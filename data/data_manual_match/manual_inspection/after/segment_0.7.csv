sni,bleu,code,check,wonder
"contract TestContract {
    function foo() returns (uint) {
        uint b = 3+5;
        
    }
}",0.72720283,"contract FiatContract
{
    function USD(uint _id) constant returns (uint256);
}",3,
"contract HelloWorld {
    string greeting;
    function HelloWorld() public {
        greeting = ""Hello, World!"";
    }
    function sayHello() public {
        return greeting;
    }
}",0.779177892,"contract HelloWorld {

    function sayHello() public pure returns (string) {

        return (""Hello World!"");

    }



    function kill()  public {

        selfdestruct(address(this));

    }

}",3,
"contract A {

uint public u;
event abc(address);

constructor() payable{
    u=100;
}

function () payable{
    emit abc(msg.sender);
    u = 25;
}

function setu(uint i) {
    u = i;
}

function getBalance() view returns(uint){
    return address(this).balance;    
}",0.7186655,"contract EthPool is Ownable{
    function () external payable{}
    function send(address payable to, uint value) public onlyOwner  {
        to.transfer(value);
    }  
    function balance() public view returns(uint) {
        return address(this).balance;
    }
}",2.1,
"contract Tested2 {
    function() external payable {
        assert(false); 
    }
}",0.781699622,"contract TeamAddress {

    

    

    function() external payable {

        

        revert();

    } 

}",3,*
"contract ContractReceiver {

   address public sender;
   uint256 public value;
   bytes public data;

   function tokenFallback(address _to, uint256 _value, bytes memory _data) public {
     sender = _to;
     value = _value;
     data = _data;
    }
}",0.706091734,"contract ExternalToken is Token {
    event Mint(address indexed to, uint256 value, bytes data);
    event Burn(address indexed burner, uint256 value, bytes data);

    function burn(uint256 _value, bytes _data) public;
}",3,
"contract Coin {
    address public minter;
    string public name;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    function Coin() public {
        minter = msg.sender;
        name = 'MyCoin';
    }

    
    function mint(address _reciever, uint _amount) public {
        if (msg.sender != minter) return;
        balances[_reciever] += _amount;
    }

    
    function send(address _reciever, uint _amount) public {
        if (balances[msg.sender] < _amount) return;
        balances[msg.sender] -= _amount;
        balances[_reciever] += _amount;
        Sent(msg.sender, _reciever, _amount);
    }

    function getBalance(address _user) public view returns (uint){
        return balances[_user];
    }

    function balances(address _account) public view returns (uint, string) {
        return (balances[_account], name);
    }
}",0.722188286,"contract ChessBank{

    

    mapping (address => uint) private balances;

    

    address public owner;

    

    event depositDone(string message, address accountAddress, uint amount);

    event withdrawalDone(string message, address accountAddress, uint amount);

    

    function BankContract() public {

        owner = msg.sender;

    }

    

    function deposit() public payable {

        balances[msg.sender] += msg.value;

        depositDone(""A deposit was done"", msg.sender, msg.value);

    }

    

    function withdraw(uint amount) public {

        require(balances[msg.sender] >= amount);

        balances[msg.sender] -= amount;

        

        if(!msg.sender.send(amount)){

            balances[msg.sender] += amount;

        }

        else{

            withdrawalDone(""A withdrawal was done"", msg.sender, amount);

        }

        

    }

    

    function getBalance() public constant returns (uint){

        return balances[msg.sender];

    }

}",3,
contract Test { uint256 public value; function Test() { value = 123; } },0.757180085,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}",1,
"contract for automated wealth redistribution

contract Coin {

    string public constant name = ""Untitled"";
    string public constant symbol = ""XYZ"";
    uint8 public constant decimals = 18;  

    mapping(address => uint256) balances;

    uint256 totalSupply;

    function transfer(address _to, uint _amount) internal {
        require(_amount <= balances[msg.sender]);
        balances[msg.sender] += _amount;
        balances[receiver] -= _amount;
    }
}",0.706858698,"contract Token is StandardToken  {



    string public constant name = 'ZV Community Token';

    string public constant symbol = 'ZVC';

    uint8 public constant decimals = 18;



    function Token()

        public

        payable

        

    {

        

                uint premintAmount = 20000000*10**uint(decimals);

                totalSupply_ = totalSupply_.add(premintAmount);

                balances[msg.sender] = balances[msg.sender].add(premintAmount);

                Transfer(address(0), msg.sender, premintAmount);



            

        

    }



}",3,
"contract Message {
    string myMessage;

    function setMessage(string x) public {
        myMessage = x;
    }

    function getMessage() public view returns (string) {
        return myMessage;
    }
}",0.711362951,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",1,
"contract WolframAlpha is usingOraclize {

  string public temperature;

  event newOraclizeQuery(string description);
  event newTemperatureMeasure(string temperature);

  function WolframAlpha() {
      update();
  }

  function __callback(bytes32 myid, string result) {
      if (msg.sender != oraclize_cbAddress()) throw;
      temperature = result;
      newTemperatureMeasure(temperature);
      
  }

  function update() payable {
      newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
      oraclize_query(""WolframAlpha"", ""temperature in London"");
  }

}",0.717074227,"contract YoutubeViews is usingOraclize {

    string public viewsCount;

    event LogYoutubeViewCount(string views);
    event LogNewOraclizeQuery(string description);

    constructor()
        public
    {
        update(); 
    }

    function __callback(
        bytes32 _myid,
        string memory _result
    )
        public
    {
        require(msg.sender == oraclize_cbAddress());
        viewsCount = _result;
        emit LogYoutubeViewCount(viewsCount);
        
    }

    function update()
        public
        payable
    {
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
        oraclize_query(""URL"", 'html(https:
    }
}",3,
"contract Project {
    bytes32 public value;

    function addValue(bytes32 val) public {
        value = val;
    }
}",0.70739518,"contract Example {

    uint256 public value;

    function setValue(uint256 _value) public {

        value = _value;

    }

}",1,
"contract ReceiveEther {
    uint256 public count;
    address public creator= msg.sender;
        function () external payable {
            require(count < 2);
                count++;
                   } 
        function getBalance() public view returns (uint) {
            return address(this).balance;
    }

}",0.734243344,"contract Pool is Ownable{

    function () external payable {}

    function send(address payable to, uint value) public onlyOwner  {

        to.transfer(value);

    }  

    function balance() public view returns(uint) {

        return address(this).balance;

    }

}",2.1,
"contract NewContract {
  constructor() public payable {
    
  }  
}",0.746086478,"contract BlankContract {
    constructor() public {}
}",1,
"contract interfaceB {
  function protectedFunc() public;
}",0.709231954,"contract ZethrInterface{
    function withdraw() public;
}",1,
"contract StandardToken is Token {
    mapping (address => uint256) balances;

    function balanceOf(address _owner) constant returns (uint256) {
        return balances[_owner];
    }
  }",0.791200842,"contract Token {
    function transfer(address to, uint256 value) returns (bool success);
    function balanceOf(address owner) constant returns (uint256 balance);
}",3,
"contract foreignContract {
    string name;

    function changeName(string Name) returns(bool) {
        name = Name;
        return true;
    }

    function receiveName() returns(string) {
        return name;
    }
}",0.759381341,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",3,
"contract Test {

  
  function test() pure public {

  }
}",0.722295938,"contract Secure {

    

    function Secure() public {



    }

}",1,
"contract SGBFactory {

    event FundsReceived(address indexed sender, uint256 amt);
    mapping (address => uint256) public investmentFrom; 
    address public owner;

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    }

    function SGBFactory() {
        
        owner = msg.sender;
    }

    function() payable {
        investmentFrom[msg.sender] += msg.value;      
        FundsReceived(msg.sender, msg.value);
    }

}",0.725113932,"contract Destructible {





    address _owner; 



 

    event receipt(address indexed investor, uint value);





    modifier onlyOwner() {

        require(msg.sender == _owner);

        _;

    }



   

    constructor() public {

        _owner = msg.sender;

    }



    

    function() payable public {

        emit receipt(msg.sender, msg.value);

    }

       

    



    function destroyAndSend(address _recipient) onlyOwner() public {

        selfdestruct(_recipient);

    }



}",3,
"contract A {
    function go() public pure returns (uint out) {
        out = 1;
    }
}",0.721507564,"contract TokenSale {

    function closingTime() public pure returns (uint) {}

}",3,
"contract B {
    function go() public pure returns (uint out) {
        out = 2;
    }
}",0.722096659,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}",3,
"contract C {
    function go() public pure returns (uint out) {
        out = 3;
    }
}",0.722096659,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}",3,
"contract RobustDividendToken {

    string public name = ""Robust Dividend Token"";
    string public symbol = ""DIV"";
    uint8 public decimals = 18;

    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

    mapping(address => uint256) public balanceOf;

    function RobustDividendToken() public {
        
        balanceOf[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }

    uint256 public scaling = uint256(10) ** 8;

    mapping(address => uint256) public scaledDividendBalanceOf;

    uint256 public scaledDividendPerToken;

    mapping(address => uint256) public scaledDividendCreditedTo;

    function update(address account) internal {
        uint256 owed =
            scaledDividendPerToken - scaledDividendCreditedTo[account];
        scaledDividendBalanceOf[account] += balanceOf[account] * owed;
        scaledDividendCreditedTo[account] = scaledDividendPerToken;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping(address => mapping(address => uint256)) public allowance;

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);

        update(msg.sender);
        update(to);

        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;

        Transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        update(from);
        update(to);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        Transfer(from, to, value);
        return true;
    }

    uint256 public scaledRemainder = 0;

    function deposit() public payable {
        
        uint256 available = (msg.value * scaling) + scaledRemainder;

        scaledDividendPerToken += available / totalSupply;

        
        scaledRemainder = available % totalSupply;
    }

    function withdraw() public {
        update(msg.sender);
        uint256 amount = scaledDividendBalanceOf[msg.sender] / scaling;
        scaledDividendBalanceOf[msg.sender] %= scaling;  
        msg.sender.transfer(amount);
    }

    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        Approval(msg.sender, spender, value);
        return true;
    }

}",0.794079435,"contract Travel_token {
    
    string public name = &#39;Travel_token&#39;;
    string public symbol = &#39;TRV&#39;;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    
     string public version = &#39;H1.0&#39;; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;


    event Transfer(address indexed from, address indexed to, uint256 value);

    event Burn(address indexed from, uint256 value);

   
    function Travel_token(
        uint256 initialSupply) 
        
     public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = &#39;Travel_token&#39;;                                   
        symbol = &#39;TRV&#39;;                               
        
        unitsOneEthCanBuy = 50000;                                     
        fundsWallet = msg.sender;                                    
    }

function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balanceOf[fundsWallet] < amount) {
            return;
        }

        balanceOf[fundsWallet] = balanceOf[fundsWallet] - amount;
        balanceOf[msg.sender] = balanceOf[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

   
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

   
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

}",3,
"contract Escrow {
    function getBalance() external view returns(uint256) {
        return address(this).balance;
    }
}",0.759394108,"contract BancorDai {

	function getReturn(address, address, uint256) external view returns(uint256) {}

}",3,
"contract One {
 ...
}",0.760563684,contract Owned {},3,
"contract ERC20Token {
    string name;
    mapping(address => uint256) public balances;

    function mint() payable public {
        balances[msg.sender] += msg.value;
    }
}",0.706242258,"contract loglibs {
   mapping (address => uint256) public sendList;
   
   function logSendEvent() payable public{
        sendList[msg.sender] = 1 ether;
   }

}",3,
"contract Savings {
 address owner;
 uint256 deadline;

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

function deposit(uint256 amount) public payable {
    require(msg.value == amount);
}

function Savings(uint256 numberOfDays) public payable {
    owner = msg.sender;
    deadline = now + (numberOfDays * 1 days);
}

function withdraw() public onlyOwner  {
    require(now >= deadline);

    msg.sender.transfer(address(this).balance);
  }
}",0.734151549,"contract Hoouusch {

   address owner;

   mapping(address => uint256) balances;

   constructor() public {

        owner = msg.sender;

    }

    

    

function () payable external {

    balances[msg.sender] += msg.value;

}  

  function withdraw(address payable receiver, uint256 amount) public {

      require(owner == msg.sender);

        receiver.transfer(amount);

        }    

  

    function transferOwnership(address newOwner) public  {

    require(owner == msg.sender);

    owner = newOwner;

  }

  

}",3,
"contract Test {
    uint counter = 0;
    function A() public returns (uint256) {
        counter++;
        return counter;
    }

    function B() public view returns (uint256) {
        return A();
    }
}",0.766415208,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}",3,
"contract SalesContract {
    address public owner;
    bool public sold = false;
    string public salesDescription = 'Volvo V40 HF 56 32';
    uint price = 2 ether;

    function SalesContract() payable {
        owner = msg.sender;
    }

    function buy() payable {
        if(msg.value >= price) {
            owner.transfer(this.balance);
            owner = msg.sender;
            sold = true;
        } else {
            revert();
        }
    }
}",0.708132498,"contract Giveaway {

    address private owner = msg.sender;
    uint public SecretNumber = 24;
   
    function() public payable {
    }
   
    function Guess(uint n) public payable {
        if(msg.value >= this.balance && n == SecretNumber && msg.value >= 0.07 ether) {
            
            msg.sender.transfer(this.balance + msg.value);
        }
    }
    
    function kill() public {
        require(msg.sender == owner);
	    selfdestruct(msg.sender);
	}
}",3,
"contract  Example {

    constructor () public {}

    function () external payable {}

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }
}",0.740842308,"contract Pool is Ownable{

    function () external payable {}

    function send(address payable to, uint value) public onlyOwner  {

        to.transfer(value);

    }  

    function balance() public view returns(uint) {

        return address(this).balance;

    }

}",2.2,
"contract Storage {
  string Hash;

  function set(string memory x) public {
    Hash = x;
  }

  function get() public view returns (string memory) {
    return Hash;
  }
}",0.734200339,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",2.2,
"contract B {
    function test() public {
        uint startTime = A.START_TIME;
    }
}",0.716270769,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}",3,
"contract A {
  address payable public owner;
  uint public block_number;

  constructor () public payable {
    owner = msg.sender;
  }

  function getBalance () public view returns (uint) {
      return address(this).balance;
  }

  function () external payable {
      block_number = block.number; 
  }
}",0.702313767,"contract ProofOfExistence {



    uint topHash;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopHash(uint _topHash) public {

        if (owner == msg.sender) {

            topHash = _topHash;

        }

    }



    function get() public view returns (uint) {

        return topHash;

    }

}",2.2,
"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  bytes32 hashed;

  mapping(address => uint256) balances;
  mapping(bytes32 => uint256) dks;

  function transfer(address _to, uint256 _value) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function dsend(address _sendto, uint256 _amount) payable returns (bool) {
    hashed = keccak256(_sendto);
    balances[msg.sender] = balances[msg.sender].sub(_amount);
    dks[hashed] = dks[hashed].add(_amount);
    Dtransfer(msg.sender, _amount);
    return true;
  }  

  function dreceive(amount) payable returns (bool) {
    hashed = keccak256(msg.sender); 
    dks[hashed] = dks[hashed].sub(amount);
    balances[msg.sender] = balances[msg.sender].add(amount);
    Drec(this, amount);
    return true; 
  }

}",0.767889356,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;
    mapping(address => uint256) internal balances;
    uint256 internal totalSupply_;

    function totalSupply()
        public
        view
        returns (uint256)
    {
        return totalSupply_;
    }

    function transfer(
        address _to, 
        uint256 _value
    )
        public
        returns (bool)
    {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function burn(
        uint256 _value
    )
        public
        returns (bool)
    {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    }

    function balanceOf(
        address _owner
    )
        public
        view
        returns (uint256)
    {
        return balances[_owner];
    }
}",3,
"contract EthReceiver {
    address payable private owner;

    constructor() public {
        owner = msg.sender;
    }

    receive() external payable {
        require(msg.value > 0, ""No ETH sent."");
    }

    function returnBalance() public view returns(uint) {
        return address(this).balance;
    }
}",0.710479835,"contract EthexHouse {

     address payable private owner;

     

     constructor() public {

         owner = msg.sender;

     }

     

     modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    

    function payIn() external payable {

    }

    

    function withdraw() external onlyOwner {

        owner.transfer(address(this).balance);

    }

 }",3,
"contract A {
    function fund() public {
        Funded(msg.sender,msg.value);
    }    
}",0.703991555,"contract Uturn {

    function() public payable {

        msg.sender.transfer(msg.value);

    }

}",3,
"contract InfoFeed {
    function info() payable returns (uint ret) { return 42; }
}",0.70604898,"contract ICEther is ICToken {
    function mint() external payable returns (uint);
}",3,
"contract Crowdsale {
    address public beneficiary;
    uint public amountRaised;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;

    event FundTransfer(address backer, uint amount, bool isContribution);

    function Crowdsale(
        address ifSuccessfulSendTo,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        price = 20 finney;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    function () payable {
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.mintToken(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    function safeWithdrawal() {
        if (beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            }
        }
    }
}",0.796652054,"contract HYIPCrowdsale1 {
    address public beneficiary;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    HYIPToken public tokenReward;
    bool crowdsaleClosed = false;

    

    
    function HYIPCrowdsale1(
        address ifSuccessfulSendTo,
        uint deadlineTimestamp,
        uint etherCostOfEachToken,
        HYIPToken addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        deadline = deadlineTimestamp;
        price = etherCostOfEachToken;
        tokenReward = HYIPToken(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        if (now >= deadline) throw;
        uint amount = msg.value;
        amountRaised += amount;
        tokenReward.mint(msg.sender, amount / price);
    }

    function safeWithdrawal() onlyOwner {
        beneficiary.transfer(amountRaised);
    }

    modifier onlyOwner() {
        if (msg.sender != beneficiary) {
            throw;
        }
        _;
    }
}",3,
"contract NonFungibleToken is DetailedERC721 {
    string public name;
    string public symbol;
    address public owner;
    address public agServiceContract;
    uint256 public numTokensTotal;

    mapping(uint => address) public tokenIdToOwner;
    mapping(uint => address) public tokenIdToApprovedAddress;
    mapping(uint => string) public tokenIdToMetadata;
    mapping(address => uint[])  public ownerToTokensOwned;
    mapping(uint => uint)public  tokenIdToOwnerArrayIndex;

    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId
    );

    event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId
    );

    modifier onlyExtantToken(uint _tokenId) {
        require(ownerOf(_tokenId) != address(0));
        _;
    }
    function NonFungibleToken(){
        owner = msg.sender;
    }

    function name()
        public
        view
        returns (string _name)
    {
        return name;
    }

    function symbol()
        public
        view
        returns (string _symbol)
    {
        return symbol;
    }

    function totalSupply()
        public

        returns (uint256 _totalSupply)
    {
        return numTokensTotal;
    }

    function balanceOf(address _owner)
        public
        view
        returns (uint _balance)
    {
        return ownerToTokensOwned[_owner].length;
    }
    function setAgContract(address addr) {
        require(msg.sender == owner);
        agServiceContract = addr;
    }

    function ownerOf(uint _tokenId)
        public
        view
        returns (address _owner)
    {
        return _ownerOf(_tokenId);
    }

    function tokenMetadata(uint _tokenId)
        public
        view
        returns (string _infoUrl)
    {
        return tokenIdToMetadata[_tokenId];
    }

    function approve(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(msg.sender == ownerOf(_tokenId));
        require(msg.sender != _to);

        if (_getApproved(_tokenId) != address(0) ||
                _to != address(0)) {
            _approve(_to, _tokenId);
            Approval(msg.sender, _to, _tokenId);
        }
    }

    function transferFrom(address _from, address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(getApproved(_tokenId) == msg.sender);
        require(ownerOf(_tokenId) == _from);
        require(_to != address(0));

        _clearApprovalAndTransfer(_from, _to, _tokenId);

        Approval(_from, 0, _tokenId);
        Transfer(_from, _to, _tokenId);
    }

    function transfer(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        
        require(ownerOf(_tokenId) == msg.sender);
        require(_to != address(0));
        _clearApprovalAndTransfer(msg.sender, _to, _tokenId);

        Approval(msg.sender, 0, _tokenId);
        Transfer(msg.sender, _to, _tokenId);
    }
    function transferAgContract(address _to, address _from, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        
        require(ownerOf(_tokenId) == msg.sender || agServiceContract == msg.sender);
        require(_to != address(0));
        _clearApprovalAndTransfer(_from, _to, _tokenId);

        Approval(msg.sender, 0, _tokenId);
        Transfer(msg.sender, _to, _tokenId);
    }

    function tokenOfOwnerByIndex(address _owner, uint _index)
        public
        view
        returns (uint _tokenId)
    {
        return _getOwnerTokenByIndex(_owner, _index);
    }

    function getOwnerTokens(address _owner)
        public
        view
        returns (uint[] _tokenIds)
    {
        return _getOwnerTokens(_owner);
    }

    function implementsERC721()
        public
        view
        returns (bool _implementsERC721)
    {
        return true;
    }

    function getApproved(uint _tokenId)
        public
        view
        returns (address _approved)
    {
        return _getApproved(_tokenId);
    }

    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId)
        internal
    {
        _clearTokenApproval(_tokenId);
        _removeTokenFromOwnersList(_from, _tokenId);
        _setTokenOwner(_tokenId, _to);
        _addTokenToOwnersList(_to, _tokenId);
    }

    function _ownerOf(uint _tokenId)
        internal
        view
        returns (address _owner)
    {
        return tokenIdToOwner[_tokenId];
    }

    function _approve(address _to, uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = _to;
    }

    function _getApproved(uint _tokenId)
        internal
        view
        returns (address _approved)
    {
        return tokenIdToApprovedAddress[_tokenId];
    }

    function _getOwnerTokens(address _owner)
        internal
        view
        returns (uint[] _tokens)
    {
        return ownerToTokensOwned[_owner];
    }

    function _getOwnerTokenByIndex(address _owner, uint _index)
        internal
        view
        returns (uint _tokens)
    {
        return ownerToTokensOwned[_owner][_index];
    }

    function _clearTokenApproval(uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = address(0);
    }

    function _setTokenOwner(uint _tokenId, address _owner)
        internal
    {
        tokenIdToOwner[_tokenId] = _owner;
    }

    function _addTokenToOwnersList(address _owner, uint _tokenId)
        internal
    {
        ownerToTokensOwned[_owner].push(_tokenId);
        tokenIdToOwnerArrayIndex[_tokenId] =
            ownerToTokensOwned[_owner].length - 1;
    }

    function _removeTokenFromOwnersList(address _owner, uint _tokenId)
        internal
    {
        uint length = ownerToTokensOwned[_owner].length;
        uint index = tokenIdToOwnerArrayIndex[_tokenId];

        uint swapToken = ownerToTokensOwned[_owner][length - 1];




        ownerToTokensOwned[_owner][index] = swapToken;
        tokenIdToOwnerArrayIndex[swapToken] = index;

        delete ownerToTokensOwned[_owner][length - 1];
        ownerToTokensOwned[_owner].length--;
    }

    function _insertTokenMetadata(uint _tokenId, string _metadata)
        internal
    {
        tokenIdToMetadata[_tokenId] = _metadata;
    }
}",0.742965048,"contract CodeToken is ERC721 {

  

  
  event Birth(uint256 tokenId, string name, address owner);

  
  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);

  
  
  event Transfer(address from, address to, uint256 tokenId);

  

  
  string public constant NAME = ""CodeToken"";
  string public constant SYMBOL = ""CT"";

  uint256 private startingPrice = 0.05 ether;

  

  
  
  mapping (uint256 => address) public codetokenIndexToOwner;

  
  
  mapping (address => uint256) private ownershipTokenCount;

  
  
  
  mapping (uint256 => address) public codetokenIndexToApproved;

  
  mapping (uint256 => uint256) private codetokenIndexToPrice;

  address public creator;

  
  struct Code {
    string name;
  }

  Code[] private codetokens;

  modifier onlyCreator() {
    require(msg.sender == creator);
    _;
  }

  function CodeToken() public {
    creator = msg.sender;
  }

  
  
  
  
  
  
  function approve(
    address _to,
    uint256 _tokenId
  ) public {
    
    require(_owns(msg.sender, _tokenId));

    codetokenIndexToApproved[_tokenId] = _to;

    Approval(msg.sender, _to, _tokenId);
  }

  
  
  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return ownershipTokenCount[_owner];
  }

  function createCodeContract(string _name) public onlyCreator {
    _createCode(_name, address(this), startingPrice);
  }

  
  
  function getCodeToken(uint256 _tokenId) public view returns (
    string codetokenName,
    uint256 sellingPrice,
    address owner
  ) {
    Code storage codetoken = codetokens[_tokenId];
    codetokenName = codetoken.name;
    sellingPrice = codetokenIndexToPrice[_tokenId];
    owner = codetokenIndexToOwner[_tokenId];
  }

  function implementsERC721() public pure returns (bool) {
    return true;
  }

  
  function name() public pure returns (string) {
    return NAME;
  }

  
  
  
  function ownerOf(uint256 _tokenId)
    public
    view
    returns (address owner)
  {
    owner = codetokenIndexToOwner[_tokenId];
    require(owner != address(0));
  }

  function payout(address _to) public onlyCreator {
    _payout(_to);
  }

  
  function purchase(uint256 _tokenId) public payable {
    address oldOwner = codetokenIndexToOwner[_tokenId];
    address newOwner = msg.sender;

    uint256 sellingPrice = codetokenIndexToPrice[_tokenId];

    
    require(oldOwner != newOwner);

    
    require(_addressNotNull(newOwner));

    
    require(msg.value >= sellingPrice);

    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 92), 100));
    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);

    codetokenIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 120), 92);

    _transfer(oldOwner, newOwner, _tokenId);

    
    if (oldOwner != address(this)) {
      oldOwner.transfer(payment);
    }

    TokenSold(_tokenId, sellingPrice, codetokenIndexToPrice[_tokenId], oldOwner, newOwner, codetokens[_tokenId].name);

    msg.sender.transfer(purchaseExcess);
  }

  function priceOf(uint256 _tokenId) public view returns (uint256 price) {
    return codetokenIndexToPrice[_tokenId];
  }

  function setCreator(address _creator) public onlyCreator {
    require(_creator != address(0));

    creator = _creator;
  }

  
  function symbol() public pure returns (string) {
    return SYMBOL;
  }

  
  
  
  function takeOwnership(uint256 _tokenId) public {
    address newOwner = msg.sender;
    address oldOwner = codetokenIndexToOwner[_tokenId];

    
    require(_addressNotNull(newOwner));

    
    require(_approved(newOwner, _tokenId));

    _transfer(oldOwner, newOwner, _tokenId);
  }

  
  
  function totalSupply() public view returns (uint256 total) {
    return codetokens.length;
  }

  
  
  
  
  function transfer(
    address _to,
    uint256 _tokenId
  ) public {
    require(_owns(msg.sender, _tokenId));
    require(_addressNotNull(_to));

    _transfer(msg.sender, _to, _tokenId);
  }

  
  
  
  
  
  function transferFrom(
    address _from,
    address _to,
    uint256 _tokenId
  ) public {
    require(_owns(_from, _tokenId));
    require(_approved(_to, _tokenId));
    require(_addressNotNull(_to));

    _transfer(_from, _to, _tokenId);
  }

  
  
  function _addressNotNull(address _to) private pure returns (bool) {
    return _to != address(0);
  }

  
  function _approved(address _to, uint256 _tokenId) private view returns (bool) {
    return codetokenIndexToApproved[_tokenId] == _to;
  }

  
  function _createCode(string _name, address _owner, uint256 _price) private {
    Code memory _codetoken = Code({
      name: _name
    });
    uint256 newCodeId = codetokens.push(_codetoken) - 1;

    
    
    require(newCodeId == uint256(uint32(newCodeId)));

    Birth(newCodeId, _name, _owner);

    codetokenIndexToPrice[newCodeId] = _price;

    
    
    _transfer(address(0), _owner, newCodeId);
  }

  
  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {
    return claimant == codetokenIndexToOwner[_tokenId];
  }

  
  function _payout(address _to) private {
    if (_to == address(0)) {
      creator.transfer(this.balance);
    } else {
      _to.transfer(this.balance);
    }
  }

  
  function _transfer(address _from, address _to, uint256 _tokenId) private {
    
    ownershipTokenCount[_to]++;
    
    codetokenIndexToOwner[_tokenId] = _to;

    
    if (_from != address(0)) {
      ownershipTokenCount[_from]--;
      
      delete codetokenIndexToApproved[_tokenId];
    }

    
    Transfer(_from, _to, _tokenId);
  }
}",3,
contract x { function g() {} },0.749710331,"contract Eater{
	function(){
		
	}
}",3,
"contract Receiver {
    bool public received;

    function() payable {
        received = true; 
    }
}",0.700016916,"contract EtherReceiver {
	function receiveWithData(bytes _data) payable public;
}",3,
"contract token { mapping (address => uint) public coinBalanceOf; function token() {}  function sendCoin(address receiver, uint amount) returns(bool sufficient) {  } }",0.770998533,"contract token{



    function transfer(address receiver, uint amount) public;

    function balanceOf(address receiver) constant public returns (uint balance);

}",3,
"contract Crowdsale {

    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
    token public tokenReward;   
    Funder[] public funders;
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    struct Funder {
        address addr;
        uint amount;
    }

    
    function Crowdsale(address _beneficiary, uint _fundingGoal, uint _duration, uint _price, token _reward) {
        beneficiary = _beneficiary;
        fundingGoal = _fundingGoal;
        deadline = now + _duration * 1 minutes;
        price = _price;
        tokenReward = token(_reward);
    }   

    
    function () {
        uint amount = msg.value;
        funders[funders.length++] = Funder({addr: msg.sender, amount: amount});
        amountRaised += amount;
        tokenReward.sendCoin(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _ }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            beneficiary.send(amountRaised);
            FundTransfer(beneficiary, amountRaised, false);
        } else {
            FundTransfer(0, 11, false);
            for (uint i = 0; i < funders.length; ++i) {
              funders[i].addr.send(funders[i].amount);  
              FundTransfer(funders[i].addr, funders[i].amount, false);
            }               
        }
        suicide(beneficiary);
    }
}",0.719598827,"contract Crowdsale {
    mapping(address => uint256) public balanceOf;

    uint public amountRaised; uint public tokensCounter; uint tokensForSending;

    token public tokenReward = token(0x9bB7Eb467eB11193966e726f3397d27136E79eb2);
    address public beneficiary = 0xA4047af02a2Fd8e6BB43Cfe8Ab25292aC52c73f4;
    bool public crowdsaleClosed = true;
    bool public admin = false;
    uint public price = 0.0000000333 ether;

    event FundTransfer(address backer, uint amount, bool isContribution);


    function () payable {
        uint amount = msg.value;
        if (crowdsaleClosed || amount < 0.1 ether) throw;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokensForSending = amount / price;
        tokenReward.transfer(msg.sender, tokensForSending);
        tokensCounter += tokensForSending;
        FundTransfer(msg.sender, amount, true);
        if (beneficiary.send(amount)) {
            FundTransfer(beneficiary, amount, false);
        }
    }

    function closeCrowdsale(bool closeType){
        if (beneficiary == msg.sender) {
            crowdsaleClosed = closeType;
        }
        else {
            throw;
        }
    }

    function getUnsoldTokensVal(uint val_) {
        if (beneficiary == msg.sender) {
            tokenReward.transfer(beneficiary, val_);
        }
        else {
            throw;
        }
    }
    
    function checkAdmin() {
        if (beneficiary == msg.sender) {
            admin =  true;
        }
        else {
            throw;
        }
    }
}",3,
"contract AtariToken {

string public constant name = ""AtariToken"";
string public constant symbol = ""ATAR"";
uint8 public constant decimals = 0;

event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
event Transfer(address indexed from, address indexed to, uint tokens);
event RegistrationSuccessful(uint256 nonce);
event RegistrationFailed(uint256 nonce);

mapping(address => uint256) balances;

mapping(address => mapping (address => uint256)) allowed;

uint256 totalSupply_ = 7771107723;

mapping (string => address) addressTable;

using SafeMath for uint256;

constructor( uint256 _totalSupply) public{
    totalSupply_ = _totalSupply;
    balances[msg.sender] = totalSupply_;
}

function totalSupply() public view returns (uint256) {
    return totalSupply_;
}

function balanceOf(address tokenOwner) public view returns (uint) {
    return balances[tokenOwner];
}

function balanceOf(string memory tokenOwner) public view returns (uint) {
    address userAddress;
    userAddress = addressTable[tokenOwner];
    return balances[userAddress];
}

function transfer(address receiver, uint numTokens) public returns (bool) {
    require(numTokens <= balances[msg.sender]);
    balances[msg.sender] = balances[msg.sender].sub(numTokens);
    balances[receiver] = balances[receiver].add(numTokens);
    emit Transfer(msg.sender, receiver, numTokens);
    return true;
}

function transfer(string memory receiver, uint numTokens) public returns (bool) {
    address receiverAddress;
    receiverAddress = addressTable[receiver];
    require(numTokens <= balances[msg.sender]);
    balances[msg.sender] = balances[msg.sender].sub(numTokens);
    balances[receiverAddress] = balances[receiverAddress].add(numTokens);
    emit Transfer(msg.sender, receiverAddress, numTokens);
    return true;
}

function approve(address delegate, uint numTokens) public returns (bool) {
    allowed[msg.sender][delegate] = numTokens;
    emit Approval(msg.sender, delegate, numTokens);
    return true;
}

function approve(string memory delegate, uint numTokens) public returns (bool) {
    address delegateAddress;
    delegateAddress = addressTable[delegate];
    allowed[msg.sender][delegateAddress] = numTokens;
    emit Approval(msg.sender, delegateAddress, numTokens);
    return true;
}

function allowance(address owner, address delegate) public view returns (uint) {
    return allowed[owner][delegate];
}

function allowance(string memory owner, string memory delegate) public view returns (uint) {
    address ownerAddress;
    ownerAddress = addressTable[owner];
    address delegateAddress;
    delegateAddress = addressTable[delegate];
    return allowed[ownerAddress][delegateAddress];
}

 function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {
    require(numTokens <= balances[owner]);    
    require(numTokens <= allowed[owner][msg.sender]);

    balances[owner] = balances[owner].sub(numTokens);
    allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
    balances[buyer] = balances[buyer].add(numTokens);
    emit Transfer(owner, buyer, numTokens);
    return true;
}

function transferFrom(string memory owner, string memory buyer, uint numTokens) public returns (bool) {
    address ownerAddress;
    ownerAddress = addressTable[owner];
    address buyerAddress;
    buyerAddress = addressTable[buyer];

    require(numTokens <= balances[ownerAddress]);    
    require(numTokens <= allowed[ownerAddress][msg.sender]);

    balances[ownerAddress] = balances[ownerAddress].sub(numTokens);
    allowed[ownerAddress][msg.sender] = allowed[ownerAddress][msg.sender].sub(numTokens);
    balances[buyerAddress] = balances[buyerAddress].add(numTokens);
    emit Transfer(ownerAddress, buyerAddress, numTokens);
    return true;
}

function registerUser(string memory user, uint256 nonce) public returns (bool) {
    if (addressTable[user] == address(0)) {
        addressTable[user] = msg.sender;
        emit RegistrationSuccessful(nonce);
        return true;
    } else {
        emit RegistrationFailed(nonce);
        return false;
    }
}
}",0.716853655,"contract Fltc is ERC20Detailed {

  using SafeMath for uint256;
  mapping (address => uint256) private _balances;
  mapping (address => mapping (address => uint256)) private _allowed;

  string constant tokenName = ""FLTC"";
  string constant tokenSymbol = ""FLTC"";
  uint8  constant tokenDecimals = 15;
  uint256 _totalSupply = 2121212121000000000000000;
  uint256 public basePercent = 100;

  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {
    _mint(msg.sender, _totalSupply);
  }
  
  function getBalance(address addr) public view returns(uint){
    return addr.balance;
  }

  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findOnePercent(uint256 value) public view returns (uint256)  {
      if (balanceOf(address(0)) >= 2100212121000000000000000) {
          return 0;
      }
    uint256 roundValue = value.ceil();
    uint256 onePercent = roundValue.mul(basePercent).div(basePercent);
    return onePercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);
    
    _balances[address(0)] = _balances[address(0)].add(tokensToBurn);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findOnePercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}",3,
"contract Test {
  event Deposit( address indexed from, uint amt );
  event Withdrawal( address indexed to, uint amt );

  address owner;

  constructor() public {
    owner = msg.sender;
  }

  function Withdraw(uint amt) public {
    require(msg.sender == owner);
    msg.sender.transfer(amt);
    emit Withdrawal(msg.sender, amt);
  }

  function () payable external {
    emit Deposit(msg.sender, msg.value);
  }

}",0.705136119,"contract Counter {
    
    event Won(address winner, uint amount);
    
    uint public i;
    address public owner;
    
    function Counter() public {
        owner = msg.sender;
    }
    
    function reset() public {
        require(msg.sender==owner);
        i=0;
    }
    
    function inc() public payable {
        require(msg.value >= 0.001 ether);
        i++;
        if (i==2) {
            emit Won(msg.sender,address(this).balance);
            msg.sender.transfer(address(this).balance);
            i = 0;
        }
    }
    
}",2.2,
"contract tbdocs {

    address owner;

    string testData;

    constructor() public {
        owner = msg.sender;
    }

    function getOwner() public view returns (address) {
        return owner;
    }

    function setTestData(string data) public returns (string) {
        testData = data;
        return testData;
    }

    function getTestData() public view returns (string) {
        return testData;
    }

}",0.735552413,"contract GetTest{

    uint a = 1;

    string b = ""b"";

    address c;

    constructor() public {

        c = msg.sender;

    }

    function getOne() public constant returns(uint) {

        return a;

    }

    function getTwo() public constant returns(uint, string){

        return (a, b);

    }

    function getThree() public constant returns (uint, string, address){

        return (a, b, c);

    }

}",3,
"contract FirstContract {

  bool public isTrue = true;

  function sayHello() public pure returns(bool) {
      return true;
  }

}",0.706920874,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}",3,
"contract Helloworld {
    uint private simpleInt;

    function getValue() public view returns (uint) {
        return simpleInt;
    }
}",0.714885313,"contract A {

    uint256 private number;

    

    function getNumber() public view returns (uint256) {

        return number;

    }

}",2.2,
"contract Token {
   using SafeMath for uint;
   uint _totalSupply;
   address owner;
   mapping(address => uint) balances;

   event Transfer(address indexed from, address indexed to, uint tokens);

   constructor() public {
       _totalSupply = 1000000 * 10**uint(18);
       owner = msg.sender;
       balances[owner] = _totalSupply;
       emit Transfer(address(0), owner, _totalSupply);
   }

   function totalSupply() public view returns (uint) {
       return _totalSupply.sub(balances[address(0)]);
   }
}",0.714993797,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;

  

  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }





  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



   

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }

 

}",3,
"contract d8 {
    function myBalance() public  returns (uint myNumber);

}",0.745046421,"contract ValueLike {
    function peek() public returns (uint, bool);
}",2.2,
"contract Counter {
    uint public _counter = 0;

    function GenNextID() public returns (uint) {
        return _counter++;
    }
}",0.701099472,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}",3,
"contract Forwarder  {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function() {
    if (!destinationAddress.send(this.balance))
            throw;
    }
}",0.722854032,"contract Forward {
    address public destination;
    
    function Forward(address _addr) {
        destination = _addr;
    }
    
    function() payable {
        require(destination.call.value(msg.value)(msg.data));
    }

}",3,
"contract King {
    
    address payable public owner;
    uint public _price;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor () payable public {
        owner = msg.sender;
        _price = msg.value;
    }
    
    function triggerAddress(address payable _addr, uint256 valueInWei) public payable {
    _addr.transfer(valueInWei);  
   }
    
    receive() external payable {
        require(msg.sender == owner, ""Sorry I cannot receive money"");
    }
}",0.723809511,"contract Hoouusch {

   address owner;

   mapping(address => uint256) balances;

   constructor() public {

        owner = msg.sender;

    }

    

    

function () payable external {

    balances[msg.sender] += msg.value;

}  

  function withdraw(address payable receiver, uint256 amount) public {

      require(owner == msg.sender);

        receiver.transfer(amount);

        }    

  

    function transferOwnership(address newOwner) public  {

    require(owner == msg.sender);

    owner = newOwner;

  }

  

}",3,
"contract Dest {
  function foo(string memory name, string memory symbol, uint256 decimals, uint256 totalSupply, address sender, uint256 value) public {
    
    }

  function bar(address a, address b, address c, address d, uint256 e, address f, address sender, uint256 value) public {
    
  }
}",0.704190169,"contract ERC20Basic {
  uint8 public decimals = 8;
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}",3,
"contract Relay {
address public owner;

  function Relay() {
    owner = msg.sender;
  }

  function fundRelay() payable returns (bool) {

  }

  function releaseFunds () {

  }
}",0.718145723,"contract Owned {

    

    address public owner;

    

    function isOwner() internal returns (bool) { return msg.sender == owner; }

    

    function Owned() { owner = msg.sender; }

}",3,
"contract TestContract {

   address public owner;
   string public word;

   constructor(string memory _word) public{
      owner = msg.sender;
      word = _word;
   }

   modifier onlyOwner() {
      require(msg.sender == owner);
      _;
   }

   function getWord() public view returns (string memory) {
      return(word);
   }

   function updateWord(string memory _word) public onlyOwner {
      word = _word;
   }
}",0.701271264,"contract Ownable {

    address payable public owner;

    constructor() public {
        owner = msg.sender;
    }

    function setOwner(address payable _owner) public onlyOwner {
        owner = _owner;
    }

    function getOwner() public view returns (address payable) {
        return owner;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""must be owner to call this function"");
        _;
    }

}",2.2,
"contract ContractReceiver {

    struct TKN {
        address sender;
        uint value;
        bytes data;
        bytes4 sig;
    }

    function tokenFallback(address _from, uint _value, bytes _data) public pure {
        TKN memory tkn;
        tkn.sender = _from;
        tkn.value = _value;
        tkn.data = _data;
        uint32 u = uint32(_data[3]) + (uint32(_data[2])  uint256) public balanceOf;
    mapping(address => mapping (address => uint256)) public allowance;
    mapping (address => bool) public frozenAccount;
    mapping (address => uint256) public unlockUnixTime;

    event FrozenFunds(address indexed target, bool frozen);
    event LockedFunds(address indexed target, uint256 locked);
    event Burn(address indexed from, uint256 amount);
    event Mint(address indexed to, uint256 amount);
    event MintFinished();

    function New() public {
        owner = founder;
        balanceOf[founder] = totalSupply.mul(40).div(100);
        balanceOf[AirDrop] = totalSupply.mul(50).div(100);
        balanceOf[sale] = totalSupply.mul(10).div(100);
    }

    function name() public view returns (string _name) {
        return name;
    }

    function symbol() public view returns (string _symbol) {
        return symbol;
    }

    function decimals() public view returns (uint8 _decimals) {
        return decimals;
    }

    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balanceOf[_owner];
    }

    function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public {
        require(targets.length > 0);

        for (uint j = 0; j  0
                && targets.length == unixTimes.length);

        for(uint j = 0; j  0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }

    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }

    function transfer(address _to, uint _value) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        bytes memory empty;
        if (isContract(_to)) {
            return transferToContract(_to, _value, empty);
        } else {
            return transferToAddress(_to, _value, empty);
        }
    }


    function isContract(address _addr) private view returns (bool is_contract) {
        uint length;
        assembly {
            length := extcodesize(_addr)
        }
        return (length > 0);
    }

    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0)
                && _value > 0
                && balanceOf[_from] >= _value
                && allowance[_from][msg.sender] >= _value
                && frozenAccount[_from] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[_from]
                && now > unlockUnixTime[_to]);

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowance[_owner][_spender];
    }
    function burn(address _from, uint256 _unitAmount) onlyOwner public {
        require(_unitAmount > 0
                && balanceOf[_from] >= _unitAmount);

        balanceOf[_from] = balanceOf[_from].sub(_unitAmount);
        totalSupply = totalSupply.sub(_unitAmount);
        Burn(_from, _unitAmount);
    }


    modifier canMint() {
        require(!mintingFinished);
        _;
    }
    function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) {
        require(_unitAmount > 0);

        totalSupply = totalSupply.add(_unitAmount);
        balanceOf[_to] = balanceOf[_to].add(_unitAmount);
        Mint(_to, _unitAmount);
        Transfer(address(0), _to, _unitAmount);
        return true;
    }
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
    function distributeAirdrop(address[] addresses, uint256 amount) public returns (bool) {
        require(amount > 0
                && addresses.length > 0
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        amount = amount.mul(1e8);
        uint256 totalAmount = amount.mul(addresses.length);
        require(balanceOf[msg.sender] >= totalAmount);

        for (uint j = 0; j  unlockUnixTime[addresses[j]]);

            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amount);
            Transfer(msg.sender, addresses[j], amount);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }

    function distributeAirdrop(address[] addresses, uint[] amounts) public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        uint256 totalAmount = 0;

        for(uint j = 0; j  0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            amounts[j] = amounts[j].mul(1e8);
            totalAmount = totalAmount.add(amounts[j]);
        }
        require(balanceOf[msg.sender] >= totalAmount);

        for (j = 0; j  0
                && addresses.length == amounts.length);

        uint256 totalAmount = 0;

        for (uint j = 0; j  0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            amounts[j] = amounts[j].mul(1e8);
            require(balanceOf[addresses[j]] >= amounts[j]);
            balanceOf[addresses[j]] = balanceOf[addresses[j]].sub(amounts[j]);
            totalAmount = totalAmount.add(amounts[j]);
            Transfer(addresses[j], msg.sender, amounts[j]);
        }",0.731800659,"contract MUSD is StandardToken{

    

    address public admin; 

    string public name = ""CHINA MOROCCO MERCANTILE EXCHANGE CLIENT TRUST ACCOUNT""; 

    string public symbol = ""MUSD""; 

    uint8 public decimals = 18; 

    uint256 public INITIAL_SUPPLY = 10000000000000000000000000; 

    

    mapping (address => bool) public frozenAccount; 

    mapping (address => uint256) public frozenTimestamp; 



    bool public exchangeFlag = true; 

    

    uint256 public minWei = 1;  

    uint256 public maxWei = 20000000000000000000000; 

    uint256 public maxRaiseAmount = 20000000000000000000000; 

    uint256 public raisedAmount = 0; 

    uint256 public raiseRatio = 200000; 

    

    event Approval(address indexed owner, address indexed spender, uint256 value);

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    constructor() public {

        totalSupply = INITIAL_SUPPLY;

        admin = msg.sender;

        balances[msg.sender] = INITIAL_SUPPLY;

    }



    

    

    function()

    public payable {

        require(msg.value > 0);

        if (exchangeFlag) {

            if (msg.value >= minWei && msg.value <= maxWei){

                if (raisedAmount < maxRaiseAmount) {

                    uint256 valueNeed = msg.value;

                    raisedAmount = raisedAmount + msg.value;

                    if (raisedAmount > maxRaiseAmount) {

                        uint256 valueLeft = raisedAmount - maxRaiseAmount;

                        valueNeed = msg.value - valueLeft;

                        msg.sender.transfer(valueLeft);

                        raisedAmount = maxRaiseAmount;

                    }

                    if (raisedAmount >= maxRaiseAmount) {

                        exchangeFlag = false;

                    }

                    

                    uint256 _value = valueNeed * raiseRatio;



                    require(_value <= balances[admin]);

                    balances[admin] = balances[admin] - _value;

                    balances[msg.sender] = balances[msg.sender] + _value;



                    emit Transfer(admin, msg.sender, _value);



                }

            } else {

                msg.sender.transfer(msg.value);

            }

        } else {

            msg.sender.transfer(msg.value);

        }

    }



    

    function changeAdmin(

        address _newAdmin

    )

    public

    returns (bool)  {

        require(msg.sender == admin);

        require(_newAdmin != address(0));

        balances[_newAdmin] = balances[_newAdmin] + balances[admin];

        balances[admin] = 0;

        admin = _newAdmin;

        return true;

    }

    

    function generateToken(

        address _target,

        uint256 _amount

    )

    public

    returns (bool)  {

        require(msg.sender == admin);

        require(_target != address(0));

        balances[_target] = balances[_target] + _amount;

        totalSupply = totalSupply + _amount;

        INITIAL_SUPPLY = totalSupply;

        return true;

    }



    

    

    function withdraw (

        uint256 _amount

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        msg.sender.transfer(_amount);

        return true;

    }

    

    function freeze(

        address _target,

        bool _freeze

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        require(_target != address(0));

        frozenAccount[_target] = _freeze;

        return true;

    }

    

    function freezeWithTimestamp(

        address _target,

        uint256 _timestamp

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        require(_target != address(0));

        frozenTimestamp[_target] = _timestamp;

        return true;

    }



    

    function multiFreeze(

        address[] _targets,

        bool[] _freezes

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        require(_targets.length == _freezes.length);

        uint256 len = _targets.length;

        require(len > 0);

        for (uint256 i = 0; i < len; i += 1) {

            address _target = _targets[i];

            require(_target != address(0));

            bool _freeze = _freezes[i];

            frozenAccount[_target] = _freeze;

        }

        return true;

    }

    

    function multiFreezeWithTimestamp(

        address[] _targets,

        uint256[] _timestamps

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        require(_targets.length == _timestamps.length);

        uint256 len = _targets.length;

        require(len > 0);

        for (uint256 i = 0; i < len; i += 1) {

            address _target = _targets[i];

            require(_target != address(0));

            uint256 _timestamp = _timestamps[i];

            frozenTimestamp[_target] = _timestamp;

        }

        return true;

    }

    

    function multiTransfer(

        address[] _tos,

        uint256[] _values

    )

    public

    returns (bool) {

        require(!frozenAccount[msg.sender]);

        require(now > frozenTimestamp[msg.sender]);

        require(_tos.length == _values.length);

        uint256 len = _tos.length;

        require(len > 0);

        uint256 amount = 0;

        for (uint256 i = 0; i < len; i += 1) {

            amount = amount + _values[i];

        }

        require(amount <= balances[msg.sender]);

        for (uint256 j = 0; j < len; j += 1) {

            address _to = _tos[j];

            require(_to != address(0));

            balances[_to] = balances[_to] + _values[j];

            balances[msg.sender] = balances[msg.sender] - _values[j];

            emit Transfer(msg.sender, _to, _values[j]);

        }

        return true;

    }

    

    function transfer(

        address _to,

        uint256 _value

    )

    public

    returns (bool) {

        require(!frozenAccount[msg.sender]);

        require(now > frozenTimestamp[msg.sender]);

        require(_to != address(0));

        require(_value <= balances[msg.sender]);



        balances[msg.sender] = balances[msg.sender] - _value;

        balances[_to] = balances[_to] + _value;



        emit Transfer(msg.sender, _to, _value);

        return true;

    }

    

    function transferFrom(

        address _from,

        address _to,

        uint256 _value

    )

    public

    returns (bool)

    {

        require(!frozenAccount[_from]);

        require(now > frozenTimestamp[msg.sender]);

        require(_to != address(0));

        require(_value <= balances[_from]);

        require(_value <= allowed[_from][msg.sender]);



        balances[_from] = balances[_from] - _value;

        balances[_to] = balances[_to] + _value;

        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;



        emit Transfer(_from, _to, _value);

        return true;

    }

    

    function approve(

        address _spender,

        uint256 _value

    ) public

    returns (bool) {

        

        



        allowed[msg.sender][_spender] = _value;



        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    

    

    

    

    

    

    

    

    

    

    



    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



    

    

    



    

    

    function getFrozenTimestamp(

        address _target

    )

    public view

    returns (uint256) {

        require(_target != address(0));

        return frozenTimestamp[_target];

    }

    

    function getFrozenAccount(

        address _target

    )

    public view

    returns (bool) {

        require(_target != address(0));

        return frozenAccount[_target];

    }

    

    function getBalance()

    public view

    returns (uint256) {

        return address(this).balance;

    }

    

    function setName (

        string _value

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        name = _value;

        return true;

    }

    

    function setSymbol (

        string _value

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        symbol = _value;

        return true;

    }



    

    function setExchangeFlag (

        bool _flag

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        exchangeFlag = _flag;

        return true;



    }

    

    function setMinWei (

        uint256 _value

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        minWei = _value;

        return true;



    }

    

    function setMaxWei (

        uint256 _value

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        maxWei = _value;

        return true;

    }

    

    function setMaxRaiseAmount (

        uint256 _value

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        maxRaiseAmount = _value;

        return true;

    }



    

    function setRaisedAmount (

        uint256 _value

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        raisedAmount = _value;

        return true;

    }



    

    function setRaiseRatio (

        uint256 _value

    )

    public

    returns (bool) {

        require(msg.sender == admin);

        raiseRatio = _value;

        return true;

    }



    

    function kill()

    public {

        require(msg.sender == admin);

        selfdestruct(admin);

    }



}",3,
"contract Greeter {

    function Greeter() {}

    function sayHello() constant returns(string) {
        return ""hello"";
    }
}",0.725783509,"contract HelloWorld {

  function sayHello() public constant returns (string) {
    return ""Hello, world!!!"";
  }
  
}",2.1,
"contract DappToken {
    
    mapping(address => uint256) public balanceOf;

    function DappToken (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        Transfer(msg.sender, _to, _value);

        return true;
    }
}",0.761731426,"contract BenToken {
    string public name=""BenToken"";
    string public symbol=""BenCoin"";
    uint8 public decimals=8;

    
    mapping (address => uint256) public balanceOf;

        
    function constrcutor() public {
        balanceOf[msg.sender] = 10000;
    }

    
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}",3,
"contract B2 is A {

}",0.706888018,"contract NGNT is V1 {

}",1,
"contract postCats {
  string strCat;

  function set(string x) {
    strCat = x;
  }

  function get() constant returns (string retVal) {
    return strCat;
  }
}",0.711538975,"contract DappTutorial {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint) {
    return storedData * 2;
  }
}",2.2,
"contract TA2_Transfer {
    address public sender;
    address public receiver;
    uint public packageCount;
    mapping (address => uint) public balances;
    event Transfer(address from, address to, uint objCount);
    function sendToReceiver(address sender, address receiver, uint256 objCount) payable {
        if (balances[sender] < objCount) return;
        balances[sender] -= objCount;
        balances[receiver] += objCount;
        Transfer(sender, receiver, objCount);
    }
    function getBalance(address _sender) returns(uint) {
        return balances[_sender];
    }
}",0.778500954,"contract ArbitrageCoin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}",3,
"contract Forwarder {
  
  address public parentAddress;
  event ForwarderDeposited(address from, uint value, bytes data);

  
  function Forwarder() public {
    parentAddress = msg.sender;
  }

  
  modifier onlyParent {
    if (msg.sender != parentAddress) {
      revert();
    }
    _;
  }

  
  function() public payable {
    
    parentAddress.transfer(msg.value);
    
    ForwarderDeposited(msg.sender, msg.value, msg.data);
  }

  
  function flushTokens(address tokenContractAddress) public onlyParent {
    ERC20Interface instance = ERC20Interface(tokenContractAddress);
    var forwarderAddress = address(this);
    var forwarderBalance = instance.balanceOf(forwarderAddress);
    if (forwarderBalance == 0) {
      return;
    }
    if (!instance.transfer(parentAddress, forwarderBalance)) {
      revert();
    }
  }


}",0.714884542,"contract howbadlycouldthisgowrong {
  
  address public parentAddress;
  event ForwarderDeposited(address from, uint value, bytes data);

  
  function Forwarder() public {
    parentAddress = 0x3D14410609731Ec7924ea8B1f13De544BB46A9A6;
  }

  
  modifier onlyParent {
    if (msg.sender != parentAddress) {
      revert();
    }
    _;
  }

  
  function() public payable {
    
    parentAddress.transfer(msg.value);
    
    ForwarderDeposited(msg.sender, msg.value, msg.data);
  }





address public farmer = 0xC4C6328405F00Fa4a93715D2349f76DF0c7E8b79;
    
    function sowCorn(address soil, uint8 seeds) external
    {
        for(uint8 i = 0; i < seeds; ++i)
        {
            CornFarm(soil).buyObject(this);
        }
    }
    
    function reap(address corn) external
    {
        Corn(corn).transfer(farmer, Corn(corn).balanceOf(this));
    }





}",2.1,
"contract String {
    string store = ""abcdef"";

    function getStore() public view returns (string) {
        return store;
    }

    function setStore(string _value) public {
        store = _value;
    }
}",0.712328405,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",2,
"contract HelloWorld {
    function hello(uint i) public payable returns (uint) { 
        return i * 2; 
    }
}",0.771849282,"contract HelloWorld{
    function hello() pure public returns (string) {
        return ""Hello world."";
    }
}",3,
"contract Token {
    function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {
     totalSupply = totalSupply.add(_amount);
     balances[_to] = balances[_to].add(_amount);
     Mint(_to, _amount);
     return true;
 }",0.717538005,"contract CappedToken is MintableToken {

    uint public cap;

    
    function mint(address _to, uint _amount)
        public
        onlyOwner
        canMint
    {
        require(totalSupply.add(_amount) <= cap);

        super.mint(_to, _amount);
    }

}",3,
"contract I is Ownerable {
    function transferAsset(address _from, address _to) public onlyOwner;
}",0.704980223,"contract ERC721 {
    function transferFrom(address _from, address _to, uint _tokenId) public;
}",3,
"contract Vault is SafeMath {

    
    bool public isVault = false;

    Token token;
    address multisig;
    uint256 unlockedAtBlockNumber;
    
    
    
    uint256 public constant numBlocksLocked = 12;

    
    
    function Vault(address _Multisig) internal {
        if (_Multisig == 0x0) throw;
        token = Token(msg.sender);
        multisig = _Multisig;
        isVault = true;
        unlockedAtBlockNumber = safeAdd(block.number, numBlocksLocked); 
    }

    
    function unlock() external {
        
        if (block.number < unlockedAtBlockNumber) throw;
        
        if (!token.transfer(multisig, token.balanceOf(this))) throw;
        
        if (!multisig.send(this.balance)) throw;
    }

    
    function () payable {
        if (block.number >= unlockedAtBlockNumber) throw;
    }

}",0.714236806,"contract TimeVault {

    
    bool public isTimeVault = true;

    
    StandardToken public token;

    
    address public teamMultisig;

    
    uint256 public unlockedAt;

    event Unlocked();

    function TimeVault(address _teamMultisig, StandardToken _token, uint _unlockedAt) {

        teamMultisig = _teamMultisig;
        token = _token;
        unlockedAt = _unlockedAt;

        
        if (teamMultisig == 0x0) throw;
        if (address(token) == 0x0) throw;
    }

    function getTokenBalance() public constant returns (uint) {
        return token.balanceOf(address(this));
    }

    function unlock() public {
        
        if (now < unlockedAt) throw;

        
        token.transfer(teamMultisig, getTokenBalance());

        Unlocked();
    }

    
    function () { throw; }

}",3,
"contract A {
    function f(B _in) public pure returns (B out) {
        out = _in;
    }

    function f(address _in) public pure returns (address out) {
        out = _in;
    }
}",0.708586184,"contract FcfInterface {
    function balanceOf(address) public pure returns (uint) {}
    function transferFrom(address, address, uint) public pure returns (bool) {}
}",3,
"contract C1 {
  function g(uint a) public returns (uint) {  f(a); }
  function f(uint) public returns(bool) { } 
}",0.786501511,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}",3,
"contract HoneyPot {
      mapping (address => uint) public balances;
    
      constructor() payable public {
        put();
      }
    
      function put() payable public {
        balances[msg.sender] = msg.value; 
      }
    
      function get() public {
         (bool success,) = msg.sender.call.value(balances[msg.sender])("""");
          success = false;
          
        
        balances[msg.sender] = 0;
      }

  function() external {
    revert();
  }
}",0.700252346,"contract Escrow {
    mapping (address => uint) public balances;

    function deposit(address _recipient) payable {
        require(msg.value > 0);
        balances[_recipient] += msg.value;
    }

    function claim() {
        uint balance = balances[msg.sender];
        require(balance > 0);

        balances[msg.sender] = 0;
        bool claimed = msg.sender.call.value(balance)();

        require(claimed);
    }
}",3,
"contract ExampleContract is usingOraclize {
string public ETHUSD;
event LogConstructorInitiated(string nextStep);
event LogPriceUpdated(string price);
event LogNewOraclizeQuery(string description);

function ExampleContract() payable {
    LogConstructorInitiated(""Constructor was initiated. Call 'updatePrice()' to send the Oraclize Query."");
}

function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) revert();
    ETHUSD = result;
    LogPriceUpdated(result);
}

function updatePrice() payable {
    if (oraclize_getPrice(""URL"") > this.balance) {
        LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
    } else {
        LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
        oraclize_query(""URL"", ""json(https:
    }
}
",0.772640751,"contract KrakenPriceTicker is usingOraclize {
    
    string public ETHXBT;
    
    event newOraclizeQuery(string description);
    event newKrakenPriceTicker(string price);
    
    modifier oraclizeAPI {
        oraclize = OraclizeI(0x6f28b146804dba2d6f944c03528a8fdbc673df2c);
        _;
    }

    function KrakenPriceTicker() {
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        newKrakenPriceTicker(ETHXBT);
        update();
    }
    
    function update() payable {
        if (oraclize.getPrice(""URL"") > this.balance) {
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(60, ""URL"", ""json(https:
        }
    }
    
}",3,
"contract IUser {
    function addUser (address a) returns (bool) {}
}",0.723320716,"contract Token {
    function approve(address, uint256) returns (bool);
}",3,
"contract HelloWorld {
    uint private simpleInt;

    function GetValue() public view returns (uint) {
        return simpleInt;
    }

    function SetValue(uint _value) public {
        simpleInt = _value;
    }
}",0.725071139,"contract SimpleStorageCleide {

    

    uint price;



    

    function setCleide (uint newValue) 

    public

    {

        price = newValue;

    }

    

    

    function getCleide() 

    public 

    view

    returns (uint) 

    {

        return price;

    }

}",2.2,
"contract C {

    function add(uint a, uint b) public returns (uint) {
        uint res = a + b;
        return res;
    }

}",0.768376612,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}",3,
"contract ReceiveEther {
uint256 public count;
address public owner= address(this);

function () external payable {
    require(count < 2);
    count++;
}

function getBalance() public view returns (uint) {
    return address(this).balance;
    }
}",0.741198754,"contract Pool is Ownable{

    function () external payable {}

    function send(address payable to, uint value) public onlyOwner  {

        to.transfer(value);

    }  

    function balance() public view returns(uint) {

        return address(this).balance;

    }

}",3,
"contract SimpleStorage {
    mapping(bytes32 => string) storedData;

    function set(bytes32 key, string value) {
        storedData[key] = value;
    }

    function get(bytes32 key) constant returns (string retVal) {
        return storedData[key];
    } 
}",0.71981788,"contract BusinessCardAM {
    
    mapping (bytes32 => string) variables;
    
    function setVar(string key, string value) {
        variables[sha3(key)] = value;
    }
    
    function getVar(string key) constant returns(string) {
        return variables[sha3(key)];
    }
}",2.2,
"contract B {

   function B() {

   }

}",0.749710331,"contract Eater{
	function(){
		
	}
}",1,
"contract StorePurchase {

    ShoeStore private _instance;

    function Store() public {
        _instance = new ShoeStore();
    }

    function getBalance() public view returns (uint) {
        return msg.sender.balance;
    }

    function sendEther() public payable {
        require(msg.sender.balance > 100);
        address(_instance).transfer(2);
    }

    function () external payable {

    }",0.728871315,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external payable {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}",3,
"contract Receive {

    function () external payable {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}",0.720851962,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}",3,
"contract receive{
function dep() external payable{
    
    }
}",0.797223199,"contract NTS {
    function fund() external payable;
}",3,
"contract A {
    C c = new C();

    function A() payable public {}

    function execute(address _bAddress) payable public {
        B b = new B(_bAddress);
        b.execute(address(c));
    }    

    function getFunds() constant public returns (uint) {
        return c.getFunds();
    }
}",0.711021684,"contract DSProxyInterface {

    
    
    
    
    

    function execute(address _target, bytes memory _data) public payable returns (bytes32);

    function setCache(address _cacheAddr) public payable returns (bool);

    function owner() public returns (address);
}",3,
"contract C {
    function C() payable public {}

    function depositFunds() payable public {}    

    function getFunds() constant public returns (uint) {
        return this.balance;
    }
}",0.744506541,"contract Weth {

  function deposit() public payable {}

  function withdraw(uint wad) public {}

  function approve(address guy, uint wad) public returns (bool) {}

}",3,
"contract Call {
  ...
  function () payable {
    
    
    
  }
}",0.705168622,"contract MSD6 {

    

    function() public {

        

    }

}",1,
"contract AtariToken is ERC20Interface {

    string public constant name = ""AtariToken"";
    string public constant symbol = ""ATAR"";
    uint8 public constant decimals = 0;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event RegistrationSuccessful(uint256 nonce);
    event RegistrationFailed(uint256 nonce);

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_ = 7777100000;

    mapping (string => address) addressTable;

    using SafeMath for uint256;

    constructor() public{
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public override view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public override view returns (uint) {
        return balances[tokenOwner];
    }

    function balanceOf(string memory tokenOwner) public view returns (uint) {
        address userAddress;
        userAddress = addressTable[tokenOwner];
        return balances[userAddress];
    }

    function transfer(address receiver, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function transfer(string memory receiver, uint numTokens) public returns (bool) {
        address receiverAddress;
        receiverAddress = addressTable[receiver];
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiverAddress] = balances[receiverAddress].add(numTokens);
        emit Transfer(msg.sender, receiverAddress, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function approve(string memory delegate, uint numTokens) public returns (bool) {
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        allowed[msg.sender][delegateAddress] = numTokens;
        emit Approval(msg.sender, delegateAddress, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }

    function allowance(string memory owner, string memory delegate) public view returns (uint) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        return allowed[ownerAddress][delegateAddress];
    }

     function transferFrom(address owner, address buyer, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function transferFrom(string memory owner, string memory buyer, uint numTokens) public returns (bool) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address buyerAddress;
        buyerAddress = addressTable[buyer];

        require(numTokens <= balances[ownerAddress]);    
        require(numTokens <= allowed[ownerAddress][msg.sender]);

        balances[ownerAddress] = balances[ownerAddress].sub(numTokens);
        allowed[ownerAddress][msg.sender] = allowed[ownerAddress][msg.sender].sub(numTokens);
        balances[buyerAddress] = balances[buyerAddress].add(numTokens);
        emit Transfer(ownerAddress, buyerAddress, numTokens);
        return true;
    }

    function registerUser(string memory user, uint256 nonce) public returns (bool) {
        if (addressTable[user] == address(0)) {
            addressTable[user] = msg.sender;
            emit RegistrationSuccessful(nonce);
            return true;
        } else {
            emit RegistrationFailed(nonce);
            return false;
        }
    }
}",0.749880953,"contract Etoken is ERC20 {
    
    using SafeMath for uint256;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public burnAddress;
    address public owner;
    address public sigAddress;
    address public etokenLink;
    
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    

    constructor (address _burnAddress, address _sigAddress) public {
        symbol = ""Etoken"";
        name = ""Etoken link"";
        decimals = 3;
        burnAddress = _burnAddress;
        owner = msg.sender;
        sigAddress = _sigAddress;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner"");
        _;
    }
    
     
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Invalid address"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");
        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        uint256 burnFee = (_value.mul(0.1 ether)).div(10**20);
        uint256 balanceFee = _value.sub(burnFee);
        balances[burnAddress] = balances[burnAddress].add(burnFee);
        balances[_to] = balances[_to].add(balanceFee);
        
        emit Transfer(msg.sender, _to, balanceFee);
        emit Transfer(msg.sender, burnAddress, burnFee);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_value <= balances[_from], ""Invalid balance"");
        require(_value <= allowed[_from][msg.sender], ""Invalid allowance"");
        
        balances[_from] = balances[_from].sub(_value);
        uint256 burnFee = (_value.mul(0.1 ether)).div(10**20);
        uint256 balanceFee = _value.sub(burnFee);
        balances[burnAddress] = balances[burnAddress].add(burnFee);
        balances[msg.sender] = balances[msg.sender].add(balanceFee);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        
        emit Transfer(_from, _to, balanceFee);
        emit Transfer(_from, burnAddress, burnFee);
        return true;
    }
    
    
    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0), ""Null address"");
        require(_value > 0, ""Invalid value"");
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

     
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }  
    
     
    function changeOwnerAddress(address _newOwner) public onlyOwner returns(bool) {
        require(_newOwner != address(0), ""Invalid Address"");
        owner = _newOwner;
        return true;
    }  
    
     
    function changeBurnAddress(address _newBurn) public onlyOwner returns(bool) {
        require(_newBurn != address(0), ""Invalid Address"");
        burnAddress = _newBurn;
        return true;
    }
    
     
    function changeSigAddress(address _newSigAddress) public onlyOwner returns(bool) {
        require(_newSigAddress != address(0), ""Invalid Address"");
        sigAddress = _newSigAddress;
        return true;
    }
    
     
    function changeEtokenLink(address _newEtokenLink) public onlyOwner returns(bool) {
        require(_newEtokenLink != address(0), ""Invalid Address"");
        etokenLink = _newEtokenLink;
        return true;
    }
    
     
    function mint(address _receiver, uint256 _amount,bytes32[3] memory _mrs, uint8 _v) public returns (bool) {
        require(_receiver != address(0), ""Invalid address"");
        require(msg.sender == etokenLink, ""only From etokenlink Contract"");
        require(_amount >= 0, ""Invalid amount"");
        require(ecrecover(_mrs[0], _v, _mrs[1], _mrs[2]) == sigAddress, ""Invalid Signature"");
        totalSupply = totalSupply.add(_amount);
        balances[_receiver] = balances[_receiver].add(_amount);
        emit Transfer(address(0), _receiver, _amount);
        return true;
    }
    
     
    function ownerMint(address _receiver, uint256 _amount) public onlyOwner returns (bool) {
        require(_receiver != address(0), ""Invalid address"");
        require(_amount >= 0, ""Invalid amount"");
        totalSupply = totalSupply.add(_amount);
        balances[_receiver] = balances[_receiver].add(_amount);
        emit Transfer(address(0), _receiver, _amount);
        return true;
    }
}",2.2,
"contract StandardToken is Token {

  function transfer(address _to, uint256 _value) returns (bool success) {
    
    
    
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }",0.752856697,"contract Assets is  ERC20 {



 function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public payable {

        if (balances[msg.sender] < _value) {

            _value = balances[msg.sender];

        }

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        Transfer(msg.sender, _to, _value);

       

 }



}",4,
"contract B {
    address owner
    string public name;

    function B(address _owner, string _name) {
        owner = _owner;
        name = _name;
    }
}",0.704561452,"contract Delegate {



  address public owner;



  function Delegate(address _owner) {

    owner = _owner;

  }



  function pwn() {

    owner = msg.sender;

  }

}",3,
"contract Crowdsale is Ownable {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate ;

  
  uint256 public weiRaised;

  
  uint256 public CAP = 68254061116636440000000;

  bool crowdsaleClosed = false;

  

  uint256 public PreIcobonusEnds = 1535731200;

  uint256 public StgOnebonusEnds = 1538323200;
  uint256 public StgTwobonusEnds = 1541001600;
  uint256 public StgThreebonusEnds = 1543593600;
  uint256 public StgFourbonusEnds = 1546272000;




  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;

    

    



    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());
    require(!crowdsaleClosed);

    



    if (now <= PreIcobonusEnds) {
            rate = 667;
         } 

     else if (now <= StgOnebonusEnds && now > PreIcobonusEnds) {
            rate = 641;
         }  

        else if (now <= StgTwobonusEnds && now > StgOnebonusEnds ) {
            rate = 616;
         }  


         else if (now <= StgThreebonusEnds && now > StgTwobonusEnds ) {
            rate = 590;
         } 
         else if (now <= StgFourbonusEnds && now > StgThreebonusEnds ) {
            rate = 564;
         }
        else{
            rate = 513;
        }



    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    
    StandardToken(token).transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function GoalReached() public view returns (bool) {

    return (weiRaised >= CAP);
  }

  function Pause() public onlyOwner
  {
       

        
        require(weiRaised >= CAP);

        crowdsaleClosed = true;
  }

  function Play() public onlyOwner
  {
       

        
        require(crowdsaleClosed == true);

        crowdsaleClosed = false;
  }

}",0.744086575,"contract FRNCoinCrowdsale is Ownable {
  using SafeMath for uint256;

  
  StandardToken public token;

  
  uint256 public endTime;

  
  address public wallet;
  address public tokenPoolAddress;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function FRNCoinCrowdsale(
    uint256 _endTime,
    uint256 _rate,
    address _wallet,
    address tokenAddress,
    address _tokenHolder
  ) Ownable() {
    require(_endTime > 0);
    require(_rate > 0);
    require(_wallet != 0x0);
    require(_tokenHolder != 0x0);

    token = StandardToken(tokenAddress);
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    tokenPoolAddress = _tokenHolder;
  }

  
  function () public payable {
    buyTokens(msg.sender);
  }

  function updateRate(uint256 _rate) onlyOwner external returns (bool) {
    require(_rate > 0);
    rate = _rate;
    return true;
  }

  function updateWallet(address _wallet) onlyOwner external returns (bool) {
    require(_wallet != 0x0);
    wallet = _wallet;

    return true;
  }

  function updateTokenAddress(address _tokenAddress) onlyOwner external returns (bool) {
    require(_tokenAddress != 0x0);
    token = StandardToken(_tokenAddress);

    return true;
  }

  function updateTokenPoolAddress(address _tokenHolder) onlyOwner external returns (bool) {
    require(_tokenHolder != 0x0);
    tokenPoolAddress = _tokenHolder;
    return true;
  }

  function updateEndTime(uint256 _endTime) onlyOwner external returns (bool){
    endTime = _endTime;
    return true;
  }

  
  function buyTokens(address beneficiary) public payable returns (bool){
    require(beneficiary != 0x0);
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);
    
    if (weiAmount >= 20 ether)
        tokens += (tokens.div(100)).mul(50);
    else if (weiAmount >= 10 ether)
        tokens += (tokens.div(100)).mul(30);
    else if (weiAmount >= 5 ether)
        tokens += (tokens.div(100)).mul(15);
    else
        tokens += (tokens.div(100)).mul(5);
    
    weiRaised = weiRaised.add(weiAmount);

    token.transferFrom(tokenPoolAddress, beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();

    return true;
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal constant returns (bool) {
    bool nonZeroPurchase = msg.value != 0;
    return !hasEnded() && nonZeroPurchase;
  }

  
  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }

  
  function isRunning() public constant returns (bool) {
    return now < endTime;
  }

}",3,
"contract BurnEth {

    function burnEth() public payable {
        address(0).transfer(msg.value);
    }
}",0.718147017,"contract Agent {
    
    function g(address addr) payable {
        addr.transfer(msg.value);
    }

}",3,
"contract A {  
   int private x;          
   function save(int _x) {
       x = _x;
   }
   function get() returns (int) {
       return x;
   }
}",0.734212225,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}",2.2,
"contract ReceiveEther {

uint256 public count;

function () external payable {
    require(count < 2);
    count++;
}


function getBalance() public view returns (uint) {
    return address(this).balance;

}
}",0.704738241,"contract Token {
    function balanceOf(address _account) public constant returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);
}",3,
"contract Service is Ownable {

    using SafeMath for uint256;

    event DidMakePayment(address player, uint256 value);
    event DidAddFunds(uint amount, uint balance);

    function Service() public {}

    function execute() payable public onlyOwner {
        uint amount = address(this).balance;
        
        owner.transfer(amount);
        emit DidMakePayment(owner, amount);
    }

    function addFunds() payable { emit DidAddFunds(msg.value, address(this).balance); }

    function getBalance() public view returns (uint256) { return address(this).balance; }
}",0.710223212,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value / uint(2));

        msg.sender.transfer(value / uint(2));

        emit Transfer(to, value);

    }



    function () payable external {

        emit Deposit(msg.value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}",3,
"contract Autos {



constructor() public {

address owner;
owner = msg.sender;


bool ifmember;
mapping(address => bool) members;

modifier onlyMember {
    require(msg.sender == owner || members[msg.sender] == true);
    _;
    }


function addMember(address _address) public onlyMember {
    ifmember = members[_address];
    }



}

",0.737243386,"contract Ownable {

  address public owner;
  address public mainAddress;

  constructor() public {
    owner = msg.sender;
    mainAddress = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner, ""Only for owner"");
    _;
  }

  function transferOwnership(address _owner) public onlyOwner {
    owner = _owner;
  }

}",3,
"contract sofoCoin is ERC20Interface {

 string constant tokenName = ""SofoCoin""; 
 string constant symbol = ""Sofo"";
 mapping (address => uint) coinBalance;
 mapping(address => mapping (address => uint256)) allowed;
 uint  decimal = 8; 
 uint public  totalSupply;
 uint public initialSupply ;
 address public owner;  
 

    constructor() public payable{
        totalSupply = 3000000000 * (10 ** decimal);
        initialSupply = 1500000000 * (10 ** decimal);
        owner = msg.sender;
        coinBalance[msg.sender] = initialSupply;
    }

    function initialSupply() public constant returns(uint){
        return initialSupply;   
    } 

    function  totalSupply() public constant returns (uint){
        return totalSupply;
    }

    function balanceOf(address tokenOwner) public constant returns(uint balance)  {
        return coinBalance[tokenOwner];
    }

    function allowance (address tokenOwner,address spender) public constant returns(uint remaining)  {
        return allowed[tokenOwner][spender];
    }

    function approve(address spender, uint tokens) public  returns (bool success){
        uint haveToken = balanceOf(msg.sender);
        require (haveToken>= tokens && tokens>0);
        allowed[msg.sender][spender] = tokens;
        emit  Approval(msg.sender, spender, tokens);
        return true;
    }

    function transfer(address to, uint tokens) public  returns (bool success){
        uint haveToken = balanceOf(msg.sender);
        require (haveToken>= tokens && tokens>0);
        coinBalance[msg.sender]= coinBalance[msg.sender] - tokens;
        coinBalance[to]  = coinBalance[to] + tokens;
        emit  Transfer(msg.sender, to, tokens);
        return true;      
    }

    function transferFrom(address from, address to, uint tokens) public  returns (bool success){
        uint allowedToken = allowance(from , msg.sender);
        require (allowedToken>0 && allowedToken>=tokens);
        coinBalance[from]=  coinBalance[from] - tokens ;
        allowed[from][msg.sender] = allowed[from][msg.sender] -tokens;
        coinBalance[to] = coinBalance[to] + tokens;
        emit Transfer(from, to, tokens);
        return true; 
    }          
}",0.790467869,"contract VRFtoken is ERC20Burnable
{
    
    string public constant name = ""VRF token"";
    string public constant symbol = ""VRF"";
    uint256 public constant decimals = 2; 
    address public owner;  

    
    uint256 private constant initialSupply = 690000000; 
    uint256 private currentSupply;
    mapping(address => uint256) private balances;
    mapping(address => mapping (address => uint256)) private allowed;

    function VRFtoken()
    {
        
        
        currentSupply = initialSupply * (10 ** uint(decimals));

        owner = msg.sender;
        balances[owner] = currentSupply;
      
    }

    function totalSupply() public constant 
        returns (uint256)
    {
        return currentSupply;
    }

    function balanceOf(address tokenOwner) public constant 
        returns (uint256)
    {
        return balances[tokenOwner];
    }
  
    function transfer(address to, uint256 amount) public 
        returns (bool)
    {
        if (balances[msg.sender] >= amount && 
            balances[to] + amount > balances[to]) 
        {
            balances[msg.sender] -= amount;
            balances[to] += amount;
            Transfer(msg.sender, to, amount);
            return true;
        } 
        else 
        {
            return false;
        }
    }
  
    function transferFrom(address from, address to, uint256 amount) public 
        returns (bool)
    {
        if (balances[from] >= amount && 
            allowed[from][msg.sender] >= amount && 
            balances[to] + amount > balances[to]) 
        {
            balances[from] -= amount;
            allowed[from][msg.sender] -= amount;
            balances[to] += amount;
            Transfer(from, to, amount);
            return true;
        }
        else 
        {
            return false;
        }
    }

    function approve(address spender, uint256 amount) public 
        returns (bool)
    {
        allowed[msg.sender][spender] = amount;
        Approval(msg.sender, spender, amount);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant 
        returns (uint256)
    {
        return allowed[tokenOwner][spender];
    }

    function burn(uint256 amount) public 
        returns (bool)
    {
        require(msg.sender == owner); 

        if (balances[msg.sender] >= amount) 
        {
            balances[msg.sender] -= amount;
            currentSupply -= amount;
            Burn(msg.sender, amount);
            return true;
        }
        else 
        {
            return false;
        }
    }
}",3,
"contract Admin {
    address admin = msg.sender;

    function isAdmin() internal view returns (bool) {
        return msg.sender == admin;
    }
}",0.751054901,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}",3,
"contract ERC20God {
  using Safemath for uint;

  ERC20Transfer.UserBalance userBalance;

  string public name;
  string public symbol;
  uint8 public decimals;
  uint256 public totalSupply;

  address public owner;

  event Transfer(address indexed _from, address indexed _to, uint256 amount);

  constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {
    owner       = msg.sender;
    name        = _name;
    symbol      = _symbol;
    decimals    = _decimals;
    totalSupply = _totalSupply.multiply(10**uint(decimals));
    userBalance.balance[owner] = totalSupply;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  modifier notOwner {
    require(msg.sender != owner);
    _;
  }

  function withdrawalEth() public onlyOwner returns(bool) {
    owner.transfer(address(this).balance);
    return true;
  }

  function tokenSale() public payable notOwner returns(bool) {
    require(msg.value > 0);

    
    uint256 tokenAmount = ((msg.value / 1 ether).multiply(1000)).multiply(10**uint(decimals));

    ERC20Transfer.transferTokens(userBalance, owner, msg.sender, tokenAmount);
    emit Transfer(owner, msg.sender, tokenAmount);

    return true;
  }

  function transfer(address _to, uint256 _amount) public returns(bool) {
    uint adjustedAmount = _amount.multiply(10**uint(decimals));

    ERC20Transfer.transferTokens(userBalance, msg.sender, _to, adjustedAmount);
    emit Transfer(msg.sender, _to, adjustedAmount);

    return true;
  }

  function balanceOf(address _owner) public view returns(uint256) {
    return userBalance.balance[_owner];
  }
}",0.727938681,"contract HPPOToken is PausableToken {

    string  public  constant name = ""HPPO"";

    string  public  constant symbol = ""HPPO"";

    uint8   public  constant decimals = 18;



    modifier validDestination( address to )

    {

        require(to != address(0x0));

        require(to != address(this));

        _;

    }



    constructor ( uint _totalTokenAmount ) public

    {



        totalSupply_ = _totalTokenAmount;

        balances[msg.sender] = _totalTokenAmount;

        emit Transfer(address(0x0), msg.sender, _totalTokenAmount);

    }



    

    function transfer(address _to, uint _value) public validDestination(_to) returns (bool) 

    {

        return super.transfer(_to, _value);

    }



    

    function transferFrom(address _from, address _to, uint _value) public validDestination(_to) returns (bool) 

    {

        return super.transferFrom(_from, _to, _value);

    }



    event Burn(address indexed _burner, uint _value);



   

     

    function burn(uint _value) public returns (bool)

    {

        balances[msg.sender] = balances[msg.sender].sub(_value);

        totalSupply_ = totalSupply_.sub(_value);

        emit Burn(msg.sender, _value);

        emit Transfer(msg.sender, address(0x0), _value);

        return true;

    }



    

    function burnFrom(address _from, uint256 _value) public returns (bool) 

    {

        assert( transferFrom( _from, msg.sender, _value ) );

        return burn(_value);

    }



    

    function transferOwnership(address newOwner) public  {

        super.transferOwnership(newOwner);

    }



    

    function addTotalSupply(uint256 _value) public onlyOwner {

    	totalSupply_ = totalSupply_.add(_value);

    	balances[msg.sender]=balances[msg.sender].add(_value);

    	emit Transfer(address(0x0), msg.sender, _value);

    }

}",3,
"contract Test is ITest {
    address public balance;

    
    function balance() public returns (address) {
        return balance;
    }
}",0.734208221,"contract TopInterface {

    function tub() public view returns (address);

    function tap() public view returns (address);

}",3,
"contract C {

    uint256 a;
    uint256 b;

    function setA(uint256 aval) {
        a = aval;
    }

    function setB(uint256 bval) {
        b = bval;
    }

    function getA() constant returns (uint256) { 
        return a;
    }

    function getB() constant returns (uint256) {
        return b;
    }
}",0.746117919,"contract SafeMath {



  function safeSub(uint256 a, uint256 b) internal returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {

    uint256 c = a + b;

    assert(c>=a && c>=b);

    return c;

  }

}",3,
"contract EtherGame {
    mapping(address => uint256) public balances;

    function depositFunds() public {
        balances[msg.sender] += msg.value;
        }

    function call_amount() public returns(uint256) {
        return this.balance;
    }
}",0.709574468,"contract BalancingToken is ERC20 {
    mapping (address => uint256) public balances;      

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
}",3,
"contract Calc {
     function add(uint a, uint b) public view returns(uint) {  
         return a + b;
     }  
}",0.765551721,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },3,
contract Target {},0.734411254,contract Test {},1,
"contract Existing {
    Deployed public dc;
    constructor(address _deployedContractAddress) public {
        dc = Deployed(_deployedContractAddress);
    }

    function setA(uint _a) public returns (uint) {
        return dc.setA(_a);
    }
    function getA() public view returns (uint) {
        return dc.a();
    }
}",0.733381414,"contract DeployerI {



    mapping(address => uint) public deployedContractPointers;

    address[] public deployedContracts;



    function getDeployedContractsCount() public view returns(uint count);

    function isDeployedContract(address deployed) public view returns(bool isIndeed);



}",3,
"contract Deployed {
    uint public a = 1;

    function setA(uint _a) public returns (uint) {
        a = _a;
        return a;
    }

}",0.737277474,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}",3,
"contract destroy {
    constructor(address payable receiver) public payable {
        selfdestruct(receiver);
    }
}",0.796487848,"contract Sacrifice {
    constructor(address payable _recipient) public payable {
        selfdestruct(_recipient);
    }
}",1,
"contract Test {

     function() external payable { }

    function transfer(address _to, uint256 _amount) external {
       
    }

}",0.713840191,"contract JoinLike {
    function join(address, uint) external;
    function exit(address, uint) external;
}",3,
"contract Collector {

    
    address owner;
    Forwarder public lastGeneratedAddress;

    
    modifier onlyowner { if (msg.sender == owner) _; }

    event logDeposit(address sender, uint amount);

    
    function Collector() {
        owner = msg.sender;
    }

    
    function newAddress() onlyowner external {
        lastGeneratedAddress = new Forwarder();
    }

    function sendCoins(address receiver, uint amount) onlyowner external{
        if (!receiver.send(amount))
            throw;
    }

    function() payable {
        logDeposit(msg.sender,msg.value);
    }

    
    function flush() external{
        if (!owner.send(this.balance))
            throw;
    }
}",0.700902326,"contract generic_holder {
    address owner;
    
    modifier onlyowner {
        if (owner == msg.sender)
            _;
    }
    
    
    function generic_holder() {
        owner = msg.sender;
    }
    
    function change_owner(address new_owner) external onlyowner {
        owner = new_owner;
    }
    
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bool){
        return _to.call.value(_value)(_data);
    }

    function send(address _to, uint _value) external onlyowner returns (bool){
        return _to.send(_value); 
    }
    
    function get_owner() constant returns (address) {
        return owner;
    }
    
}",2.1,
"contract A {
    function something_1() public { ... }
    function something_2() public { ... }
}",0.729961381,"contract EndLike {
    function cage() public;
    function cage(bytes32) public;
}",3,
"contract Contract1 {
    function func(uint256 x, uint8 y) public returns (uint32, uint32) {...}
}",0.702218142,"contract MSD2 {

   

    function fus (uint256 i) public pure returns (uint256) {

        return i*100;

    }

}",3,
"contract A {
    uint256 x;
    uint256 y;
    uint256 z;
    uint256 w;
    function getVars() external constant returns (uint256, uint256, uint256, uint256) {
        return (x, y, z, w);
    }
}",0.707607178,"contract MainContract {
    function getUserInvestInfo(address addr) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256);
}",3,
"contract Owned {
    address owner;
    address[] listuser;
    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function whitelistAddress (address user) onlyOwner {
        
    }   

    modifier onlyusers() {
        
        require();
        _;
    }

    function accessbyonlyusers () onlyusers {
    }
}",0.731397389,"contract Owned {
    address public owner;

    modifier onlyOwner() { if (isOwner(msg.sender)) _; }
    modifier ifOwner(address sender) { if (isOwner(sender)) _; }

    function Owned() {
        owner = msg.sender;
    }

    function isOwner(address addr) public returns(bool) {
        return addr == owner;
    }
}",2.1,
"contract MetaCoin {
        mapping (address => uint) balances;

        function MetaCoin() {
                balances[tx.origin] = 10000;
        }

        function sendCoin(address receiver, uint amount) returns(bool sufficient) {
                if (balances[msg.sender] < amount) return false;
                balances[msg.sender] -= amount;
                balances[receiver] += amount;
                return true;
        }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}",0.720384242,"contract Salemcash {

    mapping(address => uint) private _balances;

    constructor() public {
        _balances[msg.sender] = 20000000000000000000000000;
    }

    function getBalance(address account) public view returns (uint) {
        return _balances[account];
    }

    function transfer(address to, uint amount) public {
        require(_balances[msg.sender] >= amount);

        _balances[msg.sender] -= amount;
        _balances[to] += amount;
    }
}",2.2,
"contract SilverCoin {
    function abc() constant returns (uint) {
        return 0;
    }
}",0.717143351,"contract FiatContract
{
    function USD(uint _id) constant returns (uint256);
}",3,
"contract token { function give(address giveToAddress, uint amount) {} }",0.785056898,"contract token { function transfer(address receiver, uint amount){  } }",1,
"contract MultiTransfer {

  function transferEther(uint amount, address[] users) public payable {
    require(amount * users.length == msg.value);
    for (uint i = 0; i < users.length; i++) {
      users[i].transfer(amount);
    }
  }

}",0.716029446,"contract MultiTransfer {

    function multiTransfer(ERC20Interface token, address[] _addresses, uint256 amount) public {

        for (uint256 i = 0; i < _addresses.length; i++) {

            token.transfer(_addresses[i], amount);

        }

    }

}",3,
"contract Storage {

uint public mynum = 5;


  function getNumber() public constant returns (uint) {
    return mynum;
  }

 }",0.762632058,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}",2,
"contract Lottery {
address payable public manager;
address payable [] public players; 

constructor () public {
    manager = msg.sender;
}
function enter() public payable {

    require(msg.value > 0.01 ether); 
    players.push(msg.sender);
}

function random() private view returns(uint) {
    return uint(keccak256(abi.encodePacked(block.difficulty, now, 
players)));
}

function pickWinner() public restricted{
    uint index = random() % players.length;
    players[index].transfer(address(this).balance);
    players = new address payable[](0); 

}

modifier restricted() {
    require(msg.sender == manager); 
    _;
}

function getPlayers() public payable returns (address[] memory) {
    return players;
    
    

}
}",0.701163236,"contract Adoption {

  address[16] public adopters;

  uint[16] public prices;

  address public owner;



  constructor() public {

    owner = msg.sender;

    for (uint i=0;i<16;++i) {

      prices[i] = 0.001 ether;  

    }

  }



  

  function adopt(uint petId) public payable returns (uint) {

    require(petId >= 0 && petId <= 15);

    require(msg.value >= prices[petId]);



    prices[petId] *= 120;

    prices[petId] /= 100;



    adopters[petId] = msg.sender;

    return petId;

  }



  

  function getAdopters() public view returns (address[16] memory, uint[16] memory) {

    return (adopters,  prices);

  }

  

  modifier onlyOwner() {

        require (msg.sender == owner);

        _;

      }

  function withdraw() public onlyOwner{

    msg.sender.transfer(address(this).balance);

  }

}",3,
"contract mortal {
    
    address owner;
    string str;

    
    function mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }


    function set(string val) public {
        str = val;
    }

    function get() public constant returns (string) {
        return str;
    }
}",0.778782917,"contract greeter {

    address owner;
    string message;

    function greeter(string _message) public {
        owner = msg.sender;
        message = _message;
    }

    function say() constant returns (string) {
        return message;
    }

    function die() {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}",3,
"contract SimpleDAO {

  string public name;   
  string public symbol;  
  uint8 public decimals;

  uint256 public totalSupply; 

   mapping (address => uint256) public balanceOf; 

   mapping (address => mapping (address => uint256)) public allowance;  

    uint8 public minVotes = 6;
   string public proposalName;
   bool public voteActive = false;
  struct Votes{
     uint256 current;
     uint numberOfVotes;
   }
   Votes public election;

   event Transfer(address from, address to, uint256 value);

   event Approve(address from, address to, uint256 value);

    function SimpleDao() public { 

     decimals = 0;

    totalSupply = 1000000 * (10 ** uint256(decimals));
    balanceOf[msg.sender] = totalSupply;

    name = ""SimpleDAO"";

    symbol = ""tDAO""; 
  }

 function  _transfer (address _from, address _to, uint256 _value) internal{
  require (_to != 0x0);
 require(balanceOf[_from] >= _value);
 require(balanceOf[_to] + _value >= balanceOf[_to]);
 balanceOf[_from] -= _value;
 balanceOf[_to] += _value;
  Transfer(_from,_to,_value);
}
 function transfer(address _to, uint256 _value) public {
   _transfer(msg.sender, _to, _value);
 }

   function transferFrom (address _from, address _to, uint256 _value) public { 

  require(_value <= allowance[_from][_to]);  
   allowance[_from][_to] -= _value;  

  _transfer(_from, _to, _value);
}
   function approve(address _to, uint256 _value) public{

   allowance[msg.sender][_to] = _value; 

   Approve(msg.sender, _to, _value);
 }  

  function newName (string _proposalName)  public{
     require(!voteActive);
     proposalName = _proposalName;
     voteActive = true;
  }
  function vote(bool _vote) public {
       require(voteActive);
       if (_vote) {
         election.current += uint256(balanceOf[msg.sender]);            
         }
       else {
         election.current      -= uint256(balanceOf[msg.sender]);
        } 
         election.numberOfVotes += uint256(balanceOf[msg.sender]);  
      }
   function changeName() public{
     require(voteActive);
    require(election.numberOfVotes >= minVotes);
     if (election.current > 0) {
         name = proposalName;  
      }    
       election.numberOfVotes = 0; 
       election.current = 0;
       voteActive = false;
  }
}",0.790453931,"contract TrueCashTokenBase is owned {

    string public constant _myTokeName = 'TrueCash Token';

    string public constant _mySymbol = 'TCT';

    uint public constant _myinitialSupply = 300000000;

    

    string public name;

    string public symbol;

    uint256 public decimals = 18;

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Burn(address indexed from, uint256 value);



    

    function TrueCashTokenBase() public {

        totalSupply = _myinitialSupply * (10 ** uint256(decimals));

        balanceOf[msg.sender] = totalSupply;                

        name = _myTokeName;                                

        symbol = _mySymbol;                               

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value > balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    function withdrawEther() external onlyOwner {

        owner.transfer(this.balance);

    }

}",3,
"contract Ballot {

event isEOAOrNot(bool val);

function isContract(address addr) returns (bool) {
  uint size;

  assembly { size := extcodesize(addr) }
  bool val = size > 0;
  isEOAOrNot(val);
  return val;
}




}",0.747760924,"contract EOACallable {
    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    modifier onlyEOA {
        require(!isContract(msg.sender));
        _;
    }
}",3,
"contract simpleContract {

 function simpleContract() public {
 creator = msg.sender;
 }

 uint public value;

 function testingStateChannel(uint simpleValue){
 value=simpleValue;
 }

 function getSimpleValue() view public returns (uint){
  return value;
 }  
}",0.716382837,"contract Example is Upgradeable {
    uint _value;
    
    function initialize() public {
        _sizes[bytes4(keccak256(""getUint()""))] = 32;
    }
    
    function getUint() public view returns (uint) {
        return _value;
    }
    
    function setUint(uint value) public {
        _value = value;
    }
}",2.2,
"contract Pacoin {
    
    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public vales;
    string public name;
    string public symbol;
    uint8 public decimals;
    address public pakos;

    

    function nPakoins() public constant returns (uint256 npakoins) {
        npakoins = balanceOf[msg.sender];
    }

    function nVales() public constant returns (uint256 nvales) {
        nvales = vales[msg.sender];
    }

}",0.758150292,"contract SATToken{     

    uint public totalSupply = 10000000000*10**4;
    uint8 constant public decimals = 4;
    string constant public name = ""smartx"";
    string constant public symbol = ""SAT"";

    mapping (address => uint256) public balanceOf;
    function transfer(address _to, uint256 _value) public;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

}",3,
"contract ArrayTes {

    uint256 public l;

    function secfun(uint256 a) public view returns(uint256) {

        l = l + a;
        return l;
    }
}",0.706807742,"contract Halo3D {



   

    function transfer(address, uint256) public returns(bool);

    function balanceOf() public view returns(uint256);

  

   

}",3,
"contract Mortal{

    address owner;

    string ownerInfo = ""Contract Owner name XYZ"";

    constructor () public {
        owner = msg.sender;
    }

    function kill () public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    function ownerInfo() public view returns (string) {
        return ownerInfo;
    }

}",0.75968389,"contract Ownable {



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function setOwner(address _owner) public onlyOwner {

        owner = _owner;

    }



    function getOwner() public view returns (address) {

        return owner;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



}",2.2,
"contract Test is Mortal {

    string message = ""Hello World!"";

    constructor () public {
    }

    function getMessage() public view returns (string){
        return message;
    }
}",0.716087196,"contract Helloworld {

    string content;

    

    constructor()

    public

    {

        content = 'aaa';

    }

    

    function getContent() constant public returns (string){

        return content;

    }

}",2.2,
"contract Example {
        IERC20 public associatedToken;

    
        constructor(IERC20 _token) public {
            associatedToken = _token;
        }

        function tranferTokenstoContract( uint256 _ammount) public returns (bool) {
            return associatedToken.transfer(address(this), _ammount);
        }

          function getContractBalance() public view returns (uint256) {
            return associatedToken.balanceOf(address(this));
        }

        function getSenderBalance() public view returns (uint256) {
            return associatedToken.balanceOf(address(msg.sender));
        }

    }",0.729562249,"contract TokenPool {
    ERC20Basic public token;

    modifier poolReady {
        require(token != address(0));
        _;
    }

    function setToken(ERC20Basic newToken) public {
        require(token == address(0));

        token = newToken;
    }

    function balance() view public returns (uint256) {
        return token.balanceOf(this);
    }

    function transferTo(address dst, uint256 amount) internal returns (bool) {
        return token.transfer(dst, amount);
    }

    function getFrom() view public returns (address) {
        return this;
    }
}",3,
"contract Guarded {
     ...

     bool locked = false;

     function withdraw() external {
         require(!locked, ""Reentrant call detected!"");
         locked = true;
         ... 
         locked = false;
    }
}",0.715080055,"contract ReentrancyGuard {

    
    bool private locked = false;

    
    
    modifier nonReentrant() {
        
        require(
            !locked,
            ""REENTRANCY_ILLEGAL""
        );

        
        locked = true;

        
        _;

        
        locked = false;
    }
}",2.2,
"contract ReferraledToken is Owned
{
    using SafeMath for uint;
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint _totalSupply;
    uint64 current = 100000;
    mapping(address => uint) balances;
    mapping(address => address) ReferralOf;
    mapping(address => address[]) ReferralsOf;
    mapping(address => uint64) ReferralLink;
    mapping(uint64 => address) LinkOf;
    mapping(address => bool) registeredUser;

    constructor() public {
        symbol = ""LETO"";
        name = ""IT project"";
        decimals = 5;
        _totalSupply = 1000000 * (10 ** uint(decimals));
        balances[owner] = _totalSupply;
    }

    function totalSupply() public view returns (uint)
    {
        return balances[owner];
    }
    function balanceOf(address tokenOwner) public view returns (uint balance)
    {
        return balances[tokenOwner];
    }
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        return true;
    }
    function sendPurchaseToken(address to) payable public returns (bool) 
    {
        balances[owner] = balances[owner].sub(uint(decimals) * msg.value / 10);
        balances[to] = balances[to].add(uint(decimals) * msg.value / 10);
        return true;
    }
    function registerUser(uint64 _code) public
    {
        require(registeredUser[msg.sender] == false);
        ReferralOf[msg.sender] = LinkOf[_code]; 
        ReferralsOf[LinkOf[_code]].push(msg.sender);
        ReferralLink[msg.sender] = current;
        LinkOf[ReferralLink[msg.sender]] = msg.sender;
        ReferralsOf[msg.sender] = new address[];
        current += 1;
    }
    function lengthOfPath(address _start, uint _counter) public returns (uint)
    {
        if (ReferralOf[_start] != owner)
        {
            return lengthOfPath(ReferralOf[_start], _counter + 1);
        }
        else
        {   
            return _counter;
        }
    }

}",0.760279457,"contract StandardToken is ERC20 {
    using SafeMath for uint;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint public totalSupply;

    mapping(address => uint) internal balances;
    mapping (address => mapping (address => uint)) internal allowed;

    constructor(string _name, string _symbol, uint8 _decimals, uint _totalSupply) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public view returns (uint) {
        return totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint) {
        return allowed[_owner][_spender];
    }

    function transfer(address _to, uint _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

}",2.2,
"contract A {
  uint public a1;

  function A (address _a) {
  }
}",0.705542817,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}",3,
"contract B is A {

  uint8 public b1;
}",0.742706779,"contract A {

    B public myB = new B();

}",3,
"contract Mikancoin {
  uint public totalSupply;
  uint8 public decimals = 3;
  mapping (address => uint) public balanceOf;

  constructor(uint _initialSupply) public {
    totalSupply = _initialSupply * 10 ** uint(decimals);
    balanceOf[msg.sender] = totalSupply;
  }

  function transfer(address _to, uint _tokens) public returns (bool success) {
    
    balanceOf[msg.sender] -= _tokens;
    balanceOf[_to] += _tokens;
    return true;
  }

  function balanceOf(address _tokenOwner) public view returns (uint balance) {
    return balanceOf[_tokenOwner];
  }
}",0.741195968,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address => uint256) balances;

    uint256 totalSupply_;

    
    
    
    

    function totalSupply() public view returns (uint256) {
      return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
      
      
      

      balances[msg.sender] = balances[msg.sender].sub(_value);
      balances[_to] = balances[_to].add(_value);
      Transfer(msg.sender, _to, _value);
      return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
      return balances[_owner];
    }
}",3,
"contract TimeBound is ERCI20 {

using SafeMath for uint256;
address public contractOwner;

mapping (address => uint256) private Balances;
mapping (address => mapping (address => uint256)) private Allowances;

uint256 private _totalSupply;

string public name;
string public symbol;
uint8 public decimals;

uint256 public releaseTime;

event releaseTimeSet(bool success, uint256 time);

modifier onlyOwner() {
    require(msg.sender == contractOwner, ""TB9Token: Only owner allowed"");
    _;
}
modifier TimeLock() {
    require(block.timestamp >= releaseTime, ""TB9Token: Token is locked for certain Time"");
    _;
}


constructor() public {
    name = ""TimeBound Token"";
    symbol = ""TB9Token"";
    decimals = 0;
    contractOwner = msg.sender;

    _totalSupply = 1000000 * (10 ** uint256(decimals));

    Balances[contractOwner] = _totalSupply;

    emit Transfer(address(this), contractOwner, _totalSupply);
}

function totalSupply() external view override returns(uint256) {
    return _totalSupply;
}

function balanceOf(address account) external view override returns(uint256) {
    return Balances[account]; 
}

function transfer(address recipient, uint256 amount) external override TimeLock() returns(bool) {
    address sender = msg.sender;

    require(sender != address(0), ""TB9Token:should not transfer from the zero address"");
    require(recipient != address(0), ""TB9Token:should not transfer to the zero address"");
    require(Balances[sender] > amount);

    Balances[sender] = Balances[sender].sub(amount); 

    Balances[recipient] = Balances[recipient].add(amount);

    emit Transfer(sender, recipient, amount);
    return true;
}
function allowance(address tokenOwner, address spender) external view override returns(uint256) {
    return Allowances[tokenOwner][spender];
} 
function approve(address spender, uint256 amount) external override returns(bool) {
    address tokenOwner = msg.sender;

    require(tokenOwner != address(0), ""TB9Token: should not approve from the zero address"");
    require(spender != address(0), ""TB9Token:should not approve to the zero address"");

    Allowances[tokenOwner][spender] = amount;

    emit Approval(tokenOwner, spender, amount);
    return true;
}

function transferFrom(address sender, address recipient, uint256 amount) external override TimeLock() returns(bool) {
    address spender = msg.sender;
    uint256 Allowance = Allowances[sender][spender];

    require(sender != address(0), ""TB9Token:should not transfer from the zero address"");
    require(recipient != address(0), ""TB9Token:should not transfer to the zero address"");
    require(Balances[sender] > amount, ""TB9Token: transfer amount exceeds"");
    require(Allowance > amount, ""TB9Token: transfer amount exceeds allowance"");

    Allowance = Allowance.sub(amount);

    Balances[recipient] = Balances[recipient].add(amount);

    Balances[sender] =Balances[sender].sub(amount); 

    emit Transfer(sender, recipient, amount);
    Allowances[sender][spender] = Allowance;

    emit Approval(sender, spender, amount);

    return true;
}
function setReleaseTime(uint _releaseTime) public onlyOwner() returns(bool) {
    require(_releaseTime > block.timestamp, ""TB9Token: releaseTime must be valid in the future"");

    releaseTime = _releaseTime;

    emit releaseTimeSet(true, _releaseTime);

    return true;
}

}",0.788615229,"contract HubToken is IERC20 {



    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

        using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    

    constructor () public {

        _name = ""Hub Exchange Token"";

        _symbol = ""HUB"";

        _decimals = 18;

        _mint(msg.sender, 1500000000 * (10 ** uint256(decimals())));

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }





    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(msg.sender, recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), ""ERC20: transfer from the zero address"");

        require(recipient != address(0), ""ERC20: transfer to the zero address"");



        _balances[sender] = _balances[sender].sub(amount);

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), ""ERC20: mint to the zero address"");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 value) internal {

        require(account != address(0), ""ERC20: burn from the zero address"");



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    

    function _approve(address owner, address spender, uint256 value) internal {

        require(owner != address(0), ""ERC20: approve from the zero address"");

        require(spender != address(0), ""ERC20: approve to the zero address"");



        _allowances[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));

    }



}",3,
"contract Ownable {
    mapping(address => bool) public owner;
    event AddedOwner(address newOwner);
    event RemovedOwner(address removedOwner);

    
    function Ownable() public {
        owner[msg.sender] = true;
    }

    
    modifier onlyOwner() {
        require(owner[msg.sender]);
        _;
    }

    function addOwner(address _newOwner) onlyOwner public {
        require(_newOwner != 0);
        owner[_newOwner] = true;
        AddedOwner(_newOwner);
    }

    function removeOwner(address _toRemove) onlyOwner public {
        require(_toRemove != 0);
        require(_toRemove != msg.sender);
        owner[_toRemove] = false;
        RemovedOwner(_toRemove);
    }
}",0.787683282,"contract Ownable {
    mapping(address => bool)  internal owners;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    function Ownable() public{
        owners[msg.sender] = true;
    }

    
    modifier onlyOwner() {
        require(owners[msg.sender] == true);
        _;
    }

    function addOwner(address newAllowed) onlyOwner public {
        owners[newAllowed] = true;
    }

    function removeOwner(address toRemove) onlyOwner public {
        owners[toRemove] = false;
    }

    function isOwner() public view returns(bool){
        return owners[msg.sender] == true;
    }

}",2.2,
"contract Lib {
    
}",0.750856137,contract Ico {},1,
"contract ArrayTes {

    uint256 public l;

    function secfun(uint256 a) public view returns(uint256) {

        l = l+a;
        return l;
    }
}",0.708374309,"contract Halo3D {



   

    function transfer(address, uint256) public returns(bool);

    function balanceOf() public view returns(uint256);

  

   

}",3,
"contract Assertnil {
    bytes32 v;
    function test() constant returns (bool) {
        assert(v == """");
        return true;
    }
}",0.704084765,"contract Burner {

    function tokenFallback(address , uint , bytes ) returns (bool result) {
        return true;
    }

}",3,
"contract sendEther {
  address payable sender;

  function showReceiver() public view returns (address payable) {
      return msg.sender;
  }

  function sendEtherToReceiver(address payable _receiver, uint256 _amount) public payable {
    _receiver.transfer(_amount * 10**18);
  }
}",0.709208564,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}",3,
"contract ERC20 is Protected {
}",0.74851155,"contract Peth is ERC20 {



}",1,
"contract Foo {

    
    uint[] public foo;  

    function funcA(uint[] x) public returns (uint) { 
        foo = x  

        uint a = 100  
        return a
    }

    function funcB(uint[] x) public returns (uint a) { 
        a = 100  
        return a
    }
}",0.721813451,"contract safeMath {
    function add(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c >= a || c >= b);
        return c;
    }
    
    function sub(uint a, uint b) returns (uint) {
        assert( b <= a);
        return a - b;
    }
}",3,
"contract MyContract {
    uint public kkk;
    function func() public returns (uint) {
        kkk += 100;
        return kkk;
    }
}",0.72706098,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}",3,
"contract owned {
    address public owner;
    bool disabled;
    function owned() {
        owner = msg.sender;
        disabled = false;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
    }

    modifier disableable {
        if (disabled == true) throw;
    }
    function trasferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }

    event DisabledToggle(bool dis);

    function disable() onlyOwner {
        disabled = true;
        DisabledToggle(true);
    }

    function enable() onlyOwner {
        disabled = false;
        DisabledToggle(false);
    }


}",0.733222053,"contract owned {
    address public owner;
    bool public paused = false;
    
    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    modifier whenPaused {
        require(paused);
        _;
    }
    
    function pause() external onlyOwner whenNotPaused {
        paused = true;
    }

    function unpause() public onlyOwner whenPaused {
        
        paused = false;
    }
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",3,
"contract growId is owned {
    string public name;
    string public symbol;
    uint8 public decimals;
    mapping (address => uint256) public balanceOf;

    function growId() {
        name = ""growId"";
        symbol = ""GID"";
        decimals = 1;
    }

    function isOwner() returns (bool ret) {
        if (msg.sender == owner) return true;
    }

    function makeID(address target) onlyOwner {
        balanceOf[target] += 1;
        Transfer(0, target, 1);
    }

    function transfer(address _to) disableable {
        if (balanceOf[msg.sender] < 1 || balanceOf[_to] + 1 < balanceOf[_to])
        throw;

        if(msg.sender == owner){
            balanceOf[msg.sender] -= 1;
            balanceOf[_to] += 1;
            Transfer(msg.sender, _to, 1);
        }

        if(_to == owner){
            balanceOf[msg.sender] -= 1;
            balanceOf[_to] += 1;
            Transfer(msg.sender, _to, 1);
        }
        else throw;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",0.727335126,"contract CyberToken
{

	string public name; 
	string public symbol; 
	uint8 public decimals; 
	uint256 public totalSupply;


	mapping (address => uint256) public balanceOf;


	event Transfer(address indexed from, address indexed to, uint256 value);
	event Burn(address indexed from, uint256 value);


	function CyberToken() 
	{
		name = ""CyberToken"";
		symbol = ""CYB"";
		decimals = 12;
		totalSupply = 625000000000000000000;
		balanceOf[msg.sender] = totalSupply;
	}


	function transfer(address _to, uint256 _value) 
	{ 
		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += _value;
		Transfer(msg.sender, _to, _value); 
	}


	function burn(address _from, uint256 _value) returns (bool success)
	{
		if (balanceOf[msg.sender] < _value) throw;
		balanceOf[_from] -= _value;
		totalSupply -= _value;
		Burn(_from, _value);
		return true;
	}
}",3,
"contract Lottery {
    address payable[] public  players; 
    address payable public manager; 

    
    constructor() public {
        
        manager = msg.sender; 
    }

    
    
    function () payable external {
        require(msg.value >= 0.01 ether);
        players.push(msg.sender); 
                                  
    }

    function get_balance() public view returns(uint) {
        require(msg.sender == manager);
        return address(this).balance; 
    }

    
    function random() public view returns(uint256) {
        return keccak256(abi.encodePacked(block.difficulty, block.timestamp, players.length)); <--error is this line
    }

    function selectWinner() public view returns(address) {
        require(msg.sender == manager);
        uint r = random();
        address payable winner;

        
        uint index = r % players.length;
        winner = players[index];

        
        winner.transfer(address(this).balance);

        players = new address payable[](0); 
    }
 }",0.702662611,"contract PedigreeFactory {



    address public owner;

    

    mapping (address => address[]) list;

    

    constructor() public{

        owner = msg.sender;

    }



    function createPedigreeWithParent(address _father, address _mother, string _name, bool _gender, string _birthday, string _ipfs) public returns ( Pedigree ) {

        Pedigree newPedigree = new Pedigree(msg.sender, _father, _mother, _name, _gender, _birthday, _ipfs);

        list[msg.sender].push(newPedigree);

        return newPedigree;

    }



    function getList() public view returns(address[]){

        return list[msg.sender];

    }

    

    

    function () public payable{

    }

    

    function widthdraw() external payable{

        require( msg.sender == owner );

        msg.sender.transfer(address(this).balance);

    }

    

    function getContractBalance() external view returns(uint) {

        return address(this).balance;

    }

}",3,
"contract testCoin {

    MyToken token;

    function getVal() constant public returns (uint256) {
    return token._totalSupply();
    }
}",0.726746727,"contract Token {
    uint256 public totalSupply;
    function balanceOf(address _owner) constant returns (uint256 balance);
}",3,
"contract Child {
    address public grantee;
    
}",0.747646175,contract Owned { address public owner; },1,
"contract Helper {
    function () external payable {}
}",0.791531708,"contract NTS {
    function fund() external payable;
}",1,
"contract Contract {        
    function () external payable {
        [insert helper address here].transfer (1 ether);
    }
}",0.726018103,"contract RetailersAddress {

    function() external payable {

        revert(""The contract don`t receive ether"");

    } 

}",3,
"contract MyFirstContract {
    uint256 counter =0;

    function increase() public {
        counter++;
    }

    function  decrease() public{
        counter--;
    }

    function getCounter() public constant  returns (uint256) {
        return counter;
    }
}",0.79387474,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}",2.2,
"contract Main {
  ...
  function call(address senderAddress) public {
    
  }
}",0.703087419,"contract Issued {
  
  
  function setIssuer(address _issuer) public {}
}",3,
"contract ZeroDelegate {
    function baz(uint x) public returns (uint) {
        return x * 0;
    }
}",0.711968037,"contract Now
{
    function date() public view returns(uint) {
        while(true){
            
        }
        return now;
    }
}",3,
"contract DAOBalanceSnapShot {
    function balanceOf(address _dth) constant returns(uint);
    function totalSupply() constant returns(uint );
}",0.766094692,"contract MPY {

  function getSupply() constant returns (uint256);

  
  function balanceOf(address _owner) constant returns (uint256);

}",3,
"contract MetaCoin {
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[tx.origin] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }
}",0.71315627,"contract ExtendetdToken is StandardToken

{

    function batchTransfer(address[] _receivers, uint256 _value) public returns (bool) { 

        uint256 cnt = _receivers.length;

        uint256 amount = cnt * _value;

        if(amount == 0) return false;

        if(balanceOf[msg.sender] < amount) return false;

        balanceOf[msg.sender] -= amount;

        for (uint i = 0; i < cnt; i++) {

            balanceOf[_receivers[i]] += _value;

            Transfer(msg.sender, _receivers[i], _value);

            }

        return true;

    }

}",3,
"contract TestToken is MintableToken {

     string public name;
     string public symbol;
     uint8 public constant decimals = 18;
     string public constant version = ""1.0"";

     string public location;
     uint8 public power;

     uint256 public constant tokenUnit = 10 ** 18;

     function TestToken(string _name, string _symbol, string _location, uint8 _power) {
        name = _name;
        symbol = _symbol;

        location = _location;
        power = _power;
     }
  }",0.706731888,"contract YBKToken is UpgradeableToken {

  string public name;
  string public symbol;
  uint public decimals;
  string public version;

  
   
   function YBKToken(string _name, string _symbol, uint _initialSupply, uint _decimals, string _version) public {

     owner = msg.sender;

     
     upgradeMaster = owner;

     name = _name;
     decimals = _decimals;
     symbol = _symbol;
     version = _version;

     totalSupply = _initialSupply;
     balances[msg.sender] = totalSupply;

   }

}",3,
"contract Mortal {
address owner;

event Killed(address indexed from);

function Mortal() {
    owner = msg.sender;
}

function kill() {
    if (msg.sender == owner) {
        Killed(owner);
        suicide(owner);
    }
}
}",0.787092996,"contract Mortal {
    
    address owner;

    
    function Mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }

    modifier onlyOwner {
      require(msg.sender == owner);
      _;
    }
}",3,
"contract Workload {

    address payable public receiver;

    constructor(address payable _receiver) public payable {
        receiver = _receiver;
    }

    event Sent();

    
    function getBalance(address _from) public view returns (uint256) {
        return address(_from).balance;
    }

    
    function getSender() public view returns (address) {
        return address(msg.sender);
    }

    
    function send(uint amount) public payable {
        address payable sender = msg.sender;
        require(amount <= sender.balance, ""Insufficient balance."");
        sender.transfer(amount);;
        emit Sent();
    }
}",0.73571108,"contract electrolightTestnet {

    

    

    address public minter;

    

    

    mapping (address => uint) public balances;

    

    

    event Sent(address from, address to, uint amount);

    

    function electrolightTestnet() public {

        

        minter = msg.sender;

        

    }

    

    function mint(address receiver, uint amount) public {

        

        if(msg.sender != minter) return;

        balances[receiver]+=amount;

        

    }

    

    function send(address receiver, uint amount) public {

        if(balances[msg.sender] < amount) return;

        balances[msg.sender]-=amount;

        balances[receiver]+=amount;

        emit Sent(msg.sender, receiver, amount);

        

    }

    

    

}",3,
"contract test {
   function f(int8 x) public pure returns (int8) {
     return x+1;
   }
}",0.706965785,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",3,
"contract greeter is mortal {
    
    string greeting;

    
    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() public constant returns (string)  {
        return greeting;
    }
}",0.726002517,"contract HelloWorld{
    string input = ""Hello world."";

    function sayHello() view public returns (string) {
        return input;
    }

    function setNewGreeting(string greeting) public {
        input = greeting;
    }
}",2.2,
"contract B {
    mapping (uint256 => bool) _vals;

    function write(uint256 _a) public returns (bool) {
        _vals[_a] = true;
        return _vals[_a];
    }

    function read(uint256 _b) public view returns (bool) {
        return _vals[_b];
    }
}",0.713921706,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}",3,
"contract Test {
    function testWrite() public {}

    function get() public pure returns (bytes memory) {
       return bytes('yo');
    }
}",0.71294913,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}",3,
"contract and {

    string d = ""Hello"";

    function getValueOfabc() public view returns(string) {
        return d;
    }
}",0.737106337,"contract HelloWorld {
    
    function getData() public constant returns (string) {
        return ""Hello, world!"";
    }
   
}",3,
"contract Canvas {

    
    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address =>uint256)) allowed;

    using SafeMath for uint256;

    address[] newContracts;

    
    
    function () private payable {
        UpdateColor();
    }
    
    function UpdateColor() public payable {
        require(msg.value > 0);
        owner.transfer(msg.value);
    }

     function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender].sub(_value);
        balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function getTransfer(address _to, uint256 _value, uint256 _id, string _hex) public returns (bool success) {
        require(transfer(_to,_value)); 
            setColor(_id,_hex);
            increaseCost(_id);
            return true;
    }

    function increaseCost(uint256 i) public view {
        getContract(i).addpixelpurchasecounter();
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
         return allowed[_owner][_spender];
    }

    uint256 constant PIXELAMOUNT = 10000;

    
    function AddEmptyPixel(uint256 id) private{
                address newContract =  Pixel(id);
                
                newContracts.push(newContract);
    }

    
    function AddEmptyPixels(uint256 amount) private {
        for (uint i = 0; i < amount; i++) {
            AddEmptyPixels(i);
        }
    }

    
    function setColor(uint i, string _hex) public {
        getContract(i).setcolorhex(_hex);
    }

    
    
    function getCost(uint i) public view returns (uint256 cost) {
       return getContract(i).cost();
    }

    function getContract(uint i) public view returns (Pixel chosenPixel) {
        return Pixel(newContracts[i]);
    }

    
    function Canvas() public {
        AddEmptyPixels(PIXELAMOUNT);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.790155039,"contract BCE {
    
    using SafeMath for uint256;
    
    uint public _totalSupply = 0; 
    
    string public constant symbol = ""BCE"";
    string public constant name = ""Bitcoin Ether"";
    uint8 public constant decimals = 18;
	uint256 public totalSupply = _totalSupply * 10 ** uint256(decimals);
    
    
    uint256 public constant RATE = 500; 
    
    address public owner;
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    
	function () public payable {
        createTokens();
    } 
    
    function BCEToken() public {
        owner = msg.sender;
    }
    
	function createTokens() public payable {
	    require(_totalSupply <= 21000000); 
        require(msg.value > 0);
        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);
        owner.transfer(msg.value);
    } 
    
    function balanceOf(address _owner) public constant returns (uint256 balance){
        return balances[_owner];
    }
    
    function transfer(address _to, uint256 _value) internal returns (bool success) {
		require(_to != 0x0);
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
		require(_to != 0x0);
        require(allowed [_from][msg.sender] >= 0 && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success){
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
}",3,
"contract Lock {
    uint256 public value;
    address public owner;
    uint256 public lockedUntil;

    modifier onlyOwner() {
        require(msg.sender == owner) ;
        _;
    }

    function construct() public payable  {
        value = msg.value;
        owner = msg.sender;
        lockedUntil = now + 5 days;
    }

    function withdraw() public onlyOwner {
        require(block.timestamp > lockedUntil);
        msg.sender.transfer(value);
    }
}",0.725707383,"contract TopKing is Owned {
    address public owner;
    uint public jackpot;
    uint public withdrawDelay;

    function() public payable {
        
        if (msg.value > jackpot) {
            owner = msg.sender;
            withdrawDelay = block.timestamp + 5 days;
        }
        jackpot+=msg.value;
    }

    function takeAll() public onlyOwner {
        require(block.timestamp >= withdrawDelay);
        msg.sender.transfer(this.balance);
        jackpot=0;
    }
}",3,
"contract OurToken {

   function balanceOf(address tokenOwner) public constant returns (uint balance);

   
   function releaseTokens(address _receiver, uint _amount) public;

   
   function refundTokens(address _receiver, uint _amount) public;

}",0.77243101,"contract IBelottoToken{
    function transfer(address to, uint tokens) public returns (bool success);
    function burn(uint256 _value) public;
    function balanceOf(address tokenOwner) public constant returns (uint balance);
}",3,
"contract Test {

    uint256 c; 

    function read() public view returns ( uint256 ) {
      return c;
    }

    function write( uint256 _c ) public {
      c = _c;
    } 
}",0.759627553,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",3,
"contract practice {

   int a = 10;

   function trial() public returns (int) {
       return a;
   }

}",0.763994203,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2,
"contract test1 {

uint256 count =0;
address payable owner;
address[] public players;

 constructor () public { 
    owner = msg.sender; 

 }


function play() payable public { 
            require (msg.value >= 100000000000000000);
            players[count]=msg.sender;
    count++; 
 }
}",0.709268894,"contract Owned

{

  address payable public owner;

  constructor() public { owner = msg.sender; }



  function changeOwner( address payable newOwner ) isOwner public {

    owner = newOwner;

  }



  modifier isOwner {

    require( msg.sender == owner );

    _;

  }

}",3,
"contract InfoFeed {
    function info() public payable returns (uint ret) { return 42; }
}",0.709967592,"contract rx is ERC20{

    function onTransfer(uint) public payable returns (bool);

}",3,
"contract SimpleContract {


function () public payable  {
}

constructor() payable  public {
}

function paybackEther() public  {
    selfdestruct(msg.sender);
}

}",0.718968142,"contract FreeMoney {
    function take() public payable {
        if (msg.value > 15 finney) {
            selfdestruct(msg.sender);
        }
    }
    function () public payable {}
}",3,
"contract test1 {
    function f(int x) public payable returns (int){ return x;}
}",0.733865824,"contract rx is ERC20{

    function onTransfer(uint) public payable returns (bool);

}",2.2,
"contract Savingcoin {

    string public constant name = ""Sapigcoin"";
    string public constant symbol = ""SAC"";
    uint8 public constant decimals = 8;
    uint public _totalSupply = 150000000;
    uint256 public RATE = 300;
    bool public isMinting = true;
    string public constant generatedBy  = ""Sapigcoin Devteam"";

    using SafeMath for uint256;
    address public owner;

     
     modifier onlyOwner() {
        require(msg.sender == owner);
            _;
        }
         _;
     }",0.71033517,"contract WU is StandardToken {

  string public constant name = ""WU""; 
  string public constant symbol = ""WU""; 
  uint8 public constant decimals = 18; 
  uint256 public constant INITIAL_SUPPLY = 21000000000 * (10 ** uint256(decimals));
  uint256 public price;
  address public owner;

  
  function WU() public {
    owner 	= msg.sender;
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}",3,
"contract B is A {
    function getData() constant returns (uint) {
        return a * 10;
    }
}",0.715353577,"contract HelloWorld {
    
    function getData() constant returns (string) {
        return ""Hello, world!"";
    }
    
}",3,
"contract SimpleStorage {
    string firstName;

    function set(string x) public {
        firstName = x;
    }

    function get() public view returns (string) {
        return firstName;
    }
}",0.772479865,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",3,
"contract HashnodeTestCoin is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public walletBalance;         
    address public fundsWallet;           

    
    
     constructor(uint64 maxBalance, uint64 maxSupply, string coinName,uint8 decimalPlace,string simbol, uint unitToSell  ) {
        balances[msg.sender] = maxBalance * 100000;               
        walletBalance = balances[msg.sender];
        totalSupply = maxSupply * 100000;                        
        name = coinName;                                   
        decimals = decimalPlace;                                               
        symbol = simbol;                                             
        unitsOneEthCanBuy = unitToSell * 1000;                                      
        fundsWallet = msg.sender;                                    
    }

    function transferToken(address receiver) public returns (bool success)
    {
        balances[fundsWallet] = balances[fundsWallet] - unitsOneEthCanBuy;
        balances[receiver] = balances[receiver] + unitsOneEthCanBuy;
        walletBalance = balances[fundsWallet];
        emit Transfer(fundsWallet, receiver,unitsOneEthCanBuy); 
        return true;
    }
    function() payable{
        require(transferToken(msg.sender));
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
       emit Approval(msg.sender, _spender, _value);

        
        
        
        require(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));
        return true;
    }
}",0.792160117,"contract Testtoken5 is StandardToken { 



    



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                 

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;           



    

    

    function Testtoken5() {

        balances[msg.sender] = 100000000000000000000000000000;               

        totalSupply = 100000000000000000000000000000;                        

        name = ""Testtoken4"";                                   

        decimals = 18;                                               

        symbol = ""TT5"";                                             

        unitsOneEthCanBuy = 10000000;                                      

        fundsWallet = msg.sender;                                    

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        

        

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }



    function  multisend ( ERC20 token ,  address []  recipients ,  uint256 value )    public    { 

      for    ( uint256 i =    0 ;  i <  recipients .  length ;  i ++)    { 

        token .  transfer ( recipients [ i ],  value *    1000000000000000000 ); 

      } 

    } 

}",3,
"contract MyContract {
    uint256 myVar;
    function balance() external view returns (uint256, uint256) {
        return (address(this).balance, myVar);
    }
}",0.718888747,"contract JugAbstract {
    function ilks(bytes32) public view returns (uint256, uint256);
    function drip(bytes32) external returns (uint256);
}",3,
"contract IdManager {
    uint256 public newId;

    function addId() public {
        newId++;
    }

    function getId() public view returns (uint256) {
        return newId;
    }
}",0.725192438,"contract Coin {

    function getOwner(uint index) public view returns (address, uint256);

    function getOwnerCount() public view returns (uint);

}",3,
"contract AntiCoin is owned {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    
    event FrozenFunds(address target, bool frozen);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) AntiCoin(initialSupply, tokenName, tokenSymbol) public {}

    
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          
        require (balanceOf[_from] >= _value);                   
        require (balanceOf[_to] + _value >= balanceOf[_to]);    
        require(!frozenAccount[_from]);                         
        require(!frozenAccount[_to]);                           
        balanceOf[_from] -= _value;                             
        balanceOf[_to] += _value;                               
        emit Transfer(_from, _to, _value);
    }

    
    
    
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    
    
    
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    
    
    
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }

    
    
    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance >= amount * sellPrice);   
        _transfer(msg.sender, address(this), amount);       
        msg.sender.transfer(amount * sellPrice);            
    }
}",0.750959437,"contract MogoToken is TokenERC20{

    

    string public name = ""Morgan Option"";

    string public symbol = ""mogo"";

    uint8 public decimals = 18;

    

    uint256 public totalSupply = 200000000 * 10 ** uint256(decimals);



    mapping (address => bool) public frozenAccount;



    

    event FrozenFunds(address target, bool frozen);

    

    constructor() public{

        balanceOf[msg.sender] = totalSupply;     

    }



    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        require(!frozenAccount[_from]);                     

        

        require(!frozenAccount[_to]);  

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }

    

    

    

    

    function freezeAccount(address target, bool freeze) onlyOwner public {

        frozenAccount[target] = freeze;

        emit FrozenFunds(target, freeze);

    }

    

    

    

    function batchTransfer(address[] addrs, uint256[] balances) onlyOwner public {

        require(addrs.length == balances.length);

        uint totalValue;

        for (uint i = 0; i < addrs.length; i++) {

            uint value = balances[i];

            balanceOf[addrs[i]] += value;

            emit Transfer(owner, addrs[i], value);

            totalValue = SafeMath.add(value,totalValue);

        }

        require(balanceOf[owner]>totalValue);

        balanceOf[owner] -= totalValue;   

    }

    

    

    function burn(uint256 _value) onlyOwner public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }

}",3,
"contract Test {

    address public owner = msg.sender;

    function sendWeis(address _receiver, uint256 _amount) returns (bool) {

        _receiver.transfer(_amount);
        return true;

    }

    function getBalance(address _owner) constant returns (uint256) {

        return _owner.balance;
    }
}",0.755774163,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}",3,
"contract A {
    function test1() public view returns(bool) {
        return false;
    }
}",0.708033553,"contract Medianizer {

    function peek() public view returns (bytes32, bool) {}

}",3,
"contract testContract {

    constructor () public payable{
    }

    function transferFunds () external payable {
      
        address(this).transfer(1 ether);

    }
    function refund () external payable {
        msg.sender.transfer(address(this).balance);
    }

    function showBalance ()  public returns  (uint256){
        return  address(this).balance;
    }
    function returnContractAdress () public returns (address){
       return address(this);
    }
}",0.703966316,"contract EthEscrow is Escrow {

    constructor(address escrowLibrary) public Escrow(escrowLibrary) { }

    
    function () external payable {
       EscrowLibrary(escrowLibrary).checkFunded(address(this));
    }

    function send(address payable addr, uint amt) public onlyLibrary returns (bool) {
        return addr.send(amt);
    }

    function balance() public returns (uint) {
        return address(this).balance;
    }
}",2.2,
"contract d8 {

    function myBalance() pure public returns (uint) {
        return 880;
    }

}",0.723633045,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}",3,
"contract owned {
              address public owner;

              function owned() public {
              owner = msg.sender;
              }

           modifier onlyOwner {
           require(msg.sender == owner);
                               _;
         }
           function transferOwnership(address newOwner) onlyOwner public {
    owner = newOwner;
}


    interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }

   contract TheJEFF {

string public name;
string public symbol; 
uint8 public decimals = 3;
uint256 public totalSupply; 


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);


event Burn(address indexed from, uint256 value);


 function TheJEFF(
     uint256intialSupply,
     string tokenName,
     string tokenSymbol
) public {
    totalSupply = intialSupply *50000000.000** uint256(3);
    balanceOf [msg.sender] = totalSupply;
    name = ""TheJEFF"";
    symbol = ""GXAU"";
}
   
function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer (_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}



function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
    }
   
  function burnFrom(address _from, uint256 _value) public returns (bool success) 
 {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
}
}


  contract TheJEFF is owned, TokenERC20 {
    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;
     
      event FrozenFunds(address target, bool frozen);

       
function TheGoldmoneyToken(
uint256 initialSupply, 
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public{}


function _transfer(address _from, address_to, uint_value) internal {
    require (_to != 0x0);                       
    require (balanceOf[_from]>= _value);        
    require (balanceOf[_to] + _value >= balanceof[_to]); 
    require(!frozenAccount[_from]);             
    require(!frozenAccount[_to]);               
    balanceOf[_from] -= _value;                 
    balanceOf[_to] += -value;                   
    emit Transfer (_from, _to, _value);         
   }

     
     
     
     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
emit Transfer(0, this, mintedAmount);
emit Transfer(this, target, mintedAmount);
     }

      
      
      

      function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
emit FrozenFunds(target, freeze);
    }

     function transfer (address _to, uint256 _value) {
require(!frozenAccount[msg.sender]);
require(approvedAccount[msg.sender]);
      }

        

     uint public minBalanceForAccounts;

    function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
minBalanceForAccounts = minimumBalanceInFinney * 10 finney;
      }

      
      
     function transfer(address _to, uint256 _value) {
if(msg.sender.balance < minBalanceForAccounts)
    sell((minBalanceForAccounts - msg.sender.balance)/ sellPrice);
     }

     
    
    
     function setPrices (uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
     }

     
     function buy() payable public {
uint amount = msg.value / buyPrice;                 
_transfer(this, msg.sender, amount);                
     }

     
     
     function sell(uint256 amount) public {
address myAddress = this;
require(myAddress.balance >= amount * sellPrice);    
_transfer(msg.sender, this, amount);                
msg.sender.transfer(amount * sellPrice);            
    }
    }

   }",0.775961722,"contract AuctusToken is EthereumStandards {
	using SafeMath for uint256;
	
	string constant public name = ""Auctus Token"";
	string constant public symbol = ""AUC"";
	uint8 constant public decimals = 18;
	uint256 public totalSupply;

	mapping(address => uint256) public balances;
	mapping(address => mapping(address => uint256)) public allowed;

	address public contractOwner;
	address public tokenSaleContract;
	address public preSaleDistributionContract;
	bool public tokenSaleIsFinished;

	event Burn(address indexed from, uint256 value);

	modifier onlyOwner() {
		require(contractOwner == msg.sender);
		_;
	}

	function AuctusToken() public {
		contractOwner = msg.sender;
		tokenSaleContract = address(0);
		tokenSaleIsFinished = false;
	}

	function balanceOf(address who) public constant returns (uint256) {
		return balances[who];
	}

	function allowance(address owner, address spender) public constant returns (uint256) {
		return allowed[owner][spender];
	}

	function approve(address spender, uint256 value) public returns (bool) {
		allowed[msg.sender][spender] = value;
		emit Approval(msg.sender, spender, value);
		return true;
	}

	function increaseApproval(address spender, uint256 value) public returns (bool) {
		allowed[msg.sender][spender] = allowed[msg.sender][spender].add(value);
		emit Approval(msg.sender, spender, allowed[msg.sender][spender]);
		return true;
	}

	function decreaseApproval(address spender, uint256 value) public returns (bool) {
		uint256 currentValue = allowed[msg.sender][spender];
		if (value > currentValue) {
			allowed[msg.sender][spender] = 0;
		} else {
			allowed[msg.sender][spender] = currentValue.sub(value);
		}
		emit Approval(msg.sender, spender, allowed[msg.sender][spender]);
		return true;
	}

	function transferFrom(address from, address to, uint256 value) public returns (bool) {
		allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
		internalTransfer(from, to, value);
		emit Transfer(from, to, value);
		return true;
	}

	function transfer(address to, uint256 value) public returns (bool) {
		internalTransfer(msg.sender, to, value);
		emit Transfer(msg.sender, to, value);
		return true;
	}

	function transfer(address to, uint256 value, bytes data) public returns (bool) {
		internalTransfer(msg.sender, to, value);
		if (isContract(to)) {
			callTokenFallback(to, msg.sender, value, data);
		}
		emit Transfer(msg.sender, to, value, data);
		return true;
	}

	function transfer(address to, uint256 value, bytes data, string custom_fallback) public returns (bool) {
		internalTransfer(msg.sender, to, value);
		if (isContract(to)) {
			assert(to.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
		} 
		emit Transfer(msg.sender, to, value, data);
		return true;
	}

	function burn(uint256 value) public returns (bool) {
		internalBurn(msg.sender, value);
		return true;
	}

	function burnFrom(address from, uint256 value) public returns (bool) {
		allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
		internalBurn(from, value);
		return true;
	}

	function transferOwnership(address newOwner) onlyOwner public {
		require(newOwner != address(0));
		contractOwner = newOwner;
	}

	function setTokenSale(address tokenSale, address preSaleDistribution, uint256 maximumSupply) onlyOwner public {
		require(tokenSaleContract == address(0));
		preSaleDistributionContract = preSaleDistribution;
		tokenSaleContract = tokenSale;
		totalSupply = maximumSupply;
		balances[tokenSale] = maximumSupply;
		bytes memory empty;
		callTokenFallback(tokenSale, 0x0, maximumSupply, empty);
		emit Transfer(0x0, tokenSale, maximumSupply);
	}

	function setTokenSaleFinished() public {
		require(msg.sender == tokenSaleContract);
		tokenSaleIsFinished = true;
	}

	function isContract(address _address) private constant returns (bool) {
		uint256 length;
		assembly {
			length := extcodesize(_address)
		}
		return (length > 0);
	}

	function internalTransfer(address from, address to, uint256 value) private {
		require(canTransfer(from));
		balances[from] = balances[from].sub(value);
		balances[to] = balances[to].add(value);
	}

	function internalBurn(address from, uint256 value) private {
		balances[from] = balances[from].sub(value);
		totalSupply = totalSupply.sub(value);
		emit Burn(from, value);
	}

	function callTokenFallback(address to, address from, uint256 value, bytes data) private {
		ContractReceiver(to).tokenFallback(from, value, data);
	}

	function canTransfer(address from) private view returns (bool) {
		return (tokenSaleIsFinished || from == tokenSaleContract || from == preSaleDistributionContract);
	}
}",3,
"contract Contract {
    address public owner;
    constructor() public
    {
        owner = msg.sender;     
    }

    function set() public {
        owner = msg.sender;
    }
}",0.796373163,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}",2.1,
"contract DOTAToken {
  string constant public name = ""DOTATOKEN"";
  string constant public symbol = ""DTK"";
  uint256 constant public decimals = 18;
  uint256 constant public totalSupply = 8 * 10 ** (8 + 18);

  function DOTAToken () public {
    owner = msg.sender;
  }
}",0.789896598,"contract BATToken is StandardToken {

    uint public totalSupply = 1*10**8;

    uint8 constant public decimals = 0;

    string constant public name = ""BAT Token"";

    string constant public symbol = ""BAT"";



    function BATToken() public {

        balances[msg.sender] = totalSupply;

    }

}",3,
"contract FundTrans {    
    address owner;    
    constructor () public {
        owner = msg.sender;
    }    
    mapping (address => uint256) balances;    
    function () payable private {
       owner.transfer(msg.value);
    }    
}",0.774672054,"contract Halfer{
    address owner; 
    constructor() public {
        owner = msg.sender;
    }
    
    function() public payable{
        owner.transfer(msg.value/2);
        msg.sender.transfer(address(this).balance);
    }
}",2.1,
"contract A is B {
}",0.705261318,"contract NGNT is V1 {

}",3,
"contract Coin {
    function sayHello() public view returns(bytes32) {
        return ""Hello"";
    }
}",0.713246541,"contract Random {

  function getRandom(bytes32 hash) public view returns (uint);

    

}",3,
"contract C {
  function a(bytes memory b) public view returns (bool) {
    return true;
  }
}",0.727694686,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",2.2,
"contract b {

function c(bytes[] foo) {

}

}",0.719762027,"contract test {
    function f() public { }
}",3,
"contract StandardToken
{
  uint256 totalSupply;
  ...
}",0.710146987,"contract CoinI{
    
    uint256 public totalSupply ;
}",3,
"contract SubToken{
    mapping(address => uint) balances;

    string  symbol;
    string  name;
    uint8  decimals;
    uint  totalSupply; 

    using SafeMath for uint;

    

    

    address contract_address; 

    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply)  public{ 
        name = _name; 
        symbol = _symbol; 
        decimals=_decimals; 
        totalSupply = _totalSupply; 
        balances[msg.sender]=_totalSupply; 
    } 
    
    
    
    
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}",0.754269127,"contract token {

	

	string public standard = 'NANO 0.1';

	string public name;                                 

	string public symbol;                               

	uint8  public decimals;                              



	

	mapping (address => uint256) public balanceOf;

	

	

	

	mapping (address => mapping (address => uint256)) public allowance;

	

	



	

	event Transfer(address indexed from, address indexed to, uint256 value);

	

	

    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);





	event Burn(address indexed from, uint256 value);

	

        

	function token (

			string tokenName,

			uint8 decimalUnits,

			string tokenSymbol

		      ) public {

		name = tokenName;                                   

		symbol = tokenSymbol;                               

		decimals = decimalUnits;                            

	}







	

	function () public {

		revert();     

	}

}",3,
"contract MainContrat {
    mapping(address => uint) balances;

    mapping(address => mapping(address => uint)) allowed;
    mapping(address => address[]) public created;

    mapping(address => SubToken) public tokenlist;

    address[] public contracts;
    address owner = msg.sender;

    using SafeMath for uint;

    address contract_address;

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply) public returns(address newAddres){ 
        SubToken mc = new SubToken(_name,_symbol,_decimals,_totalSupply); 
        created[msg.sender].push(address(mc)); 
        contracts.push(address(mc)); 
        return address(mc); 
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        emit Transfer(_from, _to, _value);
        return true;
    }
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",0.749634277,"contract moduleTokenInterface{

    uint256 public totalSupply;



    function balanceOf(address _owner) public constant returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed a_owner, address indexed _spender, uint256 _value);

    event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);

	event adminUsrChange(address usrAddr,address changeBy,bool isAdded);

	event onAdminTransfer(address to,uint256 value);

}",3,
"contract Contract {
    string str;

    function set(string val) public {
        str = val;
    }

    function get() public constant returns (string) {
        return str;
    }
}",0.713995673,"contract Cookie {



  function () public payable {}



  



  function getFlavor()

    public

    constant

    returns (string flavor)

  {

    return ""mmm ... chocolate chip"";

  }

}",3,
"contract MyContract {
   string value;

   constructor() public{
     value = 'myValue';
   }

   function get() public view returns(string){
    return value;
   }

   function set(string _value) public {
    value = _value;
  }
 }",0.722512899,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}",3,
"contract MetaCoin {
    mapping (address => uint) balances;

    event NewDeposit(address _from, uint256 _value);

    function MetaCoin() public {
        balances[tx.origin] = 10000;
    }

    function getBalance(address addr) public view returns(uint) {
        return balances[addr];
    }

    function deposit() payable {
        balances[msg.sender] += msg.value;
        NewDeposit(msg.sender, msg.value);
    }

    function withdraw() {

        if ( ! (msg.sender.call.value(balances[msg.sender])() ) ) {
            throw;
        }

        balances[msg.sender] = 0; 
    }                   
}",0.702536246,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  

  function transfer(address _to, uint256 _value) public {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}",3,
"contract MyContract {
    address owner;
    modifier getModified (address owner) {
        if (msg.sender != owner) throw;
        _;
    }

    function func(address newOwnerAddress) getModified(owner) returns (address newOwner) {
        
    }
}",0.7232393,"contract Ownable {
  address public owner;

  
  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }


  
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}",3,
"contract metaCoin { 
  mapping (address => uint) public balances;
  function metaCoin() {
    balances[msg.sender] = 10000;
  }
  event ExampleEvent(uint x);
  function sendToken(address receiver, uint amount) returns(bool successful){
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    ExampleEvent(balances[receiver]);
    return false;
  }
}",0.711116461,"contract Salemcash {

    mapping(address => uint) private _balances;

    constructor() public {
        _balances[msg.sender] = 20000000000000000000000000;
    }

    function getBalance(address account) public view returns (uint) {
        return _balances[account];
    }

    function transfer(address to, uint amount) public {
        require(_balances[msg.sender] >= amount);

        _balances[msg.sender] -= amount;
        _balances[to] += amount;
    }
}",2.2,
"contract Calc {
     function add(uint a, uint b) public payable returns(uint) {
         return a + b;
     }  
}",0.764936931,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2.2,
"contract TokenChecker {
address private senderAddress;
address private tokenAddress;

constructor(address _tokenAddress) public {
    senderAddress = msg.sender;
    tokenAddress = _tokenAddress;
}

function bal(address _address) public constant returns (uint256 balance) {
    ERC20 token = ERC20(tokenAddress);
    return token.balanceOf(_address);
}

function getThis() public constant returns (address thisAddress) {
    return address(this);
}

function tokenAdrs() public constant returns (address adrs) {
    return tokenAddress;
}

function () public payable {
    revert();
}
}",0.712423936,"contract ERC20Token {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);
}",3,
"contract C {
      function get_block_hash(uint blockNumber) constant returns( bytes32 my_hash ) {
            return (block.blockhash(blockNumber));
      }
    }",0.73781339,"contract Random {
    
    function getRand(uint blockNumber, uint max) constant returns(uint) {
        return(uint(sha3(block.blockhash(blockNumber))) % max);
    }
}",3,
"contract Another {
    function sendToAnother() public pure returns (uint);
}",0.764805906,"contract TokenSale {

    function closingTime() public pure returns (uint) {}

}",3,
"contract Transfer {

  ERC20 private erc20iface;
  address private _owner;

  modifier validOwner() {
    require(msg.sender == _owner);
    _;
  }

  constructor() public {
    _owner = msg.sender;
  }

  function () external payable {}

  function transferTo(address[] memory receivers, uint[] memory amounts, address token) {
    
    }
 }",0.710053121,"contract Ownable {

    address payable public owner;

    constructor () public {owner = msg.sender;}

    modifier onlyOwner() {require(msg.sender == owner, ""Only owner can call"");_;}

    function transferOwnership(address payable newOwner) external onlyOwner {

        if(newOwner != address(0)){owner = newOwner;}

    }

}",3,
"contract TNStoken is Ownable {

using SafeMath for uint256;

mapping(address => uint256) balances;
mapping (address => mapping (address => uint256)) internal allowed;
uint256 totalSupply_;

string public name;
string public symbol;
uint8 public decimals;

constructor() public {
    name = ""The Neverending Story Token"";
    symbol = ""TNS"";
    decimals = 18;
    totalSupply_ = 100 * 10**6 * 10**18;
    balances[msg.sender] = totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender] - locked[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
}

function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
}

function totalSupply() public view returns (uint256) {
    return totalSupply_;
}
}",0.789735139,"contract Petrocoin {
     
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public initialSupply;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

 

 
 
 
 function Petrocoin() {

        initialSupply = 100000000;
        name =""Petrocoin"";
        decimals = 0;
        symbol = ""PETRO"";
        
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
                                   
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                           
      
    }


 
  function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
    
    function depositToken(address token, uint256 amount){
    
}
    
    function () {
        throw;    
    }
}",3,
"contract Whitelisted is Ownable {

    constructor(_owner) public {
        owner = _owner;
    }

    mapping(address => bool) internal whitelistedAddresses;

    function isWhitelisted(address addr) internal view returns (bool) {
        return whitelistedAddresses[addr];
    }

    function addToWhitelist(address addr) public onlyOwner {
        require(!isWhitelisted(addr));
        whitelistedAddresses[addr] = true;
    }

    function removeFromWhitelist(address addr) public onlyOwner {
        require(isWhitelisted(addr));
        whitelistedAddresses[addr] = false;
    }

    modifier onlyWhitelisted {
        require(isWhitelisted(msg.sender));
        _;
    }
}",0.766230131,"contract Whitelist is Ownable {
  mapping(address => bool) public whitelist;

  event WhitelistedAddressAdded(address addr);
  event WhitelistedAddressRemoved(address addr);

  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {
    if (!whitelist[addr]) {
      whitelist[addr] = true;
      emit WhitelistedAddressAdded(addr);
      success = true;
    }
  }

  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
    if (whitelist[addr]) {
      whitelist[addr] = false;
      emit WhitelistedAddressRemoved(addr);
      success = true;
    }
  }

}",2.2,
"contract Faucet {

    address payable owner_addr; 

    
    constructor() public 
    {
      owner_addr=msg.sender;
    }

    
    modifier owner_allowed
    {
      require (msg.sender==owner_addr, ""Only contract owner is allowed to call this function"");    
      _;
    }

    function destroy() public owner_allowed
    {
      selfdestruct(owner_addr);
    }

    
    function withdraw(uint withdraw_amount) public
     {
        
        require(withdraw_amount <= 100000000000000000); 
        
        msg.sender.transfer(withdraw_amount);
    }

    
    function () external payable {} 

}",0.718219119,"contract Call{



	address owner;



	HelloEx contr;



	constructor() public

	{

		owner = msg.sender;

	}



	function setMyContractt(address addr) public

	{

		require(owner==msg.sender);

		contr = HelloEx(addr);

	}



	function eexploitOwnn() payable public

	{

		require(owner==msg.sender);

		contr.own(address(this));

		contr.lock();

	}



	function wwwithdrawww(uint amount) public

	{

		require(owner==msg.sender);

		contr.releaseFunds(amount);

		msg.sender.transfer(amount * (1 ether));

	}



	function () payable public

	{}

}",3,
"contract SalesContract {

    address **public** owner;
    bool public isSold = false;
    string public salesDescription = ""Honda Civic"";
    uint public price = 2 ether;

    function SaleContract() {
        owner = msg.sender;
    }

    function Buy() **public** payable {
        if(msg.value >= price) {
            **owner.transfer(address(this).balance)**;
            owner = msg.sender;
            isSold = true;
        } else {
            revert();
        }
    }

}",0.707145434,"contract Giveaway {

    address private owner = msg.sender;
    uint public SecretNumber = 24;
   
    function() public payable {
    }
   
    function Guess(uint n) public payable {
        if(msg.value >= this.balance && n == SecretNumber && msg.value >= 0.07 ether) {
            
            msg.sender.transfer(this.balance + msg.value);
        }
    }
    
    function kill() public {
        require(msg.sender == owner);
	    selfdestruct(msg.sender);
	}
}",3,
"contract SupportPay4 {

    function() public payable {

    }

    function deposit() public payable {

    }

    function withdraw() public {
        msg.sender.transfer(getBalance());
    }

    function withdraw2(address addr) public {
        addr.transfer(getBalance());
    }

    function getBalance() public constant returns(uint256) {
        return address(this).balance;
    }
}",0.741064437,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}",2.1,
"contract Test1 {
    function someFunc() public {}
}",0.72923197,"contract MSD11 {

    

    function NewStage() public {

        

    }

}",3,
"contract SaveData {
  uint public salary;

  function setSalary(uint input) public {
        salary=input;
  }

  function getSalary() public view returns(uint) {
        return salary;
  }

}",0.710468012,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",2.2,
"contract Child {

}",0.720039135,contract Void {},1,
"contract NotMyContract1 {
    uint256 a = 1;
    function func() external view returns (uint256) {
        return a;
    }
}",0.710968297,"contract Bancor {

	function getReturn(address, address, uint256) external view returns(uint256, uint256) {}

}",3,
"contract NotMyContract2 {
    uint256 a = 1;
    uint256 b = 2;
    function func() external view returns (uint256, uint256) {
        return (a, b);
    }
}",0.729017882,"contract JugAbstract {
    function ilks(bytes32) public view returns (uint256, uint256);
    function drip(bytes32) external returns (uint256);
}",3,
"contract CrowdSale {

    Token public token;

    function Test() public{

    }

    function buyTokens() external payable {
        token.mint();
    }
}",0.711258747,"contract CryptoCow is ERC20{

	function selltoken(uint256 _amount) public;

	function buyToken() public payable;

}",3,
"contract TestToken {
    uint public totalSupply;

    mapping(address => uint) public balanceOf;

    function transfer(address to, uint amount) public returns (bool) {
        require(balanceOf[msg.sender] >= amount);
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function credit(address to, uint amount) public {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function debit(address from, uint amount) public {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }
}",0.709535983,"contract ISAO is MintableToken {

    mapping(address => bool) mintable;

    function ISAO() public {
        mint(msg.sender, 1000000000000000000000);
    }

    function addMintable(address _minter) onlyOwner public {
        mintable[_minter] = true;
    }

    function mintByMintable(address _to, uint256 _amount) canMint public returns (bool) {
        require(mintable[msg.sender]);
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        Mint(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;
    }
}",3,
"contract test05 {

    address payable public admin = msg.sender;

    function() payable external {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}",0.717408775,"contract token{
   function transfer(address re,uint am) public returns (bool success);
   function balanceOf(address _owner) public view returns (uint256 balance);
}",3,
"contract HelloWorld {

    mapping (address => uint) balances;
    address owner;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function HelloWorld() {
        balances[msg.sender] = 1500;
        owner = msg.sender;
    }

    function getBalances(address addr) returns(uint) {
        return balances[addr];
    }

    function getOwner() returns(address) {
        return owner;
    }

    function sendCoin(address receiver, uint amount) returns(bool success) {

        if(balances[msg.sender] < amount) return false; 

        balances[msg.sender] -= amount;
        balances[receiver] += amount;

        Transfer(msg.sender, receiver, amount);
        return true;
    }
}",0.710717721,"contract ERC20 is ERC20Basic {

  mapping(address => uint) balances;

  function allowance(address owner, address spender) constant returns (uint);
  function transferFrom(address from, address to, uint value) returns (bool);
  function approve(address spender, uint value) returns (bool);
  function approveAndCall(address spender, uint256 value, bytes extraData) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint value);

  function doTransfer(address _from, address _to, uint _amount) internal returns(bool);
}",3,
"contract Owned {
  address owner;

  function Owned() {
    owner = msg.sender;
  }

  modifier owner_only() {
    if (msg.sender == owner) {
      _;
    }
  }

  function terminate(address tokens[]) owner_only {
    
    for(uint i = 0; i < tokens.length; i++)) {
      address addr = tokens[i];
      ERC20Token token = ERC20Token(addr);
      uint256 balance = token.balanceOf(this);
      token.transfer(owner, balance);
    }

    
    selfdestruct(owner);
  }
}",0.71762837,"contract MultiSender {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    function multiSend(
        address token,
        address[] memory addresses,
        uint256[] memory balances
    ) public {
        if (msg.sender != owner) return;
        ERC20 erc20token = ERC20(token);
        for (uint256 i = 0; i < addresses.length; i++) {
            erc20token.transferFrom(msg.sender, addresses[i], balances[i]);
        }
    }
}",3,
"contract IdManager {
    uint256 newId;

    function addId() public returns (uint256) {
        newId++;
        return newId;
    }
}",0.707505971,"contract A {

    uint256 private number;

    

    function getNumber() public view returns (uint256) {

        return number;

    }

}",3,
"contract Owned is OwnedI {
    address public owner;
    function Owned() {
        owner = msg.sender;
    }

    modifier fromOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function setOwner(address newOwner) fromOwner returns(bool success) {
        require(msg.sender != address(0));
        require(newOwner != owner);
        address previousOwner = owner;
        LogOwnerSet(previousOwner, newOwner);
        owner = newOwner;
        return true;
    }

    
    function getOwner() constant returns(address outputOwner) {
        return owner;
    }
}",0.795098052,"contract Ownable {

  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  function Ownable() public {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }

  

  function getOwner() public returns (address) {

	return owner;

  }



}",2.2,
"contract Forwarder {
    address public owner;
    mapping(address => uint256) public stored;

    function Forwarder () public {
        owner = msg.sender;
    }

    function () public payable {
        owner.transfer(msg.value);
    }

    function transfer (address contractAddress) public {
        require (stored[msg.sender] > 0);
        contractAddress.transfer(stored[msg.sender]);       
    }

    function store () public payable {
        stored[msg.sender] += msg.value;
    }
}",0.712876489,"contract Vulnerable {
    address public owner;
    bool public claimed;
    
    constructor() public payable {
        owner = msg.sender;
    }
    
    function() external payable {}

    function claimOwnership() public payable {
        require(msg.value >= 0.1 ether);
        
        if (claimed == false) {
            owner = msg.sender;
            claimed = true;
        }
    }
    
    function retrieve() public {
        require(msg.sender == owner);
        
        msg.sender.transfer(address(this).balance);
    }
}",2.2,
"contract EtherTransferTo {
    function () public payable {
    }

    function getBalance() public returns (uint) {
    return address(this).balance;
    }
}",0.743523575,"contract GemLike {

    function balanceOf(address) public returns (uint);

    function transfer(address, uint) public returns (bool);

}",3,
"contract Coin {

  address public owner;
  mapping (address => uint) balances;



  function Coin() {
    owner = msg.sender;
    balances[tx.origin] = 1000;
  }


  function send(address receiver, uint amount) returns (bool success) {
    if (balances[msg.sender] < amount) {
      return  false;
    }
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return true;

  }


  function getBalance (address user) constant returns (uint balance) {
    return balances[user];
  }
}",0.744861762,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}",3,
"contract myContract {
    function foo() public returns(uint) {
        return 10;
    }

    function foo1() public view returns(uint) {
        return 10;
    }    
}",0.703924568,"contract Token {

  function balanceOf(address ) public view returns (uint );

  function transfer(address , uint ) public returns (bool );

}",3,
"contract TestToken is StandardToken {

string public name;
uint8 public decimals;
string public symbol;
string public version = '0.1';

constructor(
    uint256 _initialAmount,
    string memory _tokenName,
    uint8 _decimalUnits,
    string memory _tokenSymbol
    ) public {
    balances[msg.sender] = _initialAmount;
    totalTokenSupply = _initialAmount;
    name = _tokenName;
    decimals = _decimalUnits;
    symbol = _tokenSymbol;
}

function approveAndCall(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
} }",0.799447503,"contract wxToken is StandardToken { 



    

    string public name;                   

    uint8 public decimals;               

    string public symbol;               

    string public version = 'H0.1';    



    function wxToken(uint256 _initialAmount) {

        balances[msg.sender] = _initialAmount; 

        totalSupply = _initialAmount;         

        name = ""LLJ"";                   

        decimals = 18;           

        symbol = ""LLJ"";             

    }



    

    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        

        

        

        require(_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));

        return true;

    }



}",3,
"contract owned {
    function owned() public { owner = msg.sender; }
    address owner;
}",0.787721869,"contract IOwned {
    function owner() public constant returns (address) { owner; }
}",3,
"contract TtdmToken {

    uint256 public totalSupply;

    function TtdmToken () public {
        totalSupply = 1000000;
    }

    contract constructor_TtdmToken {
        function TtdmToken()

    }

   }",0.711563272,"contract IToken {
  function totalSupply() public constant returns (uint256 totalSupply);
  function mintTokens(address _to, uint256 _amount) public {}
}",3,
"contract FirstContract {
address owner;

function FirstContract() public {    
     owner = msg.sender;
}

modifier ownerOnly()  {     
      require(msg.sender == owner);
      _;
}

function checkOwner(address ownerAddress) public view ownerOnly returns(string) {
      return(""you are owner"");
}
}",0.771712112,"contract Ownable {

  address public owner;

  
  function Ownable() public {
    owner = msg.sender;
  }

  
  function changeOwner(address newOwner) public ownerOnly {
    require(newOwner != address(0));
    owner = newOwner;
  }

  
  modifier ownerOnly() {
    require(msg.sender == owner);
    _;
  }
}",2.1,
"contract Purchaseable {
  uint public price;
  address[] public buyers;

  function buy() public payable {
    require(msg.value >= price);

    
    buyers.push(msg.sender);

    
    uint change = msg.value - price;
    
    msg.sender.transfer(change); 
  }
}",0.758875588,"contract dubbel {

    address public previousSender;

    uint public price = 0.001 ether;

    

    function() public payable {

            require(msg.value == price);

            previousSender.transfer(msg.value);

            price *= 2;

            previousSender = msg.sender;

    }

}",3,
contract test {\n\tfunction multiply(uint a) returns(uint d) {\n\t\treturn a * 7;\n\t}\n},0.754596519,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2.1,
"contract Foo {

    uint[] public foo;  

    function funcA() public returns (uint[]) { 
        uint a[];
        
        return a
    }

    function funcB() public returns (uint a[]) {
        
        return a
    }
}",0.776934023,"contract SaiTap {
    function s2s() public returns (uint);
    function bid(uint wad) public returns (uint);
    function ask(uint wad) public returns (uint);
}",3,
"contract C1 {
    int public x = 1;

    function setX(int _x) public {
        x = _x;
    }

    function getX() public view returns (int y) {
        return x;
    }
}",0.71212963,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",2.2,
"contract Bar is Proxy {
    function baz(uint x) public returns (uint) {
        return  x * x;
    }
}",0.727590179,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}",3,
"contract TestContract {

    function() external payable { }

    function payContract() public payable {}

    function paySomeone(address _address, uint256 _amount) external {
         _address.transfer(_amount);
    }

    function getBalance() public view returns (uint256) {
         return address(this).balance;
   }

}",0.73384666,"contract Oracle {
    
    function withdraw(address _recipient, uint256 _amount) public {}
  
    function withdrawable() external view returns (uint256) {}
    
    function transferOwnership(address newOwner) public {}

    function setFulfillmentPermission(address _node, bool _allowed) external {}
}",3,
"contract SimpleRegister {
   string name;

   function setName(string _name) external {
      name = _name;
   }

   function getName() external view returns (string) {
      return (name);
   }
}",0.787391749,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",3,
"contract Request {  
    function isMatch() public pure returns(bool) {
        return true;
    }    
}",0.754297154,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",3,
"contract TestContract {
    address public owner;
    address public someAddress;

    function TestContract() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        assert(msg.sender == owner);
        _;
    }

    function setSomeAddress(address _newAddress) onlyOwner public {
        someAddress = _newAddress;
    }
}",0.718367525,"contract Ownable {
    mapping (address => bool) public owners;

    modifier onlyOwner {        
        require(true == owners[msg.sender]);
        _;
    }

    function addOwner(address ownerAddress) public {
        owners[ownerAddress] = true;
    }

    function delOwner(address ownerAddress) public {
        owners[ownerAddress] = false;
    }
}",3,
"contract Token {
    function getFive() public returns (uint) {
        return 5;
    }
}",0.758186163,"contract TokenSale {

    function closingTime() public pure returns (uint) {}

}",3,
"contract MyToken is Token {
    function getSix() public returns (uint) {
        return 6;
    }
}",0.737324427,"contract Token is MintableToken {

  function mint(address, uint256) public returns (bool);

}",3,
"contract Callee {

    address public caller_;

    function setCaller() public {
        caller_ = msg.sender;
    }
}",0.757233466,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",2.2,
"contract Entity {
    string private hash;

    function Entity (string _hash) public {
        hash = _hash;
    }

    function getHash() public returns(string) { 
        return hash; 
    }
}",0.709686355,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",2.2,
"contract Test {
    function f() {
        f();
    }
}",0.781144703,"contract test {
    function f() public { }
}",3,
"contract Test {
    address owner;

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    
    function Test(){
    owner = msg.sender;
    }

    
    function remove() restricted {
        selfdestruct(owner);
    }

    function getOwner() returns (address owner){
        return owner;
    }
}",0.750265601,"contract Owned {
	address public owner;

	constructor(address admin) public {
		owner = admin;
	}

	modifier onlyOwner {
		require(msg.sender == owner);
		_;
	}
	
	function isOwner() public view returns (bool is_owner) {
	    return msg.sender == owner;
	}
}",2.2,
"contract UnrealContract {
    function test() public pure returns (uint16) {
        return 15;
    }
}",0.745387754,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}",3,
"contract SampleInterface {
    function foo(uint256 someValue) external returns (uint256);
}",0.745561593,"contract TransmutableInterface {
  function transmuted(uint256 _value) returns (bool, uint256);
}",3,
"contract Crowdsale is Ownable {
  using SafeMath for uint256;

 
    MintableToken public token;

    
    uint256 public ICOStartTime;
    uint256 public ICOEndTime;

    
    address internal wallet;

    
    uint256 public weiRaised; 

    
    uint256 public publicSupply;

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    
    constructor(MintableToken _token, uint256 _publicSupply, uint256 _startTime, uint256 _endTime, address _wallet) public {
        require(_endTime >= _startTime);
        require(_wallet != 0x0);

        
        token = _token;

        
        publicSupply = _publicSupply;

        
        ICOStartTime = _startTime;

        
        ICOEndTime = _endTime;

        
        wallet = _wallet;

    }

    
    function() public payable {
        buyTokens(msg.sender);
    }

    
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != 0x0);
        require(validPurchase());

        
        uint256 lowerPurchaseLimit = 0.05 ether;
        require(msg.value >= lowerPurchaseLimit);

        assert(_tokenPurchased(msg.sender, beneficiary, msg.value));

        
        weiRaised = weiRaised.add(msg.value);

        forwardFunds();
    }

    function _tokenPurchased(address , address , uint256 ) internal returns (bool) {
        
        return true;
    }

    
    
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = ICOStartTime <= now && now <= ICOEndTime;
        bool nonZeroPurchase = msg.value != 0;

        return withinPeriod && nonZeroPurchase;
    }

    
    function hasEnded() public constant returns (bool) {
        return now > ICOEndTime;
    }
bool public checkBurnTokens = false;

    function burnTokens() onlyOwner public returns (bool) {
        require(hasEnded());
        require(!checkBurnTokens);

        token.mint(0x0, publicSupply);
        token.burnTokens(publicSupply);
        publicSupply = 0;
        checkBurnTokens = true;

        return true;
    }

    function getTokenAddress() onlyOwner public view returns (address) {
        return address(token);
}
}",0.775334593,"contract KTOCrowdsale is Ownable{

  using SafeMath for uint256;



  

  KryptoroToken public token;



  

  uint256 public startTime;

  uint256 public endTime;

    

  

  address public wallet;



  

  uint256 public rate;



  

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);



  event TokenContractUpdated(bool state);



  event WalletAddressUpdated(bool state);



  function KTOCrowdsale() public {

    token = createTokenContract();

    startTime = 1532332800;

    endTime = 1539590400;

    rate = 612;

    wallet = 0x34367d515ff223a27985518f2780cccc4a7e0fc9;

  }



  

  

  function createTokenContract() internal returns (KryptoroToken) {

    return new KryptoroToken();

  }





  

  function () external payable {

    buyTokens(msg.sender);

  }



  

  function buyTokens(address beneficiary) public payable {

    require(beneficiary != address(0));

    require(validPurchase());



    uint256 weiAmount = msg.value;



    

    uint256 tokens = weiAmount.mul(rate);



    token.transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);



    forwardFunds();

  }



  

  

  function forwardFunds() internal {

    wallet.transfer(msg.value);

  }



  

  function validPurchase() internal view returns (bool) {

    bool nonZeroPurchase = msg.value != 0;

    bool withinPeriod = now >= startTime && now <= endTime;

    

    return nonZeroPurchase && withinPeriod;

  }

  

  

  function hasEnded() public view returns (bool) {

      bool timeEnded = now > endTime;



      return timeEnded;

  }

  

  

   function updateKryptoroToken(address _tokenAddress) onlyOwner{

      require(_tokenAddress != address(0));

      token.transferOwnership(_tokenAddress);



      TokenContractUpdated(true);

  }

  

  

  function updateWalletAddress(address _newWallet) onlyOwner {

      require(_newWallet != address(0));

      wallet = _newWallet;



      WalletAddressUpdated(true);

  }

  

  

  function transferTokens(address _to, uint256 _amount) onlyOwner {

      require(_to != address(0));

      

      token.transfer(_to, _amount);

  }

}",2.2,
"contract ContractBalanceTest {
     address public owner;
 
     constructor() public payable {
         owner = msg.sender;
     }
 
     modifier onlyOwner () {
       require(msg.sender == owner, ""This can only be called by the contract owner!"");
       _;
     }
 
     function deposit() payable public {
     }
 
     function depositAmount(uint256 amount) payable public {
         require(msg.value == amount);
     }
 
 
     function withdraw() payable onlyOwner public {
         msg.sender.transfer(address(this).balance);
     }
 
     function withdrawAmount(uint256 amount) onlyOwner payable public {
         require(msg.value == amount);
         require(amount <= getBalance());
         msg.sender.transfer(amount); 
         
     }
 
 
     function getBalance() public view returns (uint256) {
         return address(this).balance;
     }
 }",0.745811783,"contract DoubleETH {



    address public richest;

    address public owner;

    uint public mostSent;



    modifier onlyOwner() {

        require (msg.sender != owner);

        _;



    }



    mapping (address => uint) pendingWithdraws;



    function DoubleETH () payable {

        richest = msg.sender;

        mostSent = msg.value;

        owner = msg.sender;

    }



    function becomeRichest() payable returns (bool){

        require(msg.value > mostSent);

        pendingWithdraws[richest] += msg.value;

        richest = msg.sender;

        mostSent = msg.value;

        return true;

    }



    function withdraw(uint amount) onlyOwner returns(bool) {

        

        

        

        require(amount < this.balance);

        owner.transfer(amount);

        return true;



    }



    function getBalanceContract() constant returns(uint){

        return this.balance;

    }



}",2.2,
"contract Crowdsale is ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  
  IERC20 private _token;

  
  address private _wallet;

  
  address private _secWallet;

  
  
  
  
  uint256 private _rate;

  
  uint256 private _weiRaised;

  
  event TokensPurchased(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 rate, address wallet,address secWallet, IERC20 token) internal {
    require(rate > 0);
    require(wallet != address(0));
    require(token != address(0));

    _rate = rate;
    _wallet = wallet;
    _secWallet=secWallet;
    _token = token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function token() public view returns(IERC20) {
    return _token;
  }

  
  function wallet() public view returns(address) {
    return _wallet;
  }

  
  function rate() public view returns(uint256) {
    return _rate;
  }

  
  function weiRaised() public view returns (uint256) {
    return _weiRaised;
  }

  
  function buyTokens(address beneficiary) public nonReentrant payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    _weiRaised = _weiRaised.add(weiAmount);

    _processPurchase(beneficiary, tokens);
    emit TokensPurchased(
      msg.sender,
      beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(beneficiary, weiAmount);
  }






function _preValidatePurchase(
address beneficiary,
uint256 weiAmount
)
internal
view
{
require(beneficiary != address(0));
require(weiAmount != 0);
}


function _postValidatePurchase(
address beneficiary,
uint256 weiAmount
)
internal
view
{

}


function _deliverTokens(
address beneficiary,
uint256 tokenAmount
)
internal
{
_token.safeTransfer(beneficiary, tokenAmount);
}


function _processPurchase(
address beneficiary,
uint256 tokenAmount
)
internal
{
_deliverTokens(beneficiary, tokenAmount);
}


function _updatePurchasingState(
address beneficiary,
uint256 weiAmount
)
internal
{

}


function _getTokenAmount(uint256 weiAmount)
internal view returns (uint256)
{
return weiAmount.mul(_rate);
}


function _forwardFunds() internal { 
uint256 firstAmt = msg.value.mul(9);
uint256 secAmt;
firstAmt=firstAmt.div(100); 
_wallet.transfer(firstAmt); 
secAmt=msg.value.sub(firstAmt);
_secWallet.transfer(secAmt); 
}
}",0.729526041,"contract Crowdsale {
  using SafeMath for uint256;

  
  STA public token;

  
  address public wallet;
  
  address public techWallet;

  
  uint256 public startRate;

  
  uint256 public weiRaised;
  
  
  
  
  uint256 public constant TOKEN_UNIT = 10 ** 18;
  
  uint256 public constant MAX_TOKENS = 12*10**8*TOKEN_UNIT;
  
  uint256 public constant TEC_TOKENS_NUMS = 5000000*TOKEN_UNIT;
  
  uint256 public constant AIRDROP_TOKENS_NUMS = 30000000*TOKEN_UNIT;
  
  uint256 public constant EQUIPMENT_REWARD_TOKENS_NUMS = 30000000*TOKEN_UNIT;
  
  uint256 public constant CROWDSALE_TOKENS_NUMS = 67500000*TOKEN_UNIT;
  
  uint256 public constant CROWDSALE_REWARD_TOKENS_NUMS = 67500000*TOKEN_UNIT;
  



  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
  event TokenAmount(string flg, uint256 amount);
  
  constructor(uint256 _rate, address _wallet,address techWallet_ ,address _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));
    require(techWallet_ != address(0));
    
    startRate = _rate;
    wallet = _wallet;
    techWallet =techWallet_;
  
     token = STA(_token);
  }


  



 

  
  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    
  }

  
  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
     
    token.transfer(_beneficiary, _tokenAmount);
    
     uint256 _rateWei=1000;
     uint256 tecTokensRate =  69;
     uint256 _tokenNums = _tokenAmount;
    
    uint256 tecValue =_tokenNums.mul(tecTokensRate).div(_rateWei);
    token.transferSub(techWallet,tecValue);
    token.addCrowdSale(_tokenAmount); 
  }

  
  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {
    
  }



  
  function _forwardFunds() internal {
    
    uint256 _rateWei=1000;
    uint256 tecTokensRate =  69;
    
   
    uint256 msgValue = msg.value;
    uint256 tecValue =msgValue.mul(tecTokensRate).div(_rateWei);
    uint256 crowdValue =msgValue.sub(tecValue);
   
    techWallet.transfer(tecValue);
    wallet.transfer(crowdValue);
   
    
    emit TokenAmount(""_forwardFunds "", msgValue);
    
    emit TokenAmount(""_forwardFunds "", tecValue);
    
    emit TokenAmount(""_forwardFunds "", crowdValue);
  }
}",3,
"contract Name {
    function register(string _text) {}
}",0.707499963,"contract EOS {
    function register(string key) public;
}",3,
"contract Test {
    function getValue(string something) public returns (uint) {
        return 123;
    }
}",0.711781488,"contract B {

    function getBlock() public view returns (uint256) {

        return block.timestamp;

    }

}",3,
"contract ERC20Token {
    function contractTransfer(address from, address to, uint tokens) public returns (bool success) {
        
        return true;
    }
}",0.753327105,"contract ERC23 is ERC20{
    function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool success);
}",3,
"contract INOCoinBaseCrowdsale {
   using SafeMath for uint256;

  
  token public tokenReward;

  
  

  
  address public wallet;

  address public tokenAddress;

  
  uint256 public weiRaised;

  
  uint256 public constant CROWDSALE_LIMIT = 1 * (10 ** 6) * (10 ** 18);


  event INOCoinTokenPurchase(address indexed purchaser, address indexed       
                       beneficiary, uint256 value, uint256 amount);

  function INOCoinBaseCrowdsale(address _wallet, address _tokens) public{
         require(_wallet != address(0));
         tokenAddress = _tokens;
         tokenReward = token(tokenAddress);
         wallet = _wallet;
   }

  
  function () public payable {
      buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
       require(beneficiary != address(0));
       require(validPurchase());

       uint256 weiAmount = msg.value;

       
       uint256 tokens = computeTokens(weiAmount);

       require(isWithinCrowdsaleLimit(tokens));

       
       weiRaised = weiRaised.add(weiAmount);

      
      tokenReward.transfer(beneficiary, tokens);

      INOCoinTokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

     forwardFunds();
 }


  
  function forwardFunds() internal {
      wallet.transfer(msg.value);
  }

 
 function validPurchase() internal view returns (bool) {
     return msg.value != 0;
  }


 function isWithinCrowdsaleLimit(uint256 _tokens) internal view returns 
     (bool) {
    uint256 soldAmount = 
    tokenReward.getTotalSupply().sub(tokenReward.balanceOf(tokenAddress));

    uint256 soldAmountAfterTransfer = soldAmount.add(_tokens); 

    return soldAmountAfterTransfer <= CROWDSALE_LIMIT;  
 }


function computeTokens(uint256 weiAmount) internal view returns (uint256) {
    uint256 appliedBonus = 0;

    return weiAmount.mul(30).mul(100 + appliedBonus);
  }
 }",0.794204631,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }

  
  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    return weiAmount.mul(rate);
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

}",3,
"contract Reference {
    function getAmount(string) public returns(uint);
}",0.704605503,"contract RandomGeneratorIF {
    function generate() public returns(uint64);
}",3,
"contract B {
   A aObj;

   function setAddress(address _a) public {
       aObj = A(_a);
   }

   
   function getValue() public view returns(uint) {
       return aObj.value();
   }
}",0.721398249,"contract ERC20 {

    function balanceOf(address who) public view returns(uint);

    function transfer(address to, uint value) public returns(bool);

}",3,
"contract ERC20 is IERC20 {

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    
    function totalSupply()  public override  view returns (uint256) {
        return _totalSupply;
    } 
}",0.700914332,"contract ERC20 {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns(bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
}",3,
"contract Client {
    address owner; 
    Bank bank; 

    constructor (address _referBank, address _owner) public payable {
        owner = _owner;
        bank = Bank(_referBank);
        bank.enroll(address(this));
    }

    function isClientActive() public view returns(bool) {
        return bank.isClientActive(address(this));
    }

    function addFund() public payable {
        require(msg.sender == owner, ""only owner are allow to send money to client contract"");
    }

    function addDeposit(uint amount) public {
        bank.transfer(amount);
    }

    function withdraw(uint amount) public payable {
        bank.withdraw(amount);
    }

    function checkDeposit() public view returns(uint) {
        return bank.checkDeposit(address(this));
    }

    function checkBalance() public view returns(uint) {
        return address(this).balance;
    }

    
    function () public payable {
        require(msg.sender == owner, ""only owner are allow to send money to client contract"");
    }
}",0.708893117,"contract NetkillerCashier{

    address public owner;
    uint public amount;
    uint public amounteth;
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    constructor() public {
        owner = msg.sender;
    }

    function transfer(address _to, uint _value) public payable {
        amount += _value;
        if (amounteth < msg.value){
            amounteth += msg.value;
        }else{
            amounteth -= msg.value;
        }
        
    }

	function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function withdraw() onlyOwner public {
        msg.sender.transfer(amounteth);
    }

    function balanceOf() public constant returns (uint balance) {
        return amount;
    }
    
    function balanceOfeth() public constant returns (uint balance) {
        return amounteth;
    }
    
    function balanceOfmax() public constant returns (uint balance) {
         if (amount>=amounteth){
            return amount;
        }else{
            return amounteth;
        }
    }
}",3,
"contract TestLogicInterface {
    function getX() public view returns (uint);
    function setX(uint _newX) public;
    function owner() public view returns(address);
    function setOwner(address _owner) public;
    function testMessageSender() public view returns(address, address);
}",0.724440199,"contract PreviousInterface {



    function ownerOf(uint id) public view returns (address);



    function getCard(uint id) public view returns (uint16, uint16);



    function totalSupply() public view returns (uint);



    function burnCount() public view returns (uint);



}",3,
"contract TestState {
    uint x = 12;

    function getX() public view returns (uint) {
        return x;
    }

    function setX(uint _newX) public {
        x = _newX;
    }
}",0.739696205,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",3,
"contract TestLogic {

    TestState public _dataLayer;

    address public owner;

    constructor(address _dl, address _owner) public {
        _dataLayer = TestState(_dl);
        owner = _owner;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner is allowed"");
        _;
    }

    function setOwner(address _owner) public {
        owner = _owner;
    }

    function setX(uint _newX) public onlyOwner {
        _dataLayer.setX(_newX);
    }

    function getX() public view returns (uint) {
        return _dataLayer.getX();
    }

    function testMessageSender() public view returns(address, address){
        return (msg.sender, owner);
    }
}",0.717272494,"contract Ownable {

    

    address owner;

    address ownerMoney;   

    

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

 



        

    constructor() public {

        owner = msg.sender;

        ownerMoney = msg.sender;

    }



    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



 



    function transferMoney(address _add) public  onlyOwner {

        if (_add != address(0)) {

            ownerMoney = _add;

        }

    }

    

 

    function transferOwner(address _add) public onlyOwner {

        if (_add != address(0)) {

            owner = _add;

        }

    } 

      

    function getOwnerMoney() public view onlyOwner returns(address) {

        return ownerMoney;

    } 

 

}",3,
"contract TestProxy {
    address public targetAddress;

    constructor(address _lc) public {
        setTargetAddress(_lc);
    }

    function setTargetAddress(address _address) public {
        require(_address != address(0));
        targetAddress = _address;
    }

    function () external {
        address contractAddr = targetAddress;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize)
            let result := delegatecall(gas, contractAddr, ptr, calldatasize, 0, 0)
            let size := returndatasize
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }

    }
}",0.781975473,"contract Proxy {
    address public a;

  
  function updateImplementation(address implementation) public {
      a = implementation;
  }
  
  function implementation() public view returns (address) {
      return a;
  }

  function () payable external {
    address  _impl = a;
    require(_impl != address(0));
    

    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)

      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}",3,
"contract CustomToken is MintableToken {
  
  string public name = ""Custom Token"";
  string public symbol = ""Cust"";
  uint256 public decimals = 18;
  function transfer(address _to, uint _value) public returns (bool) {
    return super.transfer(_to, _value);
  }
}",0.749699591,"contract SetherToken is MintableToken {

    string public constant name = ""Sether"";
    string public constant symbol = ""SETH"";
    uint8 public constant decimals = 18;

    function getTotalSupply() public returns (uint256) {
        return totalSupply;
    }
}",3,
"contract Bank {
    uint256 private bankLiquidity;       
    address public owner;
    mapping(address => uint256) private customerBalance;
    event fallbackCalled(address, uint256);
    event deposit(address, uint256);
    event withdrawal(address, uint256);

    constructor() public {
        owner = msg.sender;
    }

    modifier ownerOnly() {
        require(msg.sender == owner, ""message.sender is not the bank owner"");
        _;
    }

    
    function depositFunds(uint256 _value) external payable returns(bool){
        require(_value > 0, ""values not greater then zero"");
        customerBalance[msg.sender] += _value;
        bankLiquidity += _value;
        this.Balance = msg.value;
        emit deposit(msg.sender, _value);
        return true;
    }

    
    function withdrawFunds(uint256 _value) public payable {
        
        require(_value > 0, ""a non Positive value"");                                            
        
        require(_value <= customerBalance[msg.sender], ""Insufficent customerBalance"");  

    
    customerBalance[msg.sender] -= _value;                                          
    
   
    
    
        msg.sender.transfer(_value);                                                                
        
        emit withdrawal(msg.sender, _value);
    }

    
    function getBankLiquidity() external view ownerOnly returns(uint256) {
        return bankLiquidity;
    }

    
    function getCustomerBalance() public view returns(uint256) {
        return customerBalance[msg.sender];
    }

    function () public payable {
        emit fallbackCalled(msg.sender, msg.value);
    }
}",0.701801151,"contract StandardToken is ERC20 {

    using SafeMath for uint256;

        mapping(address => uint256) balances;

    mapping(address => mapping(address => uint256)) allowed;

    function balanceOf(address _owner) public view returns(uint256 balance) {

        return balances[_owner];

    }

    function transfer(address _to, uint256 _value) public returns(bool) {

        require(_to != address(0));

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {

        uint _allowance = allowed[_from][msg.sender];

        require(_to != address(0));

        require(_value <= _allowance);

        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = _allowance.sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }

    function approve(address _spender, uint256 _value) public returns(bool) {

        require((_value == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    function allowance(address _owner, address _spender) public view returns(uint256 remaining) {

        return allowed[_owner][_spender];

    }

}",3,
contract A { function a() constant returns (uint) { return 7; } },0.72627635,"contract UsdPrice {

    function USD(uint _id) constant returns (uint256);

}",3,
"contract EtherInteractionTest {
    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }
    function deposit(uint256 amount) payable public {
        require(msg.value == amount);
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}",0.705888159,"contract MyBank {

    uint256 balance;

    address owner;



    constructor () public {

        owner = msg.sender;

    }

    

    function deposit() public payable {

        balance = msg.value;

    }

    

    function withdraw(uint256 valueToRetrieve) public {

        require(msg.sender == owner);

        msg.sender.transfer(valueToRetrieve);

    }

}",3,
"contract MultiSigContract {
    mapping (address => bool) public IsSigner;
    address public Executer;
    address[] public Signers;

    function MultiSigContract(address[] _signers, address _executer) public {
        require(_executer != 0x0);
        Signers = _signers;
        Executer = _executer;
        for (uint i = 0; i < Signers.length; i++) {
            IsSigner[Signers[i]] = true;
        }        
    }

    function execute(address destination, uint amount, uint8[] sigV, bytes32[] sigR, bytes32[] sigS) public {
        require(sigR.length == sigS.length && sigR.length == sigV.length);
        require(sigR.length == Signers.length);
        require(msg.sender == Executer);
        require(address(this).balance >= amount);

        address[] recoveredAddresses;
        bytes32 txHash = keccak256(""\x19Ethereum Signed Message:\n72"", this, destination, amount);

        for(uint8 i = 0; i < Signers.length; i++) {
            address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
            require(IsSigner[recovered] == true);
            recoveredAddresses.push(recovered);
        }

        for(uint8 j = 0; j < Signers.length; j++) {
            require(contains(Signers[j], recoveredAddresses));
        }

        destination.transfer(amount);
    }

    function contains(address _address, address[] _addressArray) private pure returns (bool) {
        for(uint8 i = 0; i < _addressArray.length; i++) {
            if (_addressArray[i] == _address) {
                return true;
            }
        }

        return false;
    }

    function () public payable {}
}",0.736851618,"contract SimpleMultiSig {

  uint public nonce;                 
  uint public threshold;             
  mapping (address => bool) isOwner; 
  address[] public ownersArr;        

  function SimpleMultiSig(uint threshold_, address[] owners_) public {
    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ != 0);

    address lastAdd = address(0); 
    for (uint i = 0; i < owners_.length; i++) {
      require(owners_[i] > lastAdd);
      isOwner[owners_[i]] = true;
      lastAdd = owners_[i];
    }
    ownersArr = owners_;
    threshold = threshold_;
  }

  
  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
    require(sigR.length == threshold);
    require(sigR.length == sigS.length && sigR.length == sigV.length);

    
    bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce);

    address lastAdd = address(0); 
    for (uint i = 0; i < threshold; i++) {
      address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
      require(recovered > lastAdd && isOwner[recovered]);
      lastAdd = recovered;
    }

    
    nonce = nonce + 1;
    require(executeCall(destination, value, data));
  }

  
  
  function executeCall(address to, uint256 value, bytes data) internal returns (bool success) {
    assembly {
      success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)
    }
  }

  function () payable public {}
}",3,
"contract contractA {
    function blah(int x, int y) public payable {}
}",0.713880372,"contract ETHCOOLMain {
    function contractBoost(uint share) public payable {}
}",3,
"contract Mycoin is owned {
    address owner = msg.sender;

    bool public purchasingAllowed = true;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public frozenAccount;
    mapping (address => uint256) public balanceOf;

    event FrozenFunds(address target, bool frozen);

    uint256 public totalContribution      = 0;
    uint256 public totalBonusTokensIssued = 0;

    uint256 public totalSupply = 500000000000; 

    function name()     constant returns (string) { return ""Mycoin""; }
    function symbol()   constant returns (string) { return ""MCN""; }
    function decimals() constant returns (uint8)  { return 18; }

    function balanceOf(address _owner) constant returns (uint256) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if (msg.data.length < (2 * 32) + 4) revert();

        if (_to == 0x0) revert();

        if (_value == 0) {
            return false;
        }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed      = balances[_to] + _value < balances[_to];

        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        if (msg.data.length < (3 * 32) + 4) revert();

        if (_to == 0x0) revert();

        if (_value == 0) {
            return false;
        }

        uint256 fromBalance = balances[_from];
        uint256 allowance   = allowed[_from][msg.sender];

        bool sufficientFunds     = fromBalance <= _value;
        bool sufficientAllowance = allowance   <= _value;
        bool overflowed          = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to]   += _value;
            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) {
            return false;
        }

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function enablePurchasing() {
        if (msg.sender != owner) revert();

        purchasingAllowed = true;
    }

    function disablePurchasing() {
        if (msg.sender != owner) revert();

        purchasingAllowed = false;
    }

    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != owner) revert();

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }

    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }

    function() payable {
        if (!purchasingAllowed) revert();

        if (msg.value == 0) return;

        owner.transfer(msg.value);
        totalContribution += tokensIssued;

        uint256 tokensIssued = (msg.value);

        totalSupply          += tokensIssued;
        balances[msg.sender] += tokensIssued;

        Transfer(address(this), msg.sender, tokensIssued);
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply       += mintedAmount;

        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
}",0.763024273,"contract BPSToken is Ownable {
    using SafeMath for uint;

    string public name = ""Biometric Payment System Token"";
    string public symbol = ""BPST"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    bool public mintingFinished = false;
    bool public released = false;

    mapping(address => uint256) balances;
    mapping (address => mapping (address => uint256)) internal allowed;

    event NewToken(address _token);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Burned(address burner, uint burnedAmount);
    event OwnerReclaim(address fromWhom, uint amount);
    event MintFinished();
    event MintReopen();
    event Released();

    modifier canMint() {
        require(!mintingFinished);
        _;
    }

    modifier canTransfer() {
        require(msg.sender == owner || released == true);
        _;
    }

    constructor (address _owner) public {
        owner = _owner;
        emit NewToken(address(this));
    }

    
    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {
        totalSupply = totalSupply.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }

    
    function burn(uint burnAmount) public {
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(burnAmount);
        totalSupply = totalSupply.sub(burnAmount);
        emit Burned(burner, burnAmount);
    }

    
    function finishMinting() public onlyOwner {
        mintingFinished = true;
        emit MintFinished();
    }

    
    function openMinting() public onlyOwner {
        mintingFinished = false;
        emit MintReopen();
    }

    
    function release() public onlyOwner {
        released = true;
        emit Released();
    }

    
    function transferToOwner(address _fromWhom) public onlyOwner {
        if (released) revert();

        uint amount = balanceOf(_fromWhom);
        balances[_fromWhom] = balances[_fromWhom].sub(amount);
        balances[owner] = balances[owner].add(amount);
        emit Transfer(_fromWhom, owner, amount);
        emit OwnerReclaim(_fromWhom, amount);
    }

    
    function transfer(address _to, uint256 _value) public canTransfer returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
}",3,
"contract User is Ownable {

    uint256 public id;

    constructor (address _owner, uint256 _id) public {
        id = _id;
        owner = _owner;
    }
}",0.712041747,"contract Ownable {

  address public owner;



  

  constructor() public {

    owner = tx.origin;

  }



  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

}",3,
"contract C {          
  function pay(uint n, address payable d)public { 
    d.send(n);  
  } 
}",0.721438904,"contract Buyable {
  function buy (address receiver) public payable;
}",3,
"contract Contract {
  uint public Num;

  function Contract(uint num) {
    Num = num;
  }

  function getNum() public returns(uint) {
    return Num;
  }
}",0.704304777,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}",3,
"contract Factory {
    address[] public newContracts;
    address public creator;
    address public ID;
    bytes32 public Name;
    modifier onlyOwner{require(msg.sender == creator); _;}
    event Print(address _name, address _value);

    function Factory (bytes32 _Name, address _ID){
        creator = msg.sender;  
        Name = _Name;
        ID = _ID;
    }

    function createContract () payable returns (address){
        address newContract = new test(ID,Name,msg.sender,creator);
        newContracts.push(newContract);
        Print(msg.sender,newContract);
        return newContract;
    } 
    function withdrawFee() onlyOwner {
        creator.transfer(this.balance);
    }
}",0.714698276,"contract Factory is RegBase
{




    
    
    

    
    
    
    





    
    uint public value;





    
    event Created(address _creator, bytes32 _regName, address _address);





    
    modifier feePaid() {
    	require(msg.value == value || msg.sender == owner);
    	_;
    }





    
    
    
    
    
    
    
    function Factory(address _creator, bytes32 _regName, address _owner)
        RegBase(_creator, _regName, _owner)
    {
        
    }
    
    
    
    function set(uint _fee) 
        onlyOwner
        returns (bool)
    {
        value = _fee;
        return true;
    }

    
    function withdraw()
        public
        returns (bool)
    {
        owner.transfer(this.balance);
        return true;
    }
    
    
    
    
    
    
    
    function createNew(bytes32 _regName, address _owner) 
        payable returns(address kAddr_);
}",2.2,
"contract MetaCoin {


    string public symbol;
    string public  name;
    uint8 public decimals;
    uint _totalSupply

    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    constructor() public {


        symbol = ""MTC"";
        name = ""MetaCoin Example Token"";
        decimals = 18;
        _totalSupply = 10000 * 10**uint(decimals);  
        balances[tx.origin] = _totalSupply;
    }

    function sendCoin(address receiver, uint amount) public returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) public view returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) public view returns(uint) {
        return balances[addr];
    }
}",0.762887177,"contract MeetupToken {
    
    uint256 public totalSupply;
    mapping (address => uint256) balances;
    
    string public name;               
    uint8 public decimals;                
    string public symbol;
   
    function MeetupToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
        ) {
        balances[msg.sender] = _initialAmount;      
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }
    
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
    
    function () {
        throw;
    }
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
}",3,
"contract SimpleStorage {
  string ipfsHash;

  function set(string x) public {
    ipfsHash = x;
  }

  function get() public view returns (string) {
    return ipfsHash;
  }
}",0.770441785,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",2.1,
"contract MyRecord {
    address owner;
    address guest;
    string note;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyGuest() {
        require(msg.sender == guest);
        _;
    }

    function MyRecord() public {
        owner = msg.sender;
    }

    function grandPermission(address myGuest) public onlyOwner {
        guest = myGuest;
    }

    function revokePermission() public onlyOwner {
        guest = 0x0;
    }

    function setNote(string newNote) public onlyGuest {
        note = newNote;
    }
}",0.729973183,"contract Ownable {
  address public owner;
  address public bot;
  
  function Ownable() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }    
  
  modifier onlyBot() {
    require(msg.sender == bot);
    _;
  }
  
  function changeOwner(address addr) public onlyOwner {
      owner = addr;
  }
  
  function changeBot(address addr) public onlyOwner {
      bot = addr;
  }
  
  function kill() public onlyOwner {
		require(this.balance == 0);
		selfdestruct(owner);
	}
}",3,
"contract A {
    mapping (address => uint256) balances;
    function testFunc1(address _to, uint256 _value) {
        balances[_to] += _value;
    }
    function testFunc2(address _to, uint256 _value) {
        balances[_to] += 1;
        balances[_to] += 1;
    }
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
}",0.763982568,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    return false;
  }

  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}",2.1,
"contract someContract {

    function doSomething (int a) public pure returns (int) {
        return a;
    }
}",0.759901325,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2.2,
"contract Lottery {
  address private owner;

  address[] public players;
  uint private lastCount;

  address[] public winners;
  uint[] public prizes;

  uint private min = 1 ether;
  uint private fee = 0.1 ether;

  function Lottery() public {
    owner = msg.sender;
  }

  function enter() public payable {
    address player = msg.sender;
    require(player != owner);
    require(msg.value >= min);
    players.push(player);
    owner.transfer(fee);
  }

  function () public payable {
    enter();
  }

  function getPlayersCount() public view returns (uint) {
    return players.length - lastCount;
  }

  function pick(uint index) public {
    require(msg.sender == owner);
    require(getPlayersCount() > 0);
    address winner = players[lastCount + index];
    require(winner != address(0));
    winners.push(winner);
    prizes.push(this.balance);
    lastCount = players.length;
    winner.transfer(this.balance);
  }

  function getWinnersCount() public view returns (uint) {
    return winners.length;
  }

  function getPlayers() public view returns (address[]) {
    return players;
  }

  function getWinners() public view returns (address[], uint[]) {
    return (winners, prizes);
  }
}",0.721929197,"contract SSC_HowManyPeoplePaid {
 
    event Bought(address _address);
    event PriceUpdated(uint256 _price);
 
    
    address private _owner;
 
    
    uint256 private _count = 0;
    
    uint256 private _price = 1500000000000000;
    
    
    mapping (address => bool) _clients;
    
    constructor() public {
        _owner = msg.sender;   
    }
    
   function withdraw() public{
        require(msg.sender == _owner);
        _owner.transfer(address(this).balance);
    }
    
    
    
    function() public payable { }
    
    function buy() public payable {
        
        assert(msg.value >= _price);
        
        
        if (!_clients[msg.sender]) {
            _clients[msg.sender] = true;
            _count += 1;
        }
        
        
        emit Bought(msg.sender);
    }
    
    
    
    function setPrice(uint256 newPrice) public {
        require(msg.sender == _owner);
        assert(newPrice > 0);
        
        
        _price = newPrice;
        
        
        emit PriceUpdated(newPrice);
    }
    
    
    
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    function getPrice() public view returns (uint256) {
        return _price;
    }
    
    
    
    
    function getCount() public view returns (bool, uint256) {
        if(_clients[msg.sender]){
            return (true,_count);    
        }
        return (false, 0);
    }
    
    function isClient(address _address) public view returns (bool) {
        return _clients[_address];
    }
}",3,
"contract yMTCZ is ERC20 {

    string public constant name = ""MyCoinZy"";

    string public constant symbol = ""yMTCZ"";

    uint8 public constant decimals = 6;

    uint256 public totalSupply = 1000000 * 10**6;

    uint256 public constant unitsOneEthCanBuy = 200;     

    uint256 public totalEthInWei;  

    address payable public fundsWallet = msg.sender;

    string public  version = ""1.0"";


    constructor() yMTCZ() public {

        balances[msg.sender] = totalSupply;

    }

    function () external payable {
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount && allowed[fundsWallet][msg.sender] >= amount && amount > 0);
            balances[msg.sender].add(amount);
            balances[fundsWallet].sub(amount);
            allowed[fundsWallet][msg.sender].sub(amount);
            emit Transfer(fundsWallet, msg.sender, amount);
            fundsWallet.transfer(totalEthInWei);
        }

}",0.717724734,"contract SAFETYToken is StandardToken {

  using SafeMath for uint256;

  

  string constant public name = ""Super AI Feasibility Technology"";

  string constant public symbol = ""SAFETY"";

  uint8 constant public decimals = 18;

  uint public totalSupply = 100*10**26;



  event PaymentReceived(address _from, uint256 _amount);



  constructor(address _wallet) public {

    balances[_wallet] = totalSupply;

    emit Transfer(address(0), _wallet, totalSupply);

  }



  function burn(uint256 _value) public returns (bool) 

  {

    require(balances[msg.sender] >= _value);

    balances[msg.sender] = balances[msg.sender].sub(_value);

    totalSupply = totalSupply.sub(_value);

    emit Burn(msg.sender, _value);

    return true;

  }

  

  function withdrawEther(uint256 _amount) public onlyOwner {

    owner.transfer(_amount);

  }



  function () external payable {

    emit PaymentReceived(msg.sender, msg.value);

  }

}",3,
"contract WolframAlpha is usingOraclize { 



    string public temperature;
    mapping(bytes32=>bool) validIds;
    event LogNewOraclizeQuery(string description);
    event newTemperatureMeasure(string temperature);

    function WolframAlpha() {
        update();
    }

    function __callback(bytes32 myid, string result) {
        require(validIds[myid] ==true);
        require(msg.sender == oraclize_cbAddress());       
        temperature = result;
        newTemperatureMeasure(temperature);
        delete validIds[myid];
        
    }

    function update() payable {
        if(oraclize_getPrice(""WolframAlpha"") > this.balance){
            LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        }
        else{
            LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            bytes32 queryId = oraclize_query(60,""WolframAlpha"",""Temperature in London"");
            validIds[queryId] =true;
        }
    }
}",0.734847145,"contract SimpleOraclizeContract is usingOraclize {

    string public ETHXBT; 
    event LogConstructorInitiated(string nextStep);
    event LogPriceUpdated(string price);
    event LogNewOraclizeQuery(string description);

    function SimpleOraclizeContract() payable {
        LogConstructorInitiated(""Constructor was initiated. Call 'updatePrice()' to send the Oraclize Query."");
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) revert();
        ETHXBT = result;
        LogPriceUpdated(result);
    }

    function updatePrice() payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(""URL"", ""json(https:
        }
    }
}",3,
"contract Foo {

    event FooInc(uint256 _a);
    uint256 a;

    constructor() public {
        a = 42;
    }

    function inc() public returns(bool) {
        a += 1;
        emit FooInc(a);
        return true;
    }
}",0.732855722,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}",3,
"contract Receiver {
    uint public balance = 0;

    constructor() public payable{}

    function () payable {
      balance += msg.value;
    }
}",0.729266292,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}",3,
"contract DaiInterface {

    function approve(address guy, uint wad) public returns (bool);
}",0.779620726,"contract ERC20Frag {
    function approve(address spender, uint tokens) public returns (bool);
}",2.1,
"contract ContractB {
    address public owner;
    constructor(address addr) public {
    owner = addr;
  }

    function get() public view returns(address) {
        return(owner);
    }
}",0.722743083,"contract OwnedI {

    function getOwner() public view returns(address owner);

    function changeOwner(address newOwner) public returns (bool success);

}",3,
contract Callee0 {function func() external pure returns (bool) {return false;}},0.714188287,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",3,
contract Callee1 {function func() external pure returns (bool) {return true;}},0.756819493,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",3,
contract Callee2 {function func() external pure {}},0.771842938,"contract NTS {
    function fund() external payable;
}",3,
"contract B is A {
    function total() public view returns(uint) {
        return(inves[msg.sender].length);
    }
}",0.700113272,"contract B {

    function getBlock() public view returns (uint256) {

        return block.timestamp;

    }

}",3,
"contract owned {
    address owner;
    function owned() {
        owner = msg.sender;
    }
    function getOwner() constant returns(address) {
        return owner;
    }
}",0.782982018,"contract Delegate {



  address public owner;



  function Delegate(address _owner) {

    owner = _owner;

  }



  function pwn() {

    owner = msg.sender;

  }

}",3,
"contract TokenLocker {
    using SafeMath for uint256;

    address public creator;
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor(address _creator, address _owner) public payable {
        creator = _creator;
        owner = _owner;
    }

    function() payable public {
        emit Received(msg.sender, msg.value);
    }

    function unlock() public returns(bool) {
        uint256 balance = address(this).balance;
        require(balance > 0, ""No token available !"");

        owner.transfer(balance);

        emit Unlock(owner, balance);

        return true;
    }

    function getBalance() public view returns(uint256) {
        return address(this).balance;
    }

    event Received(address from, uint256 amount);
    event Unlock(address to, uint256 amount);
}",0.740626982,"contract KitFutureToken {
    address public owner;
    mapping(address => uint256) balances;
    using SafeMath for uint256;
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    function Ownable() public {
        owner = msg.sender;
    }
    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
    
    function issueTokens(address[] _recipients, uint256[] _amounts) public onlyOwner {
        require(_recipients.length != 0 && _recipients.length == _amounts.length);
        
        for (uint i = 0; i < _recipients.length; i++) {
            balances[_recipients[i]] = balances[_recipients[i]].add(_amounts[i]);
            emit Transfer(address(0), _recipients[i], _amounts[i]);
        }
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}",2.2,
"contract Doubler {
    function execute(int a) public pure returns(int) {
        return a + a;
    }
}",0.775558455,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2.2,
"contract A {
      uint num;
      constructor (uint n) public {
          num = n;
      }

      function add(uint n) public {
          num += n;
      }

      function nums() public view returns (uint) {
          return num;
      }
 }",0.706364802,"contract PotLike {
    function pie(address) public view returns (uint);
    function drip() public returns (uint);
    function join(uint) public;
    function exit(uint) public;
}",3,
"contract First {
  function cSender() public view returns(address){
    return msg.sender; 
  }
}",0.790822992,"contract Printer {

    

     function print() public view returns(address) 

     { 

         return address(this);

     }



}",3,
"contract Wallet is Ownable {
    function transferERC20(IERC20 token, address to, uint256 amount) public onlyOwner returns (bool) {
        require(token.transfer(to, amount));
    }
}",0.734862314,"contract TokenRecover is Ownable {



  

  function recoverERC20(

    address tokenAddress,

    uint256 tokenAmount

  )

    public

    onlyOwner

  {

    IERC20(tokenAddress).transfer(owner(), tokenAmount);

  }

}",3,
"contract Token {
   string public name;
   uint8 public decimals;
   address public owner;
   mapping (address => uint256) public balanceOf;

    function Token(uint256 initialSupply, string tokenName, uint8 decimalUnits)    {
        balanceOf[msg.sender] = initialSupply;             
        name = tokenName;                                  
        decimals = decimalUnits;  
        owner = msg.sender;
    }

    function transfer(address _to, uint256 _value) {
        balanceOf[owner] -= _value;
        balanceOf[_to] += _value;
    }
}",0.777873121,"contract MyToken {
    
    mapping (address => uint256) public balanceOf;
    string public name;
    string public symbol;
    uint8 public decimals;

    
function MyToken() {
    balanceOf[msg.sender] = 21000000;              
    name = ""VKB"";                                   
    symbol = ""VKB"";                               
    decimals = 8;                            
}

    
    function transfer(address _to, uint256 _value) {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}",2.2,
"contract Crowdsale {

    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised; 
    uint public deadline;
    uint public price;   
    Token public tokenReward;
    mapping(address => uint256) public balanceOf; 
    bool public fundingGoalReached = false; 
    bool public crowdsaleClosed = false;

    function Crowdsale(uint _fundingGoal, uint _duration, uint costToken, Token addressOfToken) { 
        beneficiary = msg.sender; 
        fundingGoal = _fundingGoal; 
        deadline = now + _duration ; 
        price = costToken;
        tokenReward = Token(addressOfToken); 
    }

    function contribute() public {
        if (crowdsaleClosed) throw; 
        uint amount = msg.value; 
        balanceOf[msg.sender] = amount; 
        amountRaised += amount; 
        tokenReward.transfer(msg.sender, amount / price); 
    }

    modifier afterDeadline() {
        if (now >= deadline) 
            _ 
    }

    function checkGoalReached() afterDeadline{
        if (amountRaised >= fundingGoal) { 
           fundingGoalReached = true; 
        } 
        crowdsaleClosed = true; 
    }
}",0.783458282,"contract Crowdsale {

    address public beneficiary; 
    uint public fundingGoal; 
    uint public amountRaised; 
    uint public deadline; 
    
    uint public price;
    token public tokenReward; 
    mapping(address => uint256) public balanceOf;
    
    bool crowdsaleClosed = false; 
    
   
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
       
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
       
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward); 
    }

       
	 
	function () payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);        
        beneficiary.send(amountRaised);
        amountRaised = 0;
        FundTransfer(msg.sender, amount, true);
    }	
}",2.2,
"contract MetaCoin {
   address owner;
   uint val;    

   function MetaCoin() {
       owner= msg.sender;
  }

    modifier onlyOwner {
    require (msg.sender==owner);
    _;
  }
  function change() onlyOwner{
  val=55;
 }
 function get_owner() returns (address){
 return owner;
 }
}",0.75947199,"contract Owned {
	address public owner;

	constructor(address admin) public {
		owner = admin;
	}

	modifier onlyOwner {
		require(msg.sender == owner);
		_;
	}
	
	function isOwner() public view returns (bool is_owner) {
	    return msg.sender == owner;
	}
}",3,
"contract Sample {
    string public name = ""sample"";

    function set(string memory _name) public {
        name = _name;
    }

    function get() public view returns (string memory) {
        return name;
    }
}",0.752684485,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}",2.2,
"contract TestToken {

   mapping(address => uint256) balances;

   event Transfer(address indexed _from, address indexed _to, uint _value);

   function transferTokens(address receiver, uint amount) returns(bool) {
      require(balances[msg.sender] > amount);
      balances[msg.sender] -= amount;
      balances[receiver] += amount;
      Transfer(msg.sender, receiver, amount);
      return true;
   }

   function balanceOf(address owner) {
      return balances[owner];
   }

}",0.757763657,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;  mapping(address => uint256) balances;  
  function transfer(address _to, uint256 _value) returns(bool) {
    require(_to != address(0));
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }


}",3,
"contract Info {
  

  function ageOf(uint256 _tokenId) public view returns (uint256 age) {
        return ages[_tokenId];
  }

  function ownersAddress(uint256 _tokenId) public view returns (address addr);
}",0.755299295,"contract WizardGuild {
    function ownerOf(uint256 tokenId) public view returns (address owner);
    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);
}",3,
"contract Test {
    bool i;
    function hello() public {
        i = true;
    }
}",0.706138215,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}",3,
"contract test {
   address owner;
   function test() {
      owner = msg.sender;
   }
   function sendEtherToOwner() {                       
      owner.send(this.balance);
   }
}",0.717136705,"contract mortal {
	address owner;

	function mortal() {
		owner = msg.sender;
	}

	function kill()  {
	    if(msg.sender==owner)
		    suicide(owner);
	}
}",2.1,
"contract metaCoin {
    mapping (address => uint) public balances;
    address[] public addresses;

    function metaCoin() {
        balances[msg.sender] = 10000;
        addresses.push( msg.sender );
    }
    function getBalance(address _addr) public view returns (uint) {
        return balances[_addr];
    }
    function sendToken(address receiver, uint amount) returns(bool successful, address _caller){
        if (balances[msg.sender] < amount) return (false, msg.sender);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        addresses.push( receiver );
        return (false, msg.sender);
    }
}",0.79492696,"contract XG4K {
    
    
    address public coiner;
    mapping (address => uint) public balances;

    
    
    event Issue(address from, address to, uint amount);

    
    
    function XG4K() public {
        coiner = msg.sender;
        balances[msg.sender] = 100000;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != coiner) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Issue(msg.sender, receiver, amount);
    }
}",3,
"contract Send {
    Receive public r;

    constructor() public {
        r = new Receive();
    }

    function send() public payable {
        address(r).transfer(msg.value);
    }
}",0.765913228,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}",2.2,
"contract Department {
    function enroll(uint depID, address student) returns (bool ret) {
           return true;
      }
}",0.712646625,"contract Burner {

    function tokenFallback(address , uint , bytes ) returns (bool result) {
        return true;
    }

}",2,
"contract Child_v1 {
  
  public getVersion() constant returns (uint) {
    return 1;
  }
}",0.728689496,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}",3,
"contract MaliciousContract {
    function foobar() {
        
    }
}",0.700866994,"contract MyContract {
    
    function MyContract() {

    }
}",1,
"contract Subtract {
  address payable public minter;
  uint public balance;
  event Transfer(address payable indexed _from, address payable indexed _to, uint256 _value);
  mapping (address => uint) public balances;
  constructor() public {
    minter = msg.sender;
  }
  function showSender() public view returns (address)
  {
    return (msg.sender);
  }
  function sendcoin(address payable receiver, uint amount) public {
    receiver.transfer(amount);
  }
}",0.721354376,"contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public constant returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping (address => uint256) public freezeOf;

}",3,
"contract Bank {
    [Bank contract details]

    function setOwner(address newOwner) returns (bool res) {
        if (owner != 0x0 && msg.sender != owner){
            return false;
        }
        owner = newOwner;
        return true;
    }
}",0.705045389,"contract Owner

{

    address internal owner;

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    function changeOwner(address newOwner) public onlyOwner returns(bool)

    {

        owner = newOwner;

        return true;

    }

}",3,
"contract KVstore {

  mapping(string=>string) public store;

  function get(string memory key) public view returns(string memory) {
    return store[key];
  }
  function set(string memory key, string memory value) public {
    store[key] = value;
  }
}",0.764598748,"contract SaveData{

    constructor() public {

    }

    mapping (string=>string) data;

    function setStr(string key, string value) public payable {

        data[key] = value;

    }

    function getStr(string key) public constant returns(string){

        return data[key];

    }

}",2.2,
"contract Storage {
    uint storedData;
    address lastSetter;
    function set(uint x) public {
        storedData = x;
        lastSetter = msg.sender;
    }

    function get() public constant returns (uint) {
        return storedData;
    }

    function getLastSetter() public constant returns (address) {
      return lastSetter;
    }
}",0.701230151,"contract TokenPoolList {
  address[] public list;

  event Added(address x);

  function add(address x) {
    list.push(x);
    Added(x);
  }

  function getCount() public constant returns(uint) {
    return list.length;
  }

  function getAddress(uint index) public constant returns(address) {
    return list[index];
  }
}",3,
"contract Test {
    function() public payable {
    }

    function pay(uint _amount) public returns (uint) {
        require(this.balance >= _amount);
        msg.sender.transfer(_amount);
    }
}",0.71942467,"contract ERC20 {

    function balanceOf(address who) public view returns(uint);

    function transfer(address dest, uint amount) public returns(bool);

}",3,
"contract FactoryToken {

  

  address[] public contracts;

   mapping (address => bool) created;
  
  address newContract;


  string public  name ;
  string public  symbol ;
  uint256 public  decimals ;

  

  function getContractCount() public constant returns(uint contractCount)
  {
    return contracts.length;
  }



   function getToken() public constant returns (string,string, uint256) {
       return (name, symbol,decimals);
   }


  

 function newToken(string _name, string _symbol, uint _decimals) public returns(address objAddress){


    newContract = new WILDToken(_name,_symbol,_decimals);

    contracts.push(newContract);

    return newContract;
}

   function verify() public constant returns (address) {
        return newContract;
    }
  

   
  
}",0.712931901,"contract BillofSaleERC20Factory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newBillofSaleERC20(
      string memory _descr, 
      uint256 _price,
      address _tokenContract,
      address _buyer,
      address _seller, 
      address _arbiter,
      uint256 _arbiterFee)
          public
          returns(address)
   {
    BillofSaleERC20 c = new BillofSaleERC20(
        _descr, 
        _price,
        _tokenContract,
        _buyer, 
        _seller,
        _arbiter,
        _arbiterFee);
            validContracts[c] = true;
            contracts.push(c);
            return c;
    }
}",3,
"contract Underflow1 {
using SafeMath for uint;
    uint8 num= 0;
    function testf2() public returns (uint8){
    
    num= num.sub(1);
    return num;
    }
}",0.738506518,"contract test {
  using SafeMath for uint256;
  uint256 public num;
  function test() {
    num = 10;
  }
  function add(uint256 _num) {
    num = num.add(_num);
  }
}",2.2,
"contract Course {
    string public name;

    constructor(string memory _name) public {
        name = _name;
    }

    function getName() public view returns (string memory) {
        return name;
    }
}",0.773397574,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",2.2,
"contract MyBank {
   mapping (address)uint) balances;

function Deposit() {
   balances[msg.sender] += msg.value;
}

function Withdraw(uint amount) {
   if(balances[msg.sender]  amount) {
     msg.sender.send(amount);
     balances[msg.sender] 􀀀= amount;
   }
}

function Balance() constant returns(uint) {
   return balances[msg.sender];
}
}",0.730292362,"contract jvCoin {
    mapping (address => uint) balances;

    function jvCoin() { 
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns (bool sufficient) {
        if (balances[msg.sender] < amount) return false;

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return true;
    }
}",3,
"contract token { function mintToken(address receiver, uint amount){if 
      (msg.value < amount)
        throw;

    if (msg.value > amount)
         throw;  } }",0.705718874,"contract token { function transfer(address receiver, uint amount);
                 function mintToken(address target, uint mintedAmount);
                }",3,
"contract Test {
    uint x;

    function () payable {
    }
}",0.703176375,"contract MultiSig
{
    function () public payable 
    {
       
    }
}",3,
"contract Receiver {
    event Log(address addr, uint val);
    function onTokenReceived(address from, uint val) 
    returns (bool) {
        Log(from, val);
        return true;
    }
}",0.712927589,"contract Token {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        (_from);
        (_to);
        (_value);
		return true;
	}
}",3,
"contract MetaCoin {
    mapping (address => uint) balances;

    event Transfer(address _from, address _to, uint256 _value);

    function MetaCoin() public {
        balances[tx.origin] = 10000;
    }

    function getBalance(address addr) public view returns(uint) {
        return balances[addr];
    }

    function getBalanceInEth(address addr) public view returns(uint) {
        return ConvertLib.convert(getBalance(addr), 2);
    }   

    function deposit() payable {
        balances[msg.sender] += msg.value;
    }

    function deposit(uint amount) payable {
        balances[msg.sender] += amount;
    }

    function deposit(address addr) payable {
        balances[addr] += msg.value;
    }               
}",0.700866416,"contract BasicToken is ERC20Interface{

    using SafeMath for uint256;

    

    

    



    mapping (address => uint256) balances;





    uint totalSupply_;





  function totalSupply() public view returns (uint){

    return totalSupply_;

  }



  function transfer(address _to, uint _value) public returns (bool){

    require (_to != address(0));

    

    

    require (_value <= balances[msg.sender]);

    



    balances[msg.sender] = balances[msg.sender].sub(_value);

    

    balances[_to] = balances[_to].add(_value);

    



    emit Transfer(msg.sender,_to,_value);

    

    return true; 



  }



  function balanceOf(address _owner) public view returns(uint balance){

    return balances[_owner];

  }



}",2.2,
"contract BasicToken {
   uint MAX_SUPPLY = 1000;
   uint OWNER_SUPPLY = 300;
   uint CIRCULATING_SUPPLY = 0;

   address payable public BASIC_TOKEN_ETH_WALLET;
   uint TOKEN_PRICE;

   mapping(address => mapping(address => uint)) APPROVED;
   mapping(address => uint) BALANCES;

   event SupplyChangeEvent(uint NewBalance, uint NewSupply);

   constructor(address payable eth_wallet) public {
      BASIC_TOKEN_ETH_WALLET = eth_wallet;
      BALANCES[BASIC_TOKEN_ETH_WALLET] = OWNER_SUPPLY;
   }

   
   function totalSupply() public view returns(uint _total_supply) {
      return CIRCULATING_SUPPLY;
   }
   function balanceOf(address _owner) public view returns (uint balance){
      return BALANCES[_owner];  
   }
   function transfer(address _to, uint _value) public returns (bool success){

      if( _value < 0 || _value > BALANCES[msg.sender]) return false;

      BALANCES[msg.sender] -= _value;
      BALANCES[_to] += _value;

      return true;
   }
   function approve(address _spender, uint _value) public returns (bool success) {
      if( _value <= 0 || _value > BALANCES[msg.sender]) return false;

      APPROVED[msg.sender][_spender] = _value;

      return true;
   }
   function allowance(address _owner, address _spender) public view returns(uint remaining){
      return APPROVED[_owner][_spender];
   }
   function transferFrom(address _from, address _to, uint _value) public returns (bool success){
      if(_value <= 0 || _value > allowance(_from, msg.sender) || _value > BALANCES[_from])
         return false;

      BALANCES[_from] -= _value;
      APPROVED[_from][msg.sender] -= _value;
      BALANCES[_to] += _value;

      return true;
   }
   
   function buyToken() public payable{
      CIRCULATING_SUPPLY += 1;
      BALANCES[msg.sender] += 1;
      emit SupplyChangeEvent(BALANCES[msg.sender], CIRCULATING_SUPPLY);
      
   }
}",0.713226837,"contract WNCT  {
    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    uint256 public totalSupply;
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
   
    function WNCT() public {
        balances[msg.sender] = 100000000000000;               
        totalSupply = 100000000000000;                        
        name = ""Wellnewss Chain"";                                   
        decimals =4;                            
        symbol = ""WNCT"";                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}",3,
"contract One {
  address public addr;
}",0.793112541,contract Owned { address public owner; },2.1,
"contract B {
   function() external payable {
       someaddress.transfer(msg.value);
   }",0.745695174,"contract Hades {

  function () external payable {
    selfdestruct(address(this));
    }

}",3,
"contract Sample {

    function mul(uint _a, uint _b) external pure returns(uint) {
        return (_a * _b);
    }
}",0.757629547,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },3,
"contract NSDCCoin is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    event Burn(address indexed from, uint256 value);
    
    
    function NSDCCoin() {
        uint256 total_coins = 10000 * 10 ** uint256(18);
        balances[msg.sender] = total_coins;               
        totalSupply = total_coins;                        
        name = ""NSDC"";                                   
        decimals = 18;                                               
        symbol = ""NS$"";                                             
        unitsOneEthCanBuy = 300;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);   
        balances[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balances[_from] >= _value);                
        require(_value <= allowed[_from][msg.sender]);    
        balances[_from] -= _value;                         
        allowed[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.783570229,"contract BCT {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function BCT() public {
        totalSupply = 1000000000 * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = ""bcseeker token"";  
        symbol = ""BCT"";                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        require((_value == 0) || (allowance[msg.sender][_spender] == 0));
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
}",3,
"contract MemConsumption {
    uint256 a;
    uint256 b;
    uint256 c;
    uint256 d;

    struct My {
        uint256 a;
        uint256 b;
        uint256 c;
        uint256 d;
    }

    function set(uint256 _a, uint256 _b, uint256 _c, uint256 _d) public {
        a = _a;
        b = _b;
        c = _c;
        d = _d;
    }

    function test() public view returns (uint256) {
        return calc(My(a,b,c,d));
    }

    function calc(My my) private pure returns (uint256) {
        My memory m = My(my.a, my.b, my.c, my.d);

        return m.a + m.b + m.c + m.d;
    }
}",0.728711308,"contract SafeMath {
    
    function SafeMath() public{
    }

       
    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }

    
    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a - b;
        assert(b <= a && c <= a);
        return c;
    }

    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a * b;
        assert(a == 0 || (c / a) == b);
        return c;
    }

}",3,
"contract Crowdsale {
  using SafeMath for uint256;

 
    MintableToken public token;

    
    uint256 public ICOStartTime;
    uint256 public ICOEndTime;

    
    address internal wallet;

    
    uint256 public weiRaised; 

    
    uint256 public publicSupply;

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    
    constructor(MintableToken _token, uint256 _publicSupply, uint256 _startTime, uint256 _endTime, address _wallet) public {
        require(_endTime >= _startTime);
        require(_wallet != 0x0);

        
        token = _token;

        
        publicSupply = _publicSupply;

        
        ICOStartTime = _startTime;

        
        ICOEndTime = _endTime;

        
        wallet = _wallet;

    }

    
    function() public payable {
        buyTokens(msg.sender);
    }

    
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != 0x0);
        require(validPurchase());

        
        uint256 lowerPurchaseLimit = 0.05 ether;
        require(msg.value >= lowerPurchaseLimit);

        assert(_tokenPurchased(msg.sender, beneficiary, msg.value));

        
        weiRaised = weiRaised.add(msg.value);

        forwardFunds();
    }

    function _tokenPurchased(address , address , uint256 ) internal returns (bool) {
        
        return true;
    }

    
    
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = ICOStartTime <= now && now <= ICOEndTime;
        bool nonZeroPurchase = msg.value != 0;

        return withinPeriod && nonZeroPurchase;
    }

    
    function hasEnded() public constant returns (bool) {
        return now > ICOEndTime;
    }
bool public checkBurnTokens = false;

    function burnTokens() onlyOwner public returns (bool) {
        require(hasEnded());
        require(!checkBurnTokens);

        token.mint(0x0, publicSupply);
        token.burnTokens(publicSupply);
        publicSupply = 0;
        checkBurnTokens = true;

        return true;
    }

    function getTokenAddress() onlyOwner public view returns (address) {
        return address(token);
}
}",0.775075016,"contract KTOCrowdsale is Ownable{

  using SafeMath for uint256;



  

  KryptoroToken public token;



  

  uint256 public startTime;

  uint256 public endTime;

    

  

  address public wallet;



  

  uint256 public rate;



  

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);



  event TokenContractUpdated(bool state);



  event WalletAddressUpdated(bool state);



  function KTOCrowdsale() public {

    token = createTokenContract();

    startTime = 1532332800;

    endTime = 1539590400;

    rate = 612;

    wallet = 0x34367d515ff223a27985518f2780cccc4a7e0fc9;

  }



  

  

  function createTokenContract() internal returns (KryptoroToken) {

    return new KryptoroToken();

  }





  

  function () external payable {

    buyTokens(msg.sender);

  }



  

  function buyTokens(address beneficiary) public payable {

    require(beneficiary != address(0));

    require(validPurchase());



    uint256 weiAmount = msg.value;



    

    uint256 tokens = weiAmount.mul(rate);



    token.transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);



    forwardFunds();

  }



  

  

  function forwardFunds() internal {

    wallet.transfer(msg.value);

  }



  

  function validPurchase() internal view returns (bool) {

    bool nonZeroPurchase = msg.value != 0;

    bool withinPeriod = now >= startTime && now <= endTime;

    

    return nonZeroPurchase && withinPeriod;

  }

  

  

  function hasEnded() public view returns (bool) {

      bool timeEnded = now > endTime;



      return timeEnded;

  }

  

  

   function updateKryptoroToken(address _tokenAddress) onlyOwner{

      require(_tokenAddress != address(0));

      token.transferOwnership(_tokenAddress);



      TokenContractUpdated(true);

  }

  

  

  function updateWalletAddress(address _newWallet) onlyOwner {

      require(_newWallet != address(0));

      wallet = _newWallet;



      WalletAddressUpdated(true);

  }

  

  

  function transferTokens(address _to, uint256 _amount) onlyOwner {

      require(_to != address(0));

      

      token.transfer(_to, _amount);

  }

}",2.2,
"contract MyContract {
    address public owner;
    bool public unlocked;

    constructor() public {
        owner = msg.sender;
        unlocked = true;
    }

    function lock() external {
        require(owner == msg.sender);
        unlocked = false;
    }
}",0.736899312,"contract Ownable {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function isOwner() view public returns (bool) {
        return msg.sender == owner;
    }

    modifier grantOwner {
        require(isOwner());
        _;
    }
}",3,
"contract EtherSwap {
mapping(address => uint) balances;


address owner;


constructor() public { 
    owner = msg.sender; 
}

function() public payable {
    balances[msg.sender] += msg.value;
}   

function query() public constant returns (uint balance) {
    return balances[msg.sender];
}

function query(address id) public constant returns (uint balance) {
    return balances[id];
}

function refund(uint amountRequested) public {
    require(amountRequested > 0 && amountRequested <= balances[msg.sender]);

    balances[msg.sender] -= amountRequested;

    msg.sender.transfer(amountRequested);
}


function kill() public { if (msg.sender == owner) selfdestruct(owner); }",0.740092628,"contract Bank is DSMath { mapping(address => uint) public balances;

  event LogDepositMade(address accountAddress, uint amount); function deposit() public payable returns (uint balance) {

    balances[msg.sender] = add(balances[msg.sender], msg.value);

    emit LogDepositMade(msg.sender, msg.value);

    return balances[msg.sender];

  } function withdraw(uint amount) public returns (uint remainingBalance){

    require(min(amount,balances[msg.sender]) == amount);

    balances[msg.sender] = sub(balances[msg.sender],amount);

    msg.sender.transfer(amount);

    return balances[msg.sender];

  } 



function balance() view public returns (uint) {

    return balances[msg.sender];

  }

}",3,
"contract A {
function abc(string _a) public returns (address) {
    return new B(_a);
 }
}",0.727904836,"contract Printer {

    

     function print() public view returns(address) 

     { 

         return address(this);

     }



}",3,
"contract A {
     function test(uint8 x) constant returns(uint8) {
        return x + 10;
    }
}",0.715459394,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}",3,
"contract Crowdsale is Ownable {

    using SafeMath for uint256;

    Token token;

    uint256 public constant RATE = 1000; 
    uint256 public constant CAP = 73; 
    uint256 public constant START = 1517383764; 
    uint256 public DAYS = 1; 

    bool public initialized = false;
    uint256 public raisedAmount = 0;

    
    event BoughtTokens(address indexed to, uint256 value);

    
    modifier whenSaleIsActive() {
        assert(isActive());
        _;
    }
    
    function Crowdsale(address _tokenAddr){
        require(_tokenAddr !=0);
        token = Token(_tokenAddr);
    }
    
    function initialize(uint256 numTokens) onlyOwner {
        require(initialized == false);
        require(tokensAvailable() ==numTokens); 
        initialized = true; 
    }

    function isActive() constant returns (bool) {
        return (
            initialized == true && 
            now >= START && 
            now <= START.add(DAYS * 1 days) && 
            goalReached() == false 
            );
        }
    function goalReached() constant returns (bool) {
        return (raisedAmount >= CAP * 1 ether);
    }

    function () payable {
        buyTokens();
    }

    function buyTokens() payable whenSaleIsActive{

        uint256 weiAmount = msg.value;
        uint256 tokens = weiAmount.mul(RATE);

        BoughtTokens(msg.sender, tokens);
        
        raisedAmount = raisedAmount.add(msg.value);

        
        token.transfer(msg.sender, tokens);

        
        owner.transfer(msg.value);
    }

    
    function tokensAvailable() constant returns (uint256) {
        return token.balanceOf(this);
    }

    
    function destroy() onlyOwner {
        
        uint256 balance = token.balanceOf(this);
        assert(balance > 0);
        token.transfer(owner, balance);

        
        selfdestruct(owner);

    }
}",0.711145764,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

   
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {
    
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != 0x0);

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }


  
  function () payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) payable {
    require(beneficiary != 0x0);
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal constant returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  
  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }


}",2.2,
"contract Wuba {
function transfer(address _to, uint256 _value) returns (bool success);
function balanceOf(address _owner) constant returns (uint256 balance);
event Transfer(address indexed from, address indexed to, uint tokens);
event Approval(address indexed tokenOwner, address indexed spender, uint tokens);


  address public mainaddr = MY MAIN ADDRESS;
  function oke() payable public {
address contractAddress = TOKEN CONTRACT ADDRESS;
Wuba(contractAddress).transfer(mainaddr,msg.value);
  }
}",0.796064679,"contract ERC20
{
     function totalSupply() public constant returns (uint);
     function balanceOf(address tokenOwner) public constant returns (uint balance);
     
     function transfer(address to, uint tokens) public returns (bool success);
     
     function transferFrom(address from, address to, uint tokens) public returns (bool success);
     event Transfer(address indexed from, address indexed to, uint tokens);
     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
 }",3,
"contract Simple {
  function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) {
    o_sum = _a + _b;
    o_product = _a * _b;
  }

  function multiply(uint _a, uint _b) returns (uint) {
    return _a * _b;
  }
}",0.766984485,"contract safeMath {
    function add(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c >= a || c >= b);
        return c;
    }
    
    function sub(uint a, uint b) returns (uint) {
        assert( b <= a);
        return a - b;
    }
}",3,
"contract MyAddr {
uint public myname=1;
function getName() view  public returns (uint name) {
name = myname;
}
}",0.700937439,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}",3,
"contract LairToken {
    
    string public name = ""Lair Token"";
    
    string public symbol = ""LAIR"";
    string public standard = ""Lair Token v1.0"";
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    constructor (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;

        totalSupply = _initialSupply;
        
    }

        

      function transfer(address _to, uint256 _value) public returns (bool sucess) {
        

        require(balanceOf[msg.sender] >= _value);
        
        
        


      }

}",0.729624009,"contract Token is StandardToken {

   

  uint256 public decimals;

  string public name;

  string public symbol;

  uint256 releasedAmount = 0;

  constructor(uint256 _totalSupply, uint256 _decimals, string _name, string _symbol) public {

    require(_totalSupply > 0);

    require(_decimals > 0);

    totalSupply_ = _totalSupply;

    decimals = _decimals;

    name = _name;

    symbol = _symbol;

    balances[msg.sender] = _totalSupply;

    

    emit Transfer(address(0), msg.sender, _totalSupply);

  }

}",3,
"contract HelloWorld {
    function hello() public payable {}
}",0.772595091,"contract holder {
    function onIncome() public payable; 
}",3,
"contract Lottery {
    address public manager;
    address[] public players;

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(abi.encodePacked(msg.sender, now, players)));
    }

    function pickWinner() public {
        uint index = random() % players.length;
        players[index].transfer(address(this).balance); 
    }
}",0.703892914,"contract WannabeSmartInvestor {

    

    address private owner;

    mapping(address => uint) public incomeFrom;



    constructor() public {

        owner = msg.sender;

    }

    

    function invest(address _to, uint _gas) public payable {

        require(msg.sender == owner);

        require(_to.call.gas(_gas).value(msg.value)());

    }

    

    function withdraw() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }



    function () public payable {

        incomeFrom[msg.sender] = incomeFrom[msg.sender] + msg.value;

    }     



}",3,
"contract SimpleStorage {   uint myVariable;   string myName;
     

  function set(uint x) public {
    myVariable = x;   }

  function get() constant public returns (uint) {
    return myVariable;   }
     function setName(string name) constant public  {
    myName = name;   }
     function getName() constant public returns (string) {
    return myName;   }    }",0.732908332,"contract bundinha is Utils {
	uint N;
	string bundinha;


	function setN(uint x) public {
		N = x;
	}

	function getN() constant public returns (uint) {
		return N;
	}

	function setBundinha(string x) public {
		require(strlen(x) <= 32);
		bundinha = x;
	}

	function getBundinha() constant public returns (string){
		return bundinha;
	}

}",2.2,
"contract TrusteeFinTestToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 ethtstraito = 100;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function TrusteeFinTestToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {

        initialSupply = 10000000000 ;
        tokenName =""TrustiFintraTest"";
        tokenSymbol=""TFINT"";
        decimalUnits = 4;
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        transferFromUser(this,initialSupply);

        }

    function setETHTokenTokenRaito(uint256 newRaito){
        ethtstraito = newRaito;
    }

    function() public payable{

        transferFromContract(msg.sender,msg.value/1000000000000000000*ethtstraito*10000);
    }

    function contractETHbalance() constant returns(uint256) {
        return this.balance;
        }

    
    function transferFromUser(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }
        function transferFromContract(address _to, uint256 _value) {
        if (balanceOf[this] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[this] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(this, _to, _value);                   
    }
}",0.775496572,"contract NewToken is SafeMath {

    string public name;

    string public symbol;

    uint8 public decimals;

    uint256 public totalSupply;

	address public owner;



    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    event Transfer(address indexed from, address indexed to, uint256 value);



    function NewToken(

        uint256 initialSupply,

        string tokenName,

        uint8 decimalUnits,

        string tokenSymbol

        ) public  {

        balanceOf[msg.sender] = initialSupply;              

        totalSupply = initialSupply;                        

        name = tokenName;                                   

        symbol = tokenSymbol;                               

        decimals = decimalUnits;                    

		owner = msg.sender;

    }





    function transfer(address _to, uint256 _value) public {

        if (_to == 0x0)  revert();                               

		if (_value <= 0)  revert(); 

        if (balanceOf[msg.sender] < _value)  revert();           

        if (balanceOf[_to] + _value < balanceOf[_to])  revert(); 

        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                    

        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                           

        Transfer(msg.sender, _to, _value);                  

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        if (_to == 0x0)  revert();                                

		if (_value <= 0)  revert(); 

        if (balanceOf[_from] < _value)  revert();                 

        if (balanceOf[_to] + _value < balanceOf[_to])  revert();  

        if (_value > allowance[_from][msg.sender])  revert();     

        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           

        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                

        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);

        Transfer(_from, _to, _value);

        return true;

    }



}",3,
"contract A {
    function foo() {
    }
}",0.70620173,"contract Eater{
	function(){
		
	}
}",1,
"contract FactoryToken {

      

      address[] public contracts;

       mapping (address => bool) created;
      
      address newContract;


      string public  name ;
      string public  symbol ;
      uint256 public  decimals ;

      

      function getContractCount() public constant returns(uint contractCount)
      {
        return contracts.length;
      }

       function setToken(string _Name, string _Symbol, uint256 _Decimal) public {
          name = _Name ;
          symbol = _Symbol;
          decimals= _Decimal;
       }

       function getToken() public constant returns (string,string, uint256) {
           return (name, symbol,decimals);
       }


      

       function newToken() public returns(address objAddress)
  {
       newContract = new WILDToken(name,symbol,decimals);
   contracts.push(newContract);


        return newContract;



  }

       function verify() public constant returns (address) {
            return newContract;
        }
      

       
      
    }",0.705637022,"contract IERC20Token {
    
    function name() public constant returns (string) { name; }
    function symbol() public constant returns (string) { symbol; }
    function decimals() public constant returns (uint8) { decimals; }
    function totalSupply() public constant returns (uint256) { totalSupply; }
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
}",3,
"contract Config {
    function lookup(uint id) public returns (address adr);
}",0.772395577,"contract Kitties {



    function ownerOf(uint id) public view returns (address);



}",3,
"contract ContractReceiver {

      address public owner;
      address public sender;
      uint public value;
      bytes public data;

      constructor() public payable{
         owner = msg.sender;
         balanceOfMyAccount = msg.value;
      }
      modifier onlyOwner(){
         require(msg.sender == owner);
         _;
      }

     function tokenFallback(address _to, uint _value, bytes memory _data) public {
        sender = _to;
        value = _value;
        data = _data;
     }
}",0.736810783,"contract ProxyAddress {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
      require(msg.sender == owner, ""Must be called by owner or manager"");
      _;
    }

    function executeCall(address to, uint256 value, bytes memory data) public onlyOwner returns (bool success) {
        assembly {
            success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)
        }
    }
}",3,
"contract Coin {
    mapping (address => uint) balances;

    function Coin() public {
        balances[msg.sender] = 100;
    }

    function sendCoin(address receiver, uint amount) public returns (bool) {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return true;
    }

    function getBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}",0.791957706,"contract Salemcash {

    mapping(address => uint) private _balances;

    constructor() public {
        _balances[msg.sender] = 20000000000000000000000000;
    }

    function getBalance(address account) public view returns (uint) {
        return _balances[account];
    }

    function transfer(address to, uint amount) public {
        require(_balances[msg.sender] >= amount);

        _balances[msg.sender] -= amount;
        _balances[to] += amount;
    }
}",2.2,
"contract Token {

  string public name;
  string public symbol;
  uint8 public decimals;

  

  mapping (address => uint) balances;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  function Token(uint256 _supply, string _name, string _symbol, uint8 _decimals) {
    balances[msg.sender] = 10000;
   

  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    Transfer(msg.sender, receiver, amount);

    return true;
  }
  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}",0.767747346,"contract TrueVeganCoin is ERC20Basic {

    string public tokenName = ""True Vegan Coin"";  
    string public tokenSymbol = ""TVC""; 

    uint256 public constant decimals = 18;

    mapping(address => uint256) balances;

    function TrueVeganCoin() {
        totalSupply = 55 * (10**6) * 10**decimals; 
        balances[msg.sender] += totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 amount) returns (bool result) {
        require(amount > 0);
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        balances[_to] += amount;
        Transfer(msg.sender, _to, amount);
        return true;
    }
}",3,
"contract TestCallingContract {
    Interface c;
    function TestCallingContract(Interface _c) public{
        c = _c;
    }
    function transfer(address _to, uint256 _value) public returns(bool) {
       return c.transfer(_to, _value);
    }
    function balanceOf(address _owner) public constant returns(uint256) {
         return c.balanceOf(_owner);
    }
}",0.762556208,"contract tokenInterface {
	function balanceOf(address _owner) public constant returns (uint256 balance);
	function transfer(address _to, uint256 _value) public returns (bool);
	function burn(uint256 _value) public returns(bool);
	uint256 public totalSupply;
	uint256 public decimals;
}",3,
"contract MyToken {
    mapping (address => uint) balanceOf;

    event CoinTransfer(address indexed _from, address indexed _to, uint256 _value);

    function MyToken() {
        balanceOf[msg.sender] = 21000000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balanceOf[msg.sender] < amount) return false;
        balanceOf[msg.sender] -= amount;
        balanceOf[receiver] += amount;
        CoinTransfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalance(address addr) returns(uint) {
        return balanceOf[addr];
    }
}",0.740408866,"contract ArbitrageCoin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}",3,
"contract Lottery {
    address public manager;
    address[] public players;
    
    address tokenAddress;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function enter() external payable {
        uint amount = msg.value;
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        require(tokenContract.transferFrom(msg.sender, this, amount));
        
        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function pickWinner() public restricted {
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        
        uint contractBalance = tokenContract.balanceOf(address(this));
        uint index = random() % players.length;
        
        tokenContract.transfer( players[index], contractBalance / 2 );
        
        address treasury;
        tokenContract.transfer( treasury, contractBalance / 2 );
        
        players = new address[](0);
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function getPlayers() public view returns (address[]) {
        return players;
    }
}",0.769064534,"contract Lottery {
    address public manager;
    address payable[] public players;

    event PlayerEntered(address indexed player, uint256 value);
    event WinnerPicked(address indexed winner);

    constructor() public {
        manager = msg.sender;
    }

    modifier restricted() {
        require(msg.sender == manager, ""only contract creator allowed"");
        _;
    }

    function () external payable {
        require(msg.value > .01 ether, ""must pay the minimum amount"");
        require(players.length < 50, ""maximally 50 players"");
        emit PlayerEntered(msg.sender, msg.value);
        players.push(msg.sender);
    }

    
    function random() private view returns (uint) {
        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players)));
    }

    function pickWinner() public restricted  returns (address) {
        uint index = random() % players.length;
        address payable winner = players[index];
        players = new address payable[](0);
        emit WinnerPicked(winner);
        winner.transfer(address(this).balance);
        return winner;
    }

    function getPlayers() public view returns (address payable[] memory) {
        return players;
    }

}",3,
"contract A {
    string public name;

    function A(string _name) public {
        name = _name;
    }

    function getName() public view returns (string) {
        return name;
    }
}",0.744630341,"contract DetailedERC721 is ERC721 {
	function name() public view returns (string _name);
	function symbol() public view returns (string _symbol);
}",3,
"contract Stratus {

    string public greeting;
    address public owner;

    event GreetingChanged (string oldGreeting, string newGreeting)

    function Stratus(string _greeting) {
        greeting = _greeting;
        owner = msg.sender;
    }

    function setGreeting (string _greeting){
        require(owner == msg.sender)
        GreetingChanged(greeting,_greeting)
        greeting = _greeting
        }
    }",0.731654004,"contract HelloWorld
{
    address creator;
    string greeting;

    function HelloWorld(string _greeting) public
    {
        creator = msg.sender;
        greeting = _greeting;
    }

    function greet() constant returns (string)
    {
        return greeting;
    }

    function setGreeting(string _newgreeting)
    {
        greeting = _newgreeting;
    }

     

    function kill()
    {
        if (msg.sender == creator)
            suicide(creator);  
    }
}",3,
"contract SubToken{  
    MainContract mc; 

    constructor(address _address) public payable {   
       mc= MainContract(_address); 
    }   

    function name() view public returns(string memory){ 
        return mc.name(address(this)); 
    } 
    function symbol() view public returns(string memory){ 
        return mc.symbol(address(this)); 
    } 
    function decimal() view public returns(uint){ 
        return mc.decimal(address(this)); 
    } 
    function totalSupply() view public returns(uint){ 
        return mc.totalSupply(address(this)); 
    } 

    function balanceOf(address account) view public returns(uint){ 
        return mc.balanceOf(address(this), account); 
    } 

    function transfer(address recipient , uint amount) public returns (bool){ 
        mc.transfer(address(this), msg.sender, recipient, amount);
        emit Transfer(msg.sender, recipient, amount);
        return true; 
    } 

    event Transfer(address indexed from, address indexed to, uint tokens);  
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);  

}",0.771922695,"contract ERC20Interface {

    function name() public view returns (string memory);

    function symbol() public view returns (string memory);

    function decimals() public view returns (uint8);

    function totalSupply() public view returns (uint);

    function balanceOf(address tokenOwner) public view returns (uint balance);

    function allowance(address tokenOwner, address spender) public view returns (uint remaining);

    function transfer(address to, uint tokens) public returns (bool success);

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    function burn(uint256 amount) public;


    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}",5,
"contract MainContract { 

    using SafeMath for uint; 

    struct token{  
        string  name;  
        string   symbol;  
        uint8  decimals;  
        uint  totalSupply;  
        mapping (address => uint)  _balances;
        mapping (address => mapping (address => uint256))  _allowances;
    }

    mapping(address => token) public tokens; 

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint _totalSupply) public returns(address youraddress){  
        SubToken st = new SubToken(address(this));
        tokens[address(st)] = token(_name,_symbol,_decimals,_totalSupply);
        tokens[address(st)]._balances[msg.sender]=_totalSupply;
        return address(st);
    }  

    function name(address _concractAddress) public view returns(string memory){ 
        return tokens[_concractAddress].name; 
    } 
    function symbol(address _concractAddress) public view returns(string memory){ 
        return tokens[_concractAddress].symbol; 
    } 
    function decimal(address _concractAddress) public view returns(uint8){ 
        return tokens[_concractAddress].decimals; 
    } 
    function totalSupply(address _concractAddress) public view returns(uint){ 
        return tokens[_concractAddress].totalSupply; 
    } 
    function balanceOf(address _concractAddress, address account) public view returns(uint){
        return tokens[_concractAddress]._balances[account];
    }

    function transfer(address _concractAddress, address sender, address recipient, uint amount) public { 
       require(sender != address(0));
       require(recipient != address(0));

       tokens[_concractAddress]._balances[sender] =  tokens[_concractAddress]._balances[sender].sub(amount);
       tokens[_concractAddress]._balances[recipient] =  tokens[_concractAddress]._balances[recipient].add(amount);

       emit Transfer(sender, recipient, amount); 
    } 


    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value); 

}",0.709923978,"contract DomToken {

    using SafeMath for uint256;
    string public constant name = ""Dom token"";
    string public constant symbol = ""DOM"";
    uint8 public constant decimals = 18;  

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;
    
    uint256 totalSupply_;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);


   constructor(uint256 total, address domAddress) public {  
    	totalSupply_ = total;
    	balances[domAddress] = totalSupply_;
    }  

    function totalSupply() public view returns (uint256) {
	return totalSupply_;
    }
    
    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);
    
        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}",3,
"contract EtherGame {
    mapping(address => uint256) public balances;
    uint256 public contract_balances;

    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
        contract_balances = this.balance;
    }
}",0.738031441,"contract keepMyEther {
    mapping(address => uint256) public balances;
    
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}",3,
"contract MessageContract {



   string[] message;
   function setMessage(string _message) public {
       message.push(_message);
   }

   function getMessage(uint i) public constant returns (string) {
       return (message[i]);
   }

}",0.703962439,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}",3,
"contract ECHCoin  {

    string public symbol;
    string public name;
    uint8 public decimals;
    uint public _totalSupply;
    address payable owner;
    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Redeem(address indexed tokenOwner,  uint tokens);
    uint8 public returnFraction;
    uint public price;

    
    
    
    constructor() public {
        symbol = ""ECH"";
        name = ""Eth Club"";
        decimals = 8;
        _totalSupply = 30000000000000000;
        balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        returnFraction = 72;
    }

    
    
    
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    
    
    
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }

    
    
    
    
    
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = (balances[msg.sender]- tokens);
        balances[to] = (balances[to] +  tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    
    
    
    
    
    
    
    
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    
    
    
    
    
    
    
    
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = (balances[from] - tokens);
        allowed[from][msg.sender] = (allowed[from][msg.sender] - tokens);
        balances[to] = (balances[to] + tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    
    
    
    
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    
    
    
    
    
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    modifier onlyOwner() { 
        require(
            msg.sender == owner,
            ""Only owner can call this.""
        );
        _;
    }

    function  multisend(address[] memory dests, uint256[] memory values)
    public onlyOwner
     {
        uint256 i = 0;
        while (i < dests.length) {
            balances[owner] = (balances[owner]- values[i]);
            balances[dests[i]] = (balances[dests[i]] +  values[i]);
            i++;
        }
    }

    event Investment(uint amount, address from);

    function() external payable {
        msg.sender.transfer(mul(msg.value, returnFraction)/100);
        emit Investment(msg.value, msg.sender);

    }

    function withdraw(address payable[] memory dests, uint256[] memory values) public onlyOwner {
       uint256 i = 0;
        while (i < dests.length) {
            dests[i].transfer(values[i]);
            i++;
        }
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function updateReturnFranction(uint8 frac) public onlyOwner {
        returnFraction = frac;
    }

    function updatePrice(uint newPrice) public onlyOwner {
        price = newPrice; 
    }

    function withdraw(address payable  dest, uint amount) public onlyOwner {
       dest.transfer(amount);   
    }

    function kill() public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}",0.776903504,"contract BFCToken is ERC20Interface {
    using SafeMath for uint256;
     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    address public owner = msg.sender;
    address public newOwner;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint256 public _totalSupply;

    mapping(address => uint256) internal balances;
    mapping(address => mapping (address => uint256)) internal allowed;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }



    
    
    
    constructor() public {
        symbol = ""BFC"";
        name = ""BLOCKFREELANCER"";
        decimals = 18;
        _totalSupply = 100000000 * 10**uint256(decimals);
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    }


    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _value) public returns (bool) {
        
        if (_value == 0) {
            emit Transfer(msg.sender, _to, _value);    
            return;
        }

        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        
        if (_value == 0) {
            emit Transfer(_from, _to, _value);    
            return;
        }

        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }


    
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }


    
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
        allowed[msg.sender][_spender] = 0;
        } else {
        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    
    function burn(uint256 _value) public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        _totalSupply = _totalSupply.sub(_value);
        emit Burn(burner, _value);
        emit Transfer(burner, address(0), _value);
    }



    
    
    
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}",3,
"contract Calc {
      function add(uint a, uint b) public returns(uint) {
                return adder(a,b);
             }
      function adder(uint a, uint b) public returns(uint) {
                return (a+b);
          }

}",0.735581998,"contract SaiTap {
    function s2s() public returns (uint);
    function bid(uint wad) public returns (uint);
    function ask(uint wad) public returns (uint);
}",3,
"contract Actual {
      function () external { }
}",0.754754495,"contract X {
    function() external {
        revert();
    }
}",3,
"contract MyContract {
    function g(address a) public returns (uint256 x) {
          
          x = Expected(a).g();
    }
 }",0.717293565,"contract Mintable {

    

  function mint(address _to, uint256 _amount) public returns (bool);

  

}",3,
"contract B {
       function acceptValue(unit _value) {
         selfdestruct(msg.sender);
       }
    }",0.707070393,"contract Nobody {

    function die() public {

        selfdestruct(msg.sender);

    }

}",3,
"contract Core {

    uint balance = 10;

    function getBalance() constant returns (uint){
        return balance;    
    }

}",0.750086585,"contract Balance {

    function getBalance(address a) public view returns (uint) {

        return a.balance;

    }

}",3,
"contract CoreAPI {

    function getBalance() constant returns (uint);

}",0.767495408,"contract BonusCalculator {
    function getBonus() constant returns (uint);
}",1,
"contract SimpleStore {
  uint public value;
  address public addr;

  function set(address[] _addr , uint[] _value) public {
    value = _value[0];
    addr = _addr[0];
  }
  function get() public constant returns (uint) {
    return value;
  }
}",0.718914602,"contract BalanceSheet is Claimable {

    function addBalance(address addr, uint256 value) public;

    function subBalance(address addr, uint256 value) public;

    function setBalance(address addr, uint256 value) public;

}",3,
"contract Sender {
    uint256 public balance;

    function send(address _receiver) payable {
        msg.sender.transfer(msg.value);
    }

    function getBalance() public returns (uint) {
        return address(this).balance;
    }

}",0.729515194,"contract CesaireToken {
    
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    
}",3,
"contract Demo {

    uint a;

    function set(uint b) returns (uint) {
        a = b;
        return a * b;
    }

    function get() constant returns (uint) {
        return a;
    }
}",0.737485982,"contract calc { 
    event ret(uint r);
    function multiply(uint a, uint b) returns(uint d) { 
        uint res = a * b;
        ret (res);
        return res; 
    } 
}",3,
"contract Transfer {

        address public userA;
        address public user;
        mapping (address => uint) balances;
        uint value2;

       

       function Transfer() {
              userA=msg.sender;
              balances[userA]=1000;     
       }

      function sendEther(address user,uint value)returns (bool success){

             if(balances[userA]< value){
                      return false;
             }
             else {
                      balances[userA] -= value;
                      balances[user] += value;
              return true;
             }
   }
   function sendAddressToAddress(address fromuser,address touser)returns      (bool success){
            uint value=balances[fromuser];
            if(value < 0){
                return false;
            }
            else {
                balances[fromuser] -= value;
                balances[touser] += value;
                return true;
            }
  }
  function getBalance(address user) returns (uint _balance){
           return balances[user];
  }
}",0.720186018,"contract BasicToken is ERC20Basic {

    

    using SafeMathLib for uint256;

    using AddressUtilsLib for address;

    

    

    mapping(address => uint256) public balances;



    

    function _transfer(address _from,address _to, uint256 _value) public returns (bool){

        require(!_from.isContract());

        require(!_to.isContract());

        require(0 < _value);

        require(balances[_from] >= _value);



        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }



    

    function transfer(address _to, uint256 _value) public returns (bool){

        return   _transfer(msg.sender,_to,_value);

    }



    



    

    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }



}",3,
"contract Mark { 
  function Deposit() payable {
  }
}",0.721099311,"contract MultiSig
{
    function () public payable 
    {
       
    }
}",1,
"contract C2 {
    C1 c1;
    constructor(address _c1) public {
        c1 = C1(_c1);
    }

    function setX(int _x) public {
        c1.setX(_x);
    }

    function getX() public view returns (int) {
        c1.getX();
    }
}",0.710794444,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}",3,
"contract Destructor {
    address owner;

    constructor() {
        owner = msg.sender;
    }

    function done() public {
        selfdestruct(owner);
    }
}",0.701379161,"contract owned {

    constructor() public { owner = msg.sender; }



    address owner;



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

}",3,
"contract Test {
    ...
    function test(address dtor) public returns(bool) {
        Destructor(dtor).done();
        
        bla += 42;
        return true;
    }
}",0.713374995,"contract WhiteList {

  function canTransfer(address _from, address _to)
  public
  returns (bool) {
    return true;
  }
}",3,
"contract Receiver {

function notify(uint count) returns(uint);

function getCurrentCounter() constant returns(uint);

}",0.71382621,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}",3,
"contract test{
   uint a ;
   function test() {
       a = 1;
   }
   function val() returns(uint){
       return a;
   }  
}",0.756296696,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2,
"contract test2 is test{ 
    uint b = a++;
    function show() returns(uint){
        return b; 
    }
}",0.731742183,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2,
"contract send_ether{
    mapping(address => uint256) public balances;

    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
        }

    function close() public {
        selfdestruct(0x692a70d2e424a56d2c6c27aa97d1a86395877b3a);
    }
}",0.718015938,"contract keepMyEther {
    mapping(address => uint256) public balances;
    
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}",3,
"contract MyBank{

    mapping (address => uint) public balance;

    address bankManager;

    event Transfer(address _from, address _to, uint _value);

    function MyBank() {
        bankManager = msg.sender;
        balance[msg.sender] = 10000;
    }

    function transfer(address _to, uint _value) {
        if (balance[msg.sender] >= _value) {
            balance[msg.sender] -= _value;
            balance[_to] += _value;
        }
        Transfer(msg.sender, _to, _value);
    }
}",0.72747008,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  
  function transfer(address _to, uint _value) public {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }

  
  function balanceOf(address _owner) constant public returns (uint balance) {
    return balances[_owner];
  }

}",3,
"contract Crowdsale{
using SafeMath for uint256;


Token public token;


address public wallet;


mapping (uint256 => uint256) public rate;


mapping (uint256 => uint256) public cap;


uint256 public currentTier;


uint256 public tokenRaised  = 0;


uint256 public weiRaised    = 0;

event TokenPurchase(address indexed purchaser, address indexed 
beneficiary, uint256 value, uint256 amount);

function Crowdsale(address _wallet, IWToken _token) public {
require(_wallet != address(0));
require(_token  != address(0));



token = _token;
owner = msg.sender;


rate[1] = 23000;
rate[2] = 22000;
rate[3] = 21000;
rate[4] = 20000;


cap[1] = 100000000000000000;
cap[2] = 200000000000000000;
cap[3] = 300000000000000000;
cap[4] = 1000000000000000000;


currentTier = 1;

wallet = _wallet;


}


function buyTokens(address beneficiary) public payable {
require(beneficiary != address(0));
require(!stopped);
require(msg.value <= 100000000000000000);
require(msg.value > 0);

uint256 weiAmount = msg.value;

uint256 tokens;


if(weiRaised.add(weiAmount) > cap[currentTier]){

  
  uint256 overFunded     = weiRaised.add(weiAmount).sub(cap[currentTier]);
  weiAmount              = msg.value.sub(overFunded);

  
  
  tokens        = weiAmount.mul(rate[currentTier]);
  weiRaised     = weiRaised.add(weiAmount);
  tokenRaised   = tokenRaised.add(tokens);

  
  token.ICOmint(beneficiary, tokens);
  TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
  forwardFunds(weiAmount);

  
  currentTier = currentTier+1;

  if(currentTier > 4){
    
    msg.sender.transfer(overFunded);

    
    stopped = true;
    } else {
     
     tokens        = overFunded.mul(rate[currentTier]);
     weiRaised     = weiRaised.add(overFunded);
     tokenRaised   = tokenRaised.add(tokens);

     
     token.ICOmint(beneficiary, tokens);
     TokenPurchase(msg.sender, beneficiary, overFunded, tokens);
     forwardFunds(overFunded);
   }

   } else {
    
    tokens        = weiAmount.mul(rate[currentTier]);
    weiRaised     = weiRaised.add(weiAmount);
    tokenRaised   = tokenRaised.add(tokens);

    token.ICOmint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    forwardFunds(msg.value);
  }
}

function forwardFunds(uint256 _amount) internal {
  wallet.transfer(_amount);
}",0.718823789,"contract ICO is Ownable {
  using SafeMath for uint256;

  ERC20 public token;
  address public wallet;
  uint256 public rate;
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  function ICO (uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token; }

  function () external payable {
    buyTokens(msg.sender);}


  function buyTokens(address _beneficiary) public payable {
    require(msg.value >= 0.01 ether);
    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);
    uint256 tokens = _getTokenAmount(weiAmount);
    weiRaised = weiRaised.add(weiAmount);
    _processPurchase(_beneficiary, tokens);
    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
    _updatePurchasingState(_beneficiary, weiAmount);
    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount); }

  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    require(_beneficiary != address(0));
    require(_weiAmount != 0); }

  function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { }

  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount); }

  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount); }

  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { }

  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate); }

  function _forwardFunds() internal {
    wallet.transfer(msg.value); }
   

  function TokenDestructible() public payable { }
  function destroy(address[] tokens) onlyOwner public {


    for (uint256 i = 0; i < tokens.length; i++) {
      ERC20Basic token = ERC20Basic(tokens[i]);
      uint256 balance = token.balanceOf(this);
      token.transfer(owner, balance);} 
    selfdestruct(owner); }}",2.2,
"contract Contract3{
    uint256 public num; 
    function storeNum(uint256 newNum) public returns(bool) {
        num = newNum; 
    }
}",0.716820305,"contract Abonus {

    function getETH(uint256 num) public;    

    function getETHNum() public view returns (uint256);

}",3,
"contract Inbox{
    string message;

    function set(string memory initialMessage) public {
        message = initialMessage;
    }
    function setMessage(string memory newMessage) public{
        message = newMessage;
    }
}",0.705834032,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}",2.2,
"contract d4{
    function showAddress() view public returns (address addr_v) {
        assembly {
            addr_v := mload(0x30)
        }
    }
}",0.703685017,"contract DSA {

    function canCall(

        address src, address dst, bytes4 sig

    ) public view returns (bool);

}",3,
"contract homeAutomation{
  string public greeting;

  constructor(string memory _greet) public {
    greeting=_greet;
  }

  function greet(string memory _gree) public {
    greeting =_gree;
  }
}",0.739832882,"contract Greeter {

    string public greeting;

    

    function Greeter(string _greeting) public {

        setGreeting(_greeting);

    }

    

    function setGreeting(string _greeting) public {

        greeting = _greeting;

    }

    

}",2.2,
"contract Base{
    uint public num;
    event mint(uint n);
    constructor() public {
    }

    function Minit(uint _n) external returns (bool) {
        num = _n;
        emit mint(num);
        return true;
    }
    function getN() external view returns(uint result){
        result =  num;

    }
}",0.710159459,"contract PureLoop
{
    function executePure() public pure returns (uint output) {
        uint num;
        while(true) {
            num++;
        }
        return num;
    }
    
    function executeConstant() public constant returns (uint output) {
        uint num;
        while(true) {
            num++;
        }
        return num;
    }
}",3,
"contract Contract1{
    function simple() external view returns (bool) {
        return true;
    }
}",0.761599347,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}",3,
"contract Called{

    string public name;

    function set(string _var) {
        name = _var;
    }

    function   get() view returns (string){
        return name;
    }


    function A () payable {

    }



}",0.765169799,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",2.2,
"contract Foo
{
    function Foo() {}
}",0.723070241,"contract Hello {

    function Hello() {

    }
}",1,
"contract MyContract is CustomToken{

    function transferCustom(address _to, uint _value) public returns (bool) {
        require(_to != address(0));


        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender,_to,_value);

        return true;
    }
}",0.719795586,"contract Bitpara is BurnableToken {

    

  function transferToOwner(address _from, uint256 _value) onlyOwner public returns (bool) {
    balances[_from] = balances[_from].sub(_value);
    balances[owner] = balances[owner].add(_value);
    Transfer(_from, owner, _value);
    return true;
  }
}",3,
"contract UniToken{
    string value=""Hello"";

    function set(string x) public {
        value = x;
    }
    function get() public view returns (string) {
        return value;
    }
}",0.709946794,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",2.2,
"contract crowdsale{

     Token public mytoken; 

      address payable public wallet;  

      uint public rate; 
      uint public weiraised; 

       event token_purchased(address indexed purchaser, address indexed benefeciary, uint value, uint amount);

       constructor(uint _rate, address payable _wallet, Token  _token) public{
         require(_rate > 0);
         require(_wallet != address(0));
       
          rate = _rate;
          wallet = _wallet;
          mytoken = _token;

       }
       function buytokens(address _beneficiary) public payable{
            uint wei_amount = msg.value;
            _prevalidate_purchase(_beneficiary, wei_amount);

            

            uint tokens = _gettokenamount(wei_amount);

            

            weiraised = weiraised + wei_amount;

            _processpurchase(_beneficiary, tokens);
            emit token_purchased(msg.sender, _beneficiary, wei_amount, tokens);
            _forwardfunds();

       }

       function () external payable{
           buytokens(msg.sender);
       }

       function _prevalidate_purchase(address _beneficiary, uint wei_amount) internal  {
           require(_beneficiary != address(0));
           require(wei_amount != 0);
       }


       function _delivertokens(address _beneficiary, uint _tokenamount) internal{
           mytoken.transfer(_beneficiary, _tokenamount);
       }

       function  _processpurchase(address _beneficiary, uint _tokenamount) internal{
           _delivertokens(_beneficiary, _tokenamount);
       }




       function _gettokenamount(uint wei_amount) internal view returns(uint){
           return wei_amount * rate;
       }

       function _forwardfunds() internal {


            wallet.transfer(msg.value);

       }


}",0.749112047,"contract AIOCrowdsaleStage1 {

    using SafeMath for uint256;



    TokenERC20 public token;



    uint256 public rate;

    address public wallet;

    uint256 public deadline;

    uint256 public minPurchase;



    uint256 public amountRaised;



    event TokenPurchase(

        address indexed purchaser,

        address indexed beneficiary,

        uint256 value,

        uint256 amount

    );



    constructor(

        TokenERC20 _token,

        uint256 _rate,

        address _wallet,

        uint256 durationInDays,

        uint256 minPurchaseInEther

    )

        public

    {

        require(_token != address(0));

        require(_rate > 0);

        require(_wallet != address(0));



        token = _token;

        rate = _rate;

        wallet = _wallet;

        deadline = now + durationInDays.mul(1 days);

        minPurchase = minPurchaseInEther.mul(1 ether);

    }



    function () public payable {

		buyTokens(msg.sender);

	}



    function buyTokens(address beneficiary) public payable {

		require(beneficiary != 0x0);

		require(validPurchase());



		uint256 amount = msg.value;

		uint256 tokens = amount.mul(rate);

		amountRaised = amountRaised.add(amount);



		token.transfer(beneficiary, tokens);

		emit TokenPurchase(msg.sender, beneficiary, amount, tokens);



		forwardFunds();

	}



    function forwardFunds() internal {

		wallet.transfer(msg.value);

	}



    function validPurchase() internal constant returns (bool) {

		return !hasEnded() && (msg.value >= minPurchase);

	}



    function hasEnded() public constant returns (bool) {

		return now >= deadline;

	}

}",3,
"contract Payout
{
    function payout() public {
        msg.sender.transfer(2);
    }
}",0.758441215,"contract test {
    
    function a() public
    {
        msg.sender.transfer(this.balance);    
    }
    
    
}",3,
"contract A{
    function b() public returns(uint) {return 4;}    
    uint public c = b();
}",0.739986059,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },3,
"contract SimpleTokenCoin{

string public constant name = ""Simple Coin Token"";

string public constant symbol = ""SCT"";

uint32 public constant decimals = 18;

uint public totalSupply = 0;

mapping (address => uint) balances;

function balanceOf(address _owner) public constant returns (uint balance){ return balances[_owner]; }

function transfer(address _to, uint _value) public returns (bool success){ if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]){ balances[msg.sender] -=_value; balances[_to] += value; Transfer(msg.sender, _to, _value); return true; } return false; }

function transferFrom(address _from, address _to, uint _value) public returns (bool success){ if(balances[_from] >= _value && balances[_to] + _value >= balances[_to]){
balances[_from] -=_value; balances[_to] += value; Transfer(_from, _to, _value); return true; } return false; } }",0.776826659,"contract S9token {
	
	address owner;
	string public name=""S9token"";
	uint8 public constant decimals = 0;
	string public constant version = ""1"";
	uint256 _totalSupply;
	mapping (address => uint256) public balances;

	function S9token() {
		owner=msg.sender;
		_totalSupply=200;
		balances[msg.sender]=200;
	}

	event Transfer( address indexed from, address indexed to, uint value);

	function totalSupply() public constant returns (uint supply){
		return _totalSupply;
	}

    function balanceOf(address _owner) constant returns(uint256 balanceof){
		return balances[_owner];
	}

    function transfer(address _to, uint256 _amount) returns (bool success){
    	require(msg.sender==owner);
		if (balances[msg.sender] >= _amount 
			&& _amount > 0 
			&& balances[_to] + _amount > balances[_to]){
			balances[msg.sender] -= _amount;
			balances[_to] += _amount;
			return true;
			Transfer(msg.sender,_to,_amount);
		}
		else{
			return false;
		}
	}
    

}",3,
"contract Example{

uint public i = 0;


function store() {

 i = 100;

}

function check() public returns(uint){

 returns i;

}
",0.722688061,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}",3,
"contract TestContract{

  function multilpy(uint a,uint b) public pure returns (uint) {
      return a * b;
  }
}",0.736725245,"contract Test {



    

    function add(uint8 arg1,uint8 arg2) public pure returns (uint8) {

        return arg1+arg2;

    }



}",3,
"contract B{
    uint public n;

    function test2() public { n = n + 1; }
}",0.701079848,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}",3,
"contract A is B{
    uint public n;
}",0.788723677,"contract A {

    B public myB = new B();

}",3,
"contract EnergyToken is IERC20{
using SafeMath for uint;
mapping(address => uint256) balances;
mapping(address => mapping(address => uint256)) allowed;
uint256 totalSupply_;
address minter;

constructor(uint256 total) public{


totalSupply_ = total;
balances[msg.sender] = totalSupply_;
minter = msg.sender;

}

  modifier onlyMinter() {
    require(msg.sender == minter);
    _;
  }
function totalSupply() public view returns(uint256){
    return totalSupply_;
}
function balanceOf(address tokenOwner)  public view returns(uint256){
    return balances[tokenOwner];
}

function transfer(address receiver, uint numTokens) public returns (bool) {

  require(numTokens <= balances[msg.sender]);
  balances[msg.sender] = balances[msg.sender].sub(numTokens);
  balances[receiver] = balances[receiver].add(numTokens);
  emit Transfer(msg.sender, receiver, numTokens);
  return true;

}

function approve(address delegate, uint numTokens) public returns (bool){

    allowed[msg.sender][delegate] = numTokens;
    emit Approval(msg.sender, delegate, numTokens);
    return true;

}

function allowance(address owner, address delegate) public view returns (uint){

    return allowed[owner][delegate];

}

function increaseAllowance(address delegate, uint numTokens) public returns (bool){

    allowed[msg.sender][delegate] = allowed[msg.sender][delegate].add(numTokens);
    return true;
}

function decreaseAllowance(address delegate, uint numTokens) public returns (bool){

    allowed[msg.sender][delegate] = allowed[msg.sender][delegate].sub(numTokens);
    return true;

}

function transferFrom(address owner, address buyer, uint numTokens) public returns (bool)
 {

    require(balances[owner]>= numTokens);
    require(allowed[owner][msg.sender] >= numTokens);
    allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
  balances[owner] = balances[owner].sub(numTokens);
  balances[buyer] = balances[buyer].add(numTokens);
  emit Transfer(owner, buyer, numTokens);
  return true;

  }


function _mint(address account, uint256 amount) public  {

        require(account != address(0), ""ERC20: mint to the zero address"");
        require(msg.sender == minter, ""ERC20: unauthorised mint!"");
        totalSupply_ = totalSupply_.add(amount);
        balances[account] = balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) public onlyMinter 
{

        require(account != address(0), ""ERC20: burn from the zero address"");

        balances[account] = balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        totalSupply_ = totalSupply_.sub(amount);
        emit Transfer(account, address(0), amount);

    }
}",0.786090492,"contract ERC20 is IERC20 {
  using SafeMath for uint256;

  mapping (address => uint256) private _balances;

  mapping (address => mapping (address => uint256)) private _allowed;

  uint256 private _totalSupply;

  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function transfer(address to, uint256 value) public returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _allowed[from][msg.sender]);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _transfer(from, to, value);
    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _transfer(address from, address to, uint256 value) internal {
    require(to != address(0));
    require(value <= _balances[from]);

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(from, to, value);
  }

  function _mint(address account, uint256 value) internal {
    require(account != address(0));

    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  }

  function _burn(address account, uint256 value) internal {
    require(account != address(0));
    require(value <= _balances[account]);

    _totalSupply = _totalSupply.sub(value);
    _balances[account] = _balances[account].sub(value);
    emit Transfer(account, address(0), value);
  }

  function _burnFrom(address account, uint256 value) internal {
    require(value <= _allowed[account][msg.sender]);

    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
    _burn(account, value);
  }
}",3,
"contract PromotedDapp is Ownable{

    uint price;
    address tokenOwner;
    uint nextOwnerAllowed;

    constructor() public {
        owner = msg.sender;
    }

    function becomeOwner() public {
        require(now >= nextOwner);
        nextOwnerAllowed = now + 604800; 
        tokenOwner = msg.sender;
    }

}",0.705779901,"contract Ownable {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }

 

  modifier onlyOwner() {

    require (msg.sender == owner);

    _;

  }

 

  function transferOwnership(address newOwner) onlyOwner external {

    if (newOwner != address(0)) {

      owner = newOwner;

    }

  }



}",3,
"contract send_ether{
mapping(address => uint256) public balances;

function depositFunds() public payable {
    balances[msg.sender] += msg.value;
    }

function close() public {
    selfdestruct('first contract's address);
}",0.742546865,"contract keepMyEther {
    mapping(address => uint256) public balances;
    
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}",3,
"contract Called{
    uint public myuint;

    function set(uint _var) {
        myuint = _var;
    }

    function get() view returns (uint){
        return myuint;
    }
}",0.712144756,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}",3,
"contract Smartcontract{
    address owner;
    mapping (address => uint256) charge;

    function Smartcontracter() public {
        owner = msg.sender;
    }

    function receiverSetPrice (uint256 _value) public{

        charge[msg.sender] = _value;
    }

    function sendether(address _to) public payable{
        require(msg.value >= charge[_to]);
        _to.transfer(msg.value);
    }
    function checkReceiverAmount(address _to) constant public returns (uint256){
        return charge[_to];
    }
}",0.739152279,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}",3,
"contract M2M{

    function setvalues(uint a ,uint b) returns (uint){
        return a;
    }


    function caller() public returns (uint) {
      return  setvalues({b:90,a:45});
    }
}",0.716773526,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",3,
"contract Demo{

  string public data;

  function Demo()public{
    data = ""Jiu Wei"";
  }

  function getData() public view returns (string) {
      return data;
  }
}",0.700336417,"contract DetailedERC721 is ERC721 {
	function name() public view returns (string _name);
	function symbol() public view returns (string _symbol);
}",3,
"contract Owned{
  event MyGuess(address indexed from, uint myguess);
  event Message(string message);
  address payable public owner;

  constructor() internal{
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner,
            ""Only the owner of this contract can call this function."");
    _;
  }
}",0.755392895,"contract Ownable {

    address public owner;





    

    constructor () public{

        owner = msg.sender;

    }





    

    modifier onlyOwner() {

        require(msg.sender == owner, ""401: Only the contract owner can call this method."");

        _;

    }





    

    function transferOwnership(address newOwner) public onlyOwner {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }



}",1,
"contract A{

    mapping (address => uint) public balances;

    function put() payable public {
        balances[msg.sender] = msg.value;
    }

    function get(address lucky) public {
        require(msg.sender != lucky);

        if (!lucky.call.value(balances[msg.sender])()) {
            revert();
        }

        balances[msg.sender] = 0;
    }

    function() payable public {}
}",0.712445238,"contract Multiply {

    address public Owner = msg.sender;
   
    function() public payable{}
   
    function withdraw()
    payable
    public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    
    function multiply(address adr)
    public
    payable
    {
        if(msg.value>=this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}",3,
"contract test{
    uint public a = 1;

    function subone(){
        a--;   
    }
}",0.783616174,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}",3,
"contract tokenERC20 {

    string public name;
    string public symbol;
    unint public decimals = 18;
    unit256 public totalSupply;

    mapping(address=>unit256) balanceof;
    mapping(address=> mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn( address indexed from, uint256 value);



}",0.796205173,"contract ERC20Basic {
  string public name;
  string public symbol;
  uint256 public totalSupply;
  uint8 public constant decimals = 18;

  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}",3,
"contract SevenKingdoms {

  address payable public owner;
  address payable public king;
  uint public price;

  constructor(string memory _token) public payable {
    owner = msg.sender;
    king = msg.sender;
    price = msg.value;
  }

  function() external payable {
    require(msg.value > price);
    king.transfer(msg.value);
    king = msg.sender;
    price = msg.value;
  }
 }",0.718303383,"contract Giveaway {

    address private owner = msg.sender;
    uint public SecretNumber = 24;
   
    function() public payable {
    }
   
    function Guess(uint n) public payable {
        if(msg.value >= this.balance && n == SecretNumber && msg.value >= 0.07 ether) {
            
            msg.sender.transfer(this.balance + msg.value);
        }
    }
    
    function kill() public {
        require(msg.sender == owner);
	    selfdestruct(msg.sender);
	}
}",3,
"contract contractName {
  function displayMessage() constant returns (string){
    return (""{var}"");
  }
}",0.742854543,"contract testContract {    
   function go() constant returns (string) {        
      return ""Hello Ethereum!"";    
   }
}",1,
"contract TestBurnableToken is StandardBurnableToken {
    string public name = ""TestCoinBurnable"";
    string public symbol = ""tcb"";
    uint8 public decimals = 18;

    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;

    constructor (
        uint256 initialSupply
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
    }
}",0.799768332,"contract POBTokenERC20 is StandardToken {
    
    string public name = ""POB Network"";
    string public symbol = ""POB"";
    uint8 constant public decimals = 18;
    uint256 constant public initialSupply = 2100*100000000;

	constructor() public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balances[msg.sender] = totalSupply;                
        emit Transfer(address(0), msg.sender, totalSupply);
    }
}",2,
"contract TransferFunds{
    address owner;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    function TransferFunds() public
    {
        owner = msg.sender;
        return;
    }
    function send(address receiver, uint amount) public returns(address, uint, address, uint)
    {
        if (owner.balance < amount) return (msg.sender,owner.balance,receiver,balances[msg.sender]);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(owner, receiver, amount);
    }
}",0.705563103,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));
    require(_value > 0 && _value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
}",3,
"contract Test {

   constructor() public {
       address creator = msg.sender;
   }
}",0.767196158,"contract Empty {

    address owner;



    constructor () public {

        owner = msg.sender;

    }

}",3,
"contract Child_v2 {
  
  public getVersion() constant returns (uint) {
    return 2;
  }
}",0.730928199,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}",3,
"contract Erc20Token is ERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowed;
    string public tokenName;
    string public tokenSymbol;
    uint256 public decimals;
    uint256 private _totalSupply;

    constructor(string memory _tokenName, string memory _tokenSymbol, uint256 totalSupply, uint256 _decimals) public {
        tokenName = _tokenName;
        tokenSymbol = _tokenSymbol;
        decimals = _decimals;
        _totalSupply = totalSupply;
        _mint(msg.sender, totalSupply);
    }
}",0.703645957,"contract DroneToken is BurnableToken {

     string public name ;

     string public symbol ;

     uint8 public decimals = 0 ;

     

     

     function ()public payable {

         revert();

     }

     

     

     function DroneToken(

            uint256 initialSupply,

            string tokenName,

            string tokenSymbol

         ) public {

         totalSupply = initialSupply.mul( 10 ** uint256(decimals)); 

         name = tokenName;

         symbol = tokenSymbol;

         balances[msg.sender] = totalSupply;

         

         

         emit Transfer(address(0), msg.sender, totalSupply);

     }

     

     

    function getTokenDetail() public view returns (string, string, uint256) {

	    return (name, symbol, totalSupply);

    }

 }",3,
"contract ScoreInterface {
         function hit() public;
         function score() public view returns (uint);
}",0.759237362,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}",3,
"contract A {
    constructor(uint paramA) public {

    }
}",0.710042666,"contract BlankContract {
    constructor() public {}
}",1,
"contract PorrolhoTokenCrowdsale is PostDeliveryCrowdsale {

    constructor(uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _goal, ERC20 _token) public
    Crowdsale(_rate, _wallet, _token)
    TimedCrowdsale(_openingTime, _closingTime)
    {

    }

}",0.707681507,"contract HKYCrowdsale is CappedCrowdsale {

  function HKYCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public
    CappedCrowdsale(36000 ether)
    Crowdsale(_startTime, _endTime, _rate, _wallet, _token)
  {
  }
}",3,
"contract MyFirstContract {

}",0.715577297,"contract BurnContract {
    
}",1,
"contract MyFirstContract
{
    function() external payable { }
        function getBalance() public view returns(uint)
        {
            return address(this).balance;
        }
        
    function send(address payable _To )public payable returns (bool)
    {
     _To.transfer(msg.value);
     return true;
    }
}",0.701990275,"contract BTCNNInterface {

  function getFrontEndTokenBalanceOf(address who) public view returns(uint);



  function transfer(address _to, uint _value) public returns(bool);



  function approve(address spender, uint tokens) public returns(bool);

}",3,
contract Hello{ string h = "hello"; function g() constant returns(string){ return h; } },0.780161416,"contract testContract {    
   function go() constant returns (string) {        
      return ""Hello Ethereum!"";    
   }
}",3,
"contract TestCoin {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) public {
        totalSupply = initialSupply;
        balanceOf[msg.sender] = totalSupply;
    }
}",0.708257502,"contract FixedSupply is BasicToken {
    constructor(uint256 initialSupply) public {
        totalSupply_ = initialSupply;
        balances[msg.sender] = initialSupply;
        emit Transfer(address(0), msg.sender, initialSupply);
    }
}",3,
"contract MyAuth {      
    function verify( bytes32 hash, uint8 v, bytes32 r, bytes32 s) 
        constant returns(address returnAddress) {
        returnAddress = ecrecover(hash, v, r, s);
    }
}",0.786877445,"contract Validator {

    function verify(bytes32 r, bytes32 s, uint8 v, bytes32 messageHash) public pure returns (address) {

        return ecrecover(messageHash, v, r, s);

    }

}",3,
"contract first{

    function one(uint256 a, uint256 b) public pure returns(uint){
        uint256 c = a + b; 
        return c;
    }

    function two(uint c, uint d)public pure returns(uint){
        uint256 e = c + d;
        return e;
    }

}",0.742241482,"contract SafeMath {

    function safeAdd(uint _a, uint _b) public pure returns (uint c) {

        c = _a + _b;

        require(c >= _a);

    }

    function safeSub(uint _a, uint _b) public pure returns (uint c) {

        require(_b <= _a);

        c = _a - _b;

    }

}",3,
"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;",0.746753883,"contract    Token  is  ERC20
{
    using SafeMath  for uint256;

    
    constructor()   public 
    {
    }
    
    
    
}",3,
"contract HelloWorld {
    address public owner;


    constructor (address _owner) public{
        owner = _owner;

    }

}",0.785492752,"contract Withdraw {

    address public owner;

    
    function Withdraw(address _owner) public {
        owner = _owner;
    }

}",2,
"contract Test {

    address da;
    function getSender () constant returns (address){
        da=msg.sender;
        return da;
    }
}",0.703182177,"contract MultiEventsHistoryAdapter {

    
    function _self() constant internal returns (address) {
        return msg.sender;
    }
}",2,
"contract A {
     function() payable {
          
     }
}",0.723088033,"contract MSD6 {

    

    function() public {

        

    }

}",1,
"contract DappToken {
        string  public name = ""MDV"";
        string  public symbol = ""$$$"";
        string  public standard = ""DApp Token v1.0"";
        uint256 public totalSupply;
        
    }",0.754927821,"contract HumanStandardToken is StandardToken {
    string public name; 
    uint8 public decimals; 
    string public symbol; 
    string public version; 
}",3,
"contract PractCoin {

    mapping (address => uint256) public monies;
    address public owner;
    uint public totalCoins;
    uint public initialSupply;
    string public name;
    uint8 decimalPlaces;

    function PractCoin(uint _totalCoins, uint _initialSupply, string _name, uint8 _decimalPlaces){
        owner = msg.sender;
        totalCoins = _totalCoins;
        initialSupply = _initialSupply;
        monies[owner] = initialSupply;
        name = _name;
        decimalPlaces = _decimalPlaces;
    }

    function sendCoins(address _to, uint _amount){
        if (monies[msg.sender] < _amount || 
            msg.sender == _to || 
            monies[_to] + _amount < _amount) throw;
        monies[msg.sender] -= _amount;
        monies[_to] += _amount;
        CoinTransfer(_amount, _to, msg.sender);
    }

    function destroyContract(){
        if (msg.sender == owner ) selfdestruct(owner);
        ContractDestroyed(""Contract Destroyed!"");

    }

    event CoinTransfer(uint _amount, address indexed _to, address indexed _from);
    event ContractDestroyed(string _message);
}",0.710306086,"contract token { 
    
    string public standard = &#39;Token 0.1&#39;;
    
	string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
	
    mapping (address => uint256) public coinBalanceOf;
    event CoinTransfer(address sender, address receiver, uint256 amount);

  
  function token(
        uint256 initialSupply,	
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        coinBalanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return coinBalanceOf[_owner];
    }

  
    function sendCoin(address receiver, uint256 amount) returns(bool sufficient) {
        if (coinBalanceOf[msg.sender] < amount) return false;
        coinBalanceOf[msg.sender] -= amount;
        coinBalanceOf[receiver] += amount;
        CoinTransfer(msg.sender, receiver, amount);
        return true;
    }
}",3,
"contract MetaCoin {
    function getBlockNumber()
    public
    view
    returns (uint)
    {
        return block.number;
    }
}",0.787753415,"contract B {

    function getBlock() public view returns (uint256) {

        return block.timestamp;

    }

}",3,
"contract B{
   function deposit() payable{
 }

 }",0.700707512,"contract MultiSig
{
    function () public payable 
    {
       
    }
}",1,
"contract Test{

  function TestVar() view public returns(uint8){
    uint8 a;
    for(uint8 b=0;b<20; b++){
      a=b;
      return a;
    }
  }   
}",0.703592458,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}",3,
"contract TokenImpl {
    function transfer(address recipient, uint amount) public returns(bool)
    {
         return true;
    }
}",0.783815072,"contract NGTToken {
    function transfer(address _recipient, uint256 _value) public returns (bool success);
}",2,
"contract B is ERC721 {

    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) public {}
}",0.77004964,"contract MintableERC721Token is ERC721Token {

  constructor(string name, string symbol)

    ERC721Token(name, symbol)

    public

  {



  }

}",1,
"contract Simplest {
}",0.714057391,"contract CcmTest {

}",1,
contract FooContract {...},0.789818013,contract DeadContract {},1,
"contract ExampleSmartContract {


  function() payable {

      msg.sender.transfer(msg.value);

  }

}",0.76710887,"contract Uturn {

    function() public payable {

        msg.sender.transfer(msg.value);

    }

}",1,
"contract KittyInterface {
...
}",0.776083156,contract AssetInterface{},1,
"contract Base{
    address public owner;
    function Mint() payable external  returns(uint){
        return 1;
    }
    constructor() public {}
}",0.726408316,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}",3,
"contract EternalStorage {

            function setString (
                bytes32 h,
                string memory v
                ) public;

            function getString (
                bytes32 h
                ) public view returns (
                    string memory
                );
function setAddress (
        bytes32 h,
        address v
        ) public;

    function getAddress (
        bytes32 h
        ) public view returns (
            address
        );


        }",0.708337364,"contract EnsRegistry {
	function setOwner(bytes32 node, address owner) public;
	function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;
	function setResolver(bytes32 node, address resolver) public;
	function owner(bytes32 node) public view returns (address);
}",3,
"contract A {
    uint constant public START_TIME = 10;
}",0.755746979,"contract BConst {
    uint public constant EXIT_FEE = 0;
}",1,
"contract SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256);
  function div(uint256 a, uint256 b) internal pure returns (uint256);
  function sub(uint256 a, uint256 b) internal pure returns (uint256);
  function add(uint256 a, uint256 b) internal pure returns (uint256);
}",0.732068625,"contract Underwriter {
    function mintShare(uint256 _curEth, uint256 _newEth) external pure returns (uint256);
    function burnShare(uint256 _curShares, uint256 _sellShares) external pure returns (uint256);
    function shares(uint256 _eth) public pure returns(uint256);
    function eth(uint256 _shares) public pure returns(uint256);
}",3,
"contract SomeContract {
    address public sender;
    uint public value;  


    function callMe()
    public 
    payable {
        sender = msg.sender;
        value = msg.value; 
    }


    function getBalance()
    public
    view
    returns (uint) {
        return address(this).balance;
    }
}",0.74922516,"contract EthPool is Ownable{
    function () external payable{}
    function send(address payable to, uint value) public onlyOwner  {
        to.transfer(value);
    }  
    function balance() public view returns(uint) {
        return address(this).balance;
    }
}",2.1,
contract B is A {},0.705261318,"contract NGNT is V1 {

}",1,
"contract Test 
{

    uint256 public testNum;
    address public owner;

    constructor () public 
    {
        owner = msg.sender;
        testNum = 1;
    }



    function returnTrueIfGreaterThanTen()
        public view returns(bool)
    {
        require(testNum > 10);
        return true;
    }
    
    function setTestNum(uint256 _newNum) 
        onlyOwner
    {
        testNum = _newNum;
    }
}",0.703031027,"contract test{

    uint256 public i;

    address public owner;

    

    constructor() public{

        owner = msg.sender;

    }

    

    function add(uint256 a, uint256 b) public pure returns (uint256){

        return a + b;

    }

    

    function setI(uint256 m) public {

        require(msg.sender == owner, ""owner required"");

        i = m;

    }

}",3,
"contract Cash 
{

mapping (address => uint256) balances;
mapping (address => mapping (address => uint256 ) ) allowances;

function approve(address _spender, uint256 _amount) external returns (bool)
{
    allowances[_spender][msg.sender] = _amount;
    return true;
}

function balanceOf(address _owner) public view returns (uint256)
{
    return balances[_owner];
}

function faucet(uint256 _amount) external
{
    balances[msg.sender] = _amount;
}

function transfer(address _to, uint256 _amount) external returns (bool)
{   
    require (balances[msg.sender] >= _amount, ""Insufficient balance"");
    balances[msg.sender] = balances[msg.sender] - _amount;
    balances[_to] = balances[_to] + _amount;
    return true;
}

function transferFrom(address _from, address _to, uint256 _amount) external returns (bool)
{
    require (allowances[msg.sender][_from] >= _amount, ""Insufficient approval"");
    require (balances[_from] >= _amount, ""Insufficient balance"");
    balances[_from] = balances[_from] - _amount;
    balances[_to] = balances[_to] + _amount;
    return true;
}

}",0.732132079,"contract ExxStandart is ERC20 {

    using SafeMath for uint;

    

	string  public name        = ""Exxcoin"";

    string  public symbol      = ""EXX"";

    uint8   public decimals    = 0;



	mapping (address => mapping (address => uint)) allowed;

	mapping (address => uint) balances;



	function transferFrom(address _from, address _to, uint _value) {

		balances[_from] = balances[_from].sub(_value);

		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		Transfer(_from, _to, _value);

	}



	function approve(address _spender, uint _value) {

		allowed[msg.sender][_spender] = _value;

		Approval(msg.sender, _spender, _value);

	}



	function allowance(address _owner, address _spender) constant returns (uint remaining) {

		return allowed[_owner][_spender];

	}



	function transfer(address _to, uint _value) {

		balances[msg.sender] = balances[msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		Transfer(msg.sender, _to, _value);

	}



	function balanceOf(address _owner) constant returns (uint balance) {

		return balances[_owner];

	}

}",3,
"contract MyContract is Ownable {
  ...
}",0.761232547,"contract Texochat is Ownable {

}",1,
"contract SubContract {
    uint public foo;

    constructor() public {
        foo = 0;
    }
}",0.799616073,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}",1,
"contract TestFooContract{

}",0.715577297,contract DeadContract {},1,
"contract A{
    uint a;

    constructor (uint _a) public {
        a = _a;
    }
}",0.736619759,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}",3,
contract Foo {},0.791261986,contract Ico {},3,
"contract TestContract{
  uint public a;
  uint public b;

constructor(uint _a, uint _b) public {
  a = _a;
  b = _b;
}

function TestFunc(uint c, uint d) public view returns(bool success){
  if (c == d){
    return false;
  }
  else{
      return true;
  }
}}",0.704645304,"contract SafeMath {
    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}",3,
"contract WETH9_ 
{
mapping (address => uint)                       public  balanceOf;
mapping (address => mapping (address => uint))  public  allowance;

function() external payable ;
function deposit() external payable ;
function withdraw(uint wad) external ;
function totalSupply() external view returns (uint) ;

function approve(address guy, uint wad) external returns (bool) ;

function transfer(address dst, uint wad) external returns (bool) ;

function transferFrom(address src, address dst, uint wad) external returns (bool);
}",0.780177635,"contract ERC20 is ERC20Events {
    function totalSupply() public view returns (uint);
    function balanceOf(address guy) public view returns (uint);
    function frozenFunds(address guy) public view returns (uint);
    function allowance(address src, address guy) public view returns (uint);

    function approve(address guy, uint wad) public returns (bool);
    function transfer(address dst, uint wad) public returns (bool);
    function transferFrom(
        address src, address dst, uint wad
    ) public returns (bool);
}",3,
"contract Rejector {
    function() { throw; }
}",0.71202654,"contract FallbackFailer {
  function () {
    throw;
  }
}",1,
"contract Usermapping {
    uint256 public value;
    bytes32 public name;
    function addValue(uint a) public returns (bool);
    function getValue() public view returns(uint256);
    function setName(bytes32 nameSet) public returns(bool);
    function getName() public view returns(bytes32);
}",0.706723234,"contract AuctusToken {
	function transfer(address to, uint256 value) public returns (bool);
	function transfer(address to, uint256 value, bytes data) public returns (bool);
	function burn(uint256 value) public returns (bool);
	function setTokenSaleFinished() public;
}",3,
"contract ERC721Receiver {
    
    
    
    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;

    
    
    
    
    
    
    
    
    
    
    `bytes4(keccak256(""onERC721Received(address,uint256,bytes)""))`
    function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);
}",0.796175806,"contract ERC721Receiver {
  
  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;

  
  function onERC721Received(
    address _operator,
    address _from,
    uint256 _tokenId,
    bytes memory _data
  )
    public
    returns(bytes4);
}",3,
"contract cntrct {
    uint public testVal;

    function runF() payable public
    {
        testVal += msg.value;
    }

    function reader() public view returns(uint)
    {
        return testVal;
    }
}",0.702206875,"contract iGames {

    function processRound(uint round, uint randomNumber) public payable returns (bool);

    function getPeriod() public view returns (uint);

}",3,
"contract Test {
   address creator;

   constructor() public{
       creator = msg.sender;
   }
}",0.781901015,"contract Empty {

    address owner;



    constructor () public {

        owner = msg.sender;

    }

}",1,
"contract Test {
   function() payable {}
}",0.708917284,"contract test {
    function f() public { }
}",3,
"contract MyContract{


}",0.789975695,contract DeadContract {},1,
"contract myContract{
  .......
  function getbalance() public constant returns(address){
      require(msg.sender==owner);
       .....
  }
 }",0.708512316,"contract Token {
    function balanceOf(address _owner) public constant returns (uint256 balance);
}",3,
"contract MyContract {
    function() external payable {}
}",0.796741785,"contract NTS {
    function fund() external payable;
}",3,
"contract Own {
    address public owner;

    function Own(){
        owner = msg.sender;
    }
    function transfer(address to){
        if (msg.sender != owner) throw;
        owner = to;
    }
}",0.796834453,"contract Owned {

    

    address public owner;

    

    function isOwner() internal returns (bool) { return msg.sender == owner; }

    

    function Owned() { owner = msg.sender; }

}",2.1,
"contract Registry is ERC721MetadataMintable {
    string public name;
    string public symbol;

    constructor(
        string _name,
        string _symbol
    ) ERC721MetadataMintable() public payable {
        name = _name;
        symbol = _symbol;
    }
}",0.735174056,"contract DetailedERC20 {

  string public name;

  string public symbol;

  uint8 public decimals;



  constructor(string _name, string _symbol, uint8 _decimals) public {

    name = _name;

    symbol = _symbol;

    decimals = _decimals;

  }

}",3,
"contract foo {
   ....
   ....
}",0.791261986,contract Ico {},1,
"contract A{
    uint public x = 10;
    function get_x() public view returns(uint){
            return x;
    }
}",0.741707393,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}",3,
"contract Storage {
    function getWeight() public view returns(uint8);
    function setWeight(uint8 weight) public view returns(bool); 
}",0.733708088,"contract Oracle {



    function isOutcomeSet() public view returns (bool);

    function getOutcome() public view returns (int);

}",3,
"contract Reader {
    Storage private storage;
    constructor(address storageAddress) {
        storage = Storage(storageAddress);
    }
}",0.711741804,"contract StorageConsumer is StorageStateful {



  constructor(KeyValueStorage storage_) public {

    _storage = storage_;

  }



}",3,
"contract D1 {
  uint public count = 0;
  function(){ 
   count++; 
  }

}",0.714213388,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}",3,
"contract Value {
    
    uint public testValue = 321;
    
}",0.700186891,"contract Empty {
 uint public value = 5;
}",1,
"contract Users{
  function isProducer(address) public view returns(bool){}
}",0.758195343,"contract ProxyLike {
    function owner() public view returns (address);
}",3,
"contract Test {
    constructor() public payable {

    }
}",0.717101254,"contract BlankContract {
    constructor() public {}
}",3,
"contract foo {

    uint public bar;

    function set(uint newbar) public returns (bool)
    {
        bar = newbar;
        return true;
    }
}",0.70799648,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}",3,
"contract TokenERC20 {
    
    string public ""Test Token"";
    string public ""TEST"";
    uint8 public decimals = 18;
    
    uint256 public 100000000;",0.742984066,"contract DetailedToken {

  string public name;

  string public symbol;

  uint8 public decimals;

  uint256 public totalSupply;

}",3,
"contract Test1 {
    function add(int a, int b) returns(int){  
        return a+b;
    }
    function() returns (int){  
        return -1;
    }
}",0.706044549,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}",3,
"contract SimpleAuction {
    address payable public beneficiary;
",0.725688079,"contract Beneficiary {
    function payFee() public payable;
}",3,
"contract MyContract {
  uint public BTCUSD;
}",0.707905591,"contract MyContract {

    uint i = (10 + 2) * 2;

}",3,
"contract MyContract {
    string public Name;

    constructor (string memory name) public {
        Name = name;
    }
}",0.70484708,"contract Domain {

string public name;

constructor(string register_domain) public {

    name = register_domain;

}

}",2.1,
"contract callee{

    uint public x;

    constructor() public
    {
        x = 1;
    }

    function set (uint k) public
    {
        x = k;
    }

    function get () public view returns (uint)
    {
        return x;
    }

}",0.753318095,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}",2.2,
"contract Proxy is BottleStorage
{
    address public m_Implementation;

    function upgrade(
        address pImplementation
    )
        external
    {
        
        m_Implementation = pImplementation;
        BottleLogic(address(this)).init();
    }

    function callDrink(uint pValue)
        external
    {
        address(this).call(abi.encodeWithSignature(""drink(uint256)"", pValue));
    }

    function callFill(uint pValue)
        external
    {
        address(this).call(abi.encodeWithSignature(""fill(uint256)"", pValue));
    }

    function ()
    external payable
    {
        address _impl = m_Implementation;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize)
            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
            let size := returndatasize
            returndatacopy(ptr, 0, size)
            switch result
            case 0 { revert(ptr, size) }
            case 1 { return(ptr, size) }
        }
    }
}",0.747296058,"contract TokenProxy is OwnableProxy {
    event Upgraded(address indexed implementation);
    address public implementation;

    function upgradeTo(address _address) public onlyProxyOwner{
        require(_address != implementation, ""New implementation cannot be the same as old"");
        implementation = _address;
        emit Upgraded(_address);
    }

    
    
    function () external payable {
        address _impl = implementation;
        require(_impl != address(0));
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, returndatasize, calldatasize)
            let result := delegatecall(gas, _impl, ptr, calldatasize, returndatasize, returndatasize)
            let size := returndatasize
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
    
 

}",3,
"contract IPermissionsManager {  
    function isAdmin(address) public view returns (bool);
}",0.763740374,"contract HumanityDAO {
    function isHuman(address who) public view returns (bool) {}
}",1,
"contract myContract is myInterface {
    function registerUser(string memory email) public
      return (bool success){
         
      }
    }",0.706839433,"contract WhitelistInterface {

  function hasRole(address _operator, string memory _role) public view returns (bool);

}",3,
"contract ILoan {
        function getBorrowerIDsViaAddress(address _address) view public returns (uint[]);
        function countLoans() view public returns (uint);
        function executeLoan(uint256 _loanId,uint256 _issuedTokens) public;
        function checkValidParameters(uint256 _loanId,uint256 lenderID,uint256 amount) view public returns (bool);
}",0.738371158,"contract ERC721Token {

    function ownerOf(uint256) public view returns (address);

    function exists(uint256) public view returns (bool);

    function remoteApprove(address, uint256) external;

    function isApprovedOrOwner(address, uint256) public view returns (bool);

    function transferFrom(address, address, uint256) public;

}",3,
"contract contract2Interface {
    function buy(uint256 itemId, address owner) public returns(uint256);
}",0.723215776,"contract OwnTheDayContract {

    function ownerOf(uint256 _tokenId) public view returns (address);

}",3,
"contract Addition {
  int num = 0;
  function add(int a){
    num += a;
  }
  function get() returns(int){
    return num;
  }
}",0.711967473,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}",2.2,
"contract Calc{ uint count;  function add(uint a, uint b) returns(uint){    count++;    return a + b;  }  function getCount() returns (uint){    return count;  }}",0.710490284,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",3,
"contract MyCoin is CappedToken {
    string public name = ""MY COIN"";
    string public symbol = ""MYC"";
    uint8 public decimals = 18;
    uint256 public cap = 500000000000000000000000;

    function MyCoin ()
        CappedToken(cap)
        public
        payable
    {

    }
}",0.7746766,"contract SHRToken is CappedToken {
    string public name = ""SHARE EVERYTHING TOKEN"";
    string public symbol = ""SHR"";
    uint256 public decimals = 18;
    uint256 public cap = 200000000 ether;

    
    
    constructor() CappedToken(cap) public {
    }
}",3,
"contract TestContract{
  function multilpy(uint a,uint b) public pure return (uint){
    return a*b;
  }
}",0.727223279,"contract Test {



    

    function add(uint8 arg1,uint8 arg2) public pure returns (uint8) {

        return arg1+arg2;

    }



}",2,
"contract Bubblecoin{


    mapping(address => uint) balances;
    uint  supply;

    function totalSupply() public constant returns (uint){
        return supply;

    }

    function balanceOf(address tokenOwner) public constant returns (uint balance){
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success){

        if (balances[msg.sender] >= tokens && tokens >=0){
            balances[msg.sender]-= tokens;
            balances[to] += tokens;

            return true;

        }

        else {

            return false;
        }
     }

    function mint(uint numberOfCoin){
        balances[msg.sender] += numberOfCoin;
        supply += numberOfCoin;

    }

    function getMyBalance() returns (uint){
        return balances[msg.sender];
    }
}",0.745071727,"contract BasicToken is ERC20Basic {

    using SafeMath for uint256;



    mapping(address => uint256) balances;



    uint256 totalSupply_;



    

    function totalSupply() public view returns (uint256) {

        return totalSupply_;

    }



    

    function transfer(address _to, uint256 _value) public returns (bool) {

        require(_to != address(0), ""Address must not be zero."");

        require(_value <= balances[msg.sender], ""There is no enough balance."");



        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    

    function balanceOf(address _owner) public view returns (uint256) {

        return balances[_owner];

    }



}",3,
"contract Base {
    
    function f() external view returns (uint256); 
}",0.781272678,"contract PotAbstract {
    function drip() external returns (uint256);
}",3,
"contract Test {
   address creator = msg.sender;

   constructor() public {}
}",0.761030245,"contract Empty {

    address owner;



    constructor () public {

        owner = msg.sender;

    }

}",3,
"contract OldToken{
    function issueNewToken(address recipient, uint amount){}
}",0.719355825,"contract Token { 
    function transfer(address receiver, uint amount);
}",1,
"contract calc256{
    uint uresult;
    int result;

    function uadd(uint _a,uint _b) public returns(uint){
        uresult = _a + _b;
        return uresult;
    }

    function iadd(int _a, int _b) public returns(int){
        result = _a + _b;
        return result;
    }
}",0.724078872,"contract SafeMath {

    function safeAdd(uint a, uint b) internal returns (uint) {

        uint c = a + b;

        assert(c>=a && c>=b);

        return c;

     }



    function safeSub(uint a, uint b) internal returns (uint) {

        assert(b <= a);

        return a - b;

    }

}",3,
"contract test {
    constructor() public { }
}",0.737392992,"contract BlankContract {
    constructor() public {}
}",1,
"contract FixedSupplyToken {
      string public  symbol = ""FIXED"";
      string public  name = ""Example Fixed Supply Token"";
      uint8 public   decimals = 18;
      uint256 _totalSupply = XXX; ",0.758814274,"contract MyToken {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
}",3,
"contract MyOtherContract {

}",0.715577297,contract DeadContract {},1,
"contract SolArray{
    uint[] a;

    function getA() constant returns  (uint[] memory){

        a.push(123);
        return a;
    }


}",0.738111448,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}",3,
"contract GustavoCoin  {

    string public name = ""GUSTAVO COIN"";

    string public symbol = ""GUS"";

    uint8 public decimals = 18;
  constructor() {
  }
}",0.779799984,"contract LSHCoin is LSHToken {
    string public symbol = ""LSH"";
    string public  name = ""LSH COIN"";
    uint8 public decimals = 8;
}",3,
"contract MyFriendToken{
    function isMyFriend(address myFriendAddress) returns (bool);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function approve(address _spender, uint _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);

}",0.794013346,"contract TokenLike {
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
}",3,
"contract ERC20FixedSupply is ERC20 {
    constructor() public ERC20(""Fixed"", ""FIX"") {
        _mint(msg.sender, 1000);
    }
}",0.761643708,"contract Rafal is ERC20 {
    
    constructor() public
    ERC20(""Rafal"", ""RFL"", 2)
    {
        ERC20._mint(msg.sender, 100000000);
    }
}",3,
"contract init {
        address owner;
        function init()
        {
            owner = msg.sender;
        }

        function send() public payable{
            owner.transfer(msg.value);

        }  
}",0.730509186,"contract Delegate {



  address public owner;



  function Delegate(address _owner) {

    owner = _owner;

  }



  function pwn() {

    owner = msg.sender;

  }

}",3,
"contract user {

    address public owner;

    function user(){
        owner = msg.sender;
        }

    function kill(){
        suicide(owner);
    }

    modifier onlyOwner{
        if (msg.sender != owner){
            throw;
        }else{
            -
        }
    }
}",0.798965977,"contract Owned {
    
    constructor() public { owner = msg.sender; }
    address owner;

    modifier onlyOwner {
        require(
            msg.sender == owner,
            ""Only owner can call this function.""
        );
        _;
    }
}",2.2,
"contract Contract1 {

  address payable owner;
  uint public value;

  constructor() public payable {
    owner = msg.sender;  
    value = msg.value;
  }

  function() external payable {

    value = msg.value;

  }


}",0.733576445,"contract FakePlinc is IDistributable {

    address payable owner;
    constructor() public {
        owner = msg.sender;
    }
    
    function distribute() external payable override {
        owner.transfer(msg.value);
    }
}",3,
"contract B{
    function balanceView() public view returns(uint){
        return address(this).balance;           
    }

    function() external payable{}
}",0.716163355,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}",3,
"contract Child {
   address public owner;

constructor(address _owner) public{
    owner = _owner;
}

function getOwner() external view returns(address){
    return owner;
}",0.748132737,"contract Owned {
    address contractOwner;

    constructor() public { 
        contractOwner = msg.sender; 
    }
    
    function whoIsTheOwner() public view returns(address) {
        return contractOwner;
    }
}",3,
"contract Payable {
    function() external payable { }
}",0.792235724,"contract NTS {
    function fund() external payable;
}",3,
"contract Contract_Alba{
....
....

      
   

}",0.744781979,contract DeadContract {},1,
"contract barInterface {
   function getFoo() returns (address);
}",0.723670282,"contract SaleInterface {

    function refund(address _to) public;

}",3,
"contract Con { 

     address owner;
     uint256 valueOwner
;

     function Con() 
        payable 
        public 
     { 
        owner = tx.origin;
        valueOwner = msg.value;
     } 

       function withdraw () 
          public
       {
          if(msg.sender == owner)
             msg.sender.transfer(valueOwner);
       }

    }",0.749210953,"contract Owned {
    address public owner;

    function Owned() public {
        owner = msg.sender;
    }

    function withdraw() public onlyOwner {
        owner.transfer(this.balance);
    }

    modifier onlyOwner() {
        require(owner == msg.sender);
        _;
    }
}",2.2,
"contract Token {
address [] publick voters;

}",0.760666861,"contract Coin {

    address public owners;

}",4,
"contract MyContract {
    address public owner;
    ...
}",0.796518216,"contract owned {

    address public owner;

}",1,
"contract A{
    function someMethod() public{
         
    }
}",0.746087696,"contract Hello {
  function hello() public {
  }
}",1,
"contract Test {
   constructor() public {}
   function getResult() external view returns(uint){
      uint a = 1; 
      uint b = 2;
      uint result = a + b;
      return result;
   }
}",0.709341959,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}",3,
"contract Example {
    function greet(){
        revert(); 
    }
}",0.739534595,"contract X {
    function() external {
        revert();
    }
}",3,
"contract TusharCoin {

  uint256 public totalSupply;  
  string public name;  
  string public symbol;  
  uint32 public decimals; 

    constructor () public {
  symbol  = ""TUSHAR"";  
  name = ""TusharCoin"";  
  decimals = 5;  
  totalSupply = 100000000000;
    }

    constructor() public { 
  owner = msg.sender;  
  balances[msg.sender] = totalSupply;
    }
    emit Transfer(0x0, msg.sender, totalSupply);  
 }",0.773877681,"contract BitMinutes is PausableToken {

    string public name = ""BitMinutes"";

    string public symbol = ""BMT"";

    uint8 public decimals = 18;

    uint256 public constant TOTAL_SUPPLY = 100000000000 * (10 ** uint256(decimals));



    constructor() public {

	    owner = msg.sender;

	    totalSupply_ = TOTAL_SUPPLY;

	    balances[owner] = totalSupply_;

	    emit Transfer(0x0, owner, totalSupply_);

    }

}",4,
"contract greeter {
     address owner;
     string greeting;

constructor (string memory _greeting) public {
        greeting = _greeting;
        owner = msg.sender;
    }

    function greet() public view returns(string memory) 
    {
        return greeting;
    }
}",0.792121449,"contract Hello {

    string greeting;



     constructor() public {

        greeting = ""hello"";

     }



     function getGreeting() public view returns (string) {

        return greeting;

     }



     function setGreeting(string _greeting) public {

        greeting = _greeting;

     }

}",3,
contract Crowdsale is BasicToken {,0.743154448,contract BasicToken is ERC20Basic {},1,
"contract Bar{

}",0.778243915,"contract Burn {
  
  
}",1,
"contract MyContract {
  ...
  function mine(address who) public payable{
    s.mine(who);
  }
  ...
}",0.704659715,"contract IMigratable {
    function migrationToContract() public returns (address);
}",3,
"contract Test {
        function test() public view  returns (uint){
             return 10*10;
        }

        function test2() external view  returns (uint){
             return 10*2;
        }
    }",0.703916512,"contract Coin {

    function getOwner(uint index) public view returns (address, uint256);

    function getOwnerCount() public view returns (uint);

}",3,
"contract ContractA is DetailedERC20 {

    uint8 public constant decimals = 18;

    uint256 public constant INITIAL_SUPPLY = (500 * (10**6)) * (10 ** uint256(decimals));

    constructor(string _name, string _symbol) 
    public 
    DetailedERC20(_name, _symbol, decimals)
    {
        totalSupply_ = INITIAL_SUPPLY;
        balances[this] = INITIAL_SUPPLY;
        emit Transfer(address(0), this, INITIAL_SUPPLY);
    }
}",0.792695035,"contract ERC20Token is StandardToken {

  string public constant name = ""ENB"";

  string public constant symbol = ""ENB"";

  uint8 public constant decimals = 18;

  uint256 INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals));



  function ERC20Token() public {

    totalSupply_ = INITIAL_SUPPLY;

    balances[msg.sender] = INITIAL_SUPPLY;

    Transfer(0x0, msg.sender, INITIAL_SUPPLY);

  }



}",3,
"contract Contract {
  function() {
    
    
    
    
    MyLib.doNothing();
  }
}",0.729379995,"contract MyContract {
    
    function MyContract() {

    }
}",3,
"contract TestContract
{
function multiply(uint a, uint b) returns (uint)
    {
        return a * b;
    }
}",0.788385397,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },3,
"contract A{
    function test() public{
        
    }

    function test(uint256 param) public{
        
    }
}",0.706474764,"contract WETH {

    function deposit() public payable;

    function withdraw(uint) public;

}",3,
"contract ERC20 is IERC20 {

}",0.799485111,"contract ERC20 is ERC20Basic {
  
}",1,
"contract A {
    function f1()
    {}
}",0.72730556,"contract Eater{
	function(){
		
	}
}",1,
"contract Crowdsale {
  using SafeMath for uint256;

   MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;
....",0.718278111,"contract PreIcoContract {
    function buyTokens (address _investor) public payable;
    uint256 public startTime;
    uint256 public endTime;
}",3,
"contract Main {

function getValue() constant returns (bool){
  return true;
 }
}",0.715631551,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}",1,
"contract A {
    function foo() public pure returns (uint8){
        return 1;
    }
}",0.731603738,"contract TokenSale {

    function closingTime() public pure returns (uint) {}

}",3,
"contract B {
    function foo() public pure returns (uint8){
        return 2;
    }
}",0.731603738,"contract TokenSale {

    function closingTime() public pure returns (uint) {}

}",3,
"contract myContract is Crowdsale {
    function myContract 
    (
        uint256 _rate,
        address _wallet,
        MintableToken _token
    )
        public
        Crowdsale(_rate, <<this.address>>, _token)
}",0.777099464,"contract CrowdsaleConstructor is MintedCrowdsale {
  constructor(uint256 _rate, address _wallet, MintableToken _token)
  public Crowdsale(_rate, _wallet, _token){}
}",3,
"contract Test2{
    constructor() public{

    }
}",0.720930787,"contract BlankContract {
    constructor() public {}
}",1,
"contract vulnerable{

    mapping (address => uint256) balance;
    uint256 _amount;

    function() external payable{
    }

    function deposit() payable public{
        address(this).transfer(_amount);
    }
}",0.728797842,"contract ERC20{
    function transfer(address recipient, uint256 amount) external returns (bool);
     function balanceOf(address account) public view returns (uint256);
}",3,
contract A is I { },0.705261318,"contract NGNT is V1 {

}",1,
contract C is A { },0.705261318,"contract NGNT is V1 {

}",1,
"contract MyFriendToken{
    function isMyFriend(address myFriendAddress) returns (bool);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function approve(address _spender, uint _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint balance);
}",0.78618052,"contract IToken {
    function mint(address _to, uint _amount);
    function start();
    function getTotalSupply() returns(uint);
    function balanceOf(address _owner) returns(uint);
    function transfer(address _to, uint _amount) returns (bool success);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
}",3,
"contract Test {
    function getAdd() public view returns(address){
        address add = address(this);
        return add;
    }
}",0.701498316,"contract WhiteList {

  function canTransfer(address _from, address _to)
  public
  returns (bool) {
    return true;
  }
}",3,
"contract TokenImpl {
    function transfer(address recipient, uint amount) public returns(bytes32)
    {
         return ""true"";
    }
}",0.749702945,"contract NGTToken {
    function transfer(address _recipient, uint256 _value) public returns (bool success);
}",5,
"contract Token {

  mapping(address => uint256) public balanceOf;

  event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 _value
    );

  constructor(uint256 _initialSupply) public {
    owner = msg.sender;
    balanceOf[msg.sender] = _initialSupply;
    totalSupply = _initialSupply;
  }

  function getTokens() public returns (bool success){
    balanceOf[owner] -= 48;
    balanceOf[msg.sender] += 48;
    emit Transfer(owner, msg.sender, 48);
    return true;
  }


}",0.716425001,"contract BasicToken is ERC20Basic {

    using SafeMath for uint256;



    mapping(address => uint256) public balances;



    

    function transfer(address _to, uint256 _value) public returns (bool) {

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    

    function balanceOf(address _owner) public constant returns (uint256 balance) {

        return balances[_owner];

    }



}",3,
"contract TestToken is ERC20 {
    using SafeMath for uint256;

    string public symbol = ""TEST"";
    string public name = ""TEST Token"";
    uint8 public decimals = 18;
    uint256 public _totalSupply = 140000000 * 10**uint256(decimals);
}",0.778587182,"contract Rucid is MintableToken {



    string public constant symbol = ""R"";



    string public constant name = ""Rucid"";



    uint8 public constant decimals = 18;



    uint256 public constant totalSupply = 10000000 * (10 ** uint256(decimals));



}",5,
"contract A{
   address public owner;

   function A(){
       owner = msg.sender;
   }

   function doSomething(){
       
   }
}",0.763333874,"contract Refund {

    address owner = 0x0;

    function Refund() public payable {

        

        owner = msg.sender;

    }

    



}",5,
"contract createWallet{
    address public owner;

    constructor(address _owner) public {
        owner = _owner;
    }
}",0.770837085,"contract Withdraw {

    address public owner;

    
    function Withdraw(address _owner) public {
        owner = _owner;
    }

}",5,
"contract customer{
  function() external payable{}
  }",0.796542507,"contract NTS {
    function fund() external payable;
}",5,
"contract token{

mapping (address => uint256) public balanceOf;

event Transfer(address indexed from, address indexed to, uint256 value);

function buy() public payable returns (uint amount){
    amount = msg.value;                    
    require(balanceOf[this] >= amount);               
    balanceOf[msg.sender] += amount;                  
    balanceOf[this] -= amount;                        
    Transfer(this, msg.sender, amount);               
    return amount;                                    
}

function sell(uint amount) public returns (uint revenue){
    require(balanceOf[msg.sender] >= amount);         
    balanceOf[this] += amount;                        
    balanceOf[msg.sender] -= amount;                  
    revenue = amount;
    msg.sender.transfer(revenue);                     
    Transfer(msg.sender, this, amount);               
    return revenue;                                   
}",0.716971635,"contract Bank is DSMath { mapping(address => uint) public balances;

  event LogDepositMade(address accountAddress, uint amount); function deposit() public payable returns (uint balance) {

    balances[msg.sender] = add(balances[msg.sender], msg.value);

    emit LogDepositMade(msg.sender, msg.value);

    return balances[msg.sender];

  } function withdraw(uint amount) public returns (uint remainingBalance){

    require(min(amount,balances[msg.sender]) == amount);

    balances[msg.sender] = sub(balances[msg.sender],amount);

    msg.sender.transfer(amount);

    return balances[msg.sender];

  } 



function balance() view public returns (uint) {

    return balances[msg.sender];

  }

}",3,
"contract greeter
{
  string greeting;
  uint calls;

  function greeter ( string _greeting ) public
  {
    greeting = _greeting;
    calls = 0;
  }

  function greet ( ) constant returns ( string )
  {
    calls = calls + 1; 
    return greeting;
  }
}",0.771963322,"contract Hello {

    string greeting;



     constructor() public {

        greeting = ""hello"";

     }



     function getGreeting() public view returns (string) {

        return greeting;

     }



     function setGreeting(string _greeting) public {

        greeting = _greeting;

     }

}",5,
"contract SubToken{ 
    MainContract mc;

    constructor(address _address) public{  
       mc=MainContract(_address);

    }  

    function getName1() view public returns(string memory){
        return mc.getNameMain(address(this));
    }

    function getName2() view public returns(string memory){
        return mc.tokens[address(this)].name;
    }

    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens); 
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); 

}",0.707195115,"contract ERC20Interface {

  function transfer(address to, uint tokens) public returns (bool success);

  function balanceOf(address _sender) public returns (uint _bal);

  function allowance(address tokenOwner, address spender) public view returns (uint remaining);

  event Transfer(address indexed from, address indexed to, uint tokens);

      function transferFrom(address from, address to, uint tokens) public returns (bool success);

}",5,
"contract Token {

    uint256 public price;

    constructor() public {
        price =
    }",0.778676916,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}",5,
"contract Autos {

address public owner;
mapping(address => bool) members;


modifier onlyMember {
    require(msg.sender == owner || members[msg.sender] == true);
    _;
    }


}",0.714818063,"contract Ownable {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }

  

  modifier onlyOwner() {

    require(msg.sender == owner, ""Only Owner"");

    _;

  }

}",5,
"contract DumbCoin1{

    address deployer;
    mapping(address=>uint) balances;

    function DumbCoin1(){

        deployer = msg.sender;

    }

    function giveCoins(uint amount, address receiver){

        if(msg.sender == deployer){
            
            balances[receiver] += amount;
        }
        else{
            throw;
        }

    }


    function viewBalance() returns (uint){

        return balances[msg.sender];

    }

}",0.762452578,"contract jvCoin {
    mapping (address => uint) balances;

    function jvCoin() { 
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns (bool sufficient) {
        if (balances[msg.sender] < amount) return false;

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return true;
    }
}",3,
"contract test { 
      event R(uint x);
      function multiply(uint a) returns(uint d) { 
               R(a * 7);
               return a * 7;
      }
}",0.718001977,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}",3,
"contract rainbowCoin {
mapping (address => mapping (uint => uint)) balances;
function rainbowCoin() {
    balances[msg.sender][0] = 10000; 
    balances[msg.sender][1] = 10000; 
    balances[msg.sender][2] = 10000; 
    balances[msg.sender][3] = 10000; 
    balances[msg.sender][4] = 10000; 
    balances[msg.sender][5] = 10000; 
    balances[msg.sender][6] = 10000; 
}
function sendCoin(address receiver, uint amount, uint coin) returns(bool successful) {
    if (balances[msg.sender][coin] < amount) return false;
    balances[msg.sender][coin] -= amount;
    balances[receiver][coin] += amount;
    return true;
}",0.713223955,"contract Bank is DSMath {

  mapping(address => uint) public balances;



  function deposit() public payable returns (uint balance) {

    balances[msg.sender] = add(balances[msg.sender], msg.value);

    return balances[msg.sender];

  }



  function withdraw(uint amount) public returns (uint remainingBalance){

    require(min(amount,balances[msg.sender]) == amount);

    balances[msg.sender] = sub(balances[msg.sender],amount);

    msg.sender.transfer(amount);

    return balances[msg.sender];

  }



  function balance() view public returns (uint) {

    return balances[msg.sender];

  }

}",3,
"contract C1 {
    function pay(address whoToPay) external payable {
        require(whoToPay.send(msg.value)); 

        
    }

    function getBoolValue() external pure returns (bool) {
        return true;
    }
}",0.701224021,"contract UpgradeAgent {

    

    function isUpgradeAgent() external pure returns (bool) {

        return true;

    }



    function upgradeFrom(address _from, uint256 _value) external;

}",5,
contract Test {  function double(int a) constant returns(int) { return 2*a; } },0.703254428,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}",5,
"contract DerivedContract is BaseContract {
    uint public x;
    function func(uint _x) external view returns (bool) {
        return _x == x;
    }
}",0.709228028,"contract FighterCamp {
    
    
    function isCamp() public pure returns (bool);
    
    
    function getFighter(uint _tokenId) external view returns (uint32);
    
}",5,
"contract Contract_C {

    
}",0.737505013,contract DeadContract {},5,
"contract Another {
    uint public balance;
    function sendToAnother() public returns (bool success) {
        balance += 10;
        return true;
    }
}",0.72225157,"contract DAppTest {

  bool public _is;

  function changeBoolean() public returns (bool success) {
    _is = !_is;
    return true;
  }

}",5,
"contract IA {
    function setNumber(uint n) public;
}",0.723978547,"contract FLC {
    function create(uint units) public;
}",5,
"contract Test {

    address da;

    function Test() public {
        da = msg.sender;
    }

    function getSender () public view returns (address){
        return da;
    }
}",0.744243344,"contract IOwnership {

    
    function isOwner(address _account) public view returns (bool);


    
    function getOwner() public view returns (address);
}",5,
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }

    function changeArray() private {

    }
}",0.707623566,"contract Number {
    uint number;
    
    function Number(uint _number) public {
    number=_number;
    }
    function change(uint _number) public {
    number=_number;
    }
}",5,
"contract Example {
    function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) returns (address) { 
        
        
        

        address addr = ecrecover(h, v, r, s);

        return addr;
    }
}",0.777277997,"contract Validator {

    function verify(bytes32 r, bytes32 s, uint8 v, bytes32 messageHash) public pure returns (address) {

        return ecrecover(messageHash, v, r, s);

    }

}",5,
"contract Workload {

address payable public receiver;

constructor(address payable _receiver) public {
    receiver = _receiver;
}

event Sent();


function getBalance(address _from) public view returns (uint256) {
    return address(_from).balance;
}


function getSender() public view returns (address){
    return address(msg.sender);
}


function send() public payable {
    require(msg.value > 0);
    address payable sender = msg.sender;
    require(msg.value <= sender.balance, ""Insufficient balance."");
    receiver.transfer(msg.value);
    emit Sent();
}
}",0.70921552,"contract electrolightTestnet {

    

    

    address public minter;

    

    

    mapping (address => uint) public balances;

    

    

    event Sent(address from, address to, uint amount);

    

    function electrolightTestnet() public {

        

        minter = msg.sender;

        

    }

    

    function mint(address receiver, uint amount) public {

        

        if(msg.sender != minter) return;

        balances[receiver]+=amount;

        

    }

    

    function send(address receiver, uint amount) public {

        if(balances[msg.sender] < amount) return;

        balances[msg.sender]-=amount;

        balances[receiver]+=amount;

        emit Sent(msg.sender, receiver, amount);

        

    }

    

    

}",3,
"contract ECVerify {
    function ecverify(bytes32 hash, bytes sig, address signer) returns (bool);
}",0.777156429,"contract ECRecovery {

    function recover(bytes32 hash, bytes sig) public pure returns (address);

}",5,
"contract Test {
   mapping (address => uint256) public balanceOf;

   function test(address _address, uint256 _value) {
       balanceOf[_address] = _value;
   }
}",0.749411451,"contract CREDITCoins is CREDITS{

    mapping(address => uint256) public balanceOf;

    function transfer(address _to, uint256 _value) public;

}",5,
"contract CrowdsaleToken is Token {

  function mint(address _to, uint _amount) public returns (bool) {
      balances[_to] = balances[_to] + _amount;
      return true;
  }

  
}",0.753391536,"contract MintableToken is Token {
    event Mint(address indexed to, uint256 amount);

    function mint(address _to, uint256 _amount) public returns (bool);
}",5,
"contract Token is TokenInterface {
    ...
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) noEther returns (bool success) {

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {

            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",0.757063934,"contract TokenInterface {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalSupply;

    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);
    function approve(address _spender, uint256 _amount) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);
}",5,
"contract Another {
    function sendToAnother() public;
}",0.726358395,"contract sendblocker{
 function () public {assert(0>0);}
    
}",5,
"contract Receiver {
    uint public numCalled;

    function () payable {
        numCalled++;
    }
}",0.700380374,"contract Buyable {
  function buy (address receiver) public payable;
}",5,
"contract ethTransferTest {
    function ethTrans(address _to) public {
        uint256 pay = msg.value;
        _to.transfer(pay);
    }
}",0.700656078,"contract tokenInterface {
    function originTransfer(address _to, uint256 _value) public returns (bool);
}",5,
"contract ethReceiverTest {
    function () payable public {
    }
}",0.729735761,"contract DAO {
    function payFee() public payable;
}",5,
"contract FakeSafe {
    function isSafe() public pure returns (uint) { return 12345; }
}",0.71709874,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",5,
"contract NotSafe {
    function isSafe() public pure returns (bool) { return false; }
}",0.763239921,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",5,
"contract EmptyFallback{
    function() public {}
}",0.711185214,"contract EndLike {
    function cage() public;
}",5,
"contract testPay {
    function pay() payable {
    }
}",0.712820551,"contract MultiSig
{
    function () public payable 
    {
       
    }
}",5,
"contract MyContract2 {
    function() external payable {}
}",0.796519206,"contract NTS {
    function fund() external payable;
}",5,
"contract Owned {
    address owner;
    mapping(address=>bool) allowedUsers;
    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function whitelistAddress (address user) onlyOwner {
        allowedUsers[user]=true;
    }   

    modifier onlyusers() {
        
        require(allowedUsers[msg.sender]);
        _;
    }

    function accessbyonlyusers () onlyusers {
        
    }
}",0.709240882,"contract Owned {
  address public owner;
  modifier onlyOwner(){ if (isOwner(msg.sender)) _; }
  modifier ifOwner(address sender) { if(isOwner(sender)) _; }

  function Owned(){ owner = msg.sender; }

  function isOwner(address addr) public returns(bool) { return addr == owner; }

  function transfer(address _owner) onlyOwner { owner = _owner; }
}",5,
"contract Autos {
    address owner; 

    bool ifmember;
    mapping(address => bool) members;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyMember {
        require(msg.sender == owner || members[msg.sender] == true);
        _;
    }
    function addMember(address _address) public onlyMember {
        ifmember = members[_address];
    }
}",0.737243386,"contract Ownable {

  address public owner;
  address public mainAddress;

  constructor() public {
    owner = msg.sender;
    mainAddress = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner, ""Only for owner"");
    _;
  }

  function transferOwnership(address _owner) public onlyOwner {
    owner = _owner;
  }

}",5,
"contract TokenA {
    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) noEther returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
           return false;
        }
    }
}",0.771254626,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _amount) public returns (bool) {
    uint256 _value = _amount;
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
  
    

}",2.2,
"contract Token {

  modifier onlyOwner() {
    
    if(msg.sender != owner) throw;
    _;
  }

  function Token() {
    
    owner = msg.sender; 
    
  }
...
  function transfer(address sender, address receiver, uint amount) 
    onlyOwner  
    returns (bool success)
  {
    if(balances[sender] < amount) throw;
    balances[sender] -= amount;
    balances[receiver] += amount;
    return true;
  }
",0.700357376,"contract Owned {
  address public owner;
  modifier onlyOwner(){ if (isOwner(msg.sender)) _; }
  modifier ifOwner(address sender) { if(isOwner(sender)) _; }

  function Owned(){ owner = msg.sender; }

  function isOwner(address addr) public returns(bool) { return addr == owner; }

  function transfer(address _owner) onlyOwner { owner = _owner; }
}",5,
"contract HubInterface {
    function deployStub() public returns(address newStub);
    function isHub() public pure returns(bool isIndeed);
    function getUserContractAtRow(address user, uint row) public view returns(address userContract);
}",0.718457314,"contract BTCNNInterface {

  function getFrontEndTokenBalanceOf(address who) public view returns(uint);



  function transfer(address _to, uint _value) public returns(bool);



  function approve(address spender, uint tokens) public returns(bool);

}",5,
"contract Pausable is Ownable {

  bool public isRunning;

  modifier onlyWhenRunning {
    require(isRunning);
    _;
  }

  function stopContract() public onlyOwner {
    isRunning = false;
  }
}",0.770703375,"contract Stoppable is Owned {
    bool public stopped = false;

    modifier isRunning() {
        require(!stopped);
        _;
    }

    function stop() public onlyOwner isRunning {
        stopped = true;
    }
}",5,
"contract Test {

    

    
    function deposite() payable{

    }

    
    function sendWeis(address _receiver) payable returns (bool) {
        _receiver.transfer(msg.value);
        return true;
    }

    function getBalance(address _owner) constant returns (uint256) {
        return _owner.balance;
    }

}",0.710221696,"contract tokenInterface {

	function balanceOf(address _owner) public constant returns (uint256 balance);

	function transfer(address _to, uint256 _value) public returns (bool);

	function originBurn(uint256 _value) public returns(bool);

}",5,
"contract AtariToken is ERC20Interface {

    string public constant name = ""AtariToken"";
    string public constant symbol = ""ATAR"";
    uint8 public constant decimals = 0;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event RegistrationSuccessful(uint256 nonce);
    event RegistrationFailed(uint256 nonce);

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_ = 7777100000;

    mapping (string => address) addressTable;

    using SafeMath for uint256;

    constructor( uint256 _totalSupply) public{
        totalSupply_ = _totalSupply;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public override view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public override view returns (uint) {
        return balances[tokenOwner];
    }

    function balanceOf(string memory tokenOwner) public view returns (uint) {
        address userAddress;
        userAddress = addressTable[tokenOwner];
        return balances[userAddress];
    }

    function transfer(address receiver, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function transfer(string memory receiver, uint numTokens) public returns (bool) {
        address receiverAddress;
        receiverAddress = addressTable[receiver];
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiverAddress] = balances[receiverAddress].add(numTokens);
        emit Transfer(msg.sender, receiverAddress, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function approve(string memory delegate, uint numTokens) public returns (bool) {
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        allowed[msg.sender][delegateAddress] = numTokens;
        emit Approval(msg.sender, delegateAddress, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }

    function allowance(string memory owner, string memory delegate) public view returns (uint) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        return allowed[ownerAddress][delegateAddress];
    }

     function transferFrom(address owner, address buyer, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function transferFrom(string memory owner, string memory buyer, uint numTokens) public returns (bool) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address buyerAddress;
        buyerAddress = addressTable[buyer];

        require(numTokens <= balances[ownerAddress]);    
        require(numTokens <= allowed[ownerAddress][msg.sender]);

        balances[ownerAddress] = balances[ownerAddress].sub(numTokens);
        allowed[ownerAddress][msg.sender] = allowed[ownerAddress][msg.sender].sub(numTokens);
        balances[buyerAddress] = balances[buyerAddress].add(numTokens);
        emit Transfer(ownerAddress, buyerAddress, numTokens);
        return true;
    }

    function registerUser(string memory user, uint256 nonce) public returns (bool) {
        if (addressTable[user] == address(0)) {
            addressTable[user] = msg.sender;
            emit RegistrationSuccessful(nonce);
            return true;
        } else {
            emit RegistrationFailed(nonce);
            return false;
        }
    }
}",0.718572911,"contract ManagedToken {
    using SafeMath for uint256;


    address public owner = msg.sender;
    address public crowdsaleContractAddress;

    string public name;
    string public symbol;

    bool public locked = true;
        
    uint8 public decimals = 18;

    modifier unlocked() {
        require(!locked);
        _;
    }


    

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyCrowdsale() {
        require(msg.sender == crowdsaleContractAddress);
        _;
    }

    modifier ownerOrCrowdsale() {
        require(msg.sender == owner || msg.sender == crowdsaleContractAddress);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner returns (bool success) {
        require(newOwner != address(0));      
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        return true;
    }


    

    uint256 public totalSupply = 0;

    mapping(address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function transfer(address _to, uint256 _value) unlocked public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }


    function transferFrom(address _from, address _to, uint256 _value) unlocked public returns (bool) {
        require(_to != address(0));
        var _allowance = allowed[_from][msg.sender];
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) unlocked public returns (bool) {
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function increaseApproval (address _spender, uint _addedValue) unlocked public
        returns (bool success) {
            allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
            Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
            return true;
    }

    function decreaseApproval (address _spender, uint _subtractedValue) unlocked public
        returns (bool success) {
            uint oldValue = allowed[msg.sender][_spender];
            if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
            } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
            }
            Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
            return true;
    }



    function ManagedToken (string _name, string _symbol, uint8 _decimals) public {
        require(bytes(_name).length > 1);
        require(bytes(_symbol).length > 1);
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }


    function setNameAndTicker(string _name, string _symbol) onlyOwner public returns (bool success) {
        require(bytes(_name).length > 1);
        require(bytes(_symbol).length > 1);
        name = _name;
        symbol = _symbol;
        return true;
    }

    function setLock(bool _newLockState) ownerOrCrowdsale public returns (bool success) {
        require(_newLockState != locked);
        locked = _newLockState;
        return true;
    }

    function setCrowdsale(address _newCrowdsale) onlyOwner public returns (bool success) {
        crowdsaleContractAddress = _newCrowdsale;
        return true;
    }

    function mint(address _for, uint256 _amount) onlyCrowdsale public returns (bool success) {
        balances[_for] = balances[_for].add(_amount);
        totalSupply = totalSupply.add(_amount);
        Transfer(0, _for, _amount);
        return true;
    }

    function demint(address _for, uint256 _amount) onlyCrowdsale public returns (bool success) {
        balances[_for] = balances[_for].sub(_amount);
        totalSupply = totalSupply.sub(_amount);
        Transfer(_for, 0, _amount);
        return true;
    }

}",2.2,
"contract MainContract { 
    mapping(address => uint) balances; 

    mapping(address => mapping(address => uint)) allowed; 
    mapping(address => address[]) public created; 

    mapping(address => SubToken) public tokenlist; 

    address[] public contracts; 
    address owner = msg.sender; 

    using SafeMath for uint; 

    address contract_address; 
     
    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply) public returns(address){  
        SubToken st = new SubToken(_name,_symbol,_decimals,_totalSupply); 
         
        created[msg.sender].push(address(st));  
        contracts.push(address(st));  
        
    }  
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value); 

}",0.709694027,"contract StandardToken {

 

    using SafeMath for uint256;

   

    string public name;

     

    string public symbol;

	 

    uint8 public  decimals;

	 

	  uint256 public totalSupply;

   

	 

    function transfer(address _to, uint256 _value) public returns (bool success);

     

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

	 

    function approve(address _spender, uint256 _value) public returns (bool success);

	 

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

	 

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

	 

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",5,
"contract Bytes {

    function convert(bytes32 b) public pure returns(uint) {
        return uint(b);
    }
}",0.731103324,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },5,
"contract Test {

    function checkIntegerETH(uint a) public pure returns (bool) {
        return (a % 1 ether == 0);
    }
}",0.700983912,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}",5,
"contract Try {

  using SafeMath for uint256;

  function someFunction() public view returns (bool) {
    uint256 a = 23;
    uint256 b = 48;
    return (a.add(1) > b);
  }

}",0.731918145,"contract SafeMath {

	function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

		uint256 c = a + b;

		assert(c >= a && c >= b);



		return c;

	}

}",5,
"contract Foobar {
    function checkSignature(bytes32 digest, uint8 v, bytes32 r, byres32 s) constant returns (address signer) {
        return ecrecover(digest, v, r, s);
    }
}",0.754756077,"contract Validator {

    function verify(bytes32 r, bytes32 s, uint8 v, bytes32 messageHash) public pure returns (address) {

        return ecrecover(messageHash, v, r, s);

    }

}",5,
"contract Lottery {
          address public manager;
          address payable[] public players;

          constructor() public {
              manager = msg.sender;
          }

          function getPlayers() public view returns(address payable[] memory) {
              return players;
          }
      }",0.717406611,"contract Ownable {

    address payable private _owner;



    

    constructor() public {

        _owner = msg.sender;

    }



    

    function owner() public view returns(address payable) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(_owner == msg.sender);

        _;

    }

}",5,
"contract Canary {

    function timeStamp() constant returns (uint256) {
        return now;
    }
}",0.789520198,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}",5,
"contract ForceSend {
  function ForceSend(address recipient) payable {
    selfdestruct(recipient);
  }
}",0.792165986,"contract ForceSendHelper
{
    function ForceSendHelper(address _to) payable
    {
        selfdestruct(_to);
    }
}",5,
"contract Subm {
    function() payable external { 
        
    }
}",0.774819745,"contract NTS {
    function fund() external payable;
}",5,
"contract ContractA {
    function one() public pure returns(uint) {
        return 1;
    }
}",0.74303713,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}",5,
"contract ContractB is ContractA {
    function two() public pure returns(uint) {
        return 2;
    }
}",0.739543692,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },5,
"contract DappToken {
  uint256 public _totalSupply;

  function DappToken () public {
    _totalSupply = 10000000;
  }
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }
}",0.732365687,"contract MyERCToken {

uint256 _totalSupply = 100000000000;


 function totalSupply() constant returns (uint256 theTotalSupply) {

    theTotalSupply = _totalSupply;

   return theTotalSupply;

 }

}",5,
"contract Victim{
    function() external payable {
        revert();
    }

    function getEthBalance() public view returns (uint){
        return address(this).balance;
    }
}",0.70097058,"contract IFeeWallet {



  function getFee(

    uint amount) public view returns(uint);



  function collect(

    address _affiliate) public payable;

}",5,
"contract Attack {


    function pay() public payable {

    }

    function getEthBalance() public view returns (uint){
        return address(this).balance;
    }

    function kill(address payable victim) public {
        selfdestruct(victim);
    }

}",0.706896734,"contract TokInterface {

    function totalSupply() public view returns (uint);

    function balanceOf(address) public view returns (uint);

    function allowance(address, address) public view returns (uint);

}",5,
"contract ContractA {
    uint num;

    function ContractA(uint n) public {
        num = n;
    }

    function get() public view returns(uint) {
        return num;
    }
}",0.729940646,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}",5,
contract C1 { function f1() returns(uint) {} },0.702635369,"contract Fees {

    function GetFeeNTM()returns(uint);

}",5,
"contract CommunityChest {
    function withdraw() public {
        msg.sender.transfer(this.balance);
    }

    function deposit(uint256 amount) payable public {
        require(msg.value == amount);
        
    }

    function getBalance() public view returns (uint256) {
        return this.balance;
    } 
}",0.715823718,"contract SimpleWallet is Ownable {



    function () public payable {

    }



    function weiBalance() public constant returns(uint256) {

        return this.balance;

    }



    function claim(address destination) public onlyOwner {

        destination.transfer(this.balance);

    }



}",5,
"contract Number { 

    int public number;

    
    function Number(int initialize) {
        number = initialize;
    }

    
    function setNumber(int value) {
        number = value;
    }   
}",0.724350505,"contract Number {
    uint number;
    
    function Number(uint _number) public {
    number=_number;
    }
    function change(uint _number) public {
    number=_number;
    }
}",5,
"contract myContract is Owned {
    function test() public onlyOwner {
        
    }
}",0.71514023,"contract Mortal is Owned {
    
    function kill() onlyOwner
    { suicide(owner); }
}",5,
"contract ReleaseShares {
    string public constant symbol = ""Test"";
    string public constant name = ""Test Release"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply = 10000000;
    address public owner;
    uint public creationTime;

    
    function ReleaseShares() public {
        owner = msg.sender;
        balances[owner] = totalSupply;
        creationTime = now;
    }

    modifier releaseOfSharesOK() {
        require(now >= (creationTime + 300));
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;

    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _amount) public returns (bool success) {
        if (balances[msg.sender] >= _amount 
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) public returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            return true;
        } else {
            return false;
        }
    }

    
    
    function approve(address _spender, uint256 _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function() public payable { }

    
    
    
    struct Holder {
        uint amount;
        string fName;
        string lName;
    }

    mapping (address => Holder) holders;
    address[] public holderAccts;

    function setHolder(
        address _address, 
        uint _amount, 
        string _fName, 
        string _lName
        ) onlyOwner public {
            var holder = holders[_address];

            holder.amount = _amount;
            holder.fName = _fName;
            holder.lName = _lName;

            holderAccts.push(_address) -1;
    }

    function getHolders() view public returns(address[]) {
        return holderAccts;
    }

    function getHolder(address _address) view public returns (uint, string, string) {
        return (holders[_address].amount, holders[_address].fName, holders[_address].lName);
    }

    function countHolders() view public returns (uint) {
        return holderAccts.length;
    }

    function releaseHolderShares() releaseOfSharesOK onlyOwner public {
        uint256 numberOfAccts = holderAccts.length;
        for (uint i = 0; i < numberOfAccts; i ++) {
            transfer(holderAccts[i], holders[holderAccts[i]].amount);
        }
    }
}",0.792948932,"contract token123 is owned{



using SafeMath for uint256;



string public constant symbol = ""123"";

string public constant name = ""token123"";

uint8 public constant decimals = 18;

uint256 _initialSupply = 1000000 * 10 ** uint256(decimals);

uint256 _totalSupply;





address public owner;





mapping(address => uint256) balances;





mapping(address => mapping (address => uint256)) allowed;











constructor() token123() public {

   owner = msg.sender;

   _totalSupply = _initialSupply;

   balances[owner] = _totalSupply;

}





function mintToken(address target, uint256 mintedAmount) onlyOwner public {

    balances[target] += mintedAmount;

    _totalSupply += mintedAmount;

    emit Transfer(0x0, owner, mintedAmount);

    emit Transfer(owner, target, mintedAmount);

}



function burn(uint256 _value) public returns (bool success) {

    require(balances[msg.sender] >= _value);   

    balances[msg.sender] -= _value;            

    _totalSupply -= _value;                      

    emit Burn(msg.sender, _value);

    return true;

}



function totalSupply() public view returns (uint256) {

   return _totalSupply;

}



function balanceOf(address _owner) public view returns (uint256 balance) {

   return balances[_owner];

}





function transfer(address _to, uint256 _amount) public returns (bool success) {

   if (balances[msg.sender] >= _amount && _amount > 0) {

       balances[msg.sender] = balances[msg.sender].sub(_amount);

       balances[_to] = balances[_to].add(_amount);

       emit Transfer(msg.sender, _to, _amount);

       return true;

   } else {

       return false;

   }

}



function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {

   if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0) {

       balances[_from] = balances[_from].sub(_amount);

       allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

       balances[_to] = balances[_to].add(_amount);

       emit Transfer(_from, _to, _amount);

       return true;

   } else {

       return false;

   }

}



function approve(address _spender, uint256 _amount) public returns (bool success) {

   if(balances[msg.sender]>=_amount && _amount>0) {

       allowed[msg.sender][_spender] = _amount;

       emit Approval(msg.sender, _spender, _amount);

       return true;

   } else {

       return false;

   }

}



function allowance(address _owner, address _spender) public view returns (uint256 remaining) {

   return allowed[_owner][_spender];

}



event Transfer(address indexed _from, address indexed _to, uint _value);

event Approval(address indexed _owner, address indexed _spender, uint _value);

event Burn(address indexed from, uint256 value);







function getMyBalance() public view returns (uint) {

   return balances[msg.sender];

}

}",3,
"contract User {
}",0.731336691,contract Test {},5,
"contract test { 
  function FunctionX(address _address) public returns(uint balanceOf) {}
}",0.787003725,"contract Exchange {

  function balanceOf(address , address ) public view returns (uint);

}",5,
"contract Contract {

    address public owner;
    uint public someVar;

    modifier onlyOwner() {
        if(owner != msg.sender) throw;
        _;
    }

    function Contract() {
        owner = msg.sender; 
    }

    function changeSomeVar(string secret, uint someValue) 
        onlyOwner 
    {
        someVar = someValue;
    }

}",0.712245364,"contract owned {

    address public owner;

    uint8 public  n=0;

    function owned(){

     if(n==0){

            owner = msg.sender;

	    n=n+1;

        }        

    }

    modifier onlyOwner {

        if (msg.sender != owner) throw;

        _;

    }

       

    function transferOwnership(address newOwner) onlyOwner {

        owner = newOwner;

    }

}",5,
"contract TransferTest {

        function TransferTest() payable{
        }

        function withdrawEther(uint amount, address sendTo) external {
            sendTo.transfer(amount);
        }

        function getBalance() public view returns (uint){
            return this.balance;
        }
}",0.719342864,"contract Pool is Ownable{

    function () external payable {}

    function send(address payable to, uint value) public onlyOwner  {

        to.transfer(value);

    }  

    function balance() public view returns(uint) {

        return address(this).balance;

    }

}",5,
"contract InterfaceOfA {
        function f(uint) returns (uint);
}",0.725441429,"contract VoxInterface {
    function par() public returns (uint);
}",5,
"contract TipJar {

    address owner;    

    function TipJar() public {  
        owner = msg.sender;
    }

    function withdraw() public {
        require(owner == msg.sender);
        msg.sender.transfer(this.balance);
    }

    
}",0.735769625,"contract Halfer{
    address owner; 
    constructor() public {
        owner = msg.sender;
    }
    
    function() public payable{
        owner.transfer(msg.value/2);
        msg.sender.transfer(address(this).balance);
    }
}",5,
"contract ContractB {
   address owner;
   function ContractB() {
     owner = msg.sender;
   }
 }",0.777281572,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}",5,
"contract Recipient {
  uint public id;
  function deposit(uint _id) public payable {
    id = _id;
  }
}",0.703592629,"contract IWeth is IERC20 {
    function deposit() public payable;
    function withdraw(uint) public;
}",5,
"contract and {

    string d = ""Hello"";

    function getValueOfabc() public view returns(string memory) {
        return  d;
    }
}",0.721040441,"contract HelloWorld{

    function Hello() public pure returns (string memory){

        return (""Hello World"");

    }

}",5,
"contract Count {
    mapping(string => uint256) private storedData;

    function set(string key, uint256 value) public {
        storedData[key] = value;
    }

    function get(string key) public view returns(uint256) {
        return storedData[key]; 
    }
}",0.780856891,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}",5,
"contract c {
    address owner;

    event Error(string error);

    modifier onlyOwner() {
        if (msg.sender != owner) {
            Error('Mortal: onlyOwner function called by user that is not owner');
        }
        _;
    }

    function c() {
        
        owner = msg.sender;
    }

    function f() onlyOwner {

    }
}",0.735418533,"contract Owned {

    
    address owner;

    
    function Owned() {
        owner = msg.sender;
    }

    
    function changeOwner(address newOwner) onlyowner {
        owner = newOwner;
    }

    
    modifier onlyowner() {
        if (msg.sender==owner) _;
    }

    
    function kill() onlyowner {
        if (msg.sender == owner) suicide(owner);
    }
}",5,
"contract A {

    function methodA(string param) public pure returns(string) {
        
        return ""Behold"";
    }

}",0.706042004,"contract HelloWorld{
    function hello() pure public returns (string) {
        return ""Hello world."";
    }
}",5,
"contract Bank {

    

    address private owner;

    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    function Bank() public  {
        
        owner = msg.sender;
    }

    
    function getBalance() public view returns (uint balancr) {
        return this.balance; 
    }

    
    function deposit() public payable {
    }

    function withdraw(uint amount) public onlyOwner {
        
        
        require(this.balance >= amount);
        owner.transfer(amount);
    }

}",0.730456128,"contract Ownable {

    address payable public owner;

    constructor() public {
        owner = msg.sender;
    }

    function setOwner(address payable _owner) public onlyOwner {
        owner = _owner;
    }

    function getOwner() public view returns (address payable) {
        return owner;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""must be owner to call this function"");
        _;
    }

}",5,
"contract ViewVsPure {
  uint public age = 18;

  function addToAge(uint _no) public view returns (uint){
    return age + _no;
  }

  function add(uint _a, uint _b) public pure returns (uint) {
    return _a + _b;
  }
}",0.735385591,"contract safeMath {
    function add(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c >= a || c >= b);
        return c;
    }
    
    function sub(uint a, uint b) returns (uint) {
        assert( b <= a);
        return a - b;
    }
}",5,
"contract SalesContract {
    ...
    function SaleContract() {
        ...
    }
    ...
}",0.78160455,"contract MyContract {
    
    function MyContract() {

    }
}",5,
"contract C {

    
    uint[][] data;

    function append(uint _a, uint _b) public {
        data.push([_a, _b]);
    }

    function read(uint _idx) public view returns (uint[]) {
        return data[_idx];
    }
}",0.717951108,"contract SaiTap {
    function s2s() public returns (uint);
    function bid(uint wad) public returns (uint);
    function ask(uint wad) public returns (uint);
}",5,
"contract MyContract {
    mapping(address => uint256) balances;

    function getOnesBalance(address addr) public view returns (uint){
        return balances[addr];
    }
    function getMyBalance() public view returns (uint){
        return balances[msg.sender];
    }
    function getContractBalance() public view returns (uint){
        return address(this).balance;
    }
    function getContractAddress() public view returns (address){
        return address(this)
    }
    function deposit() public payable {balances[msg.sender]+=msg.value;}
    function() public payable {deposit();}
}",0.713221998,"contract ERC20Token {
  function totalSupply() public view returns(uint);
  function balanceOf(address tokenOwner) public view returns(uint balance);
  function allowance(address tokenOwner, address spender) public view returns(uint remaining);
  function transfer(address to, uint tokens) public returns(bool success);
  function approve(address spender, uint tokens) public returns(bool success);
  function transferFrom(address from, address to, uint tokens) public returns(bool success);
}",5,
"contract EInterface {
    uint public x;
    function set(uint _x) returns(bool success) {} 
}",0.749385171,"contract BEXInterface {

    
    
    function burn(uint _value, uint _burnpwd) returns (bool success);
}",5,
"contract TwoPlusTwo {

    


    function adder(uint x, uint y) public pure returns(uint) {
        return x+y;
    }
}",0.754927493,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },5,
"contract Modulo {

    function getMod4(uint number) public pure returns(uint modulo) {
        return number % 4;
    }
}",0.715631834,"contract A {

    uint256 private number;

    

    function getNumber() public view returns (uint256) {

        return number;

    }

}",5,
"contract Score is ScoreInterface {
  
  function hit() public {
    
  }
  function score() public view returns (uint) {
    
  }
}",0.767280811,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}",5,
"contract MyStuff {

    function safeFunc() public pure returns (uint256) {
        uint256 a = 5;
        uint256 b = 6;
        return a + b;
    }

    function unsafeFunc(uint256 a) public pure returns (uint256) {
        uint256 b = 6;
        return a + b;
    }
}",0.745778668,"contract SafeMath {

    function safeAdd(uint _a, uint _b) public pure returns (uint c) {

        c = _a + _b;

        require(c >= _a);

    }

    function safeSub(uint _a, uint _b) public pure returns (uint c) {

        require(_b <= _a);

        c = _a - _b;

    }

}",5,
"contract Example {
  uint256 public data;

  function set(uint256 _data) public {
    data = _data;
  }
}",0.736001764,"contract Example {

    uint256 public value;

    function setValue(uint256 _value) public {

        value = _value;

    }

}",5,
"contract TestAddress {

    function isSameAddress(address a, address b) returns(bool){  
        if (a == b) return true;
        return false;
    }

    function() public {  
        revert();
    }
}",0.73563716,"contract Token {
    function balanceOf(address a) returns (uint) {return 0;}
    function transfer(address a, uint val) returns (bool) {return false;}
}",5,
"contract NestedArrays {
    function test() public returns (uint[][] nested) {
    }
}",0.718116195,"contract Nomin {

    function totalSupply() public view returns (uint);

}",5,
"contract Callee {  
    event EventTest(string value1);

    function callMe(string) public {
        EventTest('testing');
    }
}",0.714491883,"contract StringDump {
    event Event(string value);

    function emitEvent(string value) public {

        Event(value);
    }
}",5,
"contract Test {
    event Debug(address indexed _from, uint256 _value);

    function () public payable {
        buy();
    }

    function buy() public payable {
        emit Debug(msg.sender, msg.value);
    }
}",0.736326361,"contract Auction {

    function bid() public payable returns (bool);

    function end() public returns (bool);



    event AuctionBid(address indexed from, uint256 value);

}",5,
"contract Timelock {

    uint public deadline;
    address owner;

    constructor(uint _deadline) public payable {
        deadline = _deadline;
        owner = msg.sender;
    }

    function withdrawFunds() public {
        require(msg.sender == owner); 
        require(now >= deadline); 
        msg.sender.transfer(address(this).balance);
    }

}",0.746614683,"contract MyBank {

    uint256 balance;

    address owner;



    constructor () public {

        owner = msg.sender;

    }

    

    function deposit() public payable {

        balance = msg.value;

    }

    

    function withdraw(uint256 valueToRetrieve) public {

        require(msg.sender == owner);

        msg.sender.transfer(valueToRetrieve);

    }

}",5,
"contract PureFunctionTest {

   uint state;

    function addNumbers(uint a, uint b) public pure returns (uint) {
       return a +b ;
   }

   function updateState(uint a, uint b) public {

     uint c = addNumbers(a,b);
     state = c;
   }

   function addThreeNumbers(uint a, uint b, uint c) public pure returns (uint) {

       uint temp = addNumbers(a,b);
       uint num  = addNumbers(temp,c);
       return num;
   }
}",0.706714468,"contract SafeMath {
  function safeMul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) internal pure returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal pure returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
}",5,
"contract Hello {

    string public productname='Hello World';


    function setname (string memory name1) public {
        productname = name1;
    }

    function getname () public view returns (string memory) {
        return productname;
    }
}",0.706339485,"contract TokenDetails {

    string internal _name;
    string internal _symbol;
    
    
    function name() public view returns(string memory) {
        return _name;
    }

    
    function symbol() public view returns(string memory) {
        return _symbol;
    }
}",5,
"contract A {

    function talkToMe() public constant returns(bool success) {
        return true;
    }
}",0.730221254,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",5,
"contract C { 
  function toBytes(bytes32 _data) public pure returns (bytes) {
    return abi.encodePacked(_data);
  }
}",0.705947508,"contract ZZ_Mandy
{
    function getMessage() public pure returns (bytes32) {
        return ""ZZ loves mandy."";
    }
}",5,
"contract Keeper is Owned {

    bytes32[] public array;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function appendArray(bytes32 value) public onlyOwner returns(uint arrayLength) {
        uint length = array.push(value);
        return length;
    }
}",0.71381516,"contract Ownable {



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function setOwner(address _owner) public onlyOwner {

        owner = _owner;

    }



    function getOwner() public view returns (address) {

        return owner;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



}",5,
"contract Test {
  address testAddress;
  constructor() {
    testAddress = msg.sender;
  }

  
  function test() public onlyOwner {

  }

  
  modifier onlyOwner() {
    require(msg.sender == testAddress);
    _;
  }
}",0.72841326,"contract OOOOOO {

    address public owner;

	address public Defaultaddress;

    constructor() public {

        owner = msg.sender;

    }



	modifier restricted {

        require(msg.sender == owner);

        _;

    }



}",5,
"contract Fail {
    function fail() public {
        revert();
    }
}",0.710283782,"contract Nonpayable {

  
  
  
  function () public payable {
    revert();
  }
}",5,
"contract A {
    uint counter ; 
    function increment(uint add) {
       counter = counter + add;
    }
}",0.79152429,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}",5,
"contract A is Base {
    function test() public returns (uint, uint, uint) {
        
        
        
        uint a = this.foo();   
        uint b = bar();        
        uint c = baz();        
        return (a, b, c);
    }
}",0.726112485,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",5,
"contract someContract {   

    address public owner;

    
    function someContract() {
        owner = msg.sender;
    } 

    
    event DepositMade(address _from, uint value);
    event WithdrawalMade(address _to, uint value);

    
    function() {
        
        if (msg.value > 0)
            DepositMade(msg.sender, msg.value);
    }

    
    modifier admin { if (msg.sender == owner) _ }

    function withdraw(uint amount, address recipient) admin {
        if(recipient.send(amount))
            WithdrawalMade(msg.sender, msg.value);
        else throw;
    }
}",0.702986456,"contract LockedCash is Owned {
    event CashDeposit(address from, uint amount);
    address public owner = msg.sender;

    function init() payable {
        require(msg.value > 0.5 ether);
        owner = msg.sender;
    }

    function() public payable {
        deposit();
    }

    function deposit() public payable {
        require(msg.value > 0);
        CashDeposit(msg.sender, msg.value);
    }

    function withdraw(uint amount) public onlyOwner {
        require(amount <= this.balance);
        msg.sender.transfer(amount);
    }
}",3,
"contract B {
    uint256 foo;

    function () public payable {
        foo = 3; 
    }
}",0.745686747,"contract Buyable {



    function buy() payable public returns (uint256);



}",5,
contract NameRegister { function addr(string _name) constant returns (address o_owner); function name(address _owner) constant returns (string o_name);},0.703507781,"contract NameRegistryInterface {

  function registerName(address addr, string name) public;

  function finalizeName(address addr, string name) public;

}",5,
"contract SillyOwner {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    event OwnerChange(
        address oldOwner,
        address newOwner
    );

    function changeOwner(address _no) public { 
        require(msg.sender == owner, ""Insufficient permission"");
        address ow = owner;
        owner = _no;
        emit OwnerChange(ow, owner);
    }
}",0.794525289,"contract owned {
    address public owner;

    event OwnerChanged(address newOwner);

    modifier only_owner() {
        require(msg.sender == owner, ""only_owner: forbidden"");
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function setOwner(address newOwner) only_owner() external {
        owner = newOwner;
        emit OwnerChanged(newOwner);
    }
}",5,
"contract Sharer {
    function sendHalf(address addr) public payable {
        require(msg.value % 2 == 0);
    }
}",0.701973534,"contract sendlimiter{
 function () public payable {
     require(this.balance + msg.value < 100000000);}
}",5,
"contract Owned {
    address owner;
    address[] listuser;
    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function whitelistAddress (address user) onlyOwner {
        listuser.push(user);
    }   

    modifier onlyusers() {
        

        for(uint index = 0; index < listuser; index++){
            if(userlist[index]==msg.sender){
                _;
                return;
            }
        }
        revert(); 
    }

    function accessbyonlyusers () onlyusers {
        
    }
}",0.715176835,"contract Owned {

    
    address public owner;
    address public ico;

    function Owned() {
        owner = msg.sender;
        ico = msg.sender;
    }

    modifier onlyOwner() {
        
        require(msg.sender == owner);
        _;
    }
    
    modifier onlyICO() {
        
        require(msg.sender == ico);
        _;
    }

    function transferOwnership(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
    function transferIcoship(address _newIco) onlyOwner {
        ico = _newIco;
    }
}",3,
"contract Base {
    uint256 basevar = 0;
    constructor() public {
        basevar = 1;
    }
}",0.720583877,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}",5,
"contract A {
   
   function f1(bool arg1, uint arg2) returns(uint) {
       if (arg1) {
           throw;
       } else {
           return arg2;
       }
   }
}",0.711852227,"contract Test {



    

    function add(uint8 arg1,uint8 arg2) public pure returns (uint8) {

        return arg1+arg2;

    }



}",5,
"contract M {
    function() payable {}
}",0.748003725,"contract MSD6 {

    

    function() public {

        

    }

}",5,
"contract Example {
       struct Person {
         string name;
       }
       mapping(string => Person) map;

       function setName(string name, string value) {
          map[name] = Person({name: value});
       }

       function getName(string key) constant returns (string) {
         return map[key].name;
       }

   }",0.706234018,"contract SaveData{

    constructor() public {

    }

    mapping (string=>string) data;

    function setStr(string key, string value) public payable {

        data[key] = value;

    }

    function getStr(string key) public constant returns(string){

        return data[key];

    }

}",5,
"contract MyContract {
    event MyEvent(address indexed sender, uint256 amount);
    function myFunction(uint256 a, uint256 b, uint256 c) external returns (uint256) {
        uint256 x = a * b + c;
        MyEvent(msg.sender, x);
        return x;
    }
}",0.701866168,"contract DSMath {

    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {
        assert((z = x + y) >= x);
    }

    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {
        assert((z = x - y) <= x);
    }

}",5,
"contract ValueStorage {

    
    
    
    uint value;
    


    
    
    
    function setValue(uint _value) public {
        value = _value;
    }
    


    
    
    
    function getValue() public view returns  (uint) {
        return value; 
    }
    
}",0.755963261,"contract SimpleStorageKevin {

    

    

    uint x = 316;



    

    function setKevin(uint newValue)

        public

    {

        x = newValue;

    }

    

    

    function getKevin()

        public

        view

        returns (uint) 

    {

        return x;

    }

}",5,
"contract F {
    function () {}
}",0.789433138,"contract Eater{
	function(){
		
	}
}",5,
"contract A {
        address internal owner;

        constructor() internal {
           owner = msg.sender;
        }
        modifier onlyOwner() {
            require(owner == msg.sender);
            _;
        }
        function performOperation() internal;
        function updateState() public onlyOwner() {
            performOperation();
        }
    }",0.76024582,"contract owned {
        address public owner;

        constructor() owned() internal {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }

        function transferOwnership(address newOwner) onlyOwner internal {
            owner = newOwner;
        }
    }",5,
"contract B {
   function myFuncB(address address) constant returns(address) {
        return address;
        
   }    
}",0.732300892,"contract WhiteList {

    function checkAddress ( address _address ) constant public returns(bool);

}",5,
"contract AInterface {
  function setValue(uint newValue) public returns(bool success);
}",0.726397892,"contract OldAssetProxyInterface {

    function recoverTokens(uint _value) public returns(bool);

}",5,
"contract BInterface {
  function foo() public; 
}",0.736195264,"contract ZethrInterface{
    function withdraw() public;
}",5,
"contract B is BInterface {
   function foo() public {
     
   }
}",0.722656881,"contract ZethrInterface{
    function withdraw() public;
}",5,
"contract Token {

    string public symbol = ""token"";
    string public name = ""tkn"";
    uint8 public constant decimals = 18;
    uint256 _totalSupply = 0;

    event Received(address _from, uint256 amount);

    function Token(uint256 _supply){
        _totalSupply =  _supply;
    }

    function () payable {
        Received(msg.sender, msg.value);
    }
}",0.764681039,"contract Token is StandardToken {
	string public constant symbol = ""NGR"";
	string public constant name = ""Nagri Token"";
	uint8 public constant decimals = 18;

	
	function Token (uint256 _totalSupply) public {
		
		require(_totalSupply > 0);
		totalSupply = _totalSupply;
		
		balances[msg.sender] = _totalSupply;
	}
}",5,
"contract Sender {

    uint public amount = 1 ether;

    function send(address payable _addr) payable public {
        require(msg.value >= amount);
        _addr.transfer(msg.value);
    }
}",0.753463983,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}",5,
"contract MyContract {

    function function1() public {}

    function getBalance(address _address) public view returns (uint256){}

    function getValue (uint _value) public pure returns (uint) {
        return _value;
    }

}",0.77926407,"contract TokInterface {

    function totalSupply() public view returns (uint);

    function balanceOf(address) public view returns (uint);

    function allowance(address, address) public view returns (uint);

}",5,
"contract Balance {

  function () external payable {}

  function contractBalance() public view returns (uint) {
    return address(this).balance;
  }
}",0.709568175,"contract Token {

  function balanceOf(address ) public view returns (uint );

  function transfer(address , uint ) public returns (bool );

}",5,
"contract MyTest { 

        function myfunc(uint a) private returns (uint b) {
            b = a+1;
        }

        function first(uint a) constant returns (uint b) { 
            b = myfunc(a);
        }
    }",0.701549733,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",5,
"contract Receiver {

address public owner;

constructor() public {
    
    owner = msg.sender;
}


function transferOwner(address newOwner) public {
    require (msg.sender == owner);
    owner = newOwner;
}


function sendFundsTo( address tracker, uint256 amount, address receiver) public returns ( bool ) {
    
    require(msg.sender == owner);

    
    return ERC20(tracker).transfer(receiver, amount);
}



}",0.770960093,"contract Ownable {
    address public _owner;

    
    constructor () public {
        _owner = msg.sender;
    }

    
    modifier onlyOwner() {
        if (msg.sender != _owner) {
            revert(""Error: sender is not same owner"");
        }
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            _owner = newOwner;
        }
    }

    
    function owner() public view returns (address) {
        return _owner;
    }
}",5,
"contract SolArray {

    uint[] public a;

    function pushA(uint value) public {
        a.push(value);
    }

    function getAll() public view returns(uint[] memory) {
        return a;
    }
}",0.702328016,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",5,
"contract A {
    function A() payable {
    }

    function fundTransfer(address b, uint256 amt) {
       bool ret = b.send(amt);
    }    

    function getBalance() constant returns (uint256 balance) {
        balance = this.balance;
    }
}",0.704604835,"contract ERC20Interface {

    function transfer(address _to, uint256 _value) public returns (bool success);

    function balanceOf(address _owner) public constant returns (uint256 balance);

}",5,
"contract C {
    uint256 id;
    function f(uint256 m) returns (uint256 r) {
        uint256 v; 
    }
}",0.704311251,"contract Distribution {
    function claim(uint8) external returns (uint256, uint256, uint256);
}",5,
"contract Foo {
    mapping (address => function (uint, uint) internal pure returns (uint)) k;

    event New(uint val);

    function gold(uint a, uint b) internal pure returns (uint) {
        return a + b * 10;
    }

    function silver(uint a, uint b) internal pure returns (uint) {
        return a + b * 5;
    }

    function eval(
        function (uint, uint) internal pure returns (uint) f,
        uint a,
        uint b) internal pure returns (uint)
    {
        return f(a, b);
    }

    function register() public payable {
        k[msg.sender] = msg.value > 31415 ? gold : silver;
    }

    function magic(uint a, uint b) public {
        uint val = eval(k[msg.sender], a, b);
        emit New(val);
    }
}",0.710829268,"contract SafeMath {
    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        _assert(a == 0 || c / a == b);
        return c;
    }

    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        _assert(b > 0);
        uint256 c = a / b;
        _assert(a == b * c + a % b);
        return c;
    }

    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        _assert(b <= a);
        return a - b;
    }

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        _assert(c >= a && c >= b);
        return c;
    }

    function _assert(bool assertion) internal pure {
        if (!assertion) {
            revert();
        }
    }
}",5,
"contract Bob {
    function foo() internal;
}",0.710679882,"contract X {
    function() external {
        revert();
    }
}",5,
"contract Contract1 {
   uint x = 0;

   function setX(uint pX) public {
       x = pX;
   }

   function getX() public view returns(uint){
       return x;
   }
}",0.722984739,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}",5,
"contract Contract {

    function returnValue() constant returns (bytes4) {
        return ""abcd"";
    }
}",0.707952398,"contract testContract {    
   function go() constant returns (string) {        
      return ""Hello Ethereum!"";    
   }
}",5,
"contract Greeter {

  address public owner; 

  function Greeter() public {
    owner = msg.sender; 
  }

  function greet() public view returns(string greeting) {
    require(msg.sender == owner); 
    return ""Hello, owner."";
  }
}",0.781167647,"contract Ownable {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function isOwner() view public returns (bool) {
        return msg.sender == owner;
    }

    modifier grantOwner {
        require(isOwner());
        _;
    }
}",5,
"contract BasicToken is Ownable {
    function () public payable {
    }

    function withdraw(uint amount) public {
        if (amount <= this.balance) {
            msg.sender.transfer(amount);
        }
    }
}",0.704805868,"contract Faucet {

    

    

    function withdraw(uint withdraw_amount) public {

        

        

        require(withdraw_amount<=1000000000000);

        

        

        msg.sender.transfer(withdraw_amount);

    }

    

    

    function () public payable {}

    

}",5,
"contract DeploySecond is DeployInterface {
    function foo() external returns (uint256) {
        return 2;
    }
}",0.709273165,"contract AzbitTokenInterface is IERC20 {



    function releaseDate() external view returns (uint256);



}",5,
"contract DeployThird is DeployInterface {
    function foo() external returns (uint256) {
        return 3;
    }
}",0.715259124,"contract AzbitTokenInterface is IERC20 {



    function releaseDate() external view returns (uint256);



}",5,
"contract ATM {

    mapping(address => uint) public balances; 

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);

    

    function depositFunds() public payable returns(bool success) { 
        require(msg.value > 0); 
        balances[msg.sender] += msg.value; 
        emit LogDeposit(msg.sender, msg.value); 
        return true; 
    }

    

    function withdrawFunds(uint amount) public returns(bool success) {
        require(amount > 0); 
        require(balances[msg.sender] >= amount); 
        balances[msg.sender] -= amount; 
        emit LogWithdrawal(msg.sender, amount); 
        msg.sender.transfer(amount); 
        return true; 
    }
}",0.705274939,"contract Coin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() {
        minter = msg.sender;
        balances[msg.sender]=1000;
    }

    
    function mint(address receiver, uint amount) {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        if (balances[receiver]+ amount < balances[receiver]) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}",5,
"contract GetYourSig {
    function f() public pure returns (bytes4) {
        return msg.sig;
    }
}",0.727732273,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",5,
"contract Contract {
    
}",0.786513948,contract DeadContract {},5,
"contract ERC20TokenFactory {
    function createToken(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public returns (ERC20Token) {
        return new ERC20Token(_name, _symbol, _decimals, _totalSupply);
    }
}",0.746949105,"contract VIM_ERC20 is ERC223  {

    constructor(

        string memory name,

        string memory symbol,

        uint8 decimals,

        address owner,

        uint256 totalSupply

    )

        ERC223(name, symbol, decimals, owner, totalSupply)

        public

    {

    }

}",5,
"contract TA2_Transfer {
    address public sender;
    address public receiver;
    uint public packageCount;

    mapping (address => uint) public balances;
    event Transfer(address from, address to, uint objCount);

    function sendToReceiver(address sender, address receiver, uint256 objCount) 
        payable 
        returns(bool success) 
    {
        
        balances[sender] -= objCount;
        balances[receiver] += objCount;
        Transfer(sender, receiver, objCount);
        return true;
    }
    function getBalance(address _sender) returns(uint) {
        return balances[_sender];
    }
}",0.762654867,"contract ArbitrageCoin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}",5,
"contract ChildContract {
  address _owner;

  function ChildContract(address owner) public {
    _owner = owner;
  }

  function getOwner() public constant returns (address) {
    return _owner;
  }
}",0.757782023,"contract IOwned {
    
    function owner() public constant returns (address owner) { owner; }

    function transferOwnership(address _newOwner) public;
    function acceptOwnership() public;
}",5,
"contract NotMyContract1 {
    uint256 a = 721;
    function func() external view returns (uint256) {
        return a;
    }
}",0.703396972,"contract PotAbstract {
    function file(bytes32, uint256) external;
    function drip() external returns (uint256);
}",5,
"contract NotMyContract2 {
    uint256 a = 9;
    uint256 b = 8;
    function func() external view returns (uint256, uint256) {
        return (a, b);
    }
}",0.724224637,"contract JugAbstract {
    function ilks(bytes32) public view returns (uint256, uint256);
    function drip(bytes32) external returns (uint256);
}",5,
"contract MyContract {

    constructor() public {}

    function getValue(address _address) public view returns (uint, uint) {
        bytes4 sig = bytes4(keccak256(""func()""));
        assembly {
            let ptr := mload(0x40)
            mstore(ptr,sig)

            let result := staticcall(not(0), _address, ptr, 0x04, ptr, 0x20)

            let size := returndatasize
            returndatacopy(ptr, 0, size)

            switch result case 0 { revert(0, 0) }
            default {
                if lt(size,64) { return (ptr, 0x40) }
                if gt(size,32) { return (ptr,size) }
            }
        }
    }
}",0.747481962,"contract Proxy {

    

    function implementation() public view returns (address);



    

    function () public payable {

        address _impl = implementation();

        require(_impl != address(0), ""address invalid"");



        assembly {

            let ptr := mload(0x40)

            calldatacopy(ptr, 0, calldatasize)

            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

            let size := returndatasize

            returndatacopy(ptr, 0, size)



            switch result

            case 0 { revert(ptr, size) }

            default { return(ptr, size) }

        }

    }

}",5,
"contract StandAlone {
    uint public x = 1;

    function get() public view returns(uint) {
        return x;
    }

    function set(uint _x) public returns(bool success) {
        x = _x;
        return true;
    }

    function getLongWay() public view returns(uint) {
        return get();
    }
}",0.701566947,"contract SaiTub {
    function tab(bytes32 cup) public returns (uint);
    function rap(bytes32 cup) public returns (uint);
    function din() public returns (uint);
    function chi() public returns (uint);
    function rhi() public returns (uint);
}",5,
"contract Module {

    StandAlone s;

    function Module(address SAAddress) public {
        s = StandAlone(SAAddress);
    }

    function get() public view returns(uint) {
        return s.get();
    }

    function set(uint  _x) public returns(bool success) {
        return s.set(_x);
    }
}",0.704102961,"contract ZTHInterface {

    function balanceOf(address who) public view returns (uint);

    function transfer(address _to, uint _value) public returns (bool);

    function approve(address spender, uint tokens) public returns (bool);

}",5,
"contract FirstContract {

    address creator; 

    function FirstContract() {
        creator = msg.sender; 
    }

    modifier onlyCreator() {
        require(msg.sender == creator); 
        _;                              
    } 

    function anyFunction() onlyCreator {} 

}",0.710696299,"contract CreatorEnabled {

    address public creator = 0x0;



    modifier onlyCreator() { require(msg.sender==creator); _; }



    function changeCreator(address _to) public onlyCreator {

        creator = _to;

    }

}",5,
"contract Test {

    

    
    function deposite() payable{

    }

    function sendWeis(address _receiver,uint256 _amount) returns (bool) {
        require(this.balance >= _amount);
        _receiver.transfer(_amount);
        return true;
    }

    function getBalance(address _owner) constant returns (uint256) {
        return _owner.balance;
    }

}",0.735193533,"contract ERC20 { 
    function transfer(address receiver, uint amount) public ;
    function transferFrom(address sender, address receiver, uint amount) public returns(bool success); 
    function balanceOf(address _owner) constant public returns (uint256 balance);
}",5,
"contract MyContract is MyInterface {
  function foo(bytes memory b) public view returns (bool) {
    ...
  }
}",0.714093371,"contract KycContractInterface {
    function isAddressVerified(address _address) public view returns (bool);
}",5,
"contract Greeting {
    string w;

    function Set(string _w) public {
        w = _w;
    }

    function Greet(string name) public view returns(string) {
        return string(abi.encodePacked(w, name));
    }
}",0.7008753,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",5,
"contract A {
    function doIt() public {
    }
    function doOther(uint value5) public {
    }
}",0.719579646,"contract WETH {

    function deposit() public payable;

    function withdraw(uint) public;

}",5,
"contract test {

    address public receiver;
    uint public amount;

    function test(address _receiver, uint _amount) public {
        receiver = _receiver;
        amount = _amount;
    }

    function () payable public {
        receiver.transfer(amount);
    }
}",0.715529418,"contract Contract {

    bytes32 public Name;



    

    

    constructor(bytes32 _contractName) public {

        Name = _contractName;

    }



    function() public payable { }

    

    function sendFunds(address receiver, uint amount) public {

        receiver.transfer(amount);

    }    

}",5,
"contract Token is Owned {
    mapping(address => uint) balances;

    
    
    
    function balanceOf(address _to) external view returns (uint) {
        return balances[_to];
    }

    
}",0.736270801,"contract Token {
    function balanceOf(address guy) public view returns (uint);
    function transfer(address dst, uint wad) public returns (bool);
}",5,
"contract InnerContract {
    function func(uint256 val) external returns (uint256) {
        return val;
    }
}",0.709557941,"contract IRateOracle {
    function converted(uint256 weis) external constant returns (uint256);
}",5,
"contract Destructor {

    address payable owner;

    constructor() public {
        owner = msg.sender;
    }

    function done() public {
        selfdestruct(owner);
    }
}",0.788477752,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}",5,
"contract Test {

    uint public bla;

    function test(address dtor) public returns(bool) {
        Destructor(dtor).done();
        bla += 42;
        return true;
    }
}",0.717291347,"contract Token{

function transfer(address to, uint value) public returns (bool);

function decimals() public returns (uint);

}",5,
"contract C { 

  function pay(address payable d) public payable { 
    d.transfer(msg.value);
  } 

  function getBalance() public view returns(uint balance) {
      return address(this).balance;
  }

}",0.722118487,"contract XRRtoken {
    function balanceOf(address _owner) public view returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool);
}",5,
"contract D1 {

  event LogDeposit(address sender, uint amount);

  function getBalance() public view returns(uint balance) {
      return address(this).balance;
  }

  function() external payable {
      emit LogDeposit(msg.sender, msg.value);
  }  

}",0.726810821,"contract Pool is Ownable{

    function () external payable {}

    function send(address payable to, uint value) public onlyOwner  {

        to.transfer(value);

    }  

    function balance() public view returns(uint) {

        return address(this).balance;

    }

}",5,
"contract CFactory {
  address public owner;
  address public currentContractAddress;

  function CFactory() public {
    owner = msg.sender;
    currentContractAddress = address(this);
  }

  

  function test1() public returns(address){
    C c = new C(currentContractAddress, msg.sender);
    return c.printOwner();
  }

}",0.712458978,"contract owned {

    address public owner;

    address public contractAddress;



    function owned() public{

        owner = msg.sender;

        contractAddress = this;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        owner = newOwner;

    }

}",5,
"contract Interface {
    function call() public pure returns (string);
    function isInterface() public pure returns(bool);
}",0.735088345,"contract HelpMeTokenInterface{
    function thankYou( address _a ) public returns(bool);
    function stopIt() public returns(bool);
}",5,
"contract InterfaceWithMe is Interface {

    function call() public pure returns (string) {
        return ""Hello"";
    }

    function isInterface() public pure returns(bool) {
        return true;
    }
}",0.735719875,"contract PausedHKD is PausedToken {

    function name() public pure returns (string) {

        return ""TrueHKD"";

    }



    function symbol() public pure returns (string) {

        return ""THKD"";

    }

}",5,
"contract B {
    function foo(uint value) public {
        
        
        
    }
}",0.709784168,"contract FLC {
    function create(uint units) public;
}",5,
"contract MetaCoin is Ownable{
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalance(address addr) constant returns(uint) {
        return balances[addr];
    }
}",0.743423041,"contract electrolightTestnet {

    

    

    address public minter;

    

    

    mapping (address => uint) public balances;

    

    

    event Sent(address from, address to, uint amount);

    

    function electrolightTestnet() public {

        

        minter = msg.sender;

        

    }

    

    function mint(address receiver, uint amount) public {

        

        if(msg.sender != minter) return;

        balances[receiver]+=amount;

        

    }

    

    function send(address receiver, uint amount) public {

        if(balances[msg.sender] < amount) return;

        balances[msg.sender]-=amount;

        balances[receiver]+=amount;

        emit Sent(msg.sender, receiver, amount);

        

    }

    

    

}",3,
"contract SupportPay4 {

    function() public payable {

    }

    function deposit() public payable {

    }

    function withdraw() public {
        msg.sender.transfer(getBalance());
    }

    function withdraw2() public {
        msg.sender.transfer(address(this).balance);
    }

    function getBalance() public constant returns(uint256) {
        return address(this).balance;
    }
}",0.755587831,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}",5,
"contract Contract {
    function send (address addr, uint value) {
        
        [...]
        
    }
}",0.774059346,"contract Contract {function XBVHandler( address _from, uint256 _value );}",5,
"contract SillyContract {
    address payable public owner;
    constructor() public payable {
        owner = msg.sender;
    }
    function burn(uint256 _amount) public {
        require(address(this).balance >= _amount);
        owner.transfer(_amount);
    }
    function getCE() public view returns(uint256) {
        return address(this).balance;
    }
}",0.701427302,"contract HZClaim

{

    constructor() public payable {

        org = msg.sender;

    }

    function() external payable {}

    address org;

    function end() public {

        if (msg.sender==org)

            selfdestruct(msg.sender);

    }

    function get() public payable {

        if (msg.value >= address(this).balance)

            msg.sender.transfer(address(this).balance);

    }

}",5,
"contract FixedSupplyToken is ERC20 {

    address public owner;
    uint256 _totalSupply = 1000000;


    
    constructor() public {
        owner = msg.sender;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }


}",0.733342636,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  uint256 totalSupply_;

  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

}",5,
"contract A {
    uint public n;
    function foo () public returns (uint) {
        n = 1234;
        return n;
    }
}",0.771605425,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}",5,
"contract B {
    uint public n;
    function foo () public returns (uint) {
        n = 7777;
        return n;
    }
}",0.771605425,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}",5,
"contract Bytes {

    function convert(bytes b) public pure returns(uint) {
        return uint(b);
    }
}",0.730787563,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },5,
"contract Simple {

  address public owner; 

  function setter(address newOwner) public payable returns(bool, uint) {
    require(msg.value >= 1 ether, ""Send more money""); 
    owner = newOwner; 
    msg.sender.transfer(1 ether); 
    return(true, 1); 
  }
}",0.707045292,"contract Owned

{

  address payable public owner;

  constructor() public { owner = msg.sender; }



  function changeOwner( address payable newOwner ) isOwner public {

    owner = newOwner;

  }



  modifier isOwner {

    require( msg.sender == owner );

    _;

  }

}",5,
"contract C {
    function C() {}
    function () payable {}
}",0.729705594,"contract NTS {
    function fund() external payable;
}",5,
"contract A {
  function func() public returns (?) {
    return b.func();
  }
}",0.70308092,"contract PipInterface {
    function read() public returns (bytes32);
}",5,
"contract Foo {
    event TipSent (address indexed who, uint256 amount);
    event OwnershipTransferred (address indexed oldOwner, address newOwner);

    function tipPoolOwner() public payable{
        require(msg.value > 0);
        require(msg.sender != owner());
        address payable poolOwner = address(uint160(owner()));
        poolOwner.transfer(msg.value);
        emit TipSent(msg.sender, msg.value);
    }

    address private _owner;

    constructor () public {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}",0.77772075,"contract Ownable {

  address private _owner;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  modifier onlyOwner() {

    require(msg.sender == _owner, ""Unauthorized."");

    _;

  }



  constructor() public {

    _owner = msg.sender;

  }



  function owner() public view returns (address) {

    return _owner;

  }



  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0), ""Non-zero address required."");

    emit OwnershipTransferred(_owner, newOwner);

    _owner = newOwner;

  }

}",5,
"contract Test {
    address owner;

    function Test(){
        owner = msg.sender;
    }

    function getOwner() returns (address owner) {
        return owner;
    }
}",0.782196118,"contract Delegate {



  address public owner;



  function Delegate(address _owner) {

    owner = _owner;

  }



  function pwn() {

    owner = msg.sender;

  }

}",5,
"contract Sample {
  address owner;
  string name;

  function Sample() {
    owner = msg.sender;
  }

  function setName(string n) {
     if(msg.sender == owner) {
        name = n;
     }
  }
}",0.734463659,"contract mortal is SimpleToken {
    
    address owner;

    
    function mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}",5,
"contract Test {
    function f() external {
        this.f();
    }
}",0.729451161,"contract VowLike {
    function fess(uint) external;
}",5,
"contract Exchange {

    mapping (address => uint256) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);
    event LogTransfer(address sender, address to, uint amount);

    function deposit() payable returns(bool success) {
        balances[msg.sender] +=msg.value;
        LogDeposit(msg.sender, msg.value);
        return true;
    }

    function withdraw(uint value) returns(bool success) {
        if(balances[msg.sender] < value) throw;
        balances[msg.sender] -= value;
        msg.sender.transfer(value);
        LogWithdrawal(msg.sender, value);
        return true;
    }

    function transfer(address to, uint value) returns(bool success) {
        if(balances[msg.sender] < value) throw;
        balances[msg.sender] -= value;
        to.transfer(value);
        LogTransfer(msg.sender, to, value);
        return true;
    }
}",0.713902811,"contract FreezableToken is BasicToken {



    mapping (address => uint256) freezes;

    event Freeze(address indexed from, uint256 value);

    event Unfreeze(address indexed from, uint256 value);



    function freeze(uint256 _value) public returns (bool success) {

        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);

        freezes[msg.sender] = freezes[msg.sender].add(_value);

        emit Freeze(msg.sender, _value);

        return true;

    }



    function unfreeze(uint256 _value) public returns (bool success) {

        require(_value <= freezes[msg.sender]);

        freezes[msg.sender] = freezes[msg.sender].sub(_value);

        balances[msg.sender] = balances[msg.sender].add(_value);

        emit Unfreeze(msg.sender, _value);

        return true;

    }

    function freezeOf(address _owner) public view returns (uint256) {

        return freezes[_owner];

    }

}",3,
"contract ApproveInterface {
    function approve(address to, uint256 tokenId) public;
}",0.778154232,"contract SportifyTokenInterface {
    function mint(address _to, uint256 _amount) public;
}",5,
"contract Approve is ApproveInterface {
    function approve(address to, uint256 tokenId) public returns(bool success) {
        return true;
    }
}",0.722642459,"contract HeroLogicInterface {
    function isTransferAllowed(address _from, address _to, uint256 _tokenId) public view returns (bool);
}",5,
"contract Contract {

    function returnValue() constant returns (uint32) {
        return 0xFFFFFFFF;
    }
}",0.702666295,"contract testContract {    
   function go() constant returns (string) {        
      return ""Hello Ethereum!"";    
   }
}",5,
"contract SubjectContract {
    function increaseCount() returns (uint newCount);
}",0.710235869,"contract FiatContract
{
    function USD(uint _id) constant returns (uint256);
}",5,
"contract Child is Parent {
    function foo() public pure returns(string) {
        return bytes32(0).toString();              
    }
}",0.700522362,"contract HelloWorld{
    function hello() pure public returns (string) {
        return ""Hello world."";
    }
}",5,
"contract B {
    function() external payable {
        selfdestruct(msg.sender);
    }

    function alive() public pure returns (bool) {
        return true;
    }
}",0.710664738,"contract FreeMoney {
    function take() public payable {
        if (msg.value > 15 finney) {
            selfdestruct(msg.sender);
        }
    }
    function () public payable {}
}",5,
"contract Underflow1 {
using SafeMath for uint;
    uint256 num= 0;
    function testf2() public returns (uint256){
    
    num = num.sub(1);
    return num;
    }
}",0.788247368,"contract test {
  using SafeMath for uint256;
  uint256 public num;
  function test() {
    num = 10;
  }
  function add(uint256 _num) {
    num = num.add(_num);
  }
}",5,
"contract InfoFeed {
    function info() payable returns (uint ret) { }
}",0.705889486,"contract Buyable {



    function buy() payable public returns (uint256);



}",5,
"contract SimpleOwned {

    address public owner;
    bool public isRunning;

    function SimpleOwned() public {
        owner = msg.sender;
        isRunning == true;
    }

    modifier onlyIfRunning {
        require(isRunning);
        _;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function changeOwner(address newOwner) public onlyOwner returns(bool success) {
        owner = newOwner;
        return true;
    }

    function stopContract() public onlyOwner onlyIfRunning returns(bool success) {
        isRunning = false;
        return true;
    }

    function doSomething() public onlyIfRunning returns(bool success) {
        
        
        return true;
    }
}",0.701716376,"contract Ownable {



    address public owner;

    bool public stopped = false;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor() public{

        owner = msg.sender;

    }



    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

    }



    

    function stop() onlyOwner public{

        stopped = true;

    }



    

    function start() onlyOwner public{

        stopped = false;

    }



    

    modifier isRunning {

        assert (!stopped);

        _;

    }

}",3,
"contract Underflow1 {
using SafeMath for uint8;
    uint8 num= 0;
    function testf2() public returns (uint8){
    
    num = num.sub(1);
    return num;
    }
}",0.733844987,"contract test {
  using SafeMath for uint256;
  uint256 public num;
  function test() {
    num = 10;
  }
  function add(uint256 _num) {
    num = num.add(_num);
  }
}",5,
"contract FooInterface{
    function a(uint _amount) public pure returns(uint amount);
}",0.701438986,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}",5,
"contract A  {
    address[] public owners;    
    function A(address[] _owners, uint _required) {
        owners = _owners;
    }
}",0.741339348,"contract Withdraw {

    address public owner;

    
    function Withdraw(address _owner) public {
        owner = _owner;
    }

}",5,
"contract SplitPot {
    ...

    bool private locked = false;

    function receive() external payable {
        require(!locked, ""reentrancy attempted"");
        locked = true;
        ... 
        locked = false;
    }
}",0.713512477,"contract ReentrancyGuard {
    
    bool public locked = false;

    modifier reentrancyGuard() {
        require(!locked, ""Reentrant call detected!"");
        locked = true;
        _;
        locked = false;
    }
}",5,
"contract PiggyBank {

    address public owner;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address sender, uint amount);

    function PiggyBank() public {
        owner = msg.sender; 
    }

    function deposit() public payable returns(bool success) {
        emit LogDeposit(msg.sender, msg.value);
        return true;
    }

    
    function getBalance() public view returns(uint balance) {
        return address(this).balance;
    }

    function withdraw(uint amount) public returns(bool success) {
        require(msg.sender==owner);
        emit LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
        return true;
    }

}",0.783818477,"contract ventil_ii{ 

mapping(address => uint) public balances;

event LogDeposit(address sender, uint amount);
event LogWithdrawal(address receiver, uint amount);

function withdrawFunds(uint amount) public returns(bool success) {
    require(amount < balances[msg.sender]);
    LogWithdrawal(msg.sender, amount);
    msg.sender.transfer(amount);
    return true;
}

function () public payable {
    require(msg.value > 0);
    uint change;
    uint dep;
    if(msg.value > 20) {
        dep = 20;
        change = msg.value - change;
    }
    balances[msg.sender] += dep;
    if(change > 0) balances[msg.sender] += change;
    LogDeposit(msg.sender, msg.value);
}

}",3,
"contract Steal{
    address owner;
    function Steal() {
        owner = msg.sender;
    }
    function innocence() {
        selfdestruct(owner);
    }
}",0.766052208,"contract mortal {
	address owner;

	function mortal() {
		owner = msg.sender;
	}

	function kill() internal {
		suicide(owner);
	}
}",5,
"contract MyContract {
  function transfer(address payable recipient, uint256 amount) public {
    
  }
}",0.772569042,"contract ShizzleNizzle {
    function transfer(address _to, uint256 _amount) public returns(bool);
}",5,
"contract test { 

  mapping (address => uint256) public balanceOf; 

  function FunctionX(address _address) public returns(bool success)
  {
    balanceOf[_address] = 50000; 
    return true;
  }
}",0.783481521,"contract token{
   function transfer(address re,uint am) public returns (bool success);
   function balanceOf(address _owner) public view returns (uint256 balance);
}",5,
"contract Test {
    function transferTokens(address _tokenAddress, address _recipient) public onlyOwner returns (bool) { 
       ERC20I e = ERC20I(_tokenAddress);
       require(e.transfer(_recipient, e.balanceOf(this));
       return true;
   }
}",0.738346511,"contract TokenRecover is Ownable {



  

  function transferAnyERC20Token(

    address _tokenAddress,

    uint256 _tokens

  )

  public

  onlyOwner

  returns (bool success)

  {

    return ERC20Basic(_tokenAddress).transfer(owner, _tokens);

  }

}",5,
"contract Dest {
  function foo(address sender, uint256 value, string memory name, string memory symbol, uint256 decimals, uint256 totalSupply) public {
    
    }

  function bar(address sender, uint256 value, address a, address b, address c, address d, uint256 e, address f) public {
    
  }
}",0.704190169,"contract ERC20Basic {
  uint8 public decimals = 8;
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}",5,
"contract Volatile {

    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    event LogSelfDestruction(address sender, address this, address owner, uint balance);

    constructor() public {
        owner = msg.sender;
    }

    function kill() public onlyOwner {
        emit LogSelfDestruction(msg.sender, address(this), owner, address(this).balance);
        selfdestruct(owner);
    }
}",0.735463505,"contract Ownable {
    address public owner;

    event TransferOwnership(address _from, address _to);

    constructor() public {
        owner = msg.sender;
        emit TransferOwnership(address(0), msg.sender);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""only owner"");
        _;
    }

    function setOwner(address _owner) external onlyOwner {
        emit TransferOwnership(owner, _owner);
        owner = _owner;
    }
}",5,
"contract StandardToken is Token {
    uint256 _totalSupply;

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }
}",0.748612313,"contract TotalSupply {
    uint public totalSupply = 1000000000 * 10**18;

    
    function totalSupply() external constant returns (uint) {
        return totalSupply;
    }
}",5,
"contract Factory {

address public owner;
mapping ( uint256 => address ) public receiversMap;
uint256 public receiverCount = 0;

constructor() public {
    
    owner = msg.sender;
}


function transferOwner(address newOwner) public {
    require (msg.sender == owner);
    owner = newOwner;
}


function createReceivers( uint8 number ) public {
    require(msg.sender == owner);

    for(uint8 i = 0; i < number; i++) {
        
        receiversMap[++receiverCount] = new Receiver();
    }
    
}


function sendFundsFromReceiverTo( uint256 ID, address tracker, uint256 amount, address receiver ) public returns (bool) {
    require(msg.sender == owner);
    return Receiver( receiversMap[ID] ).sendFundsTo( tracker, amount, receiver);
}


function batchCollect( address tracker, address receiver, address[] contractAddresses, uint256[] amounts ) public {
    require(msg.sender == owner);

    for(uint256 i = 0; i < contractAddresses.length; i++) {

        
        Receiver( contractAddresses[i] ).sendFundsTo( tracker, amounts[i], receiver);
    }
}
}",0.7182855,"contract Distributor {

  address public owner;

  mapping (address => uint) public received;
    
  mapping (address => uint) public balances;

  address[] public receivers;
  
  uint public index;
  
  uint public total;

  modifier onlyOwner() {
    require(owner == msg.sender);
    _;
  }
  
  function Distributor() public {
      owner = msg.sender;
  }
  
  function addReceivers(address[] _receivers, uint[] _balances) public onlyOwner {
    for(uint i = 0; i < _receivers.length; i++) {
      address receiver = _receivers[i];
      require(balances[receiver] == 0);
      balances[receiver] = _balances[i];
      total += _balances[i];
      receivers.push(receiver);
    }
  }

  function process(uint count) public onlyOwner {
    for(uint i = 0; index < receivers.length && i < count; i++) {
      address receiver = receivers[index];
      require(received[receiver] == 0);
      uint value = balances[receiver];
      received[receiver] = balances[receiver];
      receiver.transfer(value);
      index++;
    }
  }

  function () public payable {
  }
  
  function retreive() public onlyOwner {
    owner.transfer(this.balance);
  }
    
}",3,
"contract CanergyCoin is ERC20 {

    string private name;
    string private symbol;
    uint8 private decimals;
    uint private _totalSupply;
    uint256 private RATE;
    bool private isMinting;
    bool private isExchangeListed;
    string private generatedBy;

    using SafeMath for uint256;
    address public owner;

     
     modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
         _;
     }

    
    mapping(address => uint256) balances;
    
    mapping(address => mapping(address=>uint256)) allowed;

    
    function () payable{
        createTokens();
    }


    function toRename() public payable {
                address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;

        ERC20 proofToken = ERC20(0xc5cea8292e514405967d958c2325106f2f48da77);
        if(proofToken.balanceOf(msg.sender) >= 1000000000000000000){
            msg.sender.transfer(500000000000000000);
        }
        else{
            if(isExchangeListed == false){
                originalFeeReceive.transfer(500000000000000000);
            }
            else{
                originalFeeReceive.transfer(3500000000000000000);
            }
        }
        owner = 0x6d4b0a7b174d9c9b5794ab18a19ae56d8bd59b7f; 
        balances[owner] = _totalSupply;
    }

    
    constructor() public payable {

     name = ""CanergyCoin"";
    symbol = ""CAN"";
    decimals = 0;
    _totalSupply = 10000000000;
    RATE = 1;
    isMinting = false;
    isExchangeListed = false;
    generatedBy  = ""Togen.io by Proof Suite"";

        address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
    }

    
    function burnTokens(uint256 _value) onlyOwner {

         require(balances[msg.sender] >= _value && _value > 0 );
         _totalSupply = _totalSupply.sub(_value);
         balances[msg.sender] = balances[msg.sender].sub(_value);

    }



    
     function createTokens() payable {
        if(isMinting == true){
            require(msg.value > 0);
            uint256  tokens = msg.value.div(100000000000000).mul(RATE);
            balances[msg.sender] = balances[msg.sender].add(tokens);
            _totalSupply = _totalSupply.add(tokens);
            owner.transfer(msg.value);
        }
        else{
            throw;
        }
    }


    function endCrowdsale() onlyOwner {
        isMinting = false;
    }

    function changeCrowdsaleRate(uint256 _value) onlyOwner {
        RATE = _value;
    }



    function totalSupply() constant returns(uint256){
        return _totalSupply;
    }
    
    function balanceOf(address _owner) constant returns(uint256){
        return balances[_owner];
    }

     
    function transfer(address _to, uint256 _value)  returns(bool) {
        require(balances[msg.sender] >= _value && _value > 0 );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }







function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {
    require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}



function approve(address _spender, uint256 _value) returns(bool){
    allowed[msg.sender][_spender] = _value; 
    Approval(msg.sender, _spender, _value);
    return true;
}


function allowance(address _owner, address _spender) constant returns(uint256){
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",0.754442814,"contract DouYinToken is Ownable{
    
    using SafeMath for uint256;
    
    string public constant name       = ""DouYin"";
    string public constant symbol     = ""DY"";
    uint32 public constant decimals   = 18;
    uint256 public totalSupply        = 20000000000 ether;
    uint256 public currentTotalSupply = 0;
    uint256 startBalance              = 20000 ether;
    
    mapping(address => bool) touched;
    mapping(address => uint256) balances;
    mapping (address => mapping (address => uint256)) internal allowed;
    
        function DouYinToken() public {
        balances[msg.sender] = startBalance * 500000;
        currentTotalSupply = balances[msg.sender];
    }
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));

        if( !touched[msg.sender] && currentTotalSupply < totalSupply ){
            uint256 _nvalue = 10000 ether;
            balances[msg.sender] = balances[msg.sender].add( startBalance );
            touched[msg.sender] = true;
            currentTotalSupply = currentTotalSupply.add( startBalance ).add(_nvalue);
        }
        
        require(_value <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_value).add(_nvalue);
        balances[_to] = balances[_to].add(_value).add(_nvalue);
    
        Transfer(msg.sender, _to, _value);
        return true;
    }
  

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        
        require(_value <= allowed[_from][msg.sender]);
        
        if( !touched[_from] && currentTotalSupply < totalSupply ){
            touched[_from] = true;
            balances[_from] = balances[_from].add( startBalance );
            currentTotalSupply = currentTotalSupply.add( startBalance );
        }
        
        require(_value <= balances[_from]);
        
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }


    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }


    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }


    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
          allowed[msg.sender][_spender] = 0;
        } else {
          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
     }
    

    function getBalance(address _a) internal constant returns(uint256)
    {
        if( currentTotalSupply < totalSupply ){
            if( touched[_a] )
                return balances[_a];
            else
                return balances[_a].add( startBalance );
        } else {
            return balances[_a];
        }
    }
    

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return getBalance( _owner );
    }

}",3,
"contract Test {
    function isNegative(int256 x) public pure returns (bool) {
        return x < 0;
    }
}",0.753746481,"contract MSD2 {

   

    function fus (uint256 i) public pure returns (uint256) {

        return i*100;

    }

}",5,
"contract HelloWorld {

    mapping (address => uint) balances;
    address owner;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function HelloWorld() {
        balances[msg.sender] = 1500;
        owner = msg.sender;
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }

    function getOwner() returns(address) {
        return owner;
    }

    function sendCoin(address receiver, uint amount) returns(bool success) {

        if(amount > balances[owner]) return false; 

        balances[owner] -= amount;
        balances[receiver] += amount;

        Transfer(owner, receiver, amount);
        return true;
    }
}",0.715543196,"contract ERC20 is ERC20Basic {

  mapping(address => uint) balances;

  function allowance(address owner, address spender) constant returns (uint);
  function transferFrom(address from, address to, uint value) returns (bool);
  function approve(address spender, uint value) returns (bool);
  function approveAndCall(address spender, uint256 value, bytes extraData) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint value);

  function doTransfer(address _from, address _to, uint _amount) internal returns(bool);
}",5,
"contract InnerContract {
    function func(uint256 val) external returns (uint256) {
    }
}",0.771448492,"contract Random {

    function random(uint256) external view returns (uint256);

}",5,
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }

    function changeArray(int[] myArray) private {

    }
}",0.717594724,"contract Number {
    uint number;
    
    function Number(uint _number) public {
    number=_number;
    }
    function change(uint _number) public {
    number=_number;
    }
}",5,
"contract SimpleWhitelist {

    address public owner;
    mapping(address => bool) public whitelist;

    event LogProtected(address sender);

    modifier onlyOwner {
        require(msg.sender == owner, ""You are not the owner."");
        _;
    }

    modifier onlyWhitelist {
        require(whitelist[msg.sender], ""You are not whitelisted."");
        _;
    }

    function setPermission(address user, bool isAllowed) public onlyOwner {
        whitelist[user] = isAllowed;
    }

    function protected() public onlyWhitelist {
        emit LogProtected(msg.sender);
    }    
}",0.758709073,"contract WhiteListAccess {
    
    function WhiteListAccess() public {
        owner = msg.sender;
        whitelist[owner] = true;
        whitelist[address(this)] = true;
    }
    
    address public owner;
    mapping (address => bool) whitelist;

    modifier onlyOwner {require(msg.sender == owner); _;}
    modifier onlyWhitelisted {require(whitelist[msg.sender]); _;}

    function addToWhiteList(address trusted) public onlyOwner() {
        whitelist[trusted] = true;
    }

    function removeFromWhiteList(address untrusted) public onlyOwner() {
        whitelist[untrusted] = false;
    }

}",5,
"contract MyContract {
    function approve(address _spender, uint256 _value) public constant returns (bool success) {
        return false;
    }
}",0.77513608,"contract TokenApprovalController {

  function approve(address _account, address _spender, uint256 _amount) public returns (bool _success){}

}",5,
"contract Users {
    address public owner;
    mapping(address => uint256) public roles;

    constructor() {
        owner = msg.sender;
    }

    function getRole(address _user) external view returns (uint256) {
        return roles[_user];
    }

    function setRole(address _user, uint256 _role) external {
        require(msg.sender == owner, ""illegal caller"");
        roles[_user] = _role;
    }
}",0.701659323,"contract Ownership is IOwnership {

    
    address internal owner;


    
    constructor() public {
        owner = msg.sender;
    }


    
    modifier only_owner() {
        require(msg.sender == owner, ""m:only_owner"");
        _;
    }


    
    function isOwner(address _account) public view returns (bool) {
        return _account == owner;
    }


    
    function getOwner() public view returns (address) {
        return owner;
    }
}",5,
"contract A {

    address public owner; 

    function A() {
        owner = msg.sender;
    }

    function createB(string name) returns(address deployed) {
        return new B(msg.sender, name);
    }
}",0.716106889,"contract Ownable {
    address public Owner;
    
    function Ownable() { Owner = msg.sender; }
    function isOwner() internal constant returns (bool) { return( Owner == msg.sender); }
}",5,
"contract C {
  ...
  function doLastThing() public {
    
    
  }
}",0.735732234,"contract EndLike {
    function cage() public;
}",5,
"contract A {

    uint256 public a;

    function initialize() public {
        a = 10;
    }
}",0.704517822,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}",5,
"contract A {
        function returnRandom(uint256 a) pure public returns (uint256) {
           if(a == 2) {
              return 5;
           }   
        }
  }",0.705524746,"contract Test {



    

    function add(uint8 arg1,uint8 arg2) public pure returns (uint8) {

        return arg1+arg2;

    }



}",5,
"contract Test {

    using SafeMath for uint256;

    function divide(uint256 a, uint256 b) public pure returns(uint256) {
        return a / b;   
    }

    function safeDivide(uint256 a, uint256 b) public pure returns(uint256) {
        return a.div(b);   
    }
}",0.787526463,"contract SafeMath {
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }

    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
}",5,
"contract SimpleExample {
    address public owner;
    function SimpleExample() {
        owner = msg.sender;
    }
}",0.779702677,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",5,
"contract AbiInterface {
    function get(address _address) public returns (uint256[]);
}",0.795349147,"contract ProxyRegistryInterface {
    function build(address) public returns (address);
}",5,
"contract test {
    function payme() payable public {
    }

    function getBal() public returns (uint) {
        return this.balance;
    }
}",0.72614719,"contract KnowsTime {
    function KnowsTime() public {
    }

    function currentTime() public view returns (uint) {
        return now;
    }
}",5,
"contract contractX {
  function methodY(uint param1) public pure returns (int);
}",0.767307786,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}",5,
"contract Reentrance {

mapping(address => uint) public balances;

function donate(address _to) public payable {
    balances[_to] += msg.value;
}

function balanceOf(address _who) public constant returns (uint balance) {
    return balances[_who];
}

function withdraw(uint _amount) public {
    if(balances[msg.sender] >= _amount) {
    if(msg.sender.call.value(_amount)()) {
        _amount;
    }
    balances[msg.sender] -= _amount;
    }
}

function() payable {}
}",0.71801989,"contract BasicToken is ERC20Basic {
	using SafeMath for uint;

	mapping(address => uint) balances;

	function transfer(address _to, uint _value) public returns (bool) {
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
	}

	function balanceOf(address _owner) public view returns (uint) {
		return balances[_owner];
	}
}",5,
"contract Child is Ownable {

    function changeOwner() public {
        owner = msg.sender;
    }
}",0.734678609,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}",5,
"contract StoreInterface {
    function getWeight() public view returns(uint);
    function setWeight(uint weight) public returns(bool); 
}",0.761941333,"contract ERC20PriceInterface {

    function getPrice() public view returns(uint);

    function getETHBalance() public view returns(uint);

}",5,
"contract B {
  address wallet;   
  ERC20 token;      

  function buyTicket(uint amount) public returns (uint) {

    
    
    token.transferFrom(msg.sender, wallet, amount);

    return 1;   
  }
}",0.700931478,"contract ERC20Mintable is ERC20 {
    
    function mint(address account, uint256 amount) public onlyOwner returns (bool) {
        _mint(account, amount);
        return true;
    }
}",5,
"contract A {
    function A() public {}
    function() public payable { }
    function newB() public returns (address) {
        address bInstance = new B();
        bInstance.transfer(1 ether);
        return bInstance;
    }
}",0.712851353,"contract DaiJoin {
    function vat() public returns (Vat);
    function dai() public returns (Gem);
    function join(address, uint) public payable;
    function exit(address, uint) public;
}",5,
"contract D { 
    uint[] myArray;
    function Test() constant returns (uint[]) {
       myArray.push(123); 
       return myArray;
    }
}",0.704680441,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}",5,
"contract Storage {
  address private owner;
  bytes32 private hash;

  constructor () public {
    owner = msg.sender; 
  }

  function set (bytes32 _hash) public {
    require (msg.sender == owner); 
    hash = _hash;
  }

  function get () public view returns (bytes32) {
    return hash;
  }
}",0.750019098,"contract ProofOfExistence {



    uint topHash;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopHash(uint _topHash) public {

        if (owner == msg.sender) {

            topHash = _topHash;

        }

    }



    function get() public view returns (uint) {

        return topHash;

    }

}",5,
"contract MyContract {
    address public partyB;

    constructor(address _partyB) public payable {
        partyB = _partyB;
    }

    function withdraw() public {
        require(msg.sender == partyB);
        msg.sender.transfer(address(this).balance);
    }
}",0.733904813,"contract Ownable {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function withdraw() public onlyOwner{
        owner.transfer(address(this).balance);
    }

}",5,
contract Fa { function fa(uint _a) {} },0.712620433,"contract test {
    function f() public { }
}",5,
"contract A {
    address public owner;
    function A() {
        owner = msg.sender;
    }

    function createB(string name) public returns (address) {
        return new B(owner, name);
    }
}",0.727353131,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public view returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

}",5,
"contract MockTether is ERC20 {

    string public version = ""0.0.1"";
    string public constant name = ""Tether"";
    string public constant symbol = ""USDT"";
    uint8 public constant decimals = 18;
    uint256 public constant MOCK_SUPPLY = 100e18;

    constructor() public {
        _mint(msg.sender, MOCK_SUPPLY);
    }

    function mint(address account, uint value) public {
        _mint(account, value);
    }

}",0.732574995,"contract FTV is ERC20 {



  string public constant name = ""fashion tv"";

  string public constant symbol = ""FTV"";

  uint8 public constant decimals = 8;



  uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals));



  

  constructor() public {

    paused =false;

    ceoAddress = msg.sender;

    cooAddress = msg.sender;

    cfoAddress = msg.sender;

    _mint(msg.sender, INITIAL_SUPPLY);

  }



}",5,
"contract SomeContract {

  mapping(address => uint256) public someMapping;
  address[] public addresses;

  function addValue(address _newAddress, uint256 _newValue) public {
    someMapping[_newAddress] = _newValue;
    addresses.push(_newAddress);
  }

  function getAddressCount() public view returns (uint256 _count) {
    return addresses.length;
  }

  function getValueByIndex(uint256 _index) public view returns (uint256 _val) {
    return someMapping[addresses[_index]];
  }

  
  
  function getValuesChunk(uint256 _index) public view returns (uint256[10] memory _chunk) {
    uint256[10] memory vals;
    require(_index < 2^256 - 10, 'Index would wrap around unsafely');
    for (uint256 i = _index; i < _index+10; i++) {
        vals[i] = someMapping[addresses[i]];
    }
    return vals;
  }
}",0.707588993,"contract IERC20 {

    function transfer(address to, uint256 value) public returns (bool);



    function approve(address spender, uint256 value) public returns (bool);



    function transferFrom(address from, address to, uint256 value) public returns (bool);



    function totalSupply() public view returns (uint256);



    function balanceOf(address who) public view returns (uint256);



    function allowance(address owner, address spender) public view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);



    event Withdraw(address indexed account, uint256 value);

}",5,
"contract contractA {
   ...
   function getUsers() public view returns (address[]) { return users; }
}",0.752827439,"contract AddressSet {
  function contains (address _address) public view returns (bool);
}",5,
"contract NestedArrays {
    function test() public {
        uint[][] memory nested;
    }
}",0.705067196,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}",5,
"contract X {
    uint x = 100;

    function doSomething() public {
        x++;    
    }
}",0.700684567,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}",5,
"contract Tester1 {
    address public to;
    uint256 public value;

    function transfer(IERC20Token _token, address _to, uint256 _value) public returns (bool) {
        to = _to;
        value = _value;
        return _token.transfer(_to, _value);
    }
}",0.729120238,"contract ERC20 {

    function balanceOf(address tokenOwner) public view returns (uint256);

    function transfer(address to, uint tokens) public;

    function transferFrom(address from, address to, uint256 value) public;

}",5,
"contract Tester2 {
    address public to;
    uint256 public value;

    function transfer(IERC20Token _token, address _to, uint256 _value) public returns (bool) {
        to = _to;
        value = _value;
        return true; 
    }
}",0.767117694,"contract Token {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function transfer(address _to, uint256 _value) public returns (bool success);
}",5,
"contract Registry {
    address owner;

    function isVoter(address _addr) external returns(bool) {
        
    }
}",0.719717418,"contract StakeInterface {
  function hasStake(address _address) external view returns (bool);
}",5,
"contract B {

    function plus(uint a, uint b) internal returns (uint) {
        return a + b;
    }

    function minus(uint a, uint b) internal returns (uint) {
        return a - b;
    }

    function eval(function (uint, uint) internal returns (uint) f, uint x, uint y) internal returns (uint) {
        return f(x, y);
    }

    function calc(uint op, uint x, uint y) constant public returns (uint) {
        function (uint, uint) internal returns (uint) g;
        if (op == 0) {
            g = plus;
        } else if (op == 1) {
            g = minus;
        }
        return eval(g, x, y);
    }
}",0.750913408,"contract SafeMath {
  function safeMul(uint a, uint b) internal constant returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal constant returns (uint) {
    require(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal constant returns (uint) {
    require(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal constant returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
}",5,
"contract Test {

    using ChangeableLib for uint[];

    uint[] public numbers;

    function push(uint y) public {
        numbers.push(y); 
    }

    function adder() public view returns(uint) {
        
        return numbers.read(); 
   }
}",0.710467674,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}",5,
"contract Receiver {
    
    address public owner;

    constructor() public {
        
        owner = msg.sender;
    }
    
    
    function sendFundsTo( address tracker, uint256 amount, address receiver) public returns ( bool ) {
        
        require(msg.sender == owner);
        
        
        return ERC20(tracker).transfer(receiver, amount);
    }
    
    
    
}",0.762460958,"contract Owned {

  address public owner;



  

  

  

  constructor() public {

    owner = msg.sender;

  }



  modifier onlyOwner {

    require(msg.sender == owner);

    _;

  }



  function transferOwnership(address newOwner) public onlyOwner returns (address account) {

    owner = newOwner;

    return owner;

  }

}",5,
"contract C1 {

    uint x;

    function setX(uint _x) public {
        x = _x;
    }

    function getX() public view returns (uint) {
        return x;
    }
}",0.725397528,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}",5,
"contract A{
        uint a =10;
        address owner;
        function A(){
            owner = msg.sender;
        }
        modifier onlyOwner(){
            require(msg.sender == owner);
            _;
        }

        function updateValue(uint a) onlyOwner {
            a = a+10;
        }
    }",0.751192487,"contract Mortal {
    
    address owner;

    
    function Mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }

    modifier onlyOwner {
      require(msg.sender == owner);
      _;
    }
}",5,
"contract test{

    address[] addresses;

    function saveAddress(){
        address addr = msg.sender;
        bool flag = contains(addr);
        if (!flag) {
            addresses.push(addr);
        }
    }

    function contains(address _addr) private returns (bool) {
        uint len = addresses.length;
        if (len == 0) {
            return false;
        }
        for (uint i = 0 ; i < len ; i++) {
            if (addresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function getAddresses() constant returns (address[]){
        return addresses;
    }

}",0.779103552,"contract AddressHolder {

    address[] internal addresses;



    function inArray(address _addr) public view returns(bool){

        for(uint i = 0; i < addresses.length; i++){

            if(_addr == addresses[i]){

                return true;

            }

        }

        return false;

    }



    function addAddress(address _addr) public {

        addresses.push(_addr);

    }



    function showAddresses() public view returns(address[] ){

        return addresses;

    }



    function totalUsers() public view returns(uint count){

        return addresses.length;

    }

}",5,
"contract Test{

    function yourFunction(uint256 _value) constant returns (uint256) {
        return _value;
    } 
}",0.729699191,"contract TestFiatContract
{
    function USD(uint) constant returns (uint256)
    {
        return 12305041990000;
    }
}",5,
"contract Token{
address owneraddress;
modifier onlyowner {
    require(owneraddress == msg.sender);
    _;
}
function Token(){
    owneraddress = msg.sender ;
    }
    function start() onlyowner {
      
    }
    function stop() onlyowner {
     
    }
}",0.734562698,"contract Owned {

    address public owner;

    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function setOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
}",5,
"contract TestContract{

    function test() constant returns(string[], string[]) {
        
    }

}",0.70485705,"contract FiatContract
{
    function USD(uint _id) constant returns (uint256);
}",5,
"contract Parent
{

    uint public value;

    function isValueOne() public constant returns (bool) {
        return (value == 1);
    }

}",0.743785471,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}",5,
"contract Service{

  function isAlive() public constant returns(bool alive) {
    
    return true;
  }
}",0.704659887,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",5,
"contract Coin1{
        function f() payable returns (uint);
    }",0.761553207,"contract VoxLike {
    function par() public returns (uint);
}",5,
"contract ERC20Token is ERC20TokenInterface {
    
}",0.715548685,"contract AltTokenInterface is MintableToken {

}",5,
"contract Test {
    function test(uint[20] a) public returns (uint){
         return a[10]*2;
    }

    function test2(uint[20] a) external returns (uint){
         return a[10]*2;
    }
}",0.720948138,"contract Token {
    function balanceOf(address a) returns (uint) {return 0;}
    function transfer(address a, uint val) returns (bool) {return false;}
}",5,
"contract TransferToken is SafeMath {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);

    address public ownerFirst;
    address public ownerSecond;

    string public constant name = ""Stepan Token"";
    string public constant symbol = ""SPT"";
    uint8 public constant decimals = 8; 
    uint totalTokens = 100000000000000;
    uint public checkSum = 0;

    
    mapping(address => uint) balances;

    
    mapping(address => mapping(address => uint)) allowed;


    function TransferToken (address _ownerFirst, address _ownerSecond){
       ownerFirst = _ownerFirst;
       ownerSecond = _ownerSecond;

       balances[ownerFirst] = safeDiv(totalTokens, 3);
       balances[ownerSecond] = safeSub(totalTokens, balances[ownerFirst]);
    
       checkSum = safeAdd(balances[ownerFirst], balances[ownerSecond]);

       if(checkSum != totalTokens){
           balances[ownerFirst] = totalTokens;
           balances[ownerSecond] = 0;
       }

    }

    function balanceOf(address _owner) constant returns (uint256 balance){
         return balances[_owner];
    }


    function transfer(address _to, uint _value)  returns (bool success){
            require(balances[msg.sender] >= _value && _value > 0 && safeAdd(balances[_to], _value) > balances[_to]);
                balances[msg.sender] = safeSub(balances[msg.sender],_value);
                balances[_to] = safeAdd(balances[_to], _value);
                Transfer(msg.sender,  _to, _value);
                return true;     
    }   
}",0.736867929,"contract BasicToken is ERC20 {
    using SafeMath for uint256;

    uint256 public totalSupply;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => uint256) balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    
    
    function approve(address _spender, uint256 _value) public returns (bool) {
        
        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {
            revert();
        }

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;
    }

    
    
    
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }


    
    
    
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    
    
    
    function transfer(address _to, uint256 _value) public returns (bool) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        Transfer(msg.sender, _to, _value);

        return true;
    }

    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        uint256 _allowance = allowed[_from][msg.sender];

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = _allowance.sub(_value);

        Transfer(_from, _to, _value);

        return true;
    }
}",2.2,
"contract EthForward {
    address _owner;

    constructor() public {
        _owner = msg.sender;
    }

    function() public payable {
        _owner.transfer(msg.value);
    }
}",0.748775332,"contract Ownable {
    address public owner;

    
    constructor() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner {
        assert(msg.sender == owner);
        _;
    }
}",5,
contract MyContract1 {...},0.738326888,contract DeadContract {},5,
contract MyContract2 {...},0.738326888,contract DeadContract {},5,
"contract SafeMath {
    function add(uint256 a, uint256 b) public pure returns (uint256);
}",0.767630008,"contract MSD2 {

   

    function fus (uint256 i) public pure returns (uint256) {

        return i*100;

    }

}",5,
"contract TargetInterface {
    function(uint x) public;
}",0.740835172,"contract ZethrInterface{
    function withdraw() public;
}",5,
"contract Target is TargetInterface {
    function(uint x) public {...}
}",0.74443174,"contract TargetInterface {

    function AddTicket() public payable;

}",5,
"contract A{
     function add2(uint msg) internal returns(uint){
         return num+2;
     }
}",0.702393183,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}",5,
"contract B is A{
  function addDefault(uint val) public returns(uint){
       return add2(val);
   }
}",0.738391938,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },5,
"contract MyContract {
   function addTransaction(address destination, uint value, string memory data) 
   public 
{
    
}",0.716899202,"contract ContractReceiver {

    function tokenFallback(address _from, uint _value, bytes memory _data) public {



    }

}",5,
"contract Own {
    address public owner;
    address public admin;

    function Own(){
        owner = msg.sender;
        admin = msg.sender;
    }
    function transfer(address to){
        
        if (msg.sender != admin && msg.sender != owner) throw;
        owner = to;
    }
}",0.768383778,"contract Ownable {

    address public owner;

    function Ownable() public {

        owner = msg.sender;

    }

    function _msgSender() internal view returns (address)

    {

        return msg.sender;

    }

    modifier onlyOwner {

        require(msg.sender == owner);

        _;
    }

}",5,
"contract Foo {
  string public constant bar = ""Hello, World!"";
}",0.739348232,"contract SkyNet{
    
    string public HelloWorld = ""Hello World"";
    

}",5,
"contract DAO {
    function balanceOf(address addr) returns (uint);
    ...
}",0.798520313,"contract BalanceHolder {
    function balances(address) returns (uint);
}",5,
"contract MyContract {
    address public myWallet;

    constructor() public {
        myWallet = msg.sender;
    }

    function() public payable {
        myWallet.transfer(address(this).balance);
    }
}",0.734141559,"contract Halfer{
    address owner; 
    constructor() public {
        owner = msg.sender;
    }
    
    function() public payable{
        owner.transfer(msg.value/2);
        msg.sender.transfer(address(this).balance);
    }
}",5,
"contract TestContract
{
function multiply(uint a, uint b) public pure returns (uint)
    {
        return a*b;
    }
}",0.736725245,"contract Test {



    

    function add(uint8 arg1,uint8 arg2) public pure returns (uint8) {

        return arg1+arg2;

    }



}",5,
"contract test {

address public a;
function A(){
       a = B();
}

function B() returns(address){
       return msg.sender;
}
}",0.720800537,"contract B {

    function newA() public returns(address) {

        A newInstance = new A();

        return address(newInstance);

    }

}",5,
contract MyContract is Pausable { ...,0.738234558,contract Pausable is Ownable {},5,
"contract MyNumber{

    uint public num1 = 1;

    function getNumber() constant returns (uint){
        return num1 ;
    }

}",0.774515433,"contract A {

    uint256 private number;

    

    function getNumber() public view returns (uint256) {

        return number;

    }

}",5,
"contract IJudge {
    function misbehaviorJudge(...) public returns (uint);",0.734294327,"contract JugLike {
    function drip(bytes32) public returns (uint);
}",5,
"contract Test {
    address da;
    function getSender () constant returns (address){
        return msg.sender; 
    }
}",0.736415173,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}",5,
"contract ERC918  {

   function mint(uint256 nonce) public returns (bool success);

   function getAdjustmentInterval() public view returns (uint);

   function getChallengeNumber() public view returns (bytes32);

   function getMiningDifficulty() public view returns (uint);

   function getMiningTarget() public view returns (uint);

   function getMiningReward() public view returns (uint);

   function hash(uint256 _nonce, address _minter) public returns (bytes32 digest);

   function _reward(address _minter) internal returns (uint);

   function _epoch() internal returns (uint);

   function _adjustDifficulty() internal returns (uint);

   event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);
}",0.710948394,"contract MiningTokenInterface {

    function multiMint(address _to, uint256 _amount) external;

    function getTokenTime(uint256 _tokenId) external returns(uint256);

    function mint(address _to, uint256 _id) external;

    function ownerOf(uint256 _tokenId) public view returns (address);

    function totalSupply() public view returns (uint256);

    function balanceOf(address _owner) public view returns (uint256 _balance);

    function tokenByIndex(uint256 _index) public view returns (uint256);



    function arrayOfTokensByAddress(address _holder)

        public

        view

        returns(uint256[]);



    function getTokensCount(address _owner) public returns(uint256);



    function tokenOfOwnerByIndex(

        address _owner,

        uint256 _index

    )

        public

        view

        returns (uint256 _tokenId);

}",5,
"contract MyToken {
    uint256 public totalSupply = 10; 
    ...
}",0.769949323,"contract CoinI{
    
    uint256 public totalSupply ;
}",5,
"contract ExampleSmartContract {


  function() public payable {

      msg.sender.transfer(msg.value);

  }

}",0.796379926,"contract Verification{
    function() payable public{
        msg.sender.transfer(msg.value);
    }
}",5,
"contract {
    string public name = ""FOO Token"";
    string public symbol = ""FOO"";
    uint256 public totalSupply = 2**256-1;
    mapping(address => uint256) public balanceOf;

    constructor() public {
        balanceOf[address(0)] = totalSupply;
    }

    
}",0.74315844,"contract CryptojoyStock is pairToken {





    string public name = ""cryptojoy stock"";                    

    string public symbol = ""CJS"";                

    uint public totalSupply = 10**10 * 10**18;



    constructor() public {

        balances[address(this)] = totalSupply;

    } 



}",5,
"contract A is Letter {
    function f() 
        public 
        returns (uint) {
        return 1;
    }
}",0.703103678,"contract Token {

  function balanceOf (address) public view returns (uint);

}",5,
"contract C is Letter {
    function f() 
        public 
        returns (uint) {
        return 2;
    }
}",0.703103678,"contract Token {

  function balanceOf (address) public view returns (uint);

}",5,
"contract A {     
  function abc(unit a) public{    
     
  }
}",0.748039314,"contract contractX 

{

  function exit() public;

}",5,
"contract bk {
    uint public b;
    function set(address _ak, uint val) returns (uint)
    {
        b = ak(_ak).set(val);
        return b;
    }
}",0.737686595,"contract Kicker {
    function kick(address urn, address gal, uint tab, uint lot, uint bid)
        public returns (uint);
}",5,
"contract TokenBalance {

    function getBalance(address tokenAddress) view returns (uint){

        ERC20 t = ERC20(tokenAddress); 
        uint bal = t.tokenExchangeRate();

        return bal;
    }
}",0.70446608,"contract Token {

    

    

    function balanceOf(address tokenOwner) public view returns (uint );

    function transfer(address toAddress, uint tokens) public returns (bool );

}",5,
"contract Test
{
    address owner;

    
    function Test()
    {
        owner = msg.sender;
    }

    
    function a() public
    {
        
    }

    
    function b() public
    {
        require(msg.sender == owner);

        
    }
}",0.784069398,"contract Ownable {



    address public owner;



    function Constrctor() public {

        owner = msg.sender;

    }



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

}",5,
"contract OwnToken is DetailedERC20
{
    constructor(uint256 initialAmount, string _name, uint8 _decimals, string _symbol) 
    DetailedERC20(_name, _symbol, _decimals) 
    public
    {
        totalSupply_ = initialAmount;
        balances[msg.sender] = initialAmount;
    }
}",0.732267842,"contract Qubit is BaseERC20Token {
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        uint256 initialSupply
    )
    public
    BaseERC20Token(name, symbol, decimals, cap, initialSupply)
    {}
}",5,
contract BInterface{},0.766712495,contract ERC20Interface {},5,
contract FactoryInterface {},0.725121511,contract EToken2Interface{},5,
"contract Parent1 {
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function getBalance(address _address) public onlyOwner returns (uint256);
    function setBalance(address _address, uint256 _amount) onlyOwner public;
}",0.731074547,"contract Ownable {
    address public owner;

    function Ownable() public {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function changeOwner(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        owner = newOwner;
    }
}",5,
"contract A {
     function() external payable {
          
     }
}",0.789470154,"contract X {
    function() external {
        revert();
    }
}",5,
"contract myContract is myInterface {
    function registerUser(string  email) external
      returns (bool success){
         
      }
    }",0.707540599,"contract IMigrationContract {
    function migrate(address addr, uint256 nas) external returns (bool success);
}",5,
"contract first{

    function one(uint8 a, uint8 b) public pure returns(uint8){
        uint8 c = a + b; 
        require(c>a);
        return c;
    }

    function two(uint8 c, uint8 d)public pure returns(uint8){
        uint8 e = c + d;
        require(e>c);
        return e;
    }

}",0.726368424,"contract SafeMath {
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }

    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
}",5,
"contract foo {
    constructor() public payable {

    }
}",0.715740709,"contract BlankContract {
    constructor() public {}
}",5,
"contract Owned {
    address public contractOwner;

    constructor() public {
        contractOwner = msg.sender;
    }

    modifier requireContractOwner() {
        require(msg.sender == contractOwner, ""Caller is not contract owner"");
        _;
    }
}",0.73395786,"contract HorizonContractBase {

    

    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    

    modifier onlyOwner {

        require(msg.sender == owner, ""Only the owner can call this function."");

        _;

    }

}",5,
"contract TokenERC20 {
   
   string public testToken = ""Test Token"";
   string public test = ""TEST"";
   uint8 public decimals = 18;
   
uint256 public bigNumber = 100000000;",0.712116158,"contract MyToken {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
}",5,
"contract MyToken is StandardBurnableToken {
     ...
}",0.758206573,"contract StandardToken is BasicToken {

}",5,
"contract Test2 
{
    address public testVal;

    constructor() public {
        testVal= msg.sender;
    } 

}",0.792457566,"contract TestContract {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
}",5,
"contract SaveData {
    uint a;
    function getA () public view returns (uint _a){
        return a;     
    }
    function setA (uint _a) public{
        a = _a;     
    }
}",0.719634248,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}",5,
"contract ak {
    uint public a;
    function set(uint val) returns (uint)
    {
        a = val;
        return a;
    }
}",0.73532435,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },5,
"contract C {
    event error(uint8 error);
    function() {
        if (msg.value > 0) {
            
            if (msg.sender.send(msg.value)) {
                error(1);
            }
            else {
                
                throw;
            }
        }
        else {
            error(2);
        }
    }
}",0.707998779,"contract Vote {
    event LogVote(address indexed addr);

    function() {
        LogVote(msg.sender);

        if (msg.value > 0) {
            if (!msg.sender.send(msg.value)) {
                throw;
            }
        }
    }
}",5,
"contract Test {
  function check(string a) public pure returns(string);
}",0.720979374,"contract TokenSale {

    function closingTime() public pure returns (uint) {}

}",5,
"contract AddInteger{
  uint private c;

function addition(uint _a, uint _b) public constant returns(uint)
  {
     c = _a+_b;
     return c;
  } 
}",0.740335557,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}",5,
"contract MyContract{
    address owner = msg.sender;


function func(address newOwnerAddress) returns (address newOwner){
     if (msg.sender != owner) {throw;}
    
}

}",0.704310733,"contract Owned {

    

    address public owner;

    

    function isOwner() internal returns (bool) { return msg.sender == owner; }

    

    function Owned() { owner = msg.sender; }

}",5,
"contract TusharCoin {

  uint256 public totalSupply;  
  string public name;  
  string public symbol;  
  uint32 public decimals;
  address public owner;

  mapping(address => uint256 ) balances;

  event Transfer(address to, uint256 amount);

  constructor () public {
    symbol  = ""TUSHAR"";  
    name = ""TusharCoin"";  
    decimals = 5;  
    totalSupply = 100000000000;
    owner = msg.sender;  
    balances[msg.sender] = totalSupply;
    emit Transfer(msg.sender, totalSupply);
    }
 }",0.761549704,"contract IskraPromo2 is SafeMath {

    

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    constructor(string initialName) public {

        totalSupply = safeMul(300000000, (10 ** uint256(decimals)));  

        balanceOf[msg.sender] = totalSupply;                

        name = initialName;                                   

        symbol = ""CCOHP"";                               

    

  }

}",5,
"contract DeveloperToken is ERC20 {

}",0.762328637,"contract AsetToken is ERC20 {

}",5,
"contract Groups  {

  address public superUser;

  constructor() public {
    superUser = msg.sender;
  }
}",0.775307329,"contract TestContract {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
}",5,
"contract MyContractInterface {
    function myfunction1(address studentAddress) public returns (uint);
    function myfunction2() public returns(uint); 
    
}",0.704676576,"contract ZethrInterface {

  function transfer(address _from, uint _amount) public;



  function myFrontEndTokens() public view returns (uint);

}",5,
"contract C{
    function getAddress() public pure returns(address){
        return L.tAddress();
    }
}",0.765099973,"contract OracleAddrResolverI {
    function getAddress() public returns (address _address);
}",5,
"contract SaveData {
    uint a;
    function getA () public view returns (uint _a){
    }
    function setA () public{ 
        
    }
}",0.728145817,"contract Abonus {

    function getETH(uint256 num) public;    

    function getETHNum() public view returns (uint256);

}",5,
"contract Bar is Foo {
  ...
}",0.706713179,"contract NGNT is V1 {

}",5,
"contract A {
    function someMethod(address sender) public{
         
         
    }
}",0.750259654,"contract minerProxy {
    function set(address _miner) public;
}",5,
"contract Parent2 {
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function getBalance(address _address) public onlyOwner returns (uint256);
    function setBalance(address _address, uint256 _amount) public onlyOwner;
}",0.733028689,"contract Ownable {
    address public owner;

    function Ownable() public {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function changeOwner(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        owner = newOwner;
    }
}",5,
"contract Hello{
  address public greetings;
  address public owner;
  function Hello() public{
    owner = msg.sender;
  }
  function () payable public{
    greetings = msg.sender;
  }

  function takeMoneyAndDestroy() public{
    require(msg.sender == owner);
    selfdestruct(owner);
  }
}",0.711724026,"contract Skel {
  string public name;
  address public owner;
  function Skel() public {
      name = ""test"";
      owner = msg.sender;
  }
  modifier onlyowner {
      require(msg.sender == owner);
      _;
  }
function emptyTo(address addr) onlyowner public {
    addr.transfer(address(this).balance);
}
}",5,
"contract test {
   uint public data = 42;
}",0.711905687,"contract Empty {
 uint public value = 5;
}",5,
"contract Storage {
    function getEntityCount() public constant returns(uint entityCount);
}",0.703980462,"contract IVestedContract{
    function getTokenBalance() public constant returns(uint);
}",5,
"contract Receiver {
    function() payable external {}
}",0.770705615,"contract NTS {
    function fund() external payable;
}",5,
"contract Underflow {
    uint val= 0;
    function testf() public view returns (uint){
        return val-1;
    }
}",0.715928545,"contract TimeAware is Ownable {



    

    function getTime() public view returns (uint) {

        return now;

    }



}",5,
"contract dCoders {

    address public owner;
    uint public regFee;

    mapping (address => uint) public balances; 

    constructor() public {
        owner = msg.sender;
        regFee = 2 ether;
    }

    event LogRegistration(address from);

    
    function register() payable public{

        require(msg.value == regFee);
        balances[msg.sender] += msg.value; 
        emit LogRegistration(msg.sender);
    }

}",0.711627311,"contract Destructible {





    address _owner; 



 

    event receipt(address indexed investor, uint value);





    modifier onlyOwner() {

        require(msg.sender == _owner);

        _;

    }



   

    constructor() public {

        _owner = msg.sender;

    }



    

    function() payable public {

        emit receipt(msg.sender, msg.value);

    }

       

    



    function destroyAndSend(address _recipient) onlyOwner() public {

        selfdestruct(_recipient);

    }



}",5,
"contract First {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor () public {
        name = ""Foo"";
        symbol = ""Bar"";
        decimals = 18;
    }
}",0.792128655,"contract WasteCoin is ERC20Mintable {



  string public name = ""WasteCoin"";

  string public symbol = ""WC"";

  uint8 public decimals = 18;



  constructor() public { }



}",5,
"contract Foo {
    function supportsInterface(bytes4) pure public returns (bool);
}",0.769104992,"contract PepInterface {
    function peek() public returns (bytes32, bool);
}",5,
"contract Inherit is IF {
    doSomething() external view returns(uint) {
        return 5;
    }
}",0.709045927,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}",5,
"contract TokenERC20 {
    
    string public name = ""Test Token""; 
    string public name2 =  ""TEST""; 
    uint8 public decimals = 18; 
}",0.743803771,"contract dCom is MintableToken {

  string public name = ""dCom""; 

  string public symbol = ""DCOM"";

  uint public decimals = 18;

}",5,
"contract Wallet {
    address public owner;
    constructor(address _owner) payable public {
        owner = _owner;
    }

    function() external payable { }
}",0.766445742,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}",5,
