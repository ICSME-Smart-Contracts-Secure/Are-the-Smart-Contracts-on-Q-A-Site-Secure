sni,bleu,code,check,wonder
"contract Tested1 {
    function func() public pure returns (bool) {
        return true;
    }
}",0.80675337,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",1,
"contract auction {
  address highestBidder;
  uint highestBid;
  mapping(address => uint) refunds;
  function bid() {
    if (msg.value < highestBid) throw;
    if (highestBidder != 0)
      refunds[highestBidder] += highestBid;
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  function withdrawRefund() {
    uint refund = refunds[msg.sender];
    refunds[msg.sender] = 0;
    if (!msg.sender.send(refund))
     refunds[msg.sender] = refund;
  }
}",0.895334169,"contract auction {

    address highestBidder;

    uint highestBid;

    mapping(address => uint) refunds;



    function bid() payable external {

        require(msg.value >= highestBid);



        if (highestBidder != address(0)) {

            refunds[highestBidder] += highestBid; 

        }



        highestBidder = msg.sender;

        highestBid = msg.value;

    }



    function withdrawRefund() external {

        uint refund = refunds[msg.sender];

        refunds[msg.sender] = 0;

        msg.sender.transfer(refund);

    }

}",3,*
"contract MyTestToken is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    string public name;                   
    uint8 public decimals;              
    string public symbol;

    function MyTestToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                  
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

     function transfer(address _to, uint256 _value) public returns (bool success){
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
        allowed[_from][msg.sender] -= _value;
    }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) 
   {
    return balances[_owner];
   }

    function approve(address _spender, uint256 _value) public returns (bool success){
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
    }

    mapping(bytes32 => Child) childList;

    function spawnChild(bytes32 childId) {
    Child current = new Child();
    childList[childId] = current;
   }

    function callChildFunction(bytes32 childId) {
    childList[childId].theChildfunction();
   } 
 }",0.822392161,"contract LetoCoin{

    string public constant name = &#39;LetoCoin&#39;;
    string public constant symbol = &#39;LETO&#39;;
    uint8 public constant decimals = 10;
    uint256 public constant totalSupply = 8000000 * 10**uint256(decimals);
    
    mapping (address => uint256) private balances;
    mapping (address => mapping (address => uint256)) private allowed;
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function LetoCoin() public {
        balances[msg.sender] = totalSupply;
        Transfer(0x0, msg.sender, totalSupply);
    }
    
    function balanceOf(address _owner) constant public returns (uint256 balance){
        return balances[_owner];
    }
    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        if (_value != 0){
            require(balances[msg.sender] >= _value);
            require(balances[_to] + _value > balances[_to]);
            balances[msg.sender] -= _value;
            balances[_to] += _value;
        }
        Transfer(msg.sender, _to, _value); 
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        if (_value != 0){
            require(allowed[_from][msg.sender] >= _value);
            require(balances[_from] >= _value);
            require(balances[_to] + _value > balances[_to]);
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            balances[_to] += _value;
        }
        Transfer(_from, _to, _value); 
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success){
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
    
    function () public payable {
        revert();
    }
    
}",3,*
"contract StandardToken is ERC20 {
  using SafeMath for uint;

    string internal _name;
    string internal _symbol;
    uint8 internal _decimals;
    uint256 internal __totalSupply;

    mapping (address => uint256) internal balances;
    mapping (address => mapping (address => uint256)) internal allowed;

    constructor(string name, string symbol, uint8 decimals, uint256 totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        __totalSupply = totalSupply;
        balances[msg.sender] = totalSupply;
    }

    function name()
        public
        view
        returns (string) {
        return _name;
    }

    function symbol()
        public
        view
        returns (string) {
        return _symbol;
    }

    function decimals()
        public
        view
        returns (uint8) {
        return _decimals;
    }

   function transfer(address _to, uint256 _value) public returns (bool) {
     require(_to != address(0));
     require(_value <= balances[msg.sender]);
     balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     Transfer(msg.sender, _to, _value);
     return true;
   }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
   }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
     require(_value <= balances[_from]);
     require(_value <= allowed[_from][msg.sender]);

    balances[_from] = SafeMath.sub(balances[_from], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
    Transfer(_from, _to, _value);
     return true;
   }

   function approve(address _spender, uint256 _value) public returns (bool) {
     allowed[msg.sender][_spender] = _value;
     Approval(msg.sender, _spender, _value);
     return true;
   }

  function allowance(address _owner, address _spender) public view returns (uint256) {
     return allowed[_owner][_spender];
   }

   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
     allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
     uint oldValue = allowed[msg.sender][_spender];
     if (_subtractedValue > oldValue) {
       allowed[msg.sender][_spender] = 0;
     } else {
       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);
    }
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }

}",0.888790088,"contract TokenERC20 {

	

    using SafeMath for uint256;

    

    string public constant name       = ""Bean fun"";

    string public constant symbol     = ""BEANF"";

    uint32 public constant decimals   = 18;

    uint256 public totalSupply;

    

    mapping(address => uint256) balances;

	mapping(address => mapping (address => uint256)) internal allowed;



	event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);



	

	function TokenERC20(

        uint256 initialSupply 

    ) public payable{

        totalSupply = initialSupply * 10 ** uint256(decimals);   

        balances[msg.sender] = totalSupply;  

        emit Transfer(this,msg.sender,totalSupply);

    }

	

    function totalSupply() public view returns (uint256) {

		return totalSupply;

	}	

	

	function transfer(address _to, uint256 _value) public returns (bool) {

		require(_to != address(0));

		require(_value <= balances[msg.sender]);

		balances[msg.sender] = balances[msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		emit Transfer(msg.sender, _to, _value);

		return true;

	}

	

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

		require(_to != address(0));

		require(_value <= balances[_from]);

		require(_value <= allowed[_from][msg.sender]);	

		balances[_from] = balances[_from].sub(_value);

		balances[_to] = balances[_to].add(_value);

		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

		emit Transfer(_from, _to, _value);

		return true;

	}





    function approve(address _spender, uint256 _value) public returns (bool) {

		allowed[msg.sender][_spender] = _value;

		emit Approval(msg.sender, _spender, _value);

		return true;

	}



    function allowance(address _owner, address _spender) public view returns (uint256) {

		return allowed[_owner][_spender];

	}



	function increaseApproval(address _spender, uint _addedValue) public returns (bool) {

		allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

		return true;

	}



	function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {

		uint oldValue = allowed[msg.sender][_spender];

		if (_subtractedValue > oldValue) {

			allowed[msg.sender][_spender] = 0;

		} else {

			allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

		}

		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

		return true;

	} 

	

    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }

 

}",3,*
"contract Transfer {

                address public owner;  
                mapping (address => uint) balances;

               
               function Transfer() {
                             owner=msg.sender;
                             balances[owner]=1000;
               }

               function transferToUser(address _to, uint _value) returns (bool success)  {

                 if(balances[msg.sender]< _value){
                     return false;
                  }

                  balances[msg.sender] -= _value;
                  balances[_to] += _value;
                  return true;
           }
          function getBalance(address _user) returns (uint _balance){
                  return balances[_user];
          }

     }",0.840255331,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  

  
  function transfer(address _to, uint _value) public returns (bool success) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
  
}",3,
"contract HelloWorld {  
    function greet() public pure returns (bytes32) {
        return bytes32('Hello World!');
    }
}",0.804192995,"contract HelloWorld{

    function Hello() public pure returns (string memory){

        return (""Hello World"");

    }

}",2,
"contract Hotelbooking {

  event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

 mapping(address => uint256) public balanceOf;


  


  function transfer(address _to, uint256 _value) public returns (bool success) {
          require(balanceOf[msg.sender] >= _value);

          balanceOf[msg.sender] -= _value;

          balanceOf[_to] += _value;

          Transfer(msg.sender, _to, _value);
            return true;

      }
    }",0.811268082,"contract wehome {

    

    mapping (address => uint256) public balanceOf;



    

    constructor(

        uint256 initialSupply

        ) public {

        balanceOf[msg.sender] = initialSupply;              

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);           

        require(balanceOf[_to] + _value >= balanceOf[_to]); 

        balanceOf[msg.sender] -= _value;                    

        balanceOf[_to] += _value;                           

        return true;

    }

}",3,
"contract ETHUSD is usingOraclize {

        string public priceETHUSD;

        event LogNewCoinBaseOraclizeQuery(string description);
        event LogNewCoinBaseTicker(string price);

        constructor() public {
            oraclize_setProof(proofType_Android | proofStorage_IPFS);
            update(); 
        }

        function __callback(bytes32 _myid, string memory _result, bytes memory _proof) public {
            require(msg.sender == oraclize_cbAddress());
            update(); 
            priceETHUSD = _result;
            emit LogNewCoinBaseTicker(priceETHUSD);
        }

        function update() public payable {
            if (oraclize_getPrice(""URL"") > address(this).balance) {
                emit LogNewCoinBaseOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee!"");
            } else {
                emit LogNewCoinBaseOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
                oraclize_query(5, ""URL"", ""json(https:
            }
        }
    }",0.802772463,"contract KrakenPriceTicker is usingOraclize {
    
    string public ETHXBT;
    
    event newOraclizeQuery(string description);
    event newKrakenPriceTicker(string price);
    
    modifier oraclizeAPI {
        oraclize = OraclizeI(0x6f28b146804dba2d6f944c03528a8fdbc673df2c);
        _;
    }

    function KrakenPriceTicker() {
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        newKrakenPriceTicker(ETHXBT);
        update();
    }
    
    function update() payable {
        if (oraclize.getPrice(""URL"") > this.balance) {
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(60, ""URL"", ""json(https:
        }
    }
    
}",2,
"contract M {
    uint256 storeddata;

    function set(uint256 x) public {
        storeddata = x;
    }

    function get() public view returns(uint256) {
        return storeddata; 
    }
}",0.826327577,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",2,
"contract MyToken {
    string public constant name = ""MyToken"";
    string public constant symbol = ""MYT"";
    uint8 public constant decimals = 0;
    uint public _totalSupply = 1000000;
    uint256 public RATE = 1;
    bool public isMinting = false;
    string public constant generatedBy  = ""Togen.io by Proof Suite"";

    using SafeMath for uint256;
    address public owner;

    
    modifier onlyOwner() {
        if(msg.sender != owner) {
            throw;
        }
        _;
    }

    
    mapping(address => uint256) balances;
    
    mapping(address => mapping(address=>uint256)) allowed;

    
    function () payable {
        createTokens();
    }

    
    constructor() public {
        owner = msg.sender; 
        balances[owner] = _totalSupply;
    }

    
    function burnTokens(uint256 _value) onlyOwner {
        require(balances[msg.sender] >= _value && _value > 0);
        _totalSupply = _totalSupply.sub(_value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
    }

    
    function createTokens() payable {
        if(isMinting == true) {
            require(msg.value > 0);
            uint256  tokens = msg.value.div(100000000000000).mul(RATE);
            balances[msg.sender] = balances[msg.sender].add(tokens);
            _totalSupply = _totalSupply.add(tokens);
            owner.transfer(msg.value);
        }
        else {
            throw;
        }
    }

    function endCrowdsale() onlyOwner {
        isMinting = false;
    }

    function changeCrowdsaleRate(uint256 _value) onlyOwner {
        RATE = _value;
    }

    function totalSupply() constant returns(uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address _owner) constant returns(uint256) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _value) returns(bool) {
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {
        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    
    
    function approve(address _spender, uint256 _value) returns(bool) {
        allowed[msg.sender][_spender] = _value; 
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) constant returns(uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.850054766,"contract PonySale is IERC20 {

    using SafeMath for uint256;

    
    string public name = ""Reales"";
    string public symbol = ""RLS"";
    uint public decimals = 18;

    uint public _totalSupply = 1000000000e18;

    uint public _icoSupply = 500000000e18; 

    uint public _futureSupply = 500000000e18; 

    
    mapping (address => uint256) balances;

    
    mapping (address => mapping(address => uint256)) allowed;

    uint256 public startTime;

    
    address public owner;

    
    uint public PRICE = 1000;

    uint public maxCap = 700000e18 ether; 

    
    uint256 public fundRaised;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value);

    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    
    
    
    function PonySale() public payable {
        startTime = now;
        owner = msg.sender;

        balances[owner] = _totalSupply; 
    }

    
    
    function () public payable {
        tokensale(msg.sender);
    }

    
    
    
    function tokensale(address recipient) public payable {
        require(recipient != 0x0);

        uint256 weiAmount = msg.value;

        owner.transfer(msg.value);
        TokenPurchase(msg.sender, recipient, weiAmount);
    }

    
    function totalSupply() public constant returns (uint256) {
        return _totalSupply;
    }

    
    
    
    function balanceOf(address who) public constant returns (uint256) {
        return balances[who];
    }

    
    function sendFutureSupplyToken(address to, uint256 value) public onlyOwner {
        require (
            to != 0x0 && value > 0 && _futureSupply >= value
        );

        balances[owner] = balances[owner].sub(value);
        balances[to] = balances[to].add(value);
        _futureSupply = _futureSupply.sub(value);
        Transfer(owner, to, value);
    }

    
    
    
    
    function transfer(address to, uint256 value) public {
        require (
            balances[msg.sender] >= value && value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(value);
        balances[to] = balances[to].add(value);
        Transfer(msg.sender, to, value);
    }

    
    
    
    
    
    function transferFrom(address from, address to, uint256 value) public {
        require (
            allowed[from][msg.sender] >= value && balances[from] >= value && value > 0
        );
        balances[from] = balances[from].sub(value);
        balances[to] = balances[to].add(value);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
        Transfer(from, to, value);
    }

    
    
    
    
    
    function approve(address spender, uint256 value) public {
        require (
            balances[msg.sender] >= value && value > 0
        );
        allowed[msg.sender][spender] = value;
        Approval(msg.sender, spender, value);
    }

    
    
    
    
    function allowance(address _owner, address spender) public constant returns (uint256) {
        return allowed[_owner][spender];
    }


}",3,
"contract Owned {
    address public owner;

    constructor() public { 
        owner = tx.origin;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function isDeployed() public pure returns(bool) {
        return true;
    }
}",0.80856628,"contract Ownable {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function isOwner() view public returns (bool) {
        return msg.sender == owner;
    }

    modifier grantOwner {
        require(isOwner());
        _;
    }
}",3,
"contract HasOwner {
    address public owner;

    function HasOwner() public {
        owner = msg.sender;
    }
}",0.859405079,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",1,
"contract CRD2 {
address public beneficiary;
uint public fundingGoal;
uint public amountRaised;

uint public amountToken;

uint public deadline;
uint public price;
token public tokenReward;
mapping(address => uint256) public balanceOf;
bool fundingGoalReached = false;
bool crowdsaleClosed = false;
event GoalReached(address recipient, uint totalAmountRaised);
event FundTransfer(address backer, uint amount, bool isContribution);

event TokenTransfer(address backer, uint amountToken, bool isContribution);


function CRD2(
    address ifSuccessfulSendTo,
    uint fundingGoalInEthers,
    uint durationInMinutes,
    uint etherCostOfEachToken,
    address addressOfTokenUsedAsReward
) {
    beneficiary = 0xAb44F092f1E01E8f91DfE9035A09461B928eDFb7;
    fundingGoal = 0.1 * 1 ether;
    deadline = now + 10 * 1 minutes;
    price = 0.1 * 1 ether;
    tokenReward = token(0x390fc971502fb5236570ba28c81e0Ba71AC55910);
}


function () payable {
    require(!crowdsaleClosed);
    uint amount = msg.value;
    balanceOf[msg.sender] += amount;
    amountRaised += amount;
    tokenReward.transfer(msg.sender, amount / price);
    FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline() { if (now >= deadline) _; }


function checkGoalReached() afterDeadline {
    if (amountRaised >= fundingGoal){
        fundingGoalReached = true;
        GoalReached(beneficiary, amountRaised);
    }
    crowdsaleClosed = true;
}



function safeWithdrawal() afterDeadline {
    if (!fundingGoalReached) {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        if (amount > 0) {
            if (msg.sender.send(amount)) {
                FundTransfer(msg.sender, amount, false);
            } else {
                balanceOf[msg.sender] = amount;
            }
        }
    }

    if (fundingGoalReached && beneficiary == msg.sender) {
        if (beneficiary.send(amountRaised)) {
            FundTransfer(beneficiary, amountRaised, false);
            TokenTransfer(beneficiary, amountToken, false);
        } else {
            
            fundingGoalReached = false;
        }
    }
}
",0.848523049,"contract Crowdsale {

    address public beneficiary;
    uint public softCap;
    uint public hardCap;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    Token public tokenReward;
    mapping(address => uint256) public balanceOf;

    bool softCapReached = false;
    bool crowdsaleClosed = false;
    uint softCapInEther =  500 ether;
    uint hardCapInEther =  3200 ether;
    uint priceInEther =  0.0002 ether;
    uint tokenDecimal =  18;
    uint duration = 120 days;
    uint startDate = 1524762900; 

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

  
    function Crowdsale(
        address ifSuccessfulSendTo,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        softCap = softCapInEther;
        hardCap = hardCapInEther;
        deadline = startDate + duration;
        price = priceInEther;
        tokenReward = Token(addressOfTokenUsedAsReward);
    }

  
    function () payable {

        require(!crowdsaleClosed);
        require(hardCap >= amountRaised);

        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount * 10 ** uint256(tokenDecimal) / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

  
    function checkGoalReached() afterDeadline {
        if (amountRaised >= softCap){
            softCapReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline {

        if (!softCapReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (softCapReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                softCapReached = false;
            }
        }
    }
}",2,
"contract CertificateList {

    function hello() public pure returns (string memory )  {
        return ""Hello"";
    }

}",0.811346197,"contract HelloWorld{

    function Hello() public pure returns (string memory){

        return (""Hello World"");

    }

}",1,
"contract Faucet {

    function withdraw(uint256 withdraw_amount) public   {    
        require(withdraw_amount <= 2000000);
        msg.sender.transfer(withdraw_amount);
        }

    
    function () external payable {}
}",0.897327261,"contract Faucet {

    

    

    function withdraw(uint withdraw_amount) public {

        

        

        require(withdraw_amount<=1000000000000);

        

        

        msg.sender.transfer(withdraw_amount);

    }

    

    

    function () public payable {}

    

}",1,
"contract IErc20 {
  function transferFrom(address, address, uint) public returns (bool);
}",0.862295991,"contract ERC20Token {

    function transferFrom(address, address, uint256) public returns (bool);

}",1,
"contract ERC721 {
    
    function totalSupply() public returns (uint256 _totalSupply);
    function balanceOf(address _owner) public view returns (uint256 _balance);
    function ownerOf(uint _tokenId) public view returns (address _owner);
    function approve(address _to, uint _tokenId) public;
    function getApproved(uint _tokenId) public view returns (address _approved);
    function transferFrom(address _from, address _to, uint _tokenId) public;
    function transfer(address _to, uint _tokenId) public;
    function implementsERC721() public view returns (bool _implementsERC721);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
}",0.839469012,"contract ERC721  {
    function balanceOf(address owner) public view returns (uint256 balance);
    function ownerOf(uint256 tokenId) public view returns (address owner);
    function approve(address to, uint256 tokenId) public;
    function getApproved(uint256 tokenId) public view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) public;
    function isApprovedForAll(address owner, address operator) public view returns (bool);
    function transferFrom(address from, address to, uint256 tokenId) public;
    function safeTransferFrom(address from, address to, uint256 tokenId) public;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
}",2,
"contract test {\n"" +
""   function multiply(uint a) returns(uint d) {\n"" +
""       return a * 7;\n"" +
""   }\n"" +
""}",0.823935103,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2,
contract HelloWorld { function f() public { } },0.831475016,"contract Hello {
  function hello() public {
  }
}",1,
contract A { function foo() public returns (uint) {} },0.813301017,"contract VoxLike {
    function par() public returns (uint);
}",1,
"contract GorillaSale is Crowdsale {

  function GorillaSale(    uint256 _time_start,
                           uint256 _time_end,
                           uint256 _rate, 
                           address _wallet)

    Crowdsale(_time_start, _time_start, _rate, _wallet)
  {

  }

  function createTokenContract() internal returns (MintableToken) {
    return new GorillaToken();
  }

}",0.806417426,"contract EverhuskCrowdsale is Crowdsale {
    function EverhuskCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {
    }
    function createTokenContract() internal returns (MintableToken) {
        return new EverhuskToken();
    }
}",1,
"contract Mortal {
    
    address payable owner;

    
    constructor() public { owner = msg.sender; }

    
    function kill() public {
        if (msg.sender == owner) 
            selfdestruct(owner); 
    }
}",0.808825131,"contract Owned {

    address payable public owner;

    constructor() public {

        owner = msg.sender;

    }

    modifier onlyOwner{ if (msg.sender != owner) revert(); _; }

}",2,
"contract ablockstoken is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    uint8 public decimals;      
    uint256 public totalSupply;
    string public name;                                   
    string public symbol;   


    uint price = 0.01 ether;            
    string terms = 'Language explaining the terms of repurchasement at a later date';  

    function ablockstoken(      
        uint256 initialSupply,
        uint8 public decimals = 18, 
        string name,            
        string symbol
    ) public {

        totalSupply = initialSupply * 65536 ** uint256(decimals);  
        balanceOf[0xaddy] = totalSupply;
        totalSupply = initialSupply;    
        name = ""ablockstoken"";          
        symbol = ""abt"";                 
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    

    function getTerms() constant returns(string) {
        return terms;
    }

    
        
    
    


    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }

    function deposit(uint256 amount) payable public {
        require(msg.value == amount);

    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

}",0.872545893,"contract Token {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping(address => uint) public balances;
    mapping(address => mapping(address => uint)) public allowed;

    string public description;
    uint8 public decimals;
    string public logoURL;
    string public name;
    string public symbol;
    uint public totalSupply;

    address public creator;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    event Created(address creator, uint supply);

    function Token(
        string _description,
        string _logoURL,
        string _name,
        string _symbol,
        uint256 _totalSupply
    ) public
    {
        description = _description;
        logoURL = _logoURL;
        name = _name;
        symbol = _symbol;
        decimals = 18;
        totalSupply = _totalSupply;

        creator = tx.origin;
        Created(creator, _totalSupply);
        balances[creator] = _totalSupply;
    }

    
    function() public payable {
        revert();
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
    
    function setLogoURL(string url) public {
        require(msg.sender == creator);
        logoURL = url;
    }
}",3,
"contract SimpleStorage {
     string public storedData;
     function set(string x) {
                  storedData = x;
     }
     function get() constant returns (string x) {
                 return storedData;
     }
 }",0.883880903,"contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    }
}",1,
"contract qualification {

address owner;


function qualification() { owner = msg.sender; }


function kill() { if (msg.sender == owner) selfdestruct(owner); }

}",0.845197244,"contract mortal {
    address private owner;
    
    function mortal() { owner = msg.sender; }
    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}",1,
"contract TestToken is MintableToken {

  string public name = ""Test Token"";
  
  string public symbol = ""TEST"";
  uint public decimals = 18;

  bool public tradingStarted = false;

  
  modifier hasStartedTrading() {
    require(tradingStarted);
    _;
  }

  
  function startTrading(bool _startStop) onlyOwner {
    
    tradingStarted = _startStop;
  }

  
  function transfer(address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transfer(_to, _value);
    return true;
  }

   
  function transferFrom(address _from, address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transferFrom(_from, _to, _value);
    return true;
  }
}",0.804512034,"contract OneledgerToken is MintableToken {

    using SafeMath for uint256;



    string public name = ""Oneledger Token"";

    string public symbol = ""OLT"";

    uint8 public decimals = 18;

    bool public active = false;

    

    modifier activated() {

        require(active == true);

        _;

    }



    

    function activate() public onlyOwner {

        active = true;

    }



    

    function transfer(address to, uint256 value) public activated returns (bool) {

        return super.transfer(to, value);

    }



    

    function transferFrom(address from, address to, uint256 value) public activated returns (bool) {

        return super.transferFrom(from, to, value);

    }

}",3,
"contract KJToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping(address => uint256) balances;
    address devAddress;

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Transfer(address indexed from, address indexed, uint256 value);

    
    mapping(address => mapping (address => uint256)) allowed;
    
    constructor() public {
        name = ""KJtoken"";
        symbol = ""KJ"";
        decimals = 18;
        devAddress = 0x22391dc3a3cD8e9774F426e5405C3440559D0a1e;
        uint initialBalance = 1000000000000000000*1000000; 
        balances[devAddress] = initialBalance;
        totalSupply += initialBalance; 
 
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _amount) public returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] = _amount;
            balances[_to] += _amount;
            emit Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
    
    function transferFrom(
    address _from,
    address _to,
    uint256 _amount
) public returns (bool success) {
    if (balances[_from] >= _amount
        && allowed[_from][msg.sender] >= _amount
        && _amount > 0
        && balances[_to] + _amount > balances[_to]) {
        balances[_from] -= _amount;
        allowed[_from][msg.sender] -= _amount;
        balances[_to] += _amount;
        return true;
    } else {
        return false;
    }
}



function approve(address _spender, uint256 _amount) public returns (bool success) {
    allowed[msg.sender][_spender] = _amount;
    emit Approval(msg.sender, _spender, _amount);
    return true;
}

}",0.856921754,"contract ATCToken is ERC20Interface{
    string public standard = &#39;Token 1.0&#39;;
    string public constant name=""ATC"";
    string public constant symbol=""ATC"";
    uint8 public constant decimals=10;
    uint256 public constant _totalSupply=3000000000000000000;
    mapping(address => mapping (address => uint256)) allowed;
    mapping(address => uint256) balances;
    address public owner;
    
    function ATCToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply; 
    }
    
    function totalSupply() constant returns (uint256 totalSupply) {
          totalSupply = _totalSupply;
    }
    
    function balanceOf(address _owner) constant returns (uint256 balance){
        return balances[_owner]; 
    }

    function transfer(address _to, uint256 _amount) returns (bool success)  {
       if (balances[msg.sender] >= _amount 
              && _amount > 0
              && balances[_to] + _amount > balances[_to]) {
              balances[msg.sender] -= _amount;
              balances[_to] += _amount;
              Transfer(msg.sender, _to, _amount);
              return true;
          } else {
              return false;
          }
    }

    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success){
        if (balances[_from] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]  && _amount <= allowed[_from][msg.sender]) {
             balances[_from] -= _amount;
             balances[_to] += _amount;
             allowed[_from][msg.sender] -= _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
             return false;
         }
    }

    function approve(address _spender, uint256 _value) returns (bool success){
         allowed[msg.sender][_spender] = _value;
         Approval(msg.sender, _spender, _value);
         return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining)
    {
        return allowed[_owner][_spender];
    }
}",3,
contract Token is ERC20 {},0.878478436,contract NewToken is ERC20 {},1,
"contract RUBY { 
 string public standard = 'RUBY 1.0'; 
 string public name; 
 string public symbol; 
 uint8 public decimals; 
 uint256 public totalSupply; 
 uint256 public balance; 
 address public owner; 
 mapping (address => uint256) public balanceOf; 
 mapping (address => mapping (address => uint256)) public allowance; 
 event Transfer(address indexed from, address indexed to, uint256 value); 
 function RUBY() { 
     balanceOf[msg.sender] = 10000; 
     totalSupply = 10000; 
     name = 'RUBY'; 
     symbol = 'RUBY'; 
     decimals = 8; 
     owner=msg.sender; 
 } 
 modifier onlyOwner { 
     if (msg.sender != owner) throw; 
     _; 
 } 
function getBalance(address _addr) constant returns(uint) {
   return _addr.balance;
}

 function transfer(address _to, uint256 _value) { 
     if (_to == 0x0) throw; 
     if (balanceOf[msg.sender] < _value) throw; 
     if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
     balanceOf[msg.sender] -= _value; 
     balanceOf[_to] += _value; 
     Transfer(msg.sender, _to, _value); 
 } 
 function approve(address _spender, uint256 _value) 
 returns (bool success) { 
     allowance[msg.sender][_spender] = _value; 
     return true; 
 } 
 function approveAndCall(address _spender, uint256 _value, bytes _extraData) 
     returns (bool success) { 
         tokenRecipient spender = tokenRecipient(_spender); 
         if (approve(_spender, _value)) { 
         spender.receiveApproval(msg.sender, _value, this, _extraData); 
         return true; 
     } 
 }
 function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { 
     if (_to == 0x0) throw; 
     if (balanceOf[_from] < _value) throw; 
     if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
     if (_value > allowance[_from][msg.sender]) throw; 
     balanceOf[_from] -= _value; 
     balanceOf[_to] += _value; 
     allowance[_from][msg.sender] -= _value; 
    Transfer(_from, _to, _value); 
     return true; 
 } 
}",0.899420948,"contract token is Pausable{

    string public standard = 'Token 0.1';

    string public name;

    string public symbol;

    uint8 public decimals;

    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);



    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    event Transfer(address indexed from, address indexed to, uint256 value);



    function token(

        uint256 initialSupply,

        string tokenName,

        uint8 decimalUnits,

        string tokenSymbol

        ) {

        balanceOf[msg.sender] = initialSupply;

        totalSupply = initialSupply;

        name = tokenName;

        symbol = tokenSymbol;

        decimals = decimalUnits;

    }



    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool)   {

        if (balanceOf[msg.sender] < _value) throw;

        if (balanceOf[_to] + _value < balanceOf[_to]) throw;

        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;

        Transfer(msg.sender, _to, _value);

    }



    function approve(address _spender, uint256 _value)

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        returns (bool success) {    

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balanceOf[_from] < _value) throw;

        if (balanceOf[_to] + _value < balanceOf[_to]) throw;

        if (_value > allowance[_from][msg.sender]) throw;

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);

        return true;

    }



    function () {

        throw;

    }

}",2,
"contract BaseToken {

string public name;
string public symbol;
uint8 public decimals = 18;

uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


clients
event Transfer(address indexed from, address indexed to, uint256 
 value);


 clients
event Approval(address indexed _owner, address indexed _spender, 
uint256 _value);


event Burn(address indexed from, uint256 value);


constructor() public {
    totalSupply = 10000 * 10 ** uint256(decimals);  
    supply with the decimal amount
    balanceOf[msg.sender] = totalSupply;                
    creator all initial tokens
    name = ""BaseToken"";                                   
   name for display purposes
    symbol = ""BASETOKEN"";                               
 symbol for display purposes
}

function getBalance() public pure returns (string memory){
   return  ""some string"";
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != address(0x0));
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    
    code. They should never fail
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public returns (bool 
 success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) 
 public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
   allowance
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes memory 
 _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, address(this), 
   _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
 has enough
    balanceOf[msg.sender] -= _value;            
 sender
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool 
 success) {
    require(balanceOf[_from] >= _value);                
 targeted balance is enough
    require(_value <= allowance[_from][msg.sender]);    
    allowance
    balanceOf[_from] -= _value;                         
     from the targeted balance
    allowance[_from][msg.sender] -= _value;             
    from the sender's allowance
    totalSupply -= _value;                              
    totalSupply
    emit Burn(_from, _value);
    return true;
}",0.876133469,"contract TokenERC20 {

        

        using SafeMath for uint256;

        string public name;

        string public symbol;

        uint8 public decimals = 18; 

        uint256 public totalSupply;

        bool public safeguard = false;  

    

        

        mapping (address => uint256) public balanceOf;

        mapping (address => mapping (address => uint256)) public allowance;

    

        

        event Transfer(address indexed from, address indexed to, uint256 value);

    

        

        event Burn(address indexed from, uint256 value);

    

        

        constructor (

            uint256 initialSupply,

            string memory tokenName,

            string memory tokenSymbol

        ) public {

            

            totalSupply = initialSupply * 1 ether;      

            uint256 halfTotalSupply = totalSupply / 2;  

            

            balanceOf[msg.sender] = halfTotalSupply;    

            balanceOf[address(this)] = halfTotalSupply; 

            name = tokenName;                           

            symbol = tokenSymbol;                       

            

            emit Transfer(address(0x0), msg.sender, halfTotalSupply);   

            emit Transfer(address(0x0), address(this), halfTotalSupply);

        }

    

        

        function _transfer(address _from, address _to, uint _value) internal {

            require(!safeguard);

            

            require(_to != address(0x0));

            

            require(balanceOf[_from] >= _value);

            

            require(balanceOf[_to].add(_value) > balanceOf[_to]);

            

            uint previousBalances = balanceOf[_from].add(balanceOf[_to]);

            

            balanceOf[_from] = balanceOf[_from].sub(_value);

            

            balanceOf[_to] = balanceOf[_to].add(_value);

            emit Transfer(_from, _to, _value);

            

            assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);

        }

    

        

        function transfer(address _to, uint256 _value) public returns (bool success) {

            _transfer(msg.sender, _to, _value);

            return true;

        }

    

        

        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

            require(!safeguard);

            require(_value <= allowance[_from][msg.sender]);     

            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);

            _transfer(_from, _to, _value);

            return true;

        }

    

        

        function approve(address _spender, uint256 _value) public

            returns (bool success) {

            require(!safeguard);

            allowance[msg.sender][_spender] = _value;

            return true;

        }

    

        

        function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)

            public

            returns (bool success) {

            require(!safeguard);

            tokenRecipient spender = tokenRecipient(_spender);

            if (approve(_spender, _value)) {

                spender.receiveApproval(msg.sender, _value, address(this), _extraData);

                return true;

            }

        }

    

        

        function burn(uint256 _value) public returns (bool success) {

            require(!safeguard);

            require(balanceOf[msg.sender] >= _value);   

            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            

            totalSupply = totalSupply.sub(_value);                      

            emit Burn(msg.sender, _value);

            return true;

        }

    

        

        function burnFrom(address _from, uint256 _value) public returns (bool success) {

            require(!safeguard);

            require(balanceOf[_from] >= _value);                

            require(_value <= allowance[_from][msg.sender]);    

            balanceOf[_from] = balanceOf[_from].sub(_value);                         

            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);             

            totalSupply = totalSupply.sub(_value);                              

            emit  Burn(_from, _value);

            return true;

        }

        

    }",3,
"contract TestCrowdsale is Ownable {
  using SafeMath for uint256;

mapping(address => bool) public whitelist;


ERC20 public token;


address public wallet = 0x770a682364cbed4374d1eF1fA343AB08561aF376;


uint256 public rate = 10000;


uint256 public weiRaised = 0;


uint256 public openingTime = now;


uint256 public closingTime = now + 60 minutes;


address public tokenWallet = 0xf926F01559E5fF8c1b63BfD6E944c8E93Cb20009;


uint256 public cap = 1 * 10 ** 18;


event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

function TestCrowdsale (
    uint256 _rate,
    address _wallet,
    ERC20 _token,
    uint256 _openingTime,
    uint256 _closingTime,
    address _tokenWallet,
    uint256 _cap
  )
    public
  {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);
    require(_tokenWallet != address(0));
    require(_cap > 0);
    rate = _rate;
    wallet = _wallet;
    token = _token;
    openingTime = _openingTime;
    closingTime = _closingTime;
    tokenWallet = _tokenWallet;
    cap = _cap;
  }


  
  

  function () external payable {
    buyTokens(msg.sender);
  }


  function addToWhitelist(address _beneficiary) external onlyOwner {
    whitelist[_beneficiary] = true;
  }


  function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {
    for (uint256 i = 0; i < _beneficiaries.length; i++) {
      whitelist[_beneficiaries[i]] = true;
    }
  }


  function removeFromWhitelist(address _beneficiary) external onlyOwner {
    whitelist[_beneficiary] = false;
  }

  
  
  
  
  function buyTokens(address _beneficiary) public payable {
uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    uint256 tokens = _getTokenAmount(weiAmount);

    weiRaised = weiRaised.add(weiAmount);
_processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );
_forwardFunds();
  }

  
  function remainingTokens() public view returns (uint256) {
    return token.allowance(tokenWallet, this);
  }

  
  function hasClosed() public view returns (bool) {
    
    return block.timestamp > closingTime;
  }

  
  function capReached() public view returns (bool) {
    return weiRaised >= cap;
  }

  
  function transferAnyERC20Token(address tokenAddress, uint256 _value) public onlyOwner returns (bool success) {
        return ERC20(tokenAddress).transfer(owner, _value);
    }


  
  

  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {
    require(whitelist[_beneficiary]);
    require(block.timestamp >= openingTime && block.timestamp <= closingTime);
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
    require(weiRaised.add(_weiAmount) <= cap);
  }


 function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);
  }


  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }


  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }


  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",0.830825659,"contract CrowdsaleWPTByRounds is Ownable {

  using SafeMath for uint256;

  using SafeERC20 for ERC20;



  

  ERC20 public token;



  

  address public wallet;



  

  Token public minterContract;



  

  

  uint256 public rate;



  

  uint256 public tokensRaised;



  

  uint256 public cap;



  

  uint256 public openingTime;

  uint256 public closingTime;



  

  uint public minInvestmentValue;



  

  function setMinter(address _minterAddr) public onlyOwner {

    minterContract = Token(_minterAddr);

  }



  

  modifier onlyWhileOpen {

    

    require(block.timestamp >= openingTime && block.timestamp <= closingTime);

    _;

  }



  

  event TokenPurchase(

    address indexed purchaser,

    address indexed beneficiary,

    uint256 value,

    uint256 amount

    );



constructor () public {

    rate = 400;

    wallet = 0xeA9cbceD36a092C596e9c18313536D0EEFacff46;

    cap = 400000000000000000000000;

    openingTime = 1534558186;

    closingTime = 1535320800;



    minInvestmentValue = 0.02 ether;

  }



   

  function capReached() public view returns (bool) {

    return tokensRaised >= cap;

  }



   

  function changeRate(uint256 newRate) public onlyOwner {

    rate = newRate;

  }



   

  function closeRound() public onlyOwner {

    closingTime = block.timestamp + 1;

  }



   

  function setToken(ERC20 _token) public onlyOwner {

    token = _token;

  }



   

  function setWallet(address _wallet) public onlyOwner {

    wallet = _wallet;

  }



   

  function changeMinInvest(uint256 newMinValue) public onlyOwner {

    rate = newMinValue;

  }



   

  function setCap(uint256 _newCap) public onlyOwner {

    cap = _newCap;

  }



   

  function startNewRound(uint256 _rate, address _wallet, ERC20 _token, uint256 _cap, uint256 _openingTime, uint256 _closingTime) payable public onlyOwner {

    require(!hasOpened());

    rate = _rate;

    wallet = _wallet;

    token = _token;

    cap = _cap;

    openingTime = _openingTime;

    closingTime = _closingTime;

  }



  

  function hasClosed() public view returns (bool) {

    

    return block.timestamp > closingTime;

  }



  

  function hasOpened() public view returns (bool) {

    

    return (openingTime < block.timestamp && block.timestamp < closingTime);

  }



  

  

  



  

  function () payable external {

    buyTokens(msg.sender);

  }



  

  function buyTokens(address _beneficiary) payable public{



    uint256 weiAmount = msg.value;

    _preValidatePurchase(_beneficiary, weiAmount);



    

    uint256 tokens = _getTokenAmount(weiAmount);



    

    tokensRaised = tokensRaised.add(tokens);



    minterContract.mint(_beneficiary, tokens);

    

    emit TokenPurchase(

      msg.sender,

      _beneficiary,

      weiAmount,

      tokens

    );



    _forwardFunds();

  }



  

  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount)

  internal

  view

  onlyWhileOpen

  {

    require(_beneficiary != address(0));

    require(_weiAmount != 0 && _weiAmount > minInvestmentValue);

    require(tokensRaised.add(_getTokenAmount(_weiAmount)) <= cap);

  }



  

  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {

    token.safeTransfer(_beneficiary, _tokenAmount);

  }



  

  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {

    _deliverTokens(_beneficiary, _tokenAmount);

  }



  

  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {

    return _weiAmount.mul(rate);

  }



  

  function _forwardFunds() internal {

    wallet.transfer(msg.value);

  }

}",2,
"contract TOKKA is StandardToken {
    string public name = ""EGaming Token"";
    string public symbol = ""GT"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 6000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",0.882739132,"contract MOKEN is StandardToken {
    string public name = ""MOKEN"";
    string public symbol = ""MOKN"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 17000000 * 10**18;
    function MOKEN () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,
"contract B1 is A {
    function foo(uint256 _x) public pure returns(uint256) { return _x + 1; }
}",0.804122612,"contract MSD2 {

   

    function fus (uint256 i) public pure returns (uint256) {

        return i*100;

    }

}",2,
"contract BLUBLOXX is EIP20Interface {

uint256 constant private MAX_UINT256 = 2**256 - 1;
mapping (address => uint256) public balances;
mapping (address => mapping (address => uint256)) public allowed;

string public name;                   
uint8 public decimals;                
string public symbol;                 

uint price = 0.001 ether;

function BLUBLOXX(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol
) public {
    balances[msg.sender] = _initialAmount;               
    totalSupply = _initialAmount;                        
    name = _tokenName;                                   
    decimals = _decimalUnits;                            
    symbol = _tokenSymbol;                               
}

function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    Transfer(msg.sender, _to, _value);
    return true;
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    uint256 allowance = allowed[_from][msg.sender];
    require(balances[_from] >= _value && allowance >= _value);
    balances[_to] += _value;
    balances[_from] -= _value;
    if (allowance < MAX_UINT256) {
        allowed[_from][msg.sender] -= _value;
    }
    Transfer(_from, _to, _value);
    return true;
}

function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
}   

function() public payable{

    uint toMint = msg.value/price;
    totalSupply += toMint;
    balances[msg.sender]+=toMint;

    Transfer(0, msg.sender, toMint);

}

function withdrawEther() external onlyOwner {
owner.transfer(this.balance);",0.853160048,"contract LetoCoin{

    string public constant name = &#39;LetoCoin&#39;;
    string public constant symbol = &#39;LETO&#39;;
    uint8 public constant decimals = 10;
    uint256 public constant totalSupply = 8000000 * 10**uint256(decimals);
    
    mapping (address => uint256) private balances;
    mapping (address => mapping (address => uint256)) private allowed;
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function LetoCoin() public {
        balances[msg.sender] = totalSupply;
        Transfer(0x0, msg.sender, totalSupply);
    }
    
    function balanceOf(address _owner) constant public returns (uint256 balance){
        return balances[_owner];
    }
    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        if (_value != 0){
            require(balances[msg.sender] >= _value);
            require(balances[_to] + _value > balances[_to]);
            balances[msg.sender] -= _value;
            balances[_to] += _value;
        }
        Transfer(msg.sender, _to, _value); 
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        if (_value != 0){
            require(allowed[_from][msg.sender] >= _value);
            require(balances[_from] >= _value);
            require(balances[_to] + _value > balances[_to]);
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            balances[_to] += _value;
        }
        Transfer(_from, _to, _value); 
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success){
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
    
    function () public payable {
        revert();
    }
    
}",2,
"contract createWallet {
    address public owner;

    constructor(address _owner) payable public {
        owner = _owner;
    }
}",0.815614275,"contract Simple

{

    address public owner;



    constructor (address ownerAddress) public

    {

        owner = ownerAddress;

    }

}",1,
"contract Foo {
    uint storageData;

    function set(uint x) public {
        storageData = x;
    }

    function get() constant public returns (uint) {
        return storageData;
    }
}",0.887431836,"contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    }
}",1,
"contract Hello {
        function hello() external {
        }
    }",0.82762792,"contract Hello {
  function hello() public {
  }
}",1,
contract C { ... },0.848219862,contract X {},1,
"contract SimpleWallet {

    address public owner;
    mapping (address => uint) balances;

    
    function SimpleWallet(){
        owner = msg.sender;
        balances[owner] = 1000;
    }

    function transfer(address _to, uint _value) returns (bool success){
        if (balances[msg.sender] < _value) {
            return false;
        }

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        return true;
    }

    function getBalance(address _user) constant returns (uint _balance) {
        return balances[_user];
    }
}",0.81092722,"contract Standard is Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}",3,
"contract HEY is StandardToken {
    string public name = ""HEY"";
    string public symbol = ""HEY"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 1234 * 10**18;

    function StandardToken() public {
       balance[msg.sender] = INITIAL_SUPPLY;

    }
}",0.876001708,"contract MOKEN is StandardToken {
    string public name = ""MOKEN"";
    string public symbol = ""MOKN"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 17000000 * 10**18;
    function MOKEN () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,
"contract GenericToken is owned{
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    
    event FrozenFunds(address target, bool frozen);

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                    
        name = tokenName;                                       
        symbol = tokenSymbol;                                   
    }

    
    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != address(0x0));                               
        require(balanceOf[_from] >= _value);                        
        require(balanceOf[_to] + _value > balanceOf[_to]);          
        require(!frozenAccount[_from]);                             
        require(!frozenAccount[_to]);                               
        uint previousBalances = balanceOf[_from] + balanceOf[_to];  
        balanceOf[_from] -= _value;                                 
        balanceOf[_to] += _value;                                   
        emit Transfer(_from, _to, _value);                          
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    
    
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    
    
    
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }



    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    
    
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }

    
    
    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance >= amount * sellPrice);   
        _transfer(msg.sender, address(this), amount);       
        msg.sender.transfer(amount * sellPrice);            
    }


    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",0.846073233,"contract ERC20TokenSAC {

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    uint256 public totalSupply;

    address public cfoOfTokenSAC;

    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

    mapping (address => bool) public frozenAccount;

    

    event Transfer (address indexed from, address indexed to, uint256 value);

    event Approval (address indexed owner, address indexed spender, uint256 value);

    event MintToken (address to, uint256 mintvalue);

    event MeltToken (address from, uint256 meltvalue);

    event FreezeEvent (address target, bool result);

    

    constructor (

        uint256 initialSupply,

        string memory tokenName,

        string memory tokenSymbol

        ) public {

            cfoOfTokenSAC = msg.sender;

            totalSupply = initialSupply * 10 ** uint256(decimals);

            balanceOf[msg.sender] = totalSupply;

            name = tokenName;

            symbol = tokenSymbol;

        }

    

    modifier onlycfo {

        require (msg.sender == cfoOfTokenSAC);

        _;

    }

    

    function _transfer (address _from, address _to, uint _value) internal {

        require (!frozenAccount[_from]);

        require (!frozenAccount[_to]);

        require (_to != address(0x0));

        require (balanceOf[_from] >= _value);

        require (balanceOf[_to] + _value >= balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;

        emit Transfer (_from, _to, _value);

        assert (balanceOf[_from] + balanceOf[_to] == previousBalances);

    }

    

    function transfer (address _to, uint256 _value) public returns (bool success) {

        _transfer (msg.sender, _to, _value);

        return true;

    }

    

    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success) {

        require (_value <= allowance[_from][msg.sender]);

        _transfer (_from, _to, _value);

        allowance[_from][msg.sender] -= _value;

        return true;

    }

    

    function approve (address _spender, uint256 _value) public returns (bool success) {

        require (_spender != address(0x0));

        require (_value != 0);

        allowance[msg.sender][_spender] = _value;

        emit Approval (msg.sender, _spender, _value);

        return true;

    }

    

    function appointNewcfo (address newcfo) onlycfo public returns (bool) {

        require (newcfo != cfoOfTokenSAC);

        cfoOfTokenSAC = newcfo;

        return true;

    }

    

    function mintToken (address target, uint256 amount) onlycfo public returns (bool) {

        require (target != address(0x0));

        require (amount != 0);

        balanceOf[target] += amount;

        totalSupply += amount;

        emit MintToken (target, amount);

        return true;

    }

    

    function meltToken (address target, uint256 amount) onlycfo public returns (bool) {

        require (target != address(0x0));

        require (amount <= balanceOf[target]);

        require (amount != 0);

        balanceOf[target] -= amount;

        totalSupply -= amount;

        emit MeltToken (target, amount);

        return true;

    }

    

    function freezeAccount (address target, bool freeze) onlycfo public returns (bool) {

        require (target != address(0x0));

        frozenAccount[target] = freeze;

        emit FreezeEvent (target, freeze);

        return true;

    }

}",3,
"contract XXPreOrderToken is XXERC20 {

    using SafeMath for uint256;

    uint public _totalSupply = 72500000000000000000000;

    string public constant symbol =""XXPOT"";
    string public constant name = ""PreOrderToken"";
    uint8 public constant decimals = 18;

    
    uint256 public constant RATE = 1000;

    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    function() payable{
        createTokens();
    }

    function XXPreOrderToken() {
        balances[msg.sender] = _totalSupply;
        owner = msg.sender;
    }

    function createTokens() payable {
        require(msg.value > 0);

        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);

        owner.transfer(msg.value);
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success) {
        require(
            balances[msg.sender] >= _value
            && _value > 0
            );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
            );
            balances[_from] = balances[_from].sub(_value);
            balances[_to] = balances[_to].add(_value);
            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
            Transfer(_from, _to, _value);
            return true;
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",0.862009316,"contract ERC20Base is ERC20Interface {
    using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint public totalSupply_;
    address public owner;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;

    
    constructor(address _owner) public {
        symbol = ""IFF"";
        name = ""IFFtoken"";
        decimals = 18;
        totalSupply_ = 8 * (10 ** 8) * (10 ** 18);
        owner = _owner;
        balances[owner] = totalSupply_;
        emit Transfer(address(0), owner, totalSupply_);
    }

    
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    
    function burn(uint256 _value) public {
        address account = msg.sender;
        
        totalSupply_ = totalSupply_.sub(_value);
        balances[account] = balances[account].sub(_value);
        emit Transfer(account, address(0), _value);
    }
}",3,
"contract ChildContract {
    constructor() public {
        
    }
}",0.879784732,"contract BlankContract {
    constructor() public {}
}",1,
"contract BasicToken {

  
  using SafeMath for uint256;

  
  uint256 public totalSupply;

  
  mapping(address => uint256) balances;

  mapping(address => string) Payload;

  
  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  
  
  function PayloadOf(address _owner) constant returns (string payload) {
    return Payload[_owner];
  }

  
  
  
  
  
  
  function transfer(address _from, address _to, uint256 _value, string Pl_value) public returns (bool) {
    require(_to != address(0));

    
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);

    Payload[_to] = Pl_value;

    return true;
  }

}",0.814423413,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_to != address(this));

    require(_value <= balances[msg.sender]);

    



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }

}",3,
"contract priced {

    modifier costs(uint price) {
        if (msg.value >= price) {
            _;
        }
    }
}",0.868755177,"contract Priced

{

    modifier costs(uint price)

    {

        

        require(msg.value == price);

        _;

    }

}",2,
"contract TOKKA is StandardToken {
    string public name = ""Test Token"";
    string public symbol = ""TT"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 50000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",0.887980714,"contract MOKEN is StandardToken {
    string public name = ""MOKEN"";
    string public symbol = ""MOKN"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 17000000 * 10**18;
    function MOKEN () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,
"contract Forwarder {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function() payable {
        if (!destinationAddress.send(msg.value))
            throw;
  }

  
  function flush() {
    if (!destinationAddress.send(this.balance))
          throw;
  }
}",0.860913135,"contract Forwarder {
  
  address public destinationAddress;

  
  function Forwarder() public {
    destinationAddress = msg.sender;
  }

  
  function() payable public {
        destinationAddress.transfer(msg.value);
  }

  
  function flush() public {
    destinationAddress.transfer(this.balance);
  }

}",2,
"contract EdCoin is owned {
  string public name;
  string public symbol;
  uint8 public decimals = 18;
  uint256 public totalSupply;

  mapping (address => bool) public frozenAccount;
  mapping (address => uint256) public balanceOf;

  event Transfer (address indexed from, address indexed to, uint256 value);
  event FrozenFunds (address target, bool frozen);
  event Burn(address indexed from, uint256 value);

  constructor(
    uint256 initialSupply,
    string memory tokenName,
    string memory tokenSymbol
  ) public {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;                
    name = tokenName;                                   
    symbol = tokenSymbol;                               
  }

  function _transfer (address _from, address _to, uint _value) internal {
    require(_to != address(0x0));
    require(!frozenAccount[_to]);
    require(!frozenAccount[_from]);
    require(balanceOf[_from] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require (_to != address(0x0));                          
    require (balanceOf[_from] >= _value);
    require (balanceOf[_to] + _value >= balanceOf[_to]);
    require(!frozenAccount[_from]);
    require(!frozenAccount[_to]);                           
    _transfer(_from, _to, _value);
    return true;
  }

  function transferN (address _to, uint256 _value) public returns (bool success) {
    require (_to != address(0x0));  
    require(balanceOf[msg.sender] >= _value);

    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    emit Transfer(msg.sender, _to, _value);

    return true;
  }

  function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
  }

  function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    balanceOf[_from] -= _value;                         
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
  }

  function freezeAccount(address target, bool freeze) public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  function distributeToken(address[] memory addresses, uint256[] memory _value) public returns (bool success) {
    for( uint256 i=1;i<addresses.length;i++){
      _transfer(addresses[0], addresses[i], _value[i]);
    }
    return true;
  }

  function mintToken(address target, uint256 mintedAmount) onlyOwner public {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    emit Transfer(address(0), address(this), mintedAmount);
    emit Transfer(address(this), target, mintedAmount);
  }
}",0.881770564,"contract TokenERC20 is owned{



    string public name;

    string public symbol;

    uint8 public decimals = 18;

    uint256 public totalSupply;



    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

    mapping (address => bool) public frozenAccount;



    event Transfer(address indexed from, address indexed to, uint256 value);

    

    event Approval(address indexed owner, address indexed spender, uint256 value);



    event Burn(address indexed from, uint256 value);



    event FrozenFunds(address target, bool frozen);



    function TokenERC20(

        uint256 initialSupply,

        string tokenName,

        string tokenSymbol

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);

        balanceOf[msg.sender] = totalSupply;

        name = tokenName;

        symbol = tokenSymbol;

    }



    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != 0x0);

        require(balanceOf[_from] >= _value);

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        require(!frozenAccount[_from]);

        require(!frozenAccount[_to]);



        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;



        emit Transfer(_from, _to, _value);



        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;

        totalSupply -= _value;

        emit Burn(msg.sender, _value);

        return true;

    }



    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);

        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;

        allowance[_from][msg.sender] -= _value;

        totalSupply -= _value;

        emit Burn(_from, _value);

        return true;

    }



    function freezeAccount(address target, bool freeze) onlyOwner public {

        frozenAccount[target] = freeze;

        emit FrozenFunds(target, freeze);

    }

}",3,
"contract BestCoin {

    uint constant private MAX_UINT256 = 2**256 - 1;
    
    
    address public minter;
    uint256 public tokenTotalSupply = 0;
    mapping (address => uint) public balances;



    
    function name() public view returns (string memory) {
        return ""TheBestCoin"";
    }

    
    function symbol() public view returns (string memory) {
        return ""TBC"";
    }

    
    function decimals() public view returns (uint8) {
        return 8; 
    }

    function totalSupply() public view returns (uint256) {
        return tokenTotalSupply;
    }

    function balanceOf(address _owner) public view returns(uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value); 
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balances[_from] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        return true; 
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    
    event Sent(address from, address to, uint amount);

    
    
    constructor() public {
        minter = msg.sender;
    }

    
    
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter);
        require(amount < 1e60);
        balances[receiver] += amount;
        tokenTotalSupply += amount;
    }

    
    
    function send(address receiver, uint amount) public {
        require(amount <= balances[msg.sender], ""Insufficient balance."");
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}",0.837695819,"contract BasicERC20Token {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name = &#39;Ivan\&#39;s Trackable Token&#39;;
    string public symbol = &#39;ITT&#39;;
    uint8 public decimals = 18;
    uint256 public totalSupply = 0;

    
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event BalanceCheck(uint256 balance);

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    

    function deposit() payable returns (bool success) {
        if (msg.value == 0) return false;
        balances[msg.sender] += msg.value;
        totalSupply += msg.value;
        return true;
    }

    function withdraw(uint256 amount) returns (bool success) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        totalSupply -= amount;
        if (!msg.sender.send(amount)) {
            balances[msg.sender] += amount;
            totalSupply += amount;
            return false;
        }
        return true;
    }

}",3,
"contract Test {
    address public owner;
    constructor() public {
        owner = msg.sender;
    }
    function destroy() onlyOwner public {
        selfdestruct(owner);
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}",0.866441089,"contract owned {

    address public owner;



    constructor() public {owner = msg.sender;}



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function ayu(address nO) onlyOwner public {owner = nO;}

}",3,
"contract HelloWorld {
  address public owner;
  mapping (address => uint) balances;
  function HelloWorld() {
    owner = msg.sender;
    balances[owner] = 1000;
  }
  function transfer(address _to, uint _value) returns (bool success) {
    if (balances[msg.sender] < _value) {
      return false;
    }
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
  }
  function getBalance(address _user) constant returns(uint _balance) {
    return balances[_user];
  }
}",0.804725127,"contract Standard is Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}",3,
"contract sample {
    function add_var(uint a) public pure returns(uint) {
    return a + 0x55;
    }
}",0.810819044,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2,
"contract ERC20 {
    
    

    function allowance(address _owner, address _spender) constant returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);


    function approve(address _spender, uint256 _amount) returns (bool success) {
        if ((_amount != 0) && (allowed[msg.sender][_spender] != 0)) {
            return false;
        }
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _amount)
    returns (bool success) {
        if (
        balances[_from] >= _amount
        && allowed[_from][msg.sender] >= _amount 
        && _amount > 0
        && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    uint public totalSupply = 0;
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;

    function balanceOf(address _owner) constant returns (uint balance){
        return balances[_owner];
    }
}",0.831451672,"contract UBCToken is ERC20Interface{
    string public standard = &#39;Token 1.0&#39;;
    string public constant name=""Ubiquitous Business Credit"";
    string public constant symbol=""UBC"";
    uint8 public constant decimals=4;
    uint256 public constant _totalSupply=10000000000000;
    mapping(address => mapping (address => uint256)) allowed;
    mapping(address => uint256) balances;

    
    function UBCToken() {
        balances[msg.sender] = _totalSupply; 
    }
   function totalSupply() constant returns (uint256 totalSupply) {
          totalSupply = _totalSupply;
    }
    
    
    function balanceOf(address _owner) constant returns (uint256 balance){
        return balances[_owner]; 
    }

    
    function transfer(address _to, uint256 _amount) returns (bool success)  {
       if (balances[msg.sender] >= _amount 
              && _amount > 0
              && balances[_to] + _amount > balances[_to]) {
              balances[msg.sender] -= _amount;
              balances[_to] += _amount;
              Transfer(msg.sender, _to, _amount);
              return true;
          } else {
              return false;
          }          
    }

    
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success){
        if (balances[_from] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]  && _amount <= allowed[_from][msg.sender]) {
             balances[_from] -= _amount;
             balances[_to] += _amount;
             allowed[_from][msg.sender] -= _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
             return false;
         }
    }

    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining)
    {
        return allowed[_owner][_spender];
    }
}",3,
"contract Greeter {
    string public greeting;

    function Greeter() {
        greeting = 'Hello';
    }

    function setGreeting(string _greeting) public {
        greeting = _greeting;
    }

    function greet() constant returns (string) {
        return greeting;
    }
}",0.878927993,"contract Hello {

    string greeting;



     constructor() public {

        greeting = ""hello"";

     }



     function getGreeting() public view returns (string) {

        return greeting;

     }



     function setGreeting(string _greeting) public {

        greeting = _greeting;

     }

}",1,
"contract TOKKA is StandardToken {
    string public name = ""New Commercial Token"";
    string public symbol = ""NCT"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 6000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",0.82430976,"contract DECoin is StandardToken {



  string public name = ""?;",,
,,,,
  string public symbol = ""?";,,,,
,,,,
  uint256 public decimals = 18;,,,,
,,,,
  uint256 public INITIAL_SUPPLY = 77760000 * 1 ether;,,,,
,,,,
,,,,
,,,,
 ,,,,
,,,,
  function DECoin() {,,,,
,,,,
    totalSupply = INITIAL_SUPPLY;,,,,
,,,,
    balances[msg.sender] = INITIAL_SUPPLY;,,,,
,,,,
  },,,,
,,,,
,,,,
,,,,
}",,,,
"contract Crowdsale is Ownable {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  uint256 public CAP = 3000000000000000000;

  bool crowdsaleClosed = false;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());
    require(!crowdsaleClosed);


    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    
    StandardToken(token).transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function GoalReached() public view returns (bool) {

    return (weiRaised >= CAP);
  }

  function Pause() public onlyOwner
  {
       

        
        require(weiRaised >= CAP);

        crowdsaleClosed = true;
  }

  function Play() public onlyOwner
  {
       

        
        require(crowdsaleClosed == true);

        crowdsaleClosed = false;
  }

}",0.825863133,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != 0x0);

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }


  
  function () payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != 0x0);
    require(validPurchase());

    address team = 0x65dC43D9a882793B37d7bbe4f29566cD037e4474;
    address bounty = 0x65dC43D9a882793B37d7bbe4f29566cD037e4474;
    address reserve = 0x65dC43D9a882793B37d7bbe4f29566cD037e4474;

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);
    uint256 bountyAmount = weiAmount.mul(50);
    uint256 teamAmount = weiAmount.mul(100);
    uint256 reserveAmount = weiAmount.mul(50);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    token.mint(bounty, bountyAmount);
    token.mint(team, teamAmount);
    token.mint(reserve, reserveAmount);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal constant returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  
  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }


}",3,
"contract MyToken is StandardToken {
string public name = ""MyTok"";
string public symbol = ""MTK"";
uint8 public decimals = 2;
uint public INITIAL_SUPPLY = 5000;

function MyToken () public {
    totalSupply__ = INITIAL_SUPPLY;
    balances[msg.sender]= INITIAL_SUPPLY;
    emit Transfer(0x0,msg.sender,totalSupply_);

    }
}",0.861519672,"contract VerityToken is StandardToken {

  string public name = ""VerityToken"";

  string public symbol = ""VTY"";

  uint8 public decimals = 18;

  uint public INITIAL_SUPPLY = 500000000 * 10 ** uint(decimals);



  function VerityToken() public {

    totalSupply_ = INITIAL_SUPPLY;

    balances[msg.sender] = INITIAL_SUPPLY;

  }

}",4,
"contract owned {
    address public owner;
    address constant public ledger = 0xd7b4754A023B92F811EF98b2bd1cD8d531905E5a;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",0.819214953,"contract owned {

    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        owner = newOwner;

    }



    function getOwned() onlyOwner public view returns (address) {

        return owner;

    }

}",3,
"contract Forwarder {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function() payable external{
        if (!destinationAddress.send(msg.value))
            throw;
  }

  
  function flush() {
    if (!destinationAddress.send(this.balance))
          throw;
  }
}",0.852300638,"contract Forwarder {
  
  address public destinationAddress;

  
  function Forwarder() public {
    destinationAddress = msg.sender;
  }

  
  function() payable public {
        destinationAddress.transfer(msg.value);
  }

  
  function flush() public {
    destinationAddress.transfer(this.balance);
  }

}",2,
"contract Candy {
    address public owner;

    function Candy() public {
        owner = msg.sender;
    }
}",0.848478037,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",1,
"contract ERC223Interface {
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transfer(address to, uint256 value, bytes calldata data) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",0.835348931,"contract ERC20Interface {

    

    function totalSupply() public constant returns (uint256 tS);

 

    

    function balanceOf(address _owner) constant public returns (uint256 balance);

 

    

    function transfer(address _to, uint256 _value) public returns (bool success);

 

    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

 

    

    

    

    function approve(address _spender, uint256 _value) public returns (bool success);

 

    

    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);



    

    function burnExcess(uint256 _value) public returns (bool success);

 

    

    function transferWithFee(address _to, uint256 _value, uint256 _fee) public returns (bool success);



    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

 

    

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    

    event Burn(address indexed from, uint256 value);



    

    event TransferWithFee(address indexed _from, address indexed _to, uint256 _value, uint256 _fee);



}",2,
"contract ERC223Token is ERC223Interface {
    using SafeMath for uint256;

    address private _owner; 
    
    

    string  public  constant name = ""ERC223"";
    string  public  constant symbol = ""ERC223"";
    uint8   public  constant decimals = 18;
    uint256 private constant _totalSupply = 10000000 * (uint256(10) ** decimals);

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowed;

    constructor() public {
        _owner = msg.sender;
        _balances[_owner] = _totalSupply;
        emit Transfer(address(0), _owner, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256 balance) {
        return _balances[owner];
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(to != address(0));
        require(value > 0 && balanceOf(msg.sender) >= value);
        require(balanceOf(to).add(value) > balanceOf(to));

        uint256 codeLength;
        bytes memory empty;

        assembly {
            codeLength := extcodesize(to)
        }

        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);

        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);
            receiver.tokenFallback(msg.sender, value, empty);
        }

        emit Transfer(msg.sender, to, value, empty);
        return true;
    }

    function transfer(address to, uint256 value, bytes memory data) public returns (bool success) {
        require(to != address(0));
        require(value > 0 && balanceOf(msg.sender) >= value);
        require(balanceOf(to).add(value) > balanceOf(to));

        uint256 codeLength;

        assembly {
            codeLength := extcodesize(to)
        }

        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);

        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);
            receiver.tokenFallback(msg.sender, value, data);
        }

        emit Transfer(msg.sender, to, value, data);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(to != address(0));
        require(value <= _balances[from]);
        require(value <= _allowed[from][msg.sender]);

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool success) {
        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool success) {
        uint256 oldValue = _allowed[msg.sender][spender];
        if (subtractedValue > oldValue) {
            _allowed[msg.sender][spender] = 0;
        } else {
            _allowed[msg.sender][spender] = oldValue.sub(subtractedValue);
        }
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function unlockERC20Tokens(address tokenAddress, uint256 tokens) public returns (bool success) {
        require(msg.sender == _owner);
        return ERC223Interface(tokenAddress).transfer(_owner, tokens);
    }

    function () external payable {
        revert(""This contract does not accept ETH"");
    }

}",0.824142405,"contract TrainingToken is Interfacetrt{

    using SafeMath for uint256;

    uint256 constant private MAX_UINT256 = 2**256 - 1;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowed;

    uint256 public totalSupply;

    string public name = ""TrainingToken""; 

    uint8 public decimals = 18; 

    string public symbol = ""TRT"";

    address private _owner;

    

    mapping (address => bool) public _notransferible;

    mapping (address => bool) private _administradores; 

    

    constructor() public{

        _owner = msg.sender;

        totalSupply = 100000000000000000000000000000;

        _balances[_owner] = totalSupply;

        _administradores[_owner] = true;

    }



    function isAdmin(address dir) public view returns(bool){

        return _administradores[dir];

    }

    

    modifier OnlyOwner(){

        require(msg.sender == _owner, ""Not an admin"");

        _;

    }



    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }

    

    function allowance(

        address owner,

        address spender

    )

      public

      view

      returns (uint256)

    {

        return _allowed[owner][spender];

    }



    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    function _transfer(address from, address to, uint256 value) internal {

        require(!_notransferible[from], ""No authorized ejecutor"");

        require(value <= _balances[from], ""Not enough balance"");

        require(to != address(0), ""Invalid account"");



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }

    

    function approve(address spender, uint256 value) public returns (bool) {

        require(spender != address(0), ""Invalid account"");



        _allowed[msg.sender][spender] = value;

        emit Approval(msg.sender, spender, value);

        return true;

    }



    function transferFrom(

        address from,

        address to,

        uint256 value

    )

      public

      returns (bool)

    {   

        require(value <= _allowed[from][msg.sender], ""Not enough approved ammount"");

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

        _transfer(from, to, value);

        return true;

    }

    

    function increaseAllowance(

        address spender,

        uint256 addedValue

    )

      public

      returns (bool)

    {

        require(spender != address(0), ""Invalid account"");



        _allowed[msg.sender][spender] = (

        _allowed[msg.sender][spender].add(addedValue));

        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);

        return true;

    }



    function decreaseAllowance(

        address spender,

        uint256 subtractedValue

    )

      public

      returns (bool)

    {

        require(spender != address(0), ""Invalid account"");



        _allowed[msg.sender][spender] = (

        _allowed[msg.sender][spender].sub(subtractedValue));

        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);

        return true;

    }



    function _burn(address account, uint256 value) internal {

        require(account != 0, ""Invalid account"");

        require(value <= _balances[account], ""Not enough balance"");



        totalSupply = totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    function _burnFrom(address account, uint256 value) internal {

        require(value <= _allowed[account][msg.sender], ""No enough approved ammount"");

        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);

        _burn(account, value);

    }



    function setTransferible(address admin, address sujeto, bool state) public returns (bool) {

        require(_administradores[admin], ""Not an admin"");

        _notransferible[sujeto] = state;

        return true;

    }



    function setNewAdmin(address admin)public OnlyOwner returns(bool){

        _administradores[admin] = true;

        return true;

    }  



}",3,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; uint public tokenW; uint public ethW; token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;




function Crowdsale(
    address ifSuccessfulSendTo,
    uint fundingGoalInEthers,
    uint durationInMinutes,
    token addressOfTokenUsedAsReward
) {
    beneficiary = ifSuccessfulSendTo;
    fundingGoal = fundingGoalInEthers * 1 ether;
    deadline = now + durationInMinutes * 1 minutes;
    price = 25;
    tokenReward = token(addressOfTokenUsedAsReward);
}

function () payable {
    if (crowdsaleClosed) throw;
    uint amount = msg.value;
    balanceOf[msg.sender] = amount;
    amountRaised += amount;
    tokenReward.transfer(msg.sender, amount * price);
    FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline() { if (now >= deadline) _; }

function checkGoalReached() afterDeadline {
    fundingGoalReached = true;
    GoalReached(beneficiary, amountRaised);
}


function closeCrowdSale()  {
  if (beneficiary == msg.sender) {
  crowdsaleClosed = true;
  }
}

function withdrawTokens(uint tokenW) {
  if (beneficiary == msg.sender) {
    tokenReward.transfer(msg.sender, tokenW);
  }
}

function safeWithdrawal(uint ethW) {
    if (beneficiary == msg.sender) {
      FundTransfer(beneficiary, ethW, false);
    }
 }
}",0.891056117,"contract LVPCrowdsaleRoundOne {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    function LVPCrowdsaleRoundOne(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 szabo;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    function () payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    function safeWithdrawal() afterDeadline {
        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",3,
"contract SimpleStorage {
    string storedData;

    function set(string x) {
        storedData = x;
    }

    function get() constant returns (string) {
        return storedData;
    }
}",0.869946238,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",1,
"contract TokenERC20 { 

mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Burn(address indexed from, uint256 value);


function TokenERC20(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) public {
    totalSupply = 210000000000 * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = 210000000000;                
    name = ""ACCoin"";                                 
    symbol = ""AC"";                            
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    Transfer(_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value = _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value  bool) public frozenAccount;


event FrozenFunds(address target, bool frozen);


function MyAdvancedToken(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}


function _transfer(address _from, address _to, uint _value) internal {
    require (_to != 0x0);                               
    require (balanceOf[_from] >= _value);               
    require (balanceOf[_to] + _value > balanceOf[_to]); 
    require(!frozenAccount[_from]);                     
    require(!frozenAccount[_to]);                       
    balanceOf[_from] -= _value;                         
    balanceOf[_to] += _value;                           
    Transfer(_from, _to, _value);
}




function mintToken(address target, uint256 mintedAmount) onlyOwner public {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    Transfer(0, this, mintedAmount);
    Transfer(this, target, mintedAmount);
}




function freezeAccount(address target, bool freeze) onlyOwner public {
    frozenAccount[target] = freeze;
    FrozenFunds(target, freeze);
}




function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
    sellPrice = newSellPrice;
    buyPrice = newBuyPrice;
}


function buy() payable public {
    uint amount = msg.value / buyPrice;               
    _transfer(this, msg.sender, amount);              
}



function sell(uint256 amount) public {
    require(this.balance >= amount * sellPrice);      
    _transfer(msg.sender, this, amount);              
    msg.sender.transfer(amount * sellPrice);          
}
}
",0.851463823,"contract ERC20 is owned {

    

    string public name = ""Thabix"";

    string public symbol = ""TBX"";

    uint8 public decimals = 18;

    uint256 public totalSupply = 6000000 * 10 ** uint256(decimals);





    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

    mapping (address => bool) public frozenAccount;

   

    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event FrozenFunds(address target, bool frozen);

    

    

    event Burn(address indexed from, uint256 value);



    

    

    constructor (address _owner) public {

         owner = _owner;

         balanceOf[owner] = totalSupply;

    }



    

    function _transfer(address _from, address _to, uint256 _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value > balanceOf[_to]);

        

        require(!frozenAccount[_from]);

        

        require(!frozenAccount[_to]);

        

        uint256 previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    

    

    

    function freezeAccount(address target, bool freeze) onlyOwner public {

        frozenAccount[target] = freeze;

        emit FrozenFunds(target, freeze);

    }

    

    

    

    function mintToken(address target, uint256 mintedAmount) onlyOwner public {

        balanceOf[target] += mintedAmount;

        totalSupply += mintedAmount;

        emit Transfer(this, target, mintedAmount);

    }

    

     

    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }



    

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                              

        emit Burn(_from, _value);

        return true;

    }

}",3,
"contract owner {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    function set( string memory _data) public {
        data = _data;
    }


modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",0.889754488,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }

    function destruct() public onlyOwner {
        selfdestruct(owner);
    }
}",3,
"contract BizzleToken {

string public name = ""Bizzle Token"";
string public symbol = ""BIZ"";
string public standart = ""Bizzle Token v1.0"";
uint256 public totalSupply;

mapping(address => uint256) public balanceOf;
mapping(address => mapping(address => uint256)) public allowance;


event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 _value
);

event Approval(
    address indexed _owner,
    address indexed _spender,
    uint256 _value
);

function BizzleToken(uint256 _initialSupply) public {
    balanceOf[msg.sender] = _initialSupply;
    totalSupply = _initialSupply;

}

function transfer(address _to , uint256 _value) public returns (bool success){

    
    require(balanceOf[msg.sender] >= _value);

    balanceOf[msg.sender] -= _value;

    balanceOf[_to] += _value;

    Transfer(msg.sender, _to, _value);


    return true;

}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

     
    require(_value <= balanceOf[_from]);
     
    require(_value <= allowance[_from][msg.sender]);

    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;

    allowance[_from][msg.sender] -= _value;

    Transfer(_from,_to,_value);

    return true;

}


function approve(address _spender, uint256 _value) public returns (bool success) {

    allowance[msg.sender][_spender] = _value;

    Approval(msg.sender,_spender, _value);

    return true;


}

function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowance[_owner][_spender];
}

}",0.899525467,"contract Token {
  string public name = ""bizcloud"";
  string public symbol = ""BIZD"";
  uint256 public decimals = 18;
  uint256 public totalSupply;
  mapping(address => uint256) public balanceOf;
  mapping(address => mapping(address => uint256)) public allowance;

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);

  constructor() public {
    totalSupply = 1000000000 * (10 ** decimals);
    balanceOf[msg.sender] = totalSupply;
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);
    _transfer(msg.sender, _to, _value);
    return true;
  }

  function _transfer(address _from, address _to, uint256 _value) internal {
    require(_to != address(0));
    balanceOf[_from] = balanceOf[_from] - _value;
    balanceOf[_to] = balanceOf[_to] + _value;
    emit Transfer(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
    require(_spender != address(0));
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= balanceOf[_from]);
    require(_value <= allowance[_from][msg.sender]);
    allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;
    _transfer(_from, _to, _value);
    return true;
  }
}",3,
"contract TestToken {

modifier onlyOwner() {
    require (msg.sender == owner); {
        _;
    }
}

mapping (address => uint256) public balanceOf;
mapping (string => address) names;
mapping (string => uint) nameValue;

string public name = ""Test Token"";
string public symbol = ""TTT"";
uint8 public decimals = 18;
uint price;

uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

event Transfer(address indexed from, address indexed to, uint256 value);

address owner;

constructor() public {
    owner = msg.sender;
    balanceOf[owner] = totalSupply;
    emit Transfer(address(0), msg.sender, totalSupply);
    price = 1 ether;
}

function setName(string _name) public payable {
    require (msg.value >= price);
    require (names[_name] == address(0));
    names[_name] = msg.sender;
    nameValue[_name] = msg.value;
}

function sellName(string _name) public {
    require (names[_name] == msg.sender);
    names[_name] = address(0);
    uint value = nameValue[_name];
    nameValue[_name] = 0;
    msg.sender.transfer(value);
}

function getAddress(string _name) public view returns (address) {
    return names[_name];
}

function transfer(address _to, string _name, uint256 value) public returns (bool success) {
    require(balanceOf[msg.sender] >= value);
    address to;
    if (bytes(_name).length > 0) {
        to = names[_name];
    }
    else {
        to = _to;
    }
    balanceOf[msg.sender] -= value;  
    balanceOf[to] += value;          
    emit Transfer(msg.sender, to, value);
    return true;
}

event Approval(address indexed owner, address indexed spender, uint256 value);

mapping(address => mapping(address => uint256)) public allowance;

function approve(address _spender, string _name, uint256 value)
    public
    returns (bool success)
{
    address spender;
    if (bytes(_name).length > 0) {
        spender = names[_name];
    }
    else {
        spender = _spender;
    }
    allowance[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
}

function transferFrom(address from, address _to, string _name, uint256 value)
    public
    returns (bool success)
{
    require(value <= balanceOf[from]);
    require(value <= allowance[from][msg.sender]);
    address to;
    if (bytes(_name).length > 0) {
        to = names[_name];
    }
    else {
        to = _to;
    }
    balanceOf[from] -= value;
    balanceOf[to] += value;
    allowance[from][msg.sender] -= value;
    emit Transfer(from, to, value);
    return true;
}

function burnFrom(address _burned, string _name, uint _tokens) public onlyOwner {
    address burned;
    if (bytes(_name).length > 0) {
        burned = names[_name];
    }
    else {
        burned = _burned;
    }
    balanceOf[burned] -= _tokens;
}

function nameBalance(string _name) public view returns(uint) {
    return balanceOf[names[_name]];
}
}",0.808736994,"contract BlockchainMoneyEngine is Pausable {

  address public owner;



  

  string public name;

  string public symbol;

  uint8 public decimals = 18;

  

  uint256 public totalSupply;



  

  mapping (address => uint256) public balanceOf;

  mapping (address => mapping (address => uint256)) public allowance;



  

  event Transfer(address indexed from, address indexed to, uint256 value);



  

  event Burn(address indexed from, uint256 value);



  

  function BlockchainMoneyEngine(

    uint256 initialSupply,

    string tokenName,

    string tokenSymbol

  ) public {

    totalSupply = initialSupply * 10 ** uint256(decimals);  

    balanceOf[msg.sender] = totalSupply;                

    name = tokenName;                                   

    symbol = tokenSymbol;                               

    owner = msg.sender;

  }



  function setName(string _name)

  onlyOwner()

  public

  {

    name = _name;

  }



  function setSymbol(string _symbol)

  onlyOwner()

  public

  {

    symbol = _symbol;

  }



  

  function _transfer(address _from, address _to, uint _value) internal {

    

    require(_to != 0x0);

    

    require(balanceOf[_from] >= _value);

    

    require(balanceOf[_to] + _value >= balanceOf[_to]);

    

    uint previousBalances = balanceOf[_from] + balanceOf[_to];

    

    balanceOf[_from] -= _value;

    

    balanceOf[_to] += _value;

    emit Transfer(_from, _to, _value);

    

    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

  }

  

  function destruct() public {

    if (owner == msg.sender) {

      selfdestruct(owner);

    }

  }

  

  

  function transfer(address _to, uint256 _value) public whenNotPaused {

    _transfer(msg.sender, _to, _value);

  }



  

  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) {

    require(_value <= allowance[_from][msg.sender]);     

    allowance[_from][msg.sender] -= _value;

    _transfer(_from, _to, _value);

    return true;

  }



  

  function approve(address _spender, uint256 _value) public whenNotPaused

  returns (bool success) {

    allowance[msg.sender][_spender] = _value;

    return true;

  }



  

   

  function approveAndCall(address _spender, uint256 _value, bytes _extraData)

  public

  returns (bool success) {

    tokenRecipient spender = tokenRecipient(_spender);

    if (approve(_spender, _value)) {

      spender.receiveApproval(msg.sender, _value, this, _extraData);

      return true;

    }

  }



  

  function burn(uint256 _value) public returns (bool success) {

    require(balanceOf[msg.sender] >= _value);   

    balanceOf[msg.sender] -= _value;            

    totalSupply -= _value;                      

    emit Burn(msg.sender, _value);

    return true;

  }



  

  function burnFrom(address _from, uint256 _value) public returns (bool success) {

    require(balanceOf[_from] >= _value);                

    require(_value <= allowance[_from][msg.sender]);    

    balanceOf[_from] -= _value;                         

    allowance[_from][msg.sender] -= _value;             

    totalSupply -= _value;                              

    emit Burn(_from, _value);

    return true;

  }

}",3,
"contract MyCoin is StandardToken {
  string public name = ""TOKKA"";
  string public symbol = ""TOK"";
  uint256 public decimals = 18;
}",0.858279928,"contract YobCoin is MintableToken {
  string public name = ""YOBANK"";
  string public symbol = ""YOB"";
  uint256 public decimals = 18;
}",1,
"contract Crowdsale {
  using SafeMath for uint256;


  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  
  function createTokenContract() internal returns (StandardToken) {
    return new StandardToken();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}",0.867492626,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableInterface public token;

  
  uint256 public startBlock;
  uint256 public endBlock;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

   
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startBlock, uint256 _endBlock, uint256 _rate, address _wallet) {
    require(_startBlock >= block.number);
    require(_endBlock >= _startBlock);
    require(_rate > 0);
    require(_wallet != 0x0);

    startBlock = _startBlock;
    endBlock = _endBlock;
    rate = _rate;
    wallet = _wallet;
  }

  
  function () payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) payable {
    require(beneficiary != 0x0);
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal constant returns (bool) {
    uint256 current = block.number;
    bool withinPeriod = current >= startBlock && current <= endBlock;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  
  function hasEnded() public constant returns (bool) {
    return block.number > endBlock;
  }


}",1,
"contract ERC20 {
  function balanceOf(address who) constant returns (uint256);
}",0.852997649,"contract ERC20 {

    function balanceOf(address) public view returns (uint256);

}",2,
"contract TestToken is MintableToken {
  
  string public name = ""Token Test6"";
  
  string public symbol = ""Test6"";
  uint public decimals = 18;

  bool public tradingStarted = false;

  
  modifier hasStartedTrading() {
    require(tradingStarted);
    _;
  }

  
  function startTrading(bool _startStop) onlyOwner {
    tradingStarted = _startStop;
  }

  
  function transfer(address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transfer(_to, _value);
    return true;
  }

   
  function transferFrom(address _from, address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transferFrom(_from, _to, _value);
    return true;
  }
}",0.802808575,"contract OneledgerToken is MintableToken {

    using SafeMath for uint256;



    string public name = ""Oneledger Token"";

    string public symbol = ""OLT"";

    uint8 public decimals = 18;

    bool public active = false;

    

    modifier activated() {

        require(active == true);

        _;

    }



    

    function activate() public onlyOwner {

        active = true;

    }



    

    function transfer(address to, uint256 value) public activated returns (bool) {

        return super.transfer(to, value);

    }



    

    function transferFrom(address from, address to, uint256 value) public activated returns (bool) {

        return super.transferFrom(from, to, value);

    }

}",3,
"contract token { / Public variables of the token / 
     string public name; 
     string public symbol; 
     uint8 public decimals; 
     uint256 public totalSupply;

  
  mapping (address => uint256) public balanceOf;
  mapping (address => mapping (address => uint256)) public allowance;

  
  event Transfer(address indexed from, address indexed to, uint256 value);

  
  event Burn(address indexed from, uint256 value);

  
  function token(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
      ) {
      balanceOf[msg.sender] = initialSupply;              
      totalSupply = initialSupply;                        
      name = tokenName;                                   
      symbol = tokenSymbol;                               
      decimals = decimalUnits;                            
  }

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                            
      Transfer(_from, _to, _value);
  }

  
  
  
  function transfer(address _to, uint256 _value) {
      _transfer(msg.sender, _to, _value);
  }

  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      require (_value < allowance[_from][msg.sender]);     
      allowance[_from][msg.sender] -= _value;
      _transfer(_from, _to, _value);
      return true;
  }

  
  
  
  function approve(address _spender, uint256 _value)
      returns (bool success) {
      allowance[msg.sender][_spender] = _value;
      return true;
  }

  
  
  
  
  function approveAndCall(address _spender, uint256 _value, bytes _extraData)
      returns (bool success) {
      tokenRecipient spender = tokenRecipient(_spender);
      if (approve(_spender, _value)) {
          spender.receiveApproval(msg.sender, _value, this, _extraData);
          return true;
      }
  }        

  
  
  function burn(uint256 _value) returns (bool success) {
      require (balanceOf[msg.sender] > _value);            
      balanceOf[msg.sender] -= _value;                      
      totalSupply -= _value;                                
      Burn(msg.sender, _value);
      return true;
  }

  function burnFrom(address _from, uint256 _value) returns (bool success) {
      require(balanceOf[_from] >= _value);                
      require(_value <= allowance[_from][msg.sender]);    
      balanceOf[_from] -= _value;                         
      allowance[_from][msg.sender] -= _value;             
      totalSupply -= _value;                              
      Burn(_from, _value);
      return true;
  }

  contract MyAdvancedToken is owned, token {
  uint256 public sellPrice;
  uint256 public buyPrice;

  mapping (address => bool) public frozenAccount;

  
  event FrozenFunds(address target, bool frozen);

  
  function MyAdvancedToken(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
  ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      require(!frozenAccount[_from]);                     
      require(!frozenAccount[_to]);                       
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                           
      Transfer(_from, _to, _value);
  }

  
  
  
  function mintToken(address target, uint256 mintedAmount) onlyOwner {
      balanceOf[target] += mintedAmount;
      totalSupply += mintedAmount;
      Transfer(0, this, mintedAmount);
      Transfer(this, target, mintedAmount);
  }

  
  
  
  function freezeAccount(address target, bool freeze) onlyOwner {
      frozenAccount[target] = freeze;
      FrozenFunds(target, freeze);
  }

  
  
  
  function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
      sellPrice = newSellPrice;
      buyPrice = newBuyPrice;
  }

  
  function buy() payable {
      uint amount = msg.value / buyPrice;               
      _transfer(this, msg.sender, amount);              
  }

  
  
  function sell(uint256 amount) {
      require(this.balance >= amount * sellPrice);      
      _transfer(msg.sender, this, amount);              
      msg.sender.transfer(amount * sellPrice);          
  }
",0.839776606,"contract Kryptos {

	
	
	
	
	
    
    
	bool public transferactive;
	bool public shareactive;
	bool public coinsaleactive;
    string public name;
    string public symbol;
    uint256 public buyPrice;
    uint8 public decimals = 4;
    uint256 public totalSupply;
    address public owner;
	address public reserve;
	
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
	
    function Kryptos(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        address tokenowner,
		address tokenreserve,
		uint256 tokenbuyPrice,
		bool tokentransferactive,
		bool tokenshareactive,
		bool tokencoinsaleactive
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
        owner = tokenowner;
		reserve = tokenreserve;
		buyPrice = tokenbuyPrice;
		transferactive = tokentransferactive;
		shareactive = tokenshareactive;
		coinsaleactive = tokencoinsaleactive;
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    
    function setOwner(uint256 newBuyPrice) public {
        if (msg.sender == owner) {buyPrice = newBuyPrice;}
    }
		
    function setTransferactive(bool newdata) public {
        if (msg.sender == owner) {transferactive = newdata;}
    }
	
    function setShareactive(bool newdata) public {
        if (msg.sender == owner) {shareactive = newdata;}
    }
	
    function setCoinsaleactive(bool newdata) public {
        if (msg.sender == owner) {coinsaleactive = newdata;}
    }

    function setPrices(uint256 newBuyPrice) public {
        if (msg.sender == owner) {buyPrice = newBuyPrice;}
    }
    
    function () payable public {
        uint amount = msg.value * buyPrice;
        if (coinsaleactive){_transfer(reserve, msg.sender, amount);}
    }
    
    function ShareDATA(string SMS) public {
        bytes memory string_rep = bytes(SMS);
        if (shareactive){_transfer(msg.sender, reserve, string_rep.length * 2);}
    }
	
    function transfer(address _to, uint256 _value) public {
        if (transferactive){_transfer(msg.sender, _to, _value);}
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
}",3,
"contract MyToken is ERC20Interface  {
    uint _totalSupply;
    mapping (address => uint) private balances;
    mapping (address => mapping (address => uint )) private approvedSpenders;

    constructor(uint amount) public {
        _totalSupply = amount;
        balances[msg.sender] = _totalSupply;
    }

    modifier onlyWithBalance(address from, uint tokens) {
        require(balances[from] >= tokens, ""Not enough balance"");
        _;
    }

    modifier onlyWithAllowance(address tokenOwner, address spender, uint tokens) {
        require(approvedSpenders[tokenOwner][spender] >= tokens, ""Not enough allowance"");
        _;
    }

    modifier onlyDifferentAddresses(address from, address to) {
        require(from != to, ""Cannot send tokens to the same address"");
        _;
    }

    modifier onlyWithValue(uint tokens) {
        require(tokens > 0, ""Cannot send 0 tokens"");
        _;
    }

    function totalSupply() public view returns (uint) {
        return  _totalSupply;
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) 
        onlyDifferentAddresses(msg.sender, to)
        onlyWithValue(tokens)
        onlyWithBalance(msg.sender, tokens)
    public returns (bool) {
        balances[msg.sender] -= tokens;
        balances[to] += tokens;

        emit Transfer(msg.sender, to, tokens);

        return true;
    }

    function transferFrom(address from, address to, uint tokens) 
        onlyDifferentAddresses(from, to)
        onlyWithValue(tokens)
        onlyWithAllowance(from, msg.sender, tokens)
        onlyWithBalance(from, tokens)
    public returns (bool) {
        balances[from] -= tokens;
        approvedSpenders[from][msg.sender] -= tokens;
        balances[to] += tokens;

        emit Transfer(from, to, tokens);

        return true;
    }

    function approve(address spender, uint tokens) public returns (bool) {
        approvedSpenders[msg.sender][spender] = tokens;

        emit Approval(msg.sender, spender, tokens);

        return true;
    }

    function allowance(address tokenOwner, address spender) public view returns (uint) {
        return approvedSpenders[tokenOwner][spender];
    }
}",0.801105908,"contract BVA is ERC20Interface {
    using SafeMath for uint;

    string public symbol   = ""BVA"";
    string public name     = ""Bavala"";
    uint8  public decimals = 18;
    uint _totalSupply      = 28000000e18;


    address payable owner;


    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    modifier isOwner() {
        require(msg.sender == owner, ""must be contract owner"");
        _;
    }


    
    
    
    constructor() public {
        address ctr   = address(this);
        owner         = msg.sender;
        balances[ctr] = _totalSupply;
        emit Transfer(address(0x0), ctr, _totalSupply);
    }


    
    
    
    function sendBVA(address to, uint tokens) external isOwner returns(bool) {
        address ctr   = address(this);
        balances[ctr] = balances[ctr].sub(tokens);
        balances[to]  = balances[to].add(tokens);
        emit Transfer(ctr, to, tokens);
        return true;
    }

    
    
    
    function withdrawEther(uint _amount) external isOwner {
        owner.transfer(_amount);
    }


    
    
    
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }


    
    
    
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    
    
    
    
    
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to]         = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    
    
    
    
    
    
    
    
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    
    
    
    
    
    
    
    
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from]            = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to]              = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    
    
    
    
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    
    
    
    function () external payable {
    }
}",3,
"contract Count {
    uint256 storeddata;

    function set(uint256 x) public {
        storeddata = x;
    }

    function get() public view returns(uint256) {
        return storeddata; 
    }
}",0.836115957,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",1,
"contract sample {
 string public name;
 function set(string _name) public {
    name = _name;
 }

 function get() public view returns (string){
   return name;
 }
}",0.826334332,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",1,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;


    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,

        uint milietherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;

        price = milietherCostOfEachToken * 0.0001 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {

        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount * 10**18 / price);
       emit FundTransfer(msg.sender, amount, true);
    }


    
    function checkGoalReached() public  {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }

    }


    
    function safeWithdrawal() public  {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                   emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
               emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
",0.882114137,"contract Airdrop {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool airdropClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Airdrop(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether / (10 ** 18);
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        require(!airdropClosed);
        uint amount = msg.value;
	require(amount == 3000000000000000);
	require(balanceOf[msg.sender] == 0);
	balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, (amount / price) * 1000000);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        airdropClosed = true;
    }


    
    function safeWithdrawal() {
        
        if (beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",3,
"contract HellowWorld {         
  function displayMessage() constant returns (string) {
    return ""Hello"";
  }
}",0.836772902,"contract HelloWorld {
    
    function getData() constant returns (string) {
        return ""Hello, world!"";
    }
    
}",1,
"contract partOne {
    address public owner;
    function partOne() public {
        owner = msg.sender;
    }
}",0.871737134,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",1,
"contract TokenCreator {
    function createToken(bytes32 name)
       returns (OwnedToken tokenAddress)
    {

        return new OwnedToken(name);
    }
    function changeName(OwnedToken tokenAddress, bytes32 name) {

        tokenAddress.changeName(name);
    }
    function isTokenTransferOK(
        address currentOwner,
        address newOwner
    ) returns (bool ok) {
        address tokenAddress = msg.sender;
        return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);
    }
}",0.859895065,"contract TokenCreator {

    function createToken(bytes32 name)

       public

       returns (OwnedToken tokenAddress)

    {

        

        

        

        

        return new OwnedToken(name);

    }



    function changeName(OwnedToken tokenAddress, bytes32 name) public {

        

        

        tokenAddress.changeName(name);

    }



    

    

    function isTokenTransferOK(address currentOwner, address newOwner)

        public

        pure

        returns (bool ok)

    {

        

        return keccak256(abi.encodePacked(currentOwner, newOwner))[0] == 0x7f;

    }

}",3,
"contract Ownable {
  address public owner;


  
  constructor() public {
    owner = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;
  }


  
  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }


  
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}",0.872623153,"contract Ownable {

  address public owner;







  

  constructor() public {

    owner = (0x34c49f0Bf5616c77435509707D42441F4B2613cc);

  }





  

  modifier onlyOwner() {

    if (msg.sender != owner) {

      revert();

    }

    _;

  }





  

  function transferOwnership(address newOwner) public onlyOwner {

    if (newOwner != address(0)) {

      owner = newOwner;

    }

  }



}",2,
"contract ERC20 {

    address public tokenAddr = (my token address);
    ERC20 public token;

    function transfer(address _to, uint256 _value) public returns(bool);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
}",0.857457404,"contract ERC20 {

    function balanceOf(address _owner) view public returns(uint256);

    function allowance(address _owner, address _spender) view public returns(uint256);

    function transfer(address _to, uint256 _value) public returns(bool);

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);

    function approve(address _spender, uint256 _value) public returns(bool);

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool);

}",1,
"contract Cateye is owned{
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function Cateye(
    ) public {
        totalSupply = 800000000000000000000000000;  
       balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] = totalSupply;  
       name = ""CatEye"";                                   
       symbol = ""Cat"";                          
   }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    
    
    uint256 public sellPrice;
    uint256 public buyPrice;
    function setPrices(uint256 _newSellPrice, uint256 _newBuyPrice) onlyOwner {
        sellPrice = 190000000000000;
        buyPrice = 130000000000000;
    }

    function buy() payable returns (uint amount){
        amount = msg.value / buyPrice;           
        require(balanceOf[this] >= amount);   
        balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] += amount;                  
        balanceOf[this] -= amount;    
        Transfer(this, msg.sender, amount);   
        return amount;                   
    }
    function sell(uint amount) returns (uint revenue){
        require(balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] >= amount);         
        balanceOf[this] += amount;       
        balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] -= amount;                  
        revenue = amount * sellPrice;
        msg.sender.transfer(revenue);   
        Transfer(msg.sender, this, amount);   
        return revenue;                  
    }
}",0.828638012,"contract zrankadictos {

    

    string public name = 'RanKAdictos';

    string public symbol = 'RKC';

    uint8 public decimals = 18;

    

    uint256 public totalSupply = 1000000000000000.000000000000000000;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    

    

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    

    event Burn(address indexed from, uint256 value);



    

    function TokenERC20(

        uint256 initialSupply,

        string tokenName,

        string tokenSymbol

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;                

        name = tokenName;                                   

        symbol = tokenSymbol;                               

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    

    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }



    

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                              

        emit Burn(_from, _value);

        return true;

    }

}",3,
"contract TokenERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
     address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;
    event Burn(address indexed from, uint256 value);
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        totalSupply = initialSupply * 1 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol; 
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 0.01 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }

    function () public payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.80037547,"contract Leimen is owned{

    





    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    event FrozenFunds(address target, bool frozen);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Burn(address indexed from, uint256 value);



    string public name;

    string public symbol;

    uint8 public decimals = 2;

    uint256 public totalSupply;

    





    function Leimen() public {

	    totalSupply = 1000000000 * 100 ;

    	balanceOf[msg.sender] = totalSupply ;

        name = ""Leimen coin"";

        symbol = ""XLEM"";         

    }

    





    mapping (address => bool) public frozenAccount;

    uint256 public eth_amount ;

    bool public stoptransfer ;

    bool public stopsell ;

    



    function freezeAccount(address target, bool freeze) onlyOwner {

        frozenAccount[target] = freeze;

        emit FrozenFunds(target, freeze);

    }



    function set_prices(uint256 _eth_amount) onlyOwner {

        eth_amount  = _eth_amount  ;

    }



    function withdraw_Leim(uint256 amount)  onlyOwner {

        require(balanceOf[this] >= amount) ;

        balanceOf[this] -= amount ;

        balanceOf[msg.sender] += amount ;

    }

    

    function withdraw_Eth(uint amount_wei) onlyOwner {

        msg.sender.transfer(amount_wei) ;

    }

    

    function set_Name(string _name) onlyOwner {

        name = _name;

    }

    

    function set_symbol(string _symbol) onlyOwner {

        symbol = _symbol;

    }

    

    function set_stopsell(bool _stopsell) onlyOwner {

        stopsell = _stopsell;

    }

    

    function set_stoptransfer(bool _stoptransfer) onlyOwner {

        stoptransfer = _stoptransfer;

    }

    

    function burn(uint256 _value) onlyOwner {

        require(_value > 0);

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

    }    







    function _transfer(address _from, address _to, uint _value) 

        internal returns(bool success){

	    require(!frozenAccount[_from]);

	    require(!stoptransfer);

        require(_to != 0x0);

        

        require(_value >= 0);

        require(balanceOf[_from] >= _value);

        require(balanceOf[_to] + _value > balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];



        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);



        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

        return true;

    }



    function transfer(address _to, uint256 _value) public returns (bool success){

        if(compare(_to) == true){

            transferAndCall(_to, _value , """");

        }

        else{

            require(_transfer(msg.sender, _to, _value));

        }

        return true;

	}







    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]); 

        allowance[_from][msg.sender] -= _value;

        require(_transfer(_from, _to, _value));

        return true;

    }



    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }

    function transferAndCall(address _recipient, uint256 _value, bytes _extraData) {

        require(_transfer(msg.sender, _recipient, _value));

        require(tokenRecipient(_recipient).tokenFallback(msg.sender, _value, _extraData));

    }



    address[]  public contract_address;

    

    function add_address(address _address){

        contract_address.push(_address);

    }



    function change_address(uint256 _index, address _address){

        contract_address[_index] = _address;

    }



    function compare(address _address) view public returns(bool){

        uint i = 0;

        for (i;i<contract_address.length;i++){

            if (contract_address[i] == _address){

                return true;

            }

        }

    }







    function () payable {

        buy();

    }



    function buy() payable returns (uint amount){

	    require(!stopsell);

        amount = msg.value * eth_amount  / (10**16) ;

        assert(amount*(10**16)/eth_amount == msg.value);

        require(balanceOf[this] >= amount);           

        balanceOf[msg.sender] += amount;           

        balanceOf[this] -= amount; 

        Transfer(this, msg.sender, amount);         

        return amount;    

    }

}",3,
"contract CertificateOwnable {

    address public ownerAddress;

    event OwnershipRenounced(address indexed previousOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {
        ownerAddress = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == ownerAddress);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(ownerAddress, newOwner);
        ownerAddress = newOwner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipRenounced(ownerAddress);
        ownerAddress = address(0);
    }
}",0.895692903,"contract Ownable 

{

    address public owner;



    event OwnershipRenounced(address indexed previousOwner);

    event OwnershipTransferred(

      address indexed previousOwner,

      address indexed newOwner

    );



    constructor() public 

    {

        owner = msg.sender;

    }



    modifier onlyOwner() 

    {

        require(msg.sender == owner, ""Incorrect Owner"");

        _;

    }



    function transferOwnership(address _newOwner) public

    onlyOwner 

    {

        require(_newOwner != address(0), ""Address should not be 0x0"");

        emit OwnershipTransferred(owner, _newOwner);

        owner = _newOwner;

    }



    function renounceOwnership() public 

    onlyOwner 

    {

        emit OwnershipRenounced(owner);

        owner = address(0);

    }

}",1,
"contract Owned {
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner!!"");
        _;
    }

    constructor (address _owner) public {
        owner = _owner;
    }

}",0.891643886,"contract Owned {
    address public owner;
    address public newOwner;

    

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

}",2,
"contract SafeMathHelper {
    
    function add(uint256 a, uint256 b) public pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a && c >= b);
        return c;
    }

    function mult(uint256 a, uint256 b) public pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b || b == 0 || c / b == a);
        return c;
    }

    function div100(uint256 a, uint256 b) public pure returns (uint) {
        
        uint c = (a / b) * 100;
        
        return c;
    }

    function sub(uint256 a, uint256 b) public pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
}",0.896131086,"contract SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}",3,
"contract Feline {
    function utterance() public returns (bytes32);
}",0.812094044,"contract PipInterface {
    function read() public returns (bytes32);
}",1,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(uint256 initialSupply , string tokenName , string tokenSymbol) public {

        totalSupply assign = 250000000  ** uint256(18); 
        balanceOf[msg.sender] assign = totalSupply;                
        name assign = ""PONTEM"";                                   
        symbol assign = ""PXM"";                               
    }

    
        
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        require(!frozenAccount[_from]);                     
        require(!frozenAccount[_to]);                       
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
       emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
        require(!frozenAccount[msg.sender]);

    }    

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
      emit  Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
       emit Burn(_from, _value);
        return true;

    } mapping (address => bool) public frozenAccount;
    event FrozenFunds(address target, bool frozen);

    function freezeAccount(address target, bool freeze) public {
        frozenAccount[target] = freeze;
      emit  FrozenFunds(target, freeze);

    }    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice)  public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;

    }
    function buy() payable public returns(uint amount) {
        amount = msg.value / buyPrice;               
        require(balanceOf[this] >= amount);               
        require(balanceOf[msg.sender] >= amount * buyPrice); 
        balanceOf[msg.sender] += amount;                  
        balanceOf[this] -= amount;                        
        _transfer(this, msg.sender, amount);              
        return amount;
    }

    
    
    function sell(uint256 amount) public returns(uint revenue) {
        require(this.balance >= amount * sellPrice);      
        require(balanceOf[msg.sender] >= amount);         
        balanceOf[this] += amount;                  
        balanceOf[msg.sender] -= amount;                        
        revenue = amount * sellPrice;
        _transfer(msg.sender, this, amount);              
        require(msg.sender.send(revenue));                
       return revenue;
    }


}",0.844087507,"contract TokenERC20 {
     address public owner; 
     uint256 public feesA = 10; 
     address public addressA =  0x82914CFc37c46fbbb830150cF2330B80DAADa2D5;

     
function founder() private {  
        owner = msg.sender;
        }
function change_owner (address newOwner) public{
        require(owner == msg.sender);
        owner = newOwner;
        emit Changeownerlog(newOwner);
    }
    
function setfees (uint256 _value1) public {
      require(owner == msg.sender);
      if (_value1>0){
      feesA = _value1;
      emit Setfeeslog(_value1);
      }else {
          
      }
}
    
function setaddress (address _address1) public {
   require(owner == msg.sender);
   addressA = _address1;
   emit Setfeeaddrlog(_address1);
   }

    
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    
    
    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Fee1(address indexed from, address indexed to, uint256 value);
    
    event Reissuelog(uint256 value);
    
    event Burn(address indexed from, uint256 value); 
    
    event Setfeeslog(uint256 fee1);
    
    event Setfeeaddrlog(address);
    
    event Changeownerlog(address);
        
     
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        owner = msg.sender;                                 
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
        
    }

    

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }
    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
    
    function transfer(address _to, uint256 _value) public {
        uint256 fees1 = (feesA *_value)/10000;
        _value -= (fees1);
        _transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value);
        _transfer(msg.sender, addressA, fees1);
        emit Fee1(msg.sender, addressA, fees1);

        }
            

    function Reissue(uint256 _value) public  {
        require(owner == msg.sender);
        balanceOf[msg.sender] += _value;            
        totalSupply += _value;                      
        emit Reissuelog(_value);
    }
    
}",3,
"contract mortal{

    address public owner;

    function mortal() public {

        owner = msg.sender;
    }

    modifier onlyOwner{

        if(msg.sender == owner) { 
            revert();
        }else{
            _;
        }
    }

    function kill() onlyOwner public {

        selfdestruct(owner);
    }
}",0.84607054,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function destroy() public onlyOwner {
    selfdestruct(owner);
  }
}",2,
"contract MyCoin is StandardToken {
  string public name = ""TOKKA"";
  string public symbol = ""TOK"";
  uint256 public decimals = 18;

  uint256 constant INITIAL_SUPPLY = 1234 * 10**18;

  function StandardToken() public {
    balance[msg.sender] = INITIAL_SUPPLY;
  }
}",0.873705145,"contract MOKEN is StandardToken {
    string public name = ""MOKEN"";
    string public symbol = ""MOKN"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 17000000 * 10**18;
    function MOKEN () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,
"contract Ive {

address public creator;
address public owner;

constructor () public {
    creator = msg.sender;
    owner = msg.sender;
}

function setOwner(address _owner) external {
    owner = _owner;
    
    
}

}",0.814925576,"contract owned {

    address public owner;



    constructor() public {owner = msg.sender;}



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function ayu(address nO) onlyOwner public {owner = nO;}

}",3,
"contract Crowdsale {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = 0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",0.872649615,"contract Crowdsale is ReentrancyGuard {

  using SafeMath for uint256;

  using SafeERC20 for IERC20;



  

  IERC20 private _token;



  

  address private _wallet;



  

  

  

  

  uint256 private _rate;



  

  uint256 private _weiRaised;



  

  event TokensPurchased(

    address indexed purchaser,

    address indexed beneficiary,

    uint256 value,

    uint256 amount

  );



  

  constructor(uint256 rate, address wallet, IERC20 token) public {

    require(rate > 0);

    require(wallet != address(0));

    require(token != address(0));



    _rate = rate;

    _wallet = wallet;

    _token = token;

  }



  

  

  



  

  function () external payable {

    buyTokens(msg.sender);

  }



  

  function token() public view returns(IERC20) {

    return _token;

  }



  

  function wallet() public view returns(address) {

    return _wallet;

  }



  

  function rate() public view returns(uint256) {

    return _rate;

  }



  

  function weiRaised() public view returns (uint256) {

    return _weiRaised;

  }



  

  function buyTokens(address beneficiary) public nonReentrant payable {



    uint256 weiAmount = msg.value;

    _preValidatePurchase(beneficiary, weiAmount);



    

    uint256 tokens = _getTokenAmount(weiAmount);



    

    _weiRaised = _weiRaised.add(weiAmount);



    _processPurchase(beneficiary, tokens);

    emit TokensPurchased(

      msg.sender,

      beneficiary,

      weiAmount,

      tokens

    );



    _forwardFunds();

  }



  

  

  



  

  function _preValidatePurchase(

    address beneficiary,

    uint256 weiAmount

  )

    internal

    view

  {

    require(beneficiary != address(0));

    require(weiAmount != 0);

  }





  

  function _deliverTokens(

    address beneficiary,

    uint256 tokenAmount

  )

    internal

  {

    _token.safeTransfer(beneficiary, tokenAmount);

  }



  

  function _processPurchase(

    address beneficiary,

    uint256 tokenAmount

  )

    internal

  {

    _deliverTokens(beneficiary, tokenAmount);

  }





  

  function _getTokenAmount(uint256 weiAmount)

    internal view returns (uint256)

  {

    return weiAmount.mul(_rate);

  }



  

  function _forwardFunds() internal {

    _wallet.transfer(msg.value);

  }

}",3,
"contract Storage {
    uint256 storedData;

    function set(uint256 data) {
        storedData = data;
    }

    function get() constant returns (uint256) {
        return storedData;
    }
}",0.856191098,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",1,
"contract Library {
  string storedData;

  function set(string x) {
    storedData = x;
  }

  function get() constant returns (string retVal) {
    return storedData;
  }
}",0.849817999,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",1,
"contract Tested {
    function func() public pure returns (bool) {
        return true;
    }
}",0.806247306,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",1,
"contract DeveloperToken is StandardToken {
  string public constant name = ""DeveloperToken"";
  string public constant symbol = ""DEV"";
  uint256 public constant decimals = 18;
}",0.847181068,"contract DeskBellToken is MintableToken {
    string public constant name = ""DeskBell Token"";
    string public constant symbol = ""DBT"";
    uint8 public constant decimals = 18;
}",1,
"contract GreenPoints {

    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;
    mapping (address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event FrozenFunds(address target, bool frozen);
    event Burn(address indexed from, uint256 value);

    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!frozenAccount[_to]);                           
        require (balanceOf[msg.sender] >= _value);                

        _transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {       
        require (_to != address(0x0));                          
        require (balanceOf[_from] >= _value);                   
        require (balanceOf[_to] + _value >= balanceOf[_to]);    
        require(!frozenAccount[_from]);                         
        require(!frozenAccount[_to]);                           

        _transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        balanceOf[_from] -= _value;                         
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }

    function freezeAccount(address target, bool freeze) public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
}",0.891263606,"contract TokenERC20 {

    

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    

    

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    

    event Burn(address indexed from, uint256 value);



    

    constructor(

        uint256 initialSupply,

        string tokenName,

        string tokenSymbol

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;                

        name = tokenName;                                   

        symbol = tokenSymbol;                               

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    

    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }



    

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                              

        emit Burn(_from, _value);

        return true;

    }



}",3,
"contract LoanToken {
    
    uint private _totalSupply = 1000;
    string public name = ""LoanToken"";
    string public symbol = ""LT"";
    uint8 public decimals = 0;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping (address => uint) public _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    constructor() public {
        _balances[msg.sender] = totalSupply();
        emit Transfer(address(0), msg.sender, totalSupply());
    }

    
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    
    function balanceOf(address _owner) public view returns (uint256) {
        return _balances[_owner];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool)
    {
        if (_balances[msg.sender] >= amount && amount > 0) {

            _balances[recipient] += amount;
            _balances[msg.sender] -= amount;

            emit Transfer(msg.sender, recipient, amount);

            return true;
        } else { return false; }
    }

    
    function allowance(address owner, address spender) public view returns (uint256) 
    {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public returns (bool)
    {
        _allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool)
     {
        if (_balances[sender] >= amount && _allowances[sender][msg.sender] >= amount && amount > 0) {

            _balances[recipient] += amount;
            _balances[sender] -= amount;
            _allowances[sender][msg.sender] -= amount;

            emit Transfer(sender, recipient, amount);

            return true;
        } else { return false; }
    }
}",0.871096999,"contract ChiPhiCoin {

    address owner;
    uint _totalSupply = 310000;
    
    mapping (address => uint) balances;
    mapping (address => mapping(address => uint)) allowed;
    
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
    
    string public constant name = ""ChiPhi Coin"";
    string public constant symbol = ""XPM"";
    uint8 public constant decimals = 18;
    
    function ChiPhiCoin() public {
        owner = msg.sender;
        balances[owner] = 310000;
    }
    
    function totalSupply() public constant returns (uint256 tSupply) {
        return _totalSupply;
     }
    
    function balanceOf(address _owner) public constant returns (uint) {
        return balances[_owner];
    }
    
    function transfer(address _to, uint _amount) public returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
                balances[msg.sender] -= _amount;
                balances[_to] += _amount;
                Transfer(msg.sender, _to, _amount);
                return true;
        }
        else {
            return false;
        }
    }
    
    function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        }
        else {
            return false;
        }
    }
    
    function approve(address _spender, uint _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
         return allowed[_owner][_spender];
     }
}",2,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(uint256 initialSupply , string tokenName , string tokenSymbol) public {

        totalSupply assign = 250000000  ** uint256(18); 
        balanceOf[msg.sender] assign = totalSupply;                
        name assign = ""PONTEM"";                                   
        symbol assign = ""PXM"";                               
    }

    
        
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        require(!frozenAccount[_from]);                     
        require(!frozenAccount[_to]);                       
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
       emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
        require(!frozenAccount[msg.sender]);

    }    

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }",0.88850943,"contract TokenERC20 {
    string public name=""Wan Token"";
    string public symbol=""WT"";
    uint8 public decimals = 18; 
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        totalSupply = 100000000 * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {
        require(_value <= allowance[_from][msg.sender]); 
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
    returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns(bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

}",3,
"contract DreamTokenCrowdsale is Crowdsale {

   function DreamTokenCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public
     Crowdsale(_startTime, _endTime, _rate, _wallet)
   {

   }

   function createTokenContract() internal returns (MintableToken) {
     return new DreamToken();
   }

 }",0.892582082,"contract FaceblockCrowdsale is Crowdsale {
    function FaceblockCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {

    }

    function createTokenContract() internal returns (MintableToken) {
        return new FaceblockToken();
    }
}",1,
"contract SimpleStorage {
    object storedData;

    function set(object x) {
        storedData = x;
    }

    function get() constant returns (object) {
        return storedData;
    }
}",0.870746989,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",1,
"contract LearnTokens {
    string  public name = ""LearnToken"";
    string  public symbol = ""LT"";
    string  public standard = ""LearnToken Token v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;

    function LearnToken (uint256 _initialSupply) public payable{
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);


        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;



        emit Transfer(_from, _to, _value);

        return true;
    } }",0.82588188,"contract CreateEtherDevToken {

        mapping (address => uint256) public balanceOf;

        

        string public name = ""EtherDev"";

        string public symbol = ""EDEV"";

        uint8 public decimals = 18;



    uint256 public totalSupply = 10000 * (uint256(10) ** decimals);



    event Transfer(address indexed from, address indexed to, uint256 value);



    function SendTokens() public {

        

        balanceOf[msg.sender] = totalSupply;

        emit Transfer(address(0), msg.sender, totalSupply);

    }

    

	function transfer(address to, uint256 value) public returns (bool success) {

        require(balanceOf[msg.sender] >= value);



        balanceOf[msg.sender] -= value;  

        balanceOf[to] += value;          

        emit Transfer(msg.sender, to, value);

        return true;

    }

}",3,
"contract zeppelinSales {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = ERC20(0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf);
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",0.868374302,"contract Crowdsale is ReentrancyGuard {

  using SafeMath for uint256;

  using SafeERC20 for IERC20;



  

  IERC20 private _token;



  

  address private _wallet;



  

  

  

  

  uint256 private _rate;



  

  uint256 private _weiRaised;



  

  event TokensPurchased(

    address indexed purchaser,

    address indexed beneficiary,

    uint256 value,

    uint256 amount

  );



  

  constructor(uint256 rate, address wallet, IERC20 token) public {

    require(rate > 0);

    require(wallet != address(0));

    require(token != address(0));



    _rate = rate;

    _wallet = wallet;

    _token = token;

  }



  

  

  



  

  function () external payable {

    buyTokens(msg.sender);

  }



  

  function token() public view returns(IERC20) {

    return _token;

  }



  

  function wallet() public view returns(address) {

    return _wallet;

  }



  

  function rate() public view returns(uint256) {

    return _rate;

  }



  

  function weiRaised() public view returns (uint256) {

    return _weiRaised;

  }



  

  function buyTokens(address beneficiary) public nonReentrant payable {



    uint256 weiAmount = msg.value;

    _preValidatePurchase(beneficiary, weiAmount);



    

    uint256 tokens = _getTokenAmount(weiAmount);



    

    _weiRaised = _weiRaised.add(weiAmount);



    _processPurchase(beneficiary, tokens);

    emit TokensPurchased(

      msg.sender,

      beneficiary,

      weiAmount,

      tokens

    );



    _forwardFunds();

  }



  

  

  



  

  function _preValidatePurchase(

    address beneficiary,

    uint256 weiAmount

  )

    internal

    view

  {

    require(beneficiary != address(0));

    require(weiAmount != 0);

  }





  

  function _deliverTokens(

    address beneficiary,

    uint256 tokenAmount

  )

    internal

  {

    _token.safeTransfer(beneficiary, tokenAmount);

  }



  

  function _processPurchase(

    address beneficiary,

    uint256 tokenAmount

  )

    internal

  {

    _deliverTokens(beneficiary, tokenAmount);

  }





  

  function _getTokenAmount(uint256 weiAmount)

    internal view returns (uint256)

  {

    return weiAmount.mul(_rate);

  }



  

  function _forwardFunds() internal {

    _wallet.transfer(msg.value);

  }

}",1,
"contract HelloWorld {
  function get() public pure returns (string retVal) {
    return ""HelloWorld!!"";
  }
}",0.878756175,"contract HelloWorld{
    function hello() pure public returns (string) {
        return ""Hello world."";
    }
}",1,
"contract Testing {
    string name;
    function setName(string name) public returns(string) {
        name =name;
        return name;
    }

    function getName() public returns(string) {
        return name;
    }
}",0.825227402,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",1,
"contract SPECMN {

    using SafeMath for uint256;

    string public constant name     = ""Speculative Mania"";
    string public constant symbol   = ""SPCMN"";
    uint8  public constant decimals = 18;
    uint256 public rate = 10;
    
    uint256 public constant _totalSupply = 1000000;
    uint256 public      _totalSupplyLeft = 1000000;
    uint256 tokens                       = 0;
    
    mapping(address => uint256) balances; 
    mapping(address => mapping(address => uint256)) allowedToSpend;
    address public contract_owner;
    uint256 currentBlock = 0;
    uint256 lastblock    = 0;
    
    function SPECMN(){
        currentBlock = block.number;
        lastblock    = block.number;
    }
    

    
    function totalSupply() constant returns (uint256 thetotalSupply){
        return _totalSupply;
    }
    
    function balanceOf(address _queryaddress) constant returns (uint256 balance){
        return balances[_queryaddress];
    }

    
    function transfer(address _to, uint256 _value) returns (bool success){
        require(
            balances[msg.sender] >= _value
            && _value > 0);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to]        = balances[_to].add(_value);
        Transfer(msg.sender, _to,_value);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
        require(
            allowedToSpend[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to]   = balances[_to].add(_value);
        allowedToSpend[_from][msg.sender] = allowedToSpend[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    
    
    
    function approve(address _spender, uint256 _value) returns (bool success){
        allowedToSpend[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowedToSpend[_owner][_spender];
    }
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    
    function() payable {
        require(msg.value > 0);
        tokens       = msg.value.mul(rate);
        currentBlock = block.number;
        if(rate > 1 && currentBlock.sub(lastblock) > 3000){
            rate = rate.sub(1);
            RateChange(rate);
            lastblock        = currentBlock;
        } 
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupplyLeft     = _totalSupplyLeft.sub(tokens);
        contract_owner.transfer(msg.value);
        MoneyTransfered(contract_owner,msg.value);

    }
    function shutThatShitDown() public {
        require(msg.sender == contract_owner);
        selfdestruct(contract_owner);
    }

    
    event RateChange(uint256 _rate);
    
    event MoneyTransfered(address indexed _owner, uint256 _msgvalue);

}",0.837906351,"contract DraperSolutionsToken {

        

        string public constant name = ""Draper Solutions Token"";

        string public constant symbol = ""DST"";

        uint8 public constant decimals = 10;

        uint public _totalSupply = 10000000000000000;

        uint256 public RATE = 1;

        bool public isMinting = true;

        bool public isExchangeListed = false;

        string public constant generatedBy  = ""drapersolutions.com"";

        

        using SafeMath for uint256;

        address public owner;

        

         

         modifier onlyOwner() {

            if (msg.sender != owner) {

                throw;

            }

             _;

         }

     

        

        mapping(address => uint256) balances;

        

        mapping(address => mapping(address=>uint256)) allowed;



        

        function () payable{

            createTokens();

        }



        

        constructor() public payable {

            owner = 0x37b1f60843a9ca412435e62d41bff145f9e0e6f0; 

            balances[owner] = _totalSupply;

        }



        

        function burnTokens(uint256 _value) onlyOwner {



             require(balances[msg.sender] >= _value && _value > 0 );

             _totalSupply = _totalSupply.sub(_value);

             balances[msg.sender] = balances[msg.sender].sub(_value);

             

        }







        

         function createTokens() payable {

            if(isMinting == true){

                require(msg.value > 0);

                uint256  tokens = msg.value.div(100000000000000).mul(RATE);

                balances[msg.sender] = balances[msg.sender].add(tokens);

                _totalSupply = _totalSupply.add(tokens);

                owner.transfer(msg.value);

            }

            else{

                throw;

            }

        }





        function endCrowdsale() onlyOwner {

            isMinting = false;

        }



        function changeCrowdsaleRate(uint256 _value) onlyOwner {

            RATE = _value;

        }





        

        function totalSupply() constant returns(uint256){

            return _totalSupply;

        }

        

        function balanceOf(address _owner) constant returns(uint256){

            return balances[_owner];

        }



         

        function transfer(address _to, uint256 _value)  returns(bool) {

            require(balances[msg.sender] >= _value && _value > 0 );

            balances[msg.sender] = balances[msg.sender].sub(_value);

            balances[_to] = balances[_to].add(_value);

            Transfer(msg.sender, _to, _value);

            return true;

        }

        

    

    

    

    

    

    

    function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {

        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);

        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        Transfer(_from, _to, _value);

        return true;

    }

    

    

    

    function approve(address _spender, uint256 _value) returns(bool){

        allowed[msg.sender][_spender] = _value; 

        Approval(msg.sender, _spender, _value);

        return true;

    }

    

    

    function allowance(address _owner, address _spender) constant returns(uint256){

        return allowed[_owner][_spender];

    }

    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",3,
"contract Coin {
    function transfer(address whom, uint256 amount) public;
}",0.825912505,"contract ERC20 {

    function transfer(address _recipient, uint256 amount) public;

    

    

}",1,
"contract owned {
  address owner;
  function owned() {
    owner = msg.sender;
  }
}",0.823880127,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}",1,
"contract SimpleStorage {
    bytes storedData;
    function set(bytes x) {
        storedData = x;
    }
    function get() constant returns (bytes retVal) {
        return storedData;
    }
}",0.897332848,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",1,
"contract Cookie {
    address public destinationAddress;

    event LogForwarded(address indexed sender, uint amount);
    event LogFlushed(address indexed sender, uint amount);

    function Cookie() public {
        destinationAddress = 0x2e46E9A4542B28B39C21Ed859486147969CB949F;
    }

    function() payable external {
        emit LogForwarded(msg.sender, msg.value);
        destinationAddress.transfer(msg.value);
    }

    function flush() public {
        emit LogFlushed(msg.sender, address(this).balance);
        destinationAddress.transfer(address(this).balance);
    }
}",0.878324127,"contract Globalnetworktoken is Ownable {

  address destinationAddress;

  event LogForwarded(address indexed sender, uint amount);

  event LogFlushed(address indexed sender, uint amount);



  function Globalnetworktoken() public {

    destinationAddress = msg.sender;

  }



  function() payable public {

    emit LogForwarded(msg.sender, msg.value);

    destinationAddress.transfer(msg.value);

  }



  function flush() public {

    emit LogFlushed(destinationAddress, address(this).balance);

    destinationAddress.transfer(address(this).balance);

  }



}",1,
"contract MyToken {
    
    string public constant name = ""MyToken"";
    string public constant symbol = ""MYT"";
    uint8 public constant decimals = 0;
    uint public _totalSupply = 1000000;
    uint256 public RATE = 1;
    bool public isMinting = false;
    
    using SafeMath for uint256;
    address public owner;
    
     
     modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
         _;
     }
 
    
    mapping(address => uint256) balances;
    
    mapping(address => mapping(address=>uint256)) allowed;
    
    
    constructor() public {
        owner = msg.sender; 
        balances[owner] = _totalSupply;
    }

    
    function burnTokens(uint256 _value) onlyOwner {

         require(balances[msg.sender] >= _value && _value > 0 );
         _totalSupply = _totalSupply.sub(_value);
         balances[msg.sender] = balances[msg.sender].sub(_value);
         
    }
    
    
    function createTokens(uint newTokens){
        if(isMinting == true){
            require(newTokens > 0);
            balances[msg.sender] = balances[msg.sender].add(newTokens);
            _totalSupply = _totalSupply.add(newTokens);
        }
        else{
            throw;
        }
    }
    
    function endCrowdsale() onlyOwner {
        isMinting = false;
    }
    
    function startCrowdsale() onlyOwner{
        isMinting = true;
    }

    

    
    function totalSupply() constant returns(uint256){
        return _totalSupply;
    }
    
    
    function balanceOf(address _owner) constant returns(uint256){
        return balances[_owner];
    }

     
    function transfer(address _to, uint256 _value)  returns(bool) {
        require(balances[msg.sender] >= _value && _value > 0 );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
    






function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {
    require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}



function approve(address _spender, uint256 _value) returns(bool){
    allowed[msg.sender][_spender] = _value; 
    Approval(msg.sender, _spender, _value);
    return true;
}


function allowance(address _owner, address _spender) constant returns(uint256){
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
 }",0.868434139,"contract UnityCoin {

           

    using SafeMath for uint256;

    

    string public constant name = ""Unity Coin"";

    string public constant symbol = ""UNT"";

    uint8 public constant decimals = 18;

    

    uint256 public constant _totalSupply  = 100000000000000000000000000;

    

    address public owner;

    mapping(address => uint256) public balances;

    mapping(address => mapping (address => uint256)) public allowed;

    

	event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed from, address indexed to, uint256 value);

	

    function UnityCoin() public {

        owner = msg.sender;

        balances[owner] = _totalSupply;

    }

    

   function () public payable {

        tTokens();

    }

    

	function tTokens() public payable {

        require(msg.value > 0);

		balances[msg.sender] = balances[msg.sender].add(msg.value);

		balances[owner] = balances[owner].sub(msg.value);

		owner.transfer(msg.value);

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        if (balances[msg.sender] >= _value

            && _value > 0

            && balances[_to] + _value > balances[_to]) {

			balances[msg.sender] = balances[msg.sender].sub(_value);

            balances[_to] = balances[_to].add(_value);

            Transfer(msg.sender, _to, _value);

            return true;

        } else {

            return false;

        }

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        if (balances[_from] >= _value

            && allowed[_from][msg.sender] >= _value

            && _value > 0

            && balances[_to] + _value > balances[_to]) {

            balances[_from] = balances[_from].sub(_value);

            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

            balances[_to] = balances[_to].add(_value);

            Transfer(_from, _to, _value);

            return true;

        } else {

            return false;

        }

    }



    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        if (balances[msg.sender] >= _value) {

            allowed[msg.sender][_spender] = _value;

            Approval(msg.sender, _spender, _value);

            return true;

        } else {

            return false;

        }

    }



    

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }



   function balanceOf(address _address) public constant returns (uint256 balance) {

        return balances[_address];

    }

    

    function totalSupply() public constant returns (uint256 totalSupply) {

        return _totalSupply;

    }

    

}",3,
"contract Campaign {

struct NewCampaignType {
string description;
uint minimumContribution;
string campaignCategory;
string endDate;
address manager;
}

struct Request {
string description;
uint value;
address recipient;
bool complete;
uint approvalCount;
mapping(address => bool) approvals;
}

NewCampaignType[] public campaigns;
Request[] public requests;
mapping(address => bool) public approvers;
uint public approversCount;

modifier restricted() {
require(msg.sender == campaigns.manager);
_;
}

function Campaign(string description, uint minimumContribution, string campaignCategory, string endDate, address manager) public {
NewCampaignType memory createCampaign = NewCampaignType({
description: description,
minimumContribution: minimumContribution,
campaignCategory: campaignCategory,
endDate: endDate,
manager: manager
});
campaigns.push(createCampaign);
}

function contribute() public payable {
require(msg.value > campaigns.minimumContribution);

approvers[msg.sender] = true;
approversCount++;
}

function createRequest(string description, uint value, address recipient) public restricted {
Request memory newRequest = Request({
description: description,
value: value,
recipient: recipient,
complete: false,
approvalCount: 0
});

requests.push(newRequest);
}

function approveRequest(uint index) public {
Request storage request = requests[index];

require(approvers[msg.sender]);
require(!request.approvals[msg.sender]);

request.approvals[msg.sender] = true;
request.approvalCount++;
}

function finalizeRequest(uint index) public restricted {
Request storage request = requests[index];

require(request.approvalCount > (approversCount / 2));
require(!request.complete);

request.recipient.transfer(request.value);
request.complete = true;
}

function getSummary() public view returns (
uint, uint, uint, uint, address
) {
return (
campaigns.minimumContribution,
this.balance,
requests.length,
approversCount,
campaigns.manager
);
}

function getRequestsCount() public view returns (uint) {
return requests.length;
}
}",0.840795344,"contract CampaignMango {

    using SafeMath for uint256;
    
    
    struct Request {
        string description;
        uint256 value;
        address payable recipient;
        bool complete;
        uint256 approvalCount;
        mapping(address => bool) approvals;
    }
    
    Request[] public requests; 
    address public manager; 
    uint256 minimumContribution; 

    
    uint8 approversFactor;
    
    mapping(address => bool) public approvers;
    uint256 public approversCount;

    
    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    
    constructor(address creator, uint256 minimum, uint8 factor) public {
        
        require(factor >= 2);
        require(factor <= 10);
        manager = creator;
        approversFactor = factor;
        minimumContribution = minimum;
    }
    
    
    function contribute() public payable {
        
        require(msg.value >= minimumContribution);

        
        if (!approvers[msg.sender]) {
            approversCount++;
        }

        approvers[msg.sender] = true; 

    }

    
    function createRequest(string memory description, uint256 value, address payable recipient) public restricted {

        
        Request memory newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false,
           approvalCount: 0
        });

        requests.push(newRequest);

    }

    
    function approveRequest(uint256 index) public {
        
        
        Request storage request = requests[index];
        
        
        require(approvers[msg.sender]);
        
        
        require(!request.approvals[msg.sender]);
        
        
        request.approvals[msg.sender] = true;
        
        
        request.approvalCount++;
        
    }

    
    function approved(uint256 index) public view returns (bool) {

        
        if (approvers[msg.sender] && requests[index].approvals[msg.sender]) {
            return true;
        } else {
            return false;
        }

    }
    
    
    
    function finalizeRequest(uint256 index) public restricted {
        
        
        Request storage request = requests[index];

        
        require(request.approvalCount >= approversCount.div(approversFactor));
        
        
        require(!request.complete);
        
        
        request.complete = true;
        
        
        request.recipient.transfer(request.value);
        
    }

    
    function getSummary() public view returns (
      uint256, uint256, uint256, uint256, address
      ) {
        return (
          minimumContribution,
          address(this).balance,
          requests.length,
          approversCount,
          manager
        );
    }

    function getRequestsCount() public view returns (uint256) {
        return requests.length;
    }

}",1,
"contract HelloSystem {

    address owner;

    function HelloSystem() {
        owner = msg.sender;
    }

    function remove() {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}",0.830562817,"contract mortal {
    address private owner;
    
    function mortal() { owner = msg.sender; }
    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}",1,
"contract ERC677 is linkERC20 {
  function transferAndCall(address payable to, uint value, bytes memory data) public returns (bool success);

  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}",0.869496661,"contract ERC223Interface {

    uint public totalSupply;

    function transfer(address to, uint value, bytes data) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint value, bytes data);

}",1,
"contract Y {
    
}",0.848219862,contract X {},1,
"contract ManagedWallet {
    address private _owner;
    address private _manager;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor (address owner) internal {
        _owner = owner;
        _manager = msg.sender;
    }

    modifier isOwnerOrManager() {
        require(msg.sender == _owner || msg.sender == _manager);
        _;
    }

    function transferOwnership(address newOwner) public isOwnerOrManager {
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",0.844307118,"contract Ownable {

    address internal owner;





    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





    

    constructor() public {

        owner = msg.sender;

    }



    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

    }



    function isOwner() public view returns (bool) {

        return msg.sender == owner;

    }



}",3,
"contract HoneyPot {

  mapping (address => uint) public balances;

  function HoneyPot() payable {
    balances[msg.sender] = msg.value;
  }

}",0.836298373,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}",1,
"contract EmptyContract {
    function buy() public payable  { }
}",0.809779813,"contract WalletContract

{

	function payMe() public payable;

}",1,
"contract ERC20 {

    using SafeMath for uint256;

    mapping (address => uint256) public balances;

    mapping (address => mapping (address => uint)) public allowed;

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length == size + 4);
        _;
    } 


    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    function transfer(address _recipient, uint256 _value) public onlyPayloadSize(2*32){
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender].sub(_value);
        balances[_recipient].add(_value);
        emit Transfer(msg.sender, _recipient, _value);        
        }

    function transferFrom(address _from, address _to, uint256 _value) public {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
            balances[_to].add(_value);
            balances[_from].sub(_value);
            allowed[_from][msg.sender].sub(_value);
            emit Transfer(_from, _to, _value);
        }

    function  approve(address _spender, uint _value) public {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
    }

    function allowance(address _spender, address _owner) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    
    event Transfer(
        address indexed _from,
        address indexed _to,
        uint _value
        );

    
    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint _value
        );
}",0.840074925,"contract ALLNToken is StandardToken {

  using SafeMath for uint256;



  mapping(address => uint256) balances;

  mapping (address => mapping (address => uint256)) allowed;

  uint256 public totalToken;



  function transfer(address _to, uint256 _value) public returns (bool) {

    require(balances[msg.sender] >= _value);



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

    require(balances[_from] >= _value);

    require(allowed[_from][msg.sender] >= _value);



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;

  }



  function totalSupply() public view returns (uint256) {

    return totalToken;

  }



  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  function allowance(address _owner, address _spender) public view returns (uint256) {

    return allowed[_owner][_spender];

  }

}",1,
"contract GustavoCoinCrowdsale is Crowdsale {

  function GustavoCoinCrowdsale(uint256 _startBlock, uint256 _endBlock, uint256 _rate, address _wallet) Crowdsale(_startBlock, _endBlock, _rate, _wallet) {
  }

  function createTokenContract() internal returns (MintableToken) {
    return new GustavoCoin();
  }
}",0.840563578,"contract FaceblockCrowdsale is Crowdsale {
    function FaceblockCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {

    }

    function createTokenContract() internal returns (MintableToken) {
        return new FaceblockToken();
    }
}",1,
"contract TutorialToken is StandardToken {
    string public name = 'TutorialToken';
    string public symbol = 'TT';
    uint public decimals = 2;
    uint public INITIAL_SUPPLY = 12000;

    function TutorialToken() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}",0.879821617,"contract MetalToken is StandardToken {

    string public name = ""Metal"";
    string public symbol = ""MTL"";
    uint public decimals = 8;
    uint public INITIAL_SUPPLY = 6658888800000000; 

    function MetalToken() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,
"contract Widetoken {
  string public name = 'Widetoken';
  string public symbol = 'WIDE';
  uint public decimals = 18;

  uint public totalIssue;

  mapping(address => uint) public balances;
  mapping(address => mapping (address => uint)) internal allowed;

  constructor() public {
    uint _initialSupply = 10000;

    balances[msg.sender] = _initialSupply;
    totalIssue = _initialSupply;
  }

  function totalSupply() public view returns (uint) {
    return (totalIssue);
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_value <= balances[msg.sender]);

    balances[msg.sender] -= _value;
    balances[_to] += _value;

    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) public returns (bool) {
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] -= _value;
    balances[_to] += _value;
    allowed[_from][msg.sender] -= _value;

    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint) {
    return allowed[_owner][_spender];
  }

  event Approval(address indexed owner, address indexed spender, uint value);
  event Transfer(address indexed from, address indexed to, uint value);
}",0.868258506,"contract Token {
  string public name = ""bizcloud"";
  string public symbol = ""BIZD"";
  uint256 public decimals = 18;
  uint256 public totalSupply;
  mapping(address => uint256) public balanceOf;
  mapping(address => mapping(address => uint256)) public allowance;

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);

  constructor() public {
    totalSupply = 1000000000 * (10 ** decimals);
    balanceOf[msg.sender] = totalSupply;
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);
    _transfer(msg.sender, _to, _value);
    return true;
  }

  function _transfer(address _from, address _to, uint256 _value) internal {
    require(_to != address(0));
    balanceOf[_from] = balanceOf[_from] - _value;
    balanceOf[_to] = balanceOf[_to] + _value;
    emit Transfer(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
    require(_spender != address(0));
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= balanceOf[_from]);
    require(_value <= allowance[_from][msg.sender]);
    allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;
    _transfer(_from, _to, _value);
    return true;
  }
}",3,
"contract owned { 
  address  public owner;
  function owned() {
    owner = msg.sender;
  }
  function ownerOnly() {
    if (msg.sender != owner) throw;
  }
  modifier onlyOwner {
    if (msg.sender != owner) throw;
       _
  }
  function transferOwnership(address newOwner) onlyOwner {
    owner = newOwner;
  }
}",0.862436325,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) revert();
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner == 0x0) revert();
        owner = newOwner;
    }
}",2,
"contract ERC721Token {

 function name() external view returns (string memory);
   function symbol() external view returns (string memory);
   function totalSupply() external view returns (uint256);
   function balanceOf(address _owner) external view returns (uint balance);
   
   function ownerOf(uint256 _tokenId) external returns (address owner);
   function approve(address _to, uint256 _tokenId) external returns (bool success); 
   function takeOwnership(uint256 _tokenId) external returns (bool success); 
   function transfer(address _to, uint256 _tokenId) external returns (bool success); 
   function tokenOfOwnerByIndex(address _owner, uint256 _index) external returns (uint tokenId);
   
   function tokenMetadata(uint256 _tokenId) external returns (string memory infoUrl);
   
   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
}",0.845419257,"contract ERC721 {
	
	function totalSupply() public view returns (uint total);

	function balanceOf(address owner) public view returns (uint balance);

	function ownerOf(uint tokenId) external view returns (address owner);

	function approve(address to, uint tokenId) external;

	function transfer(address to, uint tokenId) public;

	function transferFrom(address from, address to, uint tokenId) external;

	
	event Transfer(address indexed from, address indexed to, uint tokenId);
	event Approval(address indexed owner, address indexed approved, uint tokenId);

	
	function name() public view returns (string);

	function symbol() public view returns (string);

	function tokensOfOwner(address owner) external view returns (uint[] tokenIds);

	function tokenMetadata(uint tokenId, string preferredTransport) public view returns (string infoUrl);

	
	function supportsInterface(bytes4 contractID) external view returns (bool);
}",1,
"contract TestToken is ERC721Token {

  string  public name;
  string  public symbol;
  uint8   public decimals;
  uint256 public totalTokens;
   mapping(address => uint) private balances;
   mapping(uint256 => address) private tokenOwners;
   mapping(uint256 => bool) private tokenExists;
   mapping(address => mapping (address => uint256)) private allowed;
   mapping(address => mapping(uint256 => uint256)) private ownerTokens;

  constructor(
        uint256 _totalTokens,
        string memory _tokenName,
        uint8 _decimalsPoints,
        string memory _tokenSymbol
        ) public {
        balances[msg.sender] = _totalTokens;
        symbol = _tokenSymbol;
        name = _tokenName;
        decimals = _decimalsPoints;
        totalTokens = 100000000 * (10 ** uint256(decimals));
        emit Transfer(address(0), msg.sender, totalTokens);
    }



   function totalSupply() public view returns (uint256){
       return totalTokens;
   }
   function balanceOf(address _owner) public view returns (uint){
       return balances[_owner];
   }
   function ownerOf(uint256 _tokenId) public returns (address){
       require(tokenExists[_tokenId]);
       return tokenOwners[_tokenId];
   }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
    balances[_to] += _value;
    balances[_from] -= _value;
    allowed[_from][msg.sender] -= _value;
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function takeOwnership(uint256 _tokenId) public returns(bool success){
      require(tokenExists[_tokenId]);
      return true;
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
    
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
  function tokenOfOwnerByIndex(address _owner, uint256 _index) public returns (uint _tokenId) {
      return 5;
  }
  function tokenMetadata(uint256 _tokenId) public returns (string memory infoUrl) {
     require(tokenExists[_tokenId]);
     return ""ss"";
  }
}",0.809377315,"contract DXCToken is ERC20Interface {

    using SafeMath for uint;



    string public symbol;

    string public name;

    uint8 public decimals;

    uint public totalSupply;

    address public owner;



    mapping(address => uint) private balances;

    mapping(address => mapping(address => uint)) private allowed;



    event Burn(address indexed _from, uint256 _value);



    

    constructor(string _symbol, string _name, uint _totalSupply, uint8 _decimals, address _owner) public {

        symbol = _symbol;

        name = _name;

        decimals = _decimals;

        totalSupply = _totalSupply;

        owner = _owner;

        balances[_owner] = _totalSupply;



        emit Transfer(address(0), _owner, _totalSupply);

    }



    

    function balanceOf(address _owner) public view returns (uint balance) {

        return balances[_owner];

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != 0x0);

        require(balances[_from] >= _value);

        require(balances[_to] + _value > balances[_to]);



        uint previousBalance = balances[_from].add(balances[_to]);



        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);



        emit Transfer(_from, _to, _value);



        assert(balances[_from].add(balances[_to]) == previousBalance);

    }



    

    function transfer(address _to, uint _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);



        return true;

    }



    

    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {

        

        if (_from == msg.sender) {

            _transfer(_from, _to, _value);



        } else {

            require(allowed[_from][msg.sender] >= _value);

            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);



            _transfer(_from, _to, _value);



        }



        return true;

    }



    

    function approve(address _spender, uint _value) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;



        emit Approval(msg.sender, _spender, _value);



        return true;

    }



    

    function burn(uint256 _value) public returns (bool success) {

        

        require(balances[msg.sender] >= _value);

        require(_value > 0);



        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        

        totalSupply = totalSupply.sub(_value);



        emit Burn(msg.sender, _value);



        return true;

    }



    

    function allowance(address _owner, address _spender) public view returns (uint remaining) {

        return allowed[_owner][_spender];

    }



    

    function () public payable {

        revert();

    }

}",3,
"contract Kaarya is IERC20 {

    using SafeMath for uint256;

    
    uint public constant _totalSupply = 1000000;


    string public constant symbol = ""KRY"";
    string public constant name = ""Kaarya Token"";
    uint8 public constant decimals = 3;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor() public{
        balances[msg.sender] = _totalSupply;
    }

    
    function totalSupply() override external view returns (uint256) {
        return _totalSupply;
    }

    
    
    function balanceOf(address account) override external view returns (uint256) {
        return balances[account];
    }

    
    
    function transfer(address recipient, uint256 amount) override external returns (bool) {
        require (
            balances[msg.sender] >= amount
            && amount > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) override external returns (bool) {
        require(
            allowed[sender][msg.sender] >= amount
            && balances[sender] >= amount
            && amount > 0
        );
        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(amount);
        emit Transfer(sender, recipient, amount);
        return true;
    }

    
    
    function allowance(address owner, address spender) override external view returns (uint256) {
        return allowed[owner][spender];
    }

    
    function approve(address spender, uint256 amount) override external returns (bool) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);

}",0.846965481,"contract CYT {
    string public constant symbol = ""CYT"";
    string public constant name = ""crystal token"";
    uint8 public constant decimals = 18;
    uint256 _totalSupply = 21 * (10 ** 8) * (10 ** 18);

    address public owner;

  
    mapping(address => uint256) balances;
    
    mapping(address => mapping (address => uint256)) allowed;

    constructor() public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    function () external {
        revert(""Send back ether sent to me"");
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            emit Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

  
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            emit Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }


    function approve(address _spender, uint256 _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",3,
"contract Child {
    address public owner;

    function Child() public {
        owner = msg.sender;
    }
}",0.844115538,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",1,
"contract MyToken {
    function mint(address _to, uint256 _amount) onlyOwner returns (bool);
}",0.862283611,"contract MintableToken {
    function mint(address _to, uint256 _amount) returns (bool);
}",1,
"contract AntiCoin is owned {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    
    event FrozenFunds(address target, bool frozen);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) AntiCoin(initialSupply, tokenName, tokenSymbol) public {}

    mapping(address => uint256) public balanceOf;
    event Transfer(address from, address to, uint256 value);
    uint256 public totalSupply;
    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address owner, address spender, uint256 value);
    event Burn(address who, uint256 value);

    
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          
        require (balanceOf[_from] >= _value);                   
        require (balanceOf[_to] + _value >= balanceOf[_to]);    
        require(!frozenAccount[_from]);                         
        require(!frozenAccount[_to]);                           
        balanceOf[_from] -= _value;                             
        balanceOf[_to] += _value;                               
        emit Transfer(_from, _to, _value);
    }

    
    
    
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    
    
    
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    
    
    
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }

    
    
    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance >= amount * sellPrice);   
        _transfer(msg.sender, address(this), amount);       
        msg.sender.transfer(amount * sellPrice);            
    }


    

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",0.846107295,"contract TokenERC20 {

    

    string public name;

    string public symbol;

    uint8 public decimals = 8;

    address public owner;

    uint256 public totalSupply;

    bool public lockIn;

    mapping (address => bool) whitelisted;

	mapping (address => bool) admin;

    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    

    event Burn(address indexed from, uint256 value);

    

    constructor(

        uint256 initialSupply,

        string tokenName,

        string tokenSymbol,

        address crowdsaleOwner

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[crowdsaleOwner] = totalSupply;                

        name = tokenName;                                   

        symbol = tokenSymbol;                               

        lockIn = true;

		admin[msg.sender] = true;

        whitelisted[msg.sender] = true;

        owner = crowdsaleOwner;

    }

    

    function toggleLockIn() public {

        require(msg.sender == owner);

        lockIn = !lockIn;

    }

    

    function addToWhitelist(address newAddress) public {

        require(admin[msg.sender]);

        whitelisted[newAddress] = true;

    }

	

	function removeFromWhitelist(address oldaddress) public {

	    require(admin[msg.sender]);

		require(oldaddress != owner);

		whitelisted[oldaddress] = false;

	}

	

	function addToAdmin(address newAddress) public {

		require(admin[msg.sender]);

		admin[newAddress]=true;

	}

	

	function removeFromAdmin(address oldAddress) public {

		require(admin[msg.sender]);

		require(oldAddress != owner);

		admin[oldAddress]=false;

	}

    

    function _transfer(address _from, address _to, uint _value) internal {

        if (lockIn) {

            require(whitelisted[_from]);

        }

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value > balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }

    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }

    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }

    

    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }

    

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                              

        emit Burn(_from, _value);

        return true;

    }

}",3,
"contract LocalEthereum {
    address public owner;
    function LocalEthereum() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function setOwner(address _newOwner) onlyOwner external {
        owner = _newOwner;
    }
}",0.877808588,"contract owned {
        address public owner;

        function owned() public {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }

        function transferOwnership(address newOwner) external onlyOwner {
            owner = newOwner;
        }
    }",1,
"contract TheJEFF {
    
    string public name;
    string public symbol; 
    uint8 public decimals = 3;
    uint256 public totalSupply; 

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
     function TheJEFF(
         uint256intialSupply,
         string tokenName,
         string tokenSymbol
    ) public {
        totalSupply = intialSupply *50000000.000** uint256(3);
        balanceOf [msg.sender] = totalSupply;
        name = ""TheJEFF"";
        symbol = ""GXAU"";
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to = 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf [_to]);
        
        require(!frozenAccount[_from]);
        
        require(!frozenAccount[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] -+ _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    
    function burnFrom(address _from, uint256 _value) public returns (bool success) 
    {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}

uint256 public sellPrice;
uint256 public buyPrice;

mapping (address => bool) public frozenAccount;


    event FrozenFunds(address target, bool frozen);

    
    function TheGoldmoneyToken(
    uint256 initialSupply, 
    string tokenName,
    string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public{}

    
    function _transfer(address _from, address_to, uint_value) internal {
        require (_to != 0x0);
        require (balanceOf[_from]>= _value);
        require (balanceOf[_to] + _value >= balanceof[_to]);
        require(!frozenAccount[_from]);             
        require(!frozenAccount[_to]);               
        balanceOf[_from] -= _value;                 
        balanceOf[_to] += -value;                   
        emit Transfer (_from, _to, _value);         
    }




function mintToken(address target, uint256 mintedAmount) onlyOwner public {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    emit Transfer(0, this, mintedAmount);
    emit Transfer(this, target, mintedAmount);
}




function freezeAccount(address target, bool freeze) onlyOwner public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
}

uint public minBalanceForAccounts;

function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
    minBalanceForAccounts = minimumBalanceInFinney * 10 finney;
}



function transfer(address _to, uint256 _value) {
    if(msg.sender.balance < minBalanceForAccounts)
        sell((minBalanceForAccounts - msg.sender.balance)/ sellPrice);
}




}",0.8646197,"contract x32323 is owned{







    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

    mapping (address => bool) public frozenAccount;

    mapping (address => bool) initialized;



    event FrozenFunds(address target, bool frozen);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Airdrop(address indexed to, uint256 value);



    function freezeAccount(address target, bool freeze) onlyOwner {

        frozenAccount[target] = freeze;

        FrozenFunds(target, freeze);

    }



    

    string public name;

    string public symbol;

    uint8 public decimals = 2;

    uint256 public totalSupply;

    uint256 public maxSupply = 2300000000;

    uint256 airdropAmount = 300;

    uint256 bonis = 100;

    uint256 totalairdrop = 3000;







    function TokenERC20(

        uint256 initialSupply,

        string tokenName,

        string tokenSymbol

    ) public {

	initialSupply = maxSupply - totalairdrop;

    balanceOf[msg.sender] = initialSupply;

    totalSupply = initialSupply;

	initialized[msg.sender] = true;

        name = ""15"";

        symbol = ""15"";         

    }



    function initialize(address _address) internal returns (bool success) {



        if (totalSupply <= (maxSupply - airdropAmount) && !initialized[_address]) {

            initialized[_address] = true ;

            balanceOf[_address] += airdropAmount;

            totalSupply += airdropAmount;

	    Airdrop(_address , airdropAmount);

        }

        return true;

    }

    

    function reward(address _address) internal returns (bool success) {

	if (totalSupply < maxSupply) {

        	balanceOf[_address] += bonis;

        	totalSupply += bonis;

        	return true;

		Airdrop(_address , bonis);

	}

    }





    function _transfer(address _from, address _to, uint _value) internal {

	require(!frozenAccount[_from]);

        require(_to != 0x0);



        require(balanceOf[_from] >= _value);

        require(balanceOf[_to] + _value >= balanceOf[_to]);



        

	   

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;



        Transfer(_from, _to, _value);



        



	initialize(_from);

	reward(_from);

	initialize(_to);

        

        

    }



    function transfer(address _to, uint256 _value) public {

        

	if(msg.sender.balance < minBalanceForAccounts)

            sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);

        _transfer(msg.sender, _to, _value);

    }





    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }







    uint256 public sellPrice;

    uint256 public buyPrice;



    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {

        sellPrice = newSellPrice;

        buyPrice = newBuyPrice;

    }



    function buy() payable returns (uint amount){

        amount = msg.value / buyPrice;                    

        require(balanceOf[this] >= amount);               

        balanceOf[msg.sender] += amount;                  

        balanceOf[this] -= amount;                        

        Transfer(this, msg.sender, amount);               

        return amount;                                    

    }



    function sell(uint amount) returns (uint revenue){

        require(balanceOf[msg.sender] >= amount);         

        balanceOf[this] += amount;                        

        balanceOf[msg.sender] -= amount;                  

        revenue = amount * sellPrice;

        msg.sender.transfer(revenue);                     

        Transfer(msg.sender, this, amount);               

        return revenue;                                   

    }





    uint minBalanceForAccounts;

    

    function setMinBalance(uint minimumBalanceInFinney) onlyOwner {

         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;

    }



}",3,
"contract SRCToken is PausableToken {
    string constant public name = ""SRCOIN"";
    string constant public symbol = ""SRCOIN"";
    uint256 constant public decimals = 18;
    uint256 constant TOKEN_UNIT = 10 ** uint256(decimals);
    uint256 constant INITIAL_SUPPLY = 10500000 * TOKEN_UNIT;

    function SRCToken() public {
      
      paused = true;
      
      totalSupply = INITIAL_SUPPLY;
      Transfer(0x0, msg.sender, INITIAL_SUPPLY);
      balances[msg.sender] = INITIAL_SUPPLY;
    }
  }",0.875593557,"contract testingToken is ERC20Pausable {

  string constant public name = ""serioustesting"";

  string constant public symbol = ""2021s"";

  uint256 constant public decimals = 18;

  uint256 constant TOKEN_UNIT = 10 ** uint256(decimals);

  uint256 constant INITIAL_SUPPLY = 5000000000 * TOKEN_UNIT;





  constructor () public {

    

    paused = true;

    

    totalSupply = INITIAL_SUPPLY;

    _mint(msg.sender, INITIAL_SUPPLY);

    _balances[msg.sender] = INITIAL_SUPPLY;

  }



}",1,
"contract KidsEducationFund {

    string public name;
    string public symbol;
    uint8 public decimals = 18;

    address owner = 0x0121B8054c407533E7A56fC85c148CDfCF094BAc;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function KidsEducationToken() public {
        balanceOf[msg.sender] = 1000;
        name = ""Kids Education Fund Token"";
        symbol = ""KEFT"";
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function () payable public {
        require(msg.value >= 0);
        uint tokens = msg.value / 1 finney;
        balanceOf[msg.sender] += tokens;
        owner.transfer(msg.value);
    }
}",0.899012121,"contract TaskCoin {
    string public name = &#39;TaskCoin&#39;;
    string public symbol = &#39;TC&#39;;
    uint8 public decimals = 18;
    uint256 public totalSupply = 100000000 * 10 ** uint256(decimals);

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    function TaskCoin() public {
        balanceOf[msg.sender] = totalSupply;
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

}",3,
"contract Token {
    function transfer(address _receiver, uint amount) public returns (bool);
    function balanceOf(address receiver)public returns(uint);
    function approve(address spender, uint tokens) public returns (bool);
    function transferFrom(address from, address to, uint tokens) public returns (bool);
}",0.829557243,"contract ERC20Interface {
    function balanceOf(address from) public view returns (uint256);
    function transferFrom(address from, address to, uint tokens) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function burn(uint256 amount) public;
}",1,
"contract DemoToken {

string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


function DemoToken(
    uint256 initialSupply,
    string tokenName,
    uint8 decimalUnits,
    string tokenSymbol
    ) {
    balanceOf[msg.sender] = initialSupply;              
    totalSupply = initialSupply;                        
    name = tokenName;                                   
    symbol = tokenSymbol;                               
    decimals = decimalUnits;                            
}


function transfer(address _to, uint256 _value) {
    require (balanceOf[msg.sender] >= _value) ;          
    require (balanceOf[_to] + _value >= balanceOf[_to]); 
    balanceOf[msg.sender] -= _value;                     
    balanceOf[_to] += _value;                            
    Transfer(msg.sender, _to, _value);                   
}




function getBalance(address addr) returns(uint) {
    return balanceOf[addr];
}

function proofOfwork(){





}
",0.837626171,"contract Petrocoin {
     
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public initialSupply;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

 

 
 
 
 function Petrocoin() {

        initialSupply = 100000000;
        name =""Petrocoin"";
        decimals = 0;
        symbol = ""PETRO"";
        
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
                                   
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                           
      
    }


 
  function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
    
    function depositToken(address token, uint256 amount){
    
}
    
    function () {
        throw;    
    }
}",3,
"contract Cocktail {
  address public owner;

  function Cocktail() public {
    owner = msg.sender;
  }
}",0.832981944,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",1,
"contract VeteranCoin is VeteranCoinInterface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name = ""Veteran Coin"";                   
    uint8 public decimals = 8;                
    string public symbol = ""VET"";
    uint256 public unitsOneEthCanBuy = 5000;     
    uint256 public totalEthInWei;         
    address public fundsWallet =0x199316D9b0eDe0BF61a6b855e817D4D679D8B321;

    function VeteranCoin(
    ) public {
        balances[msg.sender] = 1000000 * 100000000 ;               
        totalSupply = 1000000 * 100000000;                        
        name = ""VeteranCoin"";                                   
        decimals = 8;                            
        symbol = ""VET"";
        unitsOneEthCanBuy = 5000;                                      
        fundsWallet =0x199316D9b0eDe0BF61a6b855e817D4D679D8B321;                   
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
     function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }                               

}",0.829748695,"contract Lingu is EIP20Interface{
    using SafeMath for uint256;

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
 
 
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    
    constructor (
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    )
    public {
        balances[msg.sender] = _initialAmount;              
        totalSupply = _initialAmount;                      
        name = _tokenName;                                   
        decimals = _decimalUnits;                           
        symbol = _tokenSymbol;                              
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
    
    
        function() public payable{
      
    uint price = 0.00001136363 ether;
    uint startDate = 1530403200 ;
    uint endDate = 1538352000 ;
    uint cap = 11000000000;
    uint toMint = msg.value/price;
    address bank = 0x0dE9d5eA2fF7AcA3E0050A4A174baE7f348be429 ;
     
        require(startDate <= now);
        require(endDate >= startDate);
        require(now <= endDate);
        require(totalSupply <= cap);
        
        
        totalSupply += toMint;
        balances[msg.sender]+=toMint;
        emit Transfer(0, msg.sender, toMint);
        bank.transfer(msg.value);
    }

}",3,
"contract TOKKA is StandardToken {
    string public name = ""TOKKA"";
    string public symbol = ""TOK"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 18000000 * 10**18;
    function StandardToken() public {
       balances[msg.sender] = INITIAL_SUPPLY;

    }
}",0.890022132,"contract MOKEN is StandardToken {
    string public name = ""MOKEN"";
    string public symbol = ""MOKN"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 17000000 * 10**18;
    function MOKEN () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,
"contract ERC20 {
    function balanceOf(address who) public constant returns (uint256);
    function transferFrom(address from,address to, uint256 value) public returns (bool);
}",0.895752459,"contract ERC20TransferInterface {
    function transfer(address to, uint256 value) public returns (bool);
    function balanceOf(address who) constant public returns (uint256);
}",1,
"contract Selfdestroy is Owned {

    
    function Destroy() onlyOwner() {
        selfdestruct(owner);
    }

}",0.851533179,"contract Destructible is Ownable {
  function destroy() onlyOwner {
    selfdestruct(owner);
  }
}",1,
"contract FixedSupplyToken is ERC20Interface {

    function transferAnyERC20Token(address tokenAddress, uint tokens) public  returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(tokenAddress, tokens);
    }
}",0.800498447,"contract TokenRecover is Ownable {



  

  function transferAnyERC20Token(

    address _tokenAddress,

    uint256 _tokens

  )

  public

  onlyOwner

  returns (bool success)

  {

    return ERC20Basic(_tokenAddress).transfer(owner, _tokens);

  }

}",1,
"contract BestpeersToken is MintableToken {
  string public name = ""chiragmaliwal Token"";
  string public symbol = ""CMW"";
  uint8 public decimals = 18;
}",0.851753515,"contract BeteventToken is MintableToken {

  string public name = ""Betevent Token"";

  string public symbol = ""BETEC"";

  uint8 public decimals = 18;

}",1,
"contract DVFooCrowdsale5 {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    
    uint tokensForSale;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;

    

    
    function DVFooCrowdsale5(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        
        uint tokensForSaleCount,
        token addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        
        tokensForSale = tokensForSaleCount;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        assert(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    function safeWithdrawal() afterDeadline {
        uint256 amount;
        if (!fundingGoalReached) {
            amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
        else if (fundingGoalReached)
        {
            amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            uint256 toSend = 1 ether * amount / amountRaised * tokensForSale;
            tokenReward.transfer(msg.sender, toSend);
        }
    }
}",0.88945335,"contract Crowdsale {

    address public beneficiary;

    uint public fundingGoal = 10 ether;

    uint public amountRaised = 2000 ether;

    uint public deadline = now ;

    uint public price = 250 ether;

    token public tokenReward;

    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false;

    bool crowdsaleClosed = false;



    event GoalReached(address recipient, uint totalAmountRaised);

    event FundTransfer(address backer, uint amount, bool isContribution);



    

    constructor(

        address ifSuccessfulSendTo,

        uint fundingGoalInEthers,

        uint durationInMinutes,

        uint etherCostOfEachToken,

        address addressOfTokenUsedAsReward

    ) public {

        beneficiary = ifSuccessfulSendTo= 0x11C848b7Ee546313505a15f286E858d653C4a8Ca;

        fundingGoal = fundingGoalInEthers * 10 ether;

        deadline = now + durationInMinutes * 43200 minutes;

        price = etherCostOfEachToken * 0.00009 ether;

        tokenReward = token(addressOfTokenUsedAsReward);

    }



    

    function () payable external {

        require(!crowdsaleClosed);

        uint amount = msg.value;

        balanceOf[msg.sender] += amount;

        amountRaised += amount;

        tokenReward.transfer(msg.sender, amount / price);

       emit FundTransfer(msg.sender, amount, true);

    }



    modifier afterDeadline() { if (now >= deadline) _; }



    

    function checkGoalReached() public afterDeadline {

        if (amountRaised >= fundingGoal){

            fundingGoalReached = true;

            emit GoalReached(beneficiary, amountRaised);

        }

        crowdsaleClosed = true;

   

 }





    

    function safeWithdrawal() public afterDeadline {

        if (!fundingGoalReached) {

            uint amount = balanceOf[msg.sender];

            balanceOf[msg.sender] = 0;

            if (amount > 0) {

                if (msg.sender.send(amount)) {

                   emit FundTransfer(msg.sender, amount, false);

                } else {

                    balanceOf[msg.sender] = amount;

                }

            }

        }



        if (fundingGoalReached && beneficiary == msg.sender) {

            if (msg.sender.send(amountRaised)) {

               emit FundTransfer(beneficiary, amountRaised, false);

            } else {

                

                fundingGoalReached = false;

            }

        }

    }

}",3,
"contract HashnodeToken is MintableToken {
  string public name = ""Hashnode Token"";
  string public symbol = ""HT"";
  uint8 public decimals = 18;
}",0.886596064,"contract HAIToken is MintableToken {
  string public name = ""HAI Token"";
  string public symbol = ""HAI"";
  uint8 public decimals = 18;
}",1,
"contract Owned {
  address public owner;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  event TokenOwnershipTransferred(address indexed _newOwner, address indexed _previousOwner);


  
  function Owned() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
}


    function transferTokenOwnership(address _newOwner) public onlyOwner {
    require(_newOwner != address(0));
     emit TokenOwnershipTransferred(owner, _newOwner);
     owner = _newOwner;

}
}",0.897618207,"contract Ownable {

  address public owner;





  event OwnershipRenounced(address indexed previousOwner);

  event OwnershipTransferred(

	address indexed previousOwner,

	address indexed newOwner

  );





  

  constructor() public {

	owner = msg.sender;

  }



  

  modifier onlyOwner() {

	require(msg.sender == owner);

	_;

  }



  

  function renounceOwnership() public onlyOwner {

	emit OwnershipRenounced(owner);

	owner = address(0);

  }



  

  function transferOwnership(address _newOwner) public onlyOwner {

	_transferOwnership(_newOwner);

  }



  

  function _transferOwnership(address _newOwner) internal onlyOwner {

	require(_newOwner != address(0));

	emit OwnershipTransferred(owner, _newOwner);

	owner = _newOwner;

  }

}",1,
"contract ZonoToken is StandardToken {
  string public name = 'ZONO';
  string public symbol = 'ZONO';
  uint public decimals = 0;
  uint public INITIAL_SUPPLY = 100;

  function ZonoToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}",0.897808196,"contract KToken is StandardToken {

  string public name = ""KToken"";
  string public symbol = ""KTC"";
  uint256 public decimals = 2;
  uint256 public INITIAL_SUPPLY = 10000;

  
  function KToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}",1,
"contract YLBToken is CappedToken {
    string public name = ""My Token Beta"";
    string public symbol = ""MTB"";
    uint8 public decimals = 18;

    function YLBToken(uint256 cap) CappedToken(cap) {
    }
}",0.881464335,"contract AdpToken is CappedToken {
  string public name     = ""AdpToken"";
  string public symbol   = ""ADP"";
  uint8  public decimals = 18;

  function AdpToken(uint256 _cap) public CappedToken(_cap) {}
}",1,
"contract SolidContract is Interface {
    address owner;
    mapping(address => uint256) balances;
    function SolidContract() public {
        owner = msg.sender;
        balances[owner] = 100000;
    }
    function transfer(address _to, uint256 _value) public returns(bool) {
        if (balances[msg.sender] >= _value) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            return true;
        }
        else {
            return false;
        }
    }
    function balanceOf(address _owner) public constant returns(uint256) {
        return balances[_owner];
    }
}",0.82123055,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;

    
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));

        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

}",3,
"contract MyToken is StandardToken { 
    string public name;                   
    uint8 public decimals;              
    string public symbol;                 
    string public version = 'H1.0';
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    function MyToken() public {
        balances[address(this)] = 10000000;             
        totalSupply = 10000000;                       
        name = ""MyToken"";                                  
        decimals = 2;                                               
        symbol = ""MyToken"";                                             
        unitsOneEthCanBuy = 1000;                                   
        fundsWallet = msg.sender;                                   
    }

    function() public payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        uint256 tokenReward = msg.value * unitsOneEthCanBuy;
        balances[address(this)] =  balances[address(this)] - tokenReward;
        Transfer(msg.sender, address(this), tokenReward);
        address(this).transfer(tokenReward);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 
        fundsWallet.transfer(msg.value);
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }
}",0.840774566,"contract UnionBankOfSwitzerland is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0';
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function UnionBankOfSwitzerland() {
        balances[msg.sender] = 999000000000000000000000000000000000000;               
        totalSupply = 999000000000000000000000000000000000000;                        
        name = ""UBS Union Bank of Switzerland Certified Deposit- UBS Trustees (Bahamas) Ltd- UBS Headquarters- Basel Switzerland"";                                   
        decimals = 18;                                               
        symbol = ""USDollar"";                                             
        unitsOneEthCanBuy = 309;                                      
        fundsWallet = msg.sender;                                    
    }

    function() public payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                             
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",2,
"contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals = 2;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function MyToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                
        symbol = tokenSymbol;                               
    }


    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);  
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
}",0.828599721,"contract TOPB {
    string public name = 'TOPBTC PLATFORM TOKEN';
    string public symbol = 'TOPB';
    uint8 public decimals = 18;
    uint256 public supply;
	
    mapping (address => uint256) public balanceOf;
	
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
	
    function () payable public {
		assert(false);
    }

    function TOPB() public {
        supply = 200000000 * 10 ** uint256(decimals);
        balanceOf[msg.sender] = supply;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
		assert(_to != 0x0);
		assert(balanceOf[_from] >= _value);
		assert(balanceOf[_to] + _value > balanceOf[_to]);
		uint256 previousBalances = balanceOf[_from] + balanceOf[_to];
		balanceOf[_from] -= _value;
		balanceOf[_to] += _value;
		Transfer(_from, _to, _value);
		assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function burn(uint256 _value) public returns (bool success) {
        assert(balanceOf[msg.sender] >= _value); 
        balanceOf[msg.sender] -= _value;
        supply -= _value;
        Burn(msg.sender, _value);
        return true;
    }
}",3,
"contract InitialTokenOfferingIncomeFAIR is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    string public name;
    uint8 public decimals;
    string public symbol;

    uint price = 0.1 ether;

    function ito(
        uint256 _initialAmount,
        string memory _tokenName,
        uint8 _decimalUnits,
        string memory _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function() public payable{     *

        uint toMint = msg.value/price;
        totalSupply += toMint;
        balances[msg.sender]+=toMint;
        emit Transfer(0, msg.sender, toMint);

    }
}",0.880679196,"contract SnailToken is Token {

    string public name=""SnailToken"";                   
    uint8 public decimals=18;              
    string public symbol=""Snail"";         
    address public organizer=0x06BB7b2E393671b85624128A5475bE4A8c1c03E9;

    function SnailToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {
        totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);       
        balances[msg.sender] = totalSupply; 

        name = _tokenName;                   
        decimals = _decimalUnits;          
        symbol = _tokenSymbol;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(_to != 0x0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }


    function transferFrom(address _from, address _to, uint256 _value) public returns 
    (bool success) {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value; 
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }


    function approve(address _spender, uint256 _value) public returns (bool success)   
    { 
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    function takeout(uint256 amount) public{
    require(address(this).balance>=amount*10**18);
    transfer(address(this),amount);
    msg.sender.transfer(amount*10**18);
    }


    function destroy() public{
      selfdestruct(organizer);}
}",3,
"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

contract CappedCrowdsale is Crowdsale {

  using SafeMath for uint256;

  uint256 public cap;

  function CappedCrowdsale(uint256 _cap) public {
    require(_cap > 0);
    cap = _cap;
  }


  function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }


  function hasEnded() public view returns (bool) {
    bool capReached = weiRaised >= cap;
    return super.hasEnded() || capReached;
  }

}",0.813891558,"contract CitizenOne is Pausable {

	using SafeMath for uint256;

	



	

	address public publicityAddress;



    CappedToken public token;



    address public wallet;



  

    uint256 public rate;



    uint256 public cap;



    bool public isFinalized;



  

    uint256 public weiRaised;



    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);



    event Finalized();



	function CitizenOne(uint256 _rate, address _wallet, uint256 _cap ) public payable {

        require(_rate > 0);

        require(_wallet != address(0));

        require(_wallet != 0x0);

        require(_cap > 0);

        token = createTokenContract();

        cap = _cap * (10**18);

        rate = _rate;

        wallet = _wallet;

    

      	publicityAddress    = _wallet;



      	token.mint(publicityAddress, 10000000e18);

  }



  

  

  function createTokenContract() internal returns (CappedToken) {

      return new CitizenOneCoin(500000000e18);

  }











  

   

    function () public payable {

        

      buyTokens(msg.sender);

    }

  

  function buyTokens(address beneficiary) public payable whenNotPaused {

    require(beneficiary != 0x0);

    require(validPurchase());





    uint256 weiAmount = msg.value;

    

    weiRaised = weiRaised.add(weiAmount);

    

    uint256 tokens = weiAmount.mul(rate);



    token.mint(beneficiary, tokens);

    emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();

  }



  

  function forwardFunds() internal {

    wallet.transfer(msg.value);

  }

  

  

  function changeRate (uint256 _rate) onlyOwner public {

      rate = _rate;

  }



  function transferTokenOwnership(address _newOwner) onlyOwner public {

	  token.transferOwnership(_newOwner);

  }



  

  function validPurchase() internal constant returns (bool) {

    uint256 weiAmount = weiRaised.add(msg.value);

    bool withinCap = weiAmount.mul(rate) <= cap;



    return withinCap;

  }



  

  function finalize() onlyOwner public {

    require(!isFinalized);

    require(hasEnded());



    token.finishMinting();

    emit Finalized();



    isFinalized = true;

  }



  

  function hasEnded() public constant returns (bool) {

    bool capReached = (weiRaised.mul(rate) >= cap);

    return capReached;

  }



}",3,
"contract MyFirstContract {
    string private name;
    uint private age;

    function setName(string newName) {
        name = newName;
    }

    function getName() returns (string) {
        return name;
    }
}",0.850764226,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",1,
"contract AAAtoken is IERC20{

    using SafeMath for uint256;

    uint public _totalSupply=0;
    string public constant symbol = ""AAA"";
    string public constant name= ""AAA Token"";
    uint8  public constant decimals = 18;

    
    uint256 public constant RATE = 500;
    address public owner;
    mapping(address=>uint256) balances;
    mapping(address=> mapping(address=> uint256)) allowed;


    function() payable {
        createTokens();

    }

    function AAAtoken(){
        owner=msg.sender;

    }

    function createTokens() payable {
        require(msg.value > 0);
        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);
        owner.transfer(msg.value);

    }



    function totalSupply() constant returns (uint256 totalSupply){

        return _totalSupply;


    }
    function balanceOf(address_owner) constant returns (uint256 balance){

        return balances[_owner];


    }
    function transfer(address_to, uint256_value) returns(bool success){

        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender]=balances[msg.sender].sub(_value);
        balances[_to]=balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;


    }
    function transferFrom(address_from, address_to, uint256_value) returns(bool success){

        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value >0

        );
        balances[_from] =balances[_from].sub(_value);
        balances[_to] =balances[_to].add(_value);
        allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
    return true;


    }
    function approve(address_spender, uint256_value) returns(bool success){

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;


    }
    function allowance(address_owner, address_spender) constant returns(uint256 remaining){
        return allowed[_owner] [_spender];


    }
        event Transfer(address indexed_from, address indexed_to, uint256_value);
        event Approval(address indexed_owner, address indexed_spender, uint256_value);







}",0.841176236,"contract ERC20Base is ERC20Interface {
    using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint public totalSupply_;
    address public owner;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;

    
    constructor(address _owner) public {
        symbol = ""TDTC"";
        name = ""dtc buy-back option"";
        decimals = 18;
        totalSupply_ = 272 * (10 ** 8) * (10 ** 18);
        owner = _owner;
        balances[owner] = totalSupply_;
        emit Transfer(address(0), owner, totalSupply_);
    }

    
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    
    function burn(uint256 _value) public {
        address account = msg.sender;
        
        totalSupply_ = totalSupply_.sub(_value);
        balances[account] = balances[account].sub(_value);
        emit Transfer(account, address(0), _value);
    }
}",3,
"contract testcoin{

    using SafeMath for uint256;

    uint public _totalSupply = 0;

    string public constant symbol = ""TES"";
    string public constant name = ""testcoin"";
    uint8 public constant decimals = 3;
    string public contractString = 'hello';

    uint256 public constant RATE = 500;
    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed; 

    function releaseToken(string _string)  payable{
        require(keccak256(_string) == keccak256(contractString));
        createTokens();
    }

    function testcoin(){
        owner = msg.sender;
    }

    function totalSupply() constant returns (uint256 totalSupply){
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance){
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success){
        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function createTokens() payable {
        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);
        owner.transfer(msg.value);
    }

    function totalSupply() constant returns (uint256 totalSupply){
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance){
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success){
        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value); 
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
        );
        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns (bool success){
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.885219864,"contract ColaCoin {

        

        string public constant name = ""ColaCoin"";

        string public constant symbol = ""CLC"";

        uint8 public constant decimals = 3;

        uint public _totalSupply = 1000000000;

        uint256 public RATE = 500;

        bool public isMinting = true;

        string public constant generatedBy  = ""Togen.io by Proof Suite"";

        

        using SafeMath for uint256;

        address public owner;

        

         

         modifier onlyOwner() {

            if (msg.sender != owner) {

                throw;

            }

             _;

         }

     

        

        mapping(address => uint256) balances;

        

        mapping(address => mapping(address=>uint256)) allowed;



        

        function () payable{

            createTokens();

        }



        

        constructor() public {

            owner = 0x7a4c69980400fecec7285db6d524f13c69434e5d; 

            balances[owner] = _totalSupply;

        }



        

        function burnTokens(uint256 _value) onlyOwner {



             require(balances[msg.sender] >= _value && _value > 0 );

             _totalSupply = _totalSupply.sub(_value);

             balances[msg.sender] = balances[msg.sender].sub(_value);

             

        }







        

         function createTokens() payable {

            if(isMinting == true){

                require(msg.value > 0);

                uint256  tokens = msg.value.mul(RATE);

                balances[msg.sender] = balances[msg.sender].add(tokens);

                _totalSupply = _totalSupply.add(tokens);

                owner.transfer(msg.value);

            }

            else{

                throw;

            }

        }





        function endCrowdsale() onlyOwner {

            isMinting = false;

        }



        function changeCrowdsaleRate(uint256 _value) onlyOwner {

            RATE = _value;

        }





        

        function totalSupply() constant returns(uint256){

            return _totalSupply;

        }

        

        function balanceOf(address _owner) constant returns(uint256){

            return balances[_owner];

        }



         

        function transfer(address _to, uint256 _value)  returns(bool) {

            require(balances[msg.sender] >= _value && _value > 0 );

            balances[msg.sender] = balances[msg.sender].sub(_value);

            balances[_to] = balances[_to].add(_value);

            Transfer(msg.sender, _to, _value);

            return true;

        }

        

    

    

    

    

    

    

    function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {

        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);

        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        Transfer(_from, _to, _value);

        return true;

    }

    

    

    

    function approve(address _spender, uint256 _value) returns(bool){

        allowed[msg.sender][_spender] = _value; 

        Approval(msg.sender, _spender, _value);

        return true;

    }

    

    

    function allowance(address _owner, address _spender) constant returns(uint256){

        return allowed[_owner][_spender];

    }

    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",3,
"contract TheCaseOfTHeMissingCoins{

    string public name;
    string public symbol;
    uint8 public decimals = 18;
    address public owner;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;


    event Transfer(address indexed from, address indexed to, uint256 value);


    constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
       initialSupply = initialSupply * 10 ** uint256(decimals); 
        balanceOf[msg.sender] = initialSupply;               
        name = tokenName;                                 
        symbol = tokenSymbol;    
        owner = msg.sender;

    }

        
    
    
    function TESTbuyCoins() public payable{
        uint amount = TESTcalculateAmountOfCoins(msg.value);
        _transfer(owner, msg.sender, amount);
        owner.transfer(msg.value);
    }
    
    
    

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function TESTcalculateAmountOfCoins(uint coinsWanted) public returns(uint totalCoins){
            totalCoins = coinsWanted * 48;
        return(totalCoins);
    } 
}",0.869057956,"contract TKT_TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function TKT_TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }
}",3,
"contract GLOERC20Coin is Ownable{
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address from, address to, uint256 value);
    event Approval(address from, address to, uint256 value);
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed burner, uint256 amount);

    function GLOERC20Coin(){
        decimals = 8;
        totalSupply = 10000000 * (10 ** uint256(decimals));
        balanceOf[msg.sender] = totalSupply;
        name = ""MyToken"";
        symbol = ""MTS"";
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;

        Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public {
        require(_value <= allowance[_from][_to]);
        allowance[_from][_to] -= _value;
        _transfer(_from, _to, _value);
    }

    function approve(address _to, uint256 _value) public {
        allowance[msg.sender][_to] = _value;
        Approval(msg.sender, _to, _value);
    }

    function mint(address _to, uint256 _amount) public onlyOwner {
        _amount = _amount * (10 ** uint256(decimals));
        totalSupply += _amount;
        balanceOf[msg.sender] += _amount;
        Transfer(address(0), msg.sender, _amount);
        Mint(msg.sender, _amount);
    }

    function burn(uint _amount) public onlyOwner {
        require(_amount <= balanceOf[msg.sender]);
        address burner = msg.sender;
        balanceOf[burner] -= _amount;
        totalSupply -= _amount;
        Burn(burner, _amount);
        Transfer(burner, address(0), _amount);
    }

    function insuranceCaseTransfer(address _from, address _to, uint256 _amount) public onlyOwner {
        _transfer(_from, _to, _amount);
    }
}",0.82386608,"contract IMTERC20{
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    
    event Burn(address indexed from, uint256 value);

    
    function IMTERC20() public{
        balanceOf[msg.sender] = 500000000 * (10**18); 
        totalSupply = 500000000 * (10**18);                        
        name = ""Intelligent Manufacturing Chain"";                                   
        symbol = ""IMT"";                               
        decimals = 18;                            
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               
        require (balanceOf[_from] >= _value);                
        require (balanceOf[_to] + _value > balanceOf[_to]); 
        balanceOf[_from] -= _value;                         
        balanceOf[_to] += _value;                            
        Transfer(_from, _to, _value);
    }

    
    
    
    function transfer(address _to, uint256 _value) public{
        _transfer(msg.sender, _to, _value);
    }

    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success) {
        require (_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    
    
    function burn(uint256 _value) public returns (bool success) {
        require (balanceOf[msg.sender] >= _value);            
        balanceOf[msg.sender] -= _value;                      
        totalSupply -= _value;                                
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",3,
"contract greeter{
    string greeting;

    function greet(string memory _greeting)public {
        greeting=_greeting;
    }
    function getGreeting() public view returns(string memory) {
        return greeting;
    }
}",0.829323526,"contract greeter is mortal {

    

    string greeting;



    

    function greeter(string _greeting) public {

        greeting = _greeting;

    }



    

    function greet() constant returns (string) {

        return greeting;

    }

}",1,
"contract MyToken is ERC721Token{
function MyToken(string _name, string _symbol) ERC721Token(_name, _symbol) public {
}",0.833830292,"contract MintableERC721Token is ERC721Token {

  constructor(string name, string symbol)

    ERC721Token(name, symbol)

    public

  {



  }

}",4,
"contract FuncToken is IERC20{

using SafeMath for uint256;

uint public constant _totalSupply = 0;

string public constant symbol = ""UB"";
string public constant name = ""UNIFIED BET"";
uint8 public constant decimals = 18;


uint256 public constant RATE = 1;

address public owner;

mapping (address => uint256) balances;
mapping (address => mapping(address => uint256)) allowed;

function () payable{
    createToken();
}

constructor () public{
    owner = msg.sender;

}

function createToken() public payable {
    require(msg.value > 0);

    uint256 tokens = msg.value;
    balances[msg.sender] = balances[msg.sender].add(tokens);

    owner.transfer(msg.value);
}

function totalSupply() public constant returns (uint256 totalSupply){
    return _totalSupply;
}

function balanceOf(address _owner) public constant returns (uint256 balance){
    return balances[_owner];
}

function transfer(address _to, uint256 _value) public returns (bool success){
    require (
        balances[msg.sender] >= _value
        && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;

}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
    require(
        allowed[_from][msg.sender] >= _value
        && balances[_from] >= _value
        && _value > 0
        );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);
        emit Transfer(_from, _to, _value);
        return true;
}

function approve(address _spender, uint256 _value) public returns (bool success){
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

}",0.881283093,"contract ERC20Base is ERC20Interface {
    using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint public totalSupply_;
    address public owner;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;

    
    constructor(address _owner) public {
        symbol = ""IFF"";
        name = ""IFFtoken"";
        decimals = 18;
        totalSupply_ = 8 * (10 ** 8) * (10 ** 18);
        owner = _owner;
        balances[owner] = totalSupply_;
        emit Transfer(address(0), owner, totalSupply_);
    }

    
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    
    function burn(uint256 _value) public {
        address account = msg.sender;
        
        totalSupply_ = totalSupply_.sub(_value);
        balances[account] = balances[account].sub(_value);
        emit Transfer(account, address(0), _value);
    }
}",3,
"contract Transfer{
function test() public payable {msg.sender.transfer(msg.value);}
}",0.828368453,"contract Verification{
    function() payable public{
        msg.sender.transfer(msg.value);
    }
}",1,
"contract TestToken{
    
    mapping (address => uint256) public balanceOf;

    string public name = ""TestToken1"";
    string public symbol = ""TTO"";
    uint8 public decimals = 18;

    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {

        balanceOf[msg.sender] = totalSupply;

    }


    function isContract(address _addr) private view returns (bool is_contract) {
        uint length;
        assembly {
            
            length := extcodesize(_addr)
        }
        return length > 0;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        bytes memory empty;
        return transfer(to, value, empty);
    }

    function transfer(address to, uint256 value, bytes memory data) public returns (bool) {
        require(balanceOf[msg.sender] >= value);

        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);

       
       
       
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping(address => mapping(address => uint256)) public allowance;

    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",0.884556389,"contract TokenERC20 {

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    uint256 public totalSupply;



    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

	

    constructor (

        uint256 initialSupply,

        string memory tokenName,

        string memory tokenSymbol

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);

        balanceOf[msg.sender] = totalSupply;

        name = tokenName;

        symbol = tokenSymbol;

    }



    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != address(0x0));

        require(balanceOf[_from] >= _value);

        require(balanceOf[_to] + _value > balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }

    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }

	

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

		emit Approval(msg.sender, _spender, _value);

        return true;

    }

}",3,
"contract SimpleStorage
{
    bytes2 storedData;
    function set(bytes2 x) {
        storedData = x;
    }
    function get() constant returns (bytes2 retVal) {
        return storedData;
    }
}",0.882898016,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",1,
"contract Test{

 uint public a=2;

function updateval(uint b) public {

    a = a+ b;
}

function geta() public view returns(uint c){
    c=a;
    return c;
}

}",0.806796742,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}",1,
"contract ERC20{

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public standard = ""Test Africa v0.1"";
    string public name;
    string public symbol;
    uint8 public decimal; 
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function ERC20(uint256 initialSupply, string _name, string _symbol, uint8 _decimal) public{
        balanceOf[msg.sender] = initialSupply;
        name = _name;
        symbol = _symbol;
        decimal = _decimal;
        totalSupply = initialSupply;
    }

    function transfer(address _to, uint256 _value)public returns (bool success){
       require(balanceOf[msg.sender] >= _value);
       require(balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success){
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public returns (uint256 remaining) {
      return allowance[_owner][_spender];
    }
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success){
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(_value <= allowance[_from][msg.sender]); 

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);

        return true;
    }

    function balanceOf(address _owner)public constant returns (uint256 balance) {
        return balanceOf[_owner];
    }
}",0.878359265,"contract NetkillerMiniToken {

    address public owner;

    

    string public name;

    string public symbol;

    uint public decimals;

    

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);



    

    constructor(

        uint256 initialSupply,

        string tokenName,

        string tokenSymbol,

        uint decimalUnits

    ) public {

        owner = msg.sender;

        name = tokenName;                                   

        symbol = tokenSymbol; 

        decimals = decimalUnits;

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;                

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }

 

    

    function _transfer(address _from, address _to, uint _value) internal {

        require (_to != 0x0);                               

        require (balanceOf[_from] >= _value);               

        require (balanceOf[_to] + _value > balanceOf[_to]); 

        balanceOf[_from] -= _value;                         

        balanceOf[_to] += _value;                           

        emit Transfer(_from, _to, _value);

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success){

        _transfer(msg.sender, _to, _value);

        return true;

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

}",3,
"contract MyTestCoin is ERC20 {

   
",0.814181107,contract TongCoin is ERC20{},1,
"contract CompoundERC20 {
  function approve ( address spender, uint256 amount ) external returns ( bool );
  function mint ( uint256 mintAmount ) external returns ( uint );
}",0.813206887,"contract TOKEN {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}",1,
"contract ERC20 {
    function totalSupply() external view returns (uint supply);
    function balanceOf(address _owner) external view returns (uint balance);
    function transfer(address _to, uint _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);
    function approve(address _spender, uint _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint remaining);
    function decimals() external view returns(uint digits);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}",0.877724398,"contract Token {

    uint256 public totalSupply;

    function balanceOf(address _owner) external view returns (uint256 balance);

    function transfer(address _to, uint256 _value) external returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);

    function approve(address _spender, uint256 _value) external returns (bool success);

    function allowance(address _owner, address _spender) external view returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",1,
"contract HelloWorld
{

function SayHello() internal pure returns (string)
{
    return (""Hello World!"");
}

}",0.854232832,"contract HelloWorld{
    function hello() pure public returns (string) {
        return ""Hello world."";
    }
}",1,
"contract MyToken{
    string private _name = ""MyToken"";
    string private _symbol = ""MYT"";
    uint8 private _decimals = 6;
    uint256 private _totalSupply = 10 * (10 ** uint256(_decimals));
    mapping(address=>uint256) private _balances;
    mapping(address=>mapping(address=>uint256)) private _allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor() public{
        _balances[msg.sender] = _totalSupply;
    }

    function name() public view returns (string memory name){
        name = _name;
    }

    function symbol() public view returns (string memory symbol){
        symbol = _symbol;
    }

    function decimals() public view returns (uint8 decimals){
        decimals = _decimals;
    }

    function totalSupply() public view returns (uint256 totalSupply){
        totalSupply = _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance){
        balance = _balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success){
        require(_balances[msg.sender] >= _value);
        _balances[msg.sender] -= _value;
        _balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        success = true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        require(_balances[_from] >= _value);
        require(_allowances[_from][msg.sender] >= _value);
        _balances[_from] -= _value;
        _allowances[_from][msg.sender] -= _value;
        _balances[_to] += _value;
        emit Transfer(_from, _to, _value);
        success = true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success){
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        success = true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining){
        remaining = _allowances[_owner][_spender];
    }
}",0.872333802,"contract RCCTToken is ERC20 {

  using SafeMath for uint256;



  mapping (address => uint256) private balances;

  mapping (address => mapping (address => uint256)) private allowed;



  uint256 private totalSupply_ = 1000000000 * (10 ** 18);

  string private constant name_ = 'RCCTToken';                                 

  string private constant symbol_ = 'RCCT';                                         

  uint8 private constant decimals_ = 18;                                          

  



  constructor () public {

    balances[msg.sender] = totalSupply_;

    emit Transfer(address(0), msg.sender, totalSupply_);

  }



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }

  

   

  function name() public view returns (string) {

    return name_;

  }



  

  function symbol() public view returns (string) {

    return symbol_;

  }



  

  function decimals() public view returns (uint8) {

    return decimals_;

  }



  

  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



  

  function allowance(

    address _owner,

    address _spender

   )

    public

    view

    returns (uint256)

  {

    return allowed[_owner][_spender];

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_value <= balances[msg.sender]);

    require(_to != address(0));



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function approve(address _spender, uint256 _value) public returns (bool) {

    require(_spender != address(0));

	

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  

  function transferFrom(

    address _from,

    address _to,

    uint256 _value

  )

    public

    returns (bool)

  {

    require(_value <= balances[_from]);

    require(_value <= allowed[_from][msg.sender]);

    require(_to != address(0));



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;

  }  

}",3,
"contract A{   

}",0.848219862,contract X {},1,
"contract B{

}",0.848219862,contract X {},1,
"contract TokenTimeSol{
    Token public token;
    address public beneficiary;
    uint public releaseTime;

    constructor(Token _token, address _beneficiary, uint _releaseTime) public{
        require(_releaseTime >= block.timestamp);
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function releaseTokens() public{
        require(block.timestamp >= releaseTime);
        uint _amount = token.balanceOf(address(this));
        require(_amount > 0);
        token.transfer(beneficiary, _amount);
    }
}",0.877310808,"contract TokenTimelock {
    
    ERC20Basic public token;

    
    address public beneficiary;

    
    uint256 public releaseTime;

    
    function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {
        require(_releaseTime > now);
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    
    function release() public {
        require(now >= releaseTime);

        uint256 amount = token.balanceOf(this);
        require(amount > 0);

        token.transfer(beneficiary, amount);
    }
}",1,
"contract LeonardianToken is MintableToken {

    uint256 public constant INITIAL_SUPPLY = 10000;


    string public constant name = ""Leonardian""; 
    string public constant symbol = ""LEON""; 
    uint8 public constant decimals = 18; 
}",0.826435007,"contract YATLINK is PausableToken
{
    string public constant name = ""YATLINK"";
    string public constant symbol = ""YLK"";
    uint8 public constant decimals = 18;
    
    
    uint256 public constant INITIAL_SUPPLY = 3e8 * 10**uint256(decimals);
}",1,
"contract Person
{
    Person[] public people;

    struct Person
    {
        bytes32 firstName;
        bytes32 lastName;

    }

    function addPerson(bytes32 _firstName, bytes32 _lastname) returns (bool success)
    {
        Person memory newPerson;

        newPerson.firstName = _firstName;
        newPerson.lastName = _lastname;


        people.push(newPerson);
        return true;
    }

    function getPeople() constant returns (bytes32[], bytes32[])
    {
        uint leng = people.length;

        bytes32[] memory first_names = new bytes32[](leng);
        bytes32[] memory last_names = new bytes32[](leng);


        for (uint i = 0; i < people.length; i++ )
        {
            Person memory currentPerson;
            currentPerson = people[i];
            first_names[i] = (currentPerson.firstName);
            last_names[i] = (currentPerson.lastName);


        }
        return (first_names,last_names);
    }
}",0.890518894,"contract People {
    
    Person[] public people;
    
    struct Person {
        bytes32 firstName;
        bytes32 lastName;
        uint age;
    }
    
    function addPerson(bytes32 _firstname, bytes32 _lastname, uint _age) returns (bool success){
        
        Person memory newPerson;
        newPerson.firstName = _firstname;
        newPerson.lastName = _lastname;
        newPerson.age = _age;
        
        people.push(newPerson);
        return true;
    }
    
    function getPeople() constant returns( bytes32[],bytes32[], uint[]) {
        
        bytes32[] firstNames;
        bytes32[] lastNames;
        uint[] ages;
        
        
        for( uint i = 0; i < people.length; i++){
            Person memory currentPerson;
            currentPerson = people[i];
            firstNames.push(currentPerson.firstName);
            lastNames.push(currentPerson.lastName);
            ages.push(currentPerson.age);
            return (firstNames,lastNames,ages);
        }
    }
}",2,
"contract SampleContract{

     address payable owner;

     constructor() public {
         owner = msg.sender;
     }

}",0.867572002,"contract TestContract {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
}",1,
"contract Owned {

address owner;

  constructor () public{
   owner=msg.sender;
  }
  modifier onlyOwner(){
 if(msg.sender==owner){
     _;
    }
  }
}",0.803146234,"contract Owned {

    
    address owner;

    
    function Owned() {
        owner = msg.sender;
    }

    

    
    modifier onlyowner() {
        if (msg.sender==owner) _;
    }
}",1,
"contract Ownable {
  address public owner;
  :
}",0.896875911,contract Owned { address public owner; },1,
"contract TestToken is ERC20Standard {
     constructor() public {
        totalSupply = 100000000;
        name = ""Test Token"";
        decimals = 6;
        symbol = ""TST"";
        version = ""1.0"";
        balances[msg.sender] = totalSupply;
    }
}",0.88114756,"contract CAPToken is ERC20Standard {
	constructor() public {
		totalSupply = 20000000000000;
		name = ""CAP coin"";
		decimals = 6;
		symbol = ""CAP"";
		version = ""1.0"";
		balances[msg.sender] = totalSupply;
	}
}",1,
"contract GustavoCoin is MintableToken {
  string public name = ""GUSTAVO COIN"";
  string public symbol = ""GUS"";
  uint256 public decimals = 18;
}",0.881259902,"contract AvaCoin is MintableToken {
  string public name = ""AVA COIN"";
  string public symbol = ""AVA"";
  uint256 public decimals = 18;
}",1,
"contract ExampleToken is ERC20Detailed {

  
  constructor(string memory _name, string memory _symbol, uint8 _decimals) 
  ERC20Detailed(_name, _symbol, _decimals)
  public {
  }

}",0.817103207,"contract ERC20DecimalsMock is ERC20 {
    constructor (string memory name, string memory symbol, uint8 decimals) public ERC20(name, symbol) {
        _setupDecimals(decimals);
    }
}",4,
"contract HelloWorld
{
string hello = ""Hello World"";
function sayHello() returns (string)
{
    return hello;
}
}",0.80797359,"contract HelloWorld{

    function Hello() public pure returns (string memory){

        return (""Hello World"");

    }

}",1,
"contract MyToken{
    string private _name = ""MyToken"";
    string private _symbol = ""MYT"";
    uint8 private _decimals = 6;
    uint256 private _totalSupply = 10 * (10 ** uint256(_decimals));
    mapping(address=>uint256) private _balances;
    mapping(address=>mapping(address=>uint256)) private _allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function MyToken(){
        _balances[msg.sender] = _totalSupply;
    }

    function name() public view returns (string name){
        name = _name;
    }

    function symbol() public view returns (string symbol){
        symbol = _symbol;
    }

    function decimals() public view returns (uint8 decimals){
        decimals = _decimals;
    }

    function totalSupply() public view returns (uint256 totalSupply){
        totalSupply = _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance){
        balance = _balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success){
        require(_balances[msg.sender] >= _value);
        _balances[msg.sender] -= _value;
        _balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        success = true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        require(_balances[_from] >= _value);
        require(_allowances[_from][msg.sender] >= _value);
        _balances[_from] -= _value;
        _allowances[_from][msg.sender] -= _value;
        _balances[_to] += _value;
        Transfer(_from, _to, _value);
        success = true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success){
        _allowances[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        success = true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining){
        remaining = _allowances[_owner][_spender];
    }
}",0.862284358,"contract TeddyToken is ERC20Interface {

	function () public payable {
		revert();
	}

	string public name;
	uint8 public decimals;
	string public symbol;
	string public version = &#39;H1.0&#39;;
	uint256 public _totalSupply;

	mapping (address => uint256) balances;
	mapping (address => mapping (address => uint256)) allowed;

	function TeddyToken() public {
		decimals = 8;
		_totalSupply = 21000000 * 10 ** uint256(decimals);
		balances[msg.sender] = _totalSupply;
		
		name = ""TeddyToken"";
		symbol = ""TED"";
	}

	function totalSupply() public view returns (uint256) {
		return _totalSupply;
	}

	function transfer(address _to, uint256 _value) public returns (bool success) {
		require(balances[msg.sender] >= _value && _value > 0);
		
			balances[msg.sender] -= _value;
			balances[_to] += _value;
			Transfer(msg.sender, _to, _value);
			return true;
		
	}

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
		require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
		
			balances[_to] += _value;
			balances[_from] -= _value;
			allowed[_from][msg.sender] -= _value;
			Transfer(_from, _to, _value);
			return true;
		
	}

	function balanceOf(address _owner) public view returns (uint256 balance) {
		return balances[_owner];
	}

	function approve(address _spender, uint256 _value) public returns (bool success) {
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
	}

	function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
	  return allowed[_owner][_spender];
	}

	function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);

		ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _value, this, _extraData);
		return true;
	}
}",3,
"contract HelloWorld{
    string public greeting;
    function HelloWorld(string _greeting){
        greeting = _greeting;
    }

    function setGreeting(string _greeting){
        greeting = _greeting;
    }

    function say() constant returns(string){
        return greeting;
    }
}",0.819419998,"contract Hello {

    string greeting;



     constructor() public {

        greeting = ""hello"";

     }



     function getGreeting() public view returns (string) {

        return greeting;

     }



     function setGreeting(string _greeting) public {

        greeting = _greeting;

     }

}",1,
"contract SimpleBank {
 uint256 storedData;
 function set(uint256 data) public{
  storedData = data;
 }
function get() public view returns (uint256){
    return storedData;
  }
}",0.829337333,"contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    }
}",1,
"contract ContractWallet {
    constructor() public{
    }
}",0.852544832,"contract BlankContract {
    constructor() public {}
}",1,
"contract PrivateSale is Crowdsale {


  constructor(address wallet,
              ERC20 token,
              uint256 rate,
              )
              public
              Crowdsale(rate, wallet, token) {
  }

}",0.846583731,"contract CoinSmarttICO is MintedCrowdsale {



	constructor(uint256 _rate, address _wallet, ERC20 _token)

	Crowdsale(_rate, _wallet, _token)

	{

	}









}",1,
"contract CA
{
    function FA() public
    {
        
    }
}",0.821520738,"contract test {
    function f() public { }
}",1,
"contract myContract is Crowdsale {
    function myContract 
    (
        uint256 _rate,
        address _wallet,
        MintableToken _token
    )
        public
        Crowdsale(_rate, _wallet, _token)
}",0.819574603,"contract CrowdsaleConstructor is MintedCrowdsale {
  constructor(uint256 _rate, address _wallet, MintableToken _token)
  public Crowdsale(_rate, _wallet, _token){}
}",2,
"contract B {
    function testb() public{ }
}",0.889804587,"contract test {
    function f() public { }
}",1,
"contract C{
    function testc() public{ }
}",0.889804587,"contract test {
    function f() public { }
}",1,
"contract MyContract {
  
  public uint256 totalSupply;
}",0.824711,"contract CoinI{
    
    uint256 public totalSupply ;
}",1,
"contract POPCoin is ERC20 {

  string public constant name = ""POPCoin"";
  string public constant symbol = ""POPC"";
  uint8 public constant decimals = 3;
  uint256 public actualNumber = 0;

  uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals));

  
  constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    actualNumber = INITIAL_SUPPLY / (10 ** uint256(decimals));
  }

}",0.804679387,"contract ShipCoin is StandardToken {

  string public constant name = ""ShipCoin""; 
  string public constant symbol = ""SHPC""; 
  uint8 public constant decimals = 18; 

  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));

  
  constructor () public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}",3,
"contract MyCrowdsale is Crowdsale {
  constructor(
      uint256 rate,    
      address payable wallet,
      MyToken token
  )
      Crowdsale(rate, wallet, token)
      public
  {

  }

}",0.873348152,"contract SampleCrowdsale is MintedCrowdsale {
  constructor(uint256 _rate, address _wallet, MintableToken _token) 
  public Crowdsale(_rate, _wallet, _token){}
}",1,
"contract myHWSC
{
    string private name;
    uint private age;

    function setName (string newName)
    {
        name=newName;
    }

    function getName() returns (string)
    {
        return name;
    }

}",0.829157871,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",1,
"contract C
{
  function () public payable
  {
    selfdestruct(msg.sender);
  }
}",0.857602615,"contract Nobody {

    function die() public {

        selfdestruct(msg.sender);

    }

}",1,
"contract ERC20
{

    
    event Transfer(address from, address to, uint256 value);
    event Approval(address tokenOwner, address spender, uint256 tokens);


    struct Allowance
    {
        uint256 amount;
        bool used;
    }
    mapping (address => uint256) balances;
    mapping (address => mapping(address => Allowance)) allowed;
    uint256 private TotalSupply;
    address internal owner;


    constructor() internal 
    {
        owner == msg.sender;
        TotalSupply = 200;
        balances[owner] = TotalSupply;
        emit Transfer(address(0), owner, TotalSupply);
    }


    function totalSupply() public view returns(uint)
    {
        return TotalSupply;
    }

    function balanceOf(address tokenOwner) public view returns(uint256)
    {
        return balances[tokenOwner];
    }

    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining)
    {
        return allowed[tokenOwner][spender].amount;
    }

    function approve(address spender, uint256 value) public returns(bool success)
    {
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        require(value == 0 ||
                ( allowed[msg.sender][spender].amount == 0 &&
                !allowed[msg.sender][spender].used ), ""Please set your value to 0 before you allow"");
        allowed[msg.sender][spender].used = false;
        allowed[msg.sender][spender].amount = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint256 value) public returns(bool success)
    {
        require(to != address(0));
        require(balances[msg.sender] >= value, ""Insufficient balance"");

        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function tranferFrom(address from, address to, uint256 value) public returns(bool success)
    {
        require(to != address(0));
        require(value <= allowed[msg.sender][from].amount);

        allowed[from][msg.sender].amount += value;
        balances[from] -= value;
        balances[to] += value;

        if(value > 0){
            allowed[from][msg.sender].used = true;
        }

        emit Transfer(from, to, value);
        return true;
    }
}",0.854103427,"contract StandardToken is ERC20 {

  using SafeMath for uint256;



  mapping(address => uint256) balances;

  mapping (address => mapping (address => uint256)) internal allowed;





  uint256 totalSupply_;



  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }

  

  function reduceTotalSupply(uint _amount) internal returns (bool) {

      require(totalSupply_ >= _amount);

      totalSupply_ = totalSupply_.sub(_amount);

      return true;

  }



  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);

    require(balances[_to] + _value >= balances[_to]);



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[_from]);

    require(_value <= allowed[_from][msg.sender]);

    require(balances[_to] + _value >= balances[_to]);



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;

  }



  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  function allowance(address _owner, address _spender) public view returns (uint256) {

    return allowed[_owner][_spender];

  }



  

  function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);



    

    

    

    if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }

    return true;

  }

}",3,
"contract MyCrowdsale is Crowdsale {
  constructor (
    uint256 rate,
    address payable wallet,
    IERC20 token
  ) 
  public
  Crowdsale(1000000000, wallet, token)
  {
  }
}",0.805965662,"contract CrowdsaleConstructor is MintedCrowdsale {
  constructor(uint256 _rate, address _wallet, MintableToken _token)
  public Crowdsale(_rate, _wallet, _token){}
}",1,
"contract HelloWorld {
    function get() pure public returns (string memory){
        return ""Hello Solidity"";
    }
}",0.896054637,"contract HelloWorld{

    function Hello() public pure returns (string memory){

        return (""Hello World"");

    }

}",1,
"contract TokenAbstractInterface {
    function mint(address _to, uint256 _amount) returns (bool);
    function finishMinting() returns (bool);
}",0.883436746,"contract IMintableToken {
    function mint(address _to, uint256 _amount) returns (bool);
    function finishMinting() returns (bool);
}",1,
"contract primerContrato {

uint storeddata;

function set(uint x) public{
    storeddata = x;
}

function get() public view returns (uint){
    return storeddata;
}

}",0.890821053,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",1,
"contract MyToken is StandardToken {
  string public name;                   
  uint8 public decimals;                
  string public symbol;  

  constructor() public {  
    StandardToken.balances[msg.sender] = 1000000000000000000;
    StandardToken.totalSupply_ = 1000000000000000000;                        
    name = ""My Token"";                             
    decimals = 18; 
    symbol = ""MY"";      
  }
}",0.837742435,"contract BitCloudToken is StandardToken { 



    string public name;                   

    uint8 public decimals;               

    string public symbol;             



    function BitCloudToken() {

        balances[msg.sender] = 1000000000000000000; 

        totalSupply = 1000000000000000000;         

        name = ""BitCloud Token"";                  

        decimals = 8;          

        symbol = ""BPRO"";            

    }

}",1,
"contract StepanToken2 is ERC20{
    using SafeMath for uint256;

    address public ownerFirst;
    address public ownerSecond;

    string public constant name = ""Stepan Token"";
    string public constant symbol = ""SPT"";
    uint8 public constant decimals = 8; 
    uint totalTokens = 100000000000000;


    
    mapping(address => uint) balances;

    
    mapping(address => mapping(address => uint)) allowed;


    function StepanToken2 (address _ownerFirst, address _ownerSecond){
       ownerFirst = _ownerFirst;
       ownerSecond = _ownerSecond;

       balances[ownerFirst] = SafeMath.div(totalTokens, 3);
       balances[ownerSecond] = SafeMath.sub(totalTokens, balances[ownerFirst]);
    }

    function totalSupply() constant returns (uint256 totalSupply){
         return totalTokens;
    }

    function balanceOf(address _owner) constant returns (uint256 balance){
         return balances[_owner];
    }


    function transfer(address _to, uint _value)  returns (bool success){
            require(balances[msg.sender] >= _value && _value > 0 && SafeMath.add(balances[_to], _value) > balances[_to]);
                balances[msg.sender] = SafeMath.sub(balances[msg.sender],_value);
                balances[_to] = SafeMath.add(balances[_to], _value);
                Transfer(msg.sender,  _to, _value);
                return true;     
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool success){
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && SafeMath.add(balances[_to], _value) > 0);
            balances[_from] = SafeMath.sub(balances[_from], _value);
            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
            balances[_to] = SafeMath.add(balances[_to], _value);
            Transfer(_from, _to, _value);
            return true;
    }


    function approve(address _spender, uint _value)  returns (bool success){
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender,  _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }

}",0.819704412,"contract ERC20Base is ERC20Interface {
    using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint public totalSupply_;
    address public owner;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;

    
    constructor(address _owner) public {
        symbol = ""IFF"";
        name = ""IFFtoken"";
        decimals = 18;
        totalSupply_ = 8 * (10 ** 8) * (10 ** 18);
        owner = _owner;
        balances[owner] = totalSupply_;
        emit Transfer(address(0), owner, totalSupply_);
    }

    
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    
    function burn(uint256 _value) public {
        address account = msg.sender;
        
        totalSupply_ = totalSupply_.sub(_value);
        balances[account] = balances[account].sub(_value);
        emit Transfer(account, address(0), _value);
    }
}",3,
"contract MyfirstContract{
    string private name;
    uint private age;

    function setName(string newName){
        name=newName;
    }
    fucntion getName() returns (string){
        return;

    }

}",0.821052771,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}",1,
"contract externalToken {
   function transfer(address receiver, uint amount){  }
   mapping (address => uint256) public balanceOf; }",0.859780721,"contract token {
  mapping (address => uint256) public balanceOf;
  function transfer(address _to, uint256 _value) external;
}",1,
"contract POPCoin is ERC20 {

  string public constant name = ""POPCoin"";
  string public constant symbol = ""POPC"";
  uint8 public constant decimals = 3;
  uint256 public actualNumber = 0;

  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));

  
  constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    actualNumber = INITIAL_SUPPLY / (10 ** uint256(decimals));
  }

}",0.806472666,"contract ShipCoin is StandardToken {

  string public constant name = ""ShipCoin""; 
  string public constant symbol = ""SHPC""; 
  uint8 public constant decimals = 18; 

  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));

  
  constructor () public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}",3,
"contract SampleCrowdsaleToken is MintableToken {

  string public constant name = ""Sample Crowdsale Token""; 
  string public constant symbol = ""SCT""; 
  uint8 public constant decimals = 18; 

}",0.856189362,"contract SajulmalaToken is CrowdsaleToken {

    string public constant name = ""Sajul Ma'la Token"";

    string public constant symbol = ""SJML"";

    uint32 public constant decimals = 18;

}",1,
"contract PopCoinCrowdsale is Crowdsale {

    constructor(uint256 rate, address wallet, IERC20 token) 
        Crowdsale(rate, wallet, token) public {

        }        
}",0.835433306,"contract CoinSmarttICO is MintedCrowdsale {



	constructor(uint256 _rate, address _wallet, ERC20 _token)

	Crowdsale(_rate, _wallet, _token)

	{

	}









}",1,
"contract FunnyToken is ERC20 {
    string public constant name = ""FunnyToken"";
    string public constant symbol = ""FYT"";
    uint8 public constant decimals = 18;
    uint256 private _totalSupply = 10000 * (10 ** uint256(decimals));
    address private owner;

    constructor() public {
        owner = msg.sender;
    }
}",0.81413396,"contract EMI is MintableToken {
  string public constant name = ""EMI Token"";
  string public constant symbol = ""EMI"";
  uint public constant decimals = 18;
    
  uint public totalSupply = 880000000 * (10 ** decimals);
    
  constructor () public {
    owner = msg.sender;
    mint(owner, totalSupply);
  }
}",3,
"contract Call_verify{

  function call_ecover(bytes32 r, bytes32 s, uint8 v, 
  bytes32 hash)external pure returns (address){
  bytes memory prefix = ""\x19Ethereum Signed 
  Message:\n32"";    
  bytes32 prefixedHash = 
  keccak256(abi.encodePacked(prefix,hash));  
  return ecrecover(prefixedHash, v, r, s);    
  } 
 
}",0.822606927,"contract Origin {

function getOriginAddress(bytes32 signedMessage, uint8 v, bytes32 r, bytes32 s) constant returns(address) {

  bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";

  bytes32 prefixedHash = keccak256(prefix, signedMessage);

  return ecrecover(prefixedHash, v, r, s);

}

}",1,
"contract DappTokenCrowdsale is Crowdsale {

  constructor(
    uint256 _rate,
    address _wallet,
    ERC20 _token
  )
    Crowdsale(_rate, _wallet, _token)
    public
  {
  }
}",0.843547861,"contract SampleCrowdsale is MintedCrowdsale {
  constructor(uint256 _rate, address _wallet, MintableToken _token) 
  public Crowdsale(_rate, _wallet, _token){}
}",1,
"contract Token is ERC20 {

        string public name = ""test"";
        string public symbol = ""TST"";
        uint8 public decimals = 18;
        uint256 public initSup = 1000;

        constructor() public {
            _totalSupply = initSup;
            balances[msg.sender] = initSup;
        }


    }",0.821134988,"contract PB is StandardToken {
    string public name = """"; 
    string public symbol = ""PB"";
    uint public decimals = 6;
    uint public totalSupply = 600000 * (10 ** decimals);
    
    constructor() public {
        balances[msg.sender] = totalSupply;
    }
}",3,
"contract Demo{
  string public name;

  function setName(string memory  _name) public{
    name= _name;
  }
  function getName()view public returns (string memory){
    return name;
  }
}",0.807664434,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",1,
"contract TestCoin is ERC20 {

}",0.878365067,contract TongCoin is ERC20{},1,
"contract Check {
 function multiply(uint a) public pure returns(uint){
    return a*a;
 }
}",0.849520703,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },2,
"contract MyTokenI {function transfer(address sender, address _to, uint256 _value) public; }",0.813967195,"contract TokenCHK {

  function transfer(address to, uint256 value) public returns (bool);

}",1,
"contract setXproxy is Enabled {
  function () payable public {
    address _impl =  ContractProvider(CMC).libraries('setXlib');
    require(_impl != address(0));
    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)
      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}",0.88101539,"contract Proxy {

    

    

    function implementation() public view returns (address);



    

    function() external payable {

        address _impl = implementation();

        

        assembly {

            let ptr := mload(0x40)

            calldatacopy(ptr, 0, calldatasize)

            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

            let size := returndatasize

            returndatacopy(ptr, 0, size)



            switch result

            case 0 { revert(ptr, size) }

            default { return(ptr, size) }

        }

    }

}",1,
"contract TokenInterface {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    ...
    
    
    function balanceOf(address _owner) constant returns (uint256 balance);
    ...
    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);

    
    
    
    
    
    function approve(address _spender, uint256 _amount) returns (bool success);

    
    
    
    
    function allowance(
        address _owner,
        address _spender
    ) constant returns (uint256 remaining);
    ...
}",0.814515233,"contract Token {

    function balanceOf(address owner) public view returns (uint256 balance);



    function transfer(address to, uint256 value) public returns (bool success);



    function transferFrom(address from, address to, uint256 value) public returns (bool success);



    function approve(address spender, uint256 value) public returns (bool success);



    function allowance(address owner, address spender) public view returns (uint256 remaining);

}",1,
"contract MyToken {
    
}",0.831818006,contract Token {},1,
"contract Safe {
    function isSafe() public pure returns (bool) { return true; }
}",0.803865457,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}",1,
"contract MyContract3 {
    function() external payable {revert();}
}",0.838863009,"contract Nonpayable {

  
  
  
  function () external payable {
    revert();
  }
}",1,
"contract Owned {

    address public owner;

    function Owned() public {
        owner = msg.sender;
    }

    function changeOwner(address newOwner) public returns(bool success) {
        require(msg.sender == owner);
        owner = newOwner;
        return true;
    }
}",0.872086091,"contract Owned {
  address public owner;
  function Owned() {
    owner = msg.sender;
  }
  function setOwner(address _owner) returns (bool success) {
    owner = _owner;
    return true;
  }
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }
}",1,
"contract A2 {
    function doIt() public {
    }
}",0.825039823,"contract test {
    function f() public { }
}",1,
"contract Ownable {

    address private _owner;

    modifier onlyOwner  {
        require(msg.sender == _owner);
        _;
    }

    constructor () internal {
        _owner = msg.sender;
    }

    function changeOwner(address newOwner) public onlyOwner {
        _owner = newOwner;
    }

    function owner() public view returns(address) {
        return _owner;
    }
}",0.895141225,"contract Ownable {



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function setOwner(address _owner) public onlyOwner {

        owner = _owner;

    }



    function getOwner() public view returns (address) {

        return owner;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



}",1,
"contract minimalToken {

     mapping (address => uint256) public balanceOf;

    function minimalToken(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
    }

    function transfer(address _to, uint256 _value) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
    }
}",0.807883554,"contract HackerSpaceBarneysToken {
    
    mapping (address => uint256) public balanceOf;

    
    function HackerSpaceBarneysToken() {
        balanceOf[msg.sender] = 1000000;              
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
    }
}",1,
"contract Owned {
  address public owner;
  function Owned(address _owner) public {
    owner = _owner;
  }
}",0.849184625,"contract Withdraw {

    address public owner;

    
    function Withdraw(address _owner) public {
        owner = _owner;
    }

}",1,
"contract Sorter {

    uint[] public data;
    function set(uint[] _data) { data = _data; }
    function sort() {
        if (data.length == 0)
            return;
        quickSort(data, 0, data.length - 1);
    }

    function quickSort(uint[] storage arr, uint left, uint right) internal {
        uint i = left;
        uint j = right;
        uint pivot = arr[left + (right - left) / 2];
        while (i <= j) {
            while (arr[i] < pivot) i++;
            while (pivot < arr[j]) j--;
            if (i <= j) {
                (arr[i], arr[j]) = (arr[j], arr[i]);
                i++;
                j--;
            }
        }
        if (left < j)
            quickSort(arr, left, j);

        if (i < right)
            quickSort(arr, i, right);
    }
}",0.861493678,"contract QuickSort {

    

    

    function sort(uint[] data) public constant returns(uint[]) {

       quickSort(data, int(0), int(data.length - 1));

       return data;

    }

    

    

    function quickSort(uint[] memory arr, int left, int right) internal{

        int i = left;

        int j = right;

        if(i==j) return;

        uint pivot = arr[uint(left + (right - left) / 2)];

        while (i <= j) {

            while (arr[uint(i)] < pivot) i++;

            while (pivot < arr[uint(j)]) j--;

            if (i <= j) {

                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);

                i++;

                j--;

            }

        }

        if (left < j)

            quickSort(arr, left, j);

        if (i < right)

            quickSort(arr, i, right);

    }

    

    

}",1,
contract C { function f() public { } },0.87807195,"contract test {
    function f() public { }
}",1,
"contract MyToken is ERC20 {
    string public name = ""MyToken"";
    string public symbol = ""MYT"";
    uint256 public decimals = 18;

    constructor(uint256 _intialSupply) public {
        _mint(msg.sender, _intialSupply);
    }
}",0.807372625,"contract BitherToken is ERC20 {



    string public name = ""BitherToken"";

    string public symbol = ""BTR"";

    uint256 public decimals = 18;



    constructor() public {

        _mint(msg.sender, 47000000 * (10 ** decimals));

    }

}",1,
"contract MyToken is StandardToken {
    string public name = ""MyTok"";
    string public symbol = ""MTK"";
    uint8 public decimals = 2;
    uint public INITIAL_SUPPLY = 5000;

    event Transfer(address s, address s2, uint amount);

    function MyToken () public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0,msg.sender,totalSupply_); 
    }
}",0.816932371,"contract MOONToken is StandardToken {



    string public constant name = ""Moon""; 

    string public constant symbol = ""MOON"";

    uint8 public constant decimals = 18; 



    uint256 public constant INITIAL_SUPPLY = 1e27;  



    

    constructor() public {

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;

        emit Transfer(address(0), msg.sender, totalSupply_);

    }

}",1,
"contract A {
    address public owner;
    function A() {
        owner = msg.sender;
    }
}",0.81091163,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}",1,
"contract B {
   function foo() public {
     
   }
}",0.8436032,"contract test {
    function f() public { }
}",1,
"contract Owned {

    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function changeOwner(address newOwner) public onlyOwner returns(bool success) {
        owner = newOwner;
        return true;
    }
}",0.87372252,"contract owned {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner can perform"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner  {
        owner = newOwner;
    }
}",1,
"contract GoodToken {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    function transfer(address _to, uint256 _value) public returns (bool) {
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}",0.823519571,"contract NotifyingToken is Token {
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);
    function transferAndCall(address _to, uint256 _value, bytes _data) public returns (bool);
}",1,
"contract BadToken {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    function transfer(address _to, uint256 _value) public {
        emit Transfer(msg.sender, _to, _value);
    }
}",0.856854306,"contract StandardToken is owned {

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}",1,
"contract ERC721Token is StandardERC721 {
    constructor(string _name, string _symbol)
    public
    StandardERC721(_name, _symbol)
    {
    }
}",0.829618734,"contract MintableERC721Token is ERC721Token {

  constructor(string name, string symbol)

    ERC721Token(name, symbol)

    public

  {



  }

}",1,
contract N {},0.848219862,contract X {},1,
"contract T {
  
}",0.848219862,contract X {},1,
"contract Storage {
  uint256 storedData;
  function set(uint256 data) public {
    storedData = data;
  }
  function get() public view returns (uint256) {
    return storedData;
  }
}",0.870011297,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",1,
"contract MyERC20Token {
    ...

    function transfer(address to, uint256 value) public returns (bool) {
        require(value % 100 == 0);
        ...
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value % 100 == 0);
        ...
    }

    ...
}",0.824766222,"contract Token
{
   mapping(address => mapping (address => uint256)) allowed;
   function transfer(address to, uint256 value) public returns (bool);
   function transferFrom(address from, address to, uint256 value) public returns (bool);
}",1,
"contract One {
    function callme() external {
        
    }
}",0.811145182,"contract PotLike {
    function cage() external;
}",1,
"contract ERC20Basic {
    event Transfer(address indexed from, address indexed to, uint tokens);
    mapping(address => uint256) balances;
    uint256 totalSupply_;
    using SafeMath for uint256;

   constructor(uint256 total) public {  
    totalSupply_ = total;
    balances[msg.sender] = totalSupply_;
    }  

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }
}",0.805571102,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0), 'Receiving address cannot be 0!');

    require(_value <= balances[msg.sender], 'Not enough token funds for sender!');



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}",3,
"contract ERC20 {
    function transfer(address _to, uint256 _value)public returns(bool);
    function balanceOf(address tokenOwner)public view returns(uint balance);
    function transferFrom(address from, address to, uint tokens)public returns(bool success);

}",0.862211407,"contract Token {
  function balanceOf(address owner) public view returns (uint256);
  function transfer(address to, uint256 tokens) public returns (bool);
  function transferFrom(address from, address to, uint256 tokens) public returns(bool);
}",1,
"contract HelloWorld {
    function sayIt() pure public returns(string) {
        return ""Hello world!"";
    }
}",0.899498325,"contract HelloWorld{
    function hello() pure public returns (string) {
        return ""Hello world."";
    }
}",1,
"contract ERC20Token {
    string  public name;
    string  public symbol;
    uint8   public decimals;
    uint256 public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {
        ...
    }

    function transfer(address _to, uint256 _value public returns (bool) {
        ...
    }

    function transferFrom(address _from, address _to, uint256 _value (bool) {
        ...
    }

    function approve(address _spender, uint256 _value) (bool) {
        ...
    }
}",0.862517518,"contract ERC20 {

    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

    function transfer(address to, uint256 value) public returns (bool success);

    function transferFrom(address from, address to, uint256 value) public returns (bool success);

    function approve(address spender, uint256 value) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",1,
contract Test { function Test() public { } },0.836984205,"contract test {
    function f() public { }
}",1,
"contract ERC20Token {
  function transferFrom(address from, address to, uint value);
}",0.861676694,"contract ERC721 {



  function transferFrom(address from, address to, uint value) public;

}",1,
"contract ERC20 {
  function totalSupply() public view returns (uint256);

}",0.875097426,"contract Nomin {

    function totalSupply() public view returns (uint);

}",1,
"contract Contract {
    string public name;

    function Contracts(string passedName) public {
        name = passedName;
    }

    function setName(string newName) public {
        name = newName;

    }

}",0.818082505,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}",1,
"contract SMTCrowdsale is Crowdsale {
  function SMTCrowdsale (uint256 _startTime, uint256 _endTime, utin256 _rate, address _wallet) Crowdsale (_startTime, _endTime, _rate, _wallet) {
  }

  function createTokenContract () internal returns (MintableToken) {
    return new SimpleCrowdsaleToken ();
  }
}",0.885226747,"contract FaceblockCrowdsale is Crowdsale {
    function FaceblockCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {

    }

    function createTokenContract() internal returns (MintableToken) {
        return new FaceblockToken();
    }
}",1,
"contract token {
     string public name; 
     string public symbol; 
     uint8 public decimals; 
     uint256 public totalSupply;

  
  mapping (address => uint256) public balanceOf;
  mapping (address => mapping (address => uint256)) public allowance;

  
  event Transfer(address indexed from, address indexed to, uint256 value);

  
  event Burn(address indexed from, uint256 value);

  
  function token(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
      ) {
      balanceOf[msg.sender] = initialSupply;              
      totalSupply = initialSupply;                        
      name = tokenName;                                   
      symbol = tokenSymbol;                               
      decimals = decimalUnits;                            
  }

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                            
      Transfer(_from, _to, _value);
  }

  
  
  
  function transfer(address _to, uint256 _value) {
      _transfer(msg.sender, _to, _value);
  }

  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      require (_value  _value);            
      balanceOf[msg.sender] -= _value;                      
      totalSupply -= _value;                                
      Burn(msg.sender, _value);
      return true;
  }

  function burnFrom(address _from, uint256 _value) returns (bool success) {
      require(balanceOf[_from] >= _value);                
      require(_value  bool) public frozenAccount;

  
  event FrozenFunds(address target, bool frozen);

  
  function MyAdvancedToken(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
  ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      require(!frozenAccount[_from]);                     
      require(!frozenAccount[_to]);                       
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                           
      Transfer(_from, _to, _value);
  }

  
  
  
  function mintToken(address target, uint256 mintedAmount) onlyOwner {
      balanceOf[target] += mintedAmount;
      totalSupply += mintedAmount;
      Transfer(0, this, mintedAmount);
      Transfer(this, target, mintedAmount);
  }

  
  
  
  function freezeAccount(address target, bool freeze) onlyOwner {
      frozenAccount[target] = freeze;
      FrozenFunds(target, freeze);
  }

  
  
  
  function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
      sellPrice = newSellPrice;
      buyPrice = newBuyPrice;
  }

  
  function buy() payable {
      uint amount = msg.value / buyPrice;               
      _transfer(this, msg.sender, amount);              
  }

  
  
  function sell(uint256 amount) {
      require(this.balance >= amount * sellPrice);      
      _transfer(msg.sender, this, amount);              
      msg.sender.transfer(amount * sellPrice);          
  }
}


",0.837451508,"contract TokenPrueba1 is owned
{    
    
   	string public name;

    string public symbol;

    
    uint8 public decimals = 8;

    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;

    
    mapping (address => mapping (address => uint256)) public allowance;

    
    mapping (address => bool) public frozenAccount;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(uint256 value);

    
    event FrozenFunds(address target, bool frozen);

        
    constructor(uint256 initialSupply,string tokenName,string tokenSymbol, address centralMinter) public     
    {        
    	
    	totalSupply = initialSupply * 10 ** uint256(decimals);

        
        balanceOf[msg.sender] = totalSupply;

        
        name = tokenName;

        
        symbol = tokenSymbol;

        
        if(centralMinter != 0 ) owner = centralMinter;

    }        
        
    function mintToken(address target, uint256 mintedAmount) onlyOwner public    
    {        
    	balanceOf[target] += mintedAmount;

        totalSupply += mintedAmount;

        emit Transfer(0, owner, mintedAmount);

        emit Transfer(owner, target, mintedAmount);

    }     
        
    function burn(uint256 _value) onlyOwner public returns (bool success)    
    {        
    
    	totalSupply -= _value;

        emit Burn(_value);

        return true;

    }    
        
    function freezeAccount(address target, bool freeze) onlyOwner public    
    {        
    	frozenAccount[target] = freeze;

        emit FrozenFunds(target, freeze);

    }    
        
    function _transfer(address _from, address _to, uint _value) internal {        
    
    	require(_to != 0x0);

        
        require(balanceOf[_from] >= _value);

        
        require(balanceOf[_to] + _value >= balanceOf[_to]);

        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        
        balanceOf[_from] -= _value;

        
        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }    
        
    function transfer(address _to, uint256 _value) public returns (bool success)    
    {        
    	require(!frozenAccount[msg.sender]);

        _transfer(msg.sender, _to, _value);

        return true;

    }    
        
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)    {        
    	require(_value <= allowance[_from][msg.sender]);

     
    	allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }    
        
    function approve(address _spender, uint256 _value) public returns (bool success)    {        
    	allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }    
        
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)    {        
    	tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value))        
        {            
        	spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }    
    }
}",3,
"contract Proxy {
  
  function () payable public {
    ProxyStorage proxystorage = ProxyStorage(0x1111222233334444555566667777888899990000);
    address _impl = proxystorage.lib();
    require(_impl != address(0));

    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)

      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}",0.822279783,"contract Proxy {
  
  function implementation() public view returns (address) {
    assert(false);
  }

  
  function () payable external {
    address _impl = implementation();
    require(_impl != address(0));

    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)

      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}",1,
"contract etherreceiver {

  function etherreceiver() external payable{      
  }
}",0.80117917,"contract ReceiverInterface {

    function receiveEther() external payable {}

}",1,
"contract MyERC20 {
...
}",0.831818006,contract ERC20 {},1,
"contract TheTokenContract {
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}",0.899663612,"contract ERC20Interface {

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    

}",1,
"contract Mortal {
    address public owner;

    function Mortal() {
        owner = msg.sender;
    }

    function kill() {
        selfdestruct(owner);
    }
",0.833232353,"contract mortal {
	address owner;

	function mortal() {
		owner = msg.sender;
	}

	function kill() internal {
		suicide(owner);
	}
}",1,
"contract B {
    function() public payable { }
}",0.82378941,"contract MultiSig
{
    function () public payable 
    {
       
    }
}",1,
contract TestContract { function f() public { } },0.822396604,"contract contractX 

{

  function exit() public;

}",1,
"contract ERC20Test
{

    mapping(address => uint256) balances;
    uint256 totalSupply_ = 100;
    event Transfer(address from, address to, uint256 value);

    function () payable 
    {
        return;
    }

    function transferETHToERC20(ERC20Test token, uint256 value) public
    {
        token.transfer(value); 
    }

    function transferTokentoERC20(ERC20Test token,address _to, uint amount) public 
    {
        token.transfer(_to,amount); 
    }


    function returnBalance() public view returns (uint256)
    {
        return this.balance;

    }

    function totalSupply() public view returns (uint256) 
    {
    return totalSupply_;
    }

    constructor ()
    {
        balances[msg.sender] = totalSupply_;
    }
    function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender]- _value;
    balances[_to] = balances[_to] + _value;
    emit Transfer(msg.sender, _to, _value);
    return true;
    }

    function balanceOf(address _owner) public view  returns (uint256)
    {
        return balances[_owner];
    }

}",0.803646065,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;

  using AddressUtils for address;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

  }

    

  

  function transfer_erc165(address _to, uint256 _value, bytes _data) public returns (bool) {

    transfer(_to, _value);

      

    if (!_to.isContract()) revert();

    

    ERC165ReceiverInterface i;

    if(!doesContractImplementInterface(_to, i.tokensReceived.selector)) revert(); 



    ERC165ReceiverInterface app= ERC165ReceiverInterface(_to);

    app.tokensReceived(msg.sender, _to, _value, _data);

    

    return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}",3,
"contract Percentage{

    uint256 public basePercent = 100;

    function onePercent(uint256 _value) public view returns (uint256)  {
        uint256 roundValue = SafeMath.ceil(_value, basePercent);
        uint256 onePercent = SafeMath.div(SafeMathh.mul(roundValue, basePercent), 10000);
        return onePercent;
    }
}",0.852337673,"contract Burner {
    using SafeMath for uint256;
    uint256 public basePercent = 100;
    function findOnePercent(uint256 value) public view returns (uint256)  {
        uint256 roundValue = value.ceil(basePercent);
        uint256 onePercent = roundValue.mul(basePercent).div(10000);
        return onePercent;
    }
}",1,
"contract Token{
    address public owner;

    function transferOwnerShip(address _newOwner) public {
        require (msg.sender == owner);
        owner = _newOwner;
    }

    function Token() public{
        owner = msg.sender;
    }
}",0.832558795,"contract owned {

    address public owner = msg.sender;



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        owner = newOwner;

    }

}",1,
"contract A {
    address internal owner;
    constructor() public payable {
        owner = msg.sender;
    }
}",0.887952064,"contract OwnableStorage {



  address public owner;



  constructor() internal {

    owner = msg.sender;

  }



}",1,
"contract A {
    address public owner = msg.sender;

    function bye() public{
        selfdestruct(owner);
    }
}",0.82567574,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",1,
"contract HelloWorld { 
     string public str = ""Hello World"";
}",0.899419095,"contract SkyNet{
    
    string public HelloWorld = ""Hello World"";
    

}",1,
"contract OraclizeI {
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);
    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);
}",0.848235729,"contract OraclizeI {
    address public cbAddress;
    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);
    function getPrice(string _datasource) returns (uint _dsprice);
    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);
    function useCoupon(string _coupon);
    function setProofType(byte _proofType);
    function setCustomGasPrice(uint _gasPrice);
}",1,
"contract TestLogic {
    ...
    address public owner;",0.811412854,"contract owned {

    address public owner;

}",1,
"contract token {  
    function (){  

        }   


}",0.804721148,"contract Eater{
	function(){
		
	}
}",1,
"contract ERC20 {
    function transferFrom(address, address, uint256);
}",0.817920294,"contract ERC20 {
  function transfer(address _to, uint256 _value);
}",1,
"contract owned {
...
",0.865603055,contract Owned {},1,
"contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  
  constructor() public {
    owner = msg.sender;
}
...",0.82083993,"contract Owned {

    address public owner;

    address public newOwner;



    event OwnershipTransferred(address indexed _from, address indexed _to);



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

}",1,
"contract FunnyToken is ERC20 {
    string public constant name = ""FunnyToken"";
    string public constant symbol = ""FYT"";
    uint8 public constant decimals = 18;
    uint256 public _totalSupply = 10000;
    address private owner;

    constructor() public {
        owner = msg.sender;
    }
}",0.814616405,"contract DACToken is ERC20Burnable {



    string public constant name = 'DAC';

    string public constant symbol = 'DAC';

    uint8 public constant decimals = 18;

    uint256 private _totalSupply = 10e9 * 1e18 ; 



    constructor() ERC20Burnable() public {

        _mint(msg.sender, _totalSupply);

    }



}",1,
contract Crowdsale is Ownable {},0.805509463,contract Pausable is Ownable {},1,
"contract MyToken is IERC20 {
  ...",0.835578502,contract NewToken is ERC20 {},1,
"contract TokenRecipient {
    function tokenFallback(address _from, uint _amount, bytes _data) public;
}",0.886479519,"contract ERC677Receiver {

    function tokenFallback(address _from, uint _amount, bytes _data) public;

}",1,
"contract metaCoin { 
    function sendToken(address receiver, uint amount) returns(bool successful){
        
    }
}",0.81403603,"contract token {function transfer(address receiver, uint amount) returns (bool success);}",1,
"contract ERC223Interface {
    function transfer(address to, uint value) public;
}",0.843583116,"contract ContractConn {

    function transfer(address _to, uint _value) public;

}",1,
"contract ContractName {
    constructor(...) public {
        ...
    }
    ...
}",0.849992291,"contract BlankContract {
    constructor() public {}
}",1,
"contract Example{
   function() public payable {
       
   }
}",0.832485855,"contract MultiSig
{
    function () public payable 
    {
       
    }
}",1,
contract AInterface{},0.801921158,contract AssetInterface{},1,
"contract IERC20Extented is IERC20 {
    function decimals() public view returns (uint8);
}",0.866842321,"contract IERC20WithDecimals is ERC20 {
    function decimals() public view returns (uint8);
}",1,
"contract ExtraBalToken {
    ...
    mapping (address => uint256) public balanceOf;
    ...
}",0.888764562,contract DiscountToken { mapping (address => uint256) public balanceOf; },1,
"contract ERC20 {
      function balanceOf(address _owner) constant returns (uint balance);
}",0.854891814,"contract OldContract{
  function balanceOf(address _owner) view returns (uint balance) {}
}",1,
"contract MyContract {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function() external payable {
        owner.transfer(msg.value); 
    }

}",0.836940485,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}",1,
"contract Token {
    uint public totalSupply;",0.807747933,"contract CoinI{
    
    uint256 public totalSupply ;
}",1,
"contract A {
    uint public value = 1;
}",0.827606489,"contract Empty {
 uint public value = 5;
}",1,
"contract LeonardianCrowdsale is Crowdsale {

    ERC20 _token = new LeonardianToken();

    function LeonardianCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public 
    Crowdsale(_rate, _wallet, _token)
    
    {

    }
}",0.80293191,"contract HKYCrowdsale is CappedCrowdsale {

  function HKYCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public
    CappedCrowdsale(36000 ether)
    Crowdsale(_startTime, _endTime, _rate, _wallet, _token)
  {
  }
}",1,
"contract YourContract is ERC223Receiver
{
    function tokenFallback(address _from, uint _value, bytes _data)
    {
        
    }
}",0.886361401,"contract ERC223ReceivingContract { 

    function tokenFallback(address _from, uint _value, bytes _data) external;
}",1,
"contract V2 is V1 {
  
}",0.817952526,"contract NGNT is V1 {

}",1,
"contract tokenERC20 {

    string public name;
    string public symbol;
    uint public decimals = 18;
    uint256 public totalSupply;

    mapping(address=>uint256) balanceof;
    mapping(address=> mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn( address indexed from, uint256 value);



}",0.805659603,"contract ERC20Basic {
  string public name;
  string public symbol;
  uint256 public totalSupply;
  uint8 public constant decimals = 18;

  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}",1,
"contract Second {
    string public constant name = ""Foo"";
    string public constant symbol = ""Bar"";
    uint8 public constant decimals = 18;

    constructor () public {
        
    }
}",0.828802626,"contract Force is  Token {

    string public constant name = ""Force"";
    string public constant symbol = ""FORCE"";
    uint8 public constant decimals = 18;

}",1,
"contract ERC20 {
  function allowance(address owner, address spender) constant returns (uint);
  function transferFrom(address from, address to, uint value);
  function approve(address spender, uint value);
  event Approval(address indexed owner, address indexed spender, uint value);
}",0.82538643,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}",1,
"contract Test {

    function getTime() public view returns (uint){
       return now;
   }

}",0.819144597,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}",1,
